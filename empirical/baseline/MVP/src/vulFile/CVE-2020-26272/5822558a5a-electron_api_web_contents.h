




















































namespace extensions {
class ScriptExecutor;
}


namespace blink {
struct DeviceEmulationParams;
}

namespace gin_helper {
class Dictionary;
}

namespace network {
class ResourceRequestBody;
}

namespace gin {
class Arguments;
}

namespace electron {

class ElectronBrowserContext;
class ElectronJavaScriptDialogManager;
class InspectableWebContents;
class WebContentsZoomController;
class WebViewGuestDelegate;
class FrameSubscriber;
class WebDialogHelper;
class NativeWindow;


class OffScreenRenderWidgetHostView;
class OffScreenWebContentsView;


namespace api {


class WebContents : public gin::Wrappable<WebContents>, public gin_helper::EventEmitterMixin<WebContents>, public gin_helper::Constructible<WebContents>, public gin_helper::CleanedUpAtExit, public content::WebContentsObserver, public content::WebContentsDelegate, public InspectableWebContentsDelegate, public InspectableWebContentsViewDelegate, public mojom::ElectronBrowser {







 public:
  enum class Type {
    kBackgroundPage,   kBrowserWindow, kBrowserView, kRemote, kWebView, kOffScreen, };






  
  static gin::Handle<WebContents> New(v8::Isolate* isolate, const gin_helper::Dictionary& options);

  
  
  
  static gin::Handle<WebContents> CreateAndTake( v8::Isolate* isolate, std::unique_ptr<content::WebContents> web_contents, Type type);



  
  
  static WebContents* From(content::WebContents* web_contents);
  static WebContents* FromID(int32_t id);

  
  
  
  
  static gin::Handle<WebContents> FromOrCreate( v8::Isolate* isolate, content::WebContents* web_contents);


  
  static gin::WrapperInfo kWrapperInfo;
  static v8::Local<v8::ObjectTemplate> FillObjectTemplate( v8::Isolate*, v8::Local<v8::ObjectTemplate>);

  const char* GetTypeName() override;

  base::WeakPtr<WebContents> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }

  
  
  
  
  
  
  
  
  
  
  
  
  
  void DestroyWebContents(bool async);

  bool GetBackgroundThrottling() const;
  void SetBackgroundThrottling(bool allowed);
  int GetProcessID() const;
  base::ProcessId GetOSProcessID() const;
  Type GetType() const;
  bool Equal(const WebContents* web_contents) const;
  void LoadURL(const GURL& url, const gin_helper::Dictionary& options);
  void DownloadURL(const GURL& url);
  GURL GetURL() const;
  base::string16 GetTitle() const;
  bool IsLoading() const;
  bool IsLoadingMainFrame() const;
  bool IsWaitingForResponse() const;
  void Stop();
  void ReloadIgnoringCache();
  void GoBack();
  void GoForward();
  void GoToOffset(int offset);
  const std::string GetWebRTCIPHandlingPolicy() const;
  void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);
  bool IsCrashed() const;
  void ForcefullyCrashRenderer();
  void SetUserAgent(const std::string& user_agent);
  std::string GetUserAgent();
  void InsertCSS(const std::string& css);
  v8::Local<v8::Promise> SavePage(const base::FilePath& full_file_path, const content::SavePageType& save_type);
  void OpenDevTools(gin::Arguments* args);
  void CloseDevTools();
  bool IsDevToolsOpened();
  bool IsDevToolsFocused();
  void ToggleDevTools();
  void EnableDeviceEmulation(const blink::DeviceEmulationParams& params);
  void DisableDeviceEmulation();
  void InspectElement(int x, int y);
  void InspectSharedWorker();
  void InspectSharedWorkerById(const std::string& workerId);
  std::vector<scoped_refptr<content::DevToolsAgentHost>> GetAllSharedWorkers();
  void InspectServiceWorker();
  void SetIgnoreMenuShortcuts(bool ignore);
  void SetAudioMuted(bool muted);
  bool IsAudioMuted();
  bool IsCurrentlyAudible();
  void SetEmbedder(const WebContents* embedder);
  void SetDevToolsWebContents(const WebContents* devtools);
  v8::Local<v8::Value> GetNativeView(v8::Isolate* isolate) const;
  void IncrementCapturerCount(gin::Arguments* args);
  void DecrementCapturerCount(gin::Arguments* args);
  bool IsBeingCaptured();


  void OnGetDefaultPrinter(base::Value print_settings, printing::CompletionCallback print_callback, base::string16 device_name, bool silent, base::string16 default_printer);



  void Print(gin::Arguments* args);
  
  v8::Local<v8::Promise> PrintToPDF(base::DictionaryValue settings);


  void SetNextChildWebPreferences(const gin_helper::Dictionary);

  
  void AddWorkSpace(gin::Arguments* args, const base::FilePath& path);
  void RemoveWorkSpace(gin::Arguments* args, const base::FilePath& path);

  
  void Undo();
  void Redo();
  void Cut();
  void Copy();
  void Paste();
  void PasteAndMatchStyle();
  void Delete();
  void SelectAll();
  void Unselect();
  void Replace(const base::string16& word);
  void ReplaceMisspelling(const base::string16& word);
  uint32_t FindInPage(gin::Arguments* args);
  void StopFindInPage(content::StopFindAction action);
  void ShowDefinitionForSelection();
  void CopyImageAt(int x, int y);

  
  void Focus();
  bool IsFocused() const;

  
  bool SendIPCMessage(bool internal, const std::string& channel, v8::Local<v8::Value> args);


  bool SendIPCMessageWithSender(bool internal, const std::string& channel, blink::CloneableMessage args, int32_t sender_id = 0);



  bool SendIPCMessageToFrame(bool internal, int32_t frame_id, const std::string& channel, v8::Local<v8::Value> args);



  void PostMessage(const std::string& channel, v8::Local<v8::Value> message, base::Optional<v8::Local<v8::Value>> transfer);


  
  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);

  
  void BeginFrameSubscription(gin::Arguments* args);
  void EndFrameSubscription();

  
  void StartDrag(const gin_helper::Dictionary& item, gin::Arguments* args);

  
  
  v8::Local<v8::Promise> CapturePage(gin::Arguments* args);

  
  bool IsGuest() const;
  void AttachToIframe(content::WebContents* embedder_web_contents, int embedder_frame_id);
  void DetachFromOuterFrame();

  
  bool IsOffScreen() const;

  void OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap);
  void StartPainting();
  void StopPainting();
  bool IsPainting() const;
  void SetFrameRate(int frame_rate);
  int GetFrameRate() const;

  void Invalidate();
  gfx::Size GetSizeForNewRenderView(content::WebContents*) override;

  
  void SetZoomLevel(double level);
  double GetZoomLevel() const;
  void SetZoomFactor(gin_helper::ErrorThrower thrower, double factor);
  double GetZoomFactor() const;

  
  void OnEnterFullscreenModeForTab( content::RenderFrameHost* requesting_frame, const blink::mojom::FullscreenOptions& options, bool allowed);



  
  void OnCreateWindow(const GURL& target_url, const content::Referrer& referrer, const std::string& frame_name, WindowOpenDisposition disposition, const std::string& features, const scoped_refptr<network::ResourceRequestBody>& body);





  
  std::vector<base::FilePath> GetPreloadPaths() const;

  
  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate) const;
  v8::Local<v8::Value> GetLastWebPreferences(v8::Isolate* isolate) const;

  
  v8::Local<v8::Value> GetOwnerBrowserWindow(v8::Isolate* isolate) const;

  
  
  void GrantOriginAccess(const GURL& url);

  
  void NotifyUserActivation();

  v8::Local<v8::Promise> TakeHeapSnapshot(v8::Isolate* isolate, const base::FilePath& file_path);

  
  int32_t ID() const { return id_; }
  v8::Local<v8::Value> Session(v8::Isolate* isolate);
  content::WebContents* HostWebContents() const;
  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);
  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);
  bool WasInitiallyShown();
  content::RenderFrameHost* MainFrame();

  WebContentsZoomController* GetZoomController() { return zoom_controller_; }

  void AddObserver(ExtendedWebContentsObserver* obs) {
    observers_.AddObserver(obs);
  }
  void RemoveObserver(ExtendedWebContentsObserver* obs) {
    
    if (observers_.might_have_observers())
      observers_.RemoveObserver(obs);
  }

  bool EmitNavigationEvent(const std::string& event, content::NavigationHandle* navigation_handle);

  
  template <typename... Args> bool EmitWithSender(base::StringPiece name, content::RenderFrameHost* sender, electron::mojom::ElectronBrowser::InvokeCallback callback, Args&&... args) {



    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
    v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Object> wrapper;
    if (!GetWrapper(isolate).ToLocal(&wrapper))
      return false;
    v8::Local<v8::Object> event = gin_helper::internal::CreateNativeEvent( isolate, wrapper, sender, std::move(callback));
    return EmitCustomEvent(name, event, std::forward<Args>(args)...);
  }

  void MarkDestroyed();

  WebContents* embedder() { return embedder_; }


  extensions::ScriptExecutor* script_executor() {
    return script_executor_.get();
  }


  
  void SetOwnerWindow(NativeWindow* owner_window);
  void SetOwnerWindow(content::WebContents* web_contents, NativeWindow* owner_window);

  
  content::WebContents* GetWebContents() const;

  
  content::WebContents* GetDevToolsWebContents() const;

  InspectableWebContents* inspectable_web_contents() const {
    return inspectable_web_contents_.get();
  }

  NativeWindow* owner_window() const { return owner_window_.get(); }

  bool is_html_fullscreen() const { return html_fullscreen_; }

  void set_fullscreen_frame(content::RenderFrameHost* rfh) {
    fullscreen_frame_ = rfh;
  }

 private:
  
  WebContents(v8::Isolate* isolate, content::WebContents* web_contents);
  
  WebContents(v8::Isolate* isolate, std::unique_ptr<content::WebContents> web_contents, Type type);

  
  WebContents(v8::Isolate* isolate, const gin_helper::Dictionary& options);
  ~WebContents() override;

  
  
  void InitWithWebContents(content::WebContents* web_contents, ElectronBrowserContext* browser_context, bool is_guest);


  void InitWithSessionAndOptions( v8::Isolate* isolate, std::unique_ptr<content::WebContents> web_contents, gin::Handle<class Session> session, const gin_helper::Dictionary& options);





  void InitWithExtensionView(v8::Isolate* isolate, content::WebContents* web_contents, extensions::ViewType view_type);



  
  bool DidAddMessageToConsole(content::WebContents* source, blink::mojom::ConsoleMessageLevel level, const base::string16& message, int32_t line_no, const base::string16& source_id) override;



  bool IsWebContentsCreationOverridden( content::SiteInstance* source_site_instance, content::mojom::WindowContainerType window_container_type, const GURL& opener_url, const content::mojom::CreateNewWindowParams& params) override;



  content::WebContents* CreateCustomWebContents( content::RenderFrameHost* opener, content::SiteInstance* source_site_instance, bool is_new_browsing_instance, const GURL& opener_url, const std::string& frame_name, const GURL& target_url, const std::string& partition_id, content::SessionStorageNamespace* session_storage_namespace) override;







  void WebContentsCreatedWithFullParams( content::WebContents* source_contents, int opener_render_process_id, int opener_render_frame_id, const content::mojom::CreateNewWindowParams& params, content::WebContents* new_contents) override;




  void AddNewContents(content::WebContents* source, std::unique_ptr<content::WebContents> new_contents, const GURL& target_url, WindowOpenDisposition disposition, const gfx::Rect& initial_rect, bool user_gesture, bool* was_blocked) override;





  content::WebContents* OpenURLFromTab( content::WebContents* source, const content::OpenURLParams& params) override;

  void BeforeUnloadFired(content::WebContents* tab, bool proceed, bool* proceed_to_fire_unload) override;

  void SetContentsBounds(content::WebContents* source, const gfx::Rect& pos) override;
  void CloseContents(content::WebContents* source) override;
  void ActivateContents(content::WebContents* contents) override;
  void UpdateTargetURL(content::WebContents* source, const GURL& url) override;
  bool HandleKeyboardEvent( content::WebContents* source, const content::NativeWebKeyboardEvent& event) override;

  bool PlatformHandleKeyboardEvent( content::WebContents* source, const content::NativeWebKeyboardEvent& event);

  content::KeyboardEventProcessingResult PreHandleKeyboardEvent( content::WebContents* source, const content::NativeWebKeyboardEvent& event) override;

  void ContentsZoomChange(bool zoom_in) override;
  void EnterFullscreenModeForTab( content::RenderFrameHost* requesting_frame, const blink::mojom::FullscreenOptions& options) override;

  void ExitFullscreenModeForTab(content::WebContents* source) override;
  void RendererUnresponsive( content::WebContents* source, content::RenderWidgetHost* render_widget_host, base::RepeatingClosure hang_monitor_restarter) override;


  void RendererResponsive( content::WebContents* source, content::RenderWidgetHost* render_widget_host) override;

  bool HandleContextMenu(content::RenderFrameHost* render_frame_host, const content::ContextMenuParams& params) override;
  bool OnGoToEntryOffset(int offset) override;
  void FindReply(content::WebContents* web_contents, int request_id, int number_of_matches, const gfx::Rect& selection_rect, int active_match_ordinal, bool final_update) override;




  bool CheckMediaAccessPermission(content::RenderFrameHost* render_frame_host, const GURL& security_origin, blink::mojom::MediaStreamType type) override;

  void RequestMediaAccessPermission( content::WebContents* web_contents, const content::MediaStreamRequest& request, content::MediaResponseCallback callback) override;


  void RequestToLockMouse(content::WebContents* web_contents, bool user_gesture, bool last_unlocked_by_target) override;

  content::JavaScriptDialogManager* GetJavaScriptDialogManager( content::WebContents* source) override;
  void OnAudioStateChanged(bool audible) override;
  void UpdatePreferredSize(content::WebContents* web_contents, const gfx::Size& pref_size) override;

  
  void BeforeUnloadFired(bool proceed, const base::TimeTicks& proceed_time) override;
  void RenderViewCreated(content::RenderViewHost* render_view_host) override;
  void RenderFrameCreated(content::RenderFrameHost* render_frame_host) override;
  void RenderViewDeleted(content::RenderViewHost*) override;
  void RenderProcessGone(base::TerminationStatus status) override;
  void RenderFrameDeleted(content::RenderFrameHost* render_frame_host) override;
  void DOMContentLoaded(content::RenderFrameHost* render_frame_host) override;
  void DidFinishLoad(content::RenderFrameHost* render_frame_host, const GURL& validated_url) override;
  void DidFailLoad(content::RenderFrameHost* render_frame_host, const GURL& validated_url, int error_code) override;

  void DidStartLoading() override;
  void DidStopLoading() override;
  void DidStartNavigation( content::NavigationHandle* navigation_handle) override;
  void DidRedirectNavigation( content::NavigationHandle* navigation_handle) override;
  void DidFinishNavigation( content::NavigationHandle* navigation_handle) override;
  bool OnMessageReceived(const IPC::Message& message) override;
  void WebContentsDestroyed() override;
  void NavigationEntryCommitted( const content::LoadCommittedDetails& load_details) override;
  void TitleWasSet(content::NavigationEntry* entry) override;
  void DidUpdateFaviconURL( content::RenderFrameHost* render_frame_host, const std::vector<blink::mojom::FaviconURLPtr>& urls) override;

  void PluginCrashed(const base::FilePath& plugin_path, base::ProcessId plugin_pid) override;
  void MediaStartedPlaying(const MediaPlayerInfo& video_type, const content::MediaPlayerId& id) override;
  void MediaStoppedPlaying( const MediaPlayerInfo& video_type, const content::MediaPlayerId& id, content::WebContentsObserver::MediaStoppedReason reason) override;


  void DidChangeThemeColor() override;
  void OnInterfaceRequestFromFrame( content::RenderFrameHost* render_frame_host, const std::string& interface_name, mojo::ScopedMessagePipeHandle* interface_pipe) override;


  void OnCursorChanged(const content::WebCursor& cursor) override;
  void DidAcquireFullscreen(content::RenderFrameHost* rfh) override;

  
  void DevToolsReloadPage() override;

  
  void DevToolsFocused() override;
  void DevToolsOpened() override;
  void DevToolsClosed() override;
  void DevToolsResized() override;

  ElectronBrowserContext* GetBrowserContext() const;

  
  
  void BindElectronBrowser( mojo::PendingReceiver<mojom::ElectronBrowser> receiver, content::RenderFrameHost* render_frame_host);

  void OnElectronBrowserConnectionError();


  OffScreenWebContentsView* GetOffScreenWebContentsView() const;
  OffScreenRenderWidgetHostView* GetOffScreenRenderWidgetHostView() const;


  
  void Message(bool internal, const std::string& channel, blink::CloneableMessage arguments) override;

  void Invoke(bool internal, const std::string& channel, blink::CloneableMessage arguments, InvokeCallback callback) override;


  void OnFirstNonEmptyLayout() override;
  void ReceivePostMessage(const std::string& channel, blink::TransferableMessage message) override;
  void MessageSync(bool internal, const std::string& channel, blink::CloneableMessage arguments, MessageSyncCallback callback) override;


  void MessageTo(bool internal, int32_t web_contents_id, const std::string& channel, blink::CloneableMessage arguments) override;


  void MessageHost(const std::string& channel, blink::CloneableMessage arguments) override;
  void UpdateDraggableRegions( std::vector<mojom::DraggableRegionPtr> regions) override;
  void SetTemporaryZoomLevel(double level) override;
  void DoGetZoomLevel(DoGetZoomLevelCallback callback) override;

  
  
  void OnGetZoomLevel(content::RenderFrameHost* frame_host, IPC::Message* reply_msg);

  void InitZoomController(content::WebContents* web_contents, const gin_helper::Dictionary& options);

  
  bool CanOverscrollContent() override;
  content::ColorChooser* OpenColorChooser( content::WebContents* web_contents, SkColor color, const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions)


      override;
  void RunFileChooser(content::RenderFrameHost* render_frame_host, scoped_refptr<content::FileSelectListener> listener, const blink::mojom::FileChooserParams& params) override;

  void EnumerateDirectory(content::WebContents* web_contents, scoped_refptr<content::FileSelectListener> listener, const base::FilePath& path) override;

  bool IsFullscreenForTabOrPending(const content::WebContents* source) override;
  blink::SecurityStyle GetSecurityStyle( content::WebContents* web_contents, content::SecurityStyleExplanations* explanations) override;

  bool TakeFocus(content::WebContents* source, bool reverse) override;
  content::PictureInPictureResult EnterPictureInPicture( content::WebContents* web_contents, const viz::SurfaceId&, const gfx::Size& natural_size) override;


  void ExitPictureInPicture() override;

  
  void DevToolsSaveToFile(const std::string& url, const std::string& content, bool save_as) override;

  void DevToolsAppendToFile(const std::string& url, const std::string& content) override;
  void DevToolsRequestFileSystems() override;
  void DevToolsAddFileSystem(const std::string& type, const base::FilePath& file_system_path) override;
  void DevToolsRemoveFileSystem( const base::FilePath& file_system_path) override;
  void DevToolsIndexPath(int request_id, const std::string& file_system_path, const std::string& excluded_folders_message) override;

  void DevToolsStopIndexing(int request_id) override;
  void DevToolsSearchInPath(int request_id, const std::string& file_system_path, const std::string& query) override;


  

  gfx::ImageSkia GetDevToolsWindowIcon() override;


  void GetDevToolsWindowWMClass(std::string* name, std::string* class_name) override;


  
  void ResetManagedWebContents(bool async);

  
  void OnDevToolsIndexingWorkCalculated(int request_id, const std::string& file_system_path, int total_work);

  void OnDevToolsIndexingWorked(int request_id, const std::string& file_system_path, int worked);

  void OnDevToolsIndexingDone(int request_id, const std::string& file_system_path);
  void OnDevToolsSearchCompleted(int request_id, const std::string& file_system_path, const std::vector<std::string>& file_paths);


  
  void SetHtmlApiFullscreen(bool enter_fullscreen);

  v8::Global<v8::Value> session_;
  v8::Global<v8::Value> devtools_web_contents_;
  v8::Global<v8::Value> debugger_;

  std::unique_ptr<ElectronJavaScriptDialogManager> dialog_manager_;
  std::unique_ptr<WebViewGuestDelegate> guest_delegate_;
  std::unique_ptr<FrameSubscriber> frame_subscriber_;


  std::unique_ptr<extensions::ScriptExecutor> script_executor_;


  
  WebContents* embedder_ = nullptr;

  
  WebContentsZoomController* zoom_controller_ = nullptr;

  
  Type type_ = Type::kBrowserWindow;

  int32_t id_;

  
  uint32_t find_in_page_request_id_ = 0;

  
  bool background_throttling_ = true;

  
  bool enable_devtools_ = true;

  
  base::ObserverList<ExtendedWebContentsObserver> observers_;

  v8::Global<v8::Value> pending_child_web_preferences_;

  bool initially_shown_ = true;

  
  base::WeakPtr<NativeWindow> owner_window_;

  bool offscreen_ = false;

  
  bool html_fullscreen_ = false;

  
  bool native_fullscreen_ = false;

  
  std::unique_ptr<WebDialogHelper> web_dialog_helper_;

  scoped_refptr<DevToolsFileSystemIndexer> devtools_file_system_indexer_;

  ElectronBrowserContext* browser_context_;

  
  
  
  
  std::unique_ptr<InspectableWebContents> inspectable_web_contents_;

  
  typedef std::map<std::string, base::FilePath> PathsMap;
  PathsMap saved_files_;

  
  typedef std::
      map<int, scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>> DevToolsIndexingJobsMap;
  DevToolsIndexingJobsMap devtools_indexing_jobs_;

  scoped_refptr<base::SequencedTaskRunner> file_task_runner_;

  
  content::RenderFrameHost* fullscreen_frame_ = nullptr;

  service_manager::BinderRegistryWithArgs<content::RenderFrameHost*> registry_;
  mojo::ReceiverSet<mojom::ElectronBrowser, content::RenderFrameHost*> receivers_;
  std::map<content::RenderFrameHost*, std::vector<mojo::ReceiverId>> frame_to_receivers_map_;

  base::WeakPtrFactory<WebContents> weak_factory_;

  DISALLOW_COPY_AND_ASSIGN(WebContents);
};

}  

}  


