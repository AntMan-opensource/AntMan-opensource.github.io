


























































































static char *url_canonize(char *d, char const *s, size_t n, unsigned syn33, char const allowed[]);

static char *url_canonize2(char *d, char const *s, size_t n, unsigned syn33, unsigned m32, unsigned m64, unsigned m96);

static int url_tel_cmp_numbers(char const *A, char const *B);


int url_reserved_p(char const *s)
{
  if (s)
    while (*s) {
      unsigned char u = *s++;

      if (IS_EXCLUDED(u, RMASK1, RMASK2, RMASK3))
	return 1;
    }

  return 0;
}


isize_t url_esclen(char const *s, char const reserved[])
{
  size_t n;
  unsigned mask32, mask64, mask96;

  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);

  for (n = 0; s && *s; n++) {
    unsigned char u = *s++;

    if (IS_EXCLUDED(u, mask32, mask64, mask96))
      n += 2;
  }

  return (isize_t)n;
}


char *url_escape(char *d, char const *s, char const reserved[])
{
  char *retval = d;
  unsigned mask32, mask64, mask96;

  MASKS_WITH_RESERVED(reserved, mask32, mask64, mask96);

  while (s && *s) {
    unsigned char u = *s++;

    if (IS_EXCLUDED(u, mask32, mask64, mask96)) {


      *d++ = '%';
      *d++ = URL_HEXIFY(u >> 4);
      *d++ = URL_HEXIFY(u & 15);


    }
    else {
      *d++ = u;
    }
  }

  *d = '\0';

  return retval;
}



size_t url_unescape_to(char *d, char const *s, size_t n)
{
  size_t i = 0, j = 0;

  if (s == NULL)
    return 0;

  i = j = strncspn(s, n, "%");

  if (d && d != s)
    memmove(d, s, i);

  for (; i < n;) {
    char c = s[i++];

    if (c == '\0')
      break;

    if (c == '%' && i + 1 < n && IS_HEX(s[i]) && IS_HEX(s[i + 1])) {

      c = (UNHEX(s[i]) << 4) | UNHEX(s[i + 1]);

      i += 2;
    }

    if (d)
      d[j] = c;
    j++;
  }

  return j;
}


char *url_unescape(char *d, char const *s)
{
  size_t n = url_unescape_to(d, s, SIZE_MAX);
  if (d)
    d[n] = '\0';
  return d;
}


static char *url_canonize(char *d, char const *s, size_t n, unsigned syn33, char const allowed[])


{
  unsigned mask32 = 0xbe19003f, mask64 = 0x8000001e, mask96 = 0x8000001d;

  MASKS_WITH_ALLOWED(allowed, mask32, mask64, mask96);

  return url_canonize2(d, s, n, syn33, mask32, mask64, mask96);
}





static char *url_canonize2(char *d, char const * const s, size_t n, unsigned syn33, unsigned m32, unsigned m64, unsigned m96)


{
  size_t i = 0;

  if (d == s)
    for (;s[i] && i < n; d++, i++)
      if (s[i] == '%')
	break;

  for (;s[i] && i < n; d++, i++) {
    unsigned char c = s[i], h1, h2;

    if (c != '%') {
      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))
	return NULL;
      *d = c;
      continue;
    }

    if (i >= strlen(s) - 1) return NULL;
    h1 = s[i + 1], h2 = s[i + 2];

    if (!IS_HEX(h1) || !IS_HEX(h2)) {
      *d = '\0';
      return NULL;
    }


    c = (UNHEX(h1) << 4) | UNHEX(h2);

    if (!IS_EXCLUDED(c, m32, m64, m96)) {
      
      *d = c, i += 2;
      continue;
    }

    
    if (h1 >= 'a' )
      h1 = h1 - 'a' + 'A';
    if (h2 >= 'a' )
      h2 = h2 - 'a' + 'A';

    d[0] = '%', d[1] = h1, d[2] = h2;

    d +=2, i += 2;

  }

  *d = '\0';

  return d;
}



static char *url_canonize3(char *d, char const * const s, size_t n, unsigned m32, unsigned m64, unsigned m96)

{
  size_t i = 0;

  if (d == s)
    for (;s[i] && i < n; d++, i++)
      if (s[i] == '%')
	break;

  for (;s[i] && i < n; d++, i++) {
    unsigned char c = s[i], h1, h2;

    if (c != '%') {
      *d = c;
      continue;
    }

    h1 = s[i + 1], h2 = s[i + 2];

    if (!IS_HEX(h1) || !IS_HEX(h2)) {
      *d = '\0';
      return NULL;
    }


    c = (UNHEX(h1) << 4) | UNHEX(h2);

    if (!IS_EXCLUDED(c, m32, m64, m96)) {
      *d = c, i += 2;
      continue;
    }

    
    if (h1 >= 'a' )
      h1 = h1 - 'a' + 'A';
    if (h2 >= 'a' )
      h2 = h2 - 'a' + 'A';

    d[0] = '%', d[1] = h1, d[2] = h2;

    d +=2, i += 2;

  }

  *d = '\0';

  return d;
}



char const* url_scheme(enum url_type_e url_type)
{
  switch (url_type) {
  case url_any:    return "*";
  case url_sip:    return "sip";
  case url_sips:   return "sips";
  case url_tel:    return "tel";
  case url_fax:    return "fax";
  case url_modem:  return "modem";
  case url_http:   return "http";
  case url_https:  return "https";
  case url_ftp:    return "ftp";
  case url_file:   return "file";
  case url_rtsp:   return "rtsp";
  case url_rtspu:  return "rtspu";
  case url_mailto: return "mailto";
  case url_im:     return "im";
  case url_pres:   return "pres";
  case url_cid:    return "cid";
  case url_msrp:   return "msrp";
  case url_msrps:  return "msrps";
  case url_wv:     return "wv";
  default:
    assert(url_type == url_unknown);
    return NULL;
  }
}

su_inline int url_type_is_opaque(enum url_type_e url_type)
{
  return url_type == url_invalid || url_type == url_tel || url_type == url_modem || url_type == url_fax || url_type == url_cid;




}


void url_init(url_t *url, enum url_type_e type)
{
  memset(url, 0, sizeof(*url));
  url->url_type = type;
  if (type > url_unknown) {
    char const *scheme = url_scheme((enum url_type_e)url->url_type);
    if (scheme)
      url->url_scheme = scheme;
  }
}


su_inline enum url_type_e url_get_type(char const *scheme, size_t len)
{


  switch (scheme[0]) {
  case '*': if (strcmp(scheme, "*") == 0) return url_any;
  case 'c': case 'C':
    test_scheme(cid); break;
  case 'f': case 'F':
    test_scheme(ftp); test_scheme(file); test_scheme(fax); break;
  case 'h': case 'H':
    test_scheme(http); test_scheme(https); break;
  case 'i': case 'I':
    test_scheme(im); break;
  case 'm': case 'M':
    test_scheme(mailto); test_scheme(modem);
    test_scheme(msrp); test_scheme(msrps); break;
  case 'p': case 'P':
    test_scheme(pres); break;
  case 'r': case 'R':
    test_scheme(rtsp); test_scheme(rtspu); break;
  case 's': case 'S':
    test_scheme(sip); test_scheme(sips); break;
  case 't': case 'T':
    test_scheme(tel); break;
  case 'w': case 'W':
    test_scheme(wv); break;


  default: break;
  }



  if (len != span_unreserved(scheme))
    return url_invalid;
  else return url_unknown;
}


static int _url_d(url_t *url, char *s)
{
  size_t n, p;
  char rest_c, *host, *user;
  int have_authority = 1;

  memset(url, 0, sizeof(*url));

  if (strcmp(s, "*") == 0) {
    url->url_type = url_any;
    url->url_scheme = "*";
    return 0;
  }

  n = strcspn(s, ":/?#");

  if (n && s[n] == ':') {
    char *scheme;
    url->url_scheme = scheme = s; s[n] = '\0'; s = s + n + 1;

    if (!(scheme = url_canonize(scheme, scheme, SIZE_MAX, 0, "+")))
      return -1;

    n = scheme - url->url_scheme;

    url->url_type = url_get_type(url->url_scheme, n);

    have_authority = !url_type_is_opaque((enum url_type_e)url->url_type);
  }
  else {
    url->url_type = url_unknown;
  }

  user = NULL, host = s;

  if (url->url_type == url_sip || url->url_type == url_sips) {
    
    
    
    n = strcspn(s, "@/;?#");
    p = strcspn(s + n, "@");
    if (s[n + p] == '@') {
      n += p;
      user = s;
      host = s + n + 1;
    }

    n += strcspn(s + n, "/;?#");
  }
  else if (have_authority) {
    if (url->url_type == url_wv) {
      
      n = strcspn(s, "@#?;");
      if (s[n] == '@') {
	user = s;
	host = s + n + 1;
	n += strcspn(s + n, ";?#");
      }
    }
    else if (host[0] == '/' && host[1] != '/') {
      
      url->url_root = '/';	
      host = NULL, n = 0;
    }
    else {
      if (host[0] == '/' && host[1] == '/') {
	
	host += 2; s += 2, url->url_root = '/';
	n = strcspn(s, "/?#@[]");
      }
      else n = strcspn(s, "@;/?#");

      if (s[n] == '@')
	user = host, host = user + n + 1;

      n += strcspn(s + n, ";/?#");	
    }
  }
  else  {
    user = host, host = NULL;
    if (url->url_type != url_invalid)
      n = strcspn(s, "/;?#");	
    else n = strcspn(s, "#");
  }

  rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;

  if (user) {
    if (host) host[-1] = '\0';
    url->url_user = user;
    if (url->url_type != url_unknown) {
      n = strcspn(user, ":");
      if (user[n]) {
	user[n] = '\0';
	url->url_password = user + n + 1;
      }
    }
  }

  if (host) {
    url->url_host = host;
    
    if (host[0] == '[') {
      n = strcspn(host, "]");
      if (host[n] && (host[n + 1] == '\0' || host[n + 1] == ':'))
	n++;
      else n = 0;
    }
    else {
      n = strcspn(host, ":");
    }

    
    if (n == 0) switch (url->url_type) {
    case url_sip:
    case url_sips:
    case url_im:
    case url_pres:
      return -1;
    default:
      break;
    }

    if (host[n] == ':') {
      char *port = host + n + 1;
      url->url_port = port;
      switch (url->url_type) {
      case url_any:
      case url_sip:
      case url_sips:
      case url_http:
      case url_https:
      case url_ftp:
      case url_file:
      case url_rtsp:
      case url_rtspu:
	if (!url_canonize2(port, port, SIZE_MAX, 0, RESERVED_MASK))
	  return -1;

	
	
	while (*port >= '0' && *port <= '9')
	  port++;

	if (port != url->url_port) {
	  if (port[0] != '\0')
	    return -1;
	}
	else if (port[0] == '\0')
	  ;
	else if (port[0] == '*' && port[1] == '\0')
	  ;
	else return -1;
      }
      host[n] = 0;
    }
  }

  if (rest_c == '/') {
    url->url_path = s; n = strcspn(s, "?#");
    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;
  }
  if (rest_c == ';') {
    url->url_params = s; n = strcspn(s, "?#");
    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;
  }
  if (rest_c == '?') {
    url->url_headers = s; n = strcspn(s, "#");
    rest_c = s[n]; s[n] = 0; s = rest_c ? s + n + 1 : NULL;
  }
  if (rest_c == '#') {
    url->url_fragment = s;
    rest_c = '\0';
  }
  if (rest_c)
    return -1;

  return 0;
}




int url_d(url_t *url, char *s)
{
  if (url == NULL || _url_d(url, s) < 0)
    return -1;

  
  
  if (url->url_type == url_sip || url->url_type == url_sips) {


    s = (char *)url->url_user;
    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_USER_UNRESERVED))
      return -1;

    
    

    s = (char *)url->url_password;
    if (s && !url_canonize(s, s, SIZE_MAX, 0, SIP_PASS_UNRESERVED))
      return -1;

  }
  else {


    s = (char *)url->url_user;
    if (s && !url_canonize(s, s, SIZE_MAX, 0, USER_UNRESERVED))
      return -1;


    s = (char *)url->url_password;
    if (s && !url_canonize(s, s, SIZE_MAX, 0, PASS_UNRESERVED))
      return -1;
  }

  s = (char *)url->url_host;
  if (s && !url_canonize2(s, s, SIZE_MAX, 0, RESERVED_MASK))
    return -1;

  
  s = (char *)url->url_path;
  if (s && !url_canonize(s, s, SIZE_MAX,   SYN33('/') | SYN33(';') | SYN33('=') | SYN33('@') | SYN33(','),  ":&+$"))





    return -1;

  s = (char *)url->url_params;
  if (s && !url_canonize(s, s, SIZE_MAX,   SYN33(';') | SYN33('=') | SYN33('@') | SYN33(','),  "/:&+$"))




    return -1;

  
  s = (char *)url->url_headers;
  if (s && !url_canonize3(s, s, SIZE_MAX, RESERVED_MASK))
    return -1;

  
  s = (char *)url->url_fragment;
  if (s && !url_canonize2(s, s, SIZE_MAX, 0, URIC_MASK))
    return -1;

  return 0;
}


issize_t url_e(char buffer[], isize_t n, url_t const *url)
{
  size_t i;
  char *b = buffer;
  size_t m = n;
  int do_copy = n > 0;

  if (url == NULL)
    return -1;

  if (URL_STRING_P(url)) {
    char const *u = (char *)url;
    i = strlen(u);
    if (!buffer)
      return i;

    if (i >= n) {
      memcpy(buffer, u, n - 2);
      buffer[n - 1] = '\0';
    } else {
      memcpy(buffer, u, i + 1);
    }

    return i;
  }


  if (url->url_type == url_any) {
    if (b && m > 0) {
      if (m > 1) strcpy(b, "*"); else b[0] = '\0';
    }
    return 1;
  }

  if (url->url_scheme && url->url_scheme[0]) {
    i = strlen(url->url_scheme) + 1;
    if (do_copy && (do_copy = i <= n)) {
      memcpy(b, url->url_scheme, i - 1);
      b[i - 1] = ':';
    }
    b += i; n -= i;
  }

  if (url->url_root && (url->url_host || url->url_user)) {
    if (do_copy && (do_copy = 2 <= n))
      memcpy(b, "//", 2);
    b += 2; n -= 2;
  }

  if (url->url_user) {
    i = strlen(url->url_user);
    if (do_copy && (do_copy = i <= n))
      memcpy(b, url->url_user, i);
    b += i; n -= i;

    if (url->url_password) {
      if (do_copy && (do_copy = 1 <= n))
	*b = ':';
      b++; n--;
      i = strlen(url->url_password);
      if (do_copy && (do_copy = i <= n))
	memcpy(b, url->url_password, i);
      b += i; n -= i;
    }

    if (url->url_host) {
      if (do_copy && (do_copy = 1 <= n))
	*b = '@';
      b++; n--;
    }
  }

  if (url->url_host) {
    i = strlen(url->url_host);
    if (do_copy && (do_copy = i <= n))
      memcpy(b, url->url_host, i);
    b += i; n -= i;

    if (url->url_port) {
      i = strlen(url->url_port) + 1;
      if (do_copy && (do_copy = i <= n)) {
	b[0] = ':';
	memcpy(b + 1, url->url_port, i - 1);
      }
      b += i; n -= i;
    }
  }

  if (url->url_path) {
    if (url->url_root) {
      if (do_copy && (do_copy = 1 <= n))
	b[0] = '/';
      b++, n--;
    }
    i = strlen(url->url_path);
    if (do_copy && (do_copy = i < n))
      memcpy(b, url->url_path, i);
    b += i; n -= i;
  }

  {
    static char const sep[] = ";?#";
    char const *pp[3];
    size_t j;

    pp[0] = url->url_params;
    pp[1] = url->url_headers;
    pp[2] = url->url_fragment;

    for (j = 0; j < 3; j++) {
      char const *p = pp[j];
      if (!p) continue;
      i = strlen(p) + 1;
      if (do_copy && (do_copy = i <= n)) {
	*b = sep[j];
	memcpy(b + 1, p, i - 1);
      }
      b += i; n -= i;
    }
  }

  if (do_copy && (do_copy = 1 <= n))
    *b = '\0';
  else if (buffer && m > 0)
    buffer[m - 1] = '\0';

  assert((size_t)(b - buffer) == (size_t)(m - n));

  
  return b - buffer;
}



isize_t url_len(url_t const * url)
{
  size_t rv = 0;

  if (url->url_scheme) rv += strlen(url->url_scheme) + 1; 
  if (url->url_user) {
    rv += strlen(url->url_user);
    if (url->url_password)
      rv += strlen(url->url_password) + 1;   
    rv += url->url_host != NULL;  
  }
  if (url->url_host) rv += strlen(url->url_host);
  if (url->url_port) rv += strlen(url->url_port) + 1;	        
  if (url->url_path) rv += strlen(url->url_path) + 1;     
  if (url->url_params) rv += strlen(url->url_params) + 1; 
  if (url->url_headers) rv += strlen(url->url_headers) + 1;	
  if (url->url_fragment) rv += strlen(url->url_fragment) + 1;   

  return rv;
}




isize_t url_xtra(url_t const *url)
{
  size_t xtra;

  if (URL_STRING_P(url)) {
    xtra = strlen((char const *)url) + 1;
  }
  else {
    size_t len_scheme, len_user, len_password, len_host, len_port, len_path, len_params, len_headers, len_fragment;


    len_scheme = (url->url_type <= url_unknown && url->url_scheme) ? strlen(url->url_scheme) + 1 : 0;
    len_user = url->url_user ? strlen(url->url_user) + 1 : 0;
    len_password = url->url_password ? strlen(url->url_password) + 1 : 0;
    len_host = url->url_host ? strlen(url->url_host) + 1 : 0;
    len_port = url->url_port ? strlen(url->url_port) + 1 : 0;
    len_path = url->url_path ? strlen(url->url_path) + 1 : 0;
    len_params = url->url_params ? strlen(url->url_params) + 1 : 0;
    len_headers = url->url_headers ? strlen(url->url_headers) + 1 : 0;
    len_fragment = url->url_fragment ? strlen(url->url_fragment) + 1 : 0;

    xtra = len_scheme + len_user + len_password + len_host + len_port + len_path + len_params + len_headers + len_fragment;

  }

  return xtra;
}

su_inline char *copy(char *buf, char *end, char const *src)
{

  char *b = memccpy(buf, src, '\0', end - buf);
  if (b)
    return b;
  else return end + strlen(src + (end - buf)) + 1;

  for (; buf < end && (*buf = *src); buf++, src++)
    ;

  if (buf >= end)
    while (*src++)
      buf++;

  return buf + 1;

}


issize_t url_dup(char *buf, isize_t bufsize, url_t *dst, url_t const *src)
{
  if (!src && !dst)
    return -1;
  else if (URL_STRING_P(src)) {
    size_t n = strlen((char *)src) + 1;
    if (n > bufsize || dst == NULL)
      return n;

    strcpy(buf, (char *)src);
    memset(dst, 0, sizeof(*dst));
    if (url_d(dst, buf) < 0)
      return -1;

    return n;
  }
  else {
    char *b = buf;
    char *end = b + bufsize;
    char const **dstp;
    char const * const *srcp;
    url_t dst0[1];

    if (dst == NULL)
      dst = dst0;

    memset(dst, 0, sizeof(*dst));

    if (!src)
      return 0;

    memset(dst->url_pad, 0, sizeof dst->url_pad);
    dst->url_type = src->url_type;
    dst->url_root = src->url_root;

    dstp = &dst->url_scheme;
    srcp = &src->url_scheme;

    if (dst->url_type > url_unknown)
      *dstp = url_scheme((enum url_type_e)dst->url_type);

    if (*dstp != NULL)
      dstp++, srcp++;	

    if (dst != dst0 && buf != NULL && bufsize != 0)
      for (; srcp <= &src->url_fragment; srcp++, dstp++)
	if (*srcp) {
	  char *next = copy(b, end, *srcp);

	  if (next > end)
	    break;

	  *dstp = b, b = next;
	}

    for (; srcp <= &src->url_fragment; srcp++)
      if (*srcp) {
	b += strlen(*srcp) + 1;
      }

    return b - buf;
  }
}




url_t *url_hdup(su_home_t *home, url_t const *src)
{
  if (src) {
    size_t len = sizeof(*src) + url_xtra(src);
    url_t *dst = su_alloc(home, len);
    if (dst) {
      ssize_t actual;
      actual = url_dup((char *)(dst + 1), len - sizeof(*src), dst, src);
      if (actual < 0)
	su_free(home, dst), dst = NULL;
      else assert(len == sizeof(*src) + actual);
    }
    return dst;
  }
  else return NULL;
}



url_t *url_make(su_home_t *h, char const *str)
{
  return url_hdup(h, URL_STRING_MAKE(str)->us_url);
}


url_t *url_format(su_home_t *h, char const *fmt, ...)
{
  url_t *url;
  char *us;
  va_list ap;

  va_start(ap, fmt);

  us = su_vsprintf(h, fmt, ap);

  va_end(ap);

  if (us == NULL)
    return NULL;

  url = url_hdup(h, URL_STRING_MAKE(us)->us_url);

  su_free(h, us);

  return url;
}



char *url_as_string(su_home_t *home, url_t const *url)
{
  if (url) {
    int len = url_e(NULL, 0, url);
    char *b = su_alloc(home, len + 1);
    url_e(b, len + 1, url);
    return b;
  } else {
    return NULL;
  }
}







isize_t url_param(char const *params, char const *tag, char value[], isize_t vlen)

{
  size_t n, tlen, flen;
  char *p;

  if (!params)
    return 0;

  tlen = strlen(tag);
  if (tlen && tag[tlen - 1] == '=')
    tlen--;

  for (p = (char *)params; *p; p += n + 1) {
    n = strcspn(p, ";");
    if (n < tlen) {
      if (p[n]) continue; else break;
    }
    if (strncasecmp(p, tag, tlen) == 0) {
      if (n == tlen) {
	if (vlen > 0)
	  value[0] = '\0';
	return 1;
      }
      if (p[tlen] != '=')
	continue;
      flen = n - tlen - 1;
      if (flen >= (size_t)vlen)
	return flen + 1;
      memcpy(value, p + tlen + 1, flen);
      value[flen] = '\0';
      return flen + 1;
    }
    if (!p[n])
      break;
  }

  return 0;
}


isize_t url_have_param(char const *params, char const *tag)
{
  return url_param(params, tag, NULL, 0);
}


int url_has_param(url_t const *url, char const *tag)
{
  return url && url->url_params && url_param(url->url_params, tag, NULL, 0);
}


int url_param_add(su_home_t *h, url_t *url, char const *param)
{
  
  size_t n = url->url_params ? strlen(url->url_params) + 1: 0;
  size_t nn = strlen(param) + 1;
  char *s = su_alloc(h, n + nn);

  if (!s)
    return -1;

  if (url->url_params)
    strcpy(s, url->url_params)[n - 1] = ';';
  strcpy(s + n, param);
  url->url_params = s;

  return 0;
}


char *url_strip_param_string(char *params, char const *name)
{
  if (params && name) {
    size_t i, n = strlen(name), remove, rest;

    for (i = 0; params[i];) {
      if (strncasecmp(params + i, name, n) || (params[i + n] != '=' && params[i + n] != ';' && params[i + n])) {
	i = i + strcspn(params + i, ";");
	if (!params[i++])
	  break;
	continue;
      }
      remove = n + strcspn(params + i + n, ";");
      if (params[i + remove] == ';')
	remove++;

      if (i == 0) {
	params += remove;
	continue;
      }

      rest = strlen(params + i + remove);
      if (!rest) {
	if (i == 0)
	  return NULL;		
	params[i - 1] = '\0';
	break;
      }
      memmove(params + i, params + i + remove, rest + 1);
    }

    if (!params[0])
      return NULL;
  }

  return params;
}

int url_string_p(url_string_t const *url)
{
  return URL_STRING_P(url);
}

int url_is_string(url_string_t const *url)
{
  return URL_IS_STRING(url);
}


static int url_strip_transport2(url_t *url, int modify)
{
  char *p, *d;
  size_t n;
  int semi;

  if (url->url_type != url_sip && url->url_type != url_sips)
    return 0;

  if (url->url_port != NULL) {
    if (!modify)
      return 1;
    url->url_port = NULL;
  }

  if (!url->url_params)
    return 0;

  for (d = p = (char *)url->url_params; *p; p += n + semi) {
    n = strcspn(p, ";");
    semi = (p[n] != '\0');

    if (modify && n == 0)
      continue;
    if (URL_PARAM_MATCH(p, "method"))
      continue;
    if (URL_PARAM_MATCH(p, "maddr"))
      continue;
    if (URL_PARAM_MATCH(p, "ttl"))
      continue;
    if (URL_PARAM_MATCH(p, "transport"))
      continue;

    if (p != d) {
      if (d != url->url_params)
	d++;
      if (p != d) {
	if (!modify)
	  return 1;
	memmove(d, p, n + 1);
      }
    }
    d += n;
  }

  if (d == p)
    return 0;
  else if (d + 1 == p)		
    return 0;
  else if (!modify)
    return 1;

  if (d != url->url_params)
    *d = '\0';
  else url->url_params = NULL;

  return 1;
}


int url_strip_transport(url_t *url)
{
  return url_strip_transport2(url, 1);
}


int url_have_transport(url_t const *url)
{
  return url_strip_transport2((url_t *)url, 0);
}


int url_cmp(url_t const *a, url_t const *b)
{
  int rv;
  int url_type;

  if ((a && a->url_type == url_any) || (b && b->url_type == url_any))
    return 0;

  if (!a || !b)
    return (a != NULL) - (b != NULL);

  if ((rv = a->url_type - b->url_type)) {

    
    enum url_type_e a_type = a->url_type;
    enum url_type_e b_type = b->url_type;

    if (a_type == url_im || a_type == url_pres)
      a_type = url_sip;

    if (b_type == url_im || b_type == url_pres)
      b_type = url_sip;

    if (a_type != b_type)

      return rv;
  }

  url_type = a->url_type;	

  if (url_type <= url_unknown && ((rv = !a->url_scheme - !b->url_scheme) || (a->url_scheme && b->url_scheme && (rv = strcasecmp(a->url_scheme, b->url_scheme)))))


    return rv;

  if ((rv = host_cmp(a->url_host, b->url_host)))
    return rv;

  if (a->url_port != b->url_port) {
    char const *a_port;
    char const *b_port;

    if (url_type != url_sip && url_type != url_sips)
      a_port = b_port = url_port_default((enum url_type_e)url_type);
    else if (host_is_ip_address(a->url_host))
      a_port = b_port = url_port_default((enum url_type_e)url_type);
    else a_port = b_port = "";

    if (a->url_port) a_port = a->url_port;
    if (b->url_port) b_port = b->url_port;

    if ((rv = strcmp(a_port, b_port)))
      return rv;
  }

  if (a->url_user != b->url_user) {
    if (a->url_user == NULL) return -1;
    if (b->url_user == NULL) return +1;
    switch (url_type) {
    case url_tel: case url_modem: case url_fax:
      rv = url_tel_cmp_numbers(a->url_user, b->url_user);
      break;
    default:
      rv = strcmp(a->url_user, b->url_user);
      break;
    }
    if (rv)
      return rv;
  }


  if (a->url_path != b->url_path) {
    if (a->url_path == NULL) return -1;
    if (b->url_path == NULL) return +1;
    if ((rv = strcmp(a->url_path, b->url_path)))
      return rv;
  }


  return 0;
}

static int url_tel_cmp_numbers(char const *A, char const *B)
{
  short a, b;
  int rv;

  while (*A && *B) {
    #define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))
    
    do {
      a = *A++;
      if (a == '%' && IS_HEX(A[0]) && IS_HEX(A[1]))
	a = (UNHEX(A[0]) << 4) | UNHEX(A[1]), A +=2;
    } while (a == ' ' || a == '-' || a == '.' || a == '(' || a == ')');

    if (isupper(a))
      a = tolower(a);

    do {
      b = *B++;
      if (b == '%' && IS_HEX(B[0]) && IS_HEX(B[1]))
	b = (UNHEX(B[0]) << 4) | UNHEX(B[1]), B +=2;
    } while (b == ' ' || b == '-' || b == '.' || b == '(' || b == ')');

    if (isupper(b))
      b = tolower(b);

    if ((rv = a - b))
      return rv;
  }

  return (int)*A - (int)*B;
}


int url_cmp_all(url_t const *a, url_t const *b)
{
  int rv, url_type;

  if (!a || !b)
    return (a != NULL) - (b != NULL);

  if ((rv = a->url_type - b->url_type))
    return rv;

  url_type = a->url_type;	

  if (url_type <= url_unknown && ((rv = !a->url_scheme - !b->url_scheme) || (a->url_scheme && b->url_scheme && (rv = strcasecmp(a->url_scheme, b->url_scheme)))))


    return rv;

  if ((rv = a->url_root - b->url_root))
    return rv;

  if ((rv = host_cmp(a->url_host, b->url_host)))
    return rv;

  if (a->url_port != b->url_port) {
    char const *a_port;
    char const *b_port;

    if (url_type != url_sip && url_type != url_sips)
      a_port = b_port = url_port_default((enum url_type_e)url_type);
    else if (host_is_ip_address(a->url_host))
      a_port = b_port = url_port_default((enum url_type_e)url_type);
    else a_port = b_port = "";

    if (a->url_port) a_port = a->url_port;
    if (b->url_port) b_port = b->url_port;

    if ((rv = strcmp(a_port, b_port)))
      return rv;
  }

  if (a->url_user != b->url_user) {
    if (a->url_user == NULL) return -1;
    if (b->url_user == NULL) return +1;

    switch (url_type) {
    case url_tel: case url_modem: case url_fax:
      rv = url_tel_cmp_numbers(a->url_user, b->url_user);
      break;
    default:
      rv = strcmp(a->url_user, b->url_user);
      break;
    }
    if (rv)
      return rv;
  }

  if (a->url_path != b->url_path) {
    if (a->url_path == NULL) return -1;
    if (b->url_path == NULL) return +1;
    if ((rv = strcmp(a->url_path, b->url_path)))
      return rv;
  }

  if (a->url_params != b->url_params) {
    if (a->url_params == NULL) return -1;
    if (b->url_params == NULL) return +1;
    if ((rv = strcmp(a->url_params, b->url_params)))
      return rv;
  }

  if (a->url_headers != b->url_headers) {
    if (a->url_headers == NULL) return -1;
    if (b->url_headers == NULL) return +1;
    if ((rv = strcmp(a->url_headers, b->url_headers)))
      return rv;
  }

  if (a->url_headers != b->url_headers) {
    if (a->url_headers == NULL) return -1;
    if (b->url_headers == NULL) return +1;
    if ((rv = strcmp(a->url_headers, b->url_headers)))
      return rv;
  }

  if (a->url_fragment != b->url_fragment) {
    if (a->url_fragment == NULL) return -1;
    if (b->url_fragment == NULL) return +1;
    if ((rv = strcmp(a->url_fragment, b->url_fragment)))
      return rv;
  }

  return 0;
}


char const *url_port_default(enum url_type_e url_type)
{
  switch (url_type) {
  case url_sip:			
    return "5060";
  case url_sips:		
    return "5061";
  case url_http:		
    return "80";
  case url_https:		
    return "443";
  case url_ftp:			
  case url_file:		
    return "21";
  case url_rtsp:		
  case url_rtspu:		
    return "554";
  case url_mailto:		
    return "25";

  case url_any:			
    return "*";

  case url_msrp:
  case url_msrps:
    return "9999";		

  case url_tel:
  case url_fax:
  case url_modem:
  case url_im:
  case url_pres:
  case url_cid:
  case url_wv:

  default:			
    return "";
  }
}


char const *url_tport_default(enum url_type_e url_type)
{
  switch (url_type) {
  case url_sip:
    return "*";
  case url_sips:
    return "tls";
  case url_http:
    return "tcp";
  case url_https:
    return "tls";
  case url_ftp:
  case url_file:
    return "tcp";
  case url_rtsp:
    return "tcp";
  case url_rtspu:
    return "udp";
  case url_mailto:
    return "tcp";
  case url_msrp:
    return "tcp";
  case url_msrps:
    return "tls";

  case url_any:			
  case url_tel:
  case url_fax:
  case url_modem:
  case url_im:
  case url_pres:
  case url_cid:
  case url_wv:

  default:			
    return "*";
  }
}



char const *url_port(url_t const *u)
{
  if (!u)
    return "";
  else if (u->url_port && u->url_port[0])
    return u->url_port;

  if (u->url_type == url_sips || u->url_type == url_sip)
    if (!host_is_ip_address(u->url_host))
      return "";

  return url_port_default((enum url_type_e)u->url_type);
}


int url_sanitize(url_t *url)
{
  if (!url)
    return -1;
  else if (url->url_scheme != NULL)
    ;
  else if (url->url_host == NULL)
    return -1;
  else if (strncasecmp(url->url_host, "ftp.", strlen("ftp.")) == 0)
    url->url_type = url_ftp, url->url_scheme = "ftp", url->url_root = '/';
  else if (strncasecmp(url->url_host, "www.", strlen("www.")) == 0 || url->url_path)
    url->url_type = url_http, url->url_scheme = "http", url->url_root = '/';
  else url->url_type = url_sip, url->url_scheme = "sip";

  return 0;
}



static void canon_update(su_md5_t *md5, char const *s, size_t n, char const *allow)
{
  size_t i, j;

  for (i = 0, j = 0; i < n && s[i]; i++) {
    char c;

    if (s[i] == '%' && i + 2 < n && IS_HEX(s[i+1]) && IS_HEX(s[i+2])) {

      c = (UNHEX(s[i+1]) << 4) | UNHEX(s[i+2]);

      if (c != '%' && c > ' ' && c < '\177' && (!strchr(EXCLUDED, c) || strchr(allow, c))) {
	if (i != j)
	  su_md5_iupdate(md5, s + j, i - j);
	su_md5_iupdate(md5, &c, 1);
	j = i + 3;
      }
      i += 2;
    }
  }

  if (i != j)
    su_md5_iupdate(md5, s + j, i - j);
}


static void url_string_update(su_md5_t *md5, char const *s)
{
  size_t n, p;
  int have_authority = 1;
  enum url_type_e type = url_any;
  char const *at, *colon;
  char schema[48];

  if (s == NULL || strlen(s) == 0 || strcmp(s, "*") == 0) {
    su_md5_update(md5, "*\0\0*", 4);
    return;
  }

  n = strcspn(s, ":/?#");
  if (n >= sizeof schema) {
    su_md5_update(md5, ":", 1);
  }
  else if (n && s[n] == ':' ) {
    at = url_canonize(schema, s, n, 0, "+");

    type = url_get_type(schema, at - schema);
    su_md5_iupdate(md5, schema, at - schema);

    have_authority = !url_type_is_opaque(type);
    s += n + 1;
  }
  else {
    su_md5_update(md5, "", 1);
  }

  if (type == url_sip || type == url_sips) {
    
    
    
    n = strcspn(s, "@/;?#");
    p = strcspn(s + n, "@");
    if (s[n + p] == '@') {
      n += p;
      
      colon = memchr(s, ':', n);
      p = colon ? (size_t)(colon - s) : n;
      canon_update(md5, s, p, SIP_USER_UNRESERVED);
      s += n + 1; n = 0;
    }
    else su_md5_iupdate(md5, "", 1);
    n += strcspn(s + n, "/;?#");
  }
  else if (have_authority) {
    if (type == url_wv) {    
      n = strcspn(s, "@;?#");
    }
    else if (type != url_wv && s[0] == '/' && s[1] != '/') {
      
      su_md5_update(md5, "\0\0", 2); 
      su_md5_striupdate(md5, url_port_default(type));
      return;
    }
    else if (s[0] == '/' && s[1] == '/') {
      
      s += 2;
      n = strcspn(s, "/?#@[]");
    }
    else n = strcspn(s, "@;/?#");

    if (s[n] == '@') {
      
      colon = type != url_unknown ? memchr(s, ':', n) : NULL;
      p = colon ? (size_t)(colon - s) : n;
      canon_update(md5, s, p, SIP_USER_UNRESERVED);
      s += n + 1;
      n = strcspn(s, "/;?#");	
    }
    else {
      su_md5_iupdate(md5, "", 1);	
      n += strcspn(s + n, "/;?#");	
    }
  }
  else  {
    n = strcspn(s, ":/;?#");	

    canon_update(md5, s, n, ""); 
    su_md5_update(md5, "\0", 1); 
    su_md5_striupdate(md5, url_port_default(type));
    return;
  }

  if (n > 0 && s[0] == '[') {	
    colon = memchr(s, ']', n);
    if (colon == NULL || ++colon == s + n || *colon != ':')
      colon = NULL;
  }
  else colon = memchr(s, ':', n);

  if (colon) {
    canon_update(md5, s, colon - s, ""); 
    canon_update(md5, colon + 1, (s + n) - (colon + 1), "");
  }
  else {
    canon_update(md5, s, n, ""); 
    su_md5_strupdate(md5, url_port_default(type));	
  }

  
}



void url_update(su_md5_t *md5, url_t const *url)
{
  if (url_string_p((url_string_t *)url)) {
    url_string_update(md5, (char const *)url);
  }
  else {
    SU_MD5_STRI0UPDATE(md5, url->url_scheme);
    SU_MD5_STRI0UPDATE(md5, url->url_user);
    SU_MD5_STRI0UPDATE(md5, url->url_host);
    su_md5_striupdate(md5, URL_PORT(url));
    
    
  }
}


void url_digest(void *hash, int hsize, url_t const *url, char const *key)
{
  su_md5_t md5[1];
  uint8_t digest[SU_MD5_DIGEST_SIZE];

  su_md5_init(md5);
  if (key) su_md5_strupdate(md5, key);
  url_update(md5, url);
  su_md5_digest(md5, digest);

  if (hsize > SU_MD5_DIGEST_SIZE) {
    memset((char *)hash + SU_MD5_DIGEST_SIZE, 0, hsize - SU_MD5_DIGEST_SIZE);
    hsize = SU_MD5_DIGEST_SIZE;
  }

  memcpy(hash, digest, hsize);
}


char *url_query_as_header_string(su_home_t *home, char const *query)
{
  size_t i, j, n, b_start = 0, b_len = 0;
  char *s = su_strdup(home, query);

  if (!s)
    return NULL;

  for (i = 0, j = 0; s[i];) {
    n = strcspn(s + i, "=");
    if (!s[i + n])
      break;
    if (n == 4 && strncasecmp(s + i, "body", 4) == 0) {
      if (b_start)
	break;
      b_start = i + n + 1, b_len = strcspn(s + b_start, "&");
      i = b_start + b_len + 1;
      continue;
    }
    if (i != j)
      memmove(s + j, s + i, n);
    s[j + n] = ':';
    i += n + 1, j += n + 1;
    n = strcspn(s + i, "&");
    j += url_unescape_to(s + j, s + i, n);
    i += n;
    if (s[i]) {
      s[j++] = '\n', i++;
    }
  }

  if (s[i])
    return (void)su_free(home, s), NULL;

  if (b_start) {
    s[j++] = '\n', s[j++] = '\n';
    j += url_unescape_to(s + j, query + b_start, b_len);
  }
  s[j] = '\0'; assert(j <= i);

  return s;
}
