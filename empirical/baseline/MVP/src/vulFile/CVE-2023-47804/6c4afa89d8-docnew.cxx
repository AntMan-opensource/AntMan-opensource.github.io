







































































































using namespace ::com::sun::star;
using namespace ::com::sun::star::document;

const sal_Char __FAR_DATA sFrmFmtStr[] = "Frameformat";
const sal_Char __FAR_DATA sEmptyPageStr[] = "Empty Page";
const sal_Char __FAR_DATA sColumnCntStr[] = "Columncontainer";
const sal_Char __FAR_DATA sCharFmtStr[] = "Zeichenformat";
const sal_Char __FAR_DATA sTxtCollStr[] = "Textformatvorlage";
const sal_Char __FAR_DATA sGrfCollStr[] = "Graphikformatvorlage";

SV_IMPL_PTRARR( SwNumRuleTbl, SwNumRulePtr)
SV_IMPL_PTRARR( SwTxtFmtColls, SwTxtFmtCollPtr)
SV_IMPL_PTRARR( SwGrfFmtColls, SwGrfFmtCollPtr)



 uno::Reference< linguistic2::XProofreadingIterator > SwDoc::GetGCIterator() const {
    if (!m_xGCIterator.is() && SvtLinguConfig().HasGrammarChecker())
    {
        uno::Reference< lang::XMultiServiceFactory >  xMgr( utl::getProcessServiceFactory() );
        if (xMgr.is())
        {
            try {
                rtl::OUString aServiceName( rtl::OUString::createFromAscii("com.sun.star.linguistic2.ProofreadingIterator") );
                m_xGCIterator = uno::Reference< linguistic2::XProofreadingIterator > ( xMgr->createInstance( aServiceName ), uno::UNO_QUERY_THROW );
            }
            catch (uno::Exception &)
            {
                DBG_ERROR( "No GCIterator" );
            }
        }
    }

    return m_xGCIterator;
}

void StartGrammarChecking( SwDoc &rDoc )
{
    
    bool bVisible = false;
    const SwDocShell *pDocShell = rDoc.GetDocShell();
    SfxViewFrame    *pFrame = SfxViewFrame::GetFirst( pDocShell, sal_False );
    while (pFrame && !bVisible)
    {
        if (pFrame->IsVisible())
            bVisible = true;
        pFrame = SfxViewFrame::GetNext( *pFrame, pDocShell, sal_False );
    }
    
    
    
    
    
    if (bVisible)
    {
        uno::Reference< linguistic2::XProofreadingIterator > xGCIterator( rDoc.GetGCIterator() );
        if ( xGCIterator.is() )
        {
            uno::Reference< lang::XComponent >  xDoc( rDoc.GetDocShell()->GetBaseModel(), uno::UNO_QUERY );
            uno::Reference< text::XFlatParagraphIteratorProvider >  xFPIP( xDoc, uno::UNO_QUERY );

            
            if ( xFPIP.is() && !xGCIterator->isProofreading( xDoc ) )
                xGCIterator->startProofreading( xDoc, xFPIP );
        }
    }
}





sal_Bool lcl_DelFmtIndizes( const SwFrmFmtPtr& rpFmt, void* )
{
	SwFmtCntnt &rFmtCntnt = (SwFmtCntnt&)rpFmt->GetCntnt();
	if ( rFmtCntnt.GetCntntIdx() )
		rFmtCntnt.SetNewCntntIdx( 0 );
	SwFmtAnchor &rFmtAnchor = (SwFmtAnchor&)rpFmt->GetAnchor();
	if ( rFmtAnchor.GetCntntAnchor() )
		rFmtAnchor.SetAnchor( 0 );
	return sal_True;
}



SwDoc::SwDoc()
    : m_pNodes( new SwNodes(this) )
    , mpAttrPool(new SwAttrPool(this)), pMarkManager(new ::sw::mark::MarkManager(*this)), m_pMetaFieldManager(new ::sw::MetaFieldManager()), m_pUndoManager(new ::sw::UndoManager( ::std::auto_ptr<SwNodes>(new SwNodes(this)), *this, *this, *this)), pDfltFrmFmt( new SwFrmFmt( GetAttrPool(), sFrmFmtStr, 0 ) ), pEmptyPageFmt( new SwFrmFmt( GetAttrPool(), sEmptyPageStr, pDfltFrmFmt ) ), pColumnContFmt( new SwFrmFmt( GetAttrPool(), sColumnCntStr, pDfltFrmFmt ) ), pDfltCharFmt( new SwCharFmt( GetAttrPool(), sCharFmtStr, 0 ) ), pDfltTxtFmtColl( new SwTxtFmtColl( GetAttrPool(), sTxtCollStr ) ), pDfltGrfFmtColl( new SwGrfFmtColl( GetAttrPool(), sGrfCollStr ) ), pFrmFmtTbl( new SwFrmFmts() ), pCharFmtTbl( new SwCharFmts() ), pSpzFrmFmtTbl( new SwSpzFrmFmts() ), pSectionFmtTbl( new SwSectionFmts() ), pTblFrmFmtTbl( new SwFrmFmts() ), pTxtFmtCollTbl( new SwTxtFmtColls() ), pGrfFmtCollTbl( new SwGrfFmtColls() ), pTOXTypes( new SwTOXTypes() ), pDefTOXBases( new SwDefTOXBase_Impl() ), pCurrentView( 0 ), pDrawModel( 0 ), pUpdtFlds( new SwDocUpdtFld() ), pFldTypes( new SwFldTypes() ), pVirDev( 0 ), pPrt( 0 ), pPrtData( 0 ), pGlossaryDoc( 0 ), pOutlineRule( 0 ), pFtnInfo( new SwFtnInfo ), pEndNoteInfo( new SwEndNoteInfo ), pLineNumberInfo( new SwLineNumberInfo ), pFtnIdxs( new SwFtnIdxs ), pDocStat( new SwDocStat ), pDocShell( 0 ), pLinkMgr( new sfx2::LinkManager( 0 ) ), pACEWord( 0 ), pURLStateChgd( 0 ), pNumberFormatter( 0 ), pNumRuleTbl( new SwNumRuleTbl ),  maLists(), maListStyleLists(),  pRedlineTbl( new SwRedlineTbl ), pAutoFmtRedlnComment( 0 ), pUnoCrsrTbl( new SwUnoCrsrTbl( 0, 16 ) ), pPgPViewPrtData( 0 ), pExtInputRing( 0 ), pLayouter( 0 ),  pStyleAccess( 0 ),  pLayoutCache( 0 ), pUnoCallBack(new SwModify(0)), mpGrammarContact( 0 ), aChartDataProviderImplRef(), pChartControllerHelper( 0 ),  mpListItemsList( new tImplSortedNodeNumList() ),  m_pXmlIdRegistry(), nAutoFmtRedlnCommentNo( 0 ), nLinkUpdMode( GLOBALSETTING ), eFldUpdMode( AUTOUPD_GLOBALSETTING ), eRedlineMode((RedlineMode_t)(nsRedlineMode_t::REDLINE_SHOW_INSERT | nsRedlineMode_t::REDLINE_SHOW_DELETE)), eChrCmprType( CHARCOMPRESS_NONE ), mReferenceCount(0), mIdleBlockCount(0), nLockExpFld( 0 ), mbReadlineChecked(false),  mbLinksUpdated( sal_False ), mbClipBoard( false ), mbColumnSelection( false ), mbContainsAtPageObjWithContentAnchor( false ),  mbProtectForm(false), mbLastBrowseMode( false ), n32DummyCompatabilityOptions1(0), n32DummyCompatabilityOptions2(0), mbStartIdleTimer(sal_False), meDocType( DOCTYPE_NATIVE )


















































































{
	RTL_LOGFILE_CONTEXT_AUTHOR( aLog, "SW", "JP93722",  "SwDoc::SwDoc" );

	mbGlossDoc = mbModified = mbDtor = mbPageNums = mbLoaded = mbUpdateExpFld = mbNewDoc = mbCopyIsMove = mbInReading = mbInXMLImport = mbUpdateTOX = mbInLoadAsynchron = mbHTMLMode = mbInCallModified = mbIsGlobalDoc = mbGlblDocSaveLinks = mbIsLabelDoc = mbIsAutoFmtRedline = mbOLEPrtNotifyPending = mbAllOLENotify = mbIsRedlineMove = mbInsOnlyTxtGlssry = mbContains_MSVBasic = mbKernAsianPunctuation =  mbXMLExport =   mbApplyWorkaroundForB6375613 =  false;






























	mbNewFldLst = mbVisibleLinks = mbPurgeOLE = true;



    
    
    

    
    
    
    const SvtCompatibilityOptions aOptions;
    mbParaSpaceMax                      = aOptions.IsAddSpacing();
    mbParaSpaceMaxAtPages               = aOptions.IsAddSpacingAtPages();
    mbTabCompat                         = !aOptions.IsUseOurTabStops();
    mbUseVirtualDevice                  = !aOptions.IsUsePrtDevice();
    mbAddExternalLeading                = !aOptions.IsNoExtLeading();
    mbOldLineSpacing                    = aOptions.IsUseLineSpacing();
    mbAddParaSpacingToTableCells        = aOptions.IsAddTableSpacing();
    mbUseFormerObjectPos                = aOptions.IsUseObjectPositioning();
    mbUseFormerTextWrapping             = aOptions.IsUseOurTextWrapping();
    mbConsiderWrapOnObjPos              = aOptions.IsConsiderWrappingStyle();
    mbMathBaselineAlignment                 = false;        
    mbAddFlyOffsets                         = false;        
    mbOldNumbering                          = false;        
    mbUseHiResolutionVirtualDevice          = true;         
    mbIgnoreFirstLineIndentInNumbering      = false;        
    mbDoNotJustifyLinesWithManualBreak      = !aOptions.IsExpandWordSpace();
    mbDoNotResetParaAttrsForNumFont         = false;        
    mbOutlineLevelYieldsOutlineRule         = false;        
    mbTableRowKeep                          = false;        
    mbIgnoreTabsAndBlanksForLineCalculation = false;        
    mbDoNotCaptureDrawObjsOnPage            = false;        
    mbClipAsCharacterAnchoredWriterFlyFrames= false;        
    mbUnixForceZeroExtLeading               = false;        
    mbOldPrinterMetrics                     = false;        
    mbTabRelativeToIndent                   = true;         
    
    mbTabAtLeftIndentForParagraphsInList    = false;        
    

    
    
    

	pMacroTable = new SvxMacroTableDtor;

    mpGrammarContact = ::createGrammarContact();

	
	
	pFrmFmtTbl->Insert(pDfltFrmFmt, 0 );
	pCharFmtTbl->Insert(pDfltCharFmt, 0 );

	
	
	pTxtFmtCollTbl->Insert(pDfltTxtFmtColl, 0 );
    
	pGrfFmtCollTbl->Insert(pDfltGrfFmtColl, 0 );

	
	if ( !aPageDescs.Count() )
		GetPageDescFromPool( RES_POOLPAGE_STANDARD );

		
    pEmptyPageFmt->SetFmtAttr( SwFmtFrmSize( ATT_FIX_SIZE ) );
		
    pColumnContFmt->SetFmtAttr( SwFmtFillOrder( ATT_LEFT_TO_RIGHT ) );

	_InitFieldTypes();

    
    
    pOutlineRule = new SwNumRule( String::CreateFromAscii( SwNumRule::GetOutlineRuleName() ),  numfunc::GetDefaultPositionAndSpaceMode(),  OUTLINE_RULE );



    
    
    AddNumRule(pOutlineRule);
    
    pOutlineRule->SetCountPhantoms( !get(IDocumentSettingAccess::OLD_NUMBERING) );
    

    new SwTxtNode( SwNodeIndex(GetUndoManager().GetUndoNodes().GetEndOfContent()), pDfltTxtFmtColl );

    new SwTxtNode( SwNodeIndex( GetNodes().GetEndOfContent() ), GetTxtCollFromPool( RES_POOLCOLL_STANDARD ));

	
	aIdleTimer.SetTimeout( 600 );
	aIdleTimer.SetTimeoutHdl( LINK(this, SwDoc, DoIdleJobs) );

	aOLEModifiedTimer.SetTimeout( 1000 );
	aOLEModifiedTimer.SetTimeoutHdl( LINK( this, SwDoc, DoUpdateModifiedOLE ));

	
	pNewDBMgr = new SwNewDBMgr;

	
    InitTOXTypes();

    
    
    
    {
        SfxItemSet aIgnorableParagraphItems( GetAttrPool(), RES_PARATR_LIST_BEGIN, RES_PARATR_LIST_END-1, 0 );

        pStyleAccess = createStyleManager( &aIgnorableParagraphItems );
    }
    

    ResetModified();
}




SwDoc::~SwDoc()
{
    
    GetIDocumentUndoRedo().DoUndo(false);

    if (pDocShell)
    {
        pDocShell->SetUndoManager(0);
    }

    
    SwPauseThreadStarting aPauseThreadStarting;
    

    
    delete mpListItemsList;
    mpListItemsList = 0;
    

    
    
    
    
    aChartDataProviderImplRef.reset();
    delete pChartControllerHelper;

    delete mpGrammarContact;
    mpGrammarContact = 0;

    
    
    
    
    SwFmtDrop aDrop;
    SetDefault(aDrop);
    
    SwFmtCharFmt aCharFmt(NULL);
    SetDefault(aCharFmt);

	StopIdling();	

	delete pUnoCallBack, pUnoCallBack = 0;
	delete pURLStateChgd;

	delete pLayouter;
    
    pLayouter = 0L;
    

	
	if( pDrawModel )
	{
		DrawNotifyUndoHdl();
		ClrContourCache();
	}

	delete pPgPViewPrtData;

	mbDtor = sal_True;
	pLayoutPtr.reset();

	delete pRedlineTbl;
	delete pUnoCrsrTbl;
	delete pAutoFmtRedlnComment;

	if( pUpdtFlds )
		delete pUpdtFlds;

	if( pACEWord )
		delete pACEWord;

	
	{
		for( sal_uInt16 n = pLinkMgr->GetServers().Count(); n; )
			pLinkMgr->GetServers()[ --n ]->Closed();

		if( pLinkMgr->GetLinks().Count() )
			pLinkMgr->Remove( 0, pLinkMgr->GetLinks().Count() );
	}

	
	
    m_pNodes->pOutlineNds->Remove(sal_uInt16(0), m_pNodes->pOutlineNds->Count());
    SwNodes & rUndoNodes( GetUndoManager().GetUndoNodes() );
    rUndoNodes.pOutlineNds->Remove(sal_uInt16(0), rUndoNodes.pOutlineNds->Count());

	pFtnIdxs->Remove( sal_uInt16(0), pFtnIdxs->Count() );

    
    m_pUndoManager->DelAllUndoObj();

	
	
    pMarkManager->clearAllMarks();
	DELETEZ( pMacroTable );

	if( pExtInputRing )
	{
		Ring* pTmp = pExtInputRing;
		pExtInputRing = 0;
		while( pTmp->GetNext() != pTmp )
			delete pTmp->GetNext();
		delete pTmp;
	}



	{
		for( sal_uInt16 n = pTOXTypes->Count(); n; )
		{
			(*pTOXTypes)[ --n ]->SetInDocDTOR();
			delete (*pTOXTypes)[ n ];
		}
		pTOXTypes->Remove( 0, pTOXTypes->Count() );
	}
	delete pDefTOXBases;

	
	
	pFrmFmtTbl->ForEach( &lcl_DelFmtIndizes, this );
	pSpzFrmFmtTbl->ForEach( &lcl_DelFmtIndizes, this );
	((SwFrmFmts&)*pSectionFmtTbl).ForEach( &lcl_DelFmtIndizes, this );

	
	
	
	
	aPageDescs.DeleteAndDestroy( 0, aPageDescs.Count() );

	
	
	
    m_pNodes->DelNodes( SwNodeIndex(*m_pNodes), m_pNodes->Count() );
    rUndoNodes.DelNodes( SwNodeIndex( rUndoNodes ), rUndoNodes.Count() );

	

	
	
    pFtnInfo->ReleaseCollection();
    pEndNoteInfo->ReleaseCollection();

	ASSERT( pDfltTxtFmtColl == (*pTxtFmtCollTbl)[0], "Default-Text-Collection muss immer am Anfang stehen" );

	
	
	
	if( 2 < pTxtFmtCollTbl->Count() )
		pTxtFmtCollTbl->DeleteAndDestroy( 2, pTxtFmtCollTbl->Count()-2 );
	pTxtFmtCollTbl->DeleteAndDestroy( 1, pTxtFmtCollTbl->Count()-1 );
	delete pTxtFmtCollTbl;

	ASSERT( pDfltGrfFmtColl == (*pGrfFmtCollTbl)[0], "Default-Grf-Collection muss immer am Anfang stehen" );

	pGrfFmtCollTbl->DeleteAndDestroy( 1, pGrfFmtCollTbl->Count()-1 );


	delete pGrfFmtCollTbl;

	
	pFrmFmtTbl->Remove( 0 );
	pCharFmtTbl->Remove( 0 );

	
	DELETEZ( pPrt );
	DELETEZ( pNewDBMgr );

	
	
	
	pSpzFrmFmtTbl->DeleteAndDestroy( 0, pSpzFrmFmtTbl->Count() );

	
	
	
	ReleaseDrawModel();
	
	
	DELETEZ( pLinkMgr );

	
	
	delete pFrmFmtTbl;
	delete pSpzFrmFmtTbl;

    delete pStyleAccess;

	delete pCharFmtTbl;
	delete pSectionFmtTbl;
	delete pTblFrmFmtTbl;
	delete pDfltTxtFmtColl;
	delete pDfltGrfFmtColl;
	delete pNumRuleTbl;

    
    {
        for ( std::hash_map< String, SwList*, StringHash >::iterator aListIter = maLists.begin();
              aListIter != maLists.end();
              ++aListIter )
        {
            delete (*aListIter).second;
        }
        maLists.clear();
    }
    maListStyleLists.clear();
    

	disposeXForms(); 

	delete pPrtData;
	delete pNumberFormatter;
	delete pFtnInfo;
	delete pEndNoteInfo;
	delete pLineNumberInfo;
	delete pFtnIdxs;
	delete pFldTypes;
	delete pTOXTypes;
	delete pDocStat;
	delete pEmptyPageFmt;
	delete pColumnContFmt;
	delete pDfltCharFmt;
	delete pDfltFrmFmt;
    delete pLayoutCache;
    delete pVirDev;

    SfxItemPool::Free(mpAttrPool);
}



VirtualDevice& SwDoc::CreateVirtualDevice_() const {
    VirtualDevice* pNewVir = new VirtualDevice( 1 );

    
    pNewVir->SetReferenceDevice( VirtualDevice::REFDEV_MODE_MSO1 );

    
    if ( get(IDocumentSettingAccess::UNIX_FORCE_ZERO_EXT_LEADING ) )
        pNewVir->Compat_ZeroExtleadBug();
    

    MapMode aMapMode( pNewVir->GetMapMode() );
    aMapMode.SetMapUnit( MAP_TWIP );
    pNewVir->SetMapMode( aMapMode );

    const_cast<SwDoc*>(this)->setVirtualDevice( pNewVir, true, true );
    return *pVirDev;
}



SfxPrinter& SwDoc::CreatePrinter_() const {
    ASSERT( ! pPrt, "Do not call CreatePrinter_(), call getPrinter() instead" )


    OSL_TRACE( "Printer will be created!" );


    
	
	SfxItemSet *pSet = new SfxItemSet( ((SwDoc*)this)->GetAttrPool(), FN_PARAM_ADDPRINTER, FN_PARAM_ADDPRINTER, SID_HTML_MODE,	SID_HTML_MODE, SID_PRINTER_NOTFOUND_WARN, SID_PRINTER_NOTFOUND_WARN, SID_PRINTER_CHANGESTODOC, SID_PRINTER_CHANGESTODOC, 0 );





    SfxPrinter* pNewPrt = new SfxPrinter( pSet );
    const_cast<SwDoc*>(this)->setPrinter( pNewPrt, true, true );
    return *pPrt;
}


void SwDoc::SetDocShell( SwDocShell* pDSh )
{
	if( pDocShell != pDSh )
	{
        if (pDocShell)
        {
            pDocShell->SetUndoManager(0);
        }
		pDocShell = pDSh;
        if (pDocShell)
        {
            pDocShell->SetUndoManager(& GetUndoManager());
        }

		pLinkMgr->SetPersist( pDocShell );
		
		if( pDrawModel )
		{
			((SwDrawDocument*)pDrawModel)->SetObjectShell( pDocShell );
			pDrawModel->SetPersist( pDocShell );
			ASSERT( pDrawModel->GetPersist() == GetPersist(), "draw model's persist is out of sync" );
		}
	}
}







uno::Reference < embed::XStorage > SwDoc::GetDocStorage()
{
	if( pDocShell )
		return pDocShell->GetStorage();
	if( pLinkMgr->GetPersist() )
		return pLinkMgr->GetPersist()->GetStorage();
	return NULL;
}



SfxObjectShell* SwDoc::GetPersist() const {
	return pDocShell ? pDocShell : pLinkMgr->GetPersist();
}


void SwDoc::ClearDoc()
{
    GetIDocumentUndoRedo().DelAllUndoObj();
    ::sw::UndoGuard const undoGuard(GetIDocumentUndoRedo());

	
	if( pDrawModel )
	{
		DrawNotifyUndoHdl();
		ClrContourCache();
	}

	
	sal_uInt16 n;
	while ( 0 != (n = GetSpzFrmFmts()->Count()) )
		DelLayoutFmt((*pSpzFrmFmtTbl)[n-1]);
	ASSERT( !pDrawModel || !pDrawModel->GetPage(0)->GetObjCount(), "not all DrawObjects removed from the page" );

	pRedlineTbl->DeleteAndDestroy( 0, pRedlineTbl->Count() );

	if( pACEWord )
		delete pACEWord;

	
	
    pMarkManager->clearAllMarks();
    InitTOXTypes();

	
	sal_uInt16 nDummyPgDsc = MakePageDesc( String::CreateFromAscii( "?DUMMY?" ));
	SwPageDesc* pDummyPgDsc = aPageDescs[ nDummyPgDsc ];

	SwNodeIndex aSttIdx( *GetNodes().GetEndOfContent().StartOfSectionNode(), 1 );
	
	SwTxtNode* pFirstNd = GetNodes().MakeTxtNode( aSttIdx, pDfltTxtFmtColl );

	if( pCurrentView )	
	{
		
        pFirstNd->SetAttr( SwFmtPageDesc( pDummyPgDsc ));

		SwPosition aPos( *pFirstNd, SwIndex( pFirstNd ));
        SwPaM const tmpPaM(aSttIdx, SwNodeIndex(GetNodes().GetEndOfContent()));
        ::PaMCorrAbs(tmpPaM, aPos);
	}

	GetNodes().Delete( aSttIdx, GetNodes().GetEndOfContent().GetIndex() - aSttIdx.GetIndex() );

    
    
    
    pOutlineRule = NULL;
    pNumRuleTbl->DeleteAndDestroy( 0, pNumRuleTbl->Count() );
    
    {
        for ( std::hash_map< String, SwList*, StringHash >::iterator aListIter = maLists.begin();
              aListIter != maLists.end();
              ++aListIter )
        {
            delete (*aListIter).second;
        }
        maLists.clear();
    }
    maListStyleLists.clear();
    
    
    
    pOutlineRule = new SwNumRule( String::CreateFromAscii( SwNumRule::GetOutlineRuleName() ),  numfunc::GetDefaultPositionAndSpaceMode(),  OUTLINE_RULE );



    
    AddNumRule(pOutlineRule);
    
    pOutlineRule->SetCountPhantoms( !get(IDocumentSettingAccess::OLD_NUMBERING) );
    
    

	
	aPageDescs.Remove( nDummyPgDsc );
	aPageDescs.DeleteAndDestroy( 0, aPageDescs.Count() );

	
	
    pFtnInfo->ReleaseCollection();
    pEndNoteInfo->ReleaseCollection();

	
	
	
	if( 2 < pTxtFmtCollTbl->Count() )
		pTxtFmtCollTbl->DeleteAndDestroy( 2, pTxtFmtCollTbl->Count()-2 );
	pTxtFmtCollTbl->DeleteAndDestroy( 1, pTxtFmtCollTbl->Count()-1 );
	pGrfFmtCollTbl->DeleteAndDestroy( 1, pGrfFmtCollTbl->Count()-1 );
	pCharFmtTbl->DeleteAndDestroy( 1, pCharFmtTbl->Count()-1 );

	if( pCurrentView )
	{
		
		pFrmFmtTbl->Remove( pFrmFmtTbl->GetPos( pCurrentView->GetLayout()->GetFmt() ) );
		pFrmFmtTbl->DeleteAndDestroy( 1, pFrmFmtTbl->Count()-1 );
		pFrmFmtTbl->Insert( pCurrentView->GetLayout()->GetFmt(), pFrmFmtTbl->Count() );
	}
	else	 pFrmFmtTbl->DeleteAndDestroy( 1, pFrmFmtTbl->Count()-1 );

	xForbiddenCharsTable.unbind();

	pFldTypes->DeleteAndDestroy( INIT_FLDTYPES, pFldTypes->Count() - INIT_FLDTYPES );

	delete pNumberFormatter, pNumberFormatter = 0;

	GetPageDescFromPool( RES_POOLPAGE_STANDARD );
	pFirstNd->ChgFmtColl( GetTxtCollFromPool( RES_POOLCOLL_STANDARD ));
	nDummyPgDsc = aPageDescs.Count();
	aPageDescs.Insert( pDummyPgDsc, nDummyPgDsc );
	
	pFirstNd->ResetAllAttr();
	
	DelPageDesc( nDummyPgDsc );
}

void SwDoc::SetPreViewPrtData( const SwPagePreViewPrtData* pNew )
{
	if( pNew )
	{
		if( pPgPViewPrtData )
			*pPgPViewPrtData = *pNew;
		else pPgPViewPrtData = new SwPagePreViewPrtData( *pNew );
	}
	else if( pPgPViewPrtData )
		DELETEZ( pPgPViewPrtData );
	SetModified();
}

SwModify*	SwDoc::GetUnoCallBack() const {
	return pUnoCallBack;
}



void SwDoc::ReadLayoutCache( SvStream& rStream )
{
    if( !pLayoutCache )
        pLayoutCache = new SwLayoutCache();
    if( !pLayoutCache->IsLocked() )
    {
        pLayoutCache->GetLockCount() |= 0x8000;
        pLayoutCache->Read( rStream );
        pLayoutCache->GetLockCount() &= 0x7fff;
    }
}

void SwDoc::WriteLayoutCache( SvStream& rStream )
{
    pLayoutCache->Write( rStream, *this );
}

IGrammarContact* getGrammarContact( const SwTxtNode& rTxtNode )
{
    const SwDoc* pDoc = rTxtNode.GetDoc();
    if( !pDoc || pDoc->IsInDtor() )
        return 0;
    return pDoc->getGrammarContact();
}



void SwDoc::UpdateLinks( sal_Bool bUI )
{
    SfxObjectCreateMode eMode;
    sal_uInt16 nLinkMode = getLinkUpdateMode( true );
    sal_uInt16 nUpdateDocMode = GetDocShell()->GetUpdateDocMode();
    if( GetDocShell() && (nLinkMode != NEVER ||  document::UpdateDocMode::FULL_UPDATE == nUpdateDocMode) && GetLinkManager().GetLinks().Count() && SFX_CREATE_MODE_INTERNAL != ( eMode = GetDocShell()->GetCreateMode()) && SFX_CREATE_MODE_ORGANIZER != eMode && SFX_CREATE_MODE_PREVIEW != eMode && !GetDocShell()->IsPreview() )






    {
        ViewShell* pVSh = 0;
        sal_Bool bAskUpdate = nLinkMode == MANUAL;
        sal_Bool bUpdate = sal_True;
        switch(nUpdateDocMode)
        {
            case document::UpdateDocMode::NO_UPDATE:   bUpdate = sal_False;break;
            case document::UpdateDocMode::QUIET_UPDATE:bAskUpdate = sal_False; break;
            case document::UpdateDocMode::FULL_UPDATE: bAskUpdate = sal_True; break;
        }
        if (nLinkMode == AUTOMATIC && !bAskUpdate)
        {
            if (!(SvtSecurityOptions().GetMacroSecurityLevel() == 0))
            {
                bAskUpdate = true;
            }
        }
        if( bUpdate && (bUI || !bAskUpdate) )
        {
            SfxMedium* pMedium = GetDocShell()->GetMedium();
            SfxFrame* pFrm = pMedium ? pMedium->GetLoadTargetFrame() : 0;
            Window* pDlgParent = pFrm ? &pFrm->GetWindow() : 0;
            if( GetCurrentViewShell() && !GetEditShell( &pVSh ) && !pVSh )	
            {
                ViewShell aVSh( *this, 0, 0 );

                SET_CURR_SHELL( &aVSh );
                GetLinkManager().UpdateAllLinks( bAskUpdate , sal_True, sal_False, pDlgParent );
            }
            else GetLinkManager().UpdateAllLinks( bAskUpdate, sal_True, sal_False, pDlgParent );
        }
    }

}


void SwDoc::SetApplyWorkaroundForB6375613( bool p_bApplyWorkaroundForB6375613 )
{
    if ( mbApplyWorkaroundForB6375613 != p_bApplyWorkaroundForB6375613 )
    {
        mbApplyWorkaroundForB6375613 = p_bApplyWorkaroundForB6375613;

        uno::Reference< document::XDocumentInfoSupplier > xDoc( GetDocShell()->GetBaseModel(), uno::UNO_QUERY);

        if ( xDoc.is() )
        {
            uno::Reference< beans::XPropertyContainer > xDocInfo( xDoc->getDocumentInfo(), uno::UNO_QUERY );

            if ( xDocInfo.is() )
            {
                try {
                    if ( mbApplyWorkaroundForB6375613 )
                    {
                        xDocInfo->addProperty( rtl::OUString::createFromAscii("WorkaroundForB6375613Applied"), beans::PropertyAttribute::TRANSIENT | beans::PropertyAttribute::REMOVABLE, uno::makeAny( false ) );


                    }
                    else {
                        xDocInfo->removeProperty( rtl::OUString::createFromAscii("WorkaroundForB6375613Applied") );
                    }
                }
                catch( uno::Exception& )
                {
                }
            }
        }
    }
}


::sfx2::IXmlIdRegistry& SwDoc::GetXmlIdRegistry()
{
    
    if (!m_pXmlIdRegistry.get())
    {
        m_pXmlIdRegistry.reset( ::sfx2::createXmlIdRegistry( IsClipBoard() ) );
    }
    return *m_pXmlIdRegistry;
}

::sw::MetaFieldManager & SwDoc::GetMetaFieldManager()
{
    return *m_pMetaFieldManager;
}

::sw::UndoManager & SwDoc::GetUndoManager()
{
    return *m_pUndoManager;
}

::sw::UndoManager const& SwDoc::GetUndoManager() const {

    return *m_pUndoManager;
}

IDocumentUndoRedo & SwDoc::GetIDocumentUndoRedo()
{
    return *m_pUndoManager;
}

IDocumentUndoRedo const& SwDoc::GetIDocumentUndoRedo() const {

    return *m_pUndoManager;
}

void SwDoc::InitTOXTypes()
{
   ShellResource* pShellRes = ViewShell::GetShellRes();
   SwTOXType * pNew = new SwTOXType(TOX_CONTENT,   pShellRes->aTOXContentName        );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_INDEX,                 pShellRes->aTOXIndexName  );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_USER,                  pShellRes->aTOXUserName  );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_ILLUSTRATIONS,         pShellRes->aTOXIllustrationsName );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_OBJECTS,               pShellRes->aTOXObjectsName       );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_TABLES,                pShellRes->aTOXTablesName        );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
   pNew = new SwTOXType(TOX_AUTHORITIES,           pShellRes->aTOXAuthoritiesName   );
   pTOXTypes->Insert( pNew, pTOXTypes->Count() );
}


SfxObjectShell* SwDoc::CreateCopy(bool bCallInitNew ) const {
    SwDoc* pRet = new SwDoc;
    
    sal_uInt16 __FAR_DATA aRangeOfDefaults[] = {
        RES_FRMATR_BEGIN, RES_FRMATR_END-1, RES_CHRATR_BEGIN, RES_CHRATR_END-1, RES_PARATR_BEGIN, RES_PARATR_END-1,  RES_PARATR_LIST_BEGIN, RES_PARATR_LIST_END-1,  RES_UNKNOWNATR_BEGIN, RES_UNKNOWNATR_END-1, 0 };








    SfxItemSet aNewDefaults( pRet->GetAttrPool(), aRangeOfDefaults );

    sal_uInt16 nWhich;
    sal_uInt16 nRange = 0;
    while( aRangeOfDefaults[nRange] != 0)
    {
        for( nWhich = aRangeOfDefaults[nRange]; nWhich < aRangeOfDefaults[nRange + 1]; ++nWhich )
        {
            const SfxPoolItem& rSourceAttr = mpAttrPool->GetDefaultItem( nWhich );
            if( rSourceAttr != pRet->mpAttrPool->GetDefaultItem( nWhich ) )
                aNewDefaults.Put( rSourceAttr );
        }
        nRange += 2;
    }
    if( aNewDefaults.Count() )
        pRet->SetDefault( aNewDefaults );

    pRet->n32DummyCompatabilityOptions1 = n32DummyCompatabilityOptions1;
    pRet->n32DummyCompatabilityOptions2 = n32DummyCompatabilityOptions2;
    pRet->mbParaSpaceMax                          = mbParaSpaceMax                          ;
    pRet->mbParaSpaceMaxAtPages                   = mbParaSpaceMaxAtPages                   ;
    pRet->mbTabCompat                             = mbTabCompat                             ;
    pRet->mbUseVirtualDevice                      = mbUseVirtualDevice                      ;
    pRet->mbAddExternalLeading                    = mbAddExternalLeading                    ;
    pRet->mbOldLineSpacing                        = mbOldLineSpacing                        ;
    pRet->mbAddParaSpacingToTableCells            = mbAddParaSpacingToTableCells            ;
    pRet->mbUseFormerObjectPos                    = mbUseFormerObjectPos                    ;
    pRet->mbUseFormerTextWrapping                 = mbUseFormerTextWrapping                 ;
    pRet->mbConsiderWrapOnObjPos                  = mbConsiderWrapOnObjPos                  ;
    pRet->mbAddFlyOffsets                         = mbAddFlyOffsets                         ;
    pRet->mbOldNumbering                          = mbOldNumbering                          ;
    pRet->mbUseHiResolutionVirtualDevice          = mbUseHiResolutionVirtualDevice          ;
    pRet->mbIgnoreFirstLineIndentInNumbering      = mbIgnoreFirstLineIndentInNumbering      ;
    pRet->mbDoNotJustifyLinesWithManualBreak      = mbDoNotJustifyLinesWithManualBreak      ;
    pRet->mbDoNotResetParaAttrsForNumFont         = mbDoNotResetParaAttrsForNumFont         ;
    pRet->mbOutlineLevelYieldsOutlineRule         = mbOutlineLevelYieldsOutlineRule         ;
    pRet->mbTableRowKeep                          = mbTableRowKeep                          ;
    pRet->mbIgnoreTabsAndBlanksForLineCalculation = mbIgnoreTabsAndBlanksForLineCalculation ;
    pRet->mbDoNotCaptureDrawObjsOnPage            = mbDoNotCaptureDrawObjsOnPage            ;
    pRet->mbClipAsCharacterAnchoredWriterFlyFrames= mbClipAsCharacterAnchoredWriterFlyFrames;
    pRet->mbUnixForceZeroExtLeading               = mbUnixForceZeroExtLeading               ;
    pRet->mbOldPrinterMetrics                     = mbOldPrinterMetrics                     ;
    pRet->mbTabRelativeToIndent                   = mbTabRelativeToIndent                   ;
    pRet->mbTabAtLeftIndentForParagraphsInList    = mbTabAtLeftIndentForParagraphsInList    ;

    
    
    
    pRet->ReplaceStyles( * const_cast< SwDoc*>( this ));

    
    
    SfxObjectShell* pRetShell = new SwDocShell( pRet, SFX_CREATE_MODE_STANDARD );
    if( bCallInitNew )
    {
        
        pRetShell->DoInitNew();
    }

    
    pRet->Paste( *this );

    
    if(pRet->GetTmpDocShell())
    {
        
        
        
        
        
        
        
        
        
        
        pRet->acquire();
        pRet->SetTmpDocShell((SfxObjectShell*)NULL);
        pRet->release();
    }

    
    

    return pRetShell;
}

void SwDoc::Paste( const SwDoc& rSource )
{

    
    SwNodeIndex aSourceIdx( rSource.GetNodes().GetEndOfExtras(), 2 );
    SwPaM aCpyPam( aSourceIdx ); 
    SwNodeIndex aTargetIdx( GetNodes().GetEndOfExtras(), 2 );
    SwPaM aInsertPam( aTargetIdx ); 


    aCpyPam.SetMark();
    aCpyPam.Move( fnMoveForward, fnGoDoc );

    this->GetIDocumentUndoRedo().StartUndo( UNDO_INSGLOSSARY, NULL );
    this->LockExpFlds();

    {
        SwPosition& rInsPos = *aInsertPam.GetPoint();
        
        bool bStartWithTable = 0 != aCpyPam.Start()->nNode.GetNode().FindTableNode();
        SwPosition aInsertPosition( rInsPos );

        {
            SwNodeIndex aIndexBefore(rInsPos.nNode);

            aIndexBefore--;

            rSource.CopyRange( aCpyPam, rInsPos, true );

            {
                aIndexBefore++;
                SwPaM aPaM(SwPosition(aIndexBefore), SwPosition(rInsPos.nNode));

                MakeUniqueNumRules(aPaM);
            }
        }

        
        if(bStartWithTable)
        {
            
            SwPaM aPara(aInsertPosition);
            this->DelFullPara(aPara);
        }
        
        if( rSource.GetSpzFrmFmts()->Count() )
        {
            for ( sal_uInt16 i = 0; i < rSource.GetSpzFrmFmts()->Count(); ++i )
            {
                sal_Bool bInsWithFmt = sal_True;
                const SwFrmFmt& rCpyFmt = *(*rSource.GetSpzFrmFmts())[i];
                if( bInsWithFmt  )
                {
                    SwFmtAnchor aAnchor( rCpyFmt.GetAnchor() );
                    if (FLY_AT_PAGE == aAnchor.GetAnchorId())
                    {
                        aAnchor.SetPageNum( aAnchor.GetPageNum() );
                    }
                    else continue;
                    this->CopyLayoutFmt( rCpyFmt, aAnchor, true, true );
                }
            }
        }
    }

    this->GetIDocumentUndoRedo().EndUndo( UNDO_INSGLOSSARY, NULL );

    UnlockExpFlds();
    UpdateFlds(NULL, false);
}
