



























struct hl_device;
struct hl_fpriv;























































enum hl_mmu_page_table_location {
	MMU_DR_PGT = 0,		 MMU_HR_PGT, MMU_NUM_PGT_LOCATIONS };




enum hl_mmu_enablement {
	MMU_EN_NONE = 0, MMU_EN_ALL = 1, MMU_EN_PMMU_ONLY = 3, };






























































enum hl_protection_levels {
	SECURED_LVL, PRIVILEGED_LVL, NON_SECURED_LVL };




struct iterate_module_ctx {
	
	void (*fn)(struct hl_device *hdev, int block, int inst, u32 offset, struct iterate_module_ctx *ctx);
	void *data;
	int rc;
};

struct hl_block_glbl_sec {
	u32 sec_array[HL_BLOCK_GLBL_SEC_LEN];
};




struct hl_gen_wait_properties {
	void	*data;
	u32	q_idx;
	u32	size;
	u16	sob_base;
	u16	sob_val;
	u16	mon_id;
	u8	sob_mask;
};


struct pgt_info {
	struct hlist_node	node;
	u64			phys_addr;
	u64			virt_addr;
	u64			shadow_addr;
	struct hl_ctx		*ctx;
	int			num_of_ptes;
};


enum hl_pci_match_mode {
	PCI_ADDRESS_MATCH_MODE, PCI_BAR_MATCH_MODE };



enum hl_fw_component {
	FW_COMP_BOOT_FIT, FW_COMP_PREBOOT, FW_COMP_LINUX, };




enum hl_fw_types {
	FW_TYPE_NONE = 0x0, FW_TYPE_LINUX = 0x1, FW_TYPE_BOOT_CPU = 0x2, FW_TYPE_PREBOOT_CPU = 0x4, FW_TYPE_ALL_TYPES = (FW_TYPE_LINUX | FW_TYPE_BOOT_CPU | FW_TYPE_PREBOOT_CPU)




};


enum hl_queue_type {
	QUEUE_TYPE_NA, QUEUE_TYPE_EXT, QUEUE_TYPE_INT, QUEUE_TYPE_CPU, QUEUE_TYPE_HW };





enum hl_cs_type {
	CS_TYPE_DEFAULT, CS_TYPE_SIGNAL, CS_TYPE_WAIT, CS_TYPE_COLLECTIVE_WAIT, CS_RESERVE_SIGNALS, CS_UNRESERVE_SIGNALS, CS_TYPE_ENGINE_CORE };








struct hl_inbound_pci_region {
	enum hl_pci_match_mode	mode;
	u64			addr;
	u64			size;
	u64			offset_in_bar;
	u8			bar;
};


struct hl_outbound_pci_region {
	u64	addr;
	u64	size;
};


enum queue_cb_alloc_flags {
	CB_ALLOC_KERNEL = 0x1, CB_ALLOC_USER   = 0x2 };



struct hl_hw_sob {
	struct hl_device	*hdev;
	struct kref		kref;
	u32			sob_id;
	u32			sob_addr;
	u32			q_idx;
	bool			need_reset;
};

enum hl_collective_mode {
	HL_COLLECTIVE_NOT_SUPPORTED = 0x0, HL_COLLECTIVE_MASTER = 0x1, HL_COLLECTIVE_SLAVE = 0x2 };




struct hw_queue_properties {
	enum hl_queue_type		type;
	enum queue_cb_alloc_flags	cb_alloc_flags;
	enum hl_collective_mode		collective_mode;
	u8				driver_only;
	u8				binned;
	u8				supports_sync_stream;
};


enum vm_type {
	VM_TYPE_USERPTR = 0x1, VM_TYPE_PHYS_PACK = 0x2 };



enum mmu_op_flags {
	MMU_OP_USERPTR = 0x1, MMU_OP_PHYS_PACK = 0x2, MMU_OP_CLEAR_MEMCACHE = 0x4, MMU_OP_SKIP_LOW_CACHE_INV = 0x8, };






enum hl_device_hw_state {
	HL_DEVICE_HW_STATE_CLEAN = 0, HL_DEVICE_HW_STATE_DIRTY };





struct hl_mmu_properties {
	u64	start_addr;
	u64	end_addr;
	u64	hop_shifts[MMU_HOP_MAX];
	u64	hop_masks[MMU_HOP_MAX];
	u64	last_mask;
	u64	pgt_size;
	u64	supported_pages_mask;
	u32	page_size;
	u32	num_hops;
	u32	hop_table_size;
	u32	hop0_tables_total_size;
	u8	host_resident;
};


struct hl_hints_range {
	u64 start_addr;
	u64 end_addr;
};


struct asic_fixed_properties {
	struct hw_queue_properties	*hw_queues_props;
	struct cpucp_info		cpucp_info;
	char				uboot_ver[VERSION_MAX_LEN];
	char				preboot_ver[VERSION_MAX_LEN];
	struct hl_mmu_properties	dmmu;
	struct hl_mmu_properties	pmmu;
	struct hl_mmu_properties	pmmu_huge;
	struct hl_hints_range		hints_dram_reserved_va_range;
	struct hl_hints_range		hints_host_reserved_va_range;
	struct hl_hints_range		hints_host_hpage_reserved_va_range;
	u64				sram_base_address;
	u64				sram_end_address;
	u64				sram_user_base_address;
	u64				dram_base_address;
	u64				dram_end_address;
	u64				dram_user_base_address;
	u64				dram_size;
	u64				dram_pci_bar_size;
	u64				max_power_default;
	u64				dc_power_default;
	u64				dram_size_for_default_page_mapping;
	u64				pcie_dbi_base_address;
	u64				pcie_aux_dbi_reg_addr;
	u64				mmu_pgt_addr;
	u64				mmu_dram_default_page_addr;
	u64				tpc_enabled_mask;
	u64				tpc_binning_mask;
	u64				dram_enabled_mask;
	u64				dram_binning_mask;
	u64				dram_hints_align_mask;
	u64				cfg_base_address;
	u64				mmu_cache_mng_addr;
	u64				mmu_cache_mng_size;
	u64				device_dma_offset_for_host_access;
	u64				host_base_address;
	u64				host_end_address;
	u64				max_freq_value;
	u32				clk_pll_index;
	u32				mmu_pgt_size;
	u32				mmu_pte_size;
	u32				mmu_hop_table_size;
	u32				mmu_hop0_tables_total_size;
	u32				dram_page_size;
	u32				cfg_size;
	u32				sram_size;
	u32				max_asid;
	u32				num_of_events;
	u32				psoc_pci_pll_nr;
	u32				psoc_pci_pll_nf;
	u32				psoc_pci_pll_od;
	u32				psoc_pci_pll_div_factor;
	u32				psoc_timestamp_frequency;
	u32				high_pll;
	u32				cb_pool_cb_cnt;
	u32				cb_pool_cb_size;
	u32				decoder_enabled_mask;
	u32				decoder_binning_mask;
	u32				edma_enabled_mask;
	u32				edma_binning_mask;
	u32				max_pending_cs;
	u32				max_queues;
	u32				fw_preboot_cpu_boot_dev_sts0;
	u32				fw_preboot_cpu_boot_dev_sts1;
	u32				fw_bootfit_cpu_boot_dev_sts0;
	u32				fw_bootfit_cpu_boot_dev_sts1;
	u32				fw_app_cpu_boot_dev_sts0;
	u32				fw_app_cpu_boot_dev_sts1;
	u32				max_dec;
	u32				hmmu_hif_enabled_mask;
	u32				faulty_dram_cluster_map;
	u32				xbar_edge_enabled_mask;
	u32				device_mem_alloc_default_page_size;
	u32				num_engine_cores;
	u16				collective_first_sob;
	u16				collective_first_mon;
	u16				sync_stream_first_sob;
	u16				sync_stream_first_mon;
	u16				first_available_user_sob[HL_MAX_DCORES];
	u16				first_available_user_mon[HL_MAX_DCORES];
	u16				first_available_user_interrupt;
	u16				first_available_cq[HL_MAX_DCORES];
	u16				user_interrupt_count;
	u16				user_dec_intr_count;
	u16				cache_line_size;
	u16				server_type;
	u8				completion_queues_count;
	u8				completion_mode;
	u8				mme_master_slave_mode;
	u8				fw_security_enabled;
	u8				fw_cpu_boot_dev_sts0_valid;
	u8				fw_cpu_boot_dev_sts1_valid;
	u8				dram_supports_virtual_memory;
	u8				hard_reset_done_by_fw;
	u8				num_functional_hbms;
	u8				hints_range_reservation;
	u8				iatu_done_by_fw;
	u8				dynamic_fw_load;
	u8				gic_interrupts_enable;
	u8				use_get_power_for_reset_history;
	u8				supports_compute_reset;
	u8				allow_inference_soft_reset;
	u8				configurable_stop_on_err;
	u8				set_max_power_on_device_init;
	u8				supports_user_set_page_size;
	u8				dma_mask;
	u8				supports_advanced_cpucp_rc;
};


struct hl_fence {
	struct completion	completion;
	struct kref		refcount;
	u64			cs_sequence;
	u32			stream_master_qid_map;
	int			error;
	ktime_t			timestamp;
	u8			mcs_handling_done;
};


struct hl_cs_compl {
	struct hl_fence		base_fence;
	spinlock_t		lock;
	struct hl_device	*hdev;
	struct hl_hw_sob	*hw_sob;
	struct hl_cs_encaps_sig_handle *encaps_sig_hdl;
	u64			cs_seq;
	enum hl_cs_type		type;
	u16			sob_val;
	u16			sob_group;
	bool			encaps_signals;
};




struct hl_ts_buff {
	void			*kernel_buff_address;
	void			*user_buff_address;
	u32			kernel_buff_size;
};

struct hl_mmap_mem_buf;


struct hl_mem_mgr {
	struct device *dev;
	spinlock_t lock;
	struct idr handles;
};


struct hl_mmap_mem_buf_behavior {
	const char *topic;
	u64 mem_id;

	int (*alloc)(struct hl_mmap_mem_buf *buf, gfp_t gfp, void *args);
	int (*mmap)(struct hl_mmap_mem_buf *buf, struct vm_area_struct *vma, void *args);
	void (*release)(struct hl_mmap_mem_buf *buf);
};


struct hl_mmap_mem_buf {
	struct hl_mmap_mem_buf_behavior *behavior;
	struct hl_mem_mgr *mmg;
	struct kref refcount;
	void *private;
	atomic_t mmap;
	u64 real_mapped_size;
	u64 mappable_size;
	u64 handle;
};


struct hl_cb {
	struct hl_device	*hdev;
	struct hl_ctx		*ctx;
	struct hl_mmap_mem_buf	*buf;
	struct list_head	debugfs_list;
	struct list_head	pool_list;
	void			*kernel_address;
	u64			virtual_addr;
	dma_addr_t		bus_address;
	u32			size;
	u32			roundup_size;
	atomic_t		cs_cnt;
	u8			is_pool;
	u8			is_internal;
	u8			is_mmu_mapped;
};




struct hl_cs_job;





















struct hl_sync_stream_properties {
	struct hl_hw_sob hw_sob[HL_RSVD_SOBS];
	u16		next_sob_val;
	u16		base_sob_id;
	u16		base_mon_id;
	u16		collective_mstr_mon_id[HL_COLLECTIVE_RSVD_MSTR_MONS];
	u16		collective_slave_mon_id;
	u16		collective_sob_id;
	u8		curr_sob_offset;
};


struct hl_encaps_signals_mgr {
	spinlock_t		lock;
	struct idr		handles;
};


struct hl_hw_queue {
	struct hl_cs_job			**shadow_queue;
	struct hl_sync_stream_properties	sync_stream_prop;
	enum hl_queue_type			queue_type;
	enum hl_collective_mode			collective_mode;
	void					*kernel_address;
	dma_addr_t				bus_address;
	u32					pi;
	atomic_t				ci;
	u32					hw_queue_id;
	u32					cq_id;
	u32					msi_vec;
	u16					int_queue_len;
	u8					valid;
	u8					supports_sync_stream;
};


struct hl_cq {
	struct hl_device	*hdev;
	void			*kernel_address;
	dma_addr_t		bus_address;
	u32			cq_idx;
	u32			hw_queue_id;
	u32			ci;
	u32			pi;
	atomic_t		free_slots_cnt;
};


struct hl_user_interrupt {
	struct hl_device	*hdev;
	struct list_head	wait_list_head;
	spinlock_t		wait_list_lock;
	u32			interrupt_id;
	bool			is_decoder;
};


struct timestamp_reg_free_node {
	struct list_head	free_objects_node;
	struct hl_cb		*cq_cb;
	struct hl_mmap_mem_buf	*buf;
};


struct timestamp_reg_work_obj {
	struct work_struct	free_obj;
	struct hl_device	*hdev;
	struct list_head	*free_obj_head;
};


struct timestamp_reg_info {
	struct hl_mmap_mem_buf	*buf;
	struct hl_cb		*cq_cb;
	u64			*timestamp_kernel_addr;
	u8			in_use;
};


struct hl_user_pending_interrupt {
	struct timestamp_reg_info	ts_reg_info;
	struct list_head		wait_list_node;
	struct hl_fence			fence;
	u64				cq_target_value;
	u64				*cq_kernel_addr;
};


struct hl_eq {
	struct hl_device	*hdev;
	void			*kernel_address;
	dma_addr_t		bus_address;
	u32			ci;
	u32			prev_eqe_index;
	bool			check_eqe_index;
};


struct hl_dec {
	struct hl_device		*hdev;
	struct work_struct		completion_abnrm_work;
	u32				core_id;
	u32				base_addr;
};


enum hl_asic_type {
	ASIC_INVALID, ASIC_GOYA, ASIC_GAUDI, ASIC_GAUDI_SEC, ASIC_GAUDI2, ASIC_GAUDI2_SEC, };






struct hl_cs_parser;


enum hl_pm_mng_profile {
	PM_AUTO = 1, PM_MANUAL, PM_LAST };




enum hl_pll_frequency {
	PLL_HIGH = 1, PLL_LOW, PLL_LAST };





enum div_select_defs {
	DIV_SEL_REF_CLK = 0, DIV_SEL_PLL_CLK = 1, DIV_SEL_DIVIDED_REF = 2, DIV_SEL_DIVIDED_PLL = 3, };




enum debugfs_access_type {
	DEBUGFS_READ8, DEBUGFS_WRITE8, DEBUGFS_READ32, DEBUGFS_WRITE32, DEBUGFS_READ64, DEBUGFS_WRITE64, };






enum pci_region {
	PCI_REGION_CFG, PCI_REGION_SRAM, PCI_REGION_DRAM, PCI_REGION_SP_SRAM, PCI_REGION_NUMBER, };






struct pci_mem_region {
	u64 region_base;
	u64 region_size;
	u64 bar_size;
	u64 offset_in_bar;
	u8 bar_id;
	u8 used;
};


struct static_fw_load_mgr {
	u64 preboot_version_max_off;
	u64 boot_fit_version_max_off;
	u32 kmd_msg_to_cpu_reg;
	u32 cpu_cmd_status_to_host_reg;
	u32 cpu_boot_status_reg;
	u32 cpu_boot_dev_status0_reg;
	u32 cpu_boot_dev_status1_reg;
	u32 boot_err0_reg;
	u32 boot_err1_reg;
	u32 preboot_version_offset_reg;
	u32 boot_fit_version_offset_reg;
	u32 sram_offset_mask;
	u32 cpu_reset_wait_msec;
};


struct fw_response {
	u32 ram_offset;
	u8 ram_type;
	u8 status;
};


struct dynamic_fw_load_mgr {
	struct fw_response response;
	struct lkd_fw_comms_desc comm_desc;
	struct pci_mem_region *image_region;
	size_t fw_image_size;
	u32 wait_for_bl_timeout;
	bool fw_desc_valid;
};


struct pre_fw_load_props {
	u32 cpu_boot_status_reg;
	u32 sts_boot_dev_sts0_reg;
	u32 sts_boot_dev_sts1_reg;
	u32 boot_err0_reg;
	u32 boot_err1_reg;
	u32 wait_for_preboot_timeout;
};


struct fw_image_props {
	char *image_name;
	u32 src_off;
	u32 copy_size;
};


struct fw_load_mgr {
	union {
		struct dynamic_fw_load_mgr dynamic_loader;
		struct static_fw_load_mgr static_loader;
	};
	struct pre_fw_load_props pre_fw_load;
	struct fw_image_props boot_fit_img;
	struct fw_image_props linux_img;
	u32 cpu_timeout;
	u32 boot_fit_timeout;
	u8 skip_bmc;
	u8 sram_bar_id;
	u8 dram_bar_id;
	u8 fw_comp_loaded;
};

struct hl_cs;


struct engines_data {
	char *buf;
	int actual_size;
	u32 allocated_buf_size;
};


struct hl_asic_funcs {
	int (*early_init)(struct hl_device *hdev);
	int (*early_fini)(struct hl_device *hdev);
	int (*late_init)(struct hl_device *hdev);
	void (*late_fini)(struct hl_device *hdev);
	int (*sw_init)(struct hl_device *hdev);
	int (*sw_fini)(struct hl_device *hdev);
	int (*hw_init)(struct hl_device *hdev);
	void (*hw_fini)(struct hl_device *hdev, bool hard_reset, bool fw_reset);
	void (*halt_engines)(struct hl_device *hdev, bool hard_reset, bool fw_reset);
	int (*suspend)(struct hl_device *hdev);
	int (*resume)(struct hl_device *hdev);
	int (*mmap)(struct hl_device *hdev, struct vm_area_struct *vma, void *cpu_addr, dma_addr_t dma_addr, size_t size);
	void (*ring_doorbell)(struct hl_device *hdev, u32 hw_queue_id, u32 pi);
	void (*pqe_write)(struct hl_device *hdev, __le64 *pqe, struct hl_bd *bd);
	void* (*asic_dma_alloc_coherent)(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle, gfp_t flag);
	void (*asic_dma_free_coherent)(struct hl_device *hdev, size_t size, void *cpu_addr, dma_addr_t dma_handle);
	int (*scrub_device_mem)(struct hl_device *hdev);
	int (*scrub_device_dram)(struct hl_device *hdev, u64 val);
	void* (*get_int_queue_base)(struct hl_device *hdev, u32 queue_id, dma_addr_t *dma_handle, u16 *queue_len);
	int (*test_queues)(struct hl_device *hdev);
	void* (*asic_dma_pool_zalloc)(struct hl_device *hdev, size_t size, gfp_t mem_flags, dma_addr_t *dma_handle);
	void (*asic_dma_pool_free)(struct hl_device *hdev, void *vaddr, dma_addr_t dma_addr);
	void* (*cpu_accessible_dma_pool_alloc)(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle);
	void (*cpu_accessible_dma_pool_free)(struct hl_device *hdev, size_t size, void *vaddr);
	void (*asic_dma_unmap_single)(struct hl_device *hdev, dma_addr_t dma_addr, int len, enum dma_data_direction dir);

	dma_addr_t (*asic_dma_map_single)(struct hl_device *hdev, void *addr, int len, enum dma_data_direction dir);

	void (*hl_dma_unmap_sgtable)(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir);

	int (*cs_parser)(struct hl_device *hdev, struct hl_cs_parser *parser);
	int (*asic_dma_map_sgtable)(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir);
	void (*add_end_of_cb_packets)(struct hl_device *hdev, void *kernel_address, u32 len, u32 original_len, u64 cq_addr, u32 cq_val, u32 msix_num, bool eb);



	void (*update_eq_ci)(struct hl_device *hdev, u32 val);
	int (*context_switch)(struct hl_device *hdev, u32 asid);
	void (*restore_phase_topology)(struct hl_device *hdev);
	int (*debugfs_read_dma)(struct hl_device *hdev, u64 addr, u32 size, void *blob_addr);
	void (*add_device_attr)(struct hl_device *hdev, struct attribute_group *dev_clk_attr_grp, struct attribute_group *dev_vrm_attr_grp);
	void (*handle_eqe)(struct hl_device *hdev, struct hl_eq_entry *eq_entry);
	void* (*get_events_stat)(struct hl_device *hdev, bool aggregate, u32 *size);
	u64 (*read_pte)(struct hl_device *hdev, u64 addr);
	void (*write_pte)(struct hl_device *hdev, u64 addr, u64 val);
	int (*mmu_invalidate_cache)(struct hl_device *hdev, bool is_hard, u32 flags);
	int (*mmu_invalidate_cache_range)(struct hl_device *hdev, bool is_hard, u32 flags, u32 asid, u64 va, u64 size);
	int (*mmu_prefetch_cache_range)(struct hl_ctx *ctx, u32 flags, u32 asid, u64 va, u64 size);
	int (*send_heartbeat)(struct hl_device *hdev);
	int (*debug_coresight)(struct hl_device *hdev, struct hl_ctx *ctx, void *data);
	bool (*is_device_idle)(struct hl_device *hdev, u64 *mask_arr, u8 mask_len, struct engines_data *e);
	int (*compute_reset_late_init)(struct hl_device *hdev);
	void (*hw_queues_lock)(struct hl_device *hdev);
	void (*hw_queues_unlock)(struct hl_device *hdev);
	u32 (*get_pci_id)(struct hl_device *hdev);
	int (*get_eeprom_data)(struct hl_device *hdev, void *data, size_t max_size);
	int (*get_monitor_dump)(struct hl_device *hdev, void *data);
	int (*send_cpu_message)(struct hl_device *hdev, u32 *msg, u16 len, u32 timeout, u64 *result);
	int (*pci_bars_map)(struct hl_device *hdev);
	int (*init_iatu)(struct hl_device *hdev);
	u32 (*rreg)(struct hl_device *hdev, u32 reg);
	void (*wreg)(struct hl_device *hdev, u32 reg, u32 val);
	void (*halt_coresight)(struct hl_device *hdev, struct hl_ctx *ctx);
	int (*ctx_init)(struct hl_ctx *ctx);
	void (*ctx_fini)(struct hl_ctx *ctx);
	int (*pre_schedule_cs)(struct hl_cs *cs);
	u32 (*get_queue_id_for_cq)(struct hl_device *hdev, u32 cq_idx);
	int (*load_firmware_to_device)(struct hl_device *hdev);
	int (*load_boot_fit_to_device)(struct hl_device *hdev);
	u32 (*get_signal_cb_size)(struct hl_device *hdev);
	u32 (*get_wait_cb_size)(struct hl_device *hdev);
	u32 (*gen_signal_cb)(struct hl_device *hdev, void *data, u16 sob_id, u32 size, bool eb);
	u32 (*gen_wait_cb)(struct hl_device *hdev, struct hl_gen_wait_properties *prop);
	void (*reset_sob)(struct hl_device *hdev, void *data);
	void (*reset_sob_group)(struct hl_device *hdev, u16 sob_group);
	u64 (*get_device_time)(struct hl_device *hdev);
	void (*pb_print_security_errors)(struct hl_device *hdev, u32 block_addr, u32 cause, u32 offended_addr);
	int (*collective_wait_init_cs)(struct hl_cs *cs);
	int (*collective_wait_create_jobs)(struct hl_device *hdev, struct hl_ctx *ctx, struct hl_cs *cs, u32 wait_queue_id, u32 collective_engine_id, u32 encaps_signal_offset);


	u32 (*get_dec_base_addr)(struct hl_device *hdev, u32 core_id);
	u64 (*scramble_addr)(struct hl_device *hdev, u64 addr);
	u64 (*descramble_addr)(struct hl_device *hdev, u64 addr);
	void (*ack_protection_bits_errors)(struct hl_device *hdev);
	int (*get_hw_block_id)(struct hl_device *hdev, u64 block_addr, u32 *block_size, u32 *block_id);
	int (*hw_block_mmap)(struct hl_device *hdev, struct vm_area_struct *vma, u32 block_id, u32 block_size);
	void (*enable_events_from_fw)(struct hl_device *hdev);
	int (*ack_mmu_errors)(struct hl_device *hdev, u64 mmu_cap_mask);
	void (*get_msi_info)(__le32 *table);
	int (*map_pll_idx_to_fw_idx)(u32 pll_idx);
	void (*init_firmware_preload_params)(struct hl_device *hdev);
	void (*init_firmware_loader)(struct hl_device *hdev);
	void (*init_cpu_scrambler_dram)(struct hl_device *hdev);
	void (*state_dump_init)(struct hl_device *hdev);
	u32 (*get_sob_addr)(struct hl_device *hdev, u32 sob_id);
	void (*set_pci_memory_regions)(struct hl_device *hdev);
	u32* (*get_stream_master_qid_arr)(void);
	void (*check_if_razwi_happened)(struct hl_device *hdev);
	int (*mmu_get_real_page_size)(struct hl_device *hdev, struct hl_mmu_properties *mmu_prop, u32 page_size, u32 *real_page_size, bool is_dram_addr);
	int (*access_dev_mem)(struct hl_device *hdev, enum pci_region region_type, u64 addr, u64 *val, enum debugfs_access_type acc_type);
	u64 (*set_dram_bar_base)(struct hl_device *hdev, u64 addr);
	int (*set_engine_cores)(struct hl_device *hdev, u32 *core_ids, u32 num_cores, u32 core_command);
	int (*send_device_activity)(struct hl_device *hdev, bool open);
};







enum hl_va_range_type {
	HL_VA_RANGE_TYPE_HOST, HL_VA_RANGE_TYPE_HOST_HUGE, HL_VA_RANGE_TYPE_DRAM, HL_VA_RANGE_TYPE_MAX };





struct hl_va_range {
	struct mutex		lock;
	struct list_head	list;
	u64			start_addr;
	u64			end_addr;
	u32			page_size;
};


struct hl_cs_counters_atomic {
	atomic64_t out_of_mem_drop_cnt;
	atomic64_t parsing_drop_cnt;
	atomic64_t queue_full_drop_cnt;
	atomic64_t device_in_reset_drop_cnt;
	atomic64_t max_cs_in_flight_drop_cnt;
	atomic64_t validation_drop_cnt;
};


struct hl_dmabuf_priv {
	struct dma_buf			*dmabuf;
	struct hl_ctx			*ctx;
	struct hl_vm_phys_pg_pack	*phys_pg_pack;
	uint64_t			device_address;
};




struct hl_cs_outcome {
	struct list_head list_link;
	struct hlist_node map_link;
	ktime_t ts;
	u64 seq;
	int error;
};


struct hl_cs_outcome_store {
	DECLARE_HASHTABLE(outcome_map, 8);
	struct list_head used_list;
	struct list_head free_list;
	struct hl_cs_outcome nodes_pool[HL_CS_OUTCOME_HISTORY_LEN];
	spinlock_t db_lock;
};


struct hl_ctx {
	DECLARE_HASHTABLE(mem_hash, MEM_HASH_TABLE_BITS);
	DECLARE_HASHTABLE(mmu_shadow_hash, MMU_HASH_TABLE_BITS);
	DECLARE_HASHTABLE(hr_mmu_phys_hash, MMU_HASH_TABLE_BITS);
	struct hl_fpriv			*hpriv;
	struct hl_device		*hdev;
	struct kref			refcount;
	struct hl_fence			**cs_pending;
	struct hl_cs_outcome_store	outcome_store;
	struct hl_va_range		*va_range[HL_VA_RANGE_TYPE_MAX];
	struct mutex			mem_hash_lock;
	struct mutex			hw_block_list_lock;
	struct list_head		debugfs_list;
	struct list_head		hw_block_mem_list;
	struct hl_cs_counters_atomic	cs_counters;
	struct gen_pool			*cb_va_pool;
	struct hl_encaps_signals_mgr	sig_mgr;
	u64				cb_va_pool_base;
	u64				cs_sequence;
	u64				*dram_default_hops;
	spinlock_t			cs_lock;
	atomic64_t			dram_phys_mem;
	atomic_t			thread_ctx_switch_token;
	u32				thread_ctx_switch_wait_token;
	u32				asid;
	u32				handle;
};


struct hl_ctx_mgr {
	struct mutex	lock;
	struct idr	handles;
};





struct hl_userptr {
	enum vm_type		vm_type; 
	struct list_head	job_node;
	struct page		**pages;
	unsigned int		npages;
	struct sg_table		*sgt;
	enum dma_data_direction dir;
	struct list_head	debugfs_list;
	pid_t			pid;
	u64			addr;
	u64			size;
	u8			dma_mapped;
};


struct hl_cs {
	u16			*jobs_in_queue_cnt;
	struct hl_ctx		*ctx;
	struct list_head	job_list;
	spinlock_t		job_lock;
	struct kref		refcount;
	struct hl_fence		*fence;
	struct hl_fence		*signal_fence;
	struct work_struct	finish_work;
	struct delayed_work	work_tdr;
	struct list_head	mirror_node;
	struct list_head	staged_cs_node;
	struct list_head	debugfs_list;
	struct hl_cs_encaps_sig_handle *encaps_sig_hdl;
	u64			sequence;
	u64			staged_sequence;
	u64			timeout_jiffies;
	u64			submission_time_jiffies;
	enum hl_cs_type		type;
	u32			jobs_cnt;
	u32			encaps_sig_hdl_id;
	u32			sob_addr_offset;
	u16			initial_sob_count;
	u8			submitted;
	u8			completed;
	u8			timedout;
	u8			tdr_active;
	u8			aborted;
	u8			timestamp;
	u8			staged_last;
	u8			staged_first;
	u8			staged_cs;
	u8			skip_reset_on_timeout;
	u8			encaps_signals;
};


struct hl_cs_job {
	struct list_head	cs_node;
	struct hl_cs		*cs;
	struct hl_cb		*user_cb;
	struct hl_cb		*patched_cb;
	struct work_struct	finish_work;
	struct list_head	userptr_list;
	struct list_head	debugfs_list;
	struct kref		refcount;
	enum hl_queue_type	queue_type;
	u32			id;
	u32			hw_queue_id;
	u32			user_cb_size;
	u32			job_cb_size;
	u32			encaps_sig_wait_offset;
	u8			is_kernel_allocated_cb;
	u8			contains_dma_pkt;
};


struct hl_cs_parser {
	struct hl_cb		*user_cb;
	struct hl_cb		*patched_cb;
	struct list_head	*job_userptr_list;
	u64			cs_sequence;
	enum hl_queue_type	queue_type;
	u32			ctx_id;
	u32			hw_queue_id;
	u32			user_cb_size;
	u32			patched_cb_size;
	u8			job_id;
	u8			is_kernel_allocated_cb;
	u8			contains_dma_pkt;
	u8			completion;
};




struct hl_vm_hash_node {
	struct hlist_node	node;
	u64			vaddr;
	void			*ptr;
};


struct hl_vm_hw_block_list_node {
	struct list_head	node;
	struct hl_ctx		*ctx;
	unsigned long		vaddr;
	u32			block_size;
	u32			mapped_size;
	u32			id;
};


struct hl_vm_phys_pg_pack {
	enum vm_type		vm_type; 
	u64			*pages;
	u64			npages;
	u64			total_size;
	struct list_head	node;
	atomic_t		mapping_cnt;
	u32			exporting_cnt;
	u32			asid;
	u32			page_size;
	u32			flags;
	u32			handle;
	u32			offset;
	u8			contiguous;
	u8			created_from_userptr;
};


struct hl_vm_va_block {
	struct list_head	node;
	u64			start;
	u64			end;
	u64			size;
};


struct hl_vm {
	struct gen_pool		*dram_pg_pool;
	struct kref		dram_pg_pool_refcount;
	spinlock_t		idr_lock;
	struct idr		phys_pg_pack_handles;
	u8			init_done;
};





struct hl_debug_params {
	void *input;
	void *output;
	u32 output_size;
	u32 reg_idx;
	u32 op;
	bool enable;
};


struct hl_notifier_event {
	struct eventfd_ctx	*eventfd;
	struct mutex		lock;
	u64			events_mask;
};




struct hl_fpriv {
	struct hl_device		*hdev;
	struct file			*filp;
	struct pid			*taskpid;
	struct hl_ctx			*ctx;
	struct hl_ctx_mgr		ctx_mgr;
	struct hl_mem_mgr		mem_mgr;
	struct hl_notifier_event	notifier_event;
	struct list_head		debugfs_list;
	struct list_head		dev_node;
	struct kref			refcount;
	struct mutex			restore_phase_mutex;
	struct mutex			ctx_lock;
};





struct hl_info_list {
	const char	*name;
	int		(*show)(struct seq_file *s, void *data);
	ssize_t		(*write)(struct file *file, const char __user *buf, size_t count, loff_t *f_pos);
};


struct hl_debugfs_entry {
	const struct hl_info_list	*info_ent;
	struct hl_dbg_device_entry	*dev_entry;
};


struct hl_dbg_device_entry {
	struct dentry			*root;
	struct hl_device		*hdev;
	struct hl_debugfs_entry		*entry_arr;
	struct list_head		file_list;
	struct mutex			file_mutex;
	struct list_head		cb_list;
	spinlock_t			cb_spinlock;
	struct list_head		cs_list;
	spinlock_t			cs_spinlock;
	struct list_head		cs_job_list;
	spinlock_t			cs_job_spinlock;
	struct list_head		userptr_list;
	spinlock_t			userptr_spinlock;
	struct list_head		ctx_mem_hash_list;
	spinlock_t			ctx_mem_hash_spinlock;
	struct debugfs_blob_wrapper	data_dma_blob_desc;
	struct debugfs_blob_wrapper	mon_dump_blob_desc;
	char				*state_dump[HL_STATE_DUMP_HIST_LEN];
	struct rw_semaphore		state_dump_sem;
	u64				addr;
	u64				mmu_addr;
	u64				mmu_cap_mask;
	u64				userptr_lookup;
	u32				mmu_asid;
	u32				state_dump_head;
	u8				i2c_bus;
	u8				i2c_addr;
	u8				i2c_reg;
	u8				i2c_len;
};


struct hl_hw_obj_name_entry {
	struct hlist_node	node;
	const char		*name;
	u32			id;
};

enum hl_state_dump_specs_props {
	SP_SYNC_OBJ_BASE_ADDR, SP_NEXT_SYNC_OBJ_ADDR, SP_SYNC_OBJ_AMOUNT, SP_MON_OBJ_WR_ADDR_LOW, SP_MON_OBJ_WR_ADDR_HIGH, SP_MON_OBJ_WR_DATA, SP_MON_OBJ_ARM_DATA, SP_MON_OBJ_STATUS, SP_MONITORS_AMOUNT, SP_TPC0_CMDQ, SP_TPC0_CFG_SO, SP_NEXT_TPC, SP_MME_CMDQ, SP_MME_CFG_SO, SP_NEXT_MME, SP_DMA_CMDQ, SP_DMA_CFG_SO, SP_DMA_QUEUES_OFFSET, SP_NUM_OF_MME_ENGINES, SP_SUB_MME_ENG_NUM, SP_NUM_OF_DMA_ENGINES, SP_NUM_OF_TPC_ENGINES, SP_ENGINE_NUM_OF_QUEUES, SP_ENGINE_NUM_OF_STREAMS, SP_ENGINE_NUM_OF_FENCES, SP_FENCE0_CNT_OFFSET, SP_FENCE0_RDATA_OFFSET, SP_CP_STS_OFFSET, SP_NUM_CORES,  SP_MAX };































enum hl_sync_engine_type {
	ENGINE_TPC, ENGINE_DMA, ENGINE_MME, };




struct hl_mon_state_dump {
	u32		id;
	u32		wr_addr_low;
	u32		wr_addr_high;
	u32		wr_data;
	u32		arm_data;
	u32		status;
};


struct hl_sync_to_engine_map_entry {
	struct hlist_node		node;
	enum hl_sync_engine_type	engine_type;
	u32				engine_id;
	u32				sync_id;
};


struct hl_sync_to_engine_map {
	DECLARE_HASHTABLE(tb, SYNC_TO_ENGINE_HASH_TABLE_BITS);
};


struct hl_state_dump_specs_funcs {
	int (*gen_sync_to_engine_map)(struct hl_device *hdev, struct hl_sync_to_engine_map *map);
	int (*print_single_monitor)(char **buf, size_t *size, size_t *offset, struct hl_device *hdev, struct hl_mon_state_dump *mon);

	int (*monitor_valid)(struct hl_mon_state_dump *mon);
	int (*print_fences_single_engine)(struct hl_device *hdev, u64 base_offset, u64 status_base_offset, enum hl_sync_engine_type engine_type, u32 engine_id, char **buf, size_t *size, size_t *offset);




};


struct hl_state_dump_specs {
	DECLARE_HASHTABLE(so_id_to_str_tb, OBJ_NAMES_HASH_TABLE_BITS);
	DECLARE_HASHTABLE(monitor_id_to_str_tb, OBJ_NAMES_HASH_TABLE_BITS);
	struct hl_state_dump_specs_funcs	funcs;
	const char * const			*sync_namager_names;
	s64					*props;
};













u32 hl_rreg(struct hl_device *hdev, u32 reg);
void hl_wreg(struct hl_device *hdev, u32 reg, u32 val);














































































































































































struct hwmon_chip_info;


struct hl_device_reset_work {
	struct workqueue_struct		*wq;
	struct delayed_work		reset_work;
	struct hl_device		*hdev;
	u32				flags;
};


struct hl_mmu_hr_priv {
	struct gen_pool	*mmu_pgt_pool;
	struct pgt_info	*mmu_asid_hop0;
};


struct hl_mmu_dr_priv {
	struct gen_pool *mmu_pgt_pool;
	void *mmu_shadow_hop0;
};


struct hl_mmu_priv {
	struct hl_mmu_dr_priv dr;
	struct hl_mmu_hr_priv hr;
};


struct hl_mmu_per_hop_info {
	u64 hop_addr;
	u64 hop_pte_addr;
	u64 hop_pte_val;
};


struct hl_mmu_hop_info {
	u64 scrambled_vaddr;
	u64 unscrambled_paddr;
	struct hl_mmu_per_hop_info hop_info[MMU_ARCH_6_HOPS];
	u32 used_hops;
	enum hl_va_range_type range_type;
};


struct hl_hr_mmu_funcs {
	struct pgt_info *(*get_hop0_pgt_info)(struct hl_ctx *ctx);
	struct pgt_info *(*get_pgt_info)(struct hl_ctx *ctx, u64 phys_hop_addr);
	void (*add_pgt_info)(struct hl_ctx *ctx, struct pgt_info *pgt_info, dma_addr_t phys_addr);
	int (*get_tlb_mapping_params)(struct hl_device *hdev, struct hl_mmu_properties **mmu_prop, struct hl_mmu_hop_info *hops, u64 virt_addr, bool *is_huge);

};


struct hl_mmu_funcs {
	int (*init)(struct hl_device *hdev);
	void (*fini)(struct hl_device *hdev);
	int (*ctx_init)(struct hl_ctx *ctx);
	void (*ctx_fini)(struct hl_ctx *ctx);
	int (*map)(struct hl_ctx *ctx, u64 virt_addr, u64 phys_addr, u32 page_size, bool is_dram_addr);
	int (*unmap)(struct hl_ctx *ctx, u64 virt_addr, bool is_dram_addr);
	void (*flush)(struct hl_ctx *ctx);
	void (*swap_out)(struct hl_ctx *ctx);
	void (*swap_in)(struct hl_ctx *ctx);
	int (*get_tlb_info)(struct hl_ctx *ctx, u64 virt_addr, struct hl_mmu_hop_info *hops);
	struct hl_hr_mmu_funcs hr_funcs;
};


struct hl_prefetch_work {
	struct work_struct	pf_work;
	struct hl_ctx		*ctx;
	u64			va;
	u64			size;
	u32			flags;
	u32			asid;
};





struct multi_cs_completion {
	struct completion	completion;
	spinlock_t		lock;
	s64			timestamp;
	u32			stream_master_qid_map;
	u8			used;
};


struct multi_cs_data {
	struct hl_ctx	*ctx;
	struct hl_fence	**fence_arr;
	u64		*seq_arr;
	s64		timeout_jiffies;
	s64		timestamp;
	long		wait_status;
	u32		completion_bitmap;
	u8		arr_len;
	u8		gone_cs;
	u8		update_ts;
};


struct hl_clk_throttle_timestamp {
	ktime_t		start;
	ktime_t		end;
};


struct hl_clk_throttle {
	struct hl_clk_throttle_timestamp timestamp[HL_CLK_THROTTLE_TYPE_MAX];
	struct mutex	lock;
	u32		current_reason;
	u32		aggregated_reason;
};


struct user_mapped_block {
	u32 address;
	u32 size;
};


struct cs_timeout_info {
	ktime_t		timestamp;
	atomic_t	write_enable;
	u64		seq;
};


struct razwi_info {
	ktime_t		timestamp;
	atomic_t	write_enable;
	u64		addr;
	u16		engine_id_1;
	u16		engine_id_2;
	u8		non_engine_initiator;
	u8		type;
};




struct undefined_opcode_info {
	ktime_t timestamp;
	u64 cb_addr_streams[MAX_QMAN_STREAMS_INFO][OPCODE_INFO_MAX_ADDR_SIZE];
	u64 cq_addr;
	u32 cq_size;
	u32 cb_addr_streams_len;
	u32 engine_id;
	u32 stream_id;
	bool write_enable;
};


struct hl_error_info {
	struct cs_timeout_info		cs_timeout;
	struct razwi_info		razwi;
	struct undefined_opcode_info	undef_opcode;
};


struct hl_reset_info {
	spinlock_t	lock;
	u32		compute_reset_cnt;
	u32		hard_reset_cnt;
	u32		hard_reset_schedule_flags;
	u8		in_reset;
	u8		in_compute_reset;
	u8		needs_reset;
	u8		hard_reset_pending;

	u8		curr_reset_cause;
	u8		prev_reset_trigger;
	u8		reset_trigger_repeated;

	u8		skip_reset_on_timeout;
};


struct hl_device {
	struct pci_dev			*pdev;
	u64				pcie_bar_phys[HL_PCI_NUM_BARS];
	void __iomem			*pcie_bar[HL_PCI_NUM_BARS];
	void __iomem			*rmmio;
	struct cdev			cdev;
	struct cdev			cdev_ctrl;
	struct device			*dev;
	struct device			*dev_ctrl;
	struct delayed_work		work_heartbeat;
	struct hl_device_reset_work	device_reset_work;
	char				asic_name[HL_STR_MAX];
	char				status[HL_DEV_STS_MAX][HL_STR_MAX];
	enum hl_asic_type		asic_type;
	struct hl_cq			*completion_queue;
	struct hl_user_interrupt	*user_interrupt;
	struct hl_user_interrupt	common_user_cq_interrupt;
	struct hl_user_interrupt	common_decoder_interrupt;
	struct hl_cs			**shadow_cs_queue;
	struct workqueue_struct		**cq_wq;
	struct workqueue_struct		*eq_wq;
	struct workqueue_struct		*cs_cmplt_wq;
	struct workqueue_struct		*ts_free_obj_wq;
	struct workqueue_struct		*pf_wq;
	struct hl_ctx			*kernel_ctx;
	struct hl_hw_queue		*kernel_queues;
	struct list_head		cs_mirror_list;
	spinlock_t			cs_mirror_lock;
	struct hl_mem_mgr		kernel_mem_mgr;
	struct hl_eq			event_queue;
	struct dma_pool			*dma_pool;
	void				*cpu_accessible_dma_mem;
	dma_addr_t			cpu_accessible_dma_address;
	struct gen_pool			*cpu_accessible_dma_pool;
	unsigned long			*asid_bitmap;
	struct mutex			asid_mutex;
	struct mutex			send_cpu_message_lock;
	struct mutex			debug_lock;
	struct mutex			mmu_lock;
	struct asic_fixed_properties	asic_prop;
	const struct hl_asic_funcs	*asic_funcs;
	void				*asic_specific;
	struct hl_vm			vm;
	struct device			*hwmon_dev;
	struct hwmon_chip_info		*hl_chip_info;

	struct hl_dbg_device_entry	hl_debugfs;

	struct list_head		cb_pool;
	spinlock_t			cb_pool_lock;

	void				*internal_cb_pool_virt_addr;
	dma_addr_t			internal_cb_pool_dma_addr;
	struct gen_pool			*internal_cb_pool;
	u64				internal_cb_va_base;

	struct list_head		fpriv_list;
	struct list_head		fpriv_ctrl_list;
	struct mutex			fpriv_list_lock;
	struct mutex			fpriv_ctrl_list_lock;

	struct hl_cs_counters_atomic	aggregated_cs_counters;

	struct hl_mmu_priv		mmu_priv;
	struct hl_mmu_funcs		mmu_func[MMU_NUM_PGT_LOCATIONS];

	struct hl_dec			*dec;

	struct fw_load_mgr		fw_loader;

	struct pci_mem_region		pci_mem_region[PCI_REGION_NUMBER];

	struct hl_state_dump_specs	state_dump_specs;

	struct multi_cs_completion	multi_cs_completion[ MULTI_CS_MAX_USER_CTX];
	struct hl_clk_throttle		clk_throttling;
	struct hl_error_info		captured_err_info;

	struct hl_reset_info		reset_info;

	u32				*stream_master_qid_arr;
	u32				fw_major_version;
	u32				fw_minor_version;
	atomic64_t			dram_used_mem;
	u64				memory_scrub_val;
	u64				timeout_jiffies;
	u64				max_power;
	u64				boot_error_status_mask;
	u64				dram_pci_bar_start;
	u64				last_successful_open_jif;
	u64				last_open_session_duration_jif;
	u64				open_counter;
	u64				fw_poll_interval_usec;
	ktime_t				last_successful_open_ktime;
	u64				fw_comms_poll_interval_usec;
	u64				dram_binning;
	u64				tpc_binning;

	enum cpucp_card_types		card_type;
	u32				major;
	u32				high_pll;
	u32				decoder_binning;
	u32				edma_binning;
	u16				id;
	u16				id_control;
	u16				cdev_idx;
	u16				cpu_pci_msb_addr;
	u8				is_in_dram_scrub;
	u8				disabled;
	u8				late_init_done;
	u8				hwmon_initialized;
	u8				reset_on_lockup;
	u8				dram_default_page_mapping;
	u8				memory_scrub;
	u8				pmmu_huge_range;
	u8				init_done;
	u8				device_cpu_disabled;
	u8				in_debug;
	u8				cdev_sysfs_created;
	u8				stop_on_err;
	u8				supports_sync_stream;
	u8				sync_stream_queue_idx;
	u8				collective_mon_idx;
	u8				supports_coresight;
	u8				supports_cb_mapping;
	u8				process_kill_trial_cnt;
	u8				device_fini_pending;
	u8				supports_staged_submission;
	u8				device_cpu_is_halted;
	u8				supports_wait_for_multi_cs;
	u8				stream_master_qid_arr_size;
	u8				is_compute_ctx_active;
	u8				compute_ctx_in_release;
	u8				supports_mmu_prefetch;
	u8				reset_upon_device_release;
	u8				supports_ctx_switch;

	
	u64				nic_ports_mask;
	u64				fw_components;
	u8				mmu_enable;
	u8				cpu_queues_enable;
	u8				pldm;
	u8				hard_reset_on_fw_events;
	u8				bmc_enable;
	u8				reset_on_preboot_fail;
	u8				heartbeat;
};



struct hl_cs_encaps_sig_handle {
	struct kref refcount;
	struct hl_device *hdev;
	struct hl_hw_sob *hw_sob;
	struct hl_ctx *ctx;
	u64  cs_seq;
	u32  id;
	u32  q_idx;
	u32  pre_sob_val;
	u32  count;
};




typedef int hl_ioctl_t(struct hl_fpriv *hpriv, void *data);


struct hl_ioctl_desc {
	unsigned int cmd;
	hl_ioctl_t *func;
};





static inline u32 hl_get_sg_info(struct scatterlist *sg, dma_addr_t *dma_addr)
{
	*dma_addr = sg_dma_address(sg);

	return ((((*dma_addr) & (PAGE_SIZE - 1)) + sg_dma_len(sg)) + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
}


static inline bool hl_mem_area_inside_range(u64 address, u64 size, u64 range_start_address, u64 range_end_address)
{
	u64 end_address = address + size;

	if ((address >= range_start_address) && (end_address <= range_end_address) && (end_address > address))

		return true;

	return false;
}


static inline bool hl_mem_area_crosses_range(u64 address, u32 size, u64 range_start_address, u64 range_end_address)
{
	u64 end_address = address + size - 1;

	return ((address <= range_end_address) && (range_start_address <= end_address));
}

uint64_t hl_set_dram_bar_default(struct hl_device *hdev, u64 addr);
void *hl_asic_dma_alloc_coherent_caller(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle, gfp_t flag, const char *caller);
void hl_asic_dma_free_coherent_caller(struct hl_device *hdev, size_t size, void *cpu_addr, dma_addr_t dma_handle, const char *caller);
void *hl_cpu_accessible_dma_pool_alloc_caller(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle, const char *caller);
void hl_cpu_accessible_dma_pool_free_caller(struct hl_device *hdev, size_t size, void *vaddr, const char *caller);
void *hl_asic_dma_pool_zalloc_caller(struct hl_device *hdev, size_t size, gfp_t mem_flags, dma_addr_t *dma_handle, const char *caller);
void hl_asic_dma_pool_free_caller(struct hl_device *hdev, void *vaddr, dma_addr_t dma_addr, const char *caller);
int hl_dma_map_sgtable(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir);
void hl_dma_unmap_sgtable(struct hl_device *hdev, struct sg_table *sgt, enum dma_data_direction dir);
int hl_access_cfg_region(struct hl_device *hdev, u64 addr, u64 *val, enum debugfs_access_type acc_type);
int hl_access_dev_mem(struct hl_device *hdev, enum pci_region region_type, u64 addr, u64 *val, enum debugfs_access_type acc_type);
int hl_device_open(struct inode *inode, struct file *filp);
int hl_device_open_ctrl(struct inode *inode, struct file *filp);
bool hl_device_operational(struct hl_device *hdev, enum hl_device_status *status);
enum hl_device_status hl_device_status(struct hl_device *hdev);
int hl_device_set_debug_mode(struct hl_device *hdev, struct hl_ctx *ctx, bool enable);
int hl_hw_queues_create(struct hl_device *hdev);
void hl_hw_queues_destroy(struct hl_device *hdev);
int hl_hw_queue_send_cb_no_cmpl(struct hl_device *hdev, u32 hw_queue_id, u32 cb_size, u64 cb_ptr);
void hl_hw_queue_submit_bd(struct hl_device *hdev, struct hl_hw_queue *q, u32 ctl, u32 len, u64 ptr);
int hl_hw_queue_schedule_cs(struct hl_cs *cs);
u32 hl_hw_queue_add_ptr(u32 ptr, u16 val);
void hl_hw_queue_inc_ci_kernel(struct hl_device *hdev, u32 hw_queue_id);
void hl_hw_queue_update_ci(struct hl_cs *cs);
void hl_hw_queue_reset(struct hl_device *hdev, bool hard_reset);




int hl_cq_init(struct hl_device *hdev, struct hl_cq *q, u32 hw_queue_id);
void hl_cq_fini(struct hl_device *hdev, struct hl_cq *q);
int hl_eq_init(struct hl_device *hdev, struct hl_eq *q);
void hl_eq_fini(struct hl_device *hdev, struct hl_eq *q);
void hl_cq_reset(struct hl_device *hdev, struct hl_cq *q);
void hl_eq_reset(struct hl_device *hdev, struct hl_eq *q);
irqreturn_t hl_irq_handler_cq(int irq, void *arg);
irqreturn_t hl_irq_handler_eq(int irq, void *arg);
irqreturn_t hl_irq_handler_dec_abnrm(int irq, void *arg);
irqreturn_t hl_irq_handler_user_interrupt(int irq, void *arg);
irqreturn_t hl_irq_handler_default(int irq, void *arg);
u32 hl_cq_inc_ptr(u32 ptr);

int hl_asid_init(struct hl_device *hdev);
void hl_asid_fini(struct hl_device *hdev);
unsigned long hl_asid_alloc(struct hl_device *hdev);
void hl_asid_free(struct hl_device *hdev, unsigned long asid);

int hl_ctx_create(struct hl_device *hdev, struct hl_fpriv *hpriv);
void hl_ctx_free(struct hl_device *hdev, struct hl_ctx *ctx);
int hl_ctx_init(struct hl_device *hdev, struct hl_ctx *ctx, bool is_kernel_ctx);
void hl_ctx_do_release(struct kref *ref);
void hl_ctx_get(struct hl_ctx *ctx);
int hl_ctx_put(struct hl_ctx *ctx);
struct hl_ctx *hl_get_compute_ctx(struct hl_device *hdev);
struct hl_fence *hl_ctx_get_fence(struct hl_ctx *ctx, u64 seq);
int hl_ctx_get_fences(struct hl_ctx *ctx, u64 *seq_arr, struct hl_fence **fence, u32 arr_len);
void hl_ctx_mgr_init(struct hl_ctx_mgr *mgr);
void hl_ctx_mgr_fini(struct hl_device *hdev, struct hl_ctx_mgr *mgr);

int hl_device_init(struct hl_device *hdev, struct class *hclass);
void hl_device_fini(struct hl_device *hdev);
int hl_device_suspend(struct hl_device *hdev);
int hl_device_resume(struct hl_device *hdev);
int hl_device_reset(struct hl_device *hdev, u32 flags);
void hl_hpriv_get(struct hl_fpriv *hpriv);
int hl_hpriv_put(struct hl_fpriv *hpriv);
int hl_device_utilization(struct hl_device *hdev, u32 *utilization);

int hl_build_hwmon_channel_info(struct hl_device *hdev, struct cpucp_sensor *sensors_arr);

void hl_notifier_event_send_all(struct hl_device *hdev, u64 event_mask);

int hl_sysfs_init(struct hl_device *hdev);
void hl_sysfs_fini(struct hl_device *hdev);

int hl_hwmon_init(struct hl_device *hdev);
void hl_hwmon_fini(struct hl_device *hdev);
void hl_hwmon_release_resources(struct hl_device *hdev);

int hl_cb_create(struct hl_device *hdev, struct hl_mem_mgr *mmg, struct hl_ctx *ctx, u32 cb_size, bool internal_cb, bool map_cb, u64 *handle);

int hl_cb_destroy(struct hl_mem_mgr *mmg, u64 cb_handle);
int hl_hw_block_mmap(struct hl_fpriv *hpriv, struct vm_area_struct *vma);
struct hl_cb *hl_cb_get(struct hl_mem_mgr *mmg, u64 handle);
void hl_cb_put(struct hl_cb *cb);
struct hl_cb *hl_cb_kernel_create(struct hl_device *hdev, u32 cb_size, bool internal_cb);
int hl_cb_pool_init(struct hl_device *hdev);
int hl_cb_pool_fini(struct hl_device *hdev);
int hl_cb_va_pool_init(struct hl_ctx *ctx);
void hl_cb_va_pool_fini(struct hl_ctx *ctx);

void hl_cs_rollback_all(struct hl_device *hdev, bool skip_wq_flush);
struct hl_cs_job *hl_cs_allocate_job(struct hl_device *hdev, enum hl_queue_type queue_type, bool is_kernel_allocated_cb);
void hl_sob_reset_error(struct kref *ref);
int hl_gen_sob_mask(u16 sob_base, u8 sob_mask, u8 *mask);
void hl_fence_put(struct hl_fence *fence);
void hl_fences_put(struct hl_fence **fence, int len);
void hl_fence_get(struct hl_fence *fence);
void cs_get(struct hl_cs *cs);
bool cs_needs_completion(struct hl_cs *cs);
bool cs_needs_timeout(struct hl_cs *cs);
bool is_staged_cs_last_exists(struct hl_device *hdev, struct hl_cs *cs);
struct hl_cs *hl_staged_cs_find_first(struct hl_device *hdev, u64 cs_seq);
void hl_multi_cs_completion_init(struct hl_device *hdev);

void goya_set_asic_funcs(struct hl_device *hdev);
void gaudi_set_asic_funcs(struct hl_device *hdev);
void gaudi2_set_asic_funcs(struct hl_device *hdev);

int hl_vm_ctx_init(struct hl_ctx *ctx);
void hl_vm_ctx_fini(struct hl_ctx *ctx);

int hl_vm_init(struct hl_device *hdev);
void hl_vm_fini(struct hl_device *hdev);

void hl_hw_block_mem_init(struct hl_ctx *ctx);
void hl_hw_block_mem_fini(struct hl_ctx *ctx);

u64 hl_reserve_va_block(struct hl_device *hdev, struct hl_ctx *ctx, enum hl_va_range_type type, u64 size, u32 alignment);
int hl_unreserve_va_block(struct hl_device *hdev, struct hl_ctx *ctx, u64 start_addr, u64 size);
int hl_pin_host_memory(struct hl_device *hdev, u64 addr, u64 size, struct hl_userptr *userptr);
void hl_unpin_host_memory(struct hl_device *hdev, struct hl_userptr *userptr);
void hl_userptr_delete_list(struct hl_device *hdev, struct list_head *userptr_list);
bool hl_userptr_is_pinned(struct hl_device *hdev, u64 addr, u32 size, struct list_head *userptr_list, struct hl_userptr **userptr);


int hl_mmu_init(struct hl_device *hdev);
void hl_mmu_fini(struct hl_device *hdev);
int hl_mmu_ctx_init(struct hl_ctx *ctx);
void hl_mmu_ctx_fini(struct hl_ctx *ctx);
int hl_mmu_map_page(struct hl_ctx *ctx, u64 virt_addr, u64 phys_addr, u32 page_size, bool flush_pte);
int hl_mmu_get_real_page_size(struct hl_device *hdev, struct hl_mmu_properties *mmu_prop, u32 page_size, u32 *real_page_size, bool is_dram_addr);
int hl_mmu_unmap_page(struct hl_ctx *ctx, u64 virt_addr, u32 page_size, bool flush_pte);
int hl_mmu_map_contiguous(struct hl_ctx *ctx, u64 virt_addr, u64 phys_addr, u32 size);
int hl_mmu_unmap_contiguous(struct hl_ctx *ctx, u64 virt_addr, u32 size);
int hl_mmu_invalidate_cache(struct hl_device *hdev, bool is_hard, u32 flags);
int hl_mmu_invalidate_cache_range(struct hl_device *hdev, bool is_hard, u32 flags, u32 asid, u64 va, u64 size);
int hl_mmu_prefetch_cache_range(struct hl_ctx *ctx, u32 flags, u32 asid, u64 va, u64 size);
u64 hl_mmu_get_next_hop_addr(struct hl_ctx *ctx, u64 curr_pte);
u64 hl_mmu_get_hop_pte_phys_addr(struct hl_ctx *ctx, struct hl_mmu_properties *mmu_prop, u8 hop_idx, u64 hop_addr, u64 virt_addr);
void hl_mmu_hr_flush(struct hl_ctx *ctx);
int hl_mmu_hr_init(struct hl_device *hdev, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size, u64 pgt_size);
void hl_mmu_hr_fini(struct hl_device *hdev, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size);
void hl_mmu_hr_free_hop_remove_pgt(struct pgt_info *pgt_info, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size);
u64 hl_mmu_hr_pte_phys_to_virt(struct hl_ctx *ctx, struct pgt_info *pgt, u64 phys_pte_addr, u32 hop_table_size);
void hl_mmu_hr_write_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info, u64 phys_pte_addr, u64 val, u32 hop_table_size);
void hl_mmu_hr_clear_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info, u64 phys_pte_addr, u32 hop_table_size);
int hl_mmu_hr_put_pte(struct hl_ctx *ctx, struct pgt_info *pgt_info, struct hl_mmu_hr_priv *hr_priv, u32 hop_table_size);
void hl_mmu_hr_get_pte(struct hl_ctx *ctx, struct hl_hr_mmu_funcs *hr_func, u64 phys_hop_addr);
struct pgt_info *hl_mmu_hr_get_next_hop_pgt_info(struct hl_ctx *ctx, struct hl_hr_mmu_funcs *hr_func, u64 curr_pte);

struct pgt_info *hl_mmu_hr_alloc_hop(struct hl_ctx *ctx, struct hl_mmu_hr_priv *hr_priv, struct hl_hr_mmu_funcs *hr_func, struct hl_mmu_properties *mmu_prop);

struct pgt_info *hl_mmu_hr_get_alloc_next_hop(struct hl_ctx *ctx, struct hl_mmu_hr_priv *hr_priv, struct hl_hr_mmu_funcs *hr_func, struct hl_mmu_properties *mmu_prop, u64 curr_pte, bool *is_new_hop);



int hl_mmu_hr_get_tlb_info(struct hl_ctx *ctx, u64 virt_addr, struct hl_mmu_hop_info *hops, struct hl_hr_mmu_funcs *hr_func);
void hl_mmu_swap_out(struct hl_ctx *ctx);
void hl_mmu_swap_in(struct hl_ctx *ctx);
int hl_mmu_if_set_funcs(struct hl_device *hdev);
void hl_mmu_v1_set_funcs(struct hl_device *hdev, struct hl_mmu_funcs *mmu);
void hl_mmu_v2_hr_set_funcs(struct hl_device *hdev, struct hl_mmu_funcs *mmu);
int hl_mmu_va_to_pa(struct hl_ctx *ctx, u64 virt_addr, u64 *phys_addr);
int hl_mmu_get_tlb_info(struct hl_ctx *ctx, u64 virt_addr, struct hl_mmu_hop_info *hops);
u64 hl_mmu_scramble_addr(struct hl_device *hdev, u64 addr);
u64 hl_mmu_descramble_addr(struct hl_device *hdev, u64 addr);
bool hl_is_dram_va(struct hl_device *hdev, u64 virt_addr);

int hl_fw_load_fw_to_device(struct hl_device *hdev, const char *fw_name, void __iomem *dst, u32 src_offset, u32 size);
int hl_fw_send_pci_access_msg(struct hl_device *hdev, u32 opcode, u64 value);
int hl_fw_send_cpu_message(struct hl_device *hdev, u32 hw_queue_id, u32 *msg, u16 len, u32 timeout, u64 *result);
int hl_fw_unmask_irq(struct hl_device *hdev, u16 event_type);
int hl_fw_unmask_irq_arr(struct hl_device *hdev, const u32 *irq_arr, size_t irq_arr_size);
int hl_fw_test_cpu_queue(struct hl_device *hdev);
void *hl_fw_cpu_accessible_dma_pool_alloc(struct hl_device *hdev, size_t size, dma_addr_t *dma_handle);
void hl_fw_cpu_accessible_dma_pool_free(struct hl_device *hdev, size_t size, void *vaddr);
int hl_fw_send_heartbeat(struct hl_device *hdev);
int hl_fw_cpucp_info_get(struct hl_device *hdev, u32 sts_boot_dev_sts0_reg, u32 sts_boot_dev_sts1_reg, u32 boot_err0_reg, u32 boot_err1_reg);


int hl_fw_cpucp_handshake(struct hl_device *hdev, u32 sts_boot_dev_sts0_reg, u32 sts_boot_dev_sts1_reg, u32 boot_err0_reg, u32 boot_err1_reg);


int hl_fw_get_eeprom_data(struct hl_device *hdev, void *data, size_t max_size);
int hl_fw_get_monitor_dump(struct hl_device *hdev, void *data);
int hl_fw_cpucp_pci_counters_get(struct hl_device *hdev, struct hl_info_pci_counters *counters);
int hl_fw_cpucp_total_energy_get(struct hl_device *hdev, u64 *total_energy);
int get_used_pll_index(struct hl_device *hdev, u32 input_pll_index, enum pll_index *pll_index);
int hl_fw_cpucp_pll_info_get(struct hl_device *hdev, u32 pll_index, u16 *pll_freq_arr);
int hl_fw_cpucp_power_get(struct hl_device *hdev, u64 *power);
void hl_fw_ask_hard_reset_without_linux(struct hl_device *hdev);
void hl_fw_ask_halt_machine_without_linux(struct hl_device *hdev);
int hl_fw_init_cpu(struct hl_device *hdev);
int hl_fw_read_preboot_status(struct hl_device *hdev);
int hl_fw_dynamic_send_protocol_cmd(struct hl_device *hdev, struct fw_load_mgr *fw_loader, enum comms_cmd cmd, unsigned int size, bool wait_ok, u32 timeout);


int hl_fw_dram_replaced_row_get(struct hl_device *hdev, struct cpucp_hbm_row_info *info);
int hl_fw_dram_pending_row_get(struct hl_device *hdev, u32 *pend_rows_num);
int hl_fw_cpucp_engine_core_asid_set(struct hl_device *hdev, u32 asid);
int hl_fw_send_device_activity(struct hl_device *hdev, bool open);
int hl_pci_bars_map(struct hl_device *hdev, const char * const name[3], bool is_wc[3]);
int hl_pci_elbi_read(struct hl_device *hdev, u64 addr, u32 *data);
int hl_pci_iatu_write(struct hl_device *hdev, u32 addr, u32 data);
int hl_pci_set_inbound_region(struct hl_device *hdev, u8 region, struct hl_inbound_pci_region *pci_region);
int hl_pci_set_outbound_region(struct hl_device *hdev, struct hl_outbound_pci_region *pci_region);
enum pci_region hl_get_pci_memory_region(struct hl_device *hdev, u64 addr);
int hl_pci_init(struct hl_device *hdev);
void hl_pci_fini(struct hl_device *hdev);

long hl_fw_get_frequency(struct hl_device *hdev, u32 pll_index, bool curr);
void hl_fw_set_frequency(struct hl_device *hdev, u32 pll_index, u64 freq);
int hl_get_temperature(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
int hl_set_temperature(struct hl_device *hdev, int sensor_index, u32 attr, long value);
int hl_get_voltage(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
int hl_get_current(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
int hl_get_fan_speed(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
int hl_get_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
void hl_set_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr, long value);
long hl_fw_get_max_power(struct hl_device *hdev);
void hl_fw_set_max_power(struct hl_device *hdev);
int hl_set_voltage(struct hl_device *hdev, int sensor_index, u32 attr, long value);
int hl_set_current(struct hl_device *hdev, int sensor_index, u32 attr, long value);
int hl_set_power(struct hl_device *hdev, int sensor_index, u32 attr, long value);
int hl_get_power(struct hl_device *hdev, int sensor_index, u32 attr, long *value);
int hl_fw_get_clk_rate(struct hl_device *hdev, u32 *cur_clk, u32 *max_clk);
void hl_fw_set_pll_profile(struct hl_device *hdev);
void hl_sysfs_add_dev_clk_attr(struct hl_device *hdev, struct attribute_group *dev_clk_attr_grp);
void hl_sysfs_add_dev_vrm_attr(struct hl_device *hdev, struct attribute_group *dev_vrm_attr_grp);

void hw_sob_get(struct hl_hw_sob *hw_sob);
void hw_sob_put(struct hl_hw_sob *hw_sob);
void hl_encaps_handle_do_release(struct kref *ref);
void hl_hw_queue_encaps_sig_set_sob_info(struct hl_device *hdev, struct hl_cs *cs, struct hl_cs_job *job, struct hl_cs_compl *cs_cmpl);


int hl_dec_init(struct hl_device *hdev);
void hl_dec_fini(struct hl_device *hdev);
void hl_dec_ctx_fini(struct hl_ctx *ctx);

void hl_release_pending_user_interrupts(struct hl_device *hdev);
int hl_cs_signal_sob_wraparound_handler(struct hl_device *hdev, u32 q_idx, struct hl_hw_sob **hw_sob, u32 count, bool encaps_sig);

int hl_state_dump(struct hl_device *hdev);
const char *hl_state_dump_get_sync_name(struct hl_device *hdev, u32 sync_id);
const char *hl_state_dump_get_monitor_name(struct hl_device *hdev, struct hl_mon_state_dump *mon);
void hl_state_dump_free_sync_to_engine_map(struct hl_sync_to_engine_map *map);
__printf(4, 5) int hl_snprintf_resize(char **buf, size_t *size, size_t *offset, const char *format, ...);
char *hl_format_as_binary(char *buf, size_t buf_len, u32 n);
const char *hl_sync_engine_to_string(enum hl_sync_engine_type engine_type);

void hl_mem_mgr_init(struct device *dev, struct hl_mem_mgr *mmg);
void hl_mem_mgr_fini(struct hl_mem_mgr *mmg);
int hl_mem_mgr_mmap(struct hl_mem_mgr *mmg, struct vm_area_struct *vma, void *args);
struct hl_mmap_mem_buf *hl_mmap_mem_buf_get(struct hl_mem_mgr *mmg, u64 handle);
int hl_mmap_mem_buf_put_handle(struct hl_mem_mgr *mmg, u64 handle);
int hl_mmap_mem_buf_put(struct hl_mmap_mem_buf *buf);
struct hl_mmap_mem_buf * hl_mmap_mem_buf_alloc(struct hl_mem_mgr *mmg, struct hl_mmap_mem_buf_behavior *behavior, gfp_t gfp, void *args);


__printf(2, 3) void hl_engine_data_sprintf(struct engines_data *e, const char *fmt, ...);



void hl_debugfs_init(void);
void hl_debugfs_fini(void);
void hl_debugfs_add_device(struct hl_device *hdev);
void hl_debugfs_remove_device(struct hl_device *hdev);
void hl_debugfs_add_file(struct hl_fpriv *hpriv);
void hl_debugfs_remove_file(struct hl_fpriv *hpriv);
void hl_debugfs_add_cb(struct hl_cb *cb);
void hl_debugfs_remove_cb(struct hl_cb *cb);
void hl_debugfs_add_cs(struct hl_cs *cs);
void hl_debugfs_remove_cs(struct hl_cs *cs);
void hl_debugfs_add_job(struct hl_device *hdev, struct hl_cs_job *job);
void hl_debugfs_remove_job(struct hl_device *hdev, struct hl_cs_job *job);
void hl_debugfs_add_userptr(struct hl_device *hdev, struct hl_userptr *userptr);
void hl_debugfs_remove_userptr(struct hl_device *hdev, struct hl_userptr *userptr);
void hl_debugfs_add_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx);
void hl_debugfs_remove_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx);
void hl_debugfs_set_state_dump(struct hl_device *hdev, char *data, unsigned long length);



static inline void __init hl_debugfs_init(void)
{
}

static inline void hl_debugfs_fini(void)
{
}

static inline void hl_debugfs_add_device(struct hl_device *hdev)
{
}

static inline void hl_debugfs_remove_device(struct hl_device *hdev)
{
}

static inline void hl_debugfs_add_file(struct hl_fpriv *hpriv)
{
}

static inline void hl_debugfs_remove_file(struct hl_fpriv *hpriv)
{
}

static inline void hl_debugfs_add_cb(struct hl_cb *cb)
{
}

static inline void hl_debugfs_remove_cb(struct hl_cb *cb)
{
}

static inline void hl_debugfs_add_cs(struct hl_cs *cs)
{
}

static inline void hl_debugfs_remove_cs(struct hl_cs *cs)
{
}

static inline void hl_debugfs_add_job(struct hl_device *hdev, struct hl_cs_job *job)
{
}

static inline void hl_debugfs_remove_job(struct hl_device *hdev, struct hl_cs_job *job)
{
}

static inline void hl_debugfs_add_userptr(struct hl_device *hdev, struct hl_userptr *userptr)
{
}

static inline void hl_debugfs_remove_userptr(struct hl_device *hdev, struct hl_userptr *userptr)
{
}

static inline void hl_debugfs_add_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx)
{
}

static inline void hl_debugfs_remove_ctx_mem_hash(struct hl_device *hdev, struct hl_ctx *ctx)
{
}

static inline void hl_debugfs_set_state_dump(struct hl_device *hdev, char *data, unsigned long length)
{
}




int hl_unsecure_register(struct hl_device *hdev, u32 mm_reg_addr, int offset, const u32 pb_blocks[], struct hl_block_glbl_sec sgs_array[], int array_size);

int hl_unsecure_registers(struct hl_device *hdev, const u32 mm_reg_array[], int mm_array_size, int offset, const u32 pb_blocks[], struct hl_block_glbl_sec sgs_array[], int blocks_array_size);

void hl_config_glbl_sec(struct hl_device *hdev, const u32 pb_blocks[], struct hl_block_glbl_sec sgs_array[], u32 block_offset, int array_size);

void hl_secure_block(struct hl_device *hdev, struct hl_block_glbl_sec sgs_array[], int array_size);
int hl_init_pb_with_mask(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const u32 *regs_array, u32 regs_array_size, u64 mask);


int hl_init_pb(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const u32 *regs_array, u32 regs_array_size);


int hl_init_pb_ranges_with_mask(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const struct range *regs_range_array, u32 regs_range_array_size, u64 mask);



int hl_init_pb_ranges(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const struct range *regs_range_array, u32 regs_range_array_size);



int hl_init_pb_single_dcore(struct hl_device *hdev, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const u32 *regs_array, u32 regs_array_size);


int hl_init_pb_ranges_single_dcore(struct hl_device *hdev, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, const struct range *regs_range_array, u32 regs_range_array_size);



void hl_ack_pb(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size);

void hl_ack_pb_with_mask(struct hl_device *hdev, u32 num_dcores, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size, u64 mask);

void hl_ack_pb_single_dcore(struct hl_device *hdev, u32 dcore_offset, u32 num_instances, u32 instance_offset, const u32 pb_blocks[], u32 blocks_array_size);



long hl_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);
long hl_ioctl_control(struct file *filep, unsigned int cmd, unsigned long arg);
int hl_cb_ioctl(struct hl_fpriv *hpriv, void *data);
int hl_cs_ioctl(struct hl_fpriv *hpriv, void *data);
int hl_wait_ioctl(struct hl_fpriv *hpriv, void *data);
int hl_mem_ioctl(struct hl_fpriv *hpriv, void *data);


