


__FBSDID("$FreeBSD$");
























static sa_fstype_t *nfs_fstype;


static char * zgetline(FILE *fd, const char *skip)
{
	static char line[MAXLINESIZE];
	size_t len, skiplen = 0;
	char *s, last;

	if (skip != NULL)
		skiplen = strlen(skip);
	for (;;) {
		s = fgets(line, sizeof (line), fd);
		if (s == NULL)
			return (NULL);
		
		if (line[0] == '\n' || line[0] == '#')
			continue;
		len = strlen(line);
		if (line[len - 1] == '\n')
			line[len - 1] = '\0';
		last = line[skiplen];
		
		if (skip != NULL && strncmp(skip, line, skiplen) == 0 && (last == '\t' || last == ' ' || last == '\0')) {
			continue;
		}
		break;
	}
	return (line);
}


static char * translate_opts(const char *shareopts)
{
	static const char *known_opts[] = { "ro", "maproot", "mapall", "mask", "network", "sec", "alldirs", "public", "webnfs", "index", "quiet", NULL };

	static char newopts[OPTSSIZE];
	char oldopts[OPTSSIZE];
	char *o, *s = NULL;
	unsigned int i;
	size_t len;

	strlcpy(oldopts, shareopts, sizeof (oldopts));
	newopts[0] = '\0';
	s = oldopts;
	while ((o = strsep(&s, "-, ")) != NULL) {
		if (o[0] == '\0')
			continue;
		for (i = 0; known_opts[i] != NULL; i++) {
			len = strlen(known_opts[i]);
			if (strncmp(known_opts[i], o, len) == 0 && (o[len] == '\0' || o[len] == '=')) {
				strlcat(newopts, "-", sizeof (newopts));
				break;
			}
		}
		strlcat(newopts, o, sizeof (newopts));
		strlcat(newopts, " ", sizeof (newopts));
	}
	return (newopts);
}


int nfs_copy_entries(char *filename, const char *mountpoint)
{
	int error = SA_OK;
	char *line;

	FILE *oldfp = fopen(ZFS_EXPORTS_FILE, "re");
	FILE *newfp = fopen(filename, "w+e");
	if (newfp == NULL) {
		fprintf(stderr, "failed to open %s file: %s", filename, strerror(errno));
		fclose(oldfp);
		return (SA_SYSTEM_ERR);
	}
	fputs(FILE_HEADER, newfp);

	
	if (oldfp != NULL) {
		while ((line = zgetline(oldfp, mountpoint)) != NULL)
			fprintf(newfp, "%s\n", line);
		if (ferror(oldfp) != 0) {
			error = ferror(oldfp);
		}
		if (fclose(oldfp) != 0) {
			fprintf(stderr, "Unable to close file %s: %s\n", filename, strerror(errno));
			error = error != 0 ? error : SA_SYSTEM_ERR;
		}
	}

	if (error == 0 && ferror(newfp) != 0) {
		error = ferror(newfp);
	}

	if (fclose(newfp) != 0) {
		fprintf(stderr, "Unable to close file %s: %s\n", filename, strerror(errno));
		error = error != 0 ? error : SA_SYSTEM_ERR;
	}
	return (error);
}

static int nfs_enable_share_impl(sa_share_impl_t impl_share, char *filename)
{
	FILE *fp = fopen(filename, "a+e");
	if (fp == NULL) {
		fprintf(stderr, "failed to open %s file: %s", filename, strerror(errno));
		return (SA_SYSTEM_ERR);
	}

	char *shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
	if (strcmp(shareopts, "on") == 0)
		shareopts = "";

	if (fprintf(fp, "%s\t%s\n", impl_share->sa_mountpoint, translate_opts(shareopts)) < 0) {
		fprintf(stderr, "failed to write to %s\n", filename);
		fclose(fp);
		return (SA_SYSTEM_ERR);
	}

	if (fclose(fp) != 0) {
		fprintf(stderr, "Unable to close file %s: %s\n", filename, strerror(errno));
		return (SA_SYSTEM_ERR);
	}

	return (SA_OK);
}

static int nfs_enable_share(sa_share_impl_t impl_share)
{
	return (nfs_toggle_share( ZFS_EXPORTS_LOCK, ZFS_EXPORTS_FILE, NULL, impl_share, nfs_enable_share_impl));

}

static int nfs_disable_share_impl(sa_share_impl_t impl_share, char *filename)
{
	return (SA_OK);
}

static int nfs_disable_share(sa_share_impl_t impl_share)
{
	return (nfs_toggle_share( ZFS_EXPORTS_LOCK, ZFS_EXPORTS_FILE, NULL, impl_share, nfs_disable_share_impl));

}

static boolean_t nfs_is_shared(sa_share_impl_t impl_share)
{
	char *s, last, line[MAXLINESIZE];
	size_t len;
	char *mntpoint = impl_share->sa_mountpoint;
	size_t mntlen = strlen(mntpoint);

	FILE *fp = fopen(ZFS_EXPORTS_FILE, "re");
	if (fp == NULL)
		return (B_FALSE);

	for (;;) {
		s = fgets(line, sizeof (line), fp);
		if (s == NULL)
			return (B_FALSE);
		
		if (line[0] == '\n' || line[0] == '#')
			continue;
		len = strlen(line);
		if (line[len - 1] == '\n')
			line[len - 1] = '\0';
		last = line[mntlen];
		
		if (strncmp(mntpoint, line, mntlen) == 0 && (last == '\t' || last == ' ' || last == '\0')) {
			fclose(fp);
			return (B_TRUE);
		}
	}
	fclose(fp);
	return (B_FALSE);
}

static int nfs_validate_shareopts(const char *shareopts)
{
	return (SA_OK);
}

static int nfs_update_shareopts(sa_share_impl_t impl_share, const char *shareopts)
{
	FSINFO(impl_share, nfs_fstype)->shareopts = (char *)shareopts;
	return (SA_OK);
}

static void nfs_clear_shareopts(sa_share_impl_t impl_share)
{
	FSINFO(impl_share, nfs_fstype)->shareopts = NULL;
}


static int nfs_commit_shares(void)
{
	struct pidfh *pfh;
	pid_t mountdpid;

	pfh = pidfile_open(_PATH_MOUNTDPID, 0600, &mountdpid);
	if (pfh != NULL) {
		
		pidfile_remove(pfh);
		return (SA_OK);
	}
	if (errno != EEXIST) {
		
		return (SA_SYSTEM_ERR);
	}
	
	kill(mountdpid, SIGHUP);
	return (SA_OK);
}

static const sa_share_ops_t nfs_shareops = {
	.enable_share = nfs_enable_share, .disable_share = nfs_disable_share, .is_shared = nfs_is_shared,  .validate_shareopts = nfs_validate_shareopts, .update_shareopts = nfs_update_shareopts, .clear_shareopts = nfs_clear_shareopts, .commit_shares = nfs_commit_shares, };









void libshare_nfs_init(void)
{
	nfs_fstype = register_fstype("nfs", &nfs_shareops);
}
