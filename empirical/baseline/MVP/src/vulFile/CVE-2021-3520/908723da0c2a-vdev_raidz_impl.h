












extern "C" {















enum raidz_math_gen_op {
	RAIDZ_GEN_P = 0, RAIDZ_GEN_PQ, RAIDZ_GEN_PQR, RAIDZ_GEN_NUM = 3 };




enum raidz_rec_op {
	RAIDZ_REC_P = 0, RAIDZ_REC_Q, RAIDZ_REC_R, RAIDZ_REC_PQ, RAIDZ_REC_PR, RAIDZ_REC_QR, RAIDZ_REC_PQR, RAIDZ_REC_NUM = 7 };








extern const char *raidz_gen_name[RAIDZ_GEN_NUM];
extern const char *raidz_rec_name[RAIDZ_REC_NUM];


typedef void		(*raidz_gen_f)(void *);
typedef int		(*raidz_rec_f)(void *, const int *);
typedef boolean_t	(*will_work_f)(void);
typedef void		(*init_impl_f)(void);
typedef void		(*fini_impl_f)(void);



typedef struct raidz_impl_ops {
	init_impl_f init;
	fini_impl_f fini;
	raidz_gen_f gen[RAIDZ_GEN_NUM];	
	raidz_rec_f rec[RAIDZ_REC_NUM];	
	will_work_f is_supported;	
	char name[RAIDZ_IMPL_NAME_MAX];	
} raidz_impl_ops_t;

typedef struct raidz_col {
	uint64_t rc_devidx;		
	uint64_t rc_offset;		
	uint64_t rc_size;		
	abd_t rc_abdstruct;		
	abd_t *rc_abd;			
	abd_t *rc_orig_data;		
	int rc_error;			
	uint8_t rc_tried;		
	uint8_t rc_skipped;		
	uint8_t rc_need_orig_restore;	
	uint8_t rc_force_repair;	
	uint8_t rc_allow_repair;	
} raidz_col_t;

typedef struct raidz_row {
	uint64_t rr_cols;		
	uint64_t rr_scols;		
	uint64_t rr_bigcols;		
	uint64_t rr_missingdata;	
	uint64_t rr_missingparity;	
	uint64_t rr_firstdatacol;	
	abd_t *rr_abd_empty;		
	int rr_nempty;			

	uint64_t rr_offset;		
	uint64_t rr_size;		

	raidz_col_t rr_col[0];		
} raidz_row_t;

typedef struct raidz_map {
	boolean_t rm_ecksuminjected;	
	int rm_nrows;			
	int rm_nskip;			
	int rm_skipstart;		
	const raidz_impl_ops_t *rm_ops;	
	raidz_row_t *rm_row[0];		
} raidz_map_t;




extern const raidz_impl_ops_t vdev_raidz_scalar_impl;
extern boolean_t raidz_will_scalar_work(void);


extern const raidz_impl_ops_t vdev_raidz_sse2_impl;


extern const raidz_impl_ops_t vdev_raidz_ssse3_impl;


extern const raidz_impl_ops_t vdev_raidz_avx2_impl;


extern const raidz_impl_ops_t vdev_raidz_avx512f_impl;


extern const raidz_impl_ops_t vdev_raidz_avx512bw_impl;


extern const raidz_impl_ops_t vdev_raidz_aarch64_neon_impl;
extern const raidz_impl_ops_t vdev_raidz_aarch64_neonx2_impl;


extern const raidz_impl_ops_t vdev_raidz_powerpc_altivec_impl;


























































typedef struct raidz_impl_kstat {
	uint64_t gen[RAIDZ_GEN_NUM];	
	uint64_t rec[RAIDZ_REC_NUM];	
} raidz_impl_kstat_t;


typedef enum raidz_mul_info {
	
	MUL_Q_X		= 0,  MUL_R_X		= 0,  MUL_PQ_X	= 0, MUL_PQ_Y	= 1,  MUL_PR_X	= 0, MUL_PR_Y	= 1,  MUL_QR_XQ	= 0, MUL_QR_X	= 1, MUL_QR_YQ	= 2, MUL_QR_Y	= 3,  MUL_PQR_XP	= 0, MUL_PQR_XQ	= 1, MUL_PQR_XR	= 2, MUL_PQR_YU	= 3, MUL_PQR_YP	= 4, MUL_PQR_YQ	= 5,  MUL_CNT		= 6 } raidz_mul_info_t;
























extern const uint8_t vdev_raidz_pow2[256] __attribute__((aligned(256)));

extern const uint8_t vdev_raidz_log2[256] __attribute__((aligned(256)));


static inline uint8_t vdev_raidz_exp2(const uint8_t a, const unsigned exp)
{
	if (a == 0)
		return (0);

	return (vdev_raidz_pow2[(exp + (unsigned)vdev_raidz_log2[a]) % 255]);
}


typedef unsigned gf_t;
typedef unsigned gf_log_t;

static inline gf_t gf_mul(const gf_t a, const gf_t b)
{
	gf_log_t logsum;

	if (a == 0 || b == 0)
		return (0);

	logsum = (gf_log_t)vdev_raidz_log2[a] + (gf_log_t)vdev_raidz_log2[b];

	return ((gf_t)vdev_raidz_pow2[logsum % 255]);
}

static inline gf_t gf_div(const gf_t  a, const gf_t b)
{
	gf_log_t logsum;

	ASSERT3U(b, >, 0);
	if (a == 0)
		return (0);

	logsum = (gf_log_t)255 + (gf_log_t)vdev_raidz_log2[a] - (gf_log_t)vdev_raidz_log2[b];

	return ((gf_t)vdev_raidz_pow2[logsum % 255]);
}

static inline gf_t gf_inv(const gf_t a)
{
	gf_log_t logsum;

	ASSERT3U(a, >, 0);

	logsum = (gf_log_t)255 - (gf_log_t)vdev_raidz_log2[a];

	return ((gf_t)vdev_raidz_pow2[logsum]);
}

static inline gf_t gf_exp2(gf_log_t exp)
{
	return (vdev_raidz_pow2[exp % 255]);
}

static inline gf_t gf_exp4(gf_log_t exp)
{
	ASSERT3U(exp, <=, 255);
	return ((gf_t)vdev_raidz_pow2[(2 * exp) % 255]);
}


}



