









kmutex_t		ntfy_list_lock;
kcondvar_t		ntfy_list_cv;   
static kcf_ntfy_elem_t *ntfy_list_head;


crypto_mech_type_t crypto_mech2id(char *mechname)
{
	return (crypto_mech2id_common(mechname, B_TRUE));
}


void kcf_walk_ntfylist(uint32_t event, void *event_arg)
{
	kcf_ntfy_elem_t *nep;
	int nelem = 0;

	mutex_enter(&ntfy_list_lock);

	
	for (nep = ntfy_list_head; nep != NULL; nep = nep->kn_next)
		nelem++;

	for (nep = ntfy_list_head; (nep != NULL && nelem); nep = nep->kn_next) {
		nelem--;

		
		if (!(nep->kn_event_mask & event))
			continue;

		mutex_enter(&nep->kn_lock);
		nep->kn_state = NTFY_RUNNING;
		mutex_exit(&nep->kn_lock);
		mutex_exit(&ntfy_list_lock);

		
		(*nep->kn_func)(event, event_arg);

		mutex_enter(&nep->kn_lock);
		nep->kn_state = NTFY_WAITING;
		cv_broadcast(&nep->kn_cv);
		mutex_exit(&nep->kn_lock);

		mutex_enter(&ntfy_list_lock);
	}

	mutex_exit(&ntfy_list_lock);
}


EXPORT_SYMBOL(crypto_mech2id);

