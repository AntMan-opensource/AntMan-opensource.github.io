






static int mod_null(struct modlmisc *, struct modlinkage *);
static int mod_infonull(void *, struct modlinkage *, int *);


struct mod_ops mod_cryptoops = {
	.modm_install = mod_null, .modm_remove = mod_null, .modm_info = mod_infonull };




static int mod_null(struct modlmisc *modl, struct modlinkage *modlp)
{
	return (0);
}


static int mod_infonull(void *modl, struct modlinkage *modlp, int *p0)
{
	*p0 = -1;		
	return (0);
}


int mod_install(struct modlinkage *modlp)
{
	int retval = -1;	
	struct modlmisc **linkpp;
	struct modlmisc **linkpp1;

	if (modlp->ml_rev != MODREV_1) {
		cmn_err(CE_WARN, "mod_install: " "modlinkage structure is not MODREV_1\n");
		return (EINVAL);
	}
	linkpp = (struct modlmisc **)&modlp->ml_linkage[0];

	while (*linkpp != NULL) {
		if ((retval = MODL_INSTALL(*linkpp, modlp)) != 0) {
			linkpp1 = (struct modlmisc **)&modlp->ml_linkage[0];

			while (linkpp1 != linkpp) {
				MODL_REMOVE(*linkpp1, modlp); 
				linkpp1++;
			}
			break;
		}
		linkpp++;
	}
	return (retval);
}

static char *reins_err = "Could not reinstall %s\nReboot to correct the problem";


int mod_remove(struct modlinkage *modlp)
{
	int retval = 0;
	struct modlmisc **linkpp, *last_linkp;

	linkpp = (struct modlmisc **)&modlp->ml_linkage[0];

	while (*linkpp != NULL) {
		if ((retval = MODL_REMOVE(*linkpp, modlp)) != 0) {
			last_linkp = *linkpp;
			linkpp = (struct modlmisc **)&modlp->ml_linkage[0];
			while (*linkpp != last_linkp) {
				if (MODL_INSTALL(*linkpp, modlp) != 0) {
					cmn_err(CE_WARN, reins_err, (*linkpp)->misc_linkinfo);
					break;
				}
				linkpp++;
			}
			break;
		}
		linkpp++;
	}
	return (retval);
}


int mod_info(struct modlinkage *modlp, struct modinfo *modinfop)
{
	int i;
	int retval = 0;
	struct modspecific_info *msip;
	struct modlmisc **linkpp;

	modinfop->mi_rev = modlp->ml_rev;

	linkpp = (struct modlmisc **)modlp->ml_linkage;
	msip = &modinfop->mi_msinfo[0];

	for (i = 0; i < MODMAXLINK; i++) {
		if (*linkpp == NULL) {
			msip->msi_linkinfo[0] = '\0';
		} else {
			(void) strlcpy(msip->msi_linkinfo, (*linkpp)->misc_linkinfo, MODMAXLINKINFOLEN);
			retval = MODL_INFO(*linkpp, modlp, &msip->msi_p0);
			if (retval != 0)
				break;
			linkpp++;
		}
		msip++;
	}

	if (modinfop->mi_info == MI_INFO_LINKAGE) {
		
		modinfop->mi_base = (void *)modlp;
	}

	if (retval == 0)
		return (1);
	return (0);
}
