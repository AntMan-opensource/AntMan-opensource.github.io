



























typedef struct option_map {
	const char *name;
	unsigned long mntmask;
	unsigned long zfsmask;
} option_map_t;

static const option_map_t option_map[] = {
	
	{ MNTOPT_NOAUTO,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_DEFAULTS,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_NODEVICES,	MS_NODEV,	ZS_COMMENT	}, { MNTOPT_DEVICES,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_DIRSYNC,	MS_DIRSYNC,	ZS_COMMENT	}, { MNTOPT_NOEXEC,	MS_NOEXEC,	ZS_COMMENT	}, { MNTOPT_EXEC,		MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_GROUP,		MS_GROUP,	ZS_COMMENT	}, { MNTOPT_NETDEV,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_NOFAIL,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_NOSUID,	MS_NOSUID,	ZS_COMMENT	}, { MNTOPT_SUID,		MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_OWNER,		MS_OWNER,	ZS_COMMENT	}, { MNTOPT_REMOUNT,	MS_REMOUNT,	ZS_COMMENT	}, { MNTOPT_RO,		MS_RDONLY,	ZS_COMMENT	}, { MNTOPT_RW,		MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_SYNC,		MS_SYNCHRONOUS,	ZS_COMMENT	}, { MNTOPT_USER,		MS_USERS,	ZS_COMMENT	}, { MNTOPT_USERS,		MS_USERS,	ZS_COMMENT	},  { MNTOPT_ACL,		MS_POSIXACL,	ZS_COMMENT	}, { MNTOPT_NOACL,		MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_POSIXACL,	MS_POSIXACL,	ZS_COMMENT	},  { MNTOPT_NOATIME,	MS_NOATIME,	ZS_COMMENT	}, { MNTOPT_ATIME,		MS_COMMENT,	ZS_COMMENT	},   { MNTOPT_NODIRATIME,	MS_NODIRATIME,	ZS_COMMENT	}, { MNTOPT_DIRATIME,	MS_COMMENT,	ZS_COMMENT	},   { MNTOPT_RELATIME,	MS_RELATIME,	ZS_COMMENT	}, { MNTOPT_NORELATIME,	MS_COMMENT,	ZS_COMMENT	},   { MNTOPT_STRICTATIME,	MS_STRICTATIME,	ZS_COMMENT	}, { MNTOPT_NOSTRICTATIME,	MS_COMMENT,	ZS_COMMENT	},   { MNTOPT_LAZYTIME,	MS_LAZYTIME,	ZS_COMMENT	},  { MNTOPT_CONTEXT,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_FSCONTEXT,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_DEFCONTEXT,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_ROOTCONTEXT,	MS_COMMENT,	ZS_COMMENT	},  { MNTOPT_IVERSION,	MS_I_VERSION,	ZS_COMMENT	},   { MNTOPT_NBMAND,	MS_MANDLOCK,	ZS_COMMENT	}, { MNTOPT_NONBMAND,	MS_COMMENT,	ZS_COMMENT	},   { MNTOPT_BIND,		MS_BIND,	ZS_COMMENT	},  { MNTOPT_RBIND,		MS_BIND|MS_REC,	ZS_COMMENT	},  { MNTOPT_COMMENT,	MS_COMMENT,	ZS_COMMENT	},  { MNTOPT_NOSUB,		MS_NOSUB,	ZS_COMMENT	},   { MNTOPT_QUIET,		MS_SILENT,	ZS_COMMENT	},   { MNTOPT_XATTR,		MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_NOXATTR,	MS_COMMENT,	ZS_COMMENT	}, { MNTOPT_ZFSUTIL,	MS_COMMENT,	ZS_ZFSUTIL	}, { NULL,			0,		0		} };






































































static int parse_option(char *mntopt, unsigned long *mntflags, unsigned long *zfsflags, int sloppy)

{
	const option_map_t *opt;
	char *ptr, *name, *value = NULL;
	int error = 0;

	name = strdup(mntopt);
	if (name == NULL)
		return (ENOMEM);

	for (ptr = name; ptr && *ptr; ptr++) {
		if (*ptr == '=') {
			*ptr = '\0';
			value = ptr+1;
			VERIFY3P(value, !=, NULL);
			break;
		}
	}

	for (opt = option_map; opt->name != NULL; opt++) {
		if (strncmp(name, opt->name, strlen(name)) == 0) {
			*mntflags |= opt->mntmask;
			*zfsflags |= opt->zfsmask;
			error = 0;
			goto out;
		}
	}

	if (!sloppy)
		error = ENOENT;
out:
	
	free(name);
	return (error);
}


int zfs_parse_mount_options(char *mntopts, unsigned long *mntflags, unsigned long *zfsflags, int sloppy, char *badopt, char *mtabopt)

{
	int error = 0, quote = 0, flag = 0, count = 0;
	char *ptr, *opt, *opts;

	opts = strdup(mntopts);
	if (opts == NULL)
		return (ENOMEM);

	*mntflags = 0;
	opt = NULL;

	
	for (ptr = opts; ptr && !flag; ptr++) {
		if (opt == NULL)
			opt = ptr;

		if (*ptr == '"')
			quote = !quote;

		if (quote)
			continue;

		if (*ptr == '\0')
			flag = 1;

		if ((*ptr == ',') || (*ptr == '\0')) {
			*ptr = '\0';

			error = parse_option(opt, mntflags, zfsflags, sloppy);
			if (error) {
				strcpy(badopt, opt);
				goto out;

			}

			if (!(*mntflags & MS_REMOUNT) && !(*zfsflags & ZS_ZFSUTIL) && mtabopt != NULL) {

				if (count > 0)
					strlcat(mtabopt, ",", MNT_LINE_MAX);

				strlcat(mtabopt, opt, MNT_LINE_MAX);
				count++;
			}

			opt = NULL;
		}
	}

out:
	free(opts);
	return (error);
}

static void append_mntopt(const char *name, const char *val, char *mntopts, char *mtabopt, boolean_t quote)

{
	char tmp[MNT_LINE_MAX];

	snprintf(tmp, MNT_LINE_MAX, quote ? ",%s=\"%s\"" : ",%s=%s", name, val);

	if (mntopts)
		strlcat(mntopts, tmp, MNT_LINE_MAX);

	if (mtabopt)
		strlcat(mtabopt, tmp, MNT_LINE_MAX);
}

static void zfs_selinux_setcontext(zfs_handle_t *zhp, zfs_prop_t zpt, const char *name, char *mntopts, char *mtabopt)

{
	char context[ZFS_MAXPROPLEN];

	if (zfs_prop_get(zhp, zpt, context, sizeof (context), NULL, NULL, 0, B_FALSE) == 0) {
		if (strcmp(context, "none") != 0)
			append_mntopt(name, context, mntopts, mtabopt, B_TRUE);
	}
}

void zfs_adjust_mount_options(zfs_handle_t *zhp, const char *mntpoint, char *mntopts, char *mtabopt)

{
	char prop[ZFS_MAXPROPLEN];

	
	if (zfs_prop_get(zhp, ZFS_PROP_SELINUX_CONTEXT, prop, sizeof (prop), NULL, NULL, 0, B_FALSE) == 0) {
		if (strcmp(prop, "none") == 0) {
			zfs_selinux_setcontext(zhp, ZFS_PROP_SELINUX_FSCONTEXT, MNTOPT_FSCONTEXT, mntopts, mtabopt);
			zfs_selinux_setcontext(zhp, ZFS_PROP_SELINUX_DEFCONTEXT, MNTOPT_DEFCONTEXT, mntopts, mtabopt);
			zfs_selinux_setcontext(zhp, ZFS_PROP_SELINUX_ROOTCONTEXT, MNTOPT_ROOTCONTEXT, mntopts, mtabopt);

		} else {
			append_mntopt(MNTOPT_CONTEXT, prop, mntopts, mtabopt, B_TRUE);
		}
	}

	
	append_mntopt(MNTOPT_MNTPOINT, mntpoint, mntopts, NULL, B_FALSE);
}


int do_mount(zfs_handle_t *zhp, const char *mntpt, char *opts, int flags)
{
	const char *src = zfs_get_name(zhp);
	int error = 0;

	if (!libzfs_envvar_is_set("ZFS_MOUNT_HELPER")) {
		char badopt[MNT_LINE_MAX] = {0};
		unsigned long mntflags = flags, zfsflags;
		char myopts[MNT_LINE_MAX] = {0};

		if (zfs_parse_mount_options(opts, &mntflags, &zfsflags, 0, badopt, NULL)) {
			return (EINVAL);
		}
		strlcat(myopts, opts, MNT_LINE_MAX);
		zfs_adjust_mount_options(zhp, mntpt, myopts, NULL);
		if (mount(src, mntpt, MNTTYPE_ZFS, mntflags, myopts)) {
			return (errno);
		}
	} else {
		char *argv[9] = {
		    "/bin/mount", "--no-canonicalize", "-t", MNTTYPE_ZFS, "-o", opts, (char *)src, (char *)mntpt, (char *)NULL };






		
		error = libzfs_run_process(argv[0], argv, STDOUT_VERBOSE|STDERR_VERBOSE);
		if (error) {
			if (error & MOUNT_FILEIO) {
				error = EIO;
			} else if (error & MOUNT_USER) {
				error = EINTR;
			} else if (error & MOUNT_SOFTWARE) {
				error = EPIPE;
			} else if (error & MOUNT_BUSY) {
				error = EBUSY;
			} else if (error & MOUNT_SYSERR) {
				error = EAGAIN;
			} else if (error & MOUNT_USAGE) {
				error = EINVAL;
			} else error = ENXIO;
		}
	}

	return (error);
}

int do_unmount(zfs_handle_t *zhp, const char *mntpt, int flags)
{
	if (!libzfs_envvar_is_set("ZFS_MOUNT_HELPER")) {
		int rv = umount2(mntpt, flags);

		return (rv < 0 ? errno : 0);
	}

	char force_opt[] = "-f";
	char lazy_opt[] = "-l";
	char *argv[7] = {
	    "/bin/umount", "-t", MNTTYPE_ZFS, NULL, NULL, NULL, NULL };

	int rc, count = 3;

	if (flags & MS_FORCE) {
		argv[count] = force_opt;
		count++;
	}

	if (flags & MS_DETACH) {
		argv[count] = lazy_opt;
		count++;
	}

	argv[count] = (char *)mntpt;
	rc = libzfs_run_process(argv[0], argv, STDOUT_VERBOSE|STDERR_VERBOSE);

	return (rc ? EINVAL : 0);
}

int zfs_mount_delegation_check(void)
{
	return ((geteuid() != 0) ? EACCES : 0);
}


void zpool_disable_datasets_os(zpool_handle_t *zhp, boolean_t force)
{
}


void zpool_disable_volume_os(const char *name)
{
}
