




struct vnode;
struct vattr;
struct xucred;

typedef struct flock	flock64_t;
typedef	struct vnode	vnode_t;
typedef	struct vattr	vattr_t;
typedef enum vtype vtype_t;





enum symfollow { NO_FOLLOW = NOFOLLOW };



















typedef	struct vop_vector	vnodeops_t;








static __inline int vn_is_readonly(vnode_t *vp)
{
	return (vp->v_mount->mnt_flag & MNT_RDONLY);
}









static __inline void vn_flush_cached_data(vnode_t *vp, boolean_t sync)
{

	if (vm_object_mightbedirty(vp->v_object)) {

	if (vp->v_object->flags & OBJ_MIGHTBEDIRTY) {

		int flags = sync ? OBJPC_SYNC : 0;
		zfs_vmobject_wlock(vp->v_object);
		vm_object_page_clean(vp->v_object, 0, 0, flags);
		zfs_vmobject_wunlock(vp->v_object);
	}
}




























































	














static __inline void vattr_init_mask(vattr_t *vap)
{

	vap->va_mask = 0;

	if (vap->va_uid != (uid_t)VNOVAL)
		vap->va_mask |= AT_UID;
	if (vap->va_gid != (gid_t)VNOVAL)
		vap->va_mask |= AT_GID;
	if (vap->va_size != (u_quad_t)VNOVAL)
		vap->va_mask |= AT_SIZE;
	if (vap->va_atime.tv_sec != VNOVAL)
		vap->va_mask |= AT_ATIME;
	if (vap->va_mtime.tv_sec != VNOVAL)
		vap->va_mask |= AT_MTIME;
	if (vap->va_mode != (uint16_t)VNOVAL)
		vap->va_mask |= AT_MODE;
	if (vap->va_flags != VNOVAL)
		vap->va_mask |= AT_XVATTR;
}




static __inline int vn_rename(char *from, char *to, enum uio_seg seg)
{

	ASSERT(seg == UIO_SYSSPACE);

	return (kern_renameat(curthread, AT_FDCWD, from, AT_FDCWD, to, seg));
}




