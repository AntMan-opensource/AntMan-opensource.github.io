

















namespace tensorflow {

class ResourceHandleProto;








class ResourceHandle {
 public:
  ResourceHandle();
  ResourceHandle(const ResourceHandleProto& proto);
  ~ResourceHandle();

  
  const std::string& device() const { return device_; }

  void set_device(const std::string& device) { device_ = device; }

  
  const std::string& container() const { return container_; }
  void set_container(const std::string& container) { container_ = container; }

  
  const std::string& name() const { return name_; }
  void set_name(const std::string& name) { name_ = name; }

  
  
  uint64 hash_code() const { return hash_code_; }
  void set_hash_code(uint64 hash_code) { hash_code_ = hash_code; }

  
  
  const std::string& maybe_type_name() const { return maybe_type_name_; }
  void set_maybe_type_name(const std::string& value) {
    maybe_type_name_ = value;
  }

  
  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes() const {
    return dtypes_and_shapes_;
  }
  void set_dtypes_and_shapes( const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes) {
    dtypes_and_shapes_ = dtypes_and_shapes;
  }

  void set_definition_stack_trace( const absl::optional<ManagedStackTrace>& definition_stack_trace) {
    definition_stack_trace_ = definition_stack_trace;
  }

  const absl::optional<ManagedStackTrace>& definition_stack_trace() const {
    return definition_stack_trace_;
  }

  
  void AsProto(ResourceHandleProto* proto) const;
  void FromProto(const ResourceHandleProto& proto);

  
  std::string SerializeAsString() const;
  bool ParseFromString(const std::string& s);

  std::string DebugString() const;

  std::string SummarizeValue() const { return "Resource Tensor"; }

  
  
  static constexpr const char* ANONYMOUS_NAME = "cd2c89b7-88b7-44c8-ad83-06c2a9158347";

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  template <typename T> static ResourceHandle MakeRefCountingHandle( T* resource, const string& device_name, const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes = {}, const absl::optional<ManagedStackTrace>& definition_stack_trace = {}) {



    return MakeRefCountingHandle(resource, device_name, TypeIndex::Make<T>(), dtypes_and_shapes, definition_stack_trace);
  }

  static ResourceHandle MakeRefCountingHandle( ResourceBase* resource, const string& device_name, const TypeIndex& type_index, const std::vector<DtypeAndPartialTensorShape>& dtypes_and_shapes = {}, const absl::optional<ManagedStackTrace>& definition_stack_trace = {});




  
  const core::IntrusivePtr<ResourceBase>& resource() const { return resource_; }

  
  
  template <typename T> StatusOr<T*> GetResource() const {
    TF_RETURN_IF_ERROR(ValidateType<T>());
    return down_cast<T*>(resource_.get());
  }

  
  
  bool IsRefCounting() const { return resource_.get() != nullptr; }

  
  template <typename T> Status ValidateType() const {
    return ValidateType(TypeIndex::Make<T>());
  }

  Status ValidateType(const TypeIndex& type_index) const;

  
  static int64_t GenerateUniqueId();

 private:
  std::string device_;
  std::string container_;
  std::string name_;
  uint64 hash_code_ = 0;
  std::string maybe_type_name_;
  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes_;
  absl::optional<ManagedStackTrace> definition_stack_trace_;
  
  
  
  
  core::IntrusivePtr<ResourceBase> resource_;
  static std::atomic<int64_t> current_id_;
};


std::string ProtoDebugString(const ResourceHandle& handle);


void EncodeResourceHandleList(const ResourceHandle* p, int64_t n, std::unique_ptr<port::StringListEncoder> e);


bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d, ResourceHandle* ps, int64_t n);

}  


