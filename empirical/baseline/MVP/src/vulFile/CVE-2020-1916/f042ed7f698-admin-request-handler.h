






namespace HPHP {



struct AdminCommandExt {
  AdminCommandExt() {
    next = s_head;
    s_head = this;
  }

  virtual std::string usage() = 0;
  virtual bool handleRequest(Transport* transport) = 0;

  template <typename L> static bool iterate(L lambda) {
    for (auto p = s_head; p; p = p->next) {
      if (lambda(p)) return true;
    }
    return false;
  }

  AdminCommandExt* next{nullptr};
  static AdminCommandExt* s_head;
};

struct AdminRequestHandler : RequestHandler {
  static AccessLog &GetAccessLog() { return s_accessLog; }

public:
  explicit AdminRequestHandler(int timeout);

  
  void setupRequest(Transport* transport) override;
  void teardownRequest(Transport* transport) noexcept override;
  void handleRequest(Transport *transport) override;
  void abortRequest(Transport *transport) override;
  void logToAccessLog(Transport* transport) override;

private:
  bool handleCheckRequest  (const std::string &cmd, Transport *transport);
  bool handleStatusRequest (const std::string &cmd, Transport *transport);
  bool handleMemoryRequest (const std::string &cmd, Transport *transport);
  bool handleStatsRequest  (const std::string &cmd, Transport *transport);
  bool handleProfileRequest(const std::string &cmd, Transport *transport);
  bool handleDumpCacheRequest (const std::string &cmd, Transport *transport);
  bool handleConstSizeRequest (const std::string &cmd, Transport *transport);
  bool handleInvalidateUnitRequest(const std::string &cmd, Transport *transport);
  bool handleStaticStringsRequest(const std::string &cmd, Transport *transport);
  bool handleDumpStaticStringsRequest(const std::string &cmd, const std::string &filename);
  bool handleRandomStaticStringsRequest(const std::string &cmd, Transport *transport);
  bool handleVMRequest      (const std::string &cmd, Transport *transport);
  void handleProxyRequest(const std::string& cmd, Transport *transport);
  bool handleRandomApcRequest (const std::string &cmd, Transport *transport);


  bool handleCPUProfilerRequest (const std::string &cmd, Transport *transport);


  static THREAD_LOCAL(AccessLog::ThreadData, s_accessLogThreadData);
  static AccessLog s_accessLog;

  static AccessLog::ThreadData* getAccessLogThreadData() {
    return s_accessLogThreadData.get();
  }
};


}

