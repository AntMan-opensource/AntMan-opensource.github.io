






















































void rand_init(void) {
	uint8_t buf[RLC_RAND_SEED];


	int *fd = (int *)&(core_get()->rand);

	*fd = open(RLC_RAND_PATH, O_RDONLY);
	if (*fd == -1) {
		RLC_THROW(ERR_NO_FILE);
		return;
	}




	memset(buf, 0, RLC_RAND_SEED);


	int fd, c, l;

	fd = open(RLC_RAND_PATH, O_RDONLY);
	if (fd == -1) {
		RLC_THROW(ERR_NO_FILE);
		return;
	}

	l = 0;
	do {
		c = read(fd, buf + l, RLC_RAND_SEED - l);
		l += c;
		if (c == -1) {
			RLC_THROW(ERR_NO_READ);
			return;
		}
	} while (l < RLC_RAND_SEED);

	if (fd != -1) {
		close(fd);
	}



	
	srandomdev();
	for (int i = 0; i < RLC_RAND_SEED; i++) {
		buf[i] = (uint8_t)random();
	}

	
	srand(1);
	for (int i = 0; i < RLC_RAND_SEED; i++) {
		buf[i] = (uint8_t)rand();
	}




	HCRYPTPROV hCryptProv;

	if (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {
		RLC_THROW(ERR_NO_FILE);
		return;
	}
	if (hCryptProv && !CryptGenRandom(hCryptProv, RLC_RAND_SEED, buf)) {
		RLC_THROW(ERR_NO_READ);
		return;
	}
	if (hCryptProv && !CryptReleaseContext(hCryptProv, 0)) {
		RLC_THROW(ERR_NO_READ);
		return;
	}



	int i, j;
	ull_t r;

	while (i < RLC_RAND_SEED) {

		while (_rdrand64_step(&r) == 0);



		for (j = 0; i < RLC_RAND_SEED && j < sizeof(ull_t); i++, j++) {
			buf[i] = r & 0xFF;
		}
	}






	core_get()->seeded = 0;
	rand_seed(buf, RLC_RAND_SEED);

	rand_seed(NULL, NULL);

}

int rand_check(uint8_t *buf, int size) {
	int count = 0;

	for (int i = 1; i < size; i++) {
		if (buf[i] == buf[i - 1]) {
			count++;
		} else {
			count = 0;
		}
	}

	if (count > RAND_REP) {
		return RLC_ERR;
	}
	return RLC_OK;
}

void rand_clean(void) {
	ctx_t *ctx = core_get();
	if (ctx != NULL) {

		int *fd = (int *)&(ctx->rand);
		close(*fd);


		memset(ctx->rand, 0, sizeof(ctx->rand));

		ctx->rand_call = NULL;
		ctx->rand_args = NULL;

		ctx->seeded = 0;
	}
}
