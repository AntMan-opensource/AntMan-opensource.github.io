













typedef int iconv_t;  



extern "C" {


struct directive;		
struct pending_option;
struct op;
struct _cpp_strbuf;

typedef bool (*convert_f) (iconv_t, const unsigned char *, size_t, struct _cpp_strbuf *);
struct cset_converter {
  convert_f func;
  iconv_t cd;
  int width;
  const char* from;
  const char* to;
};
























struct dummy {
  char c;
  union {
    double d;
    int *p;
  } u;
};








typedef struct _cpp_buff _cpp_buff;
struct _cpp_buff {
  struct _cpp_buff *next;
  unsigned char *base, *cur, *limit;
};

extern _cpp_buff *_cpp_get_buff (cpp_reader *, size_t);
extern void _cpp_release_buff (cpp_reader *, _cpp_buff *);
extern void _cpp_extend_buff (cpp_reader *, _cpp_buff **, size_t);
extern _cpp_buff *_cpp_append_extend_buff (cpp_reader *, _cpp_buff *, size_t);
extern void _cpp_free_buff (_cpp_buff *);
extern unsigned char *_cpp_aligned_alloc (cpp_reader *, size_t);
extern unsigned char *_cpp_unaligned_alloc (cpp_reader *, size_t);






enum include_type {
   
   IT_INCLUDE,   IT_INCLUDE_NEXT, IT_IMPORT,   IT_CMDLINE, IT_DEFAULT, IT_MAIN, IT_PRE_MAIN,  IT_DIRECTIVE_HWM = IT_IMPORT + 1, IT_HEADER_HWM = IT_DEFAULT + 1 };












union utoken {
  const cpp_token *token;
  const cpp_token **ptoken;
};


typedef struct tokenrun tokenrun;
struct tokenrun {
  tokenrun *next, *prev;
  cpp_token *base, *limit;
};








typedef struct {
  
  cpp_hashnode *macro_node;
  
  location_t *virt_locs;
  
  location_t *cur_virt_loc;
} macro_context;


enum context_tokens_kind {
  
  TOKENS_KIND_INDIRECT,  TOKENS_KIND_DIRECT,  TOKENS_KIND_EXTENDED };





typedef struct cpp_context cpp_context;
struct cpp_context {
  
  cpp_context *next, *prev;

  union {
    
    struct {
      union utoken first;
      union utoken last;
    } iso;

    
    struct {
      const unsigned char *cur;
      const unsigned char *rlimit;
    } trad;
  } u;

  
  _cpp_buff *buff;

  
  union {
    macro_context *mc;
    cpp_hashnode *macro;
  } c;

  
  enum context_tokens_kind tokens_kind;
};

struct lexer_state {
  
  unsigned char in_directive;

  
  unsigned char directive_wants_padding;

  
  unsigned char skipping;

  
  unsigned char angled_headers;

  
  unsigned char in_expression;

  
  unsigned char save_comments;

  
  unsigned char va_args_ok;

  
  unsigned char poisoned_ok;

  
  unsigned char prevent_expansion;

  
  unsigned char parsing_args;

  
  unsigned char discarding_output;

  
  unsigned int skip_eval;

  
  unsigned char in_deferred_pragma;

  
  unsigned char directive_file_token;

  
  unsigned char pragma_allow_expansion;
};


struct spec_nodes {
  cpp_hashnode *n_defined;		
  cpp_hashnode *n_true;			
  cpp_hashnode *n_false;		
  cpp_hashnode *n__VA_ARGS__;		
  cpp_hashnode *n__VA_OPT__;		

  enum {M_EXPORT, M_MODULE, M_IMPORT, M__IMPORT, M_HWM};
  
  
  cpp_hashnode *n_modules[M_HWM][2];
};

typedef struct _cpp_line_note _cpp_line_note;
struct _cpp_line_note {
  
  const unsigned char *pos;

  
  unsigned int type;
};


struct cpp_buffer {
  const unsigned char *cur;        
  const unsigned char *line_base;  
  const unsigned char *next_line;  

  const unsigned char *buf;        
  const unsigned char *rlimit;     
  const unsigned char *to_free;	   

  _cpp_line_note *notes;           
  unsigned int cur_note;           
  unsigned int notes_used;         
  unsigned int notes_cap;          

  struct cpp_buffer *prev;

  
  struct _cpp_file *file;

  
  const unsigned char *timestamp;

  
  struct if_stack *if_stack;

  
  bool need_line : 1;

  
  bool warned_cplusplus_comments : 1;

  
  bool from_stage3 : 1;

  
  bool return_at_eof : 1;

  
  unsigned char sysp;

  
  struct cpp_dir dir;

  
  struct cset_converter input_cset_desc;
};


struct def_pragma_macro {
  
  struct def_pragma_macro *next;
  
  char *name;
  
  unsigned char *definition;

  
  location_t line;
  
  unsigned int syshdr   : 1;
  
  unsigned int used     : 1;

  
  unsigned int is_undef : 1;
  
  unsigned int is_builtin : 1;
};


struct cpp_reader {
  
  cpp_buffer *buffer;

  
  cpp_buffer *overlaid_buffer;

  
  struct lexer_state state;

  
  class line_maps *line_table;

  
  location_t directive_line;

  
  _cpp_buff *a_buff;		
  _cpp_buff *u_buff;		
  _cpp_buff *free_buffs;	

  
  struct cpp_context base_context;
  struct cpp_context *context;

  
  const struct directive *directive;

  
  cpp_token directive_result;

  
  location_t invocation_location;

  
  cpp_hashnode *top_most_macro_node;

  
  bool about_to_expand_macro_p;

  
  struct cpp_dir *quote_include;	
  struct cpp_dir *bracket_include;	
  struct cpp_dir no_search_path;	

  
  struct _cpp_file *all_files;

  struct _cpp_file *main_file;

  
  struct htab *file_hash;
  struct htab *dir_hash;
  struct file_hash_entry_pool *file_hash_entries;

  
  struct htab *nonexistent_file_hash;
  struct obstack nonexistent_file_ob;

  
  bool quote_ignores_source_dir;

  
  bool seen_once_only;

  
  const cpp_hashnode *mi_cmacro;
  const cpp_hashnode *mi_ind_cmacro;
  bool mi_valid;

  
  cpp_token *cur_token;
  tokenrun base_run, *cur_run;
  unsigned int lookaheads;

  
  unsigned int keep_tokens;

  
  unsigned char *macro_buffer;
  unsigned int macro_buffer_len;

  
  struct cset_converter narrow_cset_desc;

  
  struct cset_converter utf8_cset_desc;

  
  struct cset_converter char16_cset_desc;

  
  struct cset_converter char32_cset_desc;

  
  struct cset_converter wide_cset_desc;

  
  const unsigned char *date;
  const unsigned char *time;

  
  time_t time_stamp;
  int time_stamp_kind; 

  
  cpp_token avoid_paste;
  cpp_token endarg;

  
  class mkdeps *deps;

  
  struct obstack hash_ob;

  
  struct obstack buffer_ob;

  
  struct pragma_entry *pragmas;

  
  struct cpp_callbacks cb;

  
  struct ht *hash_table;

  
  struct op *op_stack, *op_limit;

  
  struct cpp_options opts;

  
  struct spec_nodes spec_nodes;

  
  bool our_hashtable;

  
  struct {
    unsigned char *base;
    unsigned char *limit;
    unsigned char *cur;
    location_t first_line;
  } out;

  
  const unsigned char *saved_cur, *saved_rlimit, *saved_line_base;

  
  struct cpp_savedstate *savedstate;

  
  unsigned int counter;

  
  cpp_comment_table comments;

  
  struct def_pragma_macro *pushed_macros;

  
  location_t forced_token_location;

  
  location_t main_loc;
};

















extern const unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];

extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];



typedef unsigned char uchar;






inline int _cpp_in_system_header (cpp_reader *pfile)
{
  return pfile->buffer ? pfile->buffer->sysp : 0;
}




inline int _cpp_in_main_source_file (cpp_reader *pfile)
{
  return (!CPP_OPTION (pfile, main_search)
	  && pfile->buffer->file == pfile->main_file);
}


inline bool _cpp_defined_macro_p (cpp_hashnode *node)
{
  
  return cpp_macro_p (node) && !(node->flags & NODE_CONDITIONAL);
}


extern bool _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node, location_t);
inline bool _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node, location_t loc)
{
  if (!(node->flags & NODE_USED))
    return _cpp_notify_macro_use (pfile, node, loc);
  return true;
}
extern cpp_macro *_cpp_new_macro (cpp_reader *, cpp_macro_kind, void *);
extern void _cpp_free_definition (cpp_hashnode *);
extern bool _cpp_create_definition (cpp_reader *, cpp_hashnode *);
extern void _cpp_pop_context (cpp_reader *);
extern void _cpp_push_text_context (cpp_reader *, cpp_hashnode *, const unsigned char *, size_t);
extern bool _cpp_save_parameter (cpp_reader *, unsigned, cpp_hashnode *, cpp_hashnode *);
extern void _cpp_unsave_parameters (cpp_reader *, unsigned);
extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *, unsigned int);
extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *, cpp_hashnode *, location_t = 0);

extern int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);
extern void _cpp_push_token_context (cpp_reader *, cpp_hashnode *, const cpp_token *, unsigned int);
extern void _cpp_backup_tokens_direct (cpp_reader *, unsigned int);


extern void _cpp_init_hashtable (cpp_reader *, cpp_hash_table *);
extern void _cpp_destroy_hashtable (cpp_reader *);


enum _cpp_find_file_kind { _cpp_FFK_NORMAL, _cpp_FFK_FAKE, _cpp_FFK_PRE_INCLUDE, _cpp_FFK_HAS_INCLUDE };
extern _cpp_file *_cpp_find_file (cpp_reader *, const char *, cpp_dir *, int angle, _cpp_find_file_kind, location_t);
extern bool _cpp_find_failed (_cpp_file *);
extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);
extern const char *_cpp_find_header_unit (cpp_reader *, const char *file, bool angle_p,  location_t);
extern void _cpp_fake_include (cpp_reader *, const char *);
extern bool _cpp_stack_file (cpp_reader *, _cpp_file*, include_type, location_t);
extern bool _cpp_stack_include (cpp_reader *, const char *, int, enum include_type, location_t);
extern int _cpp_compare_file_date (cpp_reader *, const char *, int);
extern void _cpp_report_missing_guards (cpp_reader *);
extern void _cpp_init_files (cpp_reader *);
extern void _cpp_cleanup_files (cpp_reader *);
extern void _cpp_pop_file_buffer (cpp_reader *, struct _cpp_file *, const unsigned char *);
extern bool _cpp_save_file_entries (cpp_reader *pfile, FILE *f);
extern bool _cpp_read_file_entries (cpp_reader *, FILE *);
extern const char *_cpp_get_file_name (_cpp_file *);
extern struct stat *_cpp_get_file_stat (_cpp_file *);
extern bool _cpp_has_header (cpp_reader *, const char *, int, enum include_type);


extern bool _cpp_parse_expr (cpp_reader *, bool);
extern struct op *_cpp_expand_op_stack (cpp_reader *);


extern void _cpp_process_line_notes (cpp_reader *, int);
extern void _cpp_clean_line (cpp_reader *);
extern bool _cpp_get_fresh_line (cpp_reader *);
extern bool _cpp_skip_block_comment (cpp_reader *);
extern cpp_token *_cpp_temp_token (cpp_reader *);
extern const cpp_token *_cpp_lex_token (cpp_reader *);
extern cpp_token *_cpp_lex_direct (cpp_reader *);
extern unsigned char *_cpp_spell_ident_ucns (unsigned char *, cpp_hashnode *);
extern int _cpp_equiv_tokens (const cpp_token *, const cpp_token *);
extern void _cpp_init_tokenrun (tokenrun *, unsigned int);
extern cpp_hashnode *_cpp_lex_identifier (cpp_reader *, const char *);
extern int _cpp_remaining_tokens_num_in_context (cpp_context *);
extern void _cpp_init_lexer (void);
static inline void *_cpp_reserve_room (cpp_reader *pfile, size_t have, size_t extra)
{
  if (BUFF_ROOM (pfile->a_buff) < (have + extra))
    _cpp_extend_buff (pfile, &pfile->a_buff, extra);
  return BUFF_FRONT (pfile->a_buff);
}
extern void *_cpp_commit_buff (cpp_reader *pfile, size_t size);


extern void _cpp_maybe_push_include_file (cpp_reader *);
extern const char *cpp_named_operator2name (enum cpp_ttype type);
extern void _cpp_restore_special_builtin (cpp_reader *pfile, struct def_pragma_macro *);


extern int _cpp_test_assertion (cpp_reader *, unsigned int *);
extern int _cpp_handle_directive (cpp_reader *, bool);
extern void _cpp_define_builtin (cpp_reader *, const char *);
extern char ** _cpp_save_pragma_names (cpp_reader *);
extern void _cpp_restore_pragma_names (cpp_reader *, char **);
extern int _cpp_do__Pragma (cpp_reader *, location_t);
extern void _cpp_init_directives (cpp_reader *);
extern void _cpp_init_internal_pragmas (cpp_reader *);
extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *, linenum_type, unsigned int);
extern void _cpp_pop_buffer (cpp_reader *);
extern char *_cpp_bracket_include (cpp_reader *);


extern location_t cpp_diagnostic_get_current_location (cpp_reader *);


extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *, bool);
extern bool _cpp_read_logical_line_trad (cpp_reader *);
extern void _cpp_overlay_buffer (cpp_reader *pfile, const unsigned char *, size_t);
extern void _cpp_remove_overlay (cpp_reader *);
extern cpp_macro *_cpp_create_trad_definition (cpp_reader *);
extern bool _cpp_expansions_different_trad (const cpp_macro *, const cpp_macro *);
extern unsigned char *_cpp_copy_replacement_text (const cpp_macro *, unsigned char *);
extern size_t _cpp_replacement_text_len (const cpp_macro *);





struct normalize_state  {
  
  cppchar_t previous;
  
  unsigned char prev_class;
  
  enum cpp_normalize_level level;
};






extern bool _cpp_valid_ucn (cpp_reader *, const unsigned char **, const unsigned char *, int, struct normalize_state *state, cppchar_t *, source_range *char_range, cpp_string_location_reader *loc_reader);





extern bool _cpp_valid_utf8 (cpp_reader *pfile, const uchar **pstr, const uchar *limit, int identifier_pos, struct normalize_state *nst, cppchar_t *cp);





extern void _cpp_destroy_iconv (cpp_reader *);
extern unsigned char *_cpp_convert_input (cpp_reader *, const char *, unsigned char *, size_t, size_t, const unsigned char **, off_t *);

extern const char *_cpp_default_encoding (void);
extern cpp_hashnode * _cpp_interpret_identifier (cpp_reader *pfile, const unsigned char *id, size_t len);






static inline int ustrcmp (const unsigned char *, const unsigned char *);
static inline int ustrncmp (const unsigned char *, const unsigned char *, size_t);
static inline size_t ustrlen (const unsigned char *);
static inline const unsigned char *uxstrdup (const unsigned char *);
static inline const unsigned char *ustrchr (const unsigned char *, int);
static inline int ufputs (const unsigned char *, FILE *);


static inline int ustrcspn (const unsigned char *, const char *);

static inline int ustrcmp (const unsigned char *s1, const unsigned char *s2)
{
  return strcmp ((const char *)s1, (const char *)s2);
}

static inline int ustrncmp (const unsigned char *s1, const unsigned char *s2, size_t n)
{
  return strncmp ((const char *)s1, (const char *)s2, n);
}

static inline int ustrcspn (const unsigned char *s1, const char *s2)
{
  return strcspn ((const char *)s1, s2);
}

static inline size_t ustrlen (const unsigned char *s1)
{
  return strlen ((const char *)s1);
}

static inline const unsigned char * uxstrdup (const unsigned char *s1)
{
  return (const unsigned char *) xstrdup ((const char *)s1);
}

static inline const unsigned char * ustrchr (const unsigned char *s1, int c)
{
  return (const unsigned char *) strchr ((const char *)s1, c);
}

static inline int ufputs (const unsigned char *s, FILE *f)
{
  return fputs ((const char *)s, f);
}




location_t linemap_add_macro_token (const line_map_macro *, unsigned int, location_t, location_t);




int linemap_get_expansion_line (class line_maps *, location_t);


const char* linemap_get_expansion_filename (class line_maps *, location_t);


class encoding_rich_location : public rich_location {
 public:
  encoding_rich_location (cpp_reader *pfile)
  : rich_location (pfile->line_table, cpp_diagnostic_get_current_location (pfile))
  {
    set_escape_on_output (true);
  }

  encoding_rich_location (cpp_reader *pfile, location_t loc)
  : rich_location (pfile->line_table, loc)
  {
    set_escape_on_output (true);
  }
};


}



