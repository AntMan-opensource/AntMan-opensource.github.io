













	#ifdef _DEBUG
		#define STEAMNETWORKINGSOCKETS_SNP_PARANOIA 2
	#else
		#define STEAMNETWORKINGSOCKETS_SNP_PARANOIA 0
	#endif



	#if defined(__GNUC__ ) && defined( __linux__ ) && !defined( __ANDROID__ )
		#include <debug/map>
		
		template< typename K, typename V, typename L = std::less<K> > using std_map = __gnu_debug::map<K,V,L>;

		template <typename K, typename V, typename L> inline int len( const std_map<K,V,L> &map )
		{
			return (int)map.size();
		}

	#else
		template< typename K, typename V, typename L = std::less<K> > using std_map = std::map<K,V,L>;
	#endif

	template< typename K, typename V, typename L = std::less<K> > using std_map = std::map<K,V,L>;


struct P2PSessionState_t;

namespace SteamNetworkingSocketsLib {


constexpr int k_nAckDelayPrecisionShift = 5;
constexpr SteamNetworkingMicroseconds k_usecAckDelayPrecision = (1 << k_nAckDelayPrecisionShift );














constexpr SteamNetworkingMicroseconds k_usecNackFlush = 3*1000;


constexpr int k_cbMaxMessageSizeRecv = k_cbMaxSteamNetworkingSocketsMessageSizeSend*2;




constexpr int k_cbMaxBufferedReceiveReliableData = k_cbMaxMessageSizeRecv + 64*1024;
constexpr int k_nMaxReliableStreamGaps_Extend = 30; 
constexpr int k_nMaxReliableStreamGaps_Fragment = 20; 
constexpr int k_nMaxPacketGaps = 62; 











constexpr int k_nMaxBufferedUnreliableSegments = 20;




constexpr int k_cbMaxUnreliableMsgSize = 15*1100;

class CSteamNetworkConnectionBase;
class CConnectionTransport;
struct SteamNetworkingMessageQueue;




class CSteamNetworkingMessage : public SteamNetworkingMessage_t {
public:
	static CSteamNetworkingMessage *New( CSteamNetworkConnectionBase *pParent, uint32 cbSize, int64 nMsgNum, int nFlags, SteamNetworkingMicroseconds usecNow );
	static CSteamNetworkingMessage *New( uint32 cbSize );
	static void DefaultFreeData( SteamNetworkingMessage_t *pMsg );

	
	
	
	
	inline SteamNetworkingMicroseconds SNPSend_UsecNagle() const { return m_usecTimeReceived; }
	inline void SNPSend_SetUsecNagle( SteamNetworkingMicroseconds x ) { m_usecTimeReceived = x; }

	
	inline int64 SNPSend_ReliableStreamPos() const { return m_nConnUserData; }
	inline void SNPSend_SetReliableStreamPos( int64 x ) { m_nConnUserData = x; }
	inline int SNPSend_ReliableStreamSize() const {
		DbgAssert( m_nFlags & k_nSteamNetworkingSend_Reliable && m_nConnUserData > 0 && m_cbSNPSendReliableHeader > 0 && m_cbSize >= m_cbSNPSendReliableHeader );
		return m_cbSize;
	}

	inline bool SNPSend_IsReliable() const {
		if ( m_nFlags & k_nSteamNetworkingSend_Reliable )
		{
			DbgAssert( m_nConnUserData > 0 && m_cbSNPSendReliableHeader > 0 && m_cbSize >= m_cbSNPSendReliableHeader );
			return true;
		}
		DbgAssert( m_nConnUserData == 0 && m_cbSNPSendReliableHeader == 0 );
		return false;
	}

	
	int m_cbSNPSendReliableHeader;
	byte *SNPSend_ReliableHeader()
	{
		
		return (byte*)&m_identityPeer;
	}

	
	void Unlink();

	struct Links {
		SteamNetworkingMessageQueue *m_pQueue;
		CSteamNetworkingMessage *m_pPrev;
		CSteamNetworkingMessage *m_pNext;

		inline void Clear() { m_pQueue = nullptr; m_pPrev = nullptr; m_pNext = nullptr; }
	};

	
	Links m_links;

	
	
	Links m_linksSecondaryQueue;

	void LinkBefore( CSteamNetworkingMessage *pSuccessor, Links CSteamNetworkingMessage::*pMbrLinks, SteamNetworkingMessageQueue *pQueue );
	void LinkToQueueTail( Links CSteamNetworkingMessage::*pMbrLinks, SteamNetworkingMessageQueue *pQueue );
	void UnlinkFromQueue( Links CSteamNetworkingMessage::*pMbrLinks );

private:
	
	inline CSteamNetworkingMessage() {}
	inline ~CSteamNetworkingMessage() {}
	static void ReleaseFunc( SteamNetworkingMessage_t *pIMsg );
};


struct SteamNetworkingMessageQueue {
	CSteamNetworkingMessage *m_pFirst = nullptr;
	CSteamNetworkingMessage *m_pLast = nullptr;

	inline bool empty() const {
		if ( m_pFirst )
		{
			Assert( m_pLast );
			return false;
		}
		Assert( !m_pLast );
		return true;
	}

	
	int RemoveMessages( SteamNetworkingMessage_t **ppOutMessages, int nMaxMessages );

	
	void PurgeMessages();
};


const int k_nMaxPacketsPerThink = 16;


const float k_flSendRateBurstOverageAllowance = k_cbSteamNetworkingSocketsMaxEncryptedPayloadSend;

struct SNPRange_t {
	
	int64 m_nBegin;
	int64 m_nEnd; 

	inline int64 length() const {
		
		Assert( m_nEnd >= m_nBegin );
		return m_nEnd - m_nBegin;
	}

	
	
	
	struct NonOverlappingLess {
		inline bool operator ()(const SNPRange_t &l, const SNPRange_t &r ) const {
			if ( l.m_nBegin < r.m_nBegin ) return true;
			AssertMsg( l.m_nBegin > r.m_nBegin || l.m_nEnd == r.m_nEnd, "Ranges should not overlap in this map!" );
			return false;
		}
	};
};





struct SNPInFlightPacket_t {
	
	
	
	

	
	SteamNetworkingMicroseconds m_usecWhenSent;

	
	
	
	bool m_bNack;

	
	CConnectionTransport *m_pTransport;

	
	
	
	
	
	vstd::small_vector<SNPRange_t,1> m_vecReliableSegments;
};

struct SSNPSendMessageList : public SteamNetworkingMessageQueue {

	
	
	
	CSteamNetworkingMessage *pop_front()
	{
		CSteamNetworkingMessage *pResult = m_pFirst;
		if ( pResult )
		{
			Assert( m_pLast );
			Assert( pResult->m_links.m_pQueue == this );
			Assert( pResult->m_links.m_pPrev == nullptr );
			m_pFirst = pResult->m_links.m_pNext;
			if ( m_pFirst )
			{
				Assert( m_pFirst->m_links.m_pPrev == pResult );
				Assert( m_pFirst->m_nMessageNumber > pResult->m_nMessageNumber );
				m_pFirst->m_links.m_pPrev = nullptr;
			}
			else {
				Assert( m_pLast == pResult );
				m_pLast = nullptr;
			}
			pResult->m_links.m_pQueue = nullptr;
			pResult->m_links.m_pNext = nullptr;
		}
		return pResult;
	}

	
	void push_back( CSteamNetworkingMessage *pMsg )
	{
		if ( m_pFirst == nullptr )
		{
			Assert( m_pLast == nullptr );
			m_pFirst = pMsg;
		}
		else {
			
			Assert( pMsg->m_nMessageNumber > m_pLast->m_nMessageNumber );
			Assert( m_pLast->m_links.m_pNext == nullptr );
			m_pLast->m_links.m_pNext = pMsg;
		}
		pMsg->m_links.m_pQueue = this;
		pMsg->m_links.m_pNext = nullptr;
		pMsg->m_links.m_pPrev = m_pLast;
		m_pLast = pMsg;
	}

};

struct SSNPSenderState {
	SSNPSenderState();
	~SSNPSenderState() {
		Shutdown();
	}
	void Shutdown();

	
	
	
	
	int m_n_x = 32*1024;

	
	
	
	
	
	
	
	
	
	
	
	float m_flTokenBucket = 0;

	
	SteamNetworkingMicroseconds m_usecTokenBucketTime = 0;

	void TokenBucket_Init( SteamNetworkingMicroseconds usecNow )
	{
		m_usecTokenBucketTime = usecNow;
		m_flTokenBucket = k_flSendRateBurstOverageAllowance;
	}

	
	void TokenBucket_Limit()
	{
		if ( m_flTokenBucket > k_flSendRateBurstOverageAllowance )
			m_flTokenBucket = k_flSendRateBurstOverageAllowance;
	}

	
	
	SteamNetworkingMicroseconds CalcTimeUntilNextSend() const {
		
		if ( m_flTokenBucket >= 0.0f )
			return 0;

		return SteamNetworkingMicroseconds( m_flTokenBucket * -1e6f / (float)m_n_x ) + 1; 
	}

	
	void ClearNagleTimers()
	{
		CSteamNetworkingMessage *pMsg = m_messagesQueued.m_pLast;
		while ( pMsg && pMsg->SNPSend_UsecNagle() )
		{
			pMsg->SNPSend_SetUsecNagle( 0 );
			pMsg = pMsg->m_links.m_pPrev;
		}
	}

	
	int64 m_nReliableStreamPos = 1;
	int64 m_nLastSentMsgNum = 0; 
	int64 m_nLastSendMsgNumReliable = 0;

	
	
	
	SSNPSendMessageList m_messagesQueued;

	
	int m_cbCurrentSendMessageSent = 0;

	
	
	
	
	
	
	SSNPSendMessageList m_unackedReliableMessages;

	
	int m_cbPendingUnreliable = 0;
	int m_cbPendingReliable = 0;
	int m_cbSentUnackedReliable = 0;
	inline int PendingBytesTotal() const { return m_cbPendingUnreliable + m_cbPendingReliable; }

	
	int64 m_nMessagesSentReliable = 0;
	int64 m_nMessagesSentUnreliable = 0;

	
	
	
	std_map<int64,SNPInFlightPacket_t> m_mapInFlightPacketsByPktNum;

	
	
	
	std_map<int64,SNPInFlightPacket_t>::iterator m_itNextInFlightPacketToTimeout;

	
	
	
	
	
	
	std_map<SNPRange_t,CSteamNetworkingMessage*,SNPRange_t::NonOverlappingLess> m_listInFlightReliableRange;

	
	
	std_map<SNPRange_t,CSteamNetworkingMessage*,SNPRange_t::NonOverlappingLess> m_listReadyRetryReliableRange;

	
	
	int64 m_nMinPktWaitingOnAck = 0;

	
	void RemoveAckedReliableMessageFromUnackedList();

	
	#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA == 0 
		inline void DebugCheckInFlightPacketMap() const {}
	#else
		void DebugCheckInFlightPacketMap() const;
	#endif
	#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA > 1
		inline void MaybeCheckInFlightPacketMap() const { DebugCheckInFlightPacketMap(); }
	#else
		inline void MaybeCheckInFlightPacketMap() const {}
	#endif
};

struct SSNPRecvUnreliableSegmentKey {
	int64 m_nMsgNum;
	int m_nOffset;

	inline bool operator<(const SSNPRecvUnreliableSegmentKey &x) const {
		if ( m_nMsgNum < x.m_nMsgNum ) return true;
		if ( m_nMsgNum > x.m_nMsgNum ) return false;
		return m_nOffset < x.m_nOffset;
	}
};

struct SSNPRecvUnreliableSegmentData {
	int m_cbSegSize = -1;
	bool m_bLast = false;
	char m_buf[ k_cbSteamNetworkingSocketsMaxPlaintextPayloadRecv ];
};

struct SSNPPacketGap {
	int64 m_nEnd; 
	SteamNetworkingMicroseconds m_usecWhenReceivedPktBefore; 
	SteamNetworkingMicroseconds m_usecWhenAckPrior; 
	SteamNetworkingMicroseconds m_usecWhenOKToNack; 
};

struct SSNPReceiverState {
	SSNPReceiverState();
	~SSNPReceiverState() {
		Shutdown();
	}
	void Shutdown();

	
	
	
	
	std_map<SSNPRecvUnreliableSegmentKey,SSNPRecvUnreliableSegmentData> m_mapUnreliableSegments;

	
	
	int64 m_nReliableStreamPos = 1;

	
	int64 m_nHighestSeenMsgNum = 0;

	
	int64 m_nLastRecvReliableMsgNum = 0;

	
	std::vector<byte> m_bufReliableStream;

	
	
	
	
	
	
	
	std_map<int64,int64> m_mapReliableStreamGaps;

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	std_map<int64,SSNPPacketGap> m_mapPacketGaps;

	
	int64 m_nMinPktNumToSendAcks = 0;

	
	int64 m_nPktNumUpdatedMinPktNumToSendAcks = 0;

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	std_map<int64,SSNPPacketGap>::iterator m_itPendingAck;

	
	
	
	
	std_map<int64,SSNPPacketGap>::iterator m_itPendingNack;

	
	
	
	
	
	void QueueFlushAllAcks( SteamNetworkingMicroseconds usecWhen );

	
	
	inline SteamNetworkingMicroseconds TimeWhenFlushAcks() const {
		
		if ( m_mapPacketGaps.empty() )
		{
			AssertMsg( false, "TimeWhenFlushAcks - we're shut down!" );
			return INT64_MAX;
		}
		return m_itPendingAck->second.m_usecWhenAckPrior;
	}

	
	#if STEAMNETWORKINGSOCKETS_SNP_PARANOIA > 1
		void DebugCheckPackGapMap() const;
	#else
		inline void DebugCheckPackGapMap() const {}
	#endif

	
	int64 m_nMessagesRecvReliable = 0;
	int64 m_nMessagesRecvUnreliable = 0;
};

} 
