









 #define GIT_GNUC_PREREQ(maj, min) 0


























 





































 





























































































typedef long intptr_t;
typedef unsigned long uintptr_t;

















extern int compat_mkdir_wo_trailing_slash(const char*, mode_t);



struct itimerval {
	struct timeval it_interval;
	struct timeval it_value;
};










extern char *gitbasename(char *);

extern char *gitdirname(char *);




















































typedef uintmax_t timestamp_t;
















static inline int git_has_dos_drive_prefix(const char *path)
{
	return 0;
}




static inline int git_skip_dos_drive_prefix(char **path)
{
	return 0;
}




static inline int git_is_dir_sep(int c)
{
	return c == '/';
}




static inline int git_offset_1st_component(const char *path)
{
	return is_dir_sep(path[0]);
}








static inline char *git_find_last_dir_sep(const char *path)
{
	return strrchr(path, '/');
}

































struct strbuf;


extern void vreportf(const char *prefix, const char *err, va_list params);
extern NORETURN void usage(const char *err);
extern NORETURN void usagef(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern NORETURN void die(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern NORETURN void die_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern int error_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));
extern void warning_errno(const char *err, ...) __attribute__((format (printf, 1, 2)));













static inline int const_error(void)
{
	return -1;
}




extern void set_die_routine(NORETURN_PTR void (*routine)(const char *err, va_list params));
extern void set_error_routine(void (*routine)(const char *err, va_list params));
extern void (*get_error_routine(void))(const char *err, va_list params);
extern void set_warn_routine(void (*routine)(const char *warn, va_list params));
extern void (*get_warn_routine(void))(const char *warn, va_list params);
extern void set_die_is_recursing_routine(int (*routine)(void));

extern int starts_with(const char *str, const char *prefix);


static inline int skip_prefix(const char *str, const char *prefix, const char **out)
{
	do {
		if (!*prefix) {
			*out = str;
			return 1;
		}
	} while (*str++ == *prefix++);
	return 0;
}


int skip_to_optional_arg_default(const char *str, const char *prefix, const char **arg, const char *def);

static inline int skip_to_optional_arg(const char *str, const char *prefix, const char **arg)
{
	return skip_to_optional_arg_default(str, prefix, arg, "");
}


static inline int skip_prefix_mem(const char *buf, size_t len, const char *prefix, const char **out, size_t *outlen)

{
	size_t prefix_len = strlen(prefix);
	if (prefix_len <= len && !memcmp(buf, prefix, prefix_len)) {
		*out = buf + prefix_len;
		*outlen = len - prefix_len;
		return 1;
	}
	return 0;
}


static inline int strip_suffix_mem(const char *buf, size_t *len, const char *suffix)
{
	size_t suflen = strlen(suffix);
	if (*len < suflen || memcmp(buf + (*len - suflen), suffix, suflen))
		return 0;
	*len -= suflen;
	return 1;
}


static inline int strip_suffix(const char *str, const char *suffix, size_t *len)
{
	*len = strlen(str);
	return strip_suffix_mem(str, len, suffix);
}

static inline int ends_with(const char *str, const char *suffix)
{
	size_t len;
	return strip_suffix(str, suffix, &len);
}




















extern void *git_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
extern int git_munmap(void *start, size_t length);




















































extern int git_stat(const char *, struct stat *);




extern int git_fstat(int, struct stat *);




extern int git_lstat(const char *, struct stat *);






extern ssize_t git_pread(int fd, void *buf, size_t count, off_t offset);


extern ssize_t read_in_full(int fd, void *buf, size_t count);



extern int gitsetenv(const char *, const char *, int);




extern char *gitmkdtemp(char *);




extern void gitunsetenv(const char *);




extern char *gitstrcasestr(const char *haystack, const char *needle);




extern size_t gitstrlcpy(char *, const char *, size_t);




extern uintmax_t gitstrtoumax(const char *, char **, int);

extern intmax_t gitstrtoimax(const char *, char **, int);




extern const char *githstrerror(int herror);




void *gitmemmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen);







char *gitstrdup(const char *s);

















extern FILE *git_fopen(const char*, const char*);







extern int git_snprintf(char *str, size_t maxsize, const char *format, ...);




extern int git_vsnprintf(char *str, size_t maxsize, const char *format, va_list ap);










static inline char *gitstrchrnul(const char *s, int c)
{
	while (*s && *s != c)
		s++;
	return (char *)s;
}



int inet_pton(int af, const char *src, void *dst);



const char *inet_ntop(int af, const void *src, char *dst, size_t size);




extern int git_atexit(void (*handler)(void));


typedef void (*try_to_free_t)(size_t);
extern try_to_free_t set_try_to_free_routine(try_to_free_t);

static inline size_t st_add(size_t a, size_t b)
{
	if (unsigned_add_overflows(a, b))
		die("size_t overflow: %"PRIuMAX" + %"PRIuMAX, (uintmax_t)a, (uintmax_t)b);
	return a + b;
}



static inline size_t st_mult(size_t a, size_t b)
{
	if (unsigned_mult_overflows(a, b))
		die("size_t overflow: %"PRIuMAX" * %"PRIuMAX, (uintmax_t)a, (uintmax_t)b);
	return a * b;
}

static inline size_t st_sub(size_t a, size_t b)
{
	if (a < b)
		die("size_t underflow: %"PRIuMAX" - %"PRIuMAX, (uintmax_t)a, (uintmax_t)b);
	return a - b;
}









extern char *xstrdup(const char *str);
extern void *xmalloc(size_t size);
extern void *xmallocz(size_t size);
extern void *xmallocz_gently(size_t size);
extern void *xmemdupz(const void *data, size_t len);
extern char *xstrndup(const char *str, size_t len);
extern void *xrealloc(void *ptr, size_t size);
extern void *xcalloc(size_t nmemb, size_t size);
extern void *xmmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
extern void *xmmap_gently(void *start, size_t length, int prot, int flags, int fd, off_t offset);
extern int xopen(const char *path, int flags, ...);
extern ssize_t xread(int fd, void *buf, size_t len);
extern ssize_t xwrite(int fd, const void *buf, size_t len);
extern ssize_t xpread(int fd, void *buf, size_t len, off_t offset);
extern int xdup(int fd);
extern FILE *xfopen(const char *path, const char *mode);
extern FILE *xfdopen(int fd, const char *mode);
extern int xmkstemp(char *temp_filename);
extern int xmkstemp_mode(char *temp_filename, int mode);
extern char *xgetcwd(void);
extern FILE *fopen_for_writing(const char *path);
extern FILE *fopen_or_warn(const char *path, const char *mode);








static inline void copy_array(void *dst, const void *src, size_t n, size_t size)
{
	if (n)
		memcpy(dst, src, st_mult(size, n));
}


static inline void move_array(void *dst, const void *src, size_t n, size_t size)
{
	if (n)
		memmove(dst, src, st_mult(size, n));
}














static inline char *xstrdup_or_null(const char *str)
{
	return str ? xstrdup(str) : NULL;
}

static inline size_t xsize_t(off_t len)
{
	size_t size = (size_t) len;

	if (len != (off_t) size)
		die("Cannot handle files this big");
	return size;
}

__attribute__((format (printf, 3, 4)))
extern int xsnprintf(char *dst, size_t max, const char *fmt, ...);





extern int xgethostname(char *buf, size_t len);


extern const unsigned char tolower_trans_tbl[256];
















extern const unsigned char sane_ctype[256];


























static inline int sane_case(int x, int high)
{
	if (sane_istest(x, GIT_ALPHA))
		x = (x & ~0x20) | high;
	return x;
}

static inline int sane_iscase(int x, int is_lower)
{
	if (!sane_istest(x, GIT_ALPHA))
		return 0;

	if (is_lower)
		return (x & 0x20) != 0;
	else return (x & 0x20) == 0;
}


static inline int skip_iprefix(const char *str, const char *prefix, const char **out)
{
	do {
		if (!*prefix) {
			*out = str;
			return 1;
		}
	} while (tolower(*str++) == tolower(*prefix++));
	return 0;
}

static inline int strtoul_ui(char const *s, int base, unsigned int *result)
{
	unsigned long ul;
	char *p;

	errno = 0;
	
	if (strchr(s, '-'))
		return -1;
	ul = strtoul(s, &p, base);
	if (errno || *p || p == s || (unsigned int) ul != ul)
		return -1;
	*result = ul;
	return 0;
}

static inline int strtol_i(char const *s, int base, int *result)
{
	long ul;
	char *p;

	errno = 0;
	ul = strtol(s, &p, base);
	if (errno || *p || p == s || (int) ul != ul)
		return -1;
	*result = ul;
	return 0;
}


void git_qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));




static inline void sane_qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *))
{
	if (nmemb > 1)
		qsort(base, nmemb, size, compar);
}


int git_qsort_s(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *, void *), void *ctx);











static inline int regexec_buf(const regex_t *preg, const char *buf, size_t size, size_t nmatch, regmatch_t pmatch[], int eflags)
{
	assert(nmatch > 0 && pmatch);
	pmatch[0].rm_so = 0;
	pmatch[0].rm_eo = size;
	return regexec(preg, buf, nmatch, pmatch, eflags | REG_STARTEND);
}









































__attribute__((format (printf, 3, 4))) NORETURN void BUG_fl(const char *file, int line, const char *fmt, ...);


__attribute__((format (printf, 1, 2))) NORETURN void BUG(const char *fmt, ...);



int unlink_or_warn(const char *path);
 
int unlink_or_msg(const char *file, struct strbuf *err);

int rmdir_or_warn(const char *path);

int remove_or_warn(unsigned int mode, const char *path);



int access_or_warn(const char *path, int mode, unsigned flag);
int access_or_die(const char *path, int mode, unsigned flag);


int warn_on_fopen_errors(const char *path);


struct tm *git_gmtime(const time_t *);
struct tm *git_gmtime_r(const time_t *, struct tm *);



















static inline int is_missing_file_error(int errno_)
{
	return (errno_ == ENOENT || errno_ == ENOTDIR);
}

extern int cmd_main(int, const char **);



extern void unleak_memory(const void *ptr, size_t len);






