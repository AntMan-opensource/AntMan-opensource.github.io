

















static char dlt_name[] = "jnpr_eth";
static uint16_t dlt_value = DLT_JUNIPER_ETHER;


int  dlt_jnpr_ether_register(tcpeditdlt_t *ctx)
{
    tcpeditdlt_plugin_t *plugin;
    assert(ctx);

    
    plugin = tcpedit_dlt_newplugin();

    plugin->provides += PLUGIN_MASK_PROTO + PLUGIN_MASK_SRCADDR + PLUGIN_MASK_DSTADDR;
    plugin->requires = 0;

     
    plugin->dlt = dlt_value;

    
    plugin->name = safe_strdup(dlt_name);

    
    plugin->plugin_init = dlt_jnpr_ether_init;
    plugin->plugin_post_init = dlt_jnpr_ether_post_init;
    plugin->plugin_cleanup = dlt_jnpr_ether_cleanup;
    plugin->plugin_parse_opts = dlt_jnpr_ether_parse_opts;
    plugin->plugin_decode = dlt_jnpr_ether_decode;
    plugin->plugin_encode = dlt_jnpr_ether_encode;
    plugin->plugin_proto = dlt_jnpr_ether_proto;
    plugin->plugin_l2addr_type = dlt_jnpr_ether_l2addr_type;
    plugin->plugin_l2len = dlt_jnpr_ether_l2len;
    plugin->plugin_get_layer3 = dlt_jnpr_ether_get_layer3;
    plugin->plugin_merge_layer3 = dlt_jnpr_ether_merge_layer3;
    plugin->plugin_get_mac = dlt_jnpr_ether_get_mac;

    
    return tcpedit_dlt_addplugin(ctx, plugin);
}

 

int  dlt_jnpr_ether_init(tcpeditdlt_t *ctx)
{
    tcpeditdlt_plugin_t *plugin;
    assert(ctx);
    
    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) {
        tcpedit_seterr(ctx->tcpedit, "Unable to initialize unregistered plugin %s", dlt_name);
        return TCPEDIT_ERROR;
    }
    
    
    plugin->config_size = sizeof(jnpr_ether_config_t);
    plugin->config = safe_malloc(plugin->config_size);

    return TCPEDIT_OK; 
}


int  dlt_jnpr_ether_post_init(tcpeditdlt_t *ctx)
{
    jnpr_ether_config_t *config;
    
    
    if (ctx->decoder->dlt != dlt_value)
        return TCPEDIT_OK;
    
    
    config = (jnpr_ether_config_t *)ctx->encoder->config;
    if (config->subctx == NULL)
        config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);
        
    return TCPEDIT_OK;
}


int  dlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx)
{
    tcpeditdlt_plugin_t *plugin;
    
    assert(ctx);

    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) {
        tcpedit_seterr(ctx->tcpedit, "Unable to cleanup unregistered plugin %s", dlt_name);
        return TCPEDIT_ERROR;
    }

    safe_free(plugin->name);
    plugin->name = NULL;
    if (plugin->config != NULL) {
        
        jnpr_ether_config_t *config;

        config = (jnpr_ether_config_t *)ctx->encoder->config;
        tcpedit_dlt_cleanup(config->subctx);
        safe_free(plugin->config);
        plugin->config = NULL;
        plugin->config_size = 0;
    }

    return TCPEDIT_OK; 
}


int  dlt_jnpr_ether_parse_opts(tcpeditdlt_t *ctx)
{
    assert(ctx);

    return TCPEDIT_OK; 
}


int  dlt_jnpr_ether_decode(tcpeditdlt_t *ctx, const u_char *packet, const int pktlen)
{
    int jnpr_header_len = 0;
    const u_char *ethernet = NULL;
    jnpr_ether_config_t *config;
    
    
    assert(ctx);
    assert(packet);

    
    if (pktlen < JUNIPER_ETHER_HEADER_LEN)
        return TCPEDIT_ERROR;

    config = (jnpr_ether_config_t *)ctx->encoder->config;

    
    
    if (memcmp(packet, JUNIPER_ETHER_MAGIC, JUNIPER_ETHER_MAGIC_LEN) != 0) {
        tcpedit_seterr(ctx->tcpedit, "Invalid magic 0x%02X%02X%02X",  packet[0], packet[1], packet[2]);
        return TCPEDIT_ERROR;
    }
    
    
    if ((packet[JUNIPER_ETHER_OPTIONS_OFFSET] & JUNIPER_ETHER_L2PRESENT) 
            != JUNIPER_ETHER_L2PRESENT) {
        tcpedit_seterr(ctx->tcpedit, "Frame is missing L2 Header: %x",  packet[JUNIPER_ETHER_OPTIONS_OFFSET]);
        return TCPEDIT_ERROR;
    }
    
    
    memcpy(&jnpr_header_len, &packet[JUNIPER_ETHER_EXTLEN_OFFSET], 2);
    
    jnpr_header_len = ntohs(jnpr_header_len) + JUNIPER_ETHER_HEADER_LEN;

    dbgx(1, "jnpr header len: %d", jnpr_header_len);
    

    if (pktlen < jnpr_header_len + TCPR_ETH_H) {
        tcpedit_seterr(ctx->tcpedit, "Frame is too short! %d < %d",  pktlen, (jnpr_header_len + TCPR_ETH_H));
        return TCPEDIT_ERROR;
    }
    
    ctx->l2len = jnpr_header_len;
    
    
    ethernet = packet + jnpr_header_len;

    
    if (tcpedit_dlt_decode(config->subctx, ethernet, (pktlen - jnpr_header_len)) == TCPEDIT_ERROR)
        return TCPEDIT_ERROR;

    
    if (tcpedit_dlt_copy_decoder_state(ctx, config->subctx) == TCPEDIT_ERROR)
        return TCPEDIT_ERROR;
    
    return TCPEDIT_OK;
}


int  dlt_jnpr_ether_encode(tcpeditdlt_t *ctx, u_char *packet, int pktlen, _U_ tcpr_dir_t dir)
{
    assert(ctx);
    assert(packet);

    
    if (pktlen < JUNIPER_ETHER_HEADER_LEN)
        return TCPEDIT_ERROR;
    
    tcpedit_seterr(ctx->tcpedit, "%s", "DLT_JUNIPER_ETHER plugin does not support packet encoding");
    return TCPEDIT_ERROR;
}


int  dlt_jnpr_ether_proto(tcpeditdlt_t *ctx, const u_char *packet, const int pktlen)
{
    int jnpr_hdr_len;
    const u_char *ethernet;
    jnpr_ether_config_t *config;

    assert(ctx);
    assert(packet);

    
    if (pktlen < JUNIPER_ETHER_HEADER_LEN)
        return TCPEDIT_ERROR;

    config = (jnpr_ether_config_t *)ctx->encoder->config;


    
    if ((packet[JUNIPER_ETHER_OPTIONS_OFFSET] & JUNIPER_ETHER_L2PRESENT) 
            != JUNIPER_ETHER_L2PRESENT) {
        tcpedit_seterr(ctx->tcpedit, "Frame is missing L2 Header: %x",  packet[JUNIPER_ETHER_OPTIONS_OFFSET]);
        return TCPEDIT_ERROR;
    }

    
    memcpy(&jnpr_hdr_len, &packet[JUNIPER_ETHER_EXTLEN_OFFSET], 2);
    
    jnpr_hdr_len = ntohs(jnpr_hdr_len) + JUNIPER_ETHER_HEADER_LEN;
    ethernet = packet + jnpr_hdr_len;
    
    
    return tcpedit_dlt_proto(config->subctx, DLT_EN10MB, ethernet, (pktlen - jnpr_hdr_len));
}


u_char * dlt_jnpr_ether_get_layer3(tcpeditdlt_t *ctx, u_char *packet, const int pktlen)
{
    int l2len;
    assert(ctx);
    assert(packet);

    
    if ((packet[JUNIPER_ETHER_OPTIONS_OFFSET] & JUNIPER_ETHER_L2PRESENT) 
            != JUNIPER_ETHER_L2PRESENT) {
        tcpedit_seterr(ctx->tcpedit, "Frame is missing L2 Header: %x",  packet[JUNIPER_ETHER_OPTIONS_OFFSET]);
        return NULL;
    }

    l2len = dlt_jnpr_ether_l2len(ctx, packet, pktlen);
    if (l2len == -1 || pktlen < l2len)
        return NULL;

    return tcpedit_dlt_l3data_copy(ctx, packet, pktlen, l2len);
}


u_char * dlt_jnpr_ether_merge_layer3(tcpeditdlt_t *ctx, u_char *packet, const int pktlen, u_char *ipv4_data, u_char *ipv6_data)




{
    int l2len;
    assert(ctx);
    assert(packet);
    assert(ipv4_data || ipv6_data);
    
    l2len = dlt_jnpr_ether_l2len(ctx, packet, pktlen);
    if (l2len == -1 || pktlen < l2len)
        return NULL;
    
    return tcpedit_dlt_l3data_merge(ctx, packet, pktlen, ipv4_data ?: ipv6_data, l2len);
}

    
u_char * dlt_jnpr_ether_get_mac(tcpeditdlt_t *ctx, tcpeditdlt_mac_type_t mac, const u_char *packet, const int pktlen)
{
    const u_char *ethernet = NULL;
    jnpr_ether_config_t *config;
    int jnpr_hdr_len = 0;

    assert(ctx);
    assert(packet);

    if (pktlen < JUNIPER_ETHER_EXTLEN_OFFSET + 2)
        return NULL;

    config = (jnpr_ether_config_t *)ctx->encoder->config;

    
    memcpy(&jnpr_hdr_len, &packet[JUNIPER_ETHER_EXTLEN_OFFSET], 2);
    
    jnpr_hdr_len = ntohs(jnpr_hdr_len) + JUNIPER_ETHER_HEADER_LEN;
    ethernet = packet + jnpr_hdr_len;
    
    return dlt_en10mb_get_mac(config->subctx, mac, ethernet, (pktlen - jnpr_hdr_len));
}



int dlt_jnpr_ether_l2len(tcpeditdlt_t *ctx, const u_char *packet, const int pktlen)
{
    int len, res;
    jnpr_ether_config_t *config;

    assert(ctx);
    assert(packet);

    if (pktlen < JUNIPER_ETHER_EXTLEN_OFFSET + 2)
        return -1;
    
    config = (jnpr_ether_config_t *)ctx->encoder->config;

    
    memcpy(&len, &packet[JUNIPER_ETHER_EXTLEN_OFFSET], 2);
    
    len = ntohs(len) + JUNIPER_ETHER_HEADER_LEN;
    dbgx(3, "juniper header len: %u", len);
    
    
    res = tcpedit_dlt_l2len(config->subctx, DLT_EN10MB, (packet + len), (pktlen - len));
    if (res == -1)
        return TCPEDIT_ERROR;

    len += res;
    dbgx(3, "total l2len: %u", len);
    
    
    return len;
}


tcpeditdlt_l2addr_type_t  dlt_jnpr_ether_l2addr_type(void)
{
    return ETHERNET;
}

