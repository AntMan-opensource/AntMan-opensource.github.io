



















































































typedef ssize_t (Curl_send)(struct Curl_easy *data,    int sockindex, const void *buf, size_t len, CURLcode *err);





typedef ssize_t (Curl_recv)(struct Curl_easy *data,    int sockindex, char *buf, size_t len, CURLcode *err);





typedef CURLcode (*Curl_datastream)(struct Curl_easy *data, struct connectdata *conn, int *didwhat, bool *done, int select_res);





















































typedef bool bit;


typedef unsigned int bit;





struct krb5buffer {
  void *data;
  size_t size;
  size_t index;
  BIT(eof_flag);
};

enum protection_level {
  PROT_NONE,  PROT_CLEAR, PROT_SAFE, PROT_CONFIDENTIAL, PROT_PRIVATE, PROT_CMD, PROT_LAST };









typedef enum {
  ssl_connect_1, ssl_connect_2, ssl_connect_2_reading, ssl_connect_2_writing, ssl_connect_3, ssl_connect_done } ssl_connect_state;






typedef enum {
  ssl_connection_none, ssl_connection_negotiating, ssl_connection_complete } ssl_connection_state;




struct ssl_backend_data;


struct ssl_connect_data {
  ssl_connection_state state;
  ssl_connect_state connecting_state;

  struct ssl_backend_data *backend;

  
  BIT(use);
};

struct ssl_primary_config {
  long version;          
  long version_max;      
  char *CApath;          
  char *CAfile;          
  char *clientcert;
  char *random_file;     
  char *egdsocket;       
  char *cipher_list;     
  char *cipher_list13;   
  char *pinned_key;
  struct curl_blob *cert_blob;
  struct curl_blob *ca_info_blob;
  char *curves;          
  BIT(verifypeer);       
  BIT(verifyhost);       
  BIT(verifystatus);     
  BIT(sessionid);        
};

struct ssl_config_data {
  struct ssl_primary_config primary;
  long certverifyresult; 
  char *CRLfile;   
  char *issuercert;
  struct curl_blob *issuercert_blob;
  curl_ssl_ctx_callback fsslctx; 
  void *fsslctxp;        
  char *cert_type; 
  char *key; 
  struct curl_blob *key_blob;
  char *key_type; 
  char *key_passwd; 

  char *username; 
  char *password; 
  enum CURL_TLSAUTH authtype; 

  BIT(certinfo);     
  BIT(falsestart);
  BIT(enable_beast); 
  BIT(no_revoke);    
  BIT(no_partialchain); 
  BIT(revoke_best_effort); 
  BIT(native_ca_store); 
  BIT(auto_client_cert);   
};

struct ssl_general_config {
  size_t max_ssl_sessions; 
};


struct Curl_ssl_session {
  char *name;       
  char *conn_to_host; 
  const char *scheme; 
  void *sessionid;  
  size_t idsize;    
  long age;         
  int remote_port;  
  int conn_to_port; 
  struct ssl_primary_config ssl_config; 
};






struct digestdata {

  BYTE *input_token;
  size_t input_token_len;
  CtxtHandle *http_context;
  
  char *user;
  char *passwd;

  char *nonce;
  char *cnonce;
  char *realm;
  int algo;
  char *opaque;
  char *qop;
  char *algorithm;
  int nc; 
  BIT(stale); 
  BIT(userhash);

};

typedef enum {
  NTLMSTATE_NONE, NTLMSTATE_TYPE1, NTLMSTATE_TYPE2, NTLMSTATE_TYPE3, NTLMSTATE_LAST } curlntlm;





typedef enum {
  GSS_AUTHNONE, GSS_AUTHRECV, GSS_AUTHSENT, GSS_AUTHDONE, GSS_AUTHSUCC } curlnegotiate;











struct kerberos5data {

  CredHandle *credentials;
  CtxtHandle *context;
  TCHAR *spn;
  SEC_WINNT_AUTH_IDENTITY identity;
  SEC_WINNT_AUTH_IDENTITY *p_identity;
  size_t token_max;
  BYTE *output_token;

  gss_ctx_id_t context;
  gss_name_t spn;

};





struct gsasldata {
  Gsasl *ctx;
  Gsasl_session *client;
};




struct ntlmdata {



  CtxtHandle *sslContext;

  CredHandle *credentials;
  CtxtHandle *context;
  SEC_WINNT_AUTH_IDENTITY identity;
  SEC_WINNT_AUTH_IDENTITY *p_identity;
  size_t token_max;
  BYTE *output_token;
  BYTE *input_token;
  size_t input_token_len;
  TCHAR *spn;

  unsigned int flags;
  unsigned char nonce[8];
  unsigned int target_info_len;
  void *target_info; 


  
  curl_socket_t ntlm_auth_hlpr_socket;
  pid_t ntlm_auth_hlpr_pid;
  char *challenge; 
  char *response;  


};




struct negotiatedata {

  OM_uint32 status;
  gss_ctx_id_t context;
  gss_name_t spn;
  gss_buffer_desc output_token;



  CtxtHandle *sslContext;

  DWORD status;
  CredHandle *credentials;
  CtxtHandle *context;
  SEC_WINNT_AUTH_IDENTITY identity;
  SEC_WINNT_AUTH_IDENTITY *p_identity;
  TCHAR *spn;
  size_t token_max;
  BYTE *output_token;
  size_t output_token_length;


  BIT(noauthpersist);
  BIT(havenoauthpersist);
  BIT(havenegdata);
  BIT(havemultiplerequests);
};




struct ConnectBits {
  bool tcpconnect[2]; 

  bool proxy_ssl_connected[2]; 
  BIT(httpproxy);  
  BIT(socksproxy); 
  BIT(proxy_user_passwd); 
  BIT(tunnel_proxy);  
  BIT(proxy_connect_closed); 

  
  BIT(close); 
  BIT(reuse); 
  BIT(altused); 
  BIT(conn_to_host); 
  BIT(conn_to_port); 
  BIT(proxy); 
  BIT(user_passwd); 
  BIT(ipv6_ip); 
  BIT(ipv6);    
  BIT(do_more); 
  BIT(protoconnstart);
  BIT(retry);         
  BIT(authneg);       
  BIT(rewindaftersend);

  BIT(ftp_use_epsv);  
  BIT(ftp_use_eprt);  
  BIT(ftp_use_data_ssl); 
  BIT(ftp_use_control_ssl); 


  BIT(netrc);         

  BIT(bound); 
  BIT(multiplex); 
  BIT(tcp_fastopen); 
  BIT(tls_enable_npn);  
  BIT(tls_enable_alpn); 
  BIT(connect_only);
  BIT(doh);

  BIT(abstract_unix_socket);

  BIT(tls_upgraded);
  BIT(sock_accepted); 
  BIT(parallel_connect); 
};

struct hostname {
  char *rawalloc; 
  char *encalloc; 
  char *name;     
  const char *dispname; 
};
















struct Curl_async {
  char *hostname;
  struct Curl_dns_entry *dns;
  struct thread_data *tdata;
  void *resolver; 
  int port;
  int status; 
  BIT(done);  
};






enum expect100 {
  EXP100_SEND_DATA,            EXP100_AWAITING_CONTINUE, EXP100_SENDING_REQUEST, EXP100_FAILED };




enum upgrade101 {
  UPGR101_INIT,                UPGR101_REQUESTED, UPGR101_RECEIVED, UPGR101_WORKING };




enum doh_slots {
  
  DOH_PROBE_SLOT_IPADDR_V4 = 0,  DOH_PROBE_SLOT_IPADDR_V6 = 1,          DOH_PROBE_SLOTS };













struct dnsprobe {
  CURL *easy;
  int dnstype;
  unsigned char dohbuffer[512];
  size_t dohlen;
  struct dynbuf serverdoh;
};

struct dohdata {
  struct curl_slist *headers;
  struct dnsprobe probe[DOH_PROBE_SLOTS];
  unsigned int pending; 
  int port;
  const char *host;
};


struct SingleRequest {
  curl_off_t size;        
  curl_off_t maxdownload; 
  curl_off_t bytecount;         
  curl_off_t writebytecount;    

  curl_off_t headerbytecount;   
  curl_off_t deductheadercount; 

  curl_off_t pendingheader;      
  struct curltime start;         
  struct curltime now;           
  enum {
    HEADER_NORMAL,               HEADER_PARTHEADER, HEADER_ALLBAD } badheader;


  int headerline;               
  char *str;                    
  curl_off_t offset;            
  int httpcode;                 
  int keepon;
  struct curltime start100;      
  enum expect100 exp100;        
  enum upgrade101 upgr101;      

  
  struct contenc_writer *writer_stack;
  time_t timeofdoc;
  long bodywrites;
  char *location;   
  char *newurl;     

  
  ssize_t upload_present;

  
  char *upload_fromhere;

  
  union {
    struct FILEPROTO *file;
    struct FTP *ftp;
    struct HTTP *http;
    struct IMAP *imap;
    struct ldapreqinfo *ldap;
    struct MQTT *mqtt;
    struct POP3 *pop3;
    struct RTSP *rtsp;
    struct smb_request *smb;
    struct SMTP *smtp;
    struct SSHPROTO *ssh;
    struct TELNET *telnet;
  } p;

  struct dohdata *doh; 

  BIT(header);       
  BIT(content_range); 
  BIT(upload_done);  
  BIT(ignorebody);   
  BIT(http_bodyless); 
  BIT(chunk); 
  BIT(upload_chunky); 
  BIT(getheader);    
  BIT(forbidchunk);  
};



struct Curl_handler {
  const char *scheme;        

  
  CURLcode (*setup_connection)(struct Curl_easy *data, struct connectdata *conn);

  
  CURLcode (*do_it)(struct Curl_easy *data, bool *done);
  CURLcode (*done)(struct Curl_easy *, CURLcode, bool);

  
  CURLcode (*do_more)(struct Curl_easy *, int *);

  
  CURLcode (*connect_it)(struct Curl_easy *data, bool *done);

  
  CURLcode (*connecting)(struct Curl_easy *data, bool *done);
  CURLcode (*doing)(struct Curl_easy *data, bool *done);

  
  int (*proto_getsock)(struct Curl_easy *data, struct connectdata *conn, curl_socket_t *socks);

  
  int (*doing_getsock)(struct Curl_easy *data, struct connectdata *conn, curl_socket_t *socks);

  
  int (*domore_getsock)(struct Curl_easy *data, struct connectdata *conn, curl_socket_t *socks);

  
  int (*perform_getsock)(struct Curl_easy *data, struct connectdata *conn, curl_socket_t *socks);

  
  CURLcode (*disconnect)(struct Curl_easy *, struct connectdata *, bool dead_connection);

  
  CURLcode (*readwrite)(struct Curl_easy *data, struct connectdata *conn, ssize_t *nread, bool *readmore);

  
  unsigned int (*connection_check)(struct Curl_easy *data, struct connectdata *conn, unsigned int checks_to_perform);


  
  void (*attach)(struct Curl_easy *data, struct connectdata *conn);

  int defport;            
  unsigned int protocol;  
  unsigned int family;    
  unsigned int flags;     

};


























struct postponed_data {
  char *buffer;          
  size_t allocated_size; 
  size_t recv_size;      
  size_t recv_processed; 

  curl_socket_t bindsock;

};


struct proxy_info {
  struct hostname host;
  long port;
  curl_proxytype proxytype; 
  char *user;    
  char *passwd;  
};

struct ldapconninfo;
struct http_connect_state;


enum connect_t {
  CONNECT_INIT, CONNECT_SOCKS_INIT, CONNECT_SOCKS_SEND, CONNECT_SOCKS_READ_INIT, CONNECT_SOCKS_READ, CONNECT_GSSAPI_INIT, CONNECT_AUTH_INIT, CONNECT_AUTH_SEND, CONNECT_AUTH_READ, CONNECT_REQ_INIT, CONNECT_RESOLVING, CONNECT_RESOLVED, CONNECT_RESOLVE_REMOTE, CONNECT_REQ_SEND, CONNECT_REQ_SENDING, CONNECT_REQ_READ, CONNECT_REQ_READ_MORE, CONNECT_DONE };




















struct connstate {
  enum connect_t state;
  ssize_t outstanding;  
  unsigned char *outp; 
};


struct connectdata {
  struct connstate cnnct;
  struct Curl_llist_element bundle_node; 

  
  struct Curl_chunker chunk;

  curl_closesocket_callback fclosesocket; 
  void *closesocket_client;

  


  
  long connection_id; 

  
  struct Curl_dns_entry *dns_entry;

  
  struct Curl_addrinfo *ip_addr;
  struct Curl_addrinfo *tempaddr[2]; 

  unsigned int scope_id;  

  enum {
    TRNSPRT_TCP = 3, TRNSPRT_UDP = 4, TRNSPRT_QUIC = 5 } transport;




  struct quicsocket hequic[2]; 
  struct quicsocket *quic;


  struct hostname host;
  char *hostname_resolve; 
  char *secondaryhostname; 
  struct hostname conn_to_host; 

  struct proxy_info socks_proxy;
  struct proxy_info http_proxy;

  int port;        
  int remote_port; 
  int conn_to_port; 
  unsigned short secondary_port; 

  

  char primary_ip[MAX_IPADR_LEN];
  unsigned char ip_version; 

  char *user;    
  char *passwd;  
  char *options; 
  char *sasl_authzid;     
  unsigned char httpversion; 
  struct curltime now;     
  struct curltime created; 
  struct curltime lastused; 
  curl_socket_t sock[2]; 
  curl_socket_t tempsock[2]; 
  int tempfamily[2]; 
  Curl_recv *recv[2];
  Curl_send *send[2];


  struct postponed_data postponed[2]; 

  struct ssl_connect_data ssl[2]; 

  struct ssl_connect_data proxy_ssl[2]; 


  void *ssl_extra; 

  struct ssl_primary_config ssl_config;

  struct ssl_primary_config proxy_ssl_config;

  struct ConnectBits bits;    

  
  int num_addr; 
 
  struct curltime connecttime;

  
  
  timediff_t timeoutms_per_addr[2];

  const struct Curl_handler *handler; 
  const struct Curl_handler *given;   

  
  struct curltime keepalive;

  

  curl_socket_t sockfd;   
  curl_socket_t writesockfd; 


  BIT(sec_complete); 
  enum protection_level command_prot;
  enum protection_level data_prot;
  enum protection_level request_data_prot;
  size_t buffer_size;
  struct krb5buffer in_buffer;
  void *app_data;
  const struct Curl_sec_client_mech *mech;
  struct sockaddr_in local_addr;



  struct kerberos5data krb5;  


  struct Curl_llist easyq;    
  curl_seek_callback seek_func; 
  void *seek_client;            

  

  CtxtHandle *sslContext;



  struct gsasldata gsasl;



  curlntlm http_ntlm_state;
  curlntlm proxy_ntlm_state;

  struct ntlmdata ntlm;     
  struct ntlmdata proxyntlm; 



  curlnegotiate http_negotiate_state;
  curlnegotiate proxy_negotiate_state;

  struct negotiatedata negotiate; 
  struct negotiatedata proxyneg; 


  
  struct dynbuf trailer;

  union {
    struct ftp_conn ftpc;
    struct http_conn httpc;
    struct ssh_conn sshc;
    struct tftp_state_data *tftpc;
    struct imap_conn imapc;
    struct pop3_conn pop3c;
    struct smtp_conn smtpc;
    struct rtsp_conn rtspc;
    struct smb_conn smbc;
    void *rtmp;
    struct ldapconninfo *ldapc;
    struct mqtt_conn mqtt;
  } proto;

  struct http_connect_state *connect_state; 
  struct connectbundle *bundle; 

  char *unix_domain_socket;


  
  Curl_datastream datastream;

  
  char *localdev;
  int localportrange;
  int cselect_bits; 
  int waitfor;      
  int negnpn; 


  int socks5_gssapi_enctype;

  unsigned short localport;
};




struct PureInfo {
  int httpcode;  
  int httpproxycode; 
  int httpversion; 
  time_t filetime; 
  curl_off_t header_size;  
  curl_off_t request_size; 
  unsigned long proxyauthavail; 
  unsigned long httpauthavail;  
  long numconnects; 
  char *contenttype; 
  char *wouldredirect; 
  curl_off_t retry_after; 

  

  char conn_primary_ip[MAX_IPADR_LEN];
  int conn_primary_port;
  char conn_local_ip[MAX_IPADR_LEN];
  int conn_local_port;
  const char *conn_scheme;
  unsigned int conn_protocol;
  struct curl_certinfo certs; 
  CURLproxycode pxcode;
  BIT(timecond);  
};


struct Progress {
  time_t lastshow; 
  curl_off_t size_dl; 
  curl_off_t size_ul; 
  curl_off_t downloaded; 
  curl_off_t uploaded; 

  curl_off_t current_speed; 

  int width; 
  int flags; 

  timediff_t timespent;

  curl_off_t dlspeed;
  curl_off_t ulspeed;

  timediff_t t_nslookup;
  timediff_t t_connect;
  timediff_t t_appconnect;
  timediff_t t_pretransfer;
  timediff_t t_starttransfer;
  timediff_t t_redirect;

  struct curltime start;
  struct curltime t_startsingle;
  struct curltime t_startop;
  struct curltime t_acceptdata;


  
  struct curltime ul_limit_start;
  curl_off_t ul_limit_size;
  
  struct curltime dl_limit_start;
  curl_off_t dl_limit_size;



  curl_off_t speeder[ CURR_TIME ];
  struct curltime speeder_time[ CURR_TIME ];
  int speeder_c;
  BIT(callback);  
  BIT(is_t_startransfer_set);
};

typedef enum {
    RTSPREQ_NONE,  RTSPREQ_OPTIONS, RTSPREQ_DESCRIBE, RTSPREQ_ANNOUNCE, RTSPREQ_SETUP, RTSPREQ_PLAY, RTSPREQ_PAUSE, RTSPREQ_TEARDOWN, RTSPREQ_GET_PARAMETER, RTSPREQ_SET_PARAMETER, RTSPREQ_RECORD, RTSPREQ_RECEIVE, RTSPREQ_LAST } Curl_RtspReq;













struct auth {
  unsigned long want;  
  unsigned long picked;
  unsigned long avail; 
  BIT(done);  
  BIT(multipass); 
  BIT(iestyle); 
};

struct Curl_http2_dep {
  struct Curl_http2_dep *next;
  struct Curl_easy *data;
};


struct tempbuf {
  struct dynbuf b;
  int type;   
};


typedef enum {
  EXPIRE_100_TIMEOUT, EXPIRE_ASYNC_NAME, EXPIRE_CONNECTTIMEOUT, EXPIRE_DNS_PER_NAME, EXPIRE_DNS_PER_NAME2, EXPIRE_HAPPY_EYEBALLS_DNS, EXPIRE_HAPPY_EYEBALLS, EXPIRE_MULTI_PENDING, EXPIRE_RUN_NOW, EXPIRE_SPEEDCHECK, EXPIRE_TIMEOUT, EXPIRE_TOOFAST, EXPIRE_QUIC, EXPIRE_LAST } expire_id;















typedef enum {
  TRAILERS_NONE, TRAILERS_INITIALIZED, TRAILERS_SENDING, TRAILERS_DONE } trailers_state;






struct time_node {
  struct Curl_llist_element list;
  struct curltime time;
  expire_id eid;
};


struct urlpieces {
  char *scheme;
  char *hostname;
  char *port;
  char *user;
  char *password;
  char *options;
  char *path;
  char *query;
};

struct UrlState {
  
  struct conncache *conn_cache;
  
  struct curltime keeps_speed; 

  long lastconnect_id; 
  struct dynbuf headerb; 

  char *buffer; 
  char *ulbuf; 
  curl_off_t current_speed;  
  char *first_host; 
  int retrycount; 
  int first_remote_port; 
  struct Curl_ssl_session *session; 
  long sessionage;                  
  struct tempbuf tempwrite[3]; 
  unsigned int tempcount; 
  int os_errno;  
  char *scratch; 
  long followlocation; 

  
  void (*prev_signal)(int sig);

  struct digestdata digest;      
  struct digestdata proxydigest; 

  struct auth authhost;  
  struct auth authproxy; 

  struct Curl_async async;  



  
  void *engine;

  struct curltime expiretime; 
  struct Curl_tree timenode; 
  struct Curl_llist timeoutlist; 
  struct time_node expires[EXPIRE_LAST]; 

  
  char *most_recent_ftp_entrypath;
  unsigned char httpwant; 
  unsigned char httpversion; 




  
  BIT(prev_block_had_trailing_cr);
  
  curl_off_t crlf_conversions;

  char *range; 
  curl_off_t resume_from; 

  
  long rtsp_next_client_CSeq; 
  long rtsp_next_server_CSeq; 
  long rtsp_CSeq_recv; 

  curl_off_t infilesize; 

  size_t drain; 

  curl_read_callback fread_func; 
  void *in;                      

  struct Curl_easy *stream_depends_on;
  int stream_weight;
  CURLU *uh; 
  struct urlpieces up;
  Curl_HttpReq httpreq; 
  char *url;        
  char *referer;    
  struct curl_slist *cookielist; 
  struct curl_slist *resolve; 

  size_t trailers_bytes_sent;
  struct dynbuf trailers_buf; 

  trailers_state trailers_state; 

  bool hconnect;  
  CURLcode hresult; 


  
  struct dynamically_allocated_data {
    char *proxyuserpwd;
    char *uagent;
    char *accept_encoding;
    char *userpwd;
    char *rangeline;
    char *ref;
    char *host;
    char *cookiehost;
    char *rtsp_transport;
    char *te; 

    
    char *user;
    char *passwd;
    char *proxyuser;
    char *proxypasswd;
  } aptr;


  BIT(conncache_lock);

  
  BIT(multi_owned_by_easy);

  BIT(this_is_a_follow); 
  BIT(refused_stream); 
  BIT(errorbuf); 
  BIT(allow_port); 
  BIT(authproblem); 
  
  BIT(ftp_trying_alternative);
  BIT(wildcardmatch); 
  BIT(expect100header);  
  BIT(disableexpect);    
  BIT(use_range);
  BIT(rangestringalloc); 
  BIT(done); 
  BIT(stream_depends_e); 
  BIT(previouslypending); 
  BIT(cookie_engine);
  BIT(prefer_ascii);   
  BIT(list_only);      
  BIT(url_alloc);   
  BIT(referer_alloc); 
  BIT(wildcard_resolve); 
};



struct Curl_multi;    


enum dupstring {
  STRING_CERT,             STRING_CERT_PROXY, STRING_CERT_TYPE, STRING_CERT_TYPE_PROXY, STRING_COOKIE, STRING_COOKIEJAR, STRING_CUSTOMREQUEST, STRING_DEFAULT_PROTOCOL, STRING_DEVICE, STRING_ENCODING, STRING_FTP_ACCOUNT, STRING_FTP_ALTERNATIVE_TO_USER, STRING_FTPPORT, STRING_KEY, STRING_KEY_PROXY, STRING_KEY_PASSWD, STRING_KEY_PASSWD_PROXY, STRING_KEY_TYPE, STRING_KEY_TYPE_PROXY, STRING_KRB_LEVEL, STRING_NETRC_FILE, STRING_PROXY, STRING_PRE_PROXY, STRING_SET_RANGE, STRING_SET_REFERER, STRING_SET_URL, STRING_SSL_CAPATH, STRING_SSL_CAPATH_PROXY, STRING_SSL_CAFILE, STRING_SSL_CAFILE_PROXY, STRING_SSL_PINNEDPUBLICKEY, STRING_SSL_PINNEDPUBLICKEY_PROXY, STRING_SSL_CIPHER_LIST, STRING_SSL_CIPHER_LIST_PROXY, STRING_SSL_CIPHER13_LIST, STRING_SSL_CIPHER13_LIST_PROXY, STRING_SSL_EGDSOCKET, STRING_SSL_RANDOM_FILE, STRING_USERAGENT, STRING_SSL_CRLFILE, STRING_SSL_CRLFILE_PROXY, STRING_SSL_ISSUERCERT, STRING_SSL_ISSUERCERT_PROXY, STRING_SSL_ENGINE, STRING_USERNAME, STRING_PASSWORD, STRING_OPTIONS, STRING_PROXYUSERNAME, STRING_PROXYPASSWORD, STRING_NOPROXY, STRING_RTSP_SESSION_ID, STRING_RTSP_STREAM_URI, STRING_RTSP_TRANSPORT, STRING_SSH_PRIVATE_KEY, STRING_SSH_PUBLIC_KEY, STRING_SSH_HOST_PUBLIC_KEY_MD5, STRING_SSH_KNOWNHOSTS, STRING_PROXY_SERVICE_NAME, STRING_SERVICE_NAME, STRING_MAIL_FROM, STRING_MAIL_AUTH, STRING_TLSAUTH_USERNAME, STRING_TLSAUTH_USERNAME_PROXY, STRING_TLSAUTH_PASSWORD, STRING_TLSAUTH_PASSWORD_PROXY, STRING_BEARER, STRING_UNIX_SOCKET_PATH, STRING_TARGET, STRING_DOH, STRING_ALTSVC, STRING_HSTS, STRING_SASL_AUTHZID, STRING_DNS_SERVERS, STRING_DNS_INTERFACE, STRING_DNS_LOCAL_IP4, STRING_DNS_LOCAL_IP6, STRING_SSL_EC_CURVES,    STRING_LASTZEROTERMINATED,    STRING_COPYPOSTFIELDS,  STRING_AWS_SIGV4,  STRING_LAST };

























































































enum dupblob {
  BLOB_CERT, BLOB_CERT_PROXY, BLOB_KEY, BLOB_KEY_PROXY, BLOB_SSL_ISSUERCERT, BLOB_SSL_ISSUERCERT_PROXY, BLOB_CAINFO, BLOB_CAINFO_PROXY, BLOB_LAST };










typedef int (*multidone_func)(struct Curl_easy *easy, CURLcode result);

struct UserDefined {
  FILE *err;         
  void *debugdata;   
  char *errorbuffer; 
  long proxyport; 
  void *out;         
  void *in_set;      
  void *writeheader; 
  void *rtp_out;     
  long use_port;     
  unsigned long httpauth;  
  unsigned long proxyauth; 
  unsigned long socks5auth;
  long maxredirs;    

  int keep_post;     
  void *postfields;  
  curl_seek_callback seek_func;      
  curl_off_t postfieldsize; 
  unsigned short localport; 
  int localportrange; 
  curl_write_callback fwrite_func;   
  curl_write_callback fwrite_header; 
  curl_write_callback fwrite_rtp;    
  curl_read_callback fread_func_set; 
  curl_progress_callback fprogress; 
  curl_xferinfo_callback fxferinfo; 
  curl_debug_callback fdebug;      
  curl_ioctl_callback ioctl_func;  
  curl_sockopt_callback fsockopt;  
  void *sockopt_client; 
  curl_opensocket_callback fopensocket; 
  void *opensocket_client;
  curl_closesocket_callback fclosesocket; 
  void *closesocket_client;

  void *seek_client;    
  
  
  curl_conv_callback convfromnetwork;
  
  curl_conv_callback convtonetwork;
  
  curl_conv_callback convfromutf8;

  curl_hstsread_callback hsts_read;
  void *hsts_read_userp;
  curl_hstswrite_callback hsts_write;
  void *hsts_write_userp;

  void *progress_client; 
  void *ioctl_client;   
  long timeout;         
  long connecttimeout;  
  long accepttimeout;   
  long happy_eyeballs_timeout; 
  long server_response_timeout; 
  long maxage_conn;     
  long tftp_blksize;    
  curl_off_t filesize;  
  long low_speed_limit; 
  long low_speed_time;  
  curl_off_t max_send_speed; 
  curl_off_t max_recv_speed; 
  curl_off_t set_resume_from;  
  struct curl_slist *headers; 
  struct curl_slist *proxyheaders; 
  struct curl_httppost *httppost;  
  curl_mimepart mimepost;  
  struct curl_slist *quote;     
  struct curl_slist *postquote; 
  struct curl_slist *prequote; 
  struct curl_slist *source_quote;  
  struct curl_slist *source_prequote;  
  struct curl_slist *source_postquote; 
  struct curl_slist *telnet_options; 
  struct curl_slist *resolve;     
  struct curl_slist *connect_to; 
  curl_TimeCond timecondition; 
  curl_proxytype proxytype; 
  time_t timevalue;       
  Curl_HttpReq method;   
  unsigned char httpwant; 
  struct ssl_config_data ssl;  

  struct ssl_config_data proxy_ssl;  

  struct ssl_general_config general_ssl; 
  long dns_cache_timeout; 
  long buffer_size;      
  unsigned int upload_buffer_size; 
  void *private_data; 
  struct curl_slist *http200aliases; 
  unsigned char ipver; 
  curl_off_t max_filesize; 

  curl_ftpfile ftp_filemethod; 
  curl_ftpauth ftpsslauth; 
  curl_ftpccc ftp_ccc;   

  int ftp_create_missing_dirs; 
  curl_sshkeycallback ssh_keyfunc; 
  void *ssh_keyfunc_userp;         

  enum CURL_NETRC_OPTION use_netrc;

  curl_usessl use_ssl;   
  long new_file_perms;    
  long new_directory_perms; 
  long ssh_auth_types;   
  char *str[STRING_LAST]; 
  struct curl_blob *blobs[BLOB_LAST];
  unsigned int scope_id;  
  long allowed_protocols;
  long redir_protocols;
  struct curl_slist *mail_rcpt; 
  
  Curl_RtspReq rtspreq; 
  long rtspversion; 
  curl_chunk_bgn_callback chunk_bgn; 
  curl_chunk_end_callback chunk_end; 
  curl_fnmatch_callback fnmatch; 
  void *fnmatch_data;

  long gssapi_delegation; 

  long tcp_keepidle;     
  long tcp_keepintvl;    

  size_t maxconnects;    

  long expect_100_timeout; 
  struct Curl_easy *stream_depends_on;
  int stream_weight;
  struct Curl_http2_dep *stream_dependents;

  curl_resolver_start_callback resolver_start; 
  void *resolver_start_client; 
  long upkeep_interval_ms;      
  multidone_func fmultidone;
  struct Curl_easy *dohfor; 
  CURLU *uh; 
  void *trailer_data; 
  curl_trailer_callback trailer_callback; 
  BIT(is_fread_set); 
  BIT(is_fwrite_set); 
  BIT(free_referer); 
  BIT(tftp_no_options); 
  BIT(sep_headers);     
  BIT(cookiesession);   
  BIT(crlf);            
  BIT(strip_path_slash); 
  BIT(ssh_compression);            


  BIT(get_filetime);     
  BIT(tunnel_thru_httpproxy); 
  BIT(prefer_ascii);     
  BIT(remote_append);    
  BIT(list_only);        

  BIT(ftp_use_port);     
  BIT(ftp_use_epsv);     
  BIT(ftp_use_eprt);     
  BIT(ftp_use_pret);     
  BIT(ftp_skip_ip);      

  BIT(hide_progress);    
  BIT(http_fail_on_error);  
  BIT(http_keep_sending_on_error); 
  BIT(http_follow_location); 
  BIT(http_transfer_encoding); 
  BIT(allow_auth_to_other_hosts);
  BIT(include_header); 
  BIT(http_set_referer); 
  BIT(http_auto_referer); 
  BIT(opt_no_body);    
  BIT(upload);         
  BIT(verbose);        
  BIT(krb);            
  BIT(reuse_forbid);   
  BIT(reuse_fresh);    
  BIT(no_signal);      
  BIT(tcp_nodelay);    
  BIT(ignorecl);       
  BIT(connect_only);   
  BIT(http_te_skip);   
  BIT(http_ce_skip);   
  BIT(proxy_transfer_mode); 

  BIT(socks5_gssapi_nec); 

  BIT(sasl_ir);         
  BIT(wildcard_enabled); 
  BIT(tcp_keepalive);  
  BIT(tcp_fastopen);   
  BIT(ssl_enable_npn); 
  BIT(ssl_enable_alpn);
  BIT(path_as_is);     
  BIT(pipewait);       
  BIT(suppress_connect_headers); 
  BIT(dns_shuffle_addresses); 
  BIT(stream_depends_e); 
  BIT(haproxyprotocol); 
  BIT(abstract_unix_socket);
  BIT(disallow_username_in_url); 
  BIT(doh); 
  BIT(doh_get); 
  BIT(doh_verifypeer);     
  BIT(doh_verifyhost);     
  BIT(doh_verifystatus);   
  BIT(http09_allowed); 
  BIT(mail_rcpt_allowfails); 
};

struct Names {
  struct Curl_hash *hostcache;
  enum {
    HCACHE_NONE,     HCACHE_MULTI, HCACHE_SHARED } hostcachetype;


};



struct Curl_easy {
  
  unsigned int magic;

  
  struct Curl_easy *next;
  struct Curl_easy *prev;

  struct connectdata *conn;
  struct Curl_llist_element connect_queue;
  struct Curl_llist_element conn_queue; 

  CURLMstate mstate;  
  CURLcode result;   

  struct Curl_message msg; 

  
  curl_socket_t sockets[MAX_SOCKSPEREASYHANDLE];
  unsigned char actions[MAX_SOCKSPEREASYHANDLE]; 
  int numsocks;

  struct Names dns;
  struct Curl_multi *multi;    
  struct Curl_multi *multi_easy; 
  struct Curl_share *share;    

  struct PslCache *psl;        

  struct SingleRequest req;    
  struct UserDefined set;      
  struct CookieInfo *cookies;  

  struct hsts *hsts;


  struct altsvcinfo *asi;      

  struct Progress progress;    
  struct UrlState state;       

  struct WildcardData wildcard; 

  struct PureInfo info;        
  struct curl_tlssessioninfo tsi; 

  iconv_t outbound_cd;         
  iconv_t inbound_cd;          
  iconv_t utf8_cd;             


  struct hyptransfer hyp;

};




