



















































TAILQ_HEAD(stream_frames_tailq, stream_frame);


struct nocopy_data_in {
    struct stream_frames_tailq  ncdi_frames_in;
    struct data_in              ncdi_data_in;
    struct lsquic_conn_public  *ncdi_conn_pub;
    uint64_t                    ncdi_byteage;
    uint64_t                    ncdi_fin_off;
    lsquic_stream_id_t          ncdi_stream_id;
    unsigned                    ncdi_n_frames;
    unsigned                    ncdi_n_holes;
    unsigned                    ncdi_cons_far;
    enum {
        NCDI_FIN_SET        = 1 << 0, NCDI_FIN_REACHED    = 1 << 1, }                           ncdi_flags;

};







static const struct data_in_iface *di_if_nocopy_ptr;


struct data_in * lsquic_data_in_nocopy_new (struct lsquic_conn_public *conn_pub, lsquic_stream_id_t stream_id)

{
    struct nocopy_data_in *ncdi;

    ncdi = malloc(sizeof(*ncdi));
    if (!ncdi)
        return NULL;

    TAILQ_INIT(&ncdi->ncdi_frames_in);
    ncdi->ncdi_data_in.di_if    = di_if_nocopy_ptr;
    ncdi->ncdi_data_in.di_flags = 0;
    ncdi->ncdi_conn_pub         = conn_pub;
    ncdi->ncdi_stream_id        = stream_id;
    ncdi->ncdi_byteage          = 0;
    ncdi->ncdi_n_frames         = 0;
    ncdi->ncdi_n_holes          = 0;
    ncdi->ncdi_cons_far         = 0;
    ncdi->ncdi_fin_off          = 0;
    ncdi->ncdi_flags            = 0;
    LSQ_DEBUG("initialized");
    return &ncdi->ncdi_data_in;
}


static void nocopy_di_destroy (struct data_in *data_in)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    stream_frame_t *frame;
    while ((frame = TAILQ_FIRST(&ncdi->ncdi_frames_in)))
    {
        TAILQ_REMOVE(&ncdi->ncdi_frames_in, frame, next_frame);
        lsquic_packet_in_put(ncdi->ncdi_conn_pub->mm, frame->packet_in);
        lsquic_malo_put(frame);
    }
    free(ncdi);
}



static int frame_list_is_sane (const struct nocopy_data_in *ncdi)
{
    const stream_frame_t *frame;
    uint64_t prev_off = 0, prev_end = 0;
    int ordered = 1, overlaps = 0;
    TAILQ_FOREACH(frame, &ncdi->ncdi_frames_in, next_frame)
    {
        ordered &= prev_off <= DF_OFF(frame);
        overlaps |= prev_end > DF_OFF(frame);
        prev_off = DF_OFF(frame);
        prev_end = DF_END(frame);
    }
    return ordered && !overlaps;
}









static int insert_frame (struct nocopy_data_in *ncdi, struct stream_frame *new_frame, uint64_t read_offset, unsigned *p_n_frames)

{
    stream_frame_t *prev_frame, *next_frame;
    unsigned count;

    if (read_offset > DF_END(new_frame))
    {
        if (DF_FIN(new_frame))
            return INS_FRAME_ERR                                | CASE('A');
        else return INS_FRAME_DUP                                | CASE('B');
    }

    if (ncdi->ncdi_flags & NCDI_FIN_SET)
    {
        if (DF_FIN(new_frame) && DF_END(new_frame) != ncdi->ncdi_fin_off)
            return INS_FRAME_ERR                                | CASE('C');
        if (DF_END(new_frame) > ncdi->ncdi_fin_off)
            return INS_FRAME_ERR                                | CASE('D');
        if (read_offset == DF_END(new_frame))
            return INS_FRAME_DUP                                | CASE('M');
    }
    else {
        if (read_offset == DF_END(new_frame) && !DF_FIN(new_frame))
            return INS_FRAME_DUP                                | CASE('L');
    }

    
    next_frame = TAILQ_LAST(&ncdi->ncdi_frames_in, stream_frames_tailq);
    if (next_frame && DF_OFF(new_frame) < DF_OFF(next_frame))
    {
        count = 1;
        prev_frame = TAILQ_PREV(next_frame, stream_frames_tailq, next_frame);
        for ( ; prev_frame && DF_OFF(new_frame) < DF_OFF(next_frame);
                next_frame = prev_frame, prev_frame = TAILQ_PREV(prev_frame, stream_frames_tailq, next_frame))
        {
            if (DF_OFF(new_frame) >= DF_OFF(prev_frame))
                break;
            ++count;
        }
    }
    else {
        count = 0;
        prev_frame = NULL;
    }

    if (!prev_frame && next_frame && DF_OFF(new_frame) >= DF_OFF(next_frame))
    {
        prev_frame = next_frame;
        next_frame = TAILQ_NEXT(next_frame, next_frame);
    }

    const int select = !!prev_frame << 1 | !!next_frame;
    switch (select)
    {
    default:    
        if (read_offset == DF_END(new_frame))
        {
            if (DF_SIZE(new_frame))
            {
                if (DF_FIN(new_frame)
                    && !((ncdi->ncdi_flags & NCDI_FIN_REACHED)
                            && read_offset == ncdi->ncdi_fin_off))
                    return INS_FRAME_OVERLAP                    | CASE('E');
                else return INS_FRAME_DUP                        | CASE('F');
            }
            else if (!DF_FIN(new_frame)
                     || ((ncdi->ncdi_flags & NCDI_FIN_REACHED)
                         && read_offset == ncdi->ncdi_fin_off))
                return INS_FRAME_DUP                            | CASE('G');
        }
        else if (read_offset > DF_OFF(new_frame))
            return INS_FRAME_OVERLAP                            | CASE('N');
        goto list_was_empty;
    case 3:     
    case 2:     
        if (DF_OFF(prev_frame) == DF_OFF(new_frame)
            && DF_SIZE(prev_frame) == DF_SIZE(new_frame))
        {
            if (!DF_FIN(prev_frame) && DF_FIN(new_frame))
                return INS_FRAME_OVERLAP                        | CASE('H');
            else return INS_FRAME_DUP                            | CASE('I');
        }
        if (DF_END(prev_frame) > DF_OFF(new_frame))
            return INS_FRAME_OVERLAP                            | CASE('J');
        if (select == 2)
            goto have_prev;
        
    case 1:     
        if (DF_END(new_frame) > DF_OFF(next_frame))
            return INS_FRAME_OVERLAP                            | CASE('K');
        else if (read_offset > DF_OFF(new_frame))
            return INS_FRAME_OVERLAP                            | CASE('O');
        break;
    }

    if (prev_frame)
    {
  have_prev:
        TAILQ_INSERT_AFTER(&ncdi->ncdi_frames_in, prev_frame, new_frame, next_frame);
        ncdi->ncdi_n_holes += DF_END(prev_frame) != DF_OFF(new_frame);
        if (next_frame)
        {
            ncdi->ncdi_n_holes += DF_END(new_frame) != DF_OFF(next_frame);
            --ncdi->ncdi_n_holes;
        }
    }
    else {
        ncdi->ncdi_n_holes += next_frame && DF_END(new_frame) != DF_OFF(next_frame);
  list_was_empty:
        TAILQ_INSERT_HEAD(&ncdi->ncdi_frames_in, new_frame, next_frame);
    }
    CHECK_ORDER(ncdi);

    if (DF_FIN(new_frame))
    {
        ncdi->ncdi_flags |= NCDI_FIN_SET;
        ncdi->ncdi_fin_off = DF_END(new_frame);
        LSQ_DEBUG("FIN set at %"PRIu64, DF_END(new_frame));
    }

    ++ncdi->ncdi_n_frames;
    ncdi->ncdi_byteage += DF_SIZE(new_frame);
    *p_n_frames = count;

    return INS_FRAME_OK                                         | CASE('Z');
}


static int check_efficiency (struct nocopy_data_in *ncdi, unsigned count)
{
    if (ncdi->ncdi_n_frames <= EFF_CHECK_THRESH_LOW)
    {
        ncdi->ncdi_cons_far = 0;
        return 0;
    }
    if (ncdi->ncdi_n_frames > EFF_CHECK_THRESH_HIGH)
        return 1;
    if (count >= ncdi->ncdi_n_frames / 2)
    {
        ++ncdi->ncdi_cons_far;
        if (ncdi->ncdi_cons_far > EFF_FAR_TRAVERSE_COUNT)
            return 1;
    }
    else ncdi->ncdi_cons_far = 0;
    if (ncdi->ncdi_n_holes > EFF_MAX_HOLES)
        return 1;
    if (ncdi->ncdi_byteage / EFF_TINY_FRAME_SZ < ncdi->ncdi_n_frames)
        return 1;
    return 0;
}


static void set_eff_alert (struct nocopy_data_in *ncdi)
{
    LSQ_DEBUG("low efficiency: n_frames: %u; n_holes: %u; cons_far: %u; " "byteage: %"PRIu64, ncdi->ncdi_n_frames, ncdi->ncdi_n_holes, ncdi->ncdi_cons_far, ncdi->ncdi_byteage);

    ncdi->ncdi_data_in.di_flags |= DI_SWITCH_IMPL;
}


static enum ins_frame nocopy_di_insert_frame (struct data_in *data_in, struct stream_frame *new_frame, uint64_t read_offset)

{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    unsigned count;
    enum ins_frame ins;
    int ins_case;

    assert(0 == (new_frame->data_frame.df_fin & ~1));
    ins_case = insert_frame(ncdi, new_frame, read_offset, &count);
    ins = ins_case & 0xFF;
    ins_case >>= 8;
    LSQ_DEBUG("%s: ins: %d (case '%c')", __func__, ins, (char) ins_case);
    switch (ins)
    {
    case INS_FRAME_OK:
        if (check_efficiency(ncdi, count))
            set_eff_alert(ncdi);
        break;
    case INS_FRAME_DUP:
    case INS_FRAME_ERR:
        lsquic_packet_in_put(ncdi->ncdi_conn_pub->mm, new_frame->packet_in);
        lsquic_malo_put(new_frame);
        break;
    default:
        break;
    }

    return ins;
}


static struct data_frame * nocopy_di_get_frame (struct data_in *data_in, uint64_t read_offset)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    struct stream_frame *frame = TAILQ_FIRST(&ncdi->ncdi_frames_in);
    if (frame && frame->data_frame.df_offset + frame->data_frame.df_read_off == read_offset)
    {
        LSQ_DEBUG("get_frame: frame (off: %"PRIu64", size: %u, fin: %d), at " "read offset %"PRIu64, DF_OFF(frame), DF_SIZE(frame), DF_FIN(frame), read_offset);

        return &frame->data_frame;
    }
    else {
        LSQ_DEBUG("get_frame: no frame at read offset %"PRIu64, read_offset);
        return NULL;
    }
}


static void nocopy_di_frame_done (struct data_in *data_in, struct data_frame *data_frame)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    struct stream_frame *const frame = STREAM_FRAME_PTR(data_frame), *first;
    assert(data_frame->df_read_off == data_frame->df_size);
    TAILQ_REMOVE(&ncdi->ncdi_frames_in, frame, next_frame);
    first = TAILQ_FIRST(&ncdi->ncdi_frames_in);
    ncdi->ncdi_n_holes -= first && frame->data_frame.df_offset + frame->data_frame.df_size != first->data_frame.df_offset;
    --ncdi->ncdi_n_frames;
    ncdi->ncdi_byteage -= frame->data_frame.df_size;
    if (DF_FIN(frame))
    {
        ncdi->ncdi_flags |= NCDI_FIN_REACHED;
        LSQ_DEBUG("FIN has been reached at offset %"PRIu64, DF_END(frame));
    }
    LSQ_DEBUG("frame (off: %"PRIu64", size: %u, fin: %d) done", DF_OFF(frame), DF_SIZE(frame), DF_FIN(frame));
    lsquic_packet_in_put(ncdi->ncdi_conn_pub->mm, frame->packet_in);
    lsquic_malo_put(frame);
}


static int nocopy_di_empty (struct data_in *data_in)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    return TAILQ_EMPTY(&ncdi->ncdi_frames_in);
}


static struct data_in * nocopy_di_switch_impl (struct data_in *data_in, uint64_t read_offset)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    struct data_in *new_data_in;
    stream_frame_t *frame;
    enum ins_frame ins;

    new_data_in = lsquic_data_in_hash_new(ncdi->ncdi_conn_pub, ncdi->ncdi_stream_id, ncdi->ncdi_byteage);
    if (!new_data_in)
        goto end;

    while ((frame = TAILQ_FIRST(&ncdi->ncdi_frames_in)))
    {
        TAILQ_REMOVE(&ncdi->ncdi_frames_in, frame, next_frame);
        ins = lsquic_data_in_hash_insert_data_frame(new_data_in, &frame->data_frame, read_offset);
        lsquic_packet_in_put(ncdi->ncdi_conn_pub->mm, frame->packet_in);
        lsquic_malo_put(frame);
        if (INS_FRAME_ERR == ins)
        {
            new_data_in->di_if->di_destroy(new_data_in);
            new_data_in = NULL;
            goto end;
        }
    }

  end:
    data_in->di_if->di_destroy(data_in);
    return new_data_in;
}



static size_t nocopy_di_mem_used (struct data_in *data_in)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    const stream_frame_t *frame;
    size_t size;

    size = sizeof(*data_in);
    TAILQ_FOREACH(frame, &ncdi->ncdi_frames_in, next_frame)
        size += lsquic_packet_in_mem_used(frame->packet_in);

    return size;
}


static void nocopy_di_dump_state (struct data_in *data_in)
{
    struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    const struct stream_frame *frame;

    LSQ_DEBUG("nocopy state: frames: %u; holes: %u; cons_far: %u", ncdi->ncdi_n_frames, ncdi->ncdi_n_holes, ncdi->ncdi_cons_far);
    TAILQ_FOREACH(frame, &ncdi->ncdi_frames_in, next_frame)
        LSQ_DEBUG("frame: off: %"PRIu64"; read_off: %"PRIu16"; size: %"PRIu16 "; fin: %d", DF_OFF(frame), frame->data_frame.df_read_off, DF_SIZE(frame), DF_FIN(frame));

}


static uint64_t nocopy_di_readable_bytes (struct data_in *data_in, uint64_t read_offset)
{
    const struct nocopy_data_in *const ncdi = NCDI_PTR(data_in);
    const struct stream_frame *frame;
    uint64_t starting_offset;

    starting_offset = read_offset;
    TAILQ_FOREACH(frame, &ncdi->ncdi_frames_in, next_frame)
        if (DF_ROFF(frame) == read_offset)
            read_offset += DF_END(frame) - DF_ROFF(frame);
        else if (read_offset > starting_offset)
            break;

    return read_offset - starting_offset;
}


static const struct data_in_iface di_if_nocopy = {
    .di_destroy      = nocopy_di_destroy, .di_dump_state   = nocopy_di_dump_state, .di_empty        = nocopy_di_empty, .di_frame_done   = nocopy_di_frame_done, .di_get_frame    = nocopy_di_get_frame, .di_insert_frame = nocopy_di_insert_frame, .di_mem_used     = nocopy_di_mem_used, .di_own_on_ok    = 1, .di_readable_bytes = nocopy_di_readable_bytes, .di_switch_impl  = nocopy_di_switch_impl, };











static const struct data_in_iface *di_if_nocopy_ptr = &di_if_nocopy;
