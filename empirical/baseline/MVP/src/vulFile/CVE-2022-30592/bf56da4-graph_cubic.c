




















static const struct cong_ctl_if *const cci = &lsquic_cong_cubic_if;



enum event { EV_ACK, EV_LOSS, EV_TIMEOUT, };

static const char *const evstr[] = {
    [EV_ACK]     = "ACK", [EV_LOSS]    = "LOSS", [EV_TIMEOUT] = "TIMEOUT", };



struct rec {
    enum event      event;
    unsigned        cwnd;
};
















int main (int argc, char **argv)
{
    int i, n, opt;
    int n_recs_alloc = 0;
    int app_limited = 0;
    unsigned unit = 100;    
    unsigned rtt_ms = 10;   
    struct lsquic_cubic cubic;
    struct rec *recs = NULL;
    unsigned max_cwnd, width;
    char *line;

    struct winsize winsize;

    enum cubic_flags flags;
    struct lsquic_packet_out packet_out;

    cci->cci_init(&cubic, 0, 0);
    max_cwnd = 0;
    i = 0;
    memset(&packet_out, 0, sizeof(packet_out));

    while (-1 != (opt = getopt(argc, argv, "s:u:r:f:l:A:L:T:")))
    {
        switch (opt)
        {
        case 's':
            cubic.cu_ssthresh = atoi(optarg);
            break;
        case 'r':
            rtt_ms = atoi(optarg);
            break;
        case 'f':
            flags = atoi(optarg);
            lsquic_cubic_set_flags(&cubic, flags);
            break;
        case 'l':
            app_limited = atoi(optarg);
            break;
        case 'A':
            n = i + atoi(optarg);
            for ( ; i < n; ++i)
            {
                packet_out.po_sent = MS(unit * i) - MS(rtt_ms);
                cci->cci_ack(&cubic, &packet_out, 1370, MS(unit * i), app_limited);
                REC(EV_ACK);
            }
            break;
        case 'L':
            n = i + atoi(optarg);
            for ( ; i < n; ++i)
            {
                cci->cci_loss(&cubic);
                REC(EV_LOSS);
            }
            break;
        case 'T':
            n = i + atoi(optarg);
            for ( ; i < n; ++i)
            {
                cci->cci_timeout(&cubic);
                REC(EV_TIMEOUT);
            }
            break;
        case 'u':
            unit = atoi(optarg);
            break;
        default:
            exit(1);
        }
    }


    if (isatty(STDIN_FILENO))
    {
        if (0 == ioctl(STDIN_FILENO, TIOCGWINSZ, &winsize))
            width = winsize.ws_col;
        else {
            perror("ioctl");
            width = 80;
        }
    }
    else  width = 80;


    width -= 5  + 1  + 1  +  1  + 1 ;
    line = malloc(width);
    memset(line, '+', width);

    for (n = i, i = 0; i < n; ++i)
        printf("%c % 5d %.*s\n", *evstr[recs[i].event], recs[i].cwnd, (int) ((float) recs[i].cwnd / max_cwnd * width), line);

    free(recs);
    free(line);

    return 0;
}
