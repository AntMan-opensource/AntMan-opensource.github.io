












static void minmax_subwin_update (struct minmax *minmax, const struct minmax_sample *sample)
{
    uint64_t dt = sample->time - minmax->samples[0].time;

    if (dt > minmax->window)
    {
        
        minmax->samples[0] = minmax->samples[1];
        minmax->samples[1] = minmax->samples[2];
        minmax->samples[2] = *sample;
        if (sample->time - minmax->samples[0].time > minmax->window) {
            minmax->samples[0] = minmax->samples[1];
            minmax->samples[1] = minmax->samples[2];
            minmax->samples[2] = *sample;
        }
    }
    else if (minmax->samples[1].time == minmax->samples[0].time && dt > minmax->window / 4)
    {
        
        minmax->samples[2] = minmax->samples[1] = *sample;
    }
    else if (minmax->samples[2].time == minmax->samples[1].time && dt > minmax->window / 2)
    {
        
        minmax->samples[2] = *sample;
    }
}



void lsquic_minmax_update_max (struct minmax *minmax, uint64_t now, uint64_t meas)
{
    struct minmax_sample sample = { .time = now, .value = meas };

    if (minmax->samples[0].value == 0                                        || sample.value >= minmax->samples[0].value || sample.time - minmax->samples[2].time > minmax->window)

    {
        minmax_reset(minmax, sample);  
        return;
    }

    if (sample.value >= minmax->samples[1].value)
        minmax->samples[2] = minmax->samples[1] = sample;
    else if (sample.value >= minmax->samples[2].value)
        minmax->samples[2] = sample;

    minmax_subwin_update(minmax, &sample);
}



void lsquic_minmax_update_min (struct minmax *minmax, uint64_t now, uint64_t meas)
{
    struct minmax_sample sample = { .time = now, .value = meas };

    if (minmax->samples[0].value == 0                                        || sample.value <= minmax->samples[0].value || sample.time - minmax->samples[2].time > minmax->window)

    {
        minmax_reset(minmax, sample);  
        return;
    }

    if (sample.value <= minmax->samples[1].value)
        minmax->samples[2] = minmax->samples[1] = sample;
    else if (sample.value <= minmax->samples[2].value)
        minmax->samples[2] = sample;

    minmax_subwin_update(minmax, &sample);
}
