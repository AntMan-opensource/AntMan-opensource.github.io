














namespace tensorflow {


class EncodePngOp : public OpKernel {
 public:
  explicit EncodePngOp(OpKernelConstruction* context) : OpKernel(context) {
    OP_REQUIRES_OK(context, context->GetAttr("compression", &compression_));
    OP_REQUIRES(context, -1 <= compression_ && compression_ <= 9, errors::InvalidArgument("compression should be in [-1,9], got ", compression_));


    DataType dt = context->input_type(0);
    OP_REQUIRES(context, dt == DataType::DT_UINT8 || dt == DataType::DT_UINT16, errors::InvalidArgument( "image must have type uint8 or uint16, got ", dt));


    if (dt == DataType::DT_UINT8) {
      desired_channel_bits_ = 8;
    } else {
      desired_channel_bits_ = 16;
    }
  }

  void Compute(OpKernelContext* context) override {
    const Tensor& image = context->input(0);
    OP_REQUIRES(context, image.dims() == 3, errors::InvalidArgument("image must be 3-dimensional", image.shape().DebugString()));

    OP_REQUIRES( context, FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()), errors::InvalidArgument("image cannot have >= int32 max elements"));


    const int32 height = static_cast<int32>(image.dim_size(0));
    const int32 width = static_cast<int32>(image.dim_size(1));
    const int32 channels = static_cast<int32>(image.dim_size(2));

    
    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;

    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width), errors::InvalidArgument("image too wide to encode"));

    OP_REQUIRES(context, channels >= 1 && channels <= 4, errors::InvalidArgument( "image must have 1, 2, 3, or 4 channels, got ", channels));


    
    Tensor* output = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}), &output));
    if (desired_channel_bits_ == 8) {
      OP_REQUIRES(context, png::WriteImageToBuffer( image.flat<uint8>().data(), width, height, width * channels, channels, desired_channel_bits_, compression_, &output->scalar<tstring>()(), nullptr), errors::Internal("PNG encoding failed"));




    } else {
      OP_REQUIRES(context, png::WriteImageToBuffer( image.flat<uint16>().data(), width, height, width * channels * 2, channels, desired_channel_bits_, compression_, &output->scalar<tstring>()(), nullptr), errors::Internal("PNG encoding failed"));




    }
  }

 private:
  int compression_;
  int desired_channel_bits_;
};
REGISTER_KERNEL_BUILDER(Name("EncodePng").Device(DEVICE_CPU), EncodePngOp);

}  
