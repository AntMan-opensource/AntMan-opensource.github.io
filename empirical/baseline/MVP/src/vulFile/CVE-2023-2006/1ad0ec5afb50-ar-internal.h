













struct rxrpc_crypt {
	union {
		u8	x[FCRYPT_BSIZE];
		__be32	n[2];
	};
} __attribute__((aligned(8)));




struct key_preparsed_payload;
struct rxrpc_connection;


enum rxrpc_skb_mark {
	RXRPC_SKB_MARK_REJECT_BUSY,	 RXRPC_SKB_MARK_REJECT_ABORT, };



enum {
	RXRPC_UNBOUND = 0, RXRPC_CLIENT_UNBOUND, RXRPC_CLIENT_BOUND, RXRPC_SERVER_BOUND, RXRPC_SERVER_BOUND2, RXRPC_SERVER_LISTENING, RXRPC_SERVER_LISTEN_DISABLED, RXRPC_CLOSE, };









struct rxrpc_net {
	struct proc_dir_entry	*proc_net;	
	u32			epoch;		
	struct list_head	calls;		
	spinlock_t		call_lock;	
	atomic_t		nr_calls;	

	atomic_t		nr_conns;
	struct list_head	conn_proc_list;	
	struct list_head	service_conns;	
	rwlock_t		conn_lock;	
	struct work_struct	service_conn_reaper;
	struct timer_list	service_conn_reap_timer;

	bool			live;

	bool			kill_all_client_conns;
	atomic_t		nr_client_conns;
	spinlock_t		client_conn_cache_lock; 
	spinlock_t		client_conn_discard_lock; 
	struct list_head	idle_client_conns;
	struct work_struct	client_conn_reaper;
	struct timer_list	client_conn_reap_timer;

	struct hlist_head	local_endpoints;
	struct mutex		local_mutex;	

	DECLARE_HASHTABLE	(peer_hash, 10);
	spinlock_t		peer_hash_lock;	


	u8			peer_keepalive_cursor;
	time64_t		peer_keepalive_base;
	struct list_head	peer_keepalive[32];
	struct list_head	peer_keepalive_new;
	struct timer_list	peer_keepalive_timer;
	struct work_struct	peer_keepalive_work;
};


struct rxrpc_backlog {
	unsigned short		peer_backlog_head;
	unsigned short		peer_backlog_tail;
	unsigned short		conn_backlog_head;
	unsigned short		conn_backlog_tail;
	unsigned short		call_backlog_head;
	unsigned short		call_backlog_tail;

	struct rxrpc_peer	*peer_backlog[RXRPC_BACKLOG_MAX];
	struct rxrpc_connection	*conn_backlog[RXRPC_BACKLOG_MAX];
	struct rxrpc_call	*call_backlog[RXRPC_BACKLOG_MAX];
};


struct rxrpc_sock {
	
	struct sock		sk;
	rxrpc_notify_new_call_t	notify_new_call; 
	rxrpc_discard_new_call_t discard_new_call; 
	struct rxrpc_local	*local;		
	struct rxrpc_backlog	*backlog;	
	spinlock_t		incoming_lock;	
	struct list_head	sock_calls;	
	struct list_head	to_be_accepted;	
	struct list_head	recvmsg_q;	
	rwlock_t		recvmsg_lock;	
	struct key		*key;		
	struct key		*securities;	
	struct rb_root		calls;		
	unsigned long		flags;

	rwlock_t		call_lock;	
	u32			min_sec_level;	

	bool			exclusive;	
	u16			second_service;	
	struct {
		
		u16		from;		
		u16		to;		
	} service_upgrade;
	sa_family_t		family;		
	struct sockaddr_rxrpc	srx;		
	struct sockaddr_rxrpc	connect_srx;	
};




struct rxrpc_host_header {
	u32		epoch;		
	u32		cid;		
	u32		callNumber;	
	u32		seq;		
	u32		serial;		
	u8		type;		
	u8		flags;		
	u8		userStatus;	
	u8		securityIndex;	
	union {
		u16	_rsvd;		
		u16	cksum;		
	};
	u16		serviceId;	
} __packed;


struct rxrpc_skb_priv {
	atomic_t	nr_ring_pins;		
	u8		nr_subpackets;		
	u8		rx_flags;		


	union {
		int		remain;		

		
		unsigned long	rx_req_ack[(RXRPC_MAX_NR_JUMBO + BITS_PER_LONG - 1) / BITS_PER_LONG];
	};

	struct rxrpc_host_header hdr;		
};




struct rxrpc_security {
	const char		*name;		
	u8			security_index;	
	u32			no_key_abort;	

	
	int (*init)(void);

	
	void (*exit)(void);

	
	int (*preparse_server_key)(struct key_preparsed_payload *);

	
	void (*free_preparse_server_key)(struct key_preparsed_payload *);

	
	void (*destroy_server_key)(struct key *);

	
	void (*describe_server_key)(const struct key *, struct seq_file *);

	
	int (*init_connection_security)(struct rxrpc_connection *, struct rxrpc_key_token *);

	
	int (*how_much_data)(struct rxrpc_call *, size_t, size_t *, size_t *, size_t *);

	
	int (*secure_packet)(struct rxrpc_call *, struct sk_buff *, size_t);

	
	int (*verify_packet)(struct rxrpc_call *, struct sk_buff *, unsigned int, unsigned int, rxrpc_seq_t, u16);

	
	void (*free_call_crypto)(struct rxrpc_call *);

	
	void (*locate_data)(struct rxrpc_call *, struct sk_buff *, unsigned int *, unsigned int *);

	
	int (*issue_challenge)(struct rxrpc_connection *);

	
	int (*respond_to_challenge)(struct rxrpc_connection *, struct sk_buff *, u32 *);


	
	int (*verify_response)(struct rxrpc_connection *, struct sk_buff *, u32 *);


	
	void (*clear)(struct rxrpc_connection *);
};


struct rxrpc_local {
	struct rcu_head		rcu;
	atomic_t		active_users;	
	refcount_t		ref;		
	struct rxrpc_net	*rxnet;		
	struct hlist_node	link;
	struct socket		*socket;	
	struct work_struct	processor;
	struct rxrpc_sock __rcu	*service;	
	struct rw_semaphore	defrag_sem;	
	struct sk_buff_head	reject_queue;	
	struct sk_buff_head	event_queue;	
	struct rb_root		client_bundles;	
	spinlock_t		client_bundles_lock; 
	spinlock_t		lock;		
	rwlock_t		services_lock;	
	int			debug_id;	
	bool			dead;
	bool			service_closed;	
	struct sockaddr_rxrpc	srx;		
};


struct rxrpc_peer {
	struct rcu_head		rcu;		
	refcount_t		ref;
	unsigned long		hash_key;
	struct hlist_node	hash_link;
	struct rxrpc_local	*local;
	struct hlist_head	error_targets;	
	struct rb_root		service_conns;	
	struct list_head	keepalive_link;	
	time64_t		last_tx_at;	
	seqlock_t		service_conn_lock;
	spinlock_t		lock;		
	unsigned int		if_mtu;		
	unsigned int		mtu;		
	unsigned int		maxdata;	
	unsigned short		hdrsize;	
	int			debug_id;	
	struct sockaddr_rxrpc	srx;		

	

	spinlock_t		rtt_input_lock;	
	ktime_t			rtt_last_req;	
	unsigned int		rtt_count;	

	u32			srtt_us;	
	u32			mdev_us;	
	u32			mdev_max_us;	
	u32			rttvar_us;	
	u32			rto_j;		
	u8			backoff;	

	u8			cong_cwnd;	
};


struct rxrpc_conn_proto {
	union {
		struct {
			u32	epoch;		
			u32	cid;		
		};
		u64		index_key;
	};
};

struct rxrpc_conn_parameters {
	struct rxrpc_local	*local;		
	struct rxrpc_peer	*peer;		
	struct key		*key;		
	bool			exclusive;	
	bool			upgrade;	
	u16			service_id;	
	u32			security_level;	
};


enum rxrpc_conn_flag {
	RXRPC_CONN_HAS_IDR,		 RXRPC_CONN_IN_SERVICE_CONNS, RXRPC_CONN_DONT_REUSE, RXRPC_CONN_PROBING_FOR_UPGRADE, RXRPC_CONN_FINAL_ACK_0, RXRPC_CONN_FINAL_ACK_1, RXRPC_CONN_FINAL_ACK_2, RXRPC_CONN_FINAL_ACK_3, };













enum rxrpc_conn_event {
	RXRPC_CONN_EV_CHALLENGE,	 };


enum rxrpc_conn_proto_state {
	RXRPC_CONN_UNUSED,		 RXRPC_CONN_CLIENT, RXRPC_CONN_SERVICE_PREALLOC, RXRPC_CONN_SERVICE_UNSECURED, RXRPC_CONN_SERVICE_CHALLENGING, RXRPC_CONN_SERVICE, RXRPC_CONN_REMOTELY_ABORTED, RXRPC_CONN_LOCALLY_ABORTED, RXRPC_CONN__NR_STATES };










struct rxrpc_bundle {
	struct rxrpc_conn_parameters params;
	refcount_t		ref;
	unsigned int		debug_id;
	bool			try_upgrade;	
	bool			alloc_conn;	
	short			alloc_error;	
	spinlock_t		channel_lock;
	struct rb_node		local_node;	
	struct list_head	waiting_calls;	
	unsigned long		avail_chans;	
	struct rxrpc_connection	*conns[4];	
};


struct rxrpc_connection {
	struct rxrpc_conn_proto	proto;
	struct rxrpc_conn_parameters params;

	refcount_t		ref;
	struct rcu_head		rcu;
	struct list_head	cache_link;

	unsigned char		act_chans;	
	struct rxrpc_channel {
		unsigned long		final_ack_at;	
		struct rxrpc_call __rcu	*call;		
		unsigned int		call_debug_id;	
		u32			call_id;	
		u32			call_counter;	
		u32			last_call;	
		u8			last_type;	
		union {
			u32		last_seq;
			u32		last_abort;
		};
	} channels[RXRPC_MAXCALLS];

	struct timer_list	timer;		
	struct work_struct	processor;	
	struct rxrpc_bundle	*bundle;	
	struct rb_node		service_node;	
	struct list_head	proc_link;	
	struct list_head	link;		
	struct sk_buff_head	rx_queue;	

	const struct rxrpc_security *security;	
	union {
		struct {
			struct crypto_sync_skcipher *cipher;	
			struct rxrpc_crypt csum_iv;	
			u32	nonce;		
		} rxkad;
	};
	unsigned long		flags;
	unsigned long		events;
	unsigned long		idle_timestamp;	
	spinlock_t		state_lock;	
	enum rxrpc_conn_proto_state state;	
	u32			abort_code;	
	int			debug_id;	
	atomic_t		serial;		
	unsigned int		hi_serial;	
	u32			service_id;	
	u8			security_ix;	
	u8			out_clientflag;	
	u8			bundle_shift;	
	short			error;		
};

static inline bool rxrpc_to_server(const struct rxrpc_skb_priv *sp)
{
	return sp->hdr.flags & RXRPC_CLIENT_INITIATED;
}

static inline bool rxrpc_to_client(const struct rxrpc_skb_priv *sp)
{
	return !rxrpc_to_server(sp);
}


enum rxrpc_call_flag {
	RXRPC_CALL_RELEASED,		 RXRPC_CALL_HAS_USERID, RXRPC_CALL_IS_SERVICE, RXRPC_CALL_EXPOSED, RXRPC_CALL_RX_LAST, RXRPC_CALL_TX_LAST, RXRPC_CALL_SEND_PING, RXRPC_CALL_RETRANS_TIMEOUT, RXRPC_CALL_BEGAN_RX_TIMER, RXRPC_CALL_RX_HEARD, RXRPC_CALL_RX_UNDERRUN, RXRPC_CALL_DISCONNECTED, RXRPC_CALL_KERNEL, RXRPC_CALL_UPGRADE, };















enum rxrpc_call_event {
	RXRPC_CALL_EV_ACK,		 RXRPC_CALL_EV_ABORT, RXRPC_CALL_EV_RESEND, RXRPC_CALL_EV_PING, RXRPC_CALL_EV_EXPIRED, RXRPC_CALL_EV_ACK_LOST, };







enum rxrpc_call_state {
	RXRPC_CALL_UNINITIALISED, RXRPC_CALL_CLIENT_AWAIT_CONN, RXRPC_CALL_CLIENT_SEND_REQUEST, RXRPC_CALL_CLIENT_AWAIT_REPLY, RXRPC_CALL_CLIENT_RECV_REPLY, RXRPC_CALL_SERVER_PREALLOC, RXRPC_CALL_SERVER_SECURING, RXRPC_CALL_SERVER_RECV_REQUEST, RXRPC_CALL_SERVER_ACK_REQUEST, RXRPC_CALL_SERVER_SEND_REPLY, RXRPC_CALL_SERVER_AWAIT_ACK, RXRPC_CALL_COMPLETE, NR__RXRPC_CALL_STATES };














enum rxrpc_call_completion {
	RXRPC_CALL_SUCCEEDED,		 RXRPC_CALL_REMOTELY_ABORTED, RXRPC_CALL_LOCALLY_ABORTED, RXRPC_CALL_LOCAL_ERROR, RXRPC_CALL_NETWORK_ERROR, NR__RXRPC_CALL_COMPLETIONS };







enum rxrpc_congest_mode {
	RXRPC_CALL_SLOW_START, RXRPC_CALL_CONGEST_AVOIDANCE, RXRPC_CALL_PACKET_LOSS, RXRPC_CALL_FAST_RETRANSMIT, NR__RXRPC_CONGEST_MODES };






struct rxrpc_call {
	struct rcu_head		rcu;
	struct rxrpc_connection	*conn;		
	struct rxrpc_peer	*peer;		
	struct rxrpc_sock __rcu	*socket;	
	struct rxrpc_net	*rxnet;		
	const struct rxrpc_security *security;	
	struct mutex		user_mutex;	
	unsigned long		ack_at;		
	unsigned long		ack_lost_at;	
	unsigned long		resend_at;	
	unsigned long		ping_at;	
	unsigned long		keepalive_at;	
	unsigned long		expect_rx_by;	
	unsigned long		expect_req_by;	
	unsigned long		expect_term_by;	
	u32			next_rx_timo;	
	u32			next_req_timo;	
	struct skcipher_request	*cipher_req;	
	struct timer_list	timer;		
	struct work_struct	processor;	
	rxrpc_notify_rx_t	notify_rx;	
	struct list_head	link;		
	struct list_head	chan_wait_link;	
	struct hlist_node	error_link;	
	struct list_head	accept_link;	
	struct list_head	recvmsg_link;	
	struct list_head	sock_link;	
	struct rb_node		sock_node;	
	struct sk_buff		*tx_pending;	
	wait_queue_head_t	waitq;		
	s64			tx_total_len;	
	__be32			crypto_buf[2];	
	unsigned long		user_call_ID;	
	unsigned long		flags;
	unsigned long		events;
	spinlock_t		lock;
	spinlock_t		notify_lock;	
	rwlock_t		state_lock;	
	u32			abort_code;	
	int			error;		
	enum rxrpc_call_state	state;		
	enum rxrpc_call_completion completion;	
	refcount_t		ref;
	u16			service_id;	
	u8			security_ix;	
	enum rxrpc_interruptibility interruptibility; 
	u32			call_id;	
	u32			cid;		
	int			debug_id;	
	unsigned short		rx_pkt_offset;	
	unsigned short		rx_pkt_len;	
	bool			rx_pkt_last;	

	



	struct sk_buff		**rxtx_buffer;
	u8			*rxtx_annotations;










	rxrpc_seq_t		tx_hard_ack;	
	rxrpc_seq_t		tx_top;		
	u16			tx_backoff;	

	

	u8			cong_cwnd;	
	u8			cong_extra;	
	u8			cong_ssthresh;	
	enum rxrpc_congest_mode	cong_mode:8;	
	u8			cong_dup_acks;	
	u8			cong_cumul_acks; 
	ktime_t			cong_tstamp;	

	rxrpc_seq_t		rx_hard_ack;	
	rxrpc_seq_t		rx_top;		
	rxrpc_seq_t		rx_expect_next;	
	rxrpc_serial_t		rx_serial;	
	u8			rx_winsize;	
	u8			tx_winsize;	
	bool			tx_phase;	
	u8			nr_jumbo_bad;	

	spinlock_t		input_lock;	

	
	u8			ackr_reason;	
	rxrpc_serial_t		ackr_serial;	
	rxrpc_seq_t		ackr_highest_seq; 
	atomic_t		ackr_nr_unacked; 
	atomic_t		ackr_nr_consumed; 

	
	rxrpc_serial_t		rtt_serial[4];	
	ktime_t			rtt_sent_at[4];	
	unsigned long		rtt_avail;	



	
	ktime_t			acks_latest_ts;	
	rxrpc_seq_t		acks_first_seq;	
	rxrpc_seq_t		acks_prev_seq;	
	rxrpc_seq_t		acks_lowest_nak; 
	rxrpc_seq_t		acks_lost_top;	
	rxrpc_serial_t		acks_lost_ping;	
};


struct rxrpc_ack_summary {
	u8			ack_reason;
	u8			nr_acks;		
	u8			nr_nacks;		
	u8			nr_new_acks;		
	u8			nr_new_nacks;		
	u8			nr_rot_new_acks;	
	bool			new_low_nack;		
	bool			retrans_timeo;		
	u8			flight_size;		
	
	enum rxrpc_congest_mode	mode:8;
	u8			cwnd;
	u8			ssthresh;
	u8			dup_acks;
	u8			cumulative_acks;
};


enum rxrpc_command {
	RXRPC_CMD_SEND_DATA,		 RXRPC_CMD_SEND_ABORT, RXRPC_CMD_REJECT_BUSY, RXRPC_CMD_CHARGE_ACCEPT, };




struct rxrpc_call_params {
	s64			tx_total_len;	
	unsigned long		user_call_ID;	
	struct {
		u32		hard;		
		u32		idle;		
		u32		normal;		
	} timeouts;
	u8			nr_timeouts;	
	bool			kernel;		
	enum rxrpc_interruptibility interruptibility; 
};

struct rxrpc_send_params {
	struct rxrpc_call_params call;
	u32			abort_code;	
	enum rxrpc_command	command : 8;	
	bool			exclusive;	
	bool			upgrade;	
};




extern atomic_t rxrpc_n_tx_skbs, rxrpc_n_rx_skbs;
extern struct workqueue_struct *rxrpc_workqueue;


int rxrpc_service_prealloc(struct rxrpc_sock *, gfp_t);
void rxrpc_discard_prealloc(struct rxrpc_sock *);
struct rxrpc_call *rxrpc_new_incoming_call(struct rxrpc_local *, struct rxrpc_sock *, struct sk_buff *);

void rxrpc_accept_incoming_calls(struct rxrpc_local *);
int rxrpc_user_charge_accept(struct rxrpc_sock *, unsigned long);


void rxrpc_propose_ACK(struct rxrpc_call *, u8, u32, bool, bool, enum rxrpc_propose_ack_trace);
void rxrpc_process_call(struct work_struct *);

void rxrpc_reduce_call_timer(struct rxrpc_call *call, unsigned long expire_at, unsigned long now, enum rxrpc_timer_trace why);



void rxrpc_delete_call_timer(struct rxrpc_call *call);


extern const char *const rxrpc_call_states[];
extern const char *const rxrpc_call_completions[];
extern struct kmem_cache *rxrpc_call_jar;

struct rxrpc_call *rxrpc_find_call_by_user_ID(struct rxrpc_sock *, unsigned long);
struct rxrpc_call *rxrpc_alloc_call(struct rxrpc_sock *, gfp_t, unsigned int);
struct rxrpc_call *rxrpc_new_client_call(struct rxrpc_sock *, struct rxrpc_conn_parameters *, struct sockaddr_rxrpc *, struct rxrpc_call_params *, gfp_t, unsigned int);



void rxrpc_incoming_call(struct rxrpc_sock *, struct rxrpc_call *, struct sk_buff *);
void rxrpc_release_call(struct rxrpc_sock *, struct rxrpc_call *);
void rxrpc_release_calls_on_socket(struct rxrpc_sock *);
bool __rxrpc_queue_call(struct rxrpc_call *);
bool rxrpc_queue_call(struct rxrpc_call *);
void rxrpc_see_call(struct rxrpc_call *);
bool rxrpc_try_get_call(struct rxrpc_call *call, enum rxrpc_call_trace op);
void rxrpc_get_call(struct rxrpc_call *, enum rxrpc_call_trace);
void rxrpc_put_call(struct rxrpc_call *, enum rxrpc_call_trace);
void rxrpc_cleanup_call(struct rxrpc_call *);
void rxrpc_destroy_all_calls(struct rxrpc_net *);

static inline bool rxrpc_is_service_call(const struct rxrpc_call *call)
{
	return test_bit(RXRPC_CALL_IS_SERVICE, &call->flags);
}

static inline bool rxrpc_is_client_call(const struct rxrpc_call *call)
{
	return !rxrpc_is_service_call(call);
}


extern unsigned int rxrpc_reap_client_connections;
extern unsigned long rxrpc_conn_idle_client_expiry;
extern unsigned long rxrpc_conn_idle_client_fast_expiry;
extern struct idr rxrpc_client_conn_ids;

void rxrpc_destroy_client_conn_ids(void);
struct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *);
void rxrpc_put_bundle(struct rxrpc_bundle *);
int rxrpc_connect_call(struct rxrpc_sock *, struct rxrpc_call *, struct rxrpc_conn_parameters *, struct sockaddr_rxrpc *, gfp_t);

void rxrpc_expose_client_call(struct rxrpc_call *);
void rxrpc_disconnect_client_call(struct rxrpc_bundle *, struct rxrpc_call *);
void rxrpc_put_client_conn(struct rxrpc_connection *);
void rxrpc_discard_expired_client_conns(struct work_struct *);
void rxrpc_destroy_all_client_connections(struct rxrpc_net *);
void rxrpc_clean_up_local_conns(struct rxrpc_local *);


void rxrpc_process_connection(struct work_struct *);
void rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);


extern unsigned int rxrpc_connection_expiry;
extern unsigned int rxrpc_closed_conn_expiry;

struct rxrpc_connection *rxrpc_alloc_connection(gfp_t);
struct rxrpc_connection *rxrpc_find_connection_rcu(struct rxrpc_local *, struct sk_buff *, struct rxrpc_peer **);

void __rxrpc_disconnect_call(struct rxrpc_connection *, struct rxrpc_call *);
void rxrpc_disconnect_call(struct rxrpc_call *);
void rxrpc_kill_connection(struct rxrpc_connection *);
bool rxrpc_queue_conn(struct rxrpc_connection *);
void rxrpc_see_connection(struct rxrpc_connection *);
struct rxrpc_connection *rxrpc_get_connection(struct rxrpc_connection *);
struct rxrpc_connection *rxrpc_get_connection_maybe(struct rxrpc_connection *);
void rxrpc_put_service_conn(struct rxrpc_connection *);
void rxrpc_service_connection_reaper(struct work_struct *);
void rxrpc_destroy_all_connections(struct rxrpc_net *);

static inline bool rxrpc_conn_is_client(const struct rxrpc_connection *conn)
{
	return conn->out_clientflag;
}

static inline bool rxrpc_conn_is_service(const struct rxrpc_connection *conn)
{
	return !rxrpc_conn_is_client(conn);
}

static inline void rxrpc_put_connection(struct rxrpc_connection *conn)
{
	if (!conn)
		return;

	if (rxrpc_conn_is_client(conn))
		rxrpc_put_client_conn(conn);
	else rxrpc_put_service_conn(conn);
}

static inline void rxrpc_reduce_conn_timer(struct rxrpc_connection *conn, unsigned long expire_at)
{
	timer_reduce(&conn->timer, expire_at);
}


struct rxrpc_connection *rxrpc_find_service_conn_rcu(struct rxrpc_peer *, struct sk_buff *);
struct rxrpc_connection *rxrpc_prealloc_service_connection(struct rxrpc_net *, gfp_t);
void rxrpc_new_incoming_connection(struct rxrpc_sock *, struct rxrpc_connection *, const struct rxrpc_security *, struct sk_buff *);
void rxrpc_unpublish_service_conn(struct rxrpc_connection *);


int rxrpc_input_packet(struct sock *, struct sk_buff *);


extern const struct rxrpc_security rxrpc_no_security;


extern struct key_type key_type_rxrpc;

int rxrpc_request_key(struct rxrpc_sock *, sockptr_t , int);
int rxrpc_get_server_data_key(struct rxrpc_connection *, const void *, time64_t, u32);


extern void rxrpc_process_local_events(struct rxrpc_local *);


struct rxrpc_local *rxrpc_lookup_local(struct net *, const struct sockaddr_rxrpc *);
struct rxrpc_local *rxrpc_get_local(struct rxrpc_local *);
struct rxrpc_local *rxrpc_get_local_maybe(struct rxrpc_local *);
void rxrpc_put_local(struct rxrpc_local *);
struct rxrpc_local *rxrpc_use_local(struct rxrpc_local *);
void rxrpc_unuse_local(struct rxrpc_local *);
void rxrpc_queue_local(struct rxrpc_local *);
void rxrpc_destroy_all_locals(struct rxrpc_net *);

static inline bool __rxrpc_unuse_local(struct rxrpc_local *local)
{
	return atomic_dec_return(&local->active_users) == 0;
}

static inline bool __rxrpc_use_local(struct rxrpc_local *local)
{
	return atomic_fetch_add_unless(&local->active_users, 1, 0) != 0;
}


extern unsigned int rxrpc_max_backlog __read_mostly;
extern unsigned long rxrpc_requested_ack_delay;
extern unsigned long rxrpc_soft_ack_delay;
extern unsigned long rxrpc_idle_ack_delay;
extern unsigned int rxrpc_rx_window_size;
extern unsigned int rxrpc_rx_mtu;
extern unsigned int rxrpc_rx_jumbo_max;

extern const s8 rxrpc_ack_priority[];


extern unsigned int rxrpc_net_id;
extern struct pernet_operations rxrpc_net_ops;

static inline struct rxrpc_net *rxrpc_net(struct net *net)
{
	return net_generic(net, rxrpc_net_id);
}


int rxrpc_send_ack_packet(struct rxrpc_call *, bool, rxrpc_serial_t *);
int rxrpc_send_abort_packet(struct rxrpc_call *);
int rxrpc_send_data_packet(struct rxrpc_call *, struct sk_buff *, bool);
void rxrpc_reject_packets(struct rxrpc_local *);
void rxrpc_send_keepalive(struct rxrpc_peer *);


void rxrpc_encap_err_rcv(struct sock *sk, struct sk_buff *skb, unsigned int udp_offset);
void rxrpc_error_report(struct sock *);
void rxrpc_peer_keepalive_worker(struct work_struct *);


struct rxrpc_peer *rxrpc_lookup_peer_rcu(struct rxrpc_local *, const struct sockaddr_rxrpc *);
struct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_sock *, struct rxrpc_local *, struct sockaddr_rxrpc *, gfp_t);
struct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *, gfp_t);
void rxrpc_new_incoming_peer(struct rxrpc_sock *, struct rxrpc_local *, struct rxrpc_peer *);
void rxrpc_destroy_all_peers(struct rxrpc_net *);
struct rxrpc_peer *rxrpc_get_peer(struct rxrpc_peer *);
struct rxrpc_peer *rxrpc_get_peer_maybe(struct rxrpc_peer *);
void rxrpc_put_peer(struct rxrpc_peer *);
void rxrpc_put_peer_locked(struct rxrpc_peer *);


extern const struct seq_operations rxrpc_call_seq_ops;
extern const struct seq_operations rxrpc_connection_seq_ops;
extern const struct seq_operations rxrpc_peer_seq_ops;
extern const struct seq_operations rxrpc_local_seq_ops;


void rxrpc_notify_socket(struct rxrpc_call *);
bool __rxrpc_set_call_completion(struct rxrpc_call *, enum rxrpc_call_completion, u32, int);
bool rxrpc_set_call_completion(struct rxrpc_call *, enum rxrpc_call_completion, u32, int);
bool __rxrpc_call_completed(struct rxrpc_call *);
bool rxrpc_call_completed(struct rxrpc_call *);
bool __rxrpc_abort_call(const char *, struct rxrpc_call *, rxrpc_seq_t, u32, int);
bool rxrpc_abort_call(const char *, struct rxrpc_call *, rxrpc_seq_t, u32, int);
int rxrpc_recvmsg(struct socket *, struct msghdr *, size_t, int);


static inline bool __rxrpc_abort_eproto(struct rxrpc_call *call, struct sk_buff *skb, const char *eproto_why, const char *why, u32 abort_code)



{
	struct rxrpc_skb_priv *sp = rxrpc_skb(skb);

	trace_rxrpc_rx_eproto(call, sp->hdr.serial, eproto_why);
	return rxrpc_abort_call(why, call, sp->hdr.seq, abort_code, -EPROTO);
}





void rxrpc_peer_add_rtt(struct rxrpc_call *, enum rxrpc_rtt_rx_trace, int, rxrpc_serial_t, rxrpc_serial_t, ktime_t, ktime_t);
unsigned long rxrpc_get_rto_backoff(struct rxrpc_peer *, bool);
void rxrpc_peer_init_rtt(struct rxrpc_peer *);



extern const struct rxrpc_security rxkad;



int __init rxrpc_init_security(void);
const struct rxrpc_security *rxrpc_security_lookup(u8);
void rxrpc_exit_security(void);
int rxrpc_init_client_conn_security(struct rxrpc_connection *);
const struct rxrpc_security *rxrpc_get_incoming_security(struct rxrpc_sock *, struct sk_buff *);
struct key *rxrpc_look_up_server_security(struct rxrpc_connection *, struct sk_buff *, u32, u32);


int rxrpc_do_sendmsg(struct rxrpc_sock *, struct msghdr *, size_t);


extern struct key_type key_type_rxrpc_s;

int rxrpc_server_keyring(struct rxrpc_sock *, sockptr_t, int);


void rxrpc_kernel_data_consumed(struct rxrpc_call *, struct sk_buff *);
void rxrpc_packet_destructor(struct sk_buff *);
void rxrpc_new_skb(struct sk_buff *, enum rxrpc_skb_trace);
void rxrpc_see_skb(struct sk_buff *, enum rxrpc_skb_trace);
void rxrpc_eaten_skb(struct sk_buff *, enum rxrpc_skb_trace);
void rxrpc_get_skb(struct sk_buff *, enum rxrpc_skb_trace);
void rxrpc_free_skb(struct sk_buff *, enum rxrpc_skb_trace);
void rxrpc_purge_queue(struct sk_buff_head *);



extern int __init rxrpc_sysctl_init(void);
extern void rxrpc_sysctl_exit(void);

static inline int __init rxrpc_sysctl_init(void) { return 0; }
static inline void rxrpc_sysctl_exit(void) {}



int rxrpc_extract_addr_from_skb(struct sockaddr_rxrpc *, struct sk_buff *);

static inline bool before(u32 seq1, u32 seq2)
{
        return (s32)(seq1 - seq2) < 0;
}
static inline bool before_eq(u32 seq1, u32 seq2)
{
        return (s32)(seq1 - seq2) <= 0;
}
static inline bool after(u32 seq1, u32 seq2)
{
        return (s32)(seq1 - seq2) > 0;
}
static inline bool after_eq(u32 seq1, u32 seq2)
{
        return (s32)(seq1 - seq2) >= 0;
}


extern unsigned int rxrpc_debug;















































































































