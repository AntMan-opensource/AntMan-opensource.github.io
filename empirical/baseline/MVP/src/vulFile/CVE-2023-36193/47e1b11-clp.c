



























typedef unsigned long uintptr_t;



extern "C" {












typedef struct {
    int val_type;
    Clp_ValParseFunc func;
    int flags;
    void *user_data;
} Clp_ValType;

typedef struct {
    unsigned ilong : 1;
    unsigned ishort : 1;
    unsigned imandatory : 1;
    unsigned ioptional : 1;
    unsigned ipos : 1;
    unsigned ineg : 1;
    unsigned iprefmatch : 1;
    unsigned lmmpos_short : 1;
    unsigned lmmneg_short : 1;
    unsigned char ilongoff;
    int lmmpos;
    int lmmneg;
} Clp_InternOption;




typedef struct {
    int c;
    int type;
} Clp_Oclass;


typedef struct Clp_Internal {
    const Clp_Option *opt;
    Clp_InternOption *iopt;
    int nopt;
    unsigned opt_generation;

    Clp_ValType *valtype;
    int nvaltype;

    const char * const *argv;
    int argc;

    Clp_Oclass oclass[Clp_OclassSize];
    int noclass;
    int long1pos;
    int long1neg;
    int utf8;

    char option_chars[Clp_OptionCharsSize];
    const char *xtext;

    const char *program_name;
    void (*error_handler)(Clp_Parser *, const char *);

    int option_processing;
    int current_option;

    unsigned char is_short;
    unsigned char whole_negated; 
    unsigned char could_be_short;
    unsigned char current_short;
    unsigned char negated_by_no;

    int ambiguous;
    int ambiguous_values[MAX_AMBIGUOUS_VALUES];
} Clp_Internal;


struct Clp_ParserState {
    const char * const *argv;
    int argc;

    char option_chars[Clp_OptionCharsSize];
    const char *xtext;

    int option_processing;

    unsigned opt_generation;
    int current_option;
    unsigned char is_short;
    unsigned char whole_negated;
    unsigned char current_short;
    unsigned char negated_by_no;
};


typedef struct Clp_StringList {
    Clp_Option *items;
    Clp_InternOption *iopt;
    int nitems;

    unsigned char allow_int;
    unsigned char val_long;
    int nitems_invalid_report;
} Clp_StringList;


static const Clp_Option clp_option_sentinel[] = {
    {"", 0, Clp_NotOption, 0, 0}, {"", 0, Clp_Done, 0, 0}, {"", 0, Clp_BadOption, 0, 0}, {"", 0, Clp_Error, 0, 0}


};


static int parse_string(Clp_Parser *, const char *, int, void *);
static int parse_int(Clp_Parser *, const char *, int, void *);
static int parse_bool(Clp_Parser *, const char *, int, void *);
static int parse_double(Clp_Parser *, const char *, int, void *);
static int parse_string_list(Clp_Parser *, const char *, int, void *);

static int ambiguity_error(Clp_Parser *, int, int *, const Clp_Option *, const Clp_InternOption *, const char *, const char *, ...);







static char * encode_utf8(char *s, int n, int c)
{
    if (c < 0 || c >= 0x110000 || (c >= 0xD800 && c <= 0xDFFF))
        c = U_REPLACEMENT;
    if (c <= 0x7F && n >= 1)
        *s++ = c;
    else if (c <= 0x7FF && n >= 2) {
        *s++ = 0xC0 | (c >> 6);
        goto char1;
    } else if (c <= 0xFFFF && n >= 3) {
        *s++ = 0xE0 | (c >> 12);
        goto char2;
    } else if (n >= 4) {
        *s++ = 0xF0 | (c >> 18);
        *s++ = 0x80 | ((c >> 12) & 0x3F);
      char2:
        *s++ = 0x80 | ((c >> 6) & 0x3F);
      char1:
        *s++ = 0x80 | (c & 0x3F);
    }
    return s;
}

static int decode_utf8(const char *s, const char **cp)
{
    int c;
    if ((unsigned char) *s <= 0x7F)             
        c = *s++;
    else if ((unsigned char) *s <= 0xC1)        
        goto replacement;
    else if ((unsigned char) *s <= 0xDF) {      
        if ((s[1] & 0xC0) != 0x80)              
            goto replacement;
        c = (*s++ & 0x1F) << 6;
        goto char1;
    } else if ((unsigned char) *s <= 0xEF) {    
        if ((s[1] & 0xC0) != 0x80                || (s[2] & 0xC0) != 0x80 || ((unsigned char) *s == 0xE0 && (s[1] & 0xE0) == 0x80)


            || ((unsigned char) *s == 0xED       && (s[1] & 0xE0) == 0xA0))
            goto replacement;
        c = (*s++ & 0x0F) << 12;
        goto char2;
    } else if ((unsigned char) *s <= 0xF4) {    
        if ((s[1] & 0xC0) != 0x80                || (s[2] & 0xC0) != 0x80 || (s[3] & 0xC0) != 0x80 || ((unsigned char) *s == 0xF0 && (s[1] & 0xF0) == 0x80)



            || ((unsigned char) *s == 0xF4       && (unsigned char) s[1] >= 0x90))
            goto replacement;
        c = (*s++ & 0x07) << 18;
        c += (*s++ & 0x3F) << 12;
      char2:
        c += (*s++ & 0x3F) << 6;
      char1:
        c += (*s++ & 0x3F);
    } else {
      replacement:
        c = U_REPLACEMENT;
        for (s++; (*s & 0xC0) == 0x80; s++)
            ;
    }
    if (cp)
        *cp = s;
    return c;
}

static int utf8_charlen(const char *s)
{
    const char *sout;
    (void) decode_utf8(s, &sout);
    return sout - s;
}

static int clp_utf8_charlen(const Clp_Internal *cli, const char *s)
{
    return (cli->utf8 ? utf8_charlen(s) : 1);
}




static int min_different_chars(const char *s, const char *t)
     
{
    const char *sfirst = s;
    while (*s && *t && *s == *t)
        s++, t++;
    if (!*s)
        return s - sfirst;
    else return s - sfirst + 1;
}

static int long_as_short(const Clp_Internal *cli, const Clp_Option *o, Clp_InternOption *io, int failure)

{
    if ((cli->long1pos || cli->long1neg) && io->ilong) {
        const char *name = o->long_name + io->ilongoff;
        if (cli->utf8) {
            int c = decode_utf8(name, &name);
            if (!*name && c && c != U_REPLACEMENT)
                return c;
        } else if (name[0] && !name[1])
            return (unsigned char) name[0];
    }
    return failure;
}

static void compare_options(Clp_Parser *clp, const Clp_Option *o1, Clp_InternOption *io1, const Clp_Option *o2, Clp_InternOption *io2)

{
    Clp_Internal *cli = clp->internal;
    int short1, shortx1;

    
    if ((!io1->ishort && !io1->ilong) || (!io2->ishort && !io2->ilong)
        || !((io1->ipos && io2->ipos) || (io1->ineg && io2->ineg))
        || o1->option_id == o2->option_id)
        return;

    
    short1 = (io1->ishort ? o1->short_name : -1);
    shortx1 = long_as_short(cli, o1, io1, -2);
    if (short1 >= 0 || shortx1 >= 0) {
        int short2 = (io2->ishort ? o2->short_name : -3);
        int shortx2 = long_as_short(cli, o2, io2, -4);
        if (short1 == short2)
            Clp_OptionError(clp, "CLP internal error: more than 1 option has short name %<%c%>", short1);
        else if ((short1 == shortx2 || shortx1 == short2 || shortx1 == shortx2)
                 && ((io1->ipos && io2->ipos && cli->long1pos)
                     || (io1->ineg && io2->ineg && cli->long1neg)))
            Clp_OptionError(clp, "CLP internal error: 1-char long name conflicts with short name %<%c%>", (short1 == shortx2 ? shortx2 : shortx1));
    }

    
    if (io1->ilong) {
        const char *name1 = o1->long_name + io1->ilongoff;

        
        if (io2->ishort && !io1->iprefmatch) {
            int name1char = (cli->utf8 ? decode_utf8(name1, 0) : (unsigned char) *name1);
            if (name1char == o2->short_name) {
                if (io1->ipos && io2->ipos)
                    io1->lmmpos_short = 1;
                if (io1->ineg && io2->ineg)
                    io1->lmmneg_short = 1;
            }
        }

        
        if (io2->ilong) {
            const char *name2 = o2->long_name + io2->ilongoff;
            if (strcmp(name1, name2) == 0)
                Clp_OptionError(clp, "CLP internal error: duplicate long name %<%s%>", name1);
            if (io1->ipos && io2->ipos && !strncmp(name1, name2, io1->lmmpos)
                && (!io1->iprefmatch || strncmp(name1, name2, strlen(name1))))
                io1->lmmpos = min_different_chars(name1, name2);
            if (io1->ineg && io2->ineg && !strncmp(name1, name2, io1->lmmneg)
                && (!io1->iprefmatch || strncmp(name1, name2, strlen(name1))))
                io1->lmmneg = min_different_chars(name1, name2);
        }
    }
}

static void calculate_lmm(Clp_Parser *clp, const Clp_Option *opt, Clp_InternOption *iopt, int nopt)
{
    int i, j;
    for (i = 0; i < nopt; ++i) {
        iopt[i].lmmpos = iopt[i].lmmneg = 1;
        iopt[i].lmmpos_short = iopt[i].lmmneg_short = 0;
        for (j = 0; j < nopt; ++j)
            compare_options(clp, &opt[i], &iopt[i], &opt[j], &iopt[j]);
    }
}


Clp_Parser * Clp_NewParser(int argc, const char * const *argv, int nopt, const Clp_Option *opt)
{
    Clp_Parser *clp = (Clp_Parser *)malloc(sizeof(Clp_Parser));
    Clp_Internal *cli = (Clp_Internal *)malloc(sizeof(Clp_Internal));
    Clp_InternOption *iopt = (Clp_InternOption *)malloc(sizeof(Clp_InternOption) * nopt);
    if (cli)
        cli->valtype = (Clp_ValType *)malloc(sizeof(Clp_ValType) * Clp_InitialValType);
    if (!clp || !cli || !iopt || !cli->valtype)
        goto failed;

    clp->option = &clp_option_sentinel[-Clp_Done];
    clp->negated = 0;
    clp->have_val = 0;
    clp->vstr = 0;
    clp->user_data = 0;
    clp->internal = cli;

    cli->opt = opt;
    cli->nopt = nopt;
    cli->iopt = iopt;
    cli->opt_generation = 0;
    cli->error_handler = 0;

    
    if (argc > 0) {
        const char *slash = strrchr(argv[0], '/');
        cli->program_name = slash ? slash + 1 : argv[0];
    } else cli->program_name = 0;

    
    Clp_SetArguments(clp, argc - 1, argv + 1);

    
    {
        char *s = getenv("LANG");
        cli->utf8 = (s && (strstr(s, "UTF-8") != 0 || strstr(s, "UTF8") != 0 || strstr(s, "utf8") != 0));
    }
    cli->oclass[0].c = '-';
    cli->oclass[0].type = Clp_Short;
    cli->noclass = 1;
    cli->long1pos = cli->long1neg = 0;

    
    cli->nvaltype = 0;
    Clp_AddType(clp, Clp_ValString, 0, parse_string, 0);
    Clp_AddType(clp, Clp_ValStringNotOption, Clp_DisallowOptions, parse_string, 0);
    Clp_AddType(clp, Clp_ValInt, 0, parse_int, (void*) (uintptr_t) 0);
    Clp_AddType(clp, Clp_ValUnsigned, 0, parse_int, (void*) (uintptr_t) 1);
    Clp_AddType(clp, Clp_ValLong, 0, parse_int, (void*) (uintptr_t) 2);
    Clp_AddType(clp, Clp_ValUnsignedLong, 0, parse_int, (void*) (uintptr_t) 3);
    Clp_AddType(clp, Clp_ValBool, 0, parse_bool, 0);
    Clp_AddType(clp, Clp_ValDouble, 0, parse_double, 0);

    
    Clp_SetOptions(clp, nopt, opt);

    return clp;

  failed:
    if (cli && cli->valtype)
        free(cli->valtype);
    if (cli)
        free(cli);
    if (clp)
        free(clp);
    if (iopt)
        free(iopt);
    return 0;
}


void Clp_DeleteParser(Clp_Parser *clp)
{
    int i;
    Clp_Internal *cli;
    if (!clp)
        return;

    cli = clp->internal;

    
    for (i = 0; i < cli->nvaltype; i++)
        if (cli->valtype[i].func == parse_string_list) {
            Clp_StringList *clsl = (Clp_StringList *)cli->valtype[i].user_data;
            free(clsl->items);
            free(clsl->iopt);
            free(clsl);
        }

    free(cli->valtype);
    free(cli->iopt);
    free(cli);
    free(clp);
}



Clp_ErrorHandler Clp_SetErrorHandler(Clp_Parser *clp, void (*errh)(Clp_Parser *, const char *))
{
    Clp_Internal *cli = clp->internal;
    Clp_ErrorHandler old = cli->error_handler;
    cli->error_handler = errh;
    return old;
}


int Clp_SetUTF8(Clp_Parser *clp, int utf8)
{
    Clp_Internal *cli = clp->internal;
    int old_utf8 = cli->utf8;
    cli->utf8 = utf8;
    calculate_lmm(clp, cli->opt, cli->iopt, cli->nopt);
    return old_utf8;
}


int Clp_OptionChar(Clp_Parser *clp, int c)
{
    Clp_Internal *cli = clp->internal;
    int i, oclass = 0;
    if (cli->noclass > 0 && cli->oclass[0].c == 0)
        oclass = cli->oclass[0].type;
    for (i = 0; i < cli->noclass; ++i)
        if (cli->oclass[i].c == c)
            oclass = cli->oclass[i].type;
    return oclass;
}


int Clp_SetOptionChar(Clp_Parser *clp, int c, int type)
{
    int i, long1pos, long1neg;
    int old = Clp_OptionChar(clp, c);
    Clp_Internal *cli = clp->internal;

    if (type != Clp_NotOption && type != Clp_Short && type != Clp_Long && type != Clp_ShortNegated && type != Clp_LongNegated && type != Clp_LongImplicit && type != (Clp_Short | Clp_Long)

        && type != (Clp_ShortNegated | Clp_LongNegated))
        return -1;
    if (c < 0 || c >= (cli->utf8 ? 0x110000 : 256))
        return -1;

    if (c == 0)
        cli->noclass = 0;
    for (i = 0; i < cli->noclass; ++i)
        if (cli->oclass[i].c == c)
            break;
    if (i == Clp_OclassSize)
        return -1;

    cli->oclass[i].c = c;
    cli->oclass[i].type = type;
    if (cli->noclass == i)
        cli->noclass = i + 1;

    long1pos = long1neg = 0;
    for (i = 0; i < cli->noclass; ++i) {
        if ((cli->oclass[i].type & Clp_Short)
            && (cli->oclass[i].type & Clp_Long))
            long1pos = 1;
        if ((cli->oclass[i].type & Clp_ShortNegated)
            && (cli->oclass[i].type & Clp_LongNegated))
            long1neg = 1;
    }

    if (long1pos != cli->long1pos || long1neg != cli->long1neg) {
        
        cli->long1pos = long1pos;
        cli->long1neg = long1neg;
        calculate_lmm(clp, cli->opt, cli->iopt, cli->nopt);
    }

    return old;
}


int Clp_SetOptions(Clp_Parser *clp, int nopt, const Clp_Option *opt)
{
    Clp_Internal *cli = clp->internal;
    Clp_InternOption *iopt;
    int i;
    static unsigned opt_generation = 0;

    if (nopt > cli->nopt) {
        iopt = (Clp_InternOption *)malloc(sizeof(Clp_InternOption) * nopt);
        if (!iopt)
            return -1;
        free(cli->iopt);
        cli->iopt = iopt;
    }

    cli->opt = opt;
    cli->nopt = nopt;
    cli->opt_generation = ++opt_generation;
    iopt = cli->iopt;
    cli->current_option = -1;

    
    for (i = 0; i < nopt; ++i) {
        memset(&iopt[i], 0, sizeof(iopt[i]));

        
        if (opt[i].option_id < 0) {
            Clp_OptionError(clp, "CLP internal error: option %d has negative option_id", i);
            iopt[i].ilong = iopt[i].ishort = iopt[i].ipos = iopt[i].ineg = 0;
            continue;
        }

        
        iopt[i].ilong = (opt[i].long_name != 0 && opt[i].long_name[0] != 0);
        iopt[i].ishort = (opt[i].short_name > 0 && opt[i].short_name < (cli->utf8 ? 0x110000 : 256));
        iopt[i].ipos = 1;
        iopt[i].ineg = (opt[i].flags & Clp_Negate) != 0;
        iopt[i].imandatory = (opt[i].flags & Clp_Mandatory) != 0;
        iopt[i].ioptional = (opt[i].flags & Clp_Optional) != 0;
        iopt[i].iprefmatch = (opt[i].flags & Clp_PreferredMatch) != 0;
        iopt[i].ilongoff = 0;

        
        if (opt[i].val_type <= 0)
            iopt[i].imandatory = iopt[i].ioptional = 0;
        if (opt[i].val_type > 0 && !iopt[i].ioptional)
            iopt[i].imandatory = 1;

        
        if (iopt[i].ilong && strncmp(opt[i].long_name, "no-", 3) == 0) {
            iopt[i].ipos = 0;
            iopt[i].ineg = 1;
            iopt[i].ilongoff = 3;
            if (strncmp(opt[i].long_name + 3, "no-", 3) == 0)
                Clp_OptionError(clp, "CLP internal error: option %d begins with \"no-no-\"", i);
        } else if (opt[i].flags & Clp_OnlyNegated) {
            iopt[i].ipos = 0;
            iopt[i].ineg = 1;
        }
    }

    
    calculate_lmm(clp, opt, iopt, nopt);

    return 0;
}


void Clp_SetArguments(Clp_Parser *clp, int argc, const char * const *argv)
{
    Clp_Internal *cli = clp->internal;

    cli->argc = argc + 1;
    cli->argv = argv - 1;

    cli->is_short = 0;
    cli->whole_negated = 0;
    cli->option_processing = 1;
    cli->current_option = -1;
}



int Clp_SetOptionProcessing(Clp_Parser *clp, int on)
{
    Clp_Internal *cli = clp->internal;
    int old = cli->option_processing;
    cli->option_processing = on;
    return old;
}






static int argcmp(const char *ref, const char *arg, int min_match, int fewer_dashes)
     
{
    const char *refstart = ref;
    const char *argstart = arg;
    assert(min_match > 0);

  compare:
    while (*ref && *arg && *arg != '=' && *ref == *arg)
        ref++, arg++;

    
    if (fewer_dashes && *ref == '-' && ref[1] && ref[1] == *arg) {
        ref++;
        goto compare;
    }

    if (*arg && *arg != '=')
        return 0;
    else if (ref - refstart < min_match)
        return -1;
    else return arg - argstart;
}

static int find_prefix_opt(Clp_Parser *clp, const char *arg, int nopt, const Clp_Option *opt, const Clp_InternOption *iopt, int *ambiguous, int *ambiguous_values)



     
{
    int i, fewer_dashes = 0, first_ambiguous = *ambiguous;
    int negated = clp && clp->negated;
    int first_charlen = (clp ? clp_utf8_charlen(clp->internal, arg) : 1);

  retry:
    for (i = 0; i < nopt; i++) {
        int len, lmm;
        if (!iopt[i].ilong || (negated ? !iopt[i].ineg : !iopt[i].ipos))
            continue;

        lmm = (negated ? iopt[i].lmmneg : iopt[i].lmmpos);
        if (clp && clp->internal->could_be_short && (negated ? iopt[i].lmmneg_short : iopt[i].lmmpos_short))
            lmm = (first_charlen >= lmm ? first_charlen + 1 : lmm);
        len = argcmp(opt[i].long_name + iopt[i].ilongoff, arg, lmm, fewer_dashes);
        if (len > 0)
            return i;
        else if (len < 0) {
            if (*ambiguous < MAX_AMBIGUOUS_VALUES)
                ambiguous_values[*ambiguous] = i;
            (*ambiguous)++;
        }
    }

    
    if (*ambiguous == first_ambiguous && !fewer_dashes) {
        fewer_dashes = 1;
        goto retry;
    }

    return -1;
}




static int val_type_binsearch(Clp_Internal *cli, int val_type)
{
    unsigned l = 0, r = cli->nvaltype;
    while (l < r) {
        unsigned m = l + (r - l) / 2;
        if (cli->valtype[m].val_type == val_type)
            return m;
        else if (cli->valtype[m].val_type < val_type)
            l = m + 1;
        else r = m;
    }
    return l;
}


int Clp_AddType(Clp_Parser *clp, int val_type, int flags, Clp_ValParseFunc parser, void *user_data)

{
    Clp_Internal *cli = clp->internal;
    int vtpos;

    if (val_type <= 0 || !parser)
        return -1;

    vtpos = val_type_binsearch(cli, val_type);

    if (vtpos == cli->nvaltype || cli->valtype[vtpos].val_type != val_type) {
        if (cli->nvaltype != 0 && (cli->nvaltype % Clp_InitialValType) == 0) {
            Clp_ValType *new_valtype = (Clp_ValType *) realloc(cli->valtype, sizeof(Clp_ValType) * (cli->nvaltype + Clp_InitialValType));
            if (!new_valtype)
                return -1;
            cli->valtype = new_valtype;
        }
        memmove(&cli->valtype[vtpos + 1], &cli->valtype[vtpos], sizeof(Clp_ValType) * (cli->nvaltype - vtpos));
        cli->nvaltype++;
        cli->valtype[vtpos].func = 0;
    }

    if (cli->valtype[vtpos].func == parse_string_list) {
        Clp_StringList *clsl = (Clp_StringList *) cli->valtype[vtpos].user_data;
        free(clsl->items);
        free(clsl->iopt);
        free(clsl);
    }

    cli->valtype[vtpos].val_type = val_type;
    cli->valtype[vtpos].func = parser;
    cli->valtype[vtpos].flags = flags;
    cli->valtype[vtpos].user_data = user_data;
    return 0;
}




static int parse_string(Clp_Parser *clp, const char *arg, int complain, void *user_data)
{
    (void)complain, (void)user_data;
    clp->val.s = arg;
    return 1;
}

static int parse_int(Clp_Parser* clp, const char* arg, int complain, void* user_data)
{
    const char *val;
    uintptr_t type = (uintptr_t) user_data;
    if (*arg == 0 || isspace((unsigned char) *arg)
        || ((type & 1) && *arg == '-'))
        val = arg;
    else if (type & 1) { 

        clp->val.ul = strtoul(arg, (char **) &val, 0);

        
        if (arg[0] == '-')
            val = arg;
        else clp->val.l = strtol(arg, (char **) &val, 0);

    } else clp->val.l = strtol(arg, (char **) &val, 0);
    if (type <= 1)
        clp->val.u = (unsigned) clp->val.ul;
    if (*arg != 0 && *val == 0)
        return 1;
    else {
        if (complain) {
            const char *message = (type & 1)
                ? "%<%O%> expects a nonnegative integer, not %<%s%>" : "%<%O%> expects an integer, not %<%s%>";
            Clp_OptionError(clp, message, arg);
        }
        return 0;
    }
}

static int parse_double(Clp_Parser *clp, const char *arg, int complain, void *user_data)
{
    const char *val;
    (void)user_data;
    if (*arg == 0 || isspace((unsigned char) *arg))
        val = arg;
    else clp->val.d = strtod(arg, (char **) &val);
    if (*arg != 0 && *val == 0)
        return 1;
    else {
        if (complain)
            Clp_OptionError(clp, "%<%O%> expects a real number, not %<%s%>", arg);
        return 0;
    }
}

static int parse_bool(Clp_Parser *clp, const char *arg, int complain, void *user_data)
{
    int i;
    char lcarg[6];
    (void)user_data;
    if (strlen(arg) > 5 || strchr(arg, '=') != 0)
        goto error;

    for (i = 0; arg[i] != 0; i++)
        lcarg[i] = tolower((unsigned char) arg[i]);
    lcarg[i] = 0;

    if (argcmp("yes", lcarg, 1, 0) > 0 || argcmp("true", lcarg, 1, 0) > 0 || argcmp("1", lcarg, 1, 0) > 0) {

        clp->val.i = 1;
        return 1;
    } else if (argcmp("no", lcarg, 1, 0) > 0 || argcmp("false", lcarg, 1, 0) > 0 || argcmp("1", lcarg, 1, 0) > 0) {

        clp->val.i = 0;
        return 1;
    }

  error:
    if (complain)
        Clp_OptionError(clp, "%<%O%> expects a true-or-false value, not %<%s%>", arg);
    return 0;
}




static int parse_string_list(Clp_Parser *clp, const char *arg, int complain, void *user_data)
{
    Clp_StringList *sl = (Clp_StringList *)user_data;
    int idx, ambiguous = 0;
    int ambiguous_values[MAX_AMBIGUOUS_VALUES + 1];

    
    idx = find_prefix_opt (0, arg, sl->nitems, sl->items, sl->iopt, &ambiguous, ambiguous_values);

    if (idx >= 0) {
        clp->val.i = sl->items[idx].option_id;
        if (sl->val_long)
            clp->val.l = clp->val.i;
        return 1;
    }

    if (sl->allow_int) {
        if (parse_int(clp, arg, 0, (void*) (uintptr_t) (sl->val_long ? 2 : 0)))
            return 1;
    }

    if (complain) {
        const char *complaint = (ambiguous ? "ambiguous" : "invalid");
        if (!ambiguous) {
            ambiguous = sl->nitems_invalid_report;
            for (idx = 0; idx < ambiguous; idx++)
                ambiguous_values[idx] = idx;
        }
        return ambiguity_error (clp, ambiguous, ambiguous_values, sl->items, sl->iopt, "", "option %<%V%> is %s", complaint);

    } else return 0;
}


static int finish_string_list(Clp_Parser *clp, int val_type, int flags, Clp_Option *items, int nitems, int itemscap)

{
    int i;
    Clp_StringList *clsl = (Clp_StringList *)malloc(sizeof(Clp_StringList));
    Clp_InternOption *iopt = (Clp_InternOption *)malloc(sizeof(Clp_InternOption) * nitems);
    if (!clsl || !iopt)
        goto error;

    clsl->items = items;
    clsl->iopt = iopt;
    clsl->nitems = nitems;
    clsl->allow_int = (flags & Clp_AllowNumbers) != 0;
    clsl->val_long = (flags & Clp_StringListLong) != 0;

    if (nitems < MAX_AMBIGUOUS_VALUES && nitems < itemscap && clsl->allow_int) {
        items[nitems].long_name = "any integer";
        clsl->nitems_invalid_report = nitems + 1;
    } else if (nitems > MAX_AMBIGUOUS_VALUES + 1)
        clsl->nitems_invalid_report = MAX_AMBIGUOUS_VALUES + 1;
    else clsl->nitems_invalid_report = nitems;

    for (i = 0; i < nitems; i++) {
        iopt[i].ilong = iopt[i].ipos = 1;
        iopt[i].ishort = iopt[i].ineg = iopt[i].ilongoff = iopt[i].iprefmatch = 0;
    }
    calculate_lmm(clp, items, iopt, nitems);

    if (Clp_AddType(clp, val_type, 0, parse_string_list, clsl) >= 0)
        return 0;

  error:
    if (clsl)
        free(clsl);
    if (iopt)
        free(iopt);
    return -1;
}


int Clp_AddStringListType(Clp_Parser *clp, int val_type, int flags, ...)
{
    int nitems = 0;
    int itemscap = 5;
    Clp_Option *items = (Clp_Option *)malloc(sizeof(Clp_Option) * itemscap);

    va_list val;
    va_start(val, flags);

    if (!items)
        goto error;

    
    while (1) {
        int value;
        char *name = va_arg(val, char *);
        if (!name)
            break;
        if (flags & Clp_StringListLong) {
            long lvalue = va_arg(val, long);
            value = (int) lvalue;
            assert(value == lvalue);
        } else value = va_arg(val, int);

        if (nitems >= itemscap) {
            Clp_Option *new_items;
            itemscap *= 2;
            new_items = (Clp_Option *)realloc(items, sizeof(Clp_Option) * itemscap);
            if (!new_items)
                goto error;
            items = new_items;
        }

        items[nitems].long_name = name;
        items[nitems].option_id = value;
        items[nitems].flags = 0;
        nitems++;
    }

    va_end(val);
    if (finish_string_list(clp, val_type, flags, items, nitems, itemscap) >= 0)
        return 0;

  error:
    va_end(val);
    if (items)
        free(items);
    return -1;
}


int Clp_AddStringListTypeVec(Clp_Parser *clp, int val_type, int flags, int nstrs, const char * const *strs, const int *vals)


     
{
    int i;
    int itemscap = (nstrs < 5 ? 5 : nstrs);
    Clp_Option *items = (Clp_Option *)malloc(sizeof(Clp_Option) * itemscap);
    if (!items)
        return -1;

    
    for (i = 0; i < nstrs; i++) {
        items[i].long_name = strs[i];
        items[i].option_id = vals[i];
        items[i].flags = 0;
    }

    if (finish_string_list(clp, val_type, flags, items, nstrs, itemscap) >= 0)
        return 0;
    else {
        free(items);
        return -1;
    }
}




const char * Clp_ProgramName(Clp_Parser *clp)
{
    return clp->internal->program_name;
}


const char * Clp_SetProgramName(Clp_Parser *clp, const char *name)
{
    const char *old = clp->internal->program_name;
    clp->internal->program_name = name;
    return old;
}





Clp_ParserState * Clp_NewParserState(void)
{
    Clp_ParserState *state = (Clp_ParserState *)malloc(sizeof(Clp_ParserState));
    if (state) {
        state->argv = 0;
        state->argc = 0;
        state->option_chars[0] = 0;
        state->xtext = 0;
        state->option_processing = 0;
        state->opt_generation = 0;
        state->current_option = -1;
        state->is_short = 0;
        state->whole_negated = 0;
        state->current_short = 0;
        state->negated_by_no = 0;
    }
    return state;
}


void Clp_DeleteParserState(Clp_ParserState *state)
{
    free(state);
}


void Clp_SaveParser(const Clp_Parser *clp, Clp_ParserState *state)
{
    Clp_Internal *cli = clp->internal;
    state->argv = cli->argv;
    state->argc = cli->argc;
    memcpy(state->option_chars, cli->option_chars, Clp_OptionCharsSize);
    state->xtext = cli->xtext;

    state->option_processing = cli->option_processing;
    state->opt_generation = cli->opt_generation;
    state->current_option = cli->current_option;
    state->is_short = cli->is_short;
    state->whole_negated = cli->whole_negated;
    state->current_short = cli->current_short;
    state->negated_by_no = cli->negated_by_no;
}



void Clp_RestoreParser(Clp_Parser *clp, const Clp_ParserState *state)
{
    Clp_Internal *cli = clp->internal;
    cli->argv = state->argv;
    cli->argc = state->argc;
    memcpy(cli->option_chars, state->option_chars, Clp_OptionCharsSize);
    cli->xtext = state->xtext;
    cli->option_processing = state->option_processing;
    cli->is_short = state->is_short;
    cli->whole_negated = state->whole_negated;
    cli->current_short = state->current_short;
    cli->negated_by_no = state->negated_by_no;
    if (cli->opt_generation == state->opt_generation)
        cli->current_option = state->current_option;
    else cli->current_option = -1;
}




static void set_option_text(Clp_Internal *cli, const char *text, int n_option_chars)
{
    assert(n_option_chars < Clp_OptionCharsSize);
    memcpy(cli->option_chars, text, n_option_chars);
    cli->option_chars[n_option_chars] = 0;
    cli->xtext = text + n_option_chars;
}

static int get_oclass(Clp_Parser *clp, const char *text, int *ocharskip)
{
    int c;
    if (clp->internal->utf8) {
        const char *s;
        c = decode_utf8(text, &s);
        *ocharskip = s - text;
    } else {
        c = (unsigned char) text[0];
        *ocharskip = 1;
    }
    return Clp_OptionChar(clp, c);
}

static int next_argument(Clp_Parser *clp, int want_argument)
     
{
    Clp_Internal *cli = clp->internal;
    const char *text;
    int oclass, ocharskip;

    
    clp->have_val = 0;
    clp->vstr = 0;
    cli->could_be_short = 0;

    
    if (cli->is_short) {
        cli->xtext += clp_utf8_charlen(cli, cli->xtext);
        if (cli->xtext[0] == 0)
            cli->is_short = 0;
        else if (want_argument > 0) {
            
            clp->have_val = 1;
            if (cli->xtext[0] == '=')
                clp->vstr = cli->xtext + 1;
            else clp->vstr = cli->xtext;
            cli->is_short = 0;
            return 0;
        }
    }

    
    if (cli->is_short)
        return 1;

    
    cli->whole_negated = 0;
    cli->xtext = 0;

    if (cli->argc <= 1)
        return 0;

    cli->argc--;
    cli->argv++;
    text = cli->argv[0];

    if (want_argument > 1)
        goto not_option;

    if (text[0] == '-' && text[1] == '-') {
        oclass = Clp_DoubledLong;
        ocharskip = 2;
    } else oclass = get_oclass(clp, text, &ocharskip);

    
    if ((oclass & (Clp_Short | Clp_ShortNegated))
        && (oclass & (Clp_Long | Clp_LongNegated))) {
        oclass &= ~(Clp_Short | Clp_ShortNegated);
        if (text[ocharskip])
            cli->could_be_short = 1;
    }

    switch (oclass) {

      case Clp_Short:
        cli->is_short = 1;
        goto check_singleton;

      case Clp_ShortNegated:
        cli->is_short = 1;
        cli->whole_negated = 1;
        goto check_singleton;

      case Clp_Long:
        goto check_singleton;

      case Clp_LongNegated:
        cli->whole_negated = 1;
        goto check_singleton;

      check_singleton:
        
        if (!text[ocharskip])
            goto not_option;
        set_option_text(cli, text, ocharskip);
        break;

      case Clp_LongImplicit:
        
        if (want_argument > 0)
            goto not_option;
        set_option_text(cli, text, 0);
        break;

      case Clp_DoubledLong:
        set_option_text(cli, text, ocharskip);
        break;

      not_option:
      case Clp_NotOption:
        cli->is_short = 0;
        clp->have_val = 1;
        clp->vstr = text;
        return 0;

      default:
        assert(0 );

    }

    return 1;
}


static void switch_to_short_argument(Clp_Parser *clp)
{
    Clp_Internal *cli = clp->internal;
    const char *text = cli->argv[0];
    int ocharskip, oclass = get_oclass(clp, text, &ocharskip);
    assert(cli->could_be_short);
    cli->is_short = 1;
    cli->whole_negated = !!(oclass & Clp_ShortNegated);
    set_option_text(cli, cli->argv[0], ocharskip);
}


static int find_long(Clp_Parser *clp, const char *arg)
     
{
    Clp_Internal *cli = clp->internal;
    int optno, len, lmm;
    const Clp_Option *opt = cli->opt;
    const Clp_InternOption *iopt;
    int first_negative_ambiguous;

    
    optno = find_prefix_opt (clp, arg, cli->nopt, opt, cli->iopt, &cli->ambiguous, cli->ambiguous_values);

    if (optno >= 0)
        goto worked;

    
    
    first_negative_ambiguous = cli->ambiguous;
    while (arg[0] == 'n' && arg[1] == 'o' && arg[2] == '-') {
        arg += 3;
        clp->negated = !clp->negated;
        optno = find_prefix_opt (clp, arg, cli->nopt, opt, cli->iopt, &cli->ambiguous, cli->ambiguous_values);

        if (optno >= 0)
            goto worked;
    }

    
    {
        int i, max = cli->ambiguous;
        if (max > MAX_AMBIGUOUS_VALUES) max = MAX_AMBIGUOUS_VALUES;
        for (i = first_negative_ambiguous; i < max; i++)
            cli->ambiguous_values[i] = -cli->ambiguous_values[i] - 1;
    }
    return -1;

  worked:
    iopt = &cli->iopt[optno];
    lmm = (clp->negated ? iopt->lmmneg : iopt->lmmpos);
    if (cli->could_be_short && (clp->negated ? iopt->lmmneg_short : iopt->lmmpos_short)) {
        int first_charlen = clp_utf8_charlen(cli, arg);
        lmm = (first_charlen >= lmm ? first_charlen + 1 : lmm);
    }
    len = argcmp(opt[optno].long_name + iopt->ilongoff, arg, lmm, 1);
    assert(len > 0);
    if (arg[len] == '=') {
        clp->have_val = 1;
        clp->vstr = arg + len + 1;
    }
    return optno;
}


static int find_short(Clp_Parser *clp, const char *text)
     
{
    Clp_Internal *cli = clp->internal;
    const Clp_Option *opt = cli->opt;
    const Clp_InternOption *iopt = cli->iopt;
    int i, c;
    if (clp->internal->utf8)
        c = decode_utf8(text, 0);
    else c = (unsigned char) *text;

    for (i = 0; i < cli->nopt; i++)
        if (iopt[i].ishort && opt[i].short_name == c && (!clp->negated || iopt[i].ineg)) {
            clp->negated = clp->negated || !iopt[i].ipos;
            return i;
        }

    return -1;
}



int Clp_Next(Clp_Parser *clp)
{
    Clp_Internal *cli = clp->internal;
    int optno;
    const Clp_Option *opt;
    Clp_ParserState clpsave;
    int vtpos, complain;

    
    cli->current_option = -1;
    cli->ambiguous = 0;

    
    if (!next_argument(clp, cli->option_processing ? 0 : 2)) {
        clp->val.s = clp->vstr;
        optno = clp->have_val ? Clp_NotOption : Clp_Done;
        clp->option = &clp_option_sentinel[-optno];
        return optno;
    }

    clp->negated = cli->whole_negated;
    if (cli->is_short)
        optno = find_short(clp, cli->xtext);
    else optno = find_long(clp, cli->xtext);

    
    if (optno < 0 && cli->could_be_short) {
        switch_to_short_argument(clp);
        optno = find_short(clp, cli->xtext);
    }

    
    if (optno < 0 || (clp->negated && !cli->iopt[optno].ineg)) {
        
        if (strcmp(cli->argv[0], "--") == 0) {
            Clp_SetOptionProcessing(clp, 0);
            return Clp_Next(clp);
        }

        
        if (cli->ambiguous)
            ambiguity_error(clp, cli->ambiguous, cli->ambiguous_values, cli->opt, cli->iopt, cli->option_chars, "option %<%s%s%> is ambiguous", cli->option_chars, cli->xtext);


        else if (cli->is_short && !cli->could_be_short)
            Clp_OptionError(clp, "unrecognized option %<%s%C%>", cli->option_chars, cli->xtext);
        else Clp_OptionError(clp, "unrecognized option %<%s%s%>", cli->option_chars, cli->xtext);


        clp->option = &clp_option_sentinel[-Clp_BadOption];
        return Clp_BadOption;
    }

    
    cli->current_option = optno;
    cli->current_short = cli->is_short;
    cli->negated_by_no = clp->negated && !cli->whole_negated;

    
    if (clp->negated || (!cli->iopt[optno].imandatory && !cli->iopt[optno].ioptional)) {
        if (clp->have_val) {
            Clp_OptionError(clp, "%<%O%> can%,t take an argument");
            clp->option = &clp_option_sentinel[-Clp_BadOption];
            return Clp_BadOption;
        } else {
            clp->option = &cli->opt[optno];
            return cli->opt[optno].option_id;
        }
    }

    
    
    opt = &cli->opt[optno];
    if (opt->val_type <= 0) {
        clp->option = &clp_option_sentinel[-Clp_Error];
        return Clp_Error;
    }
    vtpos = val_type_binsearch(cli, opt->val_type);
    if (vtpos == cli->nvaltype || cli->valtype[vtpos].val_type != opt->val_type) {
        clp->option = &clp_option_sentinel[-Clp_Error];
        return Clp_Error;
    }

    
    complain = (clp->have_val != 0) || cli->iopt[optno].imandatory;
    Clp_SaveParser(clp, &clpsave);

    if (cli->iopt[optno].imandatory && !clp->have_val) {
        
        
        int disallow = (cli->valtype[vtpos].flags & Clp_DisallowOptions) != 0;
        next_argument(clp, disallow ? 1 : 2);
        if (!clp->have_val) {
            int got_option = cli->xtext != 0;
            Clp_RestoreParser(clp, &clpsave);
            if (got_option)
                Clp_OptionError(clp, "%<%O%> requires a non-option argument");
            else Clp_OptionError(clp, "%<%O%> requires an argument");
            clp->option = &clp_option_sentinel[-Clp_BadOption];
            return Clp_BadOption;
        }

    } else if (cli->is_short && !clp->have_val && cli->xtext[clp_utf8_charlen(cli, cli->xtext)])
        
        next_argument(clp, 1);

    
    clp->option = opt;
    if (clp->have_val) {
        Clp_ValType *atr = &cli->valtype[vtpos];
        if (atr->func(clp, clp->vstr, complain, atr->user_data) <= 0) {
            
            clp->have_val = 0;
            if (complain) {
                clp->option = &clp_option_sentinel[-Clp_BadOption];
                return Clp_BadOption;
            } else {
                Clp_RestoreParser(clp, &clpsave);
                clp->option = opt;
            }
        }
    }

    return opt->option_id;
}



const char * Clp_Shift(Clp_Parser *clp, int allow_options)
     
{
    Clp_ParserState clpsave;
    Clp_SaveParser(clp, &clpsave);
    next_argument(clp, allow_options ? 2 : 1);
    if (!clp->have_val)
        Clp_RestoreParser(clp, &clpsave);
    return clp->vstr;
}




typedef struct Clp_BuildString {
    char* data;
    char* pos;
    char* end_data;
    char buf[256];
} Clp_BuildString;

static void build_string_program_prefix(Clp_BuildString* bs, const Clp_Parser* clp);

static void build_string_init(Clp_BuildString* bs, Clp_Parser* clp) {
    bs->data = bs->pos = bs->buf;
    bs->end_data = &bs->buf[sizeof(bs->buf)];
    if (clp)
        build_string_program_prefix(bs, clp);
}

static void build_string_cleanup(Clp_BuildString* bs) {
    if (bs->data != bs->buf)
        free(bs->data);
}

static int build_string_grow(Clp_BuildString* bs, size_t want) {
    size_t ipos = bs->pos - bs->data, ncap;
    if (!bs->pos)
        return 0;
    for (ncap = (bs->end_data - bs->data) << 1; ncap < want; ncap *= 2)
        ;
    if (bs->data == bs->buf) {
        if ((bs->data = (char*) malloc(ncap)))
            memcpy(bs->data, bs->buf, bs->pos - bs->buf);
    } else bs->data = (char*) realloc(bs->data, ncap);
    if (!bs->data) {
        bs->pos = bs->end_data = bs->data;
        return 0;
    } else {
        bs->pos = bs->data + ipos;
        bs->end_data = bs->data + ncap;
        return 1;
    }
}




static void append_build_string(Clp_BuildString *bs, const char *s, int l)
{
    if (l < 0)
        l = strlen(s);
    if (ENSURE_BUILD_STRING(bs, l)) {
        memcpy(bs->pos, s, l);
        bs->pos += l;
    }
}

static void build_string_program_prefix(Clp_BuildString* bs, const Clp_Parser* clp)
{
    const Clp_Internal* cli = clp->internal;
    if (cli->program_name && cli->program_name[0]) {
        append_build_string(bs, cli->program_name, -1);
        append_build_string(bs, ": ", 2);
    }
}


static void Clp_vbsprintf(Clp_Parser *clp, Clp_BuildString *bs, const char *fmt, va_list val)

{
    Clp_Internal *cli = clp->internal;
    const char *percent;
    int c;

    for (percent = strchr(fmt, '%'); percent; percent = strchr(fmt, '%')) {
        append_build_string(bs, fmt, percent - fmt);
        switch (*++percent) {

          case 's': {
              const char *s = va_arg(val, const char *);
              append_build_string(bs, s ? s : "(null)", -1);
              break;
          }

          case 'C': {
              const char *s = va_arg(val, const char *);
              if (cli->utf8)
                  c = decode_utf8(s, 0);
              else c = (unsigned char) *s;
              goto char_c;
          }

          case 'c':
            c = va_arg(val, int);
            goto char_c;

          char_c:
            if (ENSURE_BUILD_STRING(bs, 4)) {
                if (c >= 32 && c <= 126)
                    *bs->pos++ = c;
                else if (c < 32) {
                    *bs->pos++ = '^';
                    *bs->pos++ = c + 64;
                } else if (cli->utf8 && c >= 127 && c < 0x110000) {
                    bs->pos = encode_utf8(bs->pos, 4, c);
                } else if (c >= 127 && c <= 255) {
                    snprintf(bs->pos, 4, "\\%03o", c & 0xFF);
                    bs->pos += 4;
                } else {
                    *bs->pos++ = '\\';
                    *bs->pos++ = '?';
                }
            }
            break;

          case 'd': {
              int d = va_arg(val, int);
              if (ENSURE_BUILD_STRING(bs, 32)) {
                  snprintf(bs->pos, 32, "%d", d);
                  bs->pos = strchr(bs->pos, 0);
              }
              break;
          }

        case 'O':
        case 'V': {
            int optno = cli->current_option;
            const Clp_Option *opt = &cli->opt[optno];
            if (optno < 0)
                append_build_string(bs, "(no current option!)", -1);
            else if (cli->current_short) {
                append_build_string(bs, cli->option_chars, -1);
                if (ENSURE_BUILD_STRING(bs, 5)) {
                    if (cli->utf8)
                        bs->pos = encode_utf8(bs->pos, 5, opt->short_name);
                    else *bs->pos++ = opt->short_name;
                }
            } else if (cli->negated_by_no) {
                append_build_string(bs, cli->option_chars, -1);
                append_build_string(bs, "no-", 3);
                append_build_string(bs, opt->long_name + cli->iopt[optno].ilongoff, -1);
            } else {
                append_build_string(bs, cli->option_chars, -1);
                append_build_string(bs, opt->long_name + cli->iopt[optno].ilongoff, -1);
            }
            if (optno >= 0 && clp->have_val && *percent == 'V') {
                if (cli->current_short && !cli->iopt[optno].ioptional)
                    append_build_string(bs, " ", 1);
                else if (!cli->current_short)
                    append_build_string(bs, "=", 1);
                append_build_string(bs, clp->vstr, -1);
            }
            break;
        }

          case '%':
            if (ENSURE_BUILD_STRING(bs, 1))
                *bs->pos++ = '%';
            break;

          case '<':
            append_build_string(bs, (cli->utf8 ? "\342\200\230" : "'"), -1);
            break;

          case ',':
          case '>':
            append_build_string(bs, (cli->utf8 ? "\342\200\231" : "'"), -1);
            break;

        case 0:
            append_build_string(bs, "%", 1);
            goto done;

          default:
            if (ENSURE_BUILD_STRING(bs, 2)) {
                *bs->pos++ = '%';
                *bs->pos++ = *percent;
            }
            break;

        }
        fmt = ++percent;
    }

 done:
    append_build_string(bs, fmt, -1);
}

static const char* build_string_text(Clp_BuildString* bs, int report_oom) {
    if (bs->pos) {
        *bs->pos = 0;
        return bs->data;
    } else if (report_oom)
        return "out of memory\n";
    else return NULL;
}

static void do_error(Clp_Parser *clp, Clp_BuildString *bs)
{
    const char *text = build_string_text(bs, 1);
    if (clp->internal->error_handler != 0)
        (*clp->internal->error_handler)(clp, text);
    else fputs(text, stderr);
}


int Clp_OptionError(Clp_Parser *clp, const char *format, ...)
{
    Clp_BuildString bs;
    va_list val;
    va_start(val, format);
    build_string_init(&bs, clp);
    Clp_vbsprintf(clp, &bs, format, val);
    append_build_string(&bs, "\n", 1);
    va_end(val);
    do_error(clp, &bs);
    build_string_cleanup(&bs);
    return bs.pos - bs.data;
}


int Clp_fprintf(Clp_Parser* clp, FILE* f, const char* format, ...)
{
    Clp_BuildString bs;
    va_list val;
    va_start(val, format);
    build_string_init(&bs, NULL);
    Clp_vbsprintf(clp, &bs, format, val);
    va_end(val);
    if (bs.pos != bs.data)
        fwrite(bs.data, 1, bs.pos - bs.data, f);
    build_string_cleanup(&bs);
    return bs.pos - bs.data;
}


int Clp_vfprintf(Clp_Parser* clp, FILE* f, const char* format, va_list val)
{
    Clp_BuildString bs;
    build_string_init(&bs, NULL);
    Clp_vbsprintf(clp, &bs, format, val);
    if (bs.pos != bs.data)
        fwrite(bs.data, 1, bs.pos - bs.data, f);
    build_string_cleanup(&bs);
    return bs.pos - bs.data;
}


int Clp_vsnprintf(Clp_Parser* clp, char* str, size_t size, const char* format, va_list val)

{
    Clp_BuildString bs;
    build_string_init(&bs, NULL);
    Clp_vbsprintf(clp, &bs, format, val);
    if ((size_t) (bs.pos - bs.data) < size) {
        memcpy(str, bs.data, bs.pos - bs.data);
        str[bs.pos - bs.data] = 0;
    } else {
        memcpy(str, bs.data, size - 1);
        str[size - 1] = 0;
    }
    build_string_cleanup(&bs);
    return bs.pos - bs.data;
}

static int ambiguity_error(Clp_Parser *clp, int ambiguous, int *ambiguous_values, const Clp_Option *opt, const Clp_InternOption *iopt, const char *prefix, const char *fmt, ...)


{
    Clp_Internal *cli = clp->internal;
    Clp_BuildString bs;
    int i;
    va_list val;

    va_start(val, fmt);
    build_string_init(&bs, clp);
    Clp_vbsprintf(clp, &bs, fmt, val);
    append_build_string(&bs, "\n", 1);

    build_string_program_prefix(&bs, clp);
    append_build_string(&bs, "(Possibilities are", -1);

    for (i = 0; i < ambiguous && i < MAX_AMBIGUOUS_VALUES; i++) {
        int value = ambiguous_values[i];
        const char *no_dash = "";
        if (value < 0)
            value = -(value + 1), no_dash = "no-";
        if (i == 0)
            append_build_string(&bs, " ", 1);
        else if (i == ambiguous - 1)
            append_build_string(&bs, (i == 1 ? " and " : ", and "), -1);
        else append_build_string(&bs, ", ", 2);
        append_build_string(&bs, (cli->utf8 ? "\342\200\230" : "'"), -1);
        append_build_string(&bs, prefix, -1);
        append_build_string(&bs, no_dash, -1);
        append_build_string(&bs, opt[value].long_name + iopt[value].ilongoff, -1);
        append_build_string(&bs, (cli->utf8 ? "\342\200\231" : "'"), -1);
    }

    if (ambiguous > MAX_AMBIGUOUS_VALUES)
        append_build_string(&bs, ", and others", -1);
    append_build_string(&bs, ".)\n", -1);
    va_end(val);

    do_error(clp, &bs);
    build_string_cleanup(&bs);
    return 0;
}

static int copy_string(char *buf, int buflen, int bufpos, const char *what)
{
    int l = strlen(what);
    if (l > buflen - bufpos - 1)
        l = buflen - bufpos - 1;
    memcpy(buf + bufpos, what, l);
    return l;
}


int Clp_CurOptionNameBuf(Clp_Parser *clp, char *buf, int len)
{
    Clp_Internal *cli = clp->internal;
    int optno = cli->current_option;
    int pos = 0;
    if (optno < 0)
        pos += copy_string(buf, len, pos, "(no current option!)");
    else if (cli->current_short) {
        pos += copy_string(buf, len, pos, cli->option_chars);
        if (cli->utf8)
            pos = (encode_utf8(buf + pos, len - pos - 1, cli->opt[optno].short_name) - buf);
        else if (pos < len - 1)
            buf[pos++] = cli->opt[optno].short_name;
    } else if (cli->negated_by_no) {
        pos += copy_string(buf, len, pos, cli->option_chars);
        pos += copy_string(buf, len, pos, "no-");
        pos += copy_string(buf, len, pos, cli->opt[optno].long_name + cli->iopt[optno].ilongoff);
    } else {
        pos += copy_string(buf, len, pos, cli->option_chars);
        pos += copy_string(buf, len, pos, cli->opt[optno].long_name + cli->iopt[optno].ilongoff);
    }
    if (pos < len)
        buf[pos] = 0;
    return pos;
}


const char * Clp_CurOptionName(Clp_Parser *clp)
{
    static char buf[256];
    Clp_CurOptionNameBuf(clp, buf, 256);
    return buf;
}

int Clp_IsLong(Clp_Parser *clp, const char *long_name)
{
    Clp_Internal *cli = clp->internal;
    int optno = cli->current_option;
    return optno >= 0 && strcmp(cli->opt[optno].long_name, long_name) == 0;
}

int Clp_IsShort(Clp_Parser *clp, int short_name)
{
    Clp_Internal *cli = clp->internal;
    int optno = cli->current_option;
    return optno >= 0 && cli->opt[optno].short_name == short_name;
}


}

