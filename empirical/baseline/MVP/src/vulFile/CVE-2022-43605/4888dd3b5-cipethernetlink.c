














  #define OPENER_ETHLINK_LABEL_ENABLE  1



  #define OPENER_ETHLINK_LABEL_ENABLE  0



  #define IFACE_LABEL_ACCESS_MODE kGetableSingleAndAll
  #define IFACE_LABEL             "PORT 1"
  #define IFACE_LABEL_1           "PORT 2"
  #define IFACE_LABEL_2           "PORT internal"

  #define IFACE_LABEL_ACCESS_MODE kGetableAll



  #define IFACE_CTRL_ACCESS_MODE  (kSetAndGetAble | kNvDataFunc)

  #define IFACE_CTRL_ACCESS_MODE  kGetableAll


typedef struct speed_duplex_array_entry {
  CipUint interface_speed;  
  CipUsint interface_duplex_mode;  
} CipEthernetLinkSpeedDuplexArrayEntry;



static void EncodeCipEthernetLinkInterfaceCounters(const void *const data, ENIPMessage *const outgoing_message);

static void EncodeCipEthernetLinkMediaCounters(const void *const data, ENIPMessage *const outgoing_message);

static void EncodeCipEthernetLinkInterfaceControl(const void *const data, ENIPMessage *const outgoing_message);

static void EncodeCipEthernetLinkInterfaceCaps(const void *const data, ENIPMessage *const outgoing_message);



EipStatus GetAndClearEthernetLink( CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);









int DecodeCipEthernetLinkInterfaceControl( CipEthernetLinkInterfaceControl *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response);






static const CipEthernetLinkSpeedDuplexArrayEntry speed_duplex_table[] = {
  { 
    .interface_speed = 10, .interface_duplex_mode = 0 }, {


    .interface_speed = 10, .interface_duplex_mode = 1 }, {


    .interface_speed = 100, .interface_duplex_mode = 0 }, {


    .interface_speed = 100, .interface_duplex_mode = 1 }, {


    .interface_speed = 1000, .interface_duplex_mode = 0 }, {


    .interface_speed = 1000, .interface_duplex_mode = 1 }, };




static const CipShortString iface_label_table[OPENER_ETHLINK_INSTANCE_CNT] = {
  {
    .length = sizeof IFACE_LABEL - 1, .string = (EipByte *)IFACE_LABEL },  {



    .length = sizeof IFACE_LABEL_1 - 1, .string = (EipByte *)IFACE_LABEL_1 },   {




    .length = sizeof IFACE_LABEL_2 - 1, .string = (EipByte *)IFACE_LABEL_2 },  };






static CipUsint dummy_attribute_usint = 0;


static CipUdint dummy_attribute_udint = 0;





static CipEthernetLinkInterfaceControl s_interface_control = {
  .control_bits = 0, .forced_interface_speed = 0, };




CipEthernetLinkObject g_ethernet_link[OPENER_ETHLINK_INSTANCE_CNT];

EipStatus CipEthernetLinkInit(void) {
  CipClass *ethernet_link_class = CreateCipClass(kCipEthernetLinkClassCode, 0,  7,  2,  11,  11,   2 + OPENER_ETHLINK_CNTRS_ENABLE + OPENER_ETHLINK_IFACE_CTRL_ENABLE, OPENER_ETHLINK_INSTANCE_CNT,  "Ethernet Link",  4,  NULL);



















  
  for (size_t idx = 0; idx < OPENER_ETHLINK_INSTANCE_CNT; ++idx) {
    g_ethernet_link[idx].interface_speed = 100;
    
    g_ethernet_link[idx].interface_flags = 0xF;

    g_ethernet_link[idx].interface_type = kEthLinkIfTypeTwistedPair;
    if (2 == idx) {
      g_ethernet_link[idx].interface_type = kEthLinkIfTypeInternal;
    }

    g_ethernet_link[idx].interface_label = iface_label_table[idx];

    g_ethernet_link[idx].interface_caps.capability_bits = kEthLinkCapAutoNeg;
    g_ethernet_link[idx].interface_caps.speed_duplex_selector = kEthLinkSpeedDpx_100_FD;

    g_ethernet_link[idx].interface_control.control_bits = kEthLinkIfCntrlAutonegotiate;
    g_ethernet_link[idx].interface_control.forced_interface_speed = 0U;

  }

  if (ethernet_link_class != NULL) {
    
    InsertService(ethernet_link_class, kGetAttributeSingle, &GetAttributeSingle, "GetAttributeSingle");

    InsertService(ethernet_link_class, kGetAttributeAll, &GetAttributeAll, "GetAttributeAll");


    InsertService(ethernet_link_class, kEthLinkGetAndClear, &GetAndClearEthernetLink, "GetAndClear");


    InsertService(ethernet_link_class, kSetAttributeSingle, &SetAttributeSingle, "SetAttributeSingle");



    
    for (size_t idx = 0; idx < OPENER_ETHLINK_INSTANCE_CNT; ++idx) {
      CipInstance *ethernet_link_instance = GetCipInstance(ethernet_link_class, idx + 1);

      InsertAttribute(ethernet_link_instance, 1, kCipUdint, EncodeCipUdint, NULL, &g_ethernet_link[idx].interface_speed, kGetableSingleAndAll);





      InsertAttribute(ethernet_link_instance, 2, kCipDword, EncodeCipDword, NULL, &g_ethernet_link[idx].interface_flags, kGetableSingleAndAll);





      InsertAttribute(ethernet_link_instance, 3, kCip6Usint, EncodeCipEthernetLinkPhyisicalAddress, NULL, &g_ethernet_link[idx].physical_address, kGetableSingleAndAll);






      InsertAttribute(ethernet_link_instance, 4, kCipUsint, EncodeCipUsint, NULL, &g_ethernet_link[idx].interface_cntrs, kGetableSingleAndAll);





      InsertAttribute(ethernet_link_instance, 5, kCipUsint, EncodeCipUsint, NULL, &g_ethernet_link[idx].media_cntrs, kGetableSingleAndAll);






      InsertAttribute(ethernet_link_instance, 4, kCipAny, EncodeCipEthernetLinkInterfaceCounters, NULL, &dummy_attribute_udint, kGetableAllDummy);





      InsertAttribute(ethernet_link_instance, 5, kCipAny, EncodeCipEthernetLinkMediaCounters, NULL, &dummy_attribute_udint, kGetableAllDummy);







      if (2 == idx) {
        
        InsertAttribute(ethernet_link_instance, 6, kCipAny, EncodeCipEthernetLinkInterfaceControl, DecodeCipEthernetLinkInterfaceControl, &g_ethernet_link[idx].interface_control, IFACE_CTRL_ACCESS_MODE & ~kSetable);





      } else {
        InsertAttribute(ethernet_link_instance, 6, kCipAny, EncodeCipEthernetLinkInterfaceControl, DecodeCipEthernetLinkInterfaceControl, &g_ethernet_link[idx].interface_control, IFACE_CTRL_ACCESS_MODE);





      }

      InsertAttribute(ethernet_link_instance, 6, kCipAny, EncodeCipEthernetLinkInterfaceControl, NULL, &s_interface_control, kGetableAll);






      InsertAttribute(ethernet_link_instance, 7, kCipUsint, EncodeCipUsint, NULL, &g_ethernet_link[idx].interface_type, kGetableSingleAndAll);





      InsertAttribute(ethernet_link_instance, 8, kCipUsint, EncodeCipUsint, NULL, &dummy_attribute_usint, kGetableAllDummy);





      InsertAttribute(ethernet_link_instance, 9, kCipUsint, EncodeCipUsint, NULL, &dummy_attribute_usint, kGetableAllDummy);




      InsertAttribute(ethernet_link_instance, 10, kCipShortString, EncodeCipShortString, NULL, &g_ethernet_link[idx].interface_label, IFACE_LABEL_ACCESS_MODE);





      InsertAttribute(ethernet_link_instance, 11, kCipAny, EncodeCipEthernetLinkInterfaceCaps, NULL, &g_ethernet_link[idx].interface_caps, kGetableSingleAndAll);





    }
  } else {
    return kEipStatusError;
  }

  return kEipStatusOk;
}

void CipEthernetLinkSetMac(EipUint8 *p_physical_address) {
  for (size_t idx = 0; idx < OPENER_ETHLINK_INSTANCE_CNT; ++idx) {
    memcpy(g_ethernet_link[idx].physical_address, p_physical_address, sizeof(g_ethernet_link[0].physical_address)

           );
  }
  return;
}

static void EncodeCipEthernetLinkInterfaceCounters(const void *const data, ENIPMessage *const outgoing_message)
{

  for (size_t i = 0; i < 11; i++) {
    
    EncodeData(kCipUdint, g_ethernet_link[instance_id - 1].interface_cntrs.cntr32 + i, message_router_response);

  }

  
  FillNextNMessageOctetsWithValueAndMoveToNextPosition(0, 11 * sizeof(CipUdint), outgoing_message);


}

static void EncodeCipEthernetLinkMediaCounters(const void *const data, ENIPMessage *const outgoing_message)
{

  for (size_t i = 0; i < 12; i++) {
    
    EncodeData(kCipUdint, g_ethernet_link[instance_id - 1].media_cntrs.cntr32 + i, message_router_response);

  }

  
  FillNextNMessageOctetsWithValueAndMoveToNextPosition(0, 12 * sizeof(CipUdint), outgoing_message);


}

static void EncodeCipEthernetLinkInterfaceControl(const void *const data, ENIPMessage *const outgoing_message)
{

  const CipEthernetLinkInterfaceControl *const interface_control = data;

  CipEthernetLinkInterfaceControl *interface_control = &s_interface_control;

  EncodeCipWord(&interface_control->control_bits, outgoing_message);
  EncodeCipUint(&interface_control->forced_interface_speed, outgoing_message);
}


static void EncodeCipEthernetLinkInterfaceCaps(const void *const data, ENIPMessage *const outgoing_message)
{
  const CipEthernetLinkMetaInterfaceCapability *const interface_caps = data;
  EncodeCipDword(&interface_caps->capability_bits, outgoing_message);
  uint16_t selected = interface_caps->speed_duplex_selector;
  CipUsint count = 0;
  while(selected) { 
    selected &= selected - 1U;        
    count++;
  }
  EncodeCipUsint(&count, outgoing_message);

  for (size_t i = 0; i < NELEMENTS(speed_duplex_table); i++) {
    if (interface_caps->speed_duplex_selector & (1U << i) ) {
      EncodeCipUint(&speed_duplex_table[i].interface_speed, outgoing_message);
      EncodeCipUsint(&speed_duplex_table[i].interface_duplex_mode, outgoing_message);
    }
  }
}


EipStatus GetAndClearEthernetLink( CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {





  CipAttributeStruct *attribute = GetCipAttribute( instance, message_router_request->request_path.attribute_number);

  message_router_response->data_length = 0;
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorAttributeNotSupported;
  message_router_response->size_of_additional_status = 0;

  EipUint16 attribute_number = message_router_request->request_path .attribute_number;

  if ( (NULL != attribute) && (NULL != attribute->data) ) {
    OPENER_TRACE_INFO("GetAndClear attribute %" PRIu16 "\n", attribute_number);

    
    switch (attribute_number) {
      case 4: 
      case 5:
        GetAttributeSingleEthernetLink( instance, message_router_request, message_router_response, originator_address, encapsulation_session);



        break;
      default:
        message_router_response->general_status = kCipErrorServiceNotSupportedForSpecifiedPath;
        break;
    }

    
    
  }

  return kEipStatusOkSend;
}



static bool IsIfaceControlAllowed(CipUdint instance_id, CipEthernetLinkInterfaceControl const *iface_cntrl)
{
  const CipUsint duplex_mode = (iface_cntrl->control_bits & kEthLinkIfCntrlForceDuplexFD) ? 1 : 0;
  for (size_t i = 0; i < NELEMENTS(speed_duplex_table); i++) {
    if (g_ethernet_link[instance_id - 1].interface_caps.speed_duplex_selector & (1U << i) ) {
      if (duplex_mode == speed_duplex_table[i].interface_duplex_mode && iface_cntrl->forced_interface_speed == speed_duplex_table[i].interface_speed) {

        return true;
      }
    }
  }
  return false;
}

int DecodeCipEthernetLinkInterfaceControl( CipEthernetLinkInterfaceControl *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {



	CipInstance *const instance = GetCipInstance( GetCipClass(message_router_request->request_path.class_id), message_router_request->request_path.instance_number);


	int number_of_decoded_bytes = -1;

	CipEthernetLinkInterfaceControl if_cntrl;

	DecodeCipWord(&if_cntrl.control_bits, message_router_request, message_router_response);
	DecodeCipUint(&if_cntrl.forced_interface_speed, message_router_request, message_router_response);

	if (if_cntrl.control_bits > kEthLinkIfCntrlMaxValid) {
		message_router_response->general_status = kCipErrorInvalidAttributeValue;
		return number_of_decoded_bytes;

	} else {
		if ((0 != (if_cntrl.control_bits & kEthLinkIfCntrlAutonegotiate))
				&& ((0 != (if_cntrl.control_bits & kEthLinkIfCntrlForceDuplexFD))
						|| (0 != if_cntrl.forced_interface_speed))) {
			message_router_response->general_status = kCipErrorObjectStateConflict;
			return number_of_decoded_bytes;
		} else {
			if (0 == (if_cntrl.control_bits & kEthLinkIfCntrlAutonegotiate)) {
				
				if (!IsIfaceControlAllowed(instance->instance_number, &if_cntrl)) {
					message_router_response->general_status = kCipErrorInvalidAttributeValue;
					return number_of_decoded_bytes;
				}
			}
			*data = if_cntrl; 
			message_router_response->general_status = kCipErrorSuccess;
			number_of_decoded_bytes = 4;
		}
	}
	return number_of_decoded_bytes;
}

 #endif
