


























  #define IFACE_CFG_SET_MODE  kSetable
  #define CFG_CAPS  (CFG_CAPS_DHCP_CLIENT | CFG_CAPS_CFG_SETTABLE |  CFG_CAPS_CFG_CHG_NEEDS_RESET

  #define IFACE_CFG_SET_MODE  kNotSetOrGetable
  #define CFG_CAPS  (CFG_CAPS_DHCP_CLIENT)



CipTcpIpObject g_tcpip = {
  .status = 0x01,  .config_capability = CFG_CAPS, .config_control = 0x02,   .physical_link_object = {




    2,   CIP_ETHERNETLINK_CLASS_CODE, OPENER_ETHLINK_INSTANCE_CNT, 0 },  .physical_link_object = {





    0,   0, 0, 0 },  .interface_configuration = {





    0,  0, 0, 0, 0, {




      0, NULL, }
  }, .hostname = {
    0, NULL }, .mcast_ttl_value = 1, .mcast_config = {



    0,   0, 1, 0 }, .select_acd = false, .encapsulation_inactivity_timeout = 120 };











static bool isalnum_c(const EipByte byte) {
  return ('a' <= byte && byte <= 'z') || ('A' <= byte && byte <= 'Z') || ('0' <= byte && byte <= '9');


}


static bool IsValidNameLabel(const EipByte *label) {
  if (!isalnum_c(*label) ) {
    return false;
  }
  ++label;
  while ('\0' != *label && (isalnum_c(*label) || '-' == *label) ) {
    ++label;
  }
  return ('\0' == *label && '-' != label[-1]);
}


static bool IsValidDomain(EipByte *domain) {
  bool status = true;

  OPENER_TRACE_INFO("Enter '%s'->", domain);
  if ('.' == *domain) { 
    return false;
  }
  EipByte *dot = (EipByte *)strchr( (char *)domain, '.' );
  if (dot) {
    bool rc;

    *dot = '\0';
    status &= rc = IsValidNameLabel(domain);
    OPENER_TRACE_INFO("Checked %d '%s'\n", rc, domain);
    if ('\0' != dot[1]) {
      status &= IsValidDomain(dot + 1);
    }
    else {  
      status = false;
    }
    *dot = '.';
  }
  else {
    status = IsValidNameLabel(domain);
    OPENER_TRACE_INFO("Check end %d '%s'\n", status, domain);
  }
  return status;
}



static bool IsValidNetmask(in_addr_t netmask) {
  in_addr_t v = ntohl(netmask);

  v = ~v;   
  ++v;      
  bool valid = v && !(v & (v - 1) );  

  return valid && (INADDR_BROADCAST != netmask);
}


static bool IsInClassAbc(in_addr_t ip_addr) {
  in_addr_t ip = ntohl(ip_addr);
  return IN_CLASSA(ip) || IN_CLASSB(ip) || IN_CLASSC(ip);
}


static bool IsOnLoopbackNetwork(in_addr_t ip_addr) {
  in_addr_t ip = ntohl(ip_addr);
  return (ip & IN_CLASSA_NET) == (INADDR_LOOPBACK & IN_CLASSA_NET);
}


static bool IsNetworkOrBroadcastIp(in_addr_t ip_addr, in_addr_t net_mask) {
  return ( (ip_addr & net_mask) == ip_addr ) ||   ( (ip_addr | ~net_mask) == ip_addr );
}


static bool IsValidNetworkConfig(const CipTcpIpInterfaceConfiguration *if_cfg) {
  if (INADDR_ANY == ntohl(if_cfg->ip_address) ) {  
    return false;
  }
  if (INADDR_ANY != ntohl(if_cfg->network_mask) &&   !IsValidNetmask(if_cfg->network_mask) ) {
    return false;
  }
  if (!IsInClassAbc(if_cfg->ip_address) ||         !IsInClassAbc(if_cfg->gateway) || !IsInClassAbc(if_cfg->name_server) || !IsInClassAbc(if_cfg->name_server_2) ) {


    return false;
  }
  if (IsOnLoopbackNetwork(if_cfg->ip_address) ||   IsOnLoopbackNetwork(if_cfg->gateway) ) {
    return false;
  }
  
  if (IsNetworkOrBroadcastIp(if_cfg->ip_address, if_cfg->network_mask) || (INADDR_ANY != ntohl(if_cfg->gateway) && IsNetworkOrBroadcastIp(if_cfg->gateway, if_cfg->network_mask) ) ) {

    return false;
  }
  if (INADDR_ANY != ntohl(if_cfg->gateway) && INADDR_ANY != ntohl(if_cfg->network_mask) ) {
    
    if ( (if_cfg->network_mask & if_cfg->ip_address) != (if_cfg->network_mask & if_cfg->gateway) ) {
      return false;
    }
  }
  return true;
}

static bool IsIOConnectionActive(void) {
  DoublyLinkedListNode *node = connection_list.first;

  while (NULL != node) {
    CipConnectionObject *connection = node->data;
    if (ConnectionObjectIsTypeIOConnection(connection) && kConnectionObjectStateTimedOut != ConnectionObjectGetState(connection) ) {

      
      return true;
    }
    node = node->next;
  }

  return false;
}



static CipUsint dummy_data_field = 0; 



void EncodeCipTcpIpInterfaceConfiguration(const void *const data, ENIPMessage *const outgoing_message)
{
  CipTcpIpInterfaceConfiguration * tcp_ip_network_interface_configuration = (CipTcpIpInterfaceConfiguration *) data;

  AddDintToMessage(ntohl(tcp_ip_network_interface_configuration->ip_address), outgoing_message);
  AddDintToMessage(ntohl(tcp_ip_network_interface_configuration->network_mask), outgoing_message);
  AddDintToMessage(ntohl(tcp_ip_network_interface_configuration->gateway), outgoing_message);
  AddDintToMessage(ntohl(tcp_ip_network_interface_configuration->name_server), outgoing_message);
  AddDintToMessage(ntohl(tcp_ip_network_interface_configuration->name_server_2), outgoing_message);
  EncodeCipString(&(tcp_ip_network_interface_configuration->domain_name), outgoing_message);
}

void EncodeCipTcpIpMulticastConfiguration(const void *const data, ENIPMessage *const outgoing_message) {
  EncodeCipUsint(&(g_tcpip.mcast_config.alloc_control), outgoing_message);
  EncodeCipUsint(&(g_tcpip.mcast_config.reserved_shall_be_zero), outgoing_message);
  EncodeCipUint(&(g_tcpip.mcast_config.number_of_allocated_multicast_addresses), outgoing_message);

  CipUdint multicast_address = ntohl( g_tcpip.mcast_config.starting_multicast_address);

  EncodeCipUdint(&multicast_address, outgoing_message);
}

void EncodeSafetyNetworkNumber(const void *const data, ENIPMessage *const outgoing_message) {
  FillNextNMessageOctetsWithValueAndMoveToNextPosition(0, 6, outgoing_message);
}

void EncodeCipLastConflictDetected(const void *const data, ENIPMessage *const outgoing_message) {
  const size_t kAttribute11Size = sizeof(CipUsint) + 6 * sizeof(CipUsint) + 28 * sizeof(CipUsint);
  OPENER_ASSERT(kAttribute11Size == 35);
  FillNextNMessageOctetsWithValueAndMoveToNextPosition(0, kAttribute11Size, outgoing_message);

}


int DecodeTcpIpInterfaceConfigurationControl(  CipDword *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {



	int number_of_decoded_bytes = -1;

	CipDword configuration_control_received = GetDintFromMessage( &(message_router_request->data));
	if ((configuration_control_received & kTcpipCfgCtrlMethodMask) >= 0x03 || (configuration_control_received & ~kTcpipCfgCtrlMethodMask)) {
		message_router_response->general_status = kCipErrorInvalidAttributeValue;

	} else {

		
		configuration_control_received &= (kTcpipCfgCtrlMethodMask | kTcpipCfgCtrlDnsEnable);

		*data = configuration_control_received;
		number_of_decoded_bytes = 4;
		message_router_response->general_status = kCipErrorSuccess;
	}

	return number_of_decoded_bytes;
}



int DecodeCipTcpIpInterfaceConfiguration(  CipTcpIpInterfaceConfiguration *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {



	int number_of_decoded_bytes = -1;

	CipTcpIpInterfaceConfiguration if_cfg;
	CipUdint tmp_ip;

	if (IsIOConnectionActive()) {
		message_router_response->general_status = kCipErrorDeviceStateConflict;
		return number_of_decoded_bytes;
	}
	if (kTcpipCfgCtrlStaticIp != (g_tcpip.config_control & kTcpipCfgCtrlMethodMask)) {
		message_router_response->general_status = kCipErrorObjectStateConflict;
		return number_of_decoded_bytes;
	}
	memset(&if_cfg, 0, sizeof if_cfg);
	tmp_ip = GetUdintFromMessage(&(message_router_request->data));
	if_cfg.ip_address = htonl(tmp_ip);
	tmp_ip = GetUdintFromMessage(&(message_router_request->data));
	if_cfg.network_mask = htonl(tmp_ip);
	tmp_ip = GetUdintFromMessage(&(message_router_request->data));
	if_cfg.gateway = htonl(tmp_ip);
	tmp_ip = GetUdintFromMessage(&(message_router_request->data));
	if_cfg.name_server = htonl(tmp_ip);
	tmp_ip = GetUdintFromMessage(&(message_router_request->data));
	if_cfg.name_server_2 = htonl(tmp_ip);

	CipUint domain_name_length = GetUintFromMessage( &(message_router_request->data));
	if (domain_name_length > 48) { 
		message_router_response->general_status = kCipErrorTooMuchData;
		return number_of_decoded_bytes;
	}
	SetCipStringByData(&if_cfg.domain_name, domain_name_length, message_router_request->data);
	domain_name_length = (domain_name_length + 1) & (~0x0001u); 
	OPENER_TRACE_INFO("Domain: ds %hu '%s'\n", domain_name_length, if_cfg.domain_name.string);


	if (!IsValidNetworkConfig(&if_cfg)
			|| (domain_name_length > 0 && !IsValidDomain(if_cfg.domain_name.string))) {
		message_router_response->general_status = kCipErrorInvalidAttributeValue;
		return number_of_decoded_bytes;
	}

	*data = if_cfg; 
	number_of_decoded_bytes = 20 + domain_name_length;

	
	g_tcpip.status |= kTcpipStatusIfaceCfgPend;
	message_router_response->general_status = kCipErrorSuccess;

	return number_of_decoded_bytes;

}

int DecodeCipTcpIpInterfaceHostName(  CipString *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {



	int number_of_decoded_bytes = -1;

	          CipString tmp_host_name = {
	            .length = 0u, .string = NULL };

	          CipUint host_name_length = GetUintFromMessage(&(message_router_request->data) );
	          if (host_name_length > 64) {  
	            message_router_response->general_status = kCipErrorTooMuchData;
	            return number_of_decoded_bytes;
	          }
	          SetCipStringByData(&tmp_host_name, host_name_length, message_router_request->data);

	          host_name_length = (host_name_length + 1) & (~0x0001u);  
	          OPENER_TRACE_INFO("Host Name: ds %hu '%s'\n", host_name_length, tmp_host_name.string);


	          if (!IsValidNameLabel(tmp_host_name.string) ) {
	            message_router_response->general_status = kCipErrorInvalidAttributeValue;
	            return number_of_decoded_bytes;
	          }

	          *data = tmp_host_name; 

	          
	          g_tcpip.status |= kTcpipStatusIfaceCfgPend;
	          message_router_response->general_status = kCipErrorSuccess;

	return number_of_decoded_bytes;

}



int DecodeCipTcpIpInterfaceEncapsulationInactivityTimeout(  CipUint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {



	int number_of_decoded_bytes = -1;

	CipUint inactivity_timeout_received = GetUintFromMessage( &(message_router_request->data));

	if (inactivity_timeout_received > 3600) {
		message_router_response->general_status = kCipErrorInvalidAttributeValue;
	} else {

		*data = inactivity_timeout_received;
		message_router_response->general_status = kCipErrorSuccess;
		number_of_decoded_bytes = 2;

	}

	return number_of_decoded_bytes;

}


EipStatus CipTcpIpInterfaceInit() {
  CipClass *tcp_ip_class = NULL;

  if ( ( tcp_ip_class = CreateCipClass(kCipTcpIpInterfaceClassCode,  0, 7, 2, 13, 13, 3, 1, "TCP/IP interface", 4, NULL ) ) == 0 ) {









    return kEipStatusError;
  }

  CipInstance *instance = GetCipInstance(tcp_ip_class, 1); 

  InsertAttribute(instance, 1, kCipDword, EncodeCipDword, NULL, &g_tcpip.status, kGetableSingleAndAll);





  InsertAttribute(instance, 2, kCipDword, EncodeCipDword, NULL, &g_tcpip.config_capability, kGetableSingleAndAll);





  InsertAttribute(instance, 3, kCipDword, EncodeCipDword, DecodeTcpIpInterfaceConfigurationControl, &g_tcpip.config_control, kSetAndGetAble | kNvDataFunc | IFACE_CFG_SET_MODE );





  InsertAttribute(instance, 4, kCipEpath, EncodeCipEPath, NULL, &g_tcpip.physical_link_object, kGetableSingleAndAll);







  InsertAttribute(instance, 5, kCipUdintUdintUdintUdintUdintString, EncodeCipTcpIpInterfaceConfiguration, DecodeCipTcpIpInterfaceConfiguration, &g_tcpip.interface_configuration, kGetableSingleAndAll | kNvDataFunc | IFACE_CFG_SET_MODE);





  InsertAttribute(instance, 6, kCipString, EncodeCipString, DecodeCipTcpIpInterfaceHostName, &g_tcpip.hostname, kGetableSingleAndAll | kNvDataFunc | IFACE_CFG_SET_MODE);







  InsertAttribute(instance, 5, kCipUdintUdintUdintUdintUdintString, EncodeCipTcpIpInterfaceConfiguration, NULL, &g_tcpip.interface_configuration, kGetableSingleAndAll | kNvDataFunc | IFACE_CFG_SET_MODE);





    InsertAttribute(instance, 6, kCipString, EncodeCipString, NULL, &g_tcpip.hostname, kGetableSingleAndAll | kNvDataFunc | IFACE_CFG_SET_MODE);








  InsertAttribute(instance, 7, kCipAny, EncodeSafetyNetworkNumber, NULL, &dummy_data_field, kGetableAllDummy);





  InsertAttribute(instance, 8, kCipUsint, EncodeCipUsint, NULL, &g_tcpip.mcast_ttl_value, kGetableSingleAndAll);





  InsertAttribute(instance, 9, kCipAny, EncodeCipTcpIpMulticastConfiguration, NULL, &g_tcpip.mcast_config, kGetableSingleAndAll);





  InsertAttribute(instance, 10, kCipBool, EncodeCipBool, NULL, &g_tcpip.select_acd, kGetableAllDummy);





  InsertAttribute(instance, 11, kCipBool, EncodeCipLastConflictDetected, NULL, &dummy_data_field, kGetableAllDummy);





  InsertAttribute(instance, 12, kCipBool, EncodeCipBool, NULL, &dummy_data_field, kGetableAllDummy);




  InsertAttribute(instance, 13, kCipUint, EncodeCipUint, DecodeCipTcpIpInterfaceEncapsulationInactivityTimeout, &g_tcpip.encapsulation_inactivity_timeout, kSetAndGetAble | kNvDataFunc);






  InsertService(tcp_ip_class, kGetAttributeSingle, &GetAttributeSingle, "GetAttributeSingle");


  InsertService(tcp_ip_class, kGetAttributeAll, &GetAttributeAll, "GetAttributeAll");

  InsertService(tcp_ip_class, kSetAttributeSingle, &SetAttributeSingle, "SetAttributeSingle");


  return kEipStatusOk;
}

void ShutdownTcpIpInterface(void) {
  
  if (NULL != g_tcpip.hostname.string) {
    CipFree(g_tcpip.hostname.string);
    g_tcpip.hostname.string = NULL;
  }

  if (NULL != g_tcpip.interface_configuration.domain_name.string) {
    CipFree(g_tcpip.interface_configuration.domain_name.string);
    g_tcpip.interface_configuration.domain_name.string = NULL;
  }
}


void CipTcpIpCalculateMulticastIp(CipTcpIpObject *const tcpip) {
  
  static const CipUdint cip_mcast_base_addr = 0xEFC00100;

  
  CipUdint host_id = ntohl(tcpip->interface_configuration.ip_address) & ~ntohl(tcpip->interface_configuration.network_mask);
  host_id -= 1;
  host_id &= 0x3ff;

  tcpip->mcast_config.starting_multicast_address = htonl(cip_mcast_base_addr + (host_id << 5) );
}


EipUint16 GetEncapsulationInactivityTimeout(CipInstance *instance) {
  CipAttributeStruct *attribute = GetCipAttribute(instance, 13);
  OPENER_ASSERT(NULL != attribute);
  CipUint *data = (CipUint *) attribute->data;
  EipUint16 encapsulation_inactivity_timeout = *data;
  return encapsulation_inactivity_timeout;
}

