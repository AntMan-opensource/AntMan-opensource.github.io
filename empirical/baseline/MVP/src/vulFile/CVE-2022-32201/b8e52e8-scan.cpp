




























Scan::Scan(class Frame *frame)
  : JKeeper(frame->EnvironOf()), m_pNext(NULL), m_pFrame(frame), m_pParser(NULL), m_pHuffman(NULL), m_pConditioner(NULL), m_bHidden(false)
{
  m_ucScanIndex = 0;
  
  for(int i = 0;i < 4;i++) {
    m_pComponent[i]     = NULL;
    m_ucMappingTable[i] = 0;
  }
  
}



Scan::~Scan(void)
{
  delete m_pParser;
  delete m_pHuffman;
  delete m_pConditioner;
}



void Scan::WriteMarker(class ByteStream *io)
{ 
  bool jpegls = (m_pFrame->ScanTypeOf() == JPEG_LS);
  UWORD len   = m_ucCount * 2 + 6; 
  int i;

  
  
  if (m_pHuffman && m_pHuffman->isEmpty() == false) {
    io->PutWord(0xffc4); 
    m_pHuffman->WriteMarker(io);
  }

  if (m_pConditioner) {
    io->PutWord(0xffcc);
    m_pConditioner->WriteMarker(io);
  }
  
  io->PutWord(0xffda); 

  
  io->PutWord(len);

  
  io->Put(m_ucCount);

  for(i = 0;i < m_ucCount;i++) {
    io->Put(m_ucComponent[i]);
    
    
    assert(m_ucDCTable[i] < 16);
    assert(m_ucACTable[i] < 16);
    
    if (jpegls) {
      io->Put(m_ucMappingTable[i]);
    } else {
      io->Put((m_ucDCTable[i] << 4) | m_ucACTable[i]);
    }
  }
  
  io->Put(m_ucScanStart);
  io->Put(m_ucScanStop);
  
  assert(m_ucHighBit < 16);
  assert(m_ucLowBit  < 16);

  io->Put((m_ucHighBit << 4) | m_ucLowBit);
}






void Scan::ParseMarker(class ByteStream *io)
{
  
  Scan::ParseMarker(io,m_pFrame->ScanTypeOf());
}





void Scan::ParseMarker(class ByteStream *io,ScanType type)
{
  LONG len = io->GetWord();
  LONG data;
  int i,j;

  if (len < 8)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","marker length of the SOS marker invalid, must be at least 8 bytes long");

  data = io->Get();
  if (data < 1 || data > 4)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","number of components in scan is invalid, must be between 1 and 4");

  m_ucCount = data;

  if (len != m_ucCount * 2 + 6)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","length of the SOS marker is invalid");

  for(i = 0;i < m_ucCount;i++) {
    data = io->Get(); 
    if (data == ByteStream::EOF)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS marker run out of data");

    m_ucComponent[i] = data;
    for(j = 0;j < i;j++) {
      if (m_ucComponent[j] == data)
        JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS includes the same component twice");
    }
    
    data = io->Get(); 
    if (data == ByteStream::EOF)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS marker run out of data");

    if (m_pFrame->ScanTypeOf() != JPEG_LS) {
      m_ucDCTable[i] = data >> 4;
      m_ucACTable[i] = data & 0x0f;
      
      if (m_ucDCTable[i] > 3)
        JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","DC table index in SOS marker is out of range, must be at most 4");
      
      if (m_ucACTable[i] > 3)
        JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","AC table index in SOS marker is out of range, must be at most 4");
    } else {
      m_ucMappingTable[i] = data; 
      
      m_ucDCTable[i]      = (i == 0)?(0):(1);
      m_ucACTable[i]      = (i == 0)?(0):(1);
    }
  }

  
  data = io->Get();
  if (data == ByteStream::EOF)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS marker run out of data");
  if (data > 63 && m_pFrame->ScanTypeOf() != JPEG_LS)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","start of scan index is out of range, must be between 0 and 63");
  m_ucScanStart = data;
  
  
  
  data = io->Get();
  if (data == ByteStream::EOF)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS marker run out of data");
  if (m_pFrame->ScanTypeOf() != JPEG_LS) {
    if (data > 63)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","end of scan index is out of range, must be between 0 and 63");
  } else {
    if (data > 2)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","interleave specification is out of range, must be between 0 and 2"); 
  }
  m_ucScanStop = data;
  
  data = io->Get();
  if (data == ByteStream::EOF)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS marker run out of data");

  m_ucHighBit    = data >> 4;
  m_ucLowBit     = data & 0x0f;
  m_ucHiddenBits = m_pFrame->TablesOf()->HiddenDCTBitsOf();

  if (m_ucHighBit > 13)
    JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","SOS high bit approximation is out of range, must be < 13");

  switch(type) {
  case Progressive:
  case ACProgressive:
  case DifferentialProgressive:
  case ACDifferentialProgressive:
    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "SOS high bit is invalid, successive approximation must refine by one bit per scan");
    if (m_ucScanStop < m_ucScanStart)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","end of scan is lower than start of scan");
    if (m_ucScanStart == 0 && m_ucScanStop != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","DC component must be in a separate scan in the progressive mode");
    if (m_ucScanStart && m_ucCount != 1)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","AC scans in progressive mode must only contain a single component");
    break;
  case Residual:
  case ACResidual:
  case ResidualProgressive:
  case ACResidualProgressive:
  case ResidualDCT:
  case ACResidualDCT:
    if (m_ucHighBit && m_ucHighBit != m_ucLowBit + 1)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "SOS high bit is invalid, successive approximation must refine by one bit per scan");
    if (m_ucScanStop < m_ucScanStart)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker","end of scan is lower than start of scan");
    break;
  case Baseline:
  case Sequential:
  case ACSequential:
  case DifferentialSequential:
  case ACDifferentialSequential:
    if (m_ucScanStop != 63 || m_ucScanStart != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "scan start must be zero and scan stop must be 63 for the sequential operating modes");
    
  case JPEG_LS: 
    
    if (m_ucHighBit != 0) 
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "successive approximation parameters must be zero for the sequential operating modes");
    break;
  case Lossless:
  case ACLossless:
    if (m_ucScanStart == 0 || m_ucScanStop > 7) 
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "predictor for the lossless mode must be between 1 and 7");
    if (m_ucScanStop != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "scan stop parameter must be zero in the lossless mode");
    if (m_ucHighBit != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "successive approximation high bit parameter must be zero for the lossless mode");
    break;
  case DifferentialLossless:
  case ACDifferentialLossless:
    if (m_ucScanStart != 0) 
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "predictor for the differential lossless mode must be zero");
    if (m_ucScanStop != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "scan stop parameter must be zero in the lossless mode");
    if (m_ucHighBit != 0)
      JPG_THROW(MALFORMED_STREAM,"Scan::ParseMarker", "successive approximation high bit parameter must be zero for the lossless mode");
    break;
  default:
    break;
  }
}




class Component *Scan::ComponentOf(UBYTE i)
{
  assert(i < 4);

  if (m_pComponent[i] == NULL)
    m_pComponent[i] = m_pFrame->FindComponent(m_ucComponent[i]);

  return m_pComponent[i];
}






void Scan::CreateParser(void)
{
  ScanType type = m_pFrame->ScanTypeOf();
  
  assert(m_pParser == NULL);
  
  switch(type) {
  case Baseline:
    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, false,false,false,true);



    break;
  case Sequential:
    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    break;
  case DifferentialSequential:
    m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits,true);


    break;
  case Lossless:
    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,m_ucScanStart, m_ucLowBit + m_ucHiddenBits);
    break;
  case DifferentialLossless:
    m_pParser = new(m_pEnviron) class LosslessScan(m_pFrame,this,0, m_ucLowBit + m_ucHiddenBits,true);
    break;
  case ACLossless:
    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,m_ucScanStart, m_ucLowBit + m_ucHiddenBits);
    break;
  case ACDifferentialLossless:
    m_pParser = new(m_pEnviron) class ACLosslessScan(m_pFrame,this,0, m_ucLowBit + m_ucHiddenBits,true);
    break;
  case ACSequential:
    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    break;
  case ACDifferentialSequential:
    m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits,true);


    break;
  case Progressive:
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    } else { 
      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    }
    break;
  case ResidualProgressive:
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true,true);



    } else { 
      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true,true);



    }
    break;
  case DifferentialProgressive:
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits,true);


    } else { 
      
      
      m_pParser = new(m_pEnviron) class RefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits,true);


    }
    break;
  case ACProgressive: 
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    } else { 
      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits);


    }
    break;
  case ACDifferentialProgressive: 
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true);



    } else { 
      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true);



    }
    break;
  case ACResidualProgressive:  
    if (m_ucHighBit == 0) { 
      m_pParser = new(m_pEnviron) class ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, false,true);



    } else { 
      m_pParser = new(m_pEnviron) class ACRefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, false,true);



    }
    break;
  case Residual:
    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true,true);



    break;
  case ACResidual:
    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, true,true);



    break;
  case ResidualDCT:
    m_pParser = new(m_pEnviron) SequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, false,false,true);



    break; 
  case ACResidualDCT:
    m_pParser = new(m_pEnviron) ACSequentialScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit + m_ucHiddenBits, m_ucHighBit + m_ucHiddenBits, false,false,true);



    break;
  case JPEG_LS:
    
    switch(m_ucScanStop) {
    case 0:
      if (m_ucCount != 1)
        JPG_THROW(MALFORMED_STREAM,"Scan::CreateParser", "invalid codestream, found a single comonent scan containing more than one component");
      m_pParser = new(m_pEnviron) class SingleComponentLSScan(m_pFrame,this, m_ucScanStart, m_ucMappingTable, m_ucLowBit + m_ucHiddenBits);


      break;
    case 1:
      m_pParser = new(m_pEnviron) class LineInterleavedLSScan(m_pFrame,this, m_ucScanStart, m_ucMappingTable, m_ucLowBit + m_ucHiddenBits);


      break;
    case 2:
      m_pParser = new(m_pEnviron) class SampleInterleavedLSScan(m_pFrame,this, m_ucScanStart, m_ucMappingTable, m_ucLowBit + m_ucHiddenBits);


      break;
    }
    break;
  default:
    JPG_THROW(NOT_IMPLEMENTED,"Scan::CreateParser", "sorry, the coding mode in the codestream is currently not supported");
  }
}




void Scan::InstallDefaults(UBYTE depth,ULONG tagoffset,const struct JPG_TagItem *tags)
{
  bool ishuffman    = false;
  bool ispredictive = false;
  bool isjpegls     = false;
  bool colortrafo   = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());
  ScanType type     = m_pFrame->ScanTypeOf();

  assert(m_pParser == NULL);
  
  switch(type) {
  case Baseline:
  case Sequential:
  case Progressive:
  case DifferentialSequential:
  case DifferentialProgressive:
  case Residual:
  case ResidualProgressive:
  case ResidualDCT:
    ishuffman    = true;
    break;
  case Lossless:
  case DifferentialLossless:
    ishuffman    = true;
    ispredictive = true;
    break;
  case ACSequential:
  case ACProgressive:
  case ACDifferentialSequential:
  case ACDifferentialProgressive:
  case ACResidual:
  case ACResidualProgressive:
  case ACResidualDCT:
    break;
  case ACLossless:
  case ACDifferentialLossless:
    ispredictive = true;
    break;
  case JPEG_LS:
    ispredictive = true;
    isjpegls     = true;
    break;
  default:
    JPG_THROW(NOT_IMPLEMENTED,"Scan::InstallDefaults", "sorry, unknown frame type, not yet implemented");
  }

  if (depth < 1 || depth > 4)
    JPG_THROW(OVERFLOW_PARAMETER,"Scan::InstallDefaults", "JPEG allows only between one and four components per scan");

  m_ucCount = depth;
  
  if (isjpegls) {
    
  } else if (ishuffman) {
    m_pHuffman     = new(m_pEnviron) HuffmanTable(m_pEnviron);
  } else {
    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);
  }
  
  switch(type) {
  case Progressive:
  case ACProgressive:
  case DifferentialProgressive:
  case ACDifferentialProgressive:
    m_ucScanStart = 0;
    m_ucScanStop  = 0; 
    m_ucHighBit   = 0;
    m_ucLowBit    = 0; 
    break;
  case Baseline:
  case Sequential: 
  case ACSequential:
  case DifferentialSequential:
  case ACDifferentialSequential:
  case Residual:
  case ACResidual:
  case ResidualProgressive:
  case ACResidualProgressive:
  case ResidualDCT:
  case ACResidualDCT:
    
    m_ucScanStart = 0;
    m_ucScanStop  = 63;
    m_ucHighBit   = 0;
    m_ucLowBit    = 0; 
    break;
  case Lossless:
  case ACLossless:
    m_ucScanStart = 4; 
    m_ucScanStop  = 0; 
    m_ucHighBit   = 0; 
    m_ucLowBit    = 0; 
    break;
  case DifferentialLossless:
  case ACDifferentialLossless:
    m_ucScanStart = 0; 
    m_ucScanStop  = 0; 
    m_ucHighBit   = 0; 
    m_ucLowBit    = 0; 
    break;
  case JPEG_LS:
    m_ucScanStart = 0; 
    m_ucScanStop  = 0; 
    m_ucHighBit   = 0; 
    m_ucLowBit    = 0; 
    break;
  default:
    assert(!"unimplemented scan type");
    break;
  }
  
  
  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0            ,0);
  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1            ,1);
  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2            ,2);  
  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3            ,3);
  m_ucComponent[0] = tags->GetTagData(JPGTAG_SCAN_COMPONENT0 + tagoffset,m_ucComponent[0]);
  m_ucComponent[1] = tags->GetTagData(JPGTAG_SCAN_COMPONENT1 + tagoffset,m_ucComponent[1]);
  m_ucComponent[2] = tags->GetTagData(JPGTAG_SCAN_COMPONENT2 + tagoffset,m_ucComponent[2]);  
  m_ucComponent[3] = tags->GetTagData(JPGTAG_SCAN_COMPONENT3 + tagoffset,m_ucComponent[3]);
  m_ucHiddenBits   = m_pFrame->TablesOf()->HiddenDCTBitsOf();
  
  
  
  for(UBYTE i = 0;i < depth;i++) {
    UBYTE c = m_ucComponent[i]; 

    if ( colortrafo) {
      m_ucDCTable[i] = (c == 0)?(0):(1);
    } else {
      m_ucDCTable[i] = 0;
    }
    
    
    if ( !ispredictive && colortrafo) {
      m_ucACTable[i] = (c == 0)?(0):(1);
    } else {
      m_ucACTable[i] = 0;
    }
  } 
  
  
  switch(type) {
  case Progressive:
  case ACProgressive:
  case DifferentialProgressive:
  case ACDifferentialProgressive:
  case ResidualProgressive:
  case ACResidualProgressive:
    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START            ,m_ucScanStart);
    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP             ,m_ucScanStop);    
    m_ucScanStart    = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_START + tagoffset,m_ucScanStart);
    m_ucScanStop     = tags->GetTagData(JPGTAG_SCAN_SPECTRUM_STOP  + tagoffset,m_ucScanStop);
    
    if (type != ResidualProgressive && type != ACResidualProgressive) {
      if (m_ucScanStart == 0 && m_ucScanStop)
        JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "DC coefficients must be in a separate scan in the progressive mode");
      if (m_ucScanStart && m_ucScanStop < m_ucScanStart)
        JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "Spectral selection stop must be larger or equal than spectral selection start");
      if (m_ucScanStart && m_ucCount > 1)
        JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "In the progressive mode, the AC components must be coded in all separate scans");
    } else {
      if (m_ucScanStop < m_ucScanStart)
        JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "Spectral selection stop must be larger or equal than spectral selection start");
    }
    if (m_ucScanStop >= 64)
      JPG_THROW(OVERFLOW_PARAMETER,"Scan::InstallDefaults", "Spectral selection stop is out of range, must be <= 63");

    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI            ,m_ucHighBit);
    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO            ,m_ucLowBit);
    m_ucHighBit      = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_HI + tagoffset,m_ucHighBit);
    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_APPROXIMATION_LO + tagoffset,m_ucLowBit);
    if (m_ucHighBit > 0 && m_ucHighBit != m_ucLowBit + 1)
      JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "Successive approximation refinement must include only a single bitplane");
    
    break;
  case JPEG_LS:
    
    m_ucScanStart = tags->GetTagData(JPGTAG_IMAGE_ERRORBOUND,0);
    switch(tags->GetTagData(JPGTAG_SCAN_LS_INTERLEAVING)) {
    case JPGFLAG_SCAN_LS_INTERLEAVING_NONE:
      m_ucScanStop = 0;
      break;
    case JPGFLAG_SCAN_LS_INTERLEAVING_LINE:
      m_ucScanStop = 1;
      break;
    case JPGFLAG_SCAN_LS_INTERLEAVING_SAMPLE:
      m_ucScanStop = 2;
      break;
     default:
      JPG_THROW(INVALID_PARAMETER,"Scan::InstallDefaults", "Invalid component interleaving mode for JPEG LS scans");
      break;
    }
    
  case Lossless:
  case ACLossless:
  case DifferentialLossless:
  case ACDifferentialLossless:
    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM            ,m_ucLowBit);
    m_ucLowBit       = tags->GetTagData(JPGTAG_SCAN_POINTTRANSFORM + tagoffset,m_ucLowBit);
    if (m_ucLowBit >= m_pFrame->PrecisionOf())
      JPG_THROW(OVERFLOW_PARAMETER,"Scan::InstallDefaults", "Point transformation removes more bits than available in the source data");
  default:
    break;
  }

  if (m_pParser)
    JPG_THROW(OBJECT_EXISTS,"Scan::CompleteSettings", "Settings are already installed and active");
  
  CreateParser();
}





void Scan::MakeHiddenRefinementScan(UBYTE bitposition,class Component *comp,UBYTE start,UBYTE stop)
{
  bool colortrafo = m_pFrame->TablesOf()->hasSeparateChroma(m_pFrame->DepthOf());
  bool residual   = false; 
  
  assert(m_pParser == NULL);

  
  if (m_pFrame->DepthOf() > 4)
    JPG_THROW(INVALID_PARAMETER,"Scan::MakeHiddenRefinementScan", "hidden refinement scans are confined to four components at most");

  m_ucScanStart    = start;
  m_ucScanStop     = stop; 
  m_ucLowBit       = bitposition;
  m_ucHighBit      = bitposition+1;
  m_ucHiddenBits   = 0; 
  m_bHidden        = true;

  switch(m_pFrame->ScanTypeOf()) { 
  case Residual:
  case ACResidual:
  case ResidualProgressive: 
  case ACResidualProgressive:
    
    assert(stop >= start);
      
    m_ucCount        = 1;
    m_ucComponent[0] = comp->IDOf();
    break;
  default:
    if (start == 0) {
      UBYTE i;
      
      assert(stop == 0); 
      
      m_ucCount        = m_pFrame->DepthOf();
      for(i = 0;i < m_ucCount;i++) {
        m_ucComponent[i] = m_pFrame->ComponentOf(i)->IDOf();
        m_ucDCTable[i]   = 0;
        m_ucACTable[i]   = 0; 
      }
    } else {
      
      assert(stop >= start);
      
      m_ucCount        = 1;
      m_ucComponent[0] = comp->IDOf();
    }
    break;
  }
  
  switch(m_pFrame->ScanTypeOf()) {
  case Baseline:
  case Sequential:
  case Progressive:
    if (colortrafo) {
      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; 
    } else {
      m_ucACTable[0] = 0;
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; 
    }
    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);
    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this, start,stop, bitposition,bitposition+1, false,false);


    break;
  case ACSequential:
  case ACProgressive:

    m_ucACTable[0] = 0;
    m_ucDCTable[0] = 0;
    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);
    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this, start,stop, bitposition,bitposition+1, false,false);



    JPG_THROW(NOT_IMPLEMENTED," Scan::MakeHiddenRefinementScan", "Arithmetic coding option not available in your code release, please contact Accusoft for a full version");

    break;
  case Residual:
  case ResidualProgressive:
    residual = true;
    
  case ResidualDCT:
    if (colortrafo) {
      m_ucACTable[0] = (comp && comp->IndexOf() == 0)?(0):(1);  
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 1; 
    } else {
      m_ucACTable[0] = 0;
      m_ucDCTable[0] = 0;
      m_ucDCTable[1] = m_ucDCTable[2] = m_ucDCTable[3] = 0; 
    }
    assert(residual == false || (start == 0 && stop == 63));
    m_pHuffman = new(m_pEnviron) HuffmanTable(m_pEnviron);
    m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this, start,stop, bitposition,bitposition+1, false,residual);


    break;
  case ACResidual:
  case ACResidualProgressive:
    residual = true;
    
  case ACResidualDCT:

    m_ucACTable[0] = 0;
    m_ucDCTable[0] = 0;
    assert(residual == false || (start == 0 && stop == 63));
    m_pConditioner = new(m_pEnviron) ACTable(m_pEnviron);
    m_pParser      = new(m_pEnviron) ACRefinementScan(m_pFrame,this, start,stop, bitposition,bitposition+1, false,residual);



    JPG_THROW(NOT_IMPLEMENTED," Scan::MakeHiddenRefinementScan", "Arithmetic coding option not available in your code release, please contact Accusoft for a full version");

    break;
  default:
    JPG_THROW(INVALID_PARAMETER,"Scan::MakeHiddenRefinementScan", "frame type does not support hidden refinement scans");
    break;
  }
}




void Scan::StartParseHiddenRefinementScan(class ByteStream *io,class BufferCtrl *ctrl)
{
  m_bHidden = true;
  bool residual = false;

  if (m_pParser == NULL) {
    ScanType type = m_pFrame->ScanTypeOf();
    
    switch(type) {
    case Baseline:
    case Sequential: 
    case Progressive:
      ParseMarker(io,Progressive);
      m_pParser = new(m_pEnviron) RefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit,m_ucHighBit, false,false);


      break;
    case ACSequential:
    case ACProgressive:

      ParseMarker(io,ACProgressive);
      m_pParser = new(m_pEnviron) ACRefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit,m_ucHighBit, false,false);



      JPG_THROW(NOT_IMPLEMENTED,"Scan::StartParseHiddenRefinementScan", "Arithmetic coding option not available in your code release, please contact Accusoft for a full version");

      break; 
    case Residual:
    case ResidualProgressive:
      residual = true;
      
    case ResidualDCT:
      ParseMarker(io,ResidualProgressive);
      m_pParser  = new(m_pEnviron) RefinementScan(m_pFrame,this, m_ucScanStart,m_ucScanStop, m_ucLowBit,m_ucHighBit, false,residual);


      break;
    case ACResidual:
    case ACResidualProgressive:
      residual = true;
      
    case ACResidualDCT:

      ParseMarker(io,ACResidualProgressive);
      m_pParser  = new(m_pEnviron) ACRefinementScan(m_pFrame,this,  m_ucScanStart,m_ucScanStop, m_ucLowBit,m_ucHighBit, false,true);



      JPG_THROW(NOT_IMPLEMENTED," Scan::MakeHiddenRefinementScan", "Arithmetic coding option not available in your code release, " "please contact Accusoft for a full version");


      break; 
    default:
      JPG_THROW(NOT_IMPLEMENTED,"Scan::StartParseHiddenRefinementScan", "sorry, the coding mode in the codestream is currently not supported");
    }
  } 

  ctrl->PrepareForDecoding();
  m_pParser->StartParseScan(io,NULL,ctrl);
}




void Scan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)
{
  
  
  if (m_pParser == NULL)
    CreateParser();
  
  ctrl->PrepareForDecoding();
  m_pParser->StartParseScan(io,chk,ctrl);
}




void Scan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)
{
  assert(m_pParser);

  if (m_pHuffman)
    m_pHuffman->AdjustToStatistics();
  
  ctrl->PrepareForEncoding();
  m_pParser->StartWriteScan(io,chk,ctrl);
}





void Scan::StartMeasureScan(class BufferCtrl *ctrl)
{
  assert(m_pParser);

  ctrl->PrepareForEncoding();
  m_pParser->StartMeasureScan(ctrl);
}




void Scan::StartOptimizeScan(class BufferCtrl *ctrl)
{
  assert(m_pParser);
  
  ctrl->PrepareForEncoding();
  m_pParser->StartOptimizeScan(ctrl);
}




bool Scan::StartMCURow(void)
{
  assert(m_pParser);

  return m_pParser->StartMCURow();
}




bool Scan::ParseMCU(void)
{
  assert(m_pParser);

  return m_pParser->ParseMCU();
}




bool Scan::WriteMCU(void)
{
  assert(m_pParser);

  return m_pParser->WriteMCU();
}





void Scan::WriteFrameType(class ByteStream *io)
{
  assert(m_pParser);

  
  
  if (m_bHidden) {
    assert(m_pNext);
    m_pNext->WriteFrameType(io);
  } else {
    m_pParser->WriteFrameType(io);
  }
}




void Scan::Flush(void)
{
  if (m_pParser)
    m_pParser->Flush(true);
}




class Thresholds *Scan::FindThresholds(void) const {
  return m_pFrame->TablesOf()->ThresholdsOf();
}





class HuffmanDecoder *Scan::DCHuffmanDecoderOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf();

  assert(idx < 4);
  
  t = m_pFrame->TablesOf()->FindDCHuffmanTable(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  if (t == NULL)
    JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::DCHuffmanDecoderOf","requested DC Huffman coding table not defined");

  return t->DecoderOf();
}





class HuffmanDecoder *Scan::ACHuffmanDecoderOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf();

  assert(idx < 4);

  t = m_pFrame->TablesOf()->FindACHuffmanTable(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  if (t == NULL)
    JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::ACHuffmanDecoderOf","requested AC Huffman coding table not defined");

  return t->DecoderOf();  
}




class HuffmanCoder *Scan::DCHuffmanCoderOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf();

  assert(idx < 4);

  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  if (t == NULL)
      JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::DCHuffmanCoderOf","requested DC Huffman coding table not defined");

  t->AdjustToStatistics();
  
  return t->EncoderOf();
}




class HuffmanCoder *Scan::ACHuffmanCoderOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf();
  
  assert(idx < 4);

  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  if (t == NULL)
      JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::ACHuffmanCoderOf","requested AC Huffman coding table not defined");

  t->AdjustToStatistics();
  
  return t->EncoderOf();
}




class HuffmanStatistics *Scan::DCHuffmanStatisticsOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf(); 
 
  assert(idx < 4);

  t = m_pHuffman->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  if (t == NULL)
      JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::DCHuffmanStatisticsOf","requested DC Huffman coding table not defined");

  return t->StatisticsOf(true);
}




class HuffmanStatistics *Scan::ACHuffmanStatisticsOf(UBYTE idx) const {
  class HuffmanTemplate *t;
  ScanType sc = m_pFrame->ScanTypeOf(); 

  assert(idx < 4);

  t = m_pHuffman->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  
  if (t == NULL)
      JPG_THROW(OBJECT_DOESNT_EXIST,"Scan::ACHuffmanStatisticsOf","requested AC Huffman coding table not defined");

  return t->StatisticsOf(false);
}





class ACTemplate *Scan::DCConditionerOf(UBYTE idx) const {
  ScanType sc = m_pFrame->ScanTypeOf();
  assert(idx < 4);

  if (m_pConditioner) {
    return m_pConditioner->DCTemplateOf(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  }

  return m_pFrame->TablesOf()->FindDCConditioner(m_ucDCTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
}




class ACTemplate *Scan::ACConditionerOf(UBYTE idx) const {
  ScanType sc = m_pFrame->ScanTypeOf();
  assert(idx < 4);

  if (m_pConditioner) {
    return m_pConditioner->ACTemplateOf(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
  }

  return m_pFrame->TablesOf()->FindACConditioner(m_ucACTable[idx],sc,m_pFrame->PrecisionOf(), m_pFrame->HiddenPrecisionOf(),m_ucScanIndex);
}







void Scan::OptimizeDCTBlock(LONG bx,LONG by,UBYTE compidx,DOUBLE lambda, class DCT *dct,LONG quantized[64])
{
  UBYTE i;

  assert(m_pParser);

  for(i = 0;i < m_ucCount;i++) {
    if (m_pComponent[i] && m_pComponent[i]->IndexOf() == compidx) {
      m_pParser->OptimizeBlock(bx,by,i,lambda,dct,quantized);
      break;
    }
  }
}






void Scan::OptimizeDC(void)
{
  assert(m_pParser);

  m_pParser->OptimizeDC();
}

