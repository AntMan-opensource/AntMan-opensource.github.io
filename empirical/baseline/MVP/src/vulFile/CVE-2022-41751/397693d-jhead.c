













    #include <io.h>



















static int DoModify  = FALSE;


static int FilesMatched;
static int FileSequence;

static const char * CurrentFile;

static const char * progname;   



static int TrimExif = FALSE;        
static int RenameToDate = 0;        

static int RenameAssociatedFiles = FALSE;

static char * strftime_args = NULL; 
static int Exif2FileTime  = FALSE;
       int ShowTags     = FALSE;    
static int Quiet        = FALSE;    
       int DumpExifMap  = FALSE;
static int ShowConcise  = FALSE;
static int CreateExifSection = FALSE;
static int TrimExifTrailingZeroes = FALSE;
static char * ApplyCommand = NULL;  
static char * FilterModel = NULL;
static int    FilterQuality = 0;
static int    ExifOnly    = FALSE;  
static int    ProcessOnly = -1;     
static int    PortraitOnly = FALSE; 
static time_t ExifTimeAdjust = 0;   
static time_t ExifTimeSet = 0;      
static char DateSet[11];
static unsigned DateSetChars = 0;
static unsigned FileTimeToExif = FALSE;

static int DeleteComments = FALSE;
static int DeleteExif = FALSE;
static int DeleteIptc = FALSE;
static int DeleteXmp = FALSE;
static int DeleteUnknown = FALSE;
static char * ThumbSaveName = NULL; 
                                    

static char * ThumbInsertName = NULL; 
                                    

static int RegenThumbnail = FALSE;

static char * ExifXferScrFile = NULL;
                                    

static int EditComment = FALSE;     
static int SuppressNonFatalErrors = FALSE; 

static char * CommentSavefileName = NULL; 
static char * CommentInsertfileName = NULL; 
static char * CommentInsertLiteral = NULL;  

static int AutoRotate = FALSE;
static int ZeroRotateTagOnly = FALSE;

static int ShowFileInfo = TRUE;     
                                    



    
    
    

    static char * AddComment = NULL; 
    static char * RemComment = NULL; 
    static int AutoResize = FALSE;





void ErrFatal(const char * msg)
{
    fprintf(stderr,"\nError : %s\n", msg);
    if (CurrentFile) fprintf(stderr,"in file '%s'\n",CurrentFile);
    exit(EXIT_FAILURE);
}





void ErrNonfatal(const char * msg, int a1, int a2)
{
    if (SuppressNonFatalErrors) return;

    fprintf(stderr,"\nNonfatal Error : ");
    if (CurrentFile) fprintf(stderr,"'%s' ",CurrentFile);
    fprintf(stderr, msg, a1, a2);
    fprintf(stderr, "\n");
}





static int FileEditComment(char * TempFileName, char * Comment, int CommentSize)
{
    FILE * file;
    int a;
    char QuotedPath[PATH_MAX+10];

    file = fopen(TempFileName, "w");
    if (file == NULL){
        fprintf(stderr, "Can't create file '%s'\n",TempFileName);
        ErrFatal("could not create temporary file");
    }
    fwrite(Comment, CommentSize, 1, file);

    fclose(file);

    fflush(stdout); 

    {
        char * Editor;
        Editor = getenv("EDITOR");
        if (Editor == NULL){

            Editor = "notepad";

            Editor = "vi";

        }
        if (strlen(Editor) > PATH_MAX) ErrFatal("env too long");

        sprintf(QuotedPath, "%s \"%s\"",Editor, TempFileName);
        a = system(QuotedPath);
    }

    if (a != 0){
        perror("Editor failed to launch");
        exit(-1);
    }

    file = fopen(TempFileName, "r");
    if (file == NULL){
        ErrFatal("could not open temp file for read");
    }

    
    CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, file);

    fclose(file);

    unlink(TempFileName);

    return CommentSize;
}






static char KnownTags[][10] = {"date", "desc","scan_date","author", "keyword","videograb", "show_raw","panorama","titlepix","";


static int ModifyDescriptComment(char * OutComment, char * SrcComment)
{
    char Line[500];
    int Len;
    int a,i;
    unsigned l;
    int HasScandate = FALSE;
    int TagExists = FALSE;
    int Modified = FALSE;
    Len = 0;

    OutComment[0] = 0;


    for (i=0;;i++){
        if (SrcComment[i] == '\r' || SrcComment[i] == '\n' || SrcComment[i] == 0 || Len >= 199){
            
            if (Len > 0){
                Line[Len] = 0;
                
                for (a=0;;a++){
                    l = strlen(KnownTags[a]);
                    if (!l){
                        
                        printf("Error: Unknown tag '%s'\n", Line); 
                        Modified = TRUE;
                        break;
                    }
                    if (memcmp(Line, KnownTags[a], l) == 0){
                        if (Line[l] == ' ' || Line[l] == '=' || Line[l] == 0){
                            
                            if (Line[l] == ' ') Line[l] = '='; 
                            if (a == 2) break; 
                            if (a == 3) HasScandate = TRUE;
                            if (RemComment){
                                if (strlen(RemComment) == l){
                                    if (!memcmp(Line, RemComment, l)){
                                        Modified = TRUE;
                                        break;
                                    }
                                }
                            }
                            if (AddComment){
                                
                                if (!memcmp(Line, AddComment, l+1)){
                                    TagExists = TRUE;
                                    strncpy(Line, AddComment, sizeof(Line));
                                    Line[sizeof(Line)-1]='\0';
                                    Modified = TRUE;
                                }
                            }
                            strncat(OutComment, Line, MAX_COMMENT_SIZE-5-strlen(OutComment));
                            strcat(OutComment, "\n");
                            break;
                        }
                    }
                }
            }
            Line[Len = 0] = 0;
            if (SrcComment[i] == 0) break;
        }else{
            Line[Len++] = SrcComment[i];
        }
    }

    if (AddComment && TagExists == FALSE){
        strncat(OutComment, AddComment, MAX_COMMENT_SIZE-5-strlen(OutComment));
        strcat(OutComment, "\n");
        Modified = TRUE;
    }

    if (!HasScandate && !ImageInfo.DateTime[0]){
        
        char Temp[40];
        sprintf(Temp, "scan_date=%s", ctime(&ImageInfo.FileDateTime));
        strncat(OutComment, Temp, MAX_COMMENT_SIZE-5-strlen(OutComment));
        Modified = TRUE;
    }
    return Modified;
}



static int AutoResizeCmdStuff(void)
{
    static char CommandString[PATH_MAX+1];
    double scale;
    float TargetSize = 1800;

    ApplyCommand = CommandString;

    scale = TargetSize / ImageInfo.Width;
    if (scale > TargetSize / ImageInfo.Height) scale = TargetSize / ImageInfo.Height;

    if (scale > 0.8){
        if (ImageInfo.QualityGuess >= 93){
            
            sprintf(CommandString, "mogrify -quality 86 &i");
            return TRUE;
        }
        printf("not resizing %dx%x '%s'\n",ImageInfo.Height, ImageInfo.Width, ImageInfo.FileName);
        return FALSE;
    }

    if (scale < 0.4) scale = 0.4; 

    sprintf(CommandString, "mogrify -geometry %dx%d -quality 85 &i",(int)(ImageInfo.Width*scale+0.5), (int)(ImageInfo.Height*scale+0.5));
    return TRUE;
}









static int shellescape(char* to, const char* from)
{
    int i, j;
    i = j = 0;

    
    
    to[j++] = '"';
    while(from[i])
    {

        
        
        
        to[j++] = from[i++];

        switch(from[i]) {
            case '"':
            case '$':
            case '`':
            case '\\':
                to[j++] = '\\';
                
            default:
                to[j++] = from[i++];
        }

        if (j >= PATH_MAX) ErrFatal("max path exceeded");
    }
    to[j++] = '"';
    return j;
}





static void DoCommand(const char * FileName, int ShowIt)
{
    int a,e;
    char ExecString[PATH_MAX*3];
    char TempName[PATH_MAX+10];
    int TempUsed = FALSE;

    e = 0;

    
    
    a = strlen(FileName)-1;
    while(a > 0 && FileName[a-1] != SLASH) a--;
    memcpy(TempName, FileName, a);
    strcpy(TempName+a, "XXXXXX");

    
    
    
    
    
    
    mktemp(TempName);


    if(!TempName[0]) {
        ErrFatal("Cannot find available temporary file name");
    }


    
    for (a=0;;a++){
        if (ApplyCommand[a] == '&'){
            if (ApplyCommand[a+1] == 'i'){
                
                e += shellescape(ExecString+e, FileName);
                a += 1;
                continue;
            }
            if (ApplyCommand[a+1] == 'o'){
                
                e += shellescape(ExecString+e, TempName);
                a += 1;
                TempUsed = TRUE;
                continue;
            }
        }
        ExecString[e++] = ApplyCommand[a];
        if (ApplyCommand[a] == 0) break;
    }

    if (ShowIt) printf("Cmd:%s\n",ExecString);

    errno = 0;
    a = system(ExecString);

    if (a || errno){
        
        if (errno) perror("system");
        ErrFatal("Problem executing specified command");
    }

    if (TempUsed){
        
        struct stat dummy;
        if (stat(TempName, &dummy) == 0){
            struct stat buf;
            int stat_result = stat(FileName, &buf);

            unlink(FileName);
            rename(TempName, FileName);
            if (stat_result == 0){
                
                struct utimbuf mtime;
                chmod(FileName, buf.st_mode);

                mtime.actime = buf.st_atime;
                mtime.modtime = buf.st_mtime;

                utime(FileName, &mtime);
            }
        }else{
            ErrFatal("specified command did not produce expected output file");
        }
    }
}




static int CheckFileSkip(void)
{
    
    
    if(ProcessOnly >= 0 && (ImageInfo.Process & 0x0f) != ProcessOnly){
        
        
        return TRUE;
    }

    if (FilterModel){
        
        
        
        if (strstr(ImageInfo.CameraModel, FilterModel) == NULL){
            
            return TRUE;
        }
    }
    if (FilterQuality > 0){
        
        if (ImageInfo.QualityGuess < FilterQuality){
            return TRUE;
        }
    }

    if (ExifOnly){
        
        if (FindSection(M_EXIF) == NULL){
            return TRUE;
        }
    }

    if (PortraitOnly == 1){
        if (ImageInfo.Width > ImageInfo.Height) return TRUE;
    }

    if (PortraitOnly == -1){
        if (ImageInfo.Width < ImageInfo.Height) return TRUE;
    }

    return FALSE;
}





static void RelativeName(char * OutFileName, const char * NamePattern, const char * OrigName)
{
    
    
    
    char * Subst;
    Subst = strstr(NamePattern, "&i");
    if (Subst){
        strncpy(OutFileName, NamePattern, Subst-NamePattern);
        OutFileName[Subst-NamePattern] = 0;
        strncat(OutFileName, OrigName, PATH_MAX);
        strncat(OutFileName, Subst+2, PATH_MAX);
    }else{
        strncpy(OutFileName, NamePattern, PATH_MAX);
    }
}






void RenameAssociated(const char * FileName, char * NewBaseName)
{
    int a;
    int PathLen;
    int ExtPos;
    char FilePattern[_MAX_PATH+1];
    char NewName[_MAX_PATH+1];
    struct _finddata_t finddata;
    long find_handle;

    for(ExtPos = strlen(FileName);FileName[ExtPos-1] != '.';){
        if (--ExtPos == 0) return; 
    }

    memcpy(FilePattern, FileName, ExtPos);
    FilePattern[ExtPos] = '*';
    FilePattern[ExtPos+1] = '\0';

    for(PathLen = strlen(FileName);FileName[PathLen-1] != SLASH;){
        if (--PathLen == 0) break;
    }

    find_handle = _findfirst(FilePattern, &finddata);

    for (;;){
        if (find_handle == -1) break;

        
        if (!memcmp(finddata.name, ".",2)) goto next_file;
        if (!memcmp(finddata.name, "..",3)) goto next_file;
        if (finddata.attrib & _A_SUBDIR) goto next_file;

        strncpy(FilePattern+PathLen, finddata.name, PATH_MAX-PathLen); 

        strcpy(NewName, NewBaseName);
        for(a = strlen(finddata.name);finddata.name[a] != '.';){
            if (--a == 0) goto next_file;
        }
        strncat(NewName, finddata.name+a, _MAX_PATH-strlen(NewName)); 

        if (rename(FilePattern, NewName) == 0){
            if (!Quiet){
                printf("%s --> %s\n",FilePattern, NewName);
            }
        }

        next_file:
        if (_findnext(find_handle, &finddata) != 0) break;
    }
    _findclose(find_handle);
}





static void DoFileRenaming(const char * FileName)
{
    int PrefixPart = 0; 
    int ExtensionPart;  
    int a;
    struct tm tm;
    char NewBaseName[PATH_MAX*2];
    int AddLetter = 0;
    char NewName[PATH_MAX+2];

    ExtensionPart = strlen(FileName);
    for (a=0;FileName[a];a++){
        if (FileName[a] == SLASH){
            
            PrefixPart = a+1;
        }

        if (FileName[a] == '.') ExtensionPart = a;  
    }
    if (ExtensionPart < PrefixPart) { 
        ExtensionPart = strlen(FileName);
    }

    if (!Exif2tm(&tm, ImageInfo.DateTime)){
        printf("File '%s' contains no exif date stamp.  Using file date\n",FileName);
        
        tm = *localtime(&ImageInfo.FileDateTime);
    }


    strncpy(NewBaseName, FileName, PATH_MAX); 

    if (strftime_args){
        
        time_t UnixTime;

        char *s;
        char pattern[PATH_MAX+20];
        int n = ExtensionPart - PrefixPart;

        
        UnixTime = mktime(&tm);
        if ((int)UnixTime == -1){
            printf("Could not convert %s to unix time",ImageInfo.DateTime);
            return;
        }

        
        pattern[PATH_MAX-1]=0;
        strncpy(pattern, strftime_args, PATH_MAX-1);
        while ((s = strstr(pattern, "%f")) && strlen(pattern) + n < PATH_MAX-1){
            memmove(s + n, s + 2, strlen(s+2) + 1);
            memmove(s, FileName + PrefixPart, n);
        }

        {
            
            
            int ppos = -1;
            for (a=0;pattern[a];a++){
                if (pattern[a] == '%'){
                     ppos = a;
                }else if (pattern[a] == 'i'){
                    if (ppos >= 0 && a<ppos+4){
                        
                        char pat[8], num[16];
                        int l,nl;
                        memcpy(pat, pattern+ppos, 4);
                        pat[a-ppos] = 'd'; 
                        pat[a-ppos+1] = '\0';
                        sprintf(num, pat, FileSequence); 
                        nl = strlen(num);
                        l = strlen(pattern+a+1);
                        if (ppos+nl+l+1 >= PATH_MAX) ErrFatal("str overflow");
                        memmove(pattern+ppos+nl, pattern+a+1, l+1);
                        memcpy(pattern+ppos, num, nl);
                        break;
                    }
                }else if (!isdigit(pattern[a])){
                    ppos = -1;
                }
            }
        }
        strftime(NewName, PATH_MAX, pattern, &tm);
    }else{
        
        sprintf(NewName, "%02d%02d-%02d%02d%02d", tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    }

    NewBaseName[PrefixPart] = 0;
    CatPath(NewBaseName, NewName);

    AddLetter = isdigit(NewBaseName[strlen(NewBaseName)-1]);
    for (a=0;;a++){
        char NewName[PATH_MAX*2+10];
        char NameExtra[3];
        struct stat dummy;

        if (a){
            
            
            
            
            
            if (AddLetter){
                NameExtra[0] = (char)('a'-1+a); 
            }else{
                NameExtra[0] = (char)('0'-1+a); 
            }
            NameExtra[1] = 0;
        }else{
            NameExtra[0] = 0;
        }

        snprintf(NewName, sizeof(NewName), "%s%s.jpg", NewBaseName, NameExtra);

        if (!strcmp(FileName, NewName)) break; 

        if (!EnsurePathExists(NewBaseName)){
            break;
        }


        if (stat(NewName, &dummy)){
            
            if (rename(FileName, NewName) == 0){
                printf("%s --> %s\n",FileName, NewName);

                if (RenameAssociatedFiles){
                    sprintf(NewName, "%s%s", NewBaseName, NameExtra);
                    RenameAssociated(FileName, NewName);
                }

            }else{
                printf("Error: Couldn't rename '%s' to '%s'\n",FileName, NewName);
            }
            break;

        }

        if (a > 25 || (!AddLetter && a > 9)){
            printf("Possible new names for for '%s' already exist\n",FileName);
            break;
        }
    }
}




static int DoAutoRotate(const char * FileName)
{
    if (ImageInfo.Orientation != 1){
        const char * Argument;
        Argument = ClearOrientation();
        if (Argument == NULL) return FALSE; 

        if (!ZeroRotateTagOnly){
            char RotateCommand[PATH_MAX*2+50];
            if (strlen(Argument) == 0){
                
                return TRUE; 
            }
            sprintf(RotateCommand, "jpegtran -trim -%s -outfile &o &i", Argument);
            ApplyCommand = RotateCommand;
            DoCommand(FileName, FALSE);
            ApplyCommand = NULL;

            
            if (ImageInfo.ThumbnailOffset && ImageInfo.ThumbnailSize && ImageInfo.ThumbnailAtEnd){

                

                char ThumbTempName_in[PATH_MAX+5];
                char ThumbTempName_out[PATH_MAX+5];

                strcpy(ThumbTempName_in, FileName);
                strcat(ThumbTempName_in, ".thi");
                strcpy(ThumbTempName_out, FileName);
                strcat(ThumbTempName_out, ".tho");
                SaveThumbnail(ThumbTempName_in);
                sprintf(RotateCommand,"jpegtran -trim -%s -outfile \"%s\" \"%s\"", Argument, ThumbTempName_out, ThumbTempName_in);

                if (system(RotateCommand) == 0){
                    
                    ReplaceThumbnail(ThumbTempName_out);
                }

                unlink(ThumbTempName_in);
                unlink(ThumbTempName_out);
            }
        }
        return TRUE;
    }
    return FALSE;
}




static int RegenerateThumbnail(const char * FileName)
{
    char ThumbnailGenCommand[PATH_MAX*2+50];
    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){
        
        return FALSE;
    }

    sprintf(ThumbnailGenCommand, "mogrify -thumbnail %dx%d -quality 80 \"%s\"", RegenThumbnail, RegenThumbnail, FileName);

    if (system(ThumbnailGenCommand) == 0){
        
        return ReplaceThumbnail(FileName);
    }else{
        ErrFatal("Unable to run 'mogrify' command");
        return FALSE;
    }
}




void FileTimeAsString(char * TimeStr)
{
    struct tm ts;
    ts = *localtime(&ImageInfo.FileDateTime);
    strftime(TimeStr, 20, "%Y:%m:%d %H:%M:%S", &ts);
}




static void ProcessFile(const char * FileName)
{
    int Modified = FALSE;
    ReadMode_t ReadMode;

    if (strlen(FileName) >= PATH_MAX-1){
        
        ErrFatal("filename too long");
    }

    ReadMode = READ_METADATA;
    CurrentFile = FileName;
    FilesMatched = 1;

    ResetJpgfile();
    Clear_EXIF();

    
    memset(&ImageInfo, 0, sizeof(ImageInfo));
    ImageInfo.FlashUsed = -1;
    ImageInfo.MeteringMode = -1;
    ImageInfo.Whitebalance = -1;

    
    {
        struct stat st;
        if (stat(FileName, &st) >= 0){
            ImageInfo.FileDateTime = st.st_mtime;
            ImageInfo.FileSize = st.st_size;
        }else{
            ErrFatal("No such file");
        }
    }

    if ((DoModify & MODIFY_ANY) || RenameToDate || Exif2FileTime){
        if (access(FileName, 2 )){
            printf("Skipping readonly file '%s'\n",FileName);
            return;
        }
    }

    strncpy(ImageInfo.FileName, FileName, PATH_MAX);


    if (ApplyCommand || AutoRotate){
        
        

        if (!ReadJpegFile(FileName, READ_METADATA)) return;

        #ifdef MATTHIAS
            if (AutoResize){
                
                if (AutoResizeCmdStuff() == 0){
                    DiscardData();
                    return;
                }
            }
        #endif 


        if (CheckFileSkip()){
            DiscardData();
            return;
        }

        DiscardAllButExif();

        if (AutoRotate){
            if (DoAutoRotate(FileName)){
                Modified = TRUE;
            }
        }else{
            struct stat dummy;
            DoCommand(FileName, Quiet ? FALSE : TRUE);

            if (stat(FileName, &dummy)){
                
                
                return;
            }
            Modified = TRUE;
        }
        ReadMode = READ_IMAGE;   
    }

    if (ExifXferScrFile){
        char RelativeExifName[PATH_MAX+1];

        
        RelativeName(RelativeExifName, ExifXferScrFile, FileName);

        if(!ReadJpegFile(RelativeExifName, READ_METADATA)) return;

        DiscardAllButExif();    

        Modified = TRUE;
        ReadMode = READ_IMAGE;
    }

    if (DoModify){
        ReadMode |= READ_IMAGE;
    }

    if (!ReadJpegFile(FileName, ReadMode)) return;

    if (CheckFileSkip()){
        DiscardData();
        return;
    }

    if (TrimExifTrailingZeroes){
        if (ImageInfo.ThumbnailAtEnd){
            Section_t * ExifSection;
            int NumRedundant, WasRedundant;
            unsigned char * StartRedundant;
            
            ExifSection = FindSection(M_EXIF);

            StartRedundant = ExifSection->Data + 8 + ImageInfo.ThumbnailOffset+ImageInfo.ThumbnailSize;
            WasRedundant = NumRedundant = (ExifSection->Size) - (ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8);

            

            for(;NumRedundant > 0 && StartRedundant[NumRedundant-1] == 0;NumRedundant--);

            if (NumRedundant != WasRedundant){
                int NewExifSize;
                printf("Trimming %d bytes from exif in %s\n", WasRedundant-NumRedundant, FileName);
                NewExifSize = ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize + 8 + NumRedundant;
                ExifSection->Data[0] = (uchar)(NewExifSize >> 8); 
                ExifSection->Data[1] = (uchar)NewExifSize;
                ExifSection->Size = NewExifSize;
                Modified = TRUE;
            }else{
                
            }
        }
    }

    FileSequence += 1; 

    if (ShowConcise){
        ShowConciseImageInfo();
    }else{
        if (!(DoModify) || ShowTags){
            ShowImageInfo(ShowFileInfo);

            {
                
                Section_t * IptcSection;
                IptcSection = FindSection(M_IPTC);

                if (IptcSection){
                    show_IPTC(IptcSection->Data, IptcSection->Size);
                }
            }
            printf("\n");
        }
    }

    if (ThumbSaveName){
        char OutFileName[PATH_MAX+1];
        
        RelativeName(OutFileName, ThumbSaveName, FileName);

        if (SaveThumbnail(OutFileName)){
            printf("Created: '%s'\n", OutFileName);
        }
    }

    if (CreateExifSection){
        
        create_EXIF();
        Modified = TRUE;
    }

    if (RegenThumbnail){
        if (RegenerateThumbnail(FileName)){
            Modified = TRUE;
        }
    }

    if (ThumbInsertName){
        char ThumbFileName[PATH_MAX+1];
        
        RelativeName(ThumbFileName, ThumbInsertName, FileName);

        if (ReplaceThumbnail(ThumbFileName)){
            Modified = TRUE;
        }
    }else if (TrimExif){
        
        if (ReplaceThumbnail(NULL)){
            Modified = TRUE;
        }
    }

    if (  AddComment || RemComment ||  EditComment || CommentInsertfileName || CommentInsertLiteral){




        Section_t * CommentSec;
        char Comment[MAX_COMMENT_SIZE+1];
        int CommentSize;

        CommentSec = FindSection(M_COM);

        if (CommentSec == NULL){
            unsigned char * DummyData;

            DummyData = (uchar *) malloc(3);
            DummyData[0] = 0;
            DummyData[1] = 2;
            DummyData[2] = 0;
            CommentSec = CreateSection(M_COM, DummyData, 2);
        }

        CommentSize = CommentSec->Size-2;
        if (CommentSize > MAX_COMMENT_SIZE){
            fprintf(stderr, "Truncating comment at %d chars\n",MAX_COMMENT_SIZE);
            CommentSize = MAX_COMMENT_SIZE;
        }

        if (CommentInsertfileName){
            
            char CommentFileName[PATH_MAX+1];
            FILE * CommentFile;

            
            RelativeName(CommentFileName, CommentInsertfileName, FileName);

            CommentFile = fopen(CommentFileName,"r");
            if (CommentFile == NULL){
                printf("Could not open '%s'\n",CommentFileName);
            }else{
                
                
                CommentSize = fread(Comment, 1, MAX_COMMENT_SIZE, CommentFile);
                fclose(CommentFile);
                if (CommentSize < 0) CommentSize = 0;
            }
        }else if (CommentInsertLiteral){
            strncpy(Comment, CommentInsertLiteral, MAX_COMMENT_SIZE);
            CommentSize = strlen(Comment);
        }else{

            char CommentZt[MAX_COMMENT_SIZE+1];
            memcpy(CommentZt, (char *)CommentSec->Data+2, CommentSize);
            CommentZt[CommentSize] = '\0';
            if (ModifyDescriptComment(Comment, CommentZt)){
                Modified = TRUE;
                CommentSize = strlen(Comment);
            }
            if (EditComment)

            memcpy(Comment, (char *)CommentSec->Data+2, CommentSize);

            {
                char EditFileName[PATH_MAX+5];
                strcpy(EditFileName, FileName);
                strcat(EditFileName, ".txt");

                CommentSize = FileEditComment(EditFileName, Comment, CommentSize);
            }
        }

        if (strcmp(Comment, (char *)CommentSec->Data+2)){
            
            int size;
            size = CommentSize+2;
            free(CommentSec->Data);
            CommentSec->Size = size;
            CommentSec->Data = malloc(size);
            CommentSec->Data[0] = (uchar)(size >> 8);
            CommentSec->Data[1] = (uchar)(size);
            memcpy((CommentSec->Data)+2, Comment, size-2);
            Modified = TRUE;
        }
        if (!Modified){
            printf("Comment not modified\n");
        }
    }


    if (CommentSavefileName){
        Section_t * CommentSec;
        CommentSec = FindSection(M_COM);

        if (CommentSec != NULL){
            char OutFileName[PATH_MAX+1];
            FILE * CommentFile;

            
            RelativeName(OutFileName, CommentSavefileName, FileName);

            CommentFile = fopen(OutFileName,"w");
            if (CommentFile){
                fwrite((char *)CommentSec->Data+2 ,CommentSec->Size-2, 1, CommentFile);
                fclose(CommentFile);
            }else{
                ErrFatal("Could not write comment file");
            }
        }else{
            printf("File '%s' contains no comment section\n",FileName);
        }
    }

    if (ExifTimeAdjust || ExifTimeSet || DateSetChars || FileTimeToExif){
       if (ImageInfo.numDateTimeTags){
            struct tm tm;
            time_t UnixTime;
            char TempBuf[50];
            int a;
            Section_t * ExifSection;
            if (ExifTimeSet){
                
                UnixTime = ExifTimeSet;
            }else{
                if (FileTimeToExif){
                    FileTimeAsString(ImageInfo.DateTime);
                }
                if (DateSetChars){
                    memcpy(ImageInfo.DateTime, DateSet, DateSetChars);
                    a = 1970;
                    sscanf(DateSet, "%d", &a);
                    if (a < 1970){
                        strcpy(TempBuf, ImageInfo.DateTime);
                        goto skip_unixtime;
                    }
                }
                
                if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;

                
                UnixTime = mktime(&tm);
                if ((int)UnixTime == -1) goto badtime;
                UnixTime += ExifTimeAdjust;
            }
            tm = *localtime(&UnixTime);

            
            
            sprintf(TempBuf, "%04d:%02d:%02d %02d:%02d:%02d", tm.tm_year+1900, tm.tm_mon+1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);


skip_unixtime:
            ExifSection = FindSection(M_EXIF);

            for (a = 0; a < ImageInfo.numDateTimeTags; a++) {
                uchar * Pointer;
                Pointer = ExifSection->Data+ImageInfo.DateTimeOffsets[a]+8;
                memcpy(Pointer, TempBuf, 19);
            }
            memcpy(ImageInfo.DateTime, TempBuf, 19);

            Modified = TRUE;
        }else{
            printf("File '%s' contains no Exif timestamp to change\n", FileName);
        }
    }

    if (DeleteComments){
        if (RemoveSectionType(M_COM)) Modified = TRUE;
    }
    if (DeleteExif){
        if (RemoveSectionType(M_EXIF)) Modified = TRUE;
    }
    if (DeleteIptc){
        if (RemoveSectionType(M_IPTC)) Modified = TRUE;
    }
    if (DeleteXmp){
        if (RemoveSectionType(M_XMP)) Modified = TRUE;
    }
    if (DeleteUnknown){
        if (RemoveUnknownSections()) Modified = TRUE;
    }


    if (Modified){
        char BackupName[PATH_MAX+5];
        struct stat buf;

        if (!Quiet) printf("Modified: %s\n",FileName);

        strcpy(BackupName, FileName);
        strcat(BackupName, ".t");

        
        unlink(BackupName);

        
        rename(FileName, BackupName);

        
        WriteJpegFile(FileName);

        
        if (stat(BackupName, &buf) == 0){
            
            struct utimbuf mtime;
            chmod(FileName, buf.st_mode);

            mtime.actime = buf.st_mtime;
            mtime.modtime = buf.st_mtime;

            utime(FileName, &mtime);
        }

        
        unlink(BackupName);
    }


    if (Exif2FileTime){
        
        if (ImageInfo.numDateTimeTags){
            
            struct tm tm;
            time_t UnixTime;
            struct utimbuf mtime;
          if (!Exif2tm(&tm, ImageInfo.DateTime)) goto badtime;
            UnixTime = mktime(&tm);
            if ((int)UnixTime == -1){
                goto badtime;
            }
            mtime.actime = UnixTime;
            mtime.modtime = UnixTime;

            if (utime(FileName, &mtime) != 0){
                printf("Error: Could not change time of file '%s'\n",FileName);
            }else{
                if (!Quiet) printf("%s\n",FileName);
            }
        }else{
            printf("File '%s' contains no Exif timestamp\n", FileName);
        }
    }

    
    

    if (RenameToDate){
        DoFileRenaming(FileName);
    }
    DiscardData();
    return;
badtime:
    printf("Error: Time '%s': cannot convert to Unix time\n",ImageInfo.DateTime);
    DiscardData();
}




static void Usage (void)
{
    printf("Jhead is a program for manipulating settings and thumbnails in Exif jpeg headers\n" "used by most Digital Cameras.  v"JHEAD_VERSION" Matthias Wandel, Oct 5 2020.\n" "http://www.sentex.net/~mwandel/jhead\n" "\n");



    printf("Usage: %s [options] files\n", progname);
    printf("Where:\n" " files       path/filenames with or without wildcards\n"  "[options] are:\n" "\nGENERAL METADATA:\n" "  -te <name> Transfer exif header from another image file <name>\n" "             Uses same name mangling as '-st' option\n" "  -dc        Delete comment field (as left by progs like Photoshop & Compupic)\n" "  -de        Strip Exif section (smaller JPEG file, but lose digicam info)\n" "  -di        Delete IPTC section (from Photoshop, or Picasa)\n" "  -dx        Delete XMP section\n" "  -du        Delete non image sections except for Exif and comment sections\n" "  -purejpg   Strip all unnecessary data from jpeg (combines -dc -de and -du)\n" "  -mkexif    Create new minimal exif section (overwrites pre-existing exif)\n" "  -ce        Edit comment field.  Uses environment variable 'editor' to\n" "             determine which editor to use.  If editor not set, uses VI\n" "             under Unix and notepad with windows\n" "  -cs <name> Save comment section to a file\n" "  -ci <name> Insert comment section from a file.  -cs and -ci use same naming\n" "             scheme as used by the -st option\n" "  -cl string Insert literal comment string\n" "  -zt        Trim exif header trailing zeroes (Nikon 1 wastes 30k that way)\n"  "\nDATE / TIME MANIPULATION:\n" "  -ft        Set file modification time to Exif time\n" "  -dsft      Set Exif time to file modification time\n" "  -n[format-string]\n" "             Rename files according to date.  Uses exif date if present, file\n" "             date otherwise.  If the optional format-string is not supplied,\n" "             the format is mmdd-hhmmss.  If a format-string is given, it is\n" "             is passed to the 'strftime' function for formatting\n" "             %%d Day of month    %%H Hour (24-hour)\n" "             %%m Month number    %%M Minute    %%S Second\n" "             %%y Year (2 digit 00 - 99)        %%Y Year (4 digit 1980-2036)\n" "             For more arguments, look up the 'strftime' function.\n" "             In addition to strftime format codes:\n" "             '%%f' as part of the string will include the original file name\n" "             '%%i' will include a sequence number, starting from 1. You can\n" "             You can specify '%%03i' for example to get leading zeros.\n" "             This feature is useful for ordering files from multiple digicams to\n" "             sequence of taking.\n" "             The '.jpg' is automatically added to the end of the name.  If the\n" "             destination name already exists, a letter or digit is added to \n" "             the end of the name to make it unique.\n" "             The new name may include a path as part of the name.  If this path\n" "             does not exist, it will be created\n" "  -a         (Windows only) Rename files with same name but different extension\n" "             Use together with -n to rename .AVI files from exif in .THM files\n" "             for example\n" "  -ta<+|->h[:mm[:ss]]\n" "             Adjust time by h:mm forwards or backwards.  Useful when having\n" "             taken pictures with the wrong time set on the camera, such as when\n" "             traveling across time zones or DST changes. Dates can be adjusted\n" "             by offsetting by 24 hours or more.  For large date adjustments,\n" "             use the -da option\n" "  -da<date>-<date>\n" "             Adjust date by large amounts.  This is used to fix photos from\n" "             cameras where the date got set back to the default camera date\n" "             by accident or battery removal.\n" "             To deal with different months and years having different numbers of\n" "             days, a simple date-month-year offset would result in unexpected\n" "             results.  Instead, the difference is specified as desired date\n" "             minus original date.  Date is specified as yyyy:mm:dd or as date\n" "             and time in the format yyyy:mm:dd/hh:mm:ss\n" "  -ts<time>  Set the Exif internal time to <time>.  <time> is in the format\n" "             yyyy:mm:dd-hh:mm:ss\n" "  -tf file   Set the exif time to the modification time from another file\n" "  -ds<date>  Set the Exif internal date.  <date> is in the format YYYY:MM:DD\n" "             or YYYY:MM or YYYY\n"  "\nTHUMBNAIL MANIPULATION:\n" "  -dt        Remove exif integral thumbnails.  Typically trims 10k\n" "  -st <name> Save Exif thumbnail, if there is one, in file <name>\n" "             If output file name contains the substring \"&i\" then the\n" "             image file name is substitute for the &i.  Note that quotes around\n" "             the argument are required for the '&' to be passed to the program.\n"  "             An output name of '-' causes thumbnail to be written to stdout\n"  "  -rt <name> Replace Exif thumbnail.  Can only be done with headers that\n" "             already contain a thumbnail.\n" "  -rgt[size] Regenerate exif thumbnail.  Only works if image already\n" "             contains a thumbnail.  size specifies maximum height or width of\n" "             thumbnail.  Relies on 'mogrify' programs to be on path\n"  "\nROTATION TAG MANIPULATION:\n" "  -autorot   Invoke jpegtran to rotate images according to Exif orientation tag\n" "             and clear Exif orientation tag\n" "             Note: Windows users must get jpegtran for this to work\n" "  -norot     Zero out the rotation tag.  This to avoid some browsers from\n" "             rotating the image again after you rotated it but neglected to\n" "             clear the rotation tag\n"  "\nOUTPUT VERBOSITY CONTROL:\n" "  -h         help (this text)\n" "  -v         even more verbose output\n" "  -q         Quiet (no messages on success, like Unix)\n" "  -V         Show jhead version\n" "  -exifmap   Dump header bytes, annotate.  Pipe thru sort for better viewing\n" "  -se        Suppress error messages relating to corrupt exif header structure\n" "  -c         concise output\n" "  -nofinfo   Don't show file info (name/size/date)\n"  "\nFILE MATCHING AND SELECTION:\n" "  -model model\n" "             Only process files from digicam containing model substring in\n" "             camera model description\n" "  -exonly    Skip all files that don't have an exif header (skip all jpegs that\n" "             were not created by digicam)\n" "  -quality x Only work on images with JPEG quality factor x or higher\n" "  -cmd command\n" "             Apply 'command' to every file, then re-insert exif and command\n" "             sections into the image. &i will be substituted for the input file\n" "             name, and &o (if &o is used). Use quotes around the command string\n" "             This is most useful in conjunction with the free ImageMagick tool. \n" "             For example, with my Canon S100, which suboptimally compresses\n" "             jpegs I can specify\n" "                jhead -cmd \"mogrify -quality 80 &i\" *.jpg\n" "             to re-compress a lot of images using ImageMagick to half the size,\n" "             and no visible loss of quality while keeping the exif header\n" "             Another invocation I like to use is jpegtran (hard to find for\n" "             windows).  I type:\n" "                jhead -cmd \"jpegtran -progressive &i &o\" *.jpg\n" "             to convert jpegs to progressive jpegs (Unix jpegtran syntax\n" "             differs slightly)\n" "  -orp       Only operate on 'portrait' aspect ratio images\n" "  -orl       Only operate on 'landscape' aspect ratio images\n"  "  -r         No longer supported.  Use the ** wildcard to recurse directories\n" "             with instead.\n" "             examples:\n" "                 jhead **/*.jpg\n" "                 jhead \"c:\\my photos\\**\\*.jpg\"\n"     "\n" "  -cr        Remove comment tag (my way)\n" "  -ca        Add comment tag (my way)\n" "  -ar        Auto resize to fit in 1024x1024, but never less than half\n"    );
















































































































































    exit(EXIT_FAILURE);
}





static time_t ParseCmdDate(char * DateSpecified)
{
    int a;
    struct tm tm;
    time_t UnixTime;

    tm.tm_wday = -1;
    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;

    a = sscanf(DateSpecified, "%d:%d:%d/%d:%d:%d", &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);


    if (a != 3 && a < 5){
        
        
        ErrFatal("Could not parse specified date");
    }
    tm.tm_isdst = -1;
    tm.tm_mon -= 1;      
    tm.tm_year -= 1900;  

    UnixTime = mktime(&tm);
    if (UnixTime == -1){
        ErrFatal("Specified time is invalid or out of range");
    }

    return UnixTime;
}




int main (int argc, char **argv)
{
    int argn;
    char * arg;
    progname = argv[0];

    for (argn=1;argn<argc;argn++){
        arg = argv[argn];
        if (arg[0] != '-') break; 

    
        if (!strcmp(arg,"-te")){
            ExifXferScrFile = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-dc")){
            DeleteComments = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-de")){
            DeleteExif = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-di")){
            DeleteIptc = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-dx")){
            DeleteXmp = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg, "-du")){
            DeleteUnknown = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg, "-purejpg")){
            DeleteExif = TRUE;
            DeleteComments = TRUE;
            DeleteIptc = TRUE;
            DeleteUnknown = TRUE;
            DeleteXmp = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-ce")){
            EditComment = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-cs")){
            CommentSavefileName = argv[++argn];
        }else if (!strcmp(arg,"-ci")){
            CommentInsertfileName = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-cl")){
            CommentInsertLiteral = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-zt")){
            TrimExifTrailingZeroes = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-mkexif")){
            CreateExifSection = TRUE;
            DoModify |= MODIFY_JPEG;
    
        }else if (!strcmp(arg,"-h") || !strcmp(arg,"--help")){
            Usage();
        }else if (!strcmp(arg,"-v")){
            ShowTags = TRUE;
        }else if (!strcmp(arg,"-q")){
            Quiet = TRUE;
        }else if (!strcmp(arg,"-V")){
            printf("Jhead version: "JHEAD_VERSION"\n");
            exit(0);
        }else if (!strcmp(arg,"-exifmap")){
            DumpExifMap = TRUE;
        }else if (!strcmp(arg,"-se")){
            SuppressNonFatalErrors = TRUE;
        }else if (!strcmp(arg,"-c")){
            ShowConcise = TRUE;
        }else if (!strcmp(arg,"-nofinfo")){
            ShowFileInfo = 0;

    
        }else if (!strcmp(arg,"-dt")){
            TrimExif = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-st")){
            ThumbSaveName = argv[++argn];
            DoModify |= READ_JPEG;
        }else if (!strcmp(arg,"-rt")){
            ThumbInsertName = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!memcmp(arg,"-rgt", 4)){
            RegenThumbnail = 160;
            sscanf(arg+4, "%d", &RegenThumbnail);
            if (RegenThumbnail > 320){
                ErrFatal("Specified thumbnail geometry too big!");
            }
            DoModify |= MODIFY_JPEG;

    
        }else if (!strcmp(arg,"-autorot")){
            AutoRotate = 1;
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-norot")){
            AutoRotate = 1;
            ZeroRotateTagOnly = 1;
            DoModify |= MODIFY_JPEG;

    
        }else if (!memcmp(arg,"-n",2)){
            RenameToDate = 1;
            DoModify |= READ_JPEG; 
            arg+=2;
            if (*arg == 'f'){
                
                arg++;
            }
            if (*arg){
                
                strftime_args = arg;
                #ifdef _WIN32
                    SlashToNative(strftime_args);
                #endif
                
            }
        }else if (!strcmp(arg,"-a")){
            #ifndef _WIN32
                ErrFatal("Error: -a only supported in Windows version");
            #else
                RenameAssociatedFiles = TRUE;
            #endif
        }else if (!strcmp(arg,"-ft")){
            Exif2FileTime = TRUE;
            DoModify |= MODIFY_ANY;
        }else if (!memcmp(arg,"-ta",3)){
            
            int hours, minutes, seconds, n;
            minutes = seconds = 0;
            if (arg[3] != '-' && arg[3] != '+'){
                ErrFatal("Error: -ta must be followed by +/- and a time");
            }
            n = sscanf(arg+4, "%d:%d:%d", &hours, &minutes, &seconds);

            if (n < 1){
                ErrFatal("Error: -ta must be immediately followed by time");
            }
            if (ExifTimeAdjust) ErrFatal("Can only use one of -da or -ta options at once");
            ExifTimeAdjust = hours*3600 + minutes*60 + seconds;
            if (arg[3] == '-') ExifTimeAdjust = -ExifTimeAdjust;
            DoModify |= MODIFY_JPEG;
        }else if (!memcmp(arg,"-da",3)){
            
            time_t NewDate, OldDate = 0;
            char * pOldDate;
            NewDate = ParseCmdDate(arg+3);
            pOldDate = strstr(arg+1, "-");
            if (pOldDate){
                OldDate = ParseCmdDate(pOldDate+1);
            }else{
                ErrFatal("Must specify second date for -da option");
            }
            if (ExifTimeAdjust) ErrFatal("Can only use one of -da or -ta options at once");
            ExifTimeAdjust = NewDate-OldDate;
            DoModify |= MODIFY_JPEG;
        }else if (!memcmp(arg,"-dsft",5)){
            
            FileTimeToExif = TRUE;
            DoModify |= MODIFY_JPEG;
        }else if (!memcmp(arg,"-ds",3)){
            
            int a;
            
            strcpy(DateSet, "0000:01:01");
            for (a=0;arg[a+3];a++){
                if (isdigit(DateSet[a])){
                    if (!isdigit(arg[a+3])){
                        a = 0;
                        break;
                    }
                }else{
                    if (arg[a+3] != ':'){
                        a=0;
                        break;
                    }
                }
                DateSet[a] = arg[a+3];
            }
            if (a < 4 || a > 10){
                ErrFatal("Date must be in format YYYY, YYYY:MM, or YYYY:MM:DD");
            }
            DateSetChars = a;
            DoModify |= MODIFY_JPEG;
        }else if (!memcmp(arg,"-ts",3)){
            
            
            char * c;
            struct tm tm;

            c = strstr(arg+1, "-");
            if (c) *c = ' '; 

            if (!Exif2tm(&tm, arg+3)){
                ErrFatal("-ts option must be followed by time in format yyyy:mm:dd-hh:mm:ss\n" "Example: jhead -ts2001:01:01-12:00:00 foo.jpg");
            }

            ExifTimeSet  = mktime(&tm);

            if ((int)ExifTimeSet == -1) ErrFatal("Time specified is out of range");
            DoModify |= MODIFY_JPEG;

        }else if (!memcmp(arg,"-tf",3)){
            
            struct stat stat_buf;
            if (stat(argv[++argn], &stat_buf) == 0){
                ExifTimeSet = stat_buf.st_mtime;
            }else{
                ErrFatal("Could not read file");
            }
            DoModify |= MODIFY_JPEG;

    
        }else if (!strcmp(arg,"-model")){
            if (argn+1 >= argc) Usage(); 
            FilterModel = argv[++argn];
        }else if (!strcmp(arg,"-quality")){
            if (argn+1 >= argc) Usage(); 
            if (sscanf(argv[++argn], "%d", &FilterQuality) != 1){
                Usage();
            }
        }else if (!strcmp(arg,"-proc")){
            sscanf(argv[++argn], "%d", &ProcessOnly);
            if (ProcessOnly < 0 || ProcessOnly > 2){
                ErrFatal("-proc must be followed by a number 0-2");
            }
        }else if (!strcmp(arg,"-exonly")){
            ExifOnly = 1;
        }else if (!strcmp(arg,"-orp")){
            PortraitOnly = 1;
        }else if (!strcmp(arg,"-orl")){
            PortraitOnly = -1;
        }else if (!strcmp(arg,"-cmd")){
            if (argn+1 >= argc) Usage(); 
            ApplyCommand = argv[++argn];
            DoModify |= MODIFY_ANY;


        }else if (!strcmp(arg,"-ca")){
            
            AddComment = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-cr")){
            
            RemComment = argv[++argn];
            DoModify |= MODIFY_JPEG;
        }else if (!strcmp(arg,"-ar")){
            AutoResize = TRUE;
            ShowConcise = TRUE;
            ApplyCommand = (char *)1; 
            DoModify |= MODIFY_JPEG;

        }else{
            printf("Argument '%s' not understood\n",arg);
            printf("Use jhead -h for list of arguments\n");
            exit(-1);
        }
        if (argn >= argc){
            
            
            ErrFatal("Extra argument required");
        }
    }
    if (argn == argc){
        ErrFatal("No files to process.  Use -h for help");
    }

    if (ThumbSaveName != NULL && strcmp(ThumbSaveName, "&i") == 0){
        printf("Error: By specifying \"&i\" for the thumbail name, your original file\n" "       will be overwritten.  If this is what you really want,\n" "       specify -st \"./&i\"  to override this check\n");

        exit(0);
    }

    if (RegenThumbnail){
        if (ThumbSaveName || ThumbInsertName){
            printf("Error: Cannot regen and save or insert thumbnail in same run\n");
            exit(0);
        }
    }

    if (EditComment){
        if (CommentSavefileName != NULL || CommentInsertfileName != NULL){
            printf("Error: Cannot use -ce option in combination with -cs or -ci\n");
            exit(0);
        }
    }


    if (ExifXferScrFile){
        if (FilterModel || ApplyCommand){
            ErrFatal("Error: Filter by model and/or applying command to files\n" "   invalid while transferring Exif headers");
        }
    }

    FileSequence = 0;
    for (;argn<argc;argn++){
        FilesMatched = FALSE;

        #ifdef _WIN32
            SlashToNative(argv[argn]);
            
            
            MyGlob(argv[argn], ProcessFile);
        #else
            
            
            ProcessFile(argv[argn]);
        #endif

        if (!FilesMatched){
            fprintf(stderr, "Error: No files matched '%s'\n",argv[argn]);
        }
    }

    if (FileSequence == 0){
        return EXIT_FAILURE;
    }else{
        return EXIT_SUCCESS;
    }
}
