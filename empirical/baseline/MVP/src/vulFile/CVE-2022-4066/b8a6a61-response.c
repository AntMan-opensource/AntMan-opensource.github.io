
























const char *onion_response_code_description(int code);




static volatile time_t onion_response_last_time = 0;
static char *onion_response_last_date_header = NULL;

pthread_rwlock_t onion_response_date_lock = PTHREAD_RWLOCK_INITIALIZER;




onion_response *onion_response_new(onion_request * req) {
  onion_response *res = onion_low_malloc(sizeof(onion_response));

  res->request = req;
  res->headers = onion_dict_new();
  res->code = 200;              
  res->flags = 0;
  res->sent_bytes_total = res->length = res->sent_bytes = 0;
  res->buffer_pos = 0;


  {
    time_t t;
    struct tm tmp;

    t = time(NULL);

    
    

    time_t current = __sync_add_and_fetch(&onion_response_last_time, 0);

    if (t != current) {
      ONION_DEBUG("Recalculating date header");
      char current_datetime[200];

      if (localtime_r(&t, &tmp) == NULL) {
        perror("localtime");
        exit(EXIT_FAILURE);
      }

      if (strftime (current_datetime, sizeof(current_datetime), "%a, %d %b %Y %H:%M:%S %Z", &tmp) == 0) {

        fprintf(stderr, "strftime returned 0");
        exit(EXIT_FAILURE);
      }

      pthread_rwlock_wrlock(&onion_response_date_lock);

      __sync_bool_compare_and_swap(&onion_response_last_time, current, t);
      if (onion_response_last_date_header)
        onion_low_free(onion_response_last_date_header);
      onion_response_last_date_header = onion_low_strdup(current_datetime);

      pthread_rwlock_unlock(&onion_response_date_lock);

    }
  }

  pthread_rwlock_rdlock(&onion_response_date_lock);

  assert(onion_response_last_date_header);
  onion_dict_add(res->headers, "Date", onion_response_last_date_header, OD_DUP_VALUE);

  pthread_rwlock_unlock(&onion_response_date_lock);


  
  onion_dict_add(res->headers, "Server", "libonion v" ONION_VERSION " - coralbits.com", 0);
  onion_dict_add(res->headers, "Content-Type", "text/html", 0); 
  
  

  return res;
}


onion_connection_status onion_response_free(onion_response * res) {
  
  if (!(res->flags & OR_HEADER_SENT) && res->buffer_pos < sizeof(res->buffer))
    onion_response_set_length(res, res->buffer_pos);

  if (!(res->flags & OR_HEADER_SENT))
    onion_response_write_headers(res);

  onion_response_flush(res);
  onion_request *req = res->request;

  if (res->flags & OR_CHUNKED) {        
    req->connection.listen_point->write(req, "0\r\n\r\n", 5);
  }

  int r = OCS_CLOSE_CONNECTION;

  
  if (req) {
    
    ONION_DEBUG0 ("keep alive [req wants] %d && ([skip] %d || [lenght ok] %d==%d || [chunked] %d)", onion_request_keep_alive(req), res->flags & OR_SKIP_CONTENT, res->length, res->sent_bytes, res->flags & OR_CHUNKED);


    if (onion_request_keep_alive(req)
        && (res->flags & OR_SKIP_CONTENT || res->length == res->sent_bytes || res->flags & OR_CHUNKED)
        )
      r = OCS_KEEP_ALIVE;

    if ((onion_log_flags & OF_NOINFO) != OF_NOINFO)
      
      ONION_INFO("[%s] \"%s %s\" %d %d (%s)", onion_request_get_client_description(res->request), onion_request_methods[res->request->flags & OR_METHODS], res->request->fullpath, res->code, res->sent_bytes, (r == OCS_KEEP_ALIVE) ? "Keep-Alive" : "Close connection");



  }

  onion_dict_free(res->headers);
  onion_low_free(res);

  return r;
}


void onion_response_set_header(onion_response * res, const char *key, const char *value) {
  ONION_DEBUG0("Adding header %s = %s", key, value);
  onion_dict_add(res->headers, key, value, OD_DUP_ALL | OD_REPLACE);    
}


void onion_response_set_length(onion_response * res, size_t len) {
  if (len != res->sent_bytes && res->flags & OR_HEADER_SENT) {
    ONION_WARNING ("Trying to set length after headers sent. Undefined onion behaviour.");
    return;
  }
  char tmp[16];
  sprintf(tmp, "%lu", (unsigned long)len);
  onion_response_set_header(res, "Content-Length", tmp);
  res->length = len;
  res->flags |= OR_LENGTH_SET;
}


void onion_response_set_code(onion_response * res, int code) {
  res->code = code;
}


static void write_header(onion_response * res, const char *key, const char *value, int flags) {
  

  onion_response_write0(res, key);
  onion_response_write(res, ": ", 2);
  onion_response_write0(res, value);
  onion_response_write(res, "\r\n", 2);
}







int onion_response_write_headers(onion_response * res) {
  if (!res->request) {
    ONION_ERROR ("Bad formed response. Need a request at creation. Will not write headers.");
    return -1;
  }

  res->flags |= OR_HEADER_SENT; 
  res->request->flags |= OR_HEADER_SENT;
  char chunked = 0;

  if (res->request->flags & OR_HTTP11) {
    onion_response_printf(res, "HTTP/1.1 %d %s\r\n", res->code, onion_response_code_description(res->code));
    
    if (!(res->flags & OR_LENGTH_SET) && onion_request_keep_alive(res->request)) {
      onion_response_write(res, CONNECTION_CHUNK_ENCODING, sizeof(CONNECTION_CHUNK_ENCODING) - 1);
      chunked = 1;
    }
  } else {
    onion_response_printf(res, "HTTP/1.0 %d %s\r\n", res->code, onion_response_code_description(res->code));
    
    if (res->flags & OR_LENGTH_SET)     
      onion_response_write(res, CONNECTION_KEEP_ALIVE, sizeof(CONNECTION_KEEP_ALIVE) - 1);
  }

  if (!(res->flags & OR_LENGTH_SET) && !chunked && !(res->flags & OR_CONNECTION_UPGRADE))
    onion_response_write(res, CONNECTION_CLOSE, sizeof(CONNECTION_CLOSE) - 1);

  if (res->flags & OR_CONNECTION_UPGRADE)
    onion_response_write(res, CONNECTION_UPGRADE, sizeof(CONNECTION_UPGRADE) - 1);

  onion_dict_preorder(res->headers, write_header, res);

  if (res->request->session_id && (onion_dict_count(res->request->session) > 0))        
    onion_response_printf(res, "Set-Cookie: sessionid=%s; httponly; Path=/\n", res->request->session_id);

  onion_response_write(res, "\r\n", 2);

  ONION_DEBUG0("Headers written");
  res->sent_bytes = -res->buffer_pos;   

  if ((res->request->flags & OR_METHODS) == OR_HEAD) {
    onion_response_flush(res);
    res->flags |= OR_SKIP_CONTENT;
    return OR_SKIP_CONTENT;
  }
  if (chunked) {
    onion_response_flush(res);
    res->flags |= OR_CHUNKED;
  }

  return 0;
}


ssize_t onion_response_write(onion_response * res, const char *data, size_t length) {
  if (res->flags & OR_SKIP_CONTENT) {
    if (!(res->flags & OR_HEADER_SENT)) {       
      onion_response_write_headers(res);
    }
    ONION_DEBUG("Skipping content as we are in HEAD mode");
    return OCS_CLOSE_CONNECTION;
  }
  if (length == 0) {
    onion_response_flush(res);
    return 0;
  }
  

  int l = length;
  int w = 0;
  while (res->buffer_pos + l > sizeof(res->buffer)) {
    int wb = sizeof(res->buffer) - res->buffer_pos;
    memcpy(&res->buffer[res->buffer_pos], data, wb);

    res->buffer_pos = sizeof(res->buffer);
    if (onion_response_flush(res) < 0)
      return w;

    l -= wb;
    data += wb;
    w += wb;
  }

  memcpy(&res->buffer[res->buffer_pos], data, l);
  res->buffer_pos += l;
  w += l;

  return w;
}


int onion_response_flush(onion_response * res) {
  res->sent_bytes += res->buffer_pos;
  res->sent_bytes_total += res->buffer_pos;
  if (res->buffer_pos == 0)     
    return 0;
  if (!(res->flags & OR_HEADER_SENT)) { 
    ONION_DEBUG0 ("Doing fast header hack: store current buffer, send current headers. Resend buffer.");
    char tmpb[sizeof(res->buffer)];
    int tmpp = res->buffer_pos;
    memcpy(tmpb, res->buffer, res->buffer_pos);
    res->buffer_pos = 0;

    onion_response_write_headers(res);
    onion_response_write(res, tmpb, tmpp);
    return 0;
  }
  if (res->flags & OR_SKIP_CONTENT)     
    return 0;
  ONION_DEBUG0("Flush %d bytes", res->buffer_pos);

  onion_request *req = res->request;
  ssize_t(*write) (onion_request *, const char *data, size_t len);
  write = req->connection.listen_point->write;

  ssize_t w;
  off_t pos = 0;
  
  if (res->flags & OR_CHUNKED) {
    char tmp[16];
    snprintf(tmp, sizeof(tmp), "%X\r\n", (unsigned int)res->buffer_pos);
    if ((w = write(req, tmp, strlen(tmp))) <= 0) {
      ONION_WARNING("Error writing chunk encoding length (%X) %s. Aborting write.",  (unsigned int)res->buffer_pos, strerror(errno));

      return OCS_CLOSE_CONNECTION;
    }
    ONION_DEBUG0("Write %d-%d bytes", res->buffer_pos, w);
  }
  int savederrno = errno;
  errno = 0;
  while ((w = write(req, &res->buffer[pos], res->buffer_pos)) != res->buffer_pos) {
    if (w <= 0 || res->buffer_pos < 0) {
      ONION_ERROR("Error writing %d bytes (%s). Maybe closed connection. Code %d. ", res->buffer_pos, strerror(errno), w);
      res->buffer_pos = 0;
      errno = savederrno;
      return OCS_CLOSE_CONNECTION;
    }
    pos += w;
    ONION_DEBUG0("Write %d-%d bytes", res->buffer_pos, w);
    res->buffer_pos -= w;
  }
  if (res->flags & OR_CHUNKED) {
    write(req, "\r\n", 2);
  }
  res->buffer_pos = 0;
  errno = savederrno;
  return 0;
}



ssize_t onion_response_write0(onion_response * res, const char *data) {
  return onion_response_write(res, data, strlen(data));
}


ssize_t onion_response_write_html_safe(onion_response * res, const char *data) {
  char *tmp = onion_html_quote(data);
  if (tmp) {
    int r = onion_response_write0(res, tmp);
    onion_low_free(tmp);
    return r;
  } else return onion_response_write0(res, data);
}


ssize_t onion_response_printf(onion_response * res, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  ssize_t ret = onion_response_vprintf(res, fmt, ap);
  va_end(ap);
  return ret;
}


ssize_t onion_response_vprintf(onion_response * res, const char *fmt, va_list args) {
  char temp[512];
  va_list argz;
  int l;
  va_copy(argz, args);
  l = vsnprintf(temp, sizeof(temp), fmt, argz);
  va_end(argz);
  if (l < 0) {
    ONION_ERROR("Invalid vprintf fmt");
    return -1;
  } else if (l < sizeof(temp)) {
    return onion_response_write(res, temp, l);
  } else {
    ssize_t s;
    char *buf = onion_low_scalar_malloc(l + 1);
    if (!buf) {
      
      
      ONION_ERROR("Could not reserve %d bytes", l + 1);
      return -1;
    }
    vsnprintf(buf, l + 1, fmt, args);
    s = onion_response_write(res, buf, l);
    onion_low_free(buf);
    return s;
  }
}


const char *onion_response_code_description(int code) {
  switch (code) {
  case HTTP_OK:
    return "OK";
  case HTTP_CREATED:
    return "Created";
  case HTTP_PARTIAL_CONTENT:
    return "Partial Content";
  case HTTP_MULTI_STATUS:
    return "Multi-Status";

  case HTTP_SWITCH_PROTOCOL:
    return "Switching Protocols";

  case HTTP_MOVED:
    return "Moved Permanently";
  case HTTP_REDIRECT:
    return "Found";
  case HTTP_SEE_OTHER:
    return "See Other";
  case HTTP_NOT_MODIFIED:
    return "Not Modified";
  case HTTP_TEMPORARY_REDIRECT:
    return "Temporary Redirect";

  case HTTP_BAD_REQUEST:
    return "Bad Request";
  case HTTP_UNAUTHORIZED:
    return "Unauthorized";
  case HTTP_FORBIDDEN:
    return "Forbidden";
  case HTTP_NOT_FOUND:
    return "Not Found";
  case HTTP_METHOD_NOT_ALLOWED:
    return "Method Not Allowed";
  case HTTP_RANGE_NOT_SATISFIABLE:
    return "Range Not Satisfiable";
  case HTTP_IM_A_TEAPOT:
    return "I'm a teapot";

  case HTTP_INTERNAL_ERROR:
    return "Internal Server Error";
  case HTTP_NOT_IMPLEMENTED:
    return "Not Implemented";
  case HTTP_BAD_GATEWAY:
    return "Bad Gateway";
  case HTTP_SERVICE_UNAVAILABLE:
    return "Service Unavailable";
  }
  return "CODE UNKNOWN";
}


onion_dict *onion_response_get_headers(onion_response * res) {
  return res->headers;
}


bool onion_response_add_cookie(onion_response * res, const char *cookiename, const char *cookievalue, time_t validity_t, const char *path, const char *domain, int flags) {


  char data[4096];
  int pos;
  pos = snprintf(data, sizeof(data), "%s=%s", cookiename, cookievalue);
  if (validity_t == 0)
    pos += snprintf(data + pos, sizeof(data) - pos, "; expires=Thu, 01 Jan 1970 00:00:00 GMT");

  else if (validity_t > 0) {
    struct tm *tmp;
    time_t t = time(NULL) + validity_t;
    tmp = localtime(&t);
    pos += strftime(data + pos, sizeof(data) - pos, "; expires=%a, %d %b %Y %H:%M:%S %Z", tmp);

  }
  if (path)
    pos += snprintf(data + pos, sizeof(data) - pos, "; path=%s", path);
  if (domain)
    pos += snprintf(data + pos, sizeof(data) - pos, "; domain=%s", domain);
  if (flags & OC_HTTP_ONLY)
    pos += snprintf(data + pos, sizeof(data) - pos, "; HttpOnly");
  if (flags & OC_SECURE)
    pos += snprintf(data + pos, sizeof(data) - pos, "; Secure");

  switch (flags & (OC_SAMESITE_NONE | OC_SAMESITE_LAX | OC_SAMESITE_STRICT)) {
  case OC_SAMESITE_NONE:
    pos+=snprintf(data+pos, sizeof(data)-pos, "; SameSite=None");
    break;
  case OC_SAMESITE_LAX:
    pos+=snprintf(data+pos, sizeof(data)-pos, "; SameSite=Lax");
    break;
  case OC_SAMESITE_STRICT:
    pos+=snprintf(data+pos, sizeof(data)-pos, "; SameSite=Strict");
    break;
  default:
    break;
  }

  if (pos >= sizeof(data)) {
    ONION_WARNING("Cookie too long to be constructed. Not added to response.");
    return false;
  }

  onion_response_set_header(res, "Set-Cookie", data);
  ONION_DEBUG("Set cookie %s", data);

  return true;
}
