












namespace Envoy {
namespace ConnectionPool {

class ConnPoolImplBase;



struct AttachContext {
  
  virtual ~AttachContext() = default;
};



class ActiveClient : public LinkedObject<ActiveClient>, public Network::ConnectionCallbacks, public Event::DeferredDeletable, protected Logger::Loggable<Logger::Id::pool> {


public:
  ActiveClient(ConnPoolImplBase& parent, uint32_t lifetime_stream_limit, uint32_t concurrent_stream_limit);
  ~ActiveClient() override;

  virtual void releaseResources() { releaseResourcesBase(); }
  void releaseResourcesBase();

  
  void onAboveWriteBufferHighWatermark() override {}
  void onBelowWriteBufferLowWatermark() override {}

  
  void onConnectTimeout();

  
  void onConnectionDurationTimeout();

  
  
  virtual uint32_t effectiveConcurrentStreamLimit() const {
    return std::min(remaining_streams_, concurrent_stream_limit_);
  }

  
  virtual absl::optional<Http::Protocol> protocol() const PURE;

  virtual int64_t currentUnusedCapacity() const {
    int64_t remaining_concurrent_streams = static_cast<int64_t>(concurrent_stream_limit_) - numActiveStreams();

    return std::min<int64_t>(remaining_streams_, remaining_concurrent_streams);
  }

  
  virtual void close() PURE;
  
  virtual uint64_t id() const PURE;
  
  virtual bool closingWithIncompleteStream() const PURE;
  
  virtual uint32_t numActiveStreams() const PURE;

  
  
  
  
  virtual bool hadNegativeDeltaOnStreamClosed() { return false; }

  enum class State {
    CONNECTING,  READY, BUSY, DRAINING,  CLOSED };






  State state() const { return state_; }

  void setState(State state) {
    
    
    if (state == State::DRAINING) {
      drain();
    }
    state_ = state;
  }

  
  virtual void drain();

  ConnPoolImplBase& parent_;
  
  
  
  
  
  uint32_t remaining_streams_;
  
  
  
  uint32_t configured_stream_limit_;
  
  
  
  uint32_t concurrent_stream_limit_;
  Upstream::HostDescriptionConstSharedPtr real_host_description_;
  Stats::TimespanPtr conn_connect_ms_;
  Stats::TimespanPtr conn_length_;
  Event::TimerPtr connect_timer_;
  Event::TimerPtr connection_duration_timer_;
  bool resources_released_{false};
  bool timed_out_{false};

private:
  State state_{State::CONNECTING};
};



class PendingStream : public LinkedObject<PendingStream>, public ConnectionPool::Cancellable {
public:
  PendingStream(ConnPoolImplBase& parent, bool can_send_early_data);
  ~PendingStream() override;

  
  void cancel(Envoy::ConnectionPool::CancelPolicy policy) override;

  
  
  virtual AttachContext& context() PURE;

  ConnPoolImplBase& parent_;
  
  bool can_send_early_data_;
};

using PendingStreamPtr = std::unique_ptr<PendingStream>;

using ActiveClientPtr = std::unique_ptr<ActiveClient>;


class ConnPoolImplBase : protected Logger::Loggable<Logger::Id::pool> {
public:
  ConnPoolImplBase(Upstream::HostConstSharedPtr host, Upstream::ResourcePriority priority, Event::Dispatcher& dispatcher, const Network::ConnectionSocket::OptionsSharedPtr& options, const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options, Upstream::ClusterConnectivityState& state);



  virtual ~ConnPoolImplBase();

  void deleteIsPendingImpl();
  
  
  
  virtual bool trackStreamCapacity() { return true; }

  
  template <class T> T& typedContext(AttachContext& context) {
    ASSERT(dynamic_cast<T*>(&context) != nullptr);
    return *static_cast<T*>(&context);
  }

  
  
  
  
  
  
  static bool shouldConnect(size_t pending_streams, size_t active_streams, int64_t connecting_and_connected_capacity, float preconnect_ratio, bool anticipate_incoming_stream = false);


  
  void addIdleCallbackImpl(Instance::IdleCb cb);
  
  bool isIdleImpl() const;
  void drainConnectionsImpl(DrainBehavior drain_behavior);
  const Upstream::HostConstSharedPtr& host() const { return host_; }
  
  bool maybePreconnectImpl(float global_preconnect_ratio);

  
  
  
  
  void destructAllConnections();

  
  virtual ActiveClientPtr instantiateActiveClient() PURE;

  
  std::list<ActiveClientPtr>& owningList(ActiveClient::State state);

  
  
  void onPendingStreamCancel(PendingStream& stream, Envoy::ConnectionPool::CancelPolicy policy);

  
  void purgePendingStreams(const Upstream::HostDescriptionConstSharedPtr& host_description, absl::string_view failure_reason, ConnectionPool::PoolFailureReason pool_failure_reason);


  
  void closeIdleConnectionsForDrainingPool();

  
  void transitionActiveClientState(ActiveClient& client, ActiveClient::State new_state);

  void onConnectionEvent(ActiveClient& client, absl::string_view failure_reason, Network::ConnectionEvent event);

  
  void checkForIdleAndCloseIdleConnsIfDraining();

  void scheduleOnUpstreamReady();
  ConnectionPool::Cancellable* newStreamImpl(AttachContext& context, bool can_send_early_data);

  virtual ConnectionPool::Cancellable* newPendingStream(AttachContext& context, bool can_send_early_data) PURE;

  virtual void attachStreamToClient(Envoy::ConnectionPool::ActiveClient& client, AttachContext& context);

  virtual void onPoolFailure(const Upstream::HostDescriptionConstSharedPtr& host_description, absl::string_view failure_reason, ConnectionPool::PoolFailureReason pool_failure_reason, AttachContext& context) PURE;


  virtual void onPoolReady(ActiveClient& client, AttachContext& context) PURE;
  
  void onStreamClosed(Envoy::ConnectionPool::ActiveClient& client, bool delay_attaching_stream);

  Event::Dispatcher& dispatcher() { return dispatcher_; }
  Upstream::ResourcePriority priority() const { return priority_; }
  const Network::ConnectionSocket::OptionsSharedPtr& socketOptions() { return socket_options_; }
  const Network::TransportSocketOptionsConstSharedPtr& transportSocketOptions() {
    return transport_socket_options_;
  }
  bool hasPendingStreams() const { return !pending_streams_.empty(); }

  void decrClusterStreamCapacity(uint32_t delta) {
    state_.decrConnectingAndConnectedStreamCapacity(delta);
  }
  void incrClusterStreamCapacity(uint32_t delta) {
    state_.incrConnectingAndConnectedStreamCapacity(delta);
  }
  void dumpState(std::ostream& os, int indent_level = 0) const {
    const char* spaces = spacesForLevel(indent_level);
    os << spaces << "ConnPoolImplBase " << this << DUMP_MEMBER(ready_clients_.size())
       << DUMP_MEMBER(busy_clients_.size()) << DUMP_MEMBER(connecting_clients_.size())
       << DUMP_MEMBER(connecting_stream_capacity_) << DUMP_MEMBER(num_active_streams_)
       << DUMP_MEMBER(pending_streams_.size())
       << " per upstream preconnect ratio: " << perUpstreamPreconnectRatio();
  }

  friend std::ostream& operator<<(std::ostream& os, const ConnPoolImplBase& s) {
    s.dumpState(os);
    return os;
  }
  Upstream::ClusterConnectivityState& state() { return state_; }

  void decrConnectingAndConnectedStreamCapacity(uint32_t delta) {
    state_.decrConnectingAndConnectedStreamCapacity(delta);
    ASSERT(connecting_stream_capacity_ >= delta);
    connecting_stream_capacity_ -= delta;
  }

  void incrConnectingAndConnectedStreamCapacity(uint32_t delta) {
    state_.incrConnectingAndConnectedStreamCapacity(delta);
    connecting_stream_capacity_ += delta;
  }

  
  void onUpstreamReady();

protected:
  virtual void onConnected(Envoy::ConnectionPool::ActiveClient&) {}

  enum class ConnectionResult {
    FailedToCreateConnection, CreatedNewConnection, ShouldNotConnect, NoConnectionRateLimited, CreatedButRateLimited, };




  
  
  ConnectionResult tryCreateNewConnections();

  
  
  
  
  ConnectionResult tryCreateNewConnection(float global_preconnect_ratio = 0);

  
  
  bool connectingConnectionIsExcess() const;

  
  
  bool shouldCreateNewConnection(float global_preconnect_ratio) const;

  float perUpstreamPreconnectRatio() const;

  ConnectionPool::Cancellable* addPendingStream(Envoy::ConnectionPool::PendingStreamPtr&& pending_stream) {
    LinkedList::moveIntoList(std::move(pending_stream), pending_streams_);
    state_.incrPendingStreams(1);
    return pending_streams_.front().get();
  }

  bool hasActiveStreams() const { return num_active_streams_ > 0; }

  Upstream::ClusterConnectivityState& state_;

  const Upstream::HostConstSharedPtr host_;
  const Upstream::ResourcePriority priority_;

  Event::Dispatcher& dispatcher_;
  const Network::ConnectionSocket::OptionsSharedPtr socket_options_;
  const Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;

  
  
  virtual bool enforceMaxRequests() const { return true; }

  std::list<Instance::IdleCb> idle_callbacks_;

  
  
  std::list<PendingStreamPtr> pending_streams_to_purge_;

  
  
  std::list<ActiveClientPtr> ready_clients_;

  
  std::list<ActiveClientPtr> busy_clients_;

  
  std::list<ActiveClientPtr> connecting_clients_;

  
  
  uint32_t connecting_stream_capacity_{0};

private:
  std::list<PendingStreamPtr> pending_streams_;

  
  uint32_t num_active_streams_{0};

  
  
  bool is_draining_for_deletion_{false};

  
  bool deferred_deleting_{false};

  Event::SchedulableCallbackPtr upstream_ready_cb_;
};

} 
} 
