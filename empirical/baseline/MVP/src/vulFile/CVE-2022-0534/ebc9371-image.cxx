







extern "C" {		

}












typedef uchar	gif_cmap_t[256][3];














static size_t	num_images = 0,		 alloc_images = 0;
static image_t	**images = NULL;	
static int	gif_eof = 0;		




static int	gif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap, int *gray);
static int	gif_get_block(FILE *fp, uchar *buffer);
static int	gif_get_code (FILE *fp, int code_size, int first_time);
static int	gif_read_image(FILE *fp, image_t *img, gif_cmap_t cmap, int interlace, int transparent);
static int	gif_read_lzw(FILE *fp, int first_time, int input_code_size);

static int	image_compare(image_t **img1, image_t **img2);
static int	image_load_bmp(image_t *img, FILE *fp, int gray, int load_data);
static int	image_load_gif(image_t *img, FILE *fp, int gray, int load_data);


static int	image_load_jpeg(image_t *img, FILE *fp, int gray, int load_data);
static void	jpeg_error_handler(j_common_ptr);



static int	image_load_png(image_t *img, FILE *fp, int gray, int load_data);


static void	image_need_mask(image_t *img, int scaling = 1);
static void	image_set_mask(image_t *img, int x, int y, uchar alpha = 0);

static int		read_long(FILE *fp);
static unsigned short	read_word(FILE *fp);
static unsigned int	read_dword(FILE *fp);




static int				 gif_read_cmap(FILE       *fp, int        ncolors, gif_cmap_t cmap, int        *gray)



{
  int	i;				


 

  if (fread(cmap, 3, (size_t)ncolors, fp) < (size_t)ncolors)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to read GIF colormap: %s", strerror(errno));
    return (-1);
  }

 

  for (i = 0; i < ncolors; i ++)
    if (cmap[i][0] != cmap[i][1] || cmap[i][1] != cmap[i][2])
      break;

  if (i == ncolors)
  {
    *gray = 1;
    return (0);
  }

 

  if (*gray)
    for (i = 0; i < ncolors; i ++)
      cmap[i][0] = (cmap[i][0] * 31 + cmap[i][1] * 61 + cmap[i][2] * 8) / 100;

  return (0);
}




static int			 gif_get_block(FILE  *fp, uchar *buf)

{
  int	count;			


 

  if ((count = getc(fp)) == EOF)
  {
    gif_eof = 1;
    return (-1);
  }
  else if (count == 0)
    gif_eof = 1;
  else if (fread(buf, 1, (size_t)count, fp) < (size_t)count)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to read GIF block of %d bytes: %s", count, strerror(errno));

    gif_eof = 1;
    return (-1);
  }
  else gif_eof = 0;

  return (count);
}




static int			 gif_get_code(FILE *fp, int  code_size, int  first_time)


{
  unsigned		i, j,		 ret;
  int			count;		
  static uchar		buf[280];	
  static unsigned	curbit,		 lastbit, done, last_byte;


  static unsigned	bits[8] =	 {
			  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };



  if (first_time)
  {
   

    curbit    = 0;
    lastbit   = 0;
    last_byte = 0;
    done      = 0;

    return (0);
  }

  if ((curbit + (unsigned)code_size) >= lastbit)
  {
   

    if (done)
    {
      progress_error(HD_ERROR_READ_ERROR, "Not enough data left to read GIF compression code.");
      return (-1);	
    }

   

    if (last_byte > 1)
    {
      buf[0]    = buf[last_byte - 2];
      buf[1]    = buf[last_byte - 1];
      last_byte = 2;
    }
    else if (last_byte == 1)
    {
      buf[0]    = buf[last_byte - 1];
      last_byte = 1;
    }

   

    if ((count = gif_get_block(fp, buf + last_byte)) <= 0)
    {
     

      done = 1;
      return (-1);
    }

   

    curbit    = curbit + 8 * last_byte - lastbit;
    last_byte += (unsigned)count;
    lastbit   = last_byte * 8;
  }

  for (ret = 0, i = curbit + (unsigned)code_size - 1, j = (unsigned)code_size;
       j > 0;
       i --, j --)
    ret = (ret << 1) | ((buf[i / 8] & bits[i & 7]) != 0);

  curbit += (unsigned)code_size;

  return (int)ret;
}




static int				 gif_read_image(FILE       *fp, image_t    *img, gif_cmap_t cmap, int        interlace, int        transparent)




{
  uchar		code_size,		 *temp;
  int		xpos,			 ypos, pass;

  int		pixel;			
  static int	xpasses[4] = { 8, 8, 4, 2 }, ypasses[5] = { 0, 4, 2, 1, 999999 };


  xpos      = 0;
  ypos      = 0;
  pass      = 0;
  code_size = (uchar)getc(fp);

  if (gif_read_lzw(fp, 1, code_size) < 0)
    return (-1);

  temp = img->pixels;

  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)
  {
    temp[0] = cmap[pixel][0];

    if (img->depth > 1)
    {
      temp[1] = cmap[pixel][1];
      temp[2] = cmap[pixel][2];
    }

    if (pixel == transparent)
      image_set_mask(img, xpos, ypos);

    xpos ++;
    temp += img->depth;
    if (xpos == img->width)
    {
      xpos = 0;

      if (interlace)
      {
        ypos += xpasses[pass];
        temp += (xpasses[pass] - 1) * img->width * img->depth;

        if (ypos >= img->height)
	{
	  pass ++;

          ypos = ypasses[pass];
          temp = img->pixels + ypos * img->width * img->depth;
	}
      }
      else ypos ++;
    }

    if (ypos >= img->height)
      break;
  }

  return (0);
}




static int				 gif_read_lzw(FILE *fp, int  first_time, int  input_code_size)


{
  int		i,			 code, incode;

  static short	fresh = 0,		 code_size = 0, set_code_size = 0, max_code = 0, max_code_size = 0, firstcode = 0, oldcode = 0, clear_code = 0, end_code = 0, table[2][4096], stack[8192], *sp = stack;












  if (first_time)
  {
   

    set_code_size = (short)input_code_size;
    code_size     = set_code_size + 1;
    clear_code    = (short)(1 << set_code_size);
    end_code      = clear_code + 1;
    max_code_size = 2 * clear_code;
    max_code      = clear_code + 2;

   

    gif_get_code(fp, 0, 1);

   

    fresh = 1;

    for (i = 0; i < clear_code; i ++)
    {
      table[0][i] = 0;
      table[1][i] = (short)i;
    }

    for (; i < 4096; i ++)
      table[0][i] = table[1][0] = 0;

    sp = stack;

    return (0);
  }
  else if (fresh)
  {
    fresh = 0;

    do firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);
    while (firstcode == clear_code);

    return (firstcode);
  }

  if (sp > stack)
    return (*--sp);

  while ((code = gif_get_code (fp, code_size, 0)) >= 0)
  {
    if (code == clear_code)
    {
      for (i = 0; i < clear_code; i ++)
      {
	table[0][i] = 0;
	table[1][i] = (short)i;
      }

      for (; i < 4096; i ++)
	table[0][i] = table[1][i] = 0;

      code_size     = set_code_size + 1;
      max_code_size = 2 * clear_code;
      max_code      = clear_code + 2;

      sp = stack;

      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);

      return (firstcode);
    }
    else if (code == end_code)
    {
      uchar	buf[260];


      if (!gif_eof)
        while (gif_get_block(fp, buf) > 0);

      return (-2);
    }

    incode = code;

    if (code >= max_code)
    {
      *sp++ = firstcode;
      code  = oldcode;
    }

    while (code >= clear_code)
    {
      *sp++ = table[1][code];
      if (code == table[0][code])
	return (255);

      code = table[0][code];
    }

    *sp++ = firstcode = table[1][code];
    code  = max_code;

    if (code < 4096)
    {
      table[0][code] = oldcode;
      table[1][code] = firstcode;
      max_code ++;

      if (max_code >= max_code_size && max_code_size < 4096)
      {
	max_code_size *= 2;
	code_size ++;
      }
    }

    oldcode = (short)incode;

    if (sp > stack)
      return (*--sp);
  }

  return (code);
}




static int			 image_compare(image_t **img1, image_t **img2)

{

  return (strcasecmp((*img1)->filename, (*img2)->filename));

  return (strcmp((*img1)->filename, (*img2)->filename));

}




void image_copy(const char *src, const char *realsrc, const char *destpath)


{
  char		dest[255];		
  FILE		*in, *out;		
  uchar		buffer[8192];		
  int		nbytes;			


  if (!src || !realsrc || !destpath)
    return;

 

  if (!strcmp(destpath, "."))
    strlcpy(dest, file_basename(src), sizeof(dest));
  else snprintf(dest, sizeof(dest), "%s/%s", destpath, file_basename(src));

  if (!strcmp(dest, realsrc))
    return;

 

  if ((in = fopen(realsrc, "rb")) == NULL)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to open \"%s\" - %s", realsrc, strerror(errno));
    return;
  }

  if ((out = fopen(dest, "wb")) == NULL)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to create \"%s\" - %s", dest, strerror(errno));
    fclose(in);
    return;
  }

  while ((nbytes = fread(buffer, 1, sizeof(buffer), in)) > 0)
    fwrite(buffer, 1, (size_t)nbytes, out);

  progress_error(HD_ERROR_NONE, "BYTES: %ld", ftell(out));

  fclose(in);
  fclose(out);
}




image_t *			 image_find(const char *filename, int        load_data)

{
  image_t	key,		 *keyptr, **match;



 

  if (filename == NULL)
    return (NULL);

  if (filename[0] == '\0')	
    return (NULL);

 

  if (num_images > 0)
  {
    strlcpy(key.filename, filename, sizeof(key.filename));
    keyptr = &key;

    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *), (int (*)(const void *, const void *))image_compare);
    if (match != NULL)
    {
      if (load_data && !(*match)->pixels)
        return (image_load((*match)->filename, (*match)->depth == 1, 1));
      else return (*match);
    }
  }

  return (NULL);
}




void image_flush_cache(void)
{
  size_t	i;			


 

  for (i = 0; i < num_images; i ++)
  {
    if (images[i]->mask)
      free(images[i]->mask);

    if (images[i]->pixels)
      free(images[i]->pixels);

    free(images[i]);
  }

  if (alloc_images)
  {
    free(images);

    alloc_images = 0;
  }

  num_images = 0;
}




int				 image_getlist(image_t ***ptrs)
{
  *ptrs = images;
  return (num_images);
}




image_t *			 image_load(const char *filename, int        gray, int        load_data)


{

  int		i;		

  FILE		*fp;		
  uchar		header[16];	
  image_t	*img,		 key, *keyptr, **match, **temp;



  int		status;		
  const char	*realname;	


 

  if (filename == NULL)
    return (NULL);

  if (filename[0] == '\0')	
    return (NULL);

  DEBUG_printf(("image_load(filename=\"%s\", gray=%d, load_data=%d)\n", filename, gray, load_data));
  DEBUG_printf(("Path = \"%s\"\n", Path));

 

  if (num_images > 0)
  {
    strlcpy(key.filename, filename, sizeof(key.filename));
    keyptr = &key;

    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *), (int (*)(const void *, const void *))image_compare);
    if (match != NULL && (!load_data || (*match)->pixels))
    {
      (*match)->use ++;
      return (*match);
    }
  }
  else match = NULL;

 

  if ((realname = file_find(Path, filename)) == NULL)
  {
    progress_error(HD_ERROR_FILE_NOT_FOUND, "Unable to find image file \"%s\"!", filename);
    return (NULL);
  }

  if ((fp = fopen(realname, "rb")) == NULL)
  {
    progress_error(HD_ERROR_FILE_NOT_FOUND, "Unable to open image file \"%s\" (%s) for reading!", filename, realname);

    return (NULL);
  }

  if (fread(header, 1, sizeof(header), fp) == 0)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to read image file \"%s\"!", filename);
    fclose(fp);
    return (NULL);
  }


  printf("Header for \"%s\" (%s): \"", filename, realname);

  for (i = 0; i < (int)sizeof(header); i ++)
    if (header[i] < ' ' || header[i] >= 127)
      printf("\\x%02X", header[i]);
    else putchar(header[i]);

  puts("\"\n");

  printf("match = %p\n", (void *)match);


  rewind(fp);

  
  if (!match)
  {
    if (num_images >= alloc_images)
    {
      
      alloc_images += ALLOC_FILES;

      if (num_images == 0)
	temp = (image_t **)malloc(sizeof(image_t *) * alloc_images);
      else temp = (image_t **)realloc(images, sizeof(image_t *) * alloc_images);

      if (temp == NULL)
      {
	progress_error(HD_ERROR_OUT_OF_MEMORY, "Unable to allocate memory for %d images - %s", (int)alloc_images, strerror(errno));

	fclose(fp);
	return (NULL);
      }

      images = temp;
    }

    
    img = (image_t *)calloc(sizeof(image_t), 1);

    if (img == NULL)
    {
      progress_error(HD_ERROR_READ_ERROR, "Unable to allocate memory for \"%s\"", filename);
      fclose(fp);
      return (NULL);
    }

    images[num_images] = img;

    strlcpy(img->filename, filename, sizeof(img->filename));
    img->use = 1;
  }
  else img = *match;

  
  if (memcmp(header, "GIF87a", 6) == 0 || memcmp(header, "GIF89a", 6) == 0)
    status = image_load_gif(img,  fp, gray, load_data);
  else if (memcmp(header, "BM", 2) == 0)
    status = image_load_bmp(img, fp, gray, load_data);

  else if (memcmp(header, "\211PNG", 4) == 0)
    status = image_load_png(img, fp, gray, load_data);


  else if (memcmp(header, "\377\330\377", 3) == 0)
    status = image_load_jpeg(img, fp, gray, load_data);

  else {
    progress_error(HD_ERROR_BAD_FORMAT, "Unknown image file format for \"%s\".", file_rlookup(filename));
    fclose(fp);
    free(img);
    return (NULL);
  }

  fclose(fp);

  if (status)
  {
    progress_error(HD_ERROR_READ_ERROR, "Unable to load image file \"%s\"!", file_rlookup(filename));
    if (!match)
      free(img);
    return (NULL);
  }

  if (!match)
  {
    num_images ++;
    if (num_images > 1)
      qsort(images, num_images, sizeof(image_t *), (int (*)(const void *, const void *))image_compare);
  }

  return (img);
}




static int			 image_load_bmp(image_t *img, FILE    *fp, int     gray, int     load_data)



{
  int		info_size,	 depth, compression, colors_used, x, y, color, count, temp, align;







  uchar		bit,		 byte;
  uchar		*ptr;		
  uchar		colormap[256][4];


  
  getc(fp);			
  getc(fp);
  read_dword(fp);		
  read_word(fp);		
  read_word(fp);
  read_dword(fp);

  
  info_size        = (int)read_dword(fp);
  img->width       = read_long(fp);
  img->height      = read_long(fp);
  read_word(fp);
  depth            = read_word(fp);
  compression      = (int)read_dword(fp);
  read_dword(fp);
  read_long(fp);
  read_long(fp);
  colors_used      = (int)read_dword(fp);
  read_dword(fp);

  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0)
    return (-1);

  if (info_size > 40)
  {
    for (info_size -= 40; info_size > 0; info_size --)
      getc(fp);
  }

  
  if (colors_used == 0 && depth <= 8)
    colors_used = 1 << depth;
  else if (colors_used < 0 || colors_used > 256)
    return (-1);

  fread(colormap, (size_t)colors_used, 4, fp);

  
  img->depth = gray ? 1 : 3;

  
  
  if (depth <= 8 && Encryption)
    img->use ++;

  
  if (!load_data)
    return (0);

  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));
  if (img->pixels == NULL)
    return (-1);

  if (gray && depth <= 8)
  {
    
    for (color = colors_used - 1; color >= 0; color --)
      colormap[color][0] = (colormap[color][2] * 31 + colormap[color][1] * 61 + colormap[color][0] * 8) / 100;

  }

  
  color = 0;
  count = 0;
  align = 0;
  byte  = 0;
  temp  = 0;

  for (y = img->height - 1; y >= 0; y --)
  {
    ptr = img->pixels + y * img->width * img->depth;

    switch (depth)
    {
      case 1 : 
          for (x = img->width, bit = 128; x > 0; x --)
	  {
	    if (bit == 128)
	      byte = (uchar)getc(fp);

	    if (byte & bit)
	    {
	      if (!gray)
	      {
		*ptr++ = colormap[1][2];
		*ptr++ = colormap[1][1];
              }

	      *ptr++ = colormap[1][0];
	    }
	    else {
	      if (!gray)
	      {
		*ptr++ = colormap[0][2];
		*ptr++ = colormap[0][1];
	      }

	      *ptr++ = colormap[0][0];
	    }

	    if (bit > 1)
	      bit >>= 1;
	    else bit = 128;
	  }

         

	  for (temp = (img->width + 7) / 8; temp & 3; temp ++)
	    getc(fp);
          break;

      case 4 : 
          for (x = img->width, bit = 0xf0; x > 0; x --)
	  {
	   

            if (compression != BI_RLE4 && count == 0)
	    {
	      count = 2;
	      color = -1;
            }

	    if (count == 0)
	    {
	      while (align > 0)
	      {
	        align --;
		getc(fp);
              }

	      if ((count = getc(fp)) == 0)
	      {
		if ((count = getc(fp)) == 0)
		{
		 

                  x ++;
		  continue;
		}
		else if (count == 1)
		{
		 

		  break;
		}
		else if (count == 2)
		{
		 

		  count = getc(fp) * getc(fp) * img->width;
		  color = 0;
		}
		else {
		 

		  color = -1;
		  align = ((4 - (count & 3)) / 2) & 1;
		}
	      }
	      else color = getc(fp);
            }

           

	    count --;

            if (bit == 0xf0)
	    {
              if (color < 0)
		temp = getc(fp) & 255;
	      else temp = color;

             

              if (!gray)
	      {
		*ptr++ = colormap[temp >> 4][2];
		*ptr++ = colormap[temp >> 4][1];
              }

	      *ptr++ = colormap[temp >> 4][0];
	      bit    = 0x0f;
            }
	    else {
             

	      if (!gray)
	      {
	        *ptr++ = colormap[temp & 15][2];
	        *ptr++ = colormap[temp & 15][1];
	      }

	      *ptr++ = colormap[temp & 15][0];
	      bit    = 0xf0;
	    }
	  }
          break;

      case 8 : 
          for (x = img->width; x > 0; x --)
	  {
	   

            if (compression != BI_RLE8)
	    {
	      count = 1;
	      color = -1;
            }

	    if (count == 0)
	    {
	      while (align > 0)
	      {
	        align --;
		getc(fp);
              }

	      if ((count = getc(fp)) == 0)
	      {
		if ((count = getc(fp)) == 0)
		{
		 

                  x ++;
		  continue;
		}
		else if (count == 1)
		{
		 

		  break;
		}
		else if (count == 2)
		{
		 

		  count = getc(fp) * getc(fp) * img->width;
		  color = 0;
		}
		else {
		 

		  color = -1;
		  align = (2 - (count & 1)) & 1;
		}
	      }
	      else color = getc(fp);
            }

           

            if (color < 0)
	      temp = getc(fp);
	    else temp = color;

            count --;

           

            if (!gray)
	    {
	      *ptr++ = colormap[temp][2];
	      *ptr++ = colormap[temp][1];
	    }

	    *ptr++ = colormap[temp][0];
	  }
          break;

      case 24 : 
          if (gray)
	  {
            for (x = img->width; x > 0; x --)
	    {
	      temp = getc(fp) * 8;
	      temp += getc(fp) * 61;
	      temp += getc(fp) * 31;
	      *ptr++ = (uchar)(temp / 100);
	    }
	  }
	  else {
            for (x = img->width; x > 0; x --, ptr += 3)
	    {
	      ptr[2] = (uchar)getc(fp);
	      ptr[1] = (uchar)getc(fp);
	      ptr[0] = (uchar)getc(fp);
	    }
          }

         

	  for (temp = img->width * 3; temp & 3; temp ++)
	    getc(fp);
          break;
    }
  }

  return (0);
}




static int			 image_load_gif(image_t *img, FILE    *fp, int     gray, int     load_data)



{
  uchar		buf[1024];	
  gif_cmap_t	cmap;		
  int		ncolors,	 transparent;


 

  fread(buf, 13, 1, fp);

  img->width  = (buf[7] << 8) | buf[6];
  img->height = (buf[9] << 8) | buf[8];
  ncolors     = 2 << (buf[10] & 0x07);

  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)
    return (-1);

  
  
  if (Encryption)
    img->use ++;

  if (buf[10] & GIF_COLORMAP)
    if (gif_read_cmap(fp, ncolors, cmap, &gray))
      return (-1);

  transparent = -1;

  while (1)
  {
    switch (getc(fp))
    {
      case ';' :	
          return (-1);		

      case '!' :	
          buf[0] = (uchar)getc(fp);
          if (buf[0] == 0xf9)	
          {
            gif_get_block(fp, buf);
            if (buf[0] & 1)	
              transparent = buf[3];
          }

          while (gif_get_block(fp, buf) != 0);
          break;

      case ',' :	
          fread(buf, 9, 1, fp);

          if (buf[8] & GIF_COLORMAP)
          {
            ncolors = 2 << (buf[8] & 0x07);

	    if (gif_read_cmap(fp, ncolors, cmap, &gray))
	      return (-1);
	  }

          img->width  = (buf[5] << 8) | buf[4];
          img->height = (buf[7] << 8) | buf[6];
          img->depth  = gray ? 1 : 3;

	  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)
	    return (-1);

          if (transparent >= 0)
          {
           

            if (BodyColor[0])
	    {
	      float rgb[3]; 


	      get_color((uchar *)BodyColor, rgb);

	      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);
	      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);
	      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);
	    }
	    else {
	      cmap[transparent][0] = 255;
              cmap[transparent][1] = 255;
              cmap[transparent][2] = 255;
	    }

           

            image_need_mask(img);
	  }

	  if (!load_data)
	    return (0);

          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));
          if (img->pixels == NULL)
            return (-1);

	  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));
    }
  }
}



typedef struct hd_jpeg_err_s	 {
  struct jpeg_error_mgr	jerr;	
  jmp_buf	retbuf;		
  char		message[JMSG_LENGTH_MAX];
				
} hd_jpeg_err_t;




static int			 image_load_jpeg(image_t *img, FILE    *fp, int     gray, int     load_data)



{
  struct jpeg_decompress_struct	cinfo;		
  hd_jpeg_err_t			jerr;		
JSAMPROW			row;		


  jpeg_std_error(&jerr.jerr);
  jerr.jerr.error_exit = jpeg_error_handler;

  if (setjmp(jerr.retbuf))
  {
    progress_error(HD_ERROR_BAD_FORMAT, "%s (%s)", jerr.message,  file_rlookup(img->filename));
    jpeg_destroy_decompress(&cinfo);
    return (-1);
  }

  cinfo.err = (struct jpeg_error_mgr *)&jerr;
  jpeg_create_decompress(&cinfo);
  jpeg_stdio_src(&cinfo, fp);
  jpeg_read_header(&cinfo, (boolean)1);

  cinfo.quantize_colors = FALSE;

  if (gray || cinfo.num_components == 1)
  {
    cinfo.out_color_space      = JCS_GRAYSCALE;
    cinfo.out_color_components = 1;
    cinfo.output_components    = 1;
  }
  else if (cinfo.num_components != 3)
  {
    jpeg_destroy_decompress(&cinfo);

    progress_error(HD_ERROR_BAD_FORMAT, "CMYK JPEG files are not supported! (%s)", file_rlookup(img->filename));

    return (-1);
  }
  else {
    cinfo.out_color_space      = JCS_RGB;
    cinfo.out_color_components = 3;
    cinfo.output_components    = 3;
  }

  jpeg_calc_output_dimensions(&cinfo);

  img->width  = (int)cinfo.output_width;
  img->height = (int)cinfo.output_height;
  img->depth  = (int)cinfo.output_components;

  if (!load_data)
  {
    jpeg_destroy_decompress(&cinfo);
    return (0);
  }

  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));

  if (img->pixels == NULL)
  {
    jpeg_destroy_decompress(&cinfo);
    return (-1);
  }

  jpeg_start_decompress(&cinfo);

  while (cinfo.output_scanline < cinfo.output_height)
  {
    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);
    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);
  }

  jpeg_finish_decompress(&cinfo);
  jpeg_destroy_decompress(&cinfo);

  return (0);
}






static int			 image_load_png(image_t *img, FILE    *fp, int     gray, int     load_data)



{
  int		i, j;		
  png_structp	pp;		
  png_infop	info;		
  int		depth;		
  png_bytep	*rows = NULL;	
  uchar		*inptr,		 *outptr;
  int		color_type,	 bit_depth;


 

  pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
  if (!pp)
  {
    progress_error(HD_ERROR_OUT_OF_MEMORY, "Unable to allocate memory for PNG file: %s", strerror(errno));
    return (-1);
  }

  info = png_create_info_struct(pp);
  if (!info)
  {
    progress_error(HD_ERROR_OUT_OF_MEMORY, "Unable to allocate memory for PNG info: %s", strerror(errno));

    png_destroy_read_struct(&pp, NULL, NULL);

    return (-1);
  }

  if (setjmp(png_jmpbuf(pp)))
  {
    progress_error(HD_ERROR_BAD_FORMAT, "PNG file contains errors!");

    png_destroy_read_struct(&pp, &info, NULL);

    if (img != NULL)
    {
      free(img->pixels);
      img->pixels = NULL;
    }

    free(rows);
    rows = NULL;

    return (-1);
  }

 

  png_init_io(pp, fp);


  
  png_set_option(pp, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);


 

  png_read_info(pp, info);

  bit_depth  = png_get_bit_depth(pp, info);
  color_type = png_get_color_type(pp, info);

  if (png_get_valid(pp, info, PNG_INFO_tRNS))
  {
    png_set_tRNS_to_alpha(pp);
    color_type |= PNG_COLOR_MASK_ALPHA;
  }

  if (color_type & PNG_COLOR_MASK_PALETTE)
  {
    png_set_palette_to_rgb(pp);

    
    
    if (Encryption)
      img->use ++;
  }
  else if (!(color_type & PNG_COLOR_MASK_COLOR) && bit_depth < 8)
  {
    png_set_expand_gray_1_2_4_to_8(pp);
  }
  else if (bit_depth == 16)
  {

    png_set_scale_16(pp);

    png_set_strip_16(pp);

  }

  if (color_type & PNG_COLOR_MASK_COLOR)
  {
    depth      = 3;
    img->depth = gray ? 1 : 3;
  }
  else {
    depth      = 1;
    img->depth = 1;
  }

  img->width  = (int)png_get_image_width(pp, info);
  img->height = (int)png_get_image_height(pp, info);

  if (color_type & PNG_COLOR_MASK_ALPHA)
  {
    if ((PSLevel == 0 && PDFVersion >= 14) || PSLevel == 3)
      image_need_mask(img, 8);
    else if (PSLevel == 0 && PDFVersion == 13)
      image_need_mask(img, 2);
    else image_need_mask(img);

    depth ++;
  }


  printf("bit_depth=%d, color_type=0x%04x, depth=%d, img->width=%d, img->height=%d, img->depth=%d\n", bit_depth, color_type, depth, img->width, img->height, img->depth);
  if (color_type & PNG_COLOR_MASK_COLOR)
    puts("    COLOR");
  else puts("    GRAYSCALE");
  if (color_type & PNG_COLOR_MASK_ALPHA)
    puts("    ALPHA");
  if (color_type & PNG_COLOR_MASK_PALETTE)
    puts("    PALETTE");


  if (!load_data)
  {
    png_destroy_read_struct(&pp, &info, NULL);
    return (0);
  }

  img->pixels = (uchar *)calloc(1, (size_t)(img->width * img->height * depth));

 

  rows = (png_bytep *)calloc(png_get_image_height(pp, info), sizeof(png_bytep));

  for (i = 0; i < (int)png_get_image_height(pp, info); i ++)
    rows[i] = img->pixels + i * img->width * depth;

 

  for (i = png_set_interlace_handling(pp); i > 0; i --)
    png_read_rows(pp, rows, NULL, (png_uint_32)img->height);

 

  if (color_type & PNG_COLOR_MASK_ALPHA)
  {

    for (inptr = img->pixels, i = 0; i < img->height; i ++)
    {
      for (j = 0; j < img->width; j ++, inptr += depth)
        switch (depth)
	{
	  case 2 :
	      printf(" %02X%02X", inptr[0], inptr[1]);
	      break;
	  case 4 :
	      printf(" %02X%02X%02X%02X", inptr[0], inptr[1], inptr[2], inptr[3]);
	      break;
	}

      putchar('\n');
    }


    for (inptr = img->pixels + depth - 1, i = 0; i < img->height; i ++)
      for (j = 0; j < img->width; j ++, inptr += depth)
        image_set_mask(img, j, i, *inptr);
  }

 

  if (gray && (color_type & PNG_COLOR_MASK_COLOR))
  {
   

    for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;
         i > 0;
         inptr += depth, outptr ++, i --)
      *outptr = (31 * inptr[0] + 61 * inptr[1] + 8 * inptr[2]) / 100;
  }
  else if (img->depth != depth)
  {
   

    if (depth == 4)
    {
      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;
           i > 0;
           inptr ++, i --)
      {
        *outptr++ = *inptr++;
        *outptr++ = *inptr++;
        *outptr++ = *inptr++;
      }
    }
    else {
      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;
           i > 0;
           inptr ++, i --)
        *outptr++ = *inptr++;
    }
  }

 

  png_read_end(pp, info);
  png_destroy_read_struct(&pp, &info, NULL);

  free(rows);

  return (0);
}





static void image_need_mask(image_t *img, int     scaling)

{
  size_t	size;			


  if (img == NULL || img->mask != NULL)
    return;

 

  img->maskscale = scaling;

  if (scaling == 8)
  {
    
    img->maskwidth = img->width;
    size           = (size_t)(img->width * img->height);
  }
  else {
    
    img->maskwidth = (img->width * scaling + 7) / 8;
    size           = (size_t)(img->maskwidth * img->height * scaling + 1);
  }

  img->mask = (uchar *)calloc(size, 1);
}




static void image_set_mask(image_t *img, int     x, int     y, uchar   alpha)



{
  int		i, j;		
  uchar		*maskptr;	
  static uchar	masks[8] =	 {
		  0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

  static uchar	dither[4][4] =  {
		  { 0,  2,  15, 6 }, { 4,  12, 9,  11 }, { 14, 7,  1,  3 }, { 8,  10, 5,  13 }


	        };


  if (img == NULL || img->mask == NULL || x < 0 || x >= img->width || y < 0 || y >= img->height)
    return;

  if (img->maskscale == 8)
  {
    
    if (PSLevel)
      img->mask[y * img->maskwidth + x] = 255 - alpha;
    else img->mask[y * img->maskwidth + x] = alpha;
  }
  else {
    
    x *= img->maskscale;
    y *= img->maskscale;
    alpha >>= 4;

    for (i = 0; i < img->maskscale; i ++, y ++, x -= img->maskscale)
      for (j = 0; j < img->maskscale; j ++, x ++)
      {
	maskptr  = img->mask + y * img->maskwidth + x / 8;
	if (alpha <= dither[x & 3][y & 3])
	  *maskptr |= masks[x & 7];
      }
  }
}




void image_unload(image_t *img)
{
  if (!img)
    return;

  if (!img->use || !img->pixels)
    return;

  if (img->obj)
    img->use = 0;
  else img->use --;

  if (img->use)
    return;

  free(img->pixels);
  img->pixels = NULL;
}





static void jpeg_error_handler(j_common_ptr p)
{
  hd_jpeg_err_t	*jerr = (hd_jpeg_err_t *)p->err;
					


  
  (jerr->jerr.format_message)(p, jerr->message);

  
  longjmp(jerr->retbuf, 1);
}





static unsigned short      read_word(FILE *fp)
{
  unsigned char b0, b1; 

  b0 = (uchar)getc(fp);
  b1 = (uchar)getc(fp);

  return (unsigned short)((b1 << 8) | b0);
}




static unsigned int                read_dword(FILE *fp)
{
  unsigned char b0, b1, b2, b3; 

  b0 = (uchar)getc(fp);
  b1 = (uchar)getc(fp);
  b2 = (uchar)getc(fp);
  b3 = (uchar)getc(fp);

  return (unsigned)((((((b3 << 8) | b2) << 8) | b1) << 8) | b0);
}




static int                         read_long(FILE *fp)
{
  unsigned char b0, b1, b2, b3; 

  b0 = (uchar)getc(fp);
  b1 = (uchar)getc(fp);
  b2 = (uchar)getc(fp);
  b3 = (uchar)getc(fp);

  return ((int)(((((b3 << 8) | b2) << 8) | b1) << 8) | b0);
}
