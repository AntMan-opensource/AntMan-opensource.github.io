















tcpr_list_t * new_list()
{
    tcpr_list_t *newlist;

    newlist = (tcpr_list_t *)safe_malloc(sizeof(tcpr_list_t));
    return (newlist);
}


int parse_list(tcpr_list_t ** listdata, char *ourstr)
{
    tcpr_list_t *listcur, *list_ptr;
    char *this = NULL;
    char *first, *second;
    int rcode;
    regex_t preg;
    char regex[] = "^[0-9]+(-[0-9]+)?$";
    char *token = NULL;
    u_int i;


    
    if ((rcode = regcomp(&preg, regex, REG_EXTENDED | REG_NOSUB)) != 0) {
        char ebuf[EBUF_SIZE];
        regerror(rcode, &preg, ebuf, sizeof(ebuf));
        errx(-1, "Unable to compile regex (%s): %s", regex, ebuf);
    }

    
    this = strtok_r(ourstr, ",", &token);
    first = this;
    second = NULL;

    
    if (regexec(&preg, this, 0, NULL, 0) != 0) {
        warnx("Unable to parse: %s", this);
        regfree(&preg);
        return 0;
    }

    *listdata = new_list();
    list_ptr = *listdata;
    listcur = list_ptr;

    for (i = 0; i < strlen(this); i++) {
        if (this[i] == '-') {
            this[i] = '\0';
            second = &this[i + 1];
        }
    }

    list_ptr->min = strtoull(first, NULL, 0);
    if (second != NULL) {
        list_ptr->max = strtoull(second, NULL, 0);
    }
    else {
        list_ptr->max = list_ptr->min;
    }

    while (1) {
        this = strtok_r(NULL, ",", &token);
        if (this == NULL)
            break;

        first = this;
        second = NULL;


        
        if (regexec(&preg, this, 0, NULL, 0) != 0) {
            warnx("Unable to parse: %s", this);
            regfree(&preg);
            return 0;
        }

        listcur->next = new_list();
        listcur = listcur->next;

        for (i = 0; i < strlen(this); i++) {
            if (this[i] == '-') {
                this[i] = '\0';
                second = &this[i + 1];
            }
        }

        listcur->min = strtoull(first, NULL, 0);
        if (second != NULL) {
            listcur->max = strtoull(second, NULL, 0);
        }
        else {
            listcur->max = listcur->min;
        }

    }

    regfree(&preg);

    return 1;
}




tcpr_dir_t check_list(tcpr_list_t * list, COUNTER value)
{
    tcpr_list_t *current;
    current = list;

    do {
        if ((current->min != 0) && (current->max != 0)) {
            if ((value >= current->min) && (value <= current->max))
                return 1;
        } else if (current->min == 0) {
            if (value <= current->max)
                return 1;
        } else if (current->max == 0) {
            if (value >= current->min)
                return 1;
        }

        if (current->next != NULL)
            current = current->next;
        else current = NULL;
    } while (current != NULL);

    return 0;
}



void free_list(tcpr_list_t * list)
{

    
    if (list->next != NULL)
        free_list(list->next);

    safe_free(list);
}
