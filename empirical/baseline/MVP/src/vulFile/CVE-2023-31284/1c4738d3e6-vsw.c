




















































static	int vsw_attach(dev_info_t *, ddi_attach_cmd_t);
static	int vsw_detach(dev_info_t *, ddi_detach_cmd_t);
static	int vsw_unattach(vsw_t *vswp);
static	int vsw_get_md_physname(vsw_t *, md_t *, mde_cookie_t, char *);
static	int vsw_get_md_smodes(vsw_t *, md_t *, mde_cookie_t, uint8_t *);
void vsw_destroy_rxpools(void *);


static	int vsw_mdeg_register(vsw_t *vswp);
static	void vsw_mdeg_unregister(vsw_t *vswp);
static	int vsw_mdeg_cb(void *cb_argp, mdeg_result_t *);
static	int vsw_port_mdeg_cb(void *cb_argp, mdeg_result_t *);
static	int vsw_get_initial_md_properties(vsw_t *vswp, md_t *, mde_cookie_t);
static	int vsw_read_mdprops(vsw_t *vswp);
static	void vsw_vlan_read_ids(void *arg, int type, md_t *mdp, mde_cookie_t node, uint16_t *pvidp, vsw_vlanid_t **vidspp, uint16_t *nvidsp, uint16_t *default_idp);

static	void vsw_port_read_bandwidth(vsw_port_t *portp, md_t *mdp, mde_cookie_t node, uint64_t *bw);
static	int vsw_port_read_props(vsw_port_t *portp, vsw_t *vswp, md_t *mdp, mde_cookie_t *node);
static	void vsw_read_pri_eth_types(vsw_t *vswp, md_t *mdp, mde_cookie_t node);
static	void vsw_mtu_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, uint32_t *mtu);
static	int vsw_mtu_update(vsw_t *vswp, uint32_t mtu);
static	void vsw_linkprop_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, boolean_t *pls);
static	void vsw_bandwidth_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, uint64_t *bw);
static	void vsw_update_md_prop(vsw_t *, md_t *, mde_cookie_t);
static void vsw_save_lmacaddr(vsw_t *vswp, uint64_t macaddr);
static boolean_t vsw_cmp_vids(vsw_vlanid_t *vids1, vsw_vlanid_t *vids2, int nvids);


static int vsw_mac_register(vsw_t *);
static int vsw_mac_unregister(vsw_t *);
static int vsw_m_stat(void *, uint_t, uint64_t *);
static void vsw_m_stop(void *arg);
static int vsw_m_start(void *arg);
static int vsw_m_unicst(void *arg, const uint8_t *);
static int vsw_m_multicst(void *arg, boolean_t, const uint8_t *);
static int vsw_m_promisc(void *arg, boolean_t);
static mblk_t *vsw_m_tx(void *arg, mblk_t *);
void vsw_mac_link_update(vsw_t *vswp, link_state_t link_state);
void vsw_mac_rx(vsw_t *vswp, mac_resource_handle_t mrh, mblk_t *mp, vsw_macrx_flags_t flags);
void vsw_physlink_state_update(vsw_t *vswp);


extern void vsw_setup_switching_thread(void *arg);
extern int vsw_setup_switching_start(vsw_t *vswp);
extern void vsw_setup_switching_stop(vsw_t *vswp);
extern int vsw_setup_switching(vsw_t *);
extern void vsw_switch_frame_nop(vsw_t *vswp, mblk_t *mp, int caller, vsw_port_t *port, mac_resource_handle_t mrh);
extern int vsw_add_mcst(vsw_t *, uint8_t, uint64_t, void *);
extern int vsw_del_mcst(vsw_t *, uint8_t, uint64_t, void *);
extern void vsw_del_mcst_vsw(vsw_t *);
extern mcst_addr_t *vsw_del_addr(uint8_t devtype, void *arg, uint64_t addr);
extern void vsw_detach_ports(vsw_t *vswp);
extern int vsw_port_add(vsw_t *vswp, md_t *mdp, mde_cookie_t *node);
extern int vsw_port_detach(vsw_t *vswp, int p_instance);
static int vsw_port_update(vsw_t *vswp, md_t *curr_mdp, mde_cookie_t curr_mdex, md_t *prev_mdp, mde_cookie_t prev_mdex);
extern	int vsw_port_attach(vsw_port_t *port);
extern vsw_port_t *vsw_lookup_port(vsw_t *vswp, int p_instance);
extern int vsw_mac_open(vsw_t *vswp);
extern void vsw_mac_close(vsw_t *vswp);
extern void vsw_mac_cleanup_ports(vsw_t *vswp);
extern void vsw_unset_addrs(vsw_t *vswp);
extern void vsw_setup_switching_post_process(vsw_t *vswp);
extern void vsw_create_vlans(void *arg, int type);
extern void vsw_destroy_vlans(void *arg, int type);
extern void vsw_vlan_add_ids(void *arg, int type);
extern void vsw_vlan_remove_ids(void *arg, int type);
extern void vsw_vlan_unaware_port_reset(vsw_port_t *portp);
extern uint32_t vsw_vlan_frame_untag(void *arg, int type, mblk_t **np, mblk_t **npt);
extern mblk_t *vsw_vlan_frame_pretag(void *arg, int type, mblk_t *mp);
extern void vsw_hio_cleanup(vsw_t *vswp);
extern void vsw_hio_start_ports(vsw_t *vswp);
extern void vsw_hio_port_update(vsw_port_t *portp, boolean_t hio_enabled);
extern int vsw_mac_multicast_add(vsw_t *, vsw_port_t *, mcst_addr_t *, int);
extern void vsw_mac_multicast_remove(vsw_t *, vsw_port_t *, mcst_addr_t *, int);
extern void vsw_mac_port_reconfig_vlans(vsw_port_t *portp, uint16_t new_pvid, vsw_vlanid_t *new_vids, int new_nvids);
extern int vsw_mac_client_init(vsw_t *vswp, vsw_port_t *port, int type);
extern void vsw_mac_client_cleanup(vsw_t *vswp, vsw_port_t *port, int type);
extern void vsw_if_mac_reconfig(vsw_t *vswp, boolean_t update_vlans, uint16_t new_pvid, vsw_vlanid_t *new_vids, int new_nvids);
extern void vsw_reset_ports(vsw_t *vswp);
extern void vsw_port_reset(vsw_port_t *portp);
extern void vsw_physlink_update_ports(vsw_t *vswp);
extern void vsw_update_bandwidth(vsw_t *vswp, vsw_port_t *port, int type, uint64_t maxbw);


int	vsw_num_handshakes = VNET_NUM_HANDSHAKES; 
int	vsw_wretries = 100;		
int	vsw_setup_switching_delay = 3;	
int	vsw_mac_open_retries = 300;	
					
int	vsw_ldc_tx_delay = 5;		
int	vsw_ldc_tx_retries = 10;	
int	vsw_ldc_retries = 5;		
int	vsw_ldc_delay = 1000;		
boolean_t vsw_ldc_rxthr_enabled = B_TRUE;	
boolean_t vsw_ldc_txthr_enabled = B_TRUE;	
int	vsw_rxpool_cleanup_delay = 100000;	


uint32_t	vsw_fdb_nchains = 8;	
uint32_t	vsw_vlan_nchains = 4;	
uint32_t	vsw_ethermtu = 1500;	


uint32_t vsw_fdbe_refcnt_delay = 10;


uint16_t	vsw_default_vlan_id = 1;


boolean_t vsw_obp_ver_proto_workaround = B_TRUE;


uint64_t vsw_pri_eth_type = 0;


uint32_t vsw_pri_tx_nmblks = 64;


uint32_t vsw_publish_macaddr_count = 3;


boolean_t vsw_hio_enabled = B_TRUE;


int vsw_hio_max_cleanup_retries = 10;


int vsw_hio_cleanup_delay = 10000;




uint32_t vsw_num_descriptors = VSW_NUM_DESCRIPTORS;


uint32_t vsw_nrbufs_factor = 2;


int	vsw_recv_delay = 0;


int	vsw_recv_retries = 5;


uint32_t vsw_chain_len = (VSW_NUM_MBLKS * 0.6);


uint32_t vsw_mblk_size1 = 0;
uint32_t vsw_mblk_size2 = 0;
uint32_t vsw_mblk_size3 = 0;
uint32_t vsw_mblk_size4 = 0;
uint32_t vsw_num_mblks1 = VSW_NUM_MBLKS;	
uint32_t vsw_num_mblks2 = VSW_NUM_MBLKS;	
uint32_t vsw_num_mblks3 = VSW_NUM_MBLKS;	
uint32_t vsw_num_mblks4 = VSW_NUM_MBLKS;	


boolean_t vsw_jumbo_rxpools = B_FALSE;


uint32_t vsw_max_tx_qcount = 4 * VSW_NUM_DESCRIPTORS;


static	mac_callbacks_t	vsw_m_callbacks = {
	0, vsw_m_stat, vsw_m_start, vsw_m_stop, vsw_m_promisc, vsw_m_multicst, vsw_m_unicst, vsw_m_tx };








static	struct	cb_ops	vsw_cb_ops = {
	nulldev,			 nulldev, nodev, nodev, nodev, nodev, nodev, nodev, nodev, nodev, nodev, nochpoll, ddi_prop_op, NULL, D_MP, CB_REV, nodev, nodev };


















static	struct	dev_ops	vsw_ops = {
	DEVO_REV,		 0, NULL, nulldev, nulldev, vsw_attach, vsw_detach, nodev, &vsw_cb_ops, (struct bus_ops *)NULL, ddi_power };











extern	struct	mod_ops	mod_driverops;
static struct modldrv vswmodldrv = {
	&mod_driverops, "sun4v Virtual Switch", &vsw_ops, };











static void	*vsw_state;


vsw_t		*vsw_head = NULL;
krwlock_t	vsw_rw;


static char vdev_propname[] = "virtual-device";
static char vsw_propname[] = "virtual-network-switch";
static char physdev_propname[] = "vsw-phys-dev";
static char smode_propname[] = "vsw-switch-mode";
static char macaddr_propname[] = "local-mac-address";
static char remaddr_propname[] = "remote-mac-address";
static char ldcids_propname[] = "ldc-ids";
static char chan_propname[] = "channel-endpoint";
static char id_propname[] = "id";
static char reg_propname[] = "reg";
static char pri_types_propname[] = "priority-ether-types";
static char vsw_pvid_propname[] = "port-vlan-id";
static char vsw_vid_propname[] = "vlan-id";
static char vsw_dvid_propname[] = "default-vlan-id";
static char port_pvid_propname[] = "remote-port-vlan-id";
static char port_vid_propname[] = "remote-vlan-id";
static char hybrid_propname[] = "hybrid";
static char vsw_mtu_propname[] = "mtu";
static char vsw_linkprop_propname[] = "linkprop";
static char vsw_maxbw_propname[] = "maxbw";
static char port_maxbw_propname[] = "maxbw";


static md_prop_match_t vport_prop_match[] = {
	{ MDET_PROP_VAL,    "id"   }, { MDET_LIST_END,    NULL    }
};

static mdeg_node_match_t vport_match = { "virtual-device-port", vport_prop_match };


static md_prop_match_t vdev_prop_match[] = {
	{ MDET_PROP_STR,    "name"   }, { MDET_PROP_VAL,    "cfg-handle" }, { MDET_LIST_END,    NULL    }

};

static mdeg_node_match_t vdev_match = { "virtual-device", vdev_prop_match };



static mdeg_prop_spec_t vsw_prop_template[] = {
	{ MDET_PROP_STR,    "name",		vsw_propname }, { MDET_PROP_VAL,    "cfg-handle",	NULL	}, { MDET_LIST_END,    NULL,		NULL	}

};





int vswdbg = 0x0;



void vswdebug(vsw_t *vswp, const char *fmt, ...)
{
	char buf[512];
	va_list ap;

	va_start(ap, fmt);
	(void) vsprintf(buf, fmt, ap);
	va_end(ap);

	if (vswp == NULL)
		cmn_err(CE_CONT, "%s\n", buf);
	else cmn_err(CE_CONT, "vsw%d: %s\n", vswp->instance, buf);
}



static struct modlinkage modlinkage = {
	MODREV_1, &vswmodldrv, NULL };



int _init(void)
{
	int status;

	rw_init(&vsw_rw, NULL, RW_DRIVER, NULL);

	status = ddi_soft_state_init(&vsw_state, sizeof (vsw_t), 1);
	if (status != 0) {
		return (status);
	}

	mac_init_ops(&vsw_ops, DRV_NAME);
	status = mod_install(&modlinkage);
	if (status != 0) {
		ddi_soft_state_fini(&vsw_state);
	}
	return (status);
}

int _fini(void)
{
	int status;

	status = mod_remove(&modlinkage);
	if (status != 0)
		return (status);
	mac_fini_ops(&vsw_ops);
	ddi_soft_state_fini(&vsw_state);

	rw_destroy(&vsw_rw);

	return (status);
}

int _info(struct modinfo *modinfop)
{
	return (mod_info(&modlinkage, modinfop));
}

static int vsw_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
	vsw_t			*vswp;
	int			instance;
	char			hashname[MAXNAMELEN];
	char			qname[TASKQ_NAMELEN];
	vsw_attach_progress_t	progress = PROG_init;
	int			rv;

	switch (cmd) {
	case DDI_ATTACH:
		break;
	case DDI_RESUME:
		
		return (DDI_SUCCESS);
	case DDI_PM_RESUME:
	default:
		return (DDI_FAILURE);
	}

	instance = ddi_get_instance(dip);
	if (ddi_soft_state_zalloc(vsw_state, instance) != DDI_SUCCESS) {
		DERR(NULL, "vsw%d: ddi_soft_state_zalloc failed", instance);
		return (DDI_FAILURE);
	}
	vswp = ddi_get_soft_state(vsw_state, instance);

	if (vswp == NULL) {
		DERR(NULL, "vsw%d: ddi_get_soft_state failed", instance);
		goto vsw_attach_fail;
	}

	vswp->dip = dip;
	vswp->instance = instance;
	vswp->phys_link_state = LINK_STATE_UNKNOWN;
	ddi_set_driver_private(dip, (caddr_t)vswp);

	mutex_init(&vswp->mac_lock, NULL, MUTEX_DRIVER, NULL);
	mutex_init(&vswp->mca_lock, NULL, MUTEX_DRIVER, NULL);
	mutex_init(&vswp->sw_thr_lock, NULL, MUTEX_DRIVER, NULL);
	cv_init(&vswp->sw_thr_cv, NULL, CV_DRIVER, NULL);
	rw_init(&vswp->maccl_rwlock, NULL, RW_DRIVER, NULL);
	rw_init(&vswp->if_lockrw, NULL, RW_DRIVER, NULL);
	rw_init(&vswp->mfdbrw, NULL, RW_DRIVER, NULL);
	rw_init(&vswp->plist.lockrw, NULL, RW_DRIVER, NULL);

	progress |= PROG_locks;

	rv = vsw_read_mdprops(vswp);
	if (rv != 0)
		goto vsw_attach_fail;

	progress |= PROG_readmd;

	
	(void) snprintf(hashname, MAXNAMELEN, "vsw_unicst_table-%d", vswp->instance);
	D2(vswp, "creating unicast hash table (%s)...", hashname);
	vswp->fdb_nchains = vsw_fdb_nchains;
	vswp->fdb_hashp = mod_hash_create_ptrhash(hashname, vswp->fdb_nchains, mod_hash_null_valdtor, sizeof (void *));
	vsw_create_vlans((void *)vswp, VSW_LOCALDEV);
	progress |= PROG_fdb;

	
	(void) snprintf(hashname, MAXNAMELEN, "vsw_mcst_table-%d", vswp->instance);
	D2(vswp, "creating multicast hash table %s)...", hashname);
	vswp->mfdb = mod_hash_create_ptrhash(hashname, vsw_fdb_nchains, mod_hash_null_valdtor, sizeof (void *));

	progress |= PROG_mfdb;

	
	(void) snprintf(qname, TASKQ_NAMELEN, "taskq%d", vswp->instance);
	if ((vswp->taskq_p = ddi_taskq_create(vswp->dip, qname, 1, TASKQ_DEFAULTPRI, 0)) == NULL) {
		cmn_err(CE_WARN, "!vsw%d: Unable to create task queue", vswp->instance);
		goto vsw_attach_fail;
	}

	progress |= PROG_taskq;

	(void) snprintf(qname, TASKQ_NAMELEN, "rxpool_taskq%d", vswp->instance);
	if ((vswp->rxp_taskq = ddi_taskq_create(vswp->dip, qname, 1, TASKQ_DEFAULTPRI, 0)) == NULL) {
		cmn_err(CE_WARN, "!vsw%d: Unable to create rxp task queue", vswp->instance);
		goto vsw_attach_fail;
	}

	progress |= PROG_rxp_taskq;

	
	if (ddi_prop_update_int(DDI_DEV_T_NONE, vswp->dip, DDI_NO_AUTODETACH, 1) != DDI_SUCCESS) {
		cmn_err(CE_NOTE, "!Unable to set \"%s\" property for " "instance %u", DDI_NO_AUTODETACH, instance);
	}

	
	vswp->vsw_switch_frame = vsw_switch_frame_nop;

	
	rv = vsw_setup_switching_start(vswp);
	if (rv != 0) {
		goto vsw_attach_fail;
	}

	progress |= PROG_swmode;

	
	rv = vsw_mac_register(vswp);
	if (rv != 0)
		goto vsw_attach_fail;

	progress |= PROG_macreg;

	
	rv = vsw_mdeg_register(vswp);
	if (rv != 0)
		goto vsw_attach_fail;

	progress |= PROG_mdreg;

	vswp->attach_progress = progress;

	WRITE_ENTER(&vsw_rw);
	vswp->next = vsw_head;
	vsw_head = vswp;
	RW_EXIT(&vsw_rw);

	ddi_report_dev(vswp->dip);
	return (DDI_SUCCESS);

vsw_attach_fail:
	DERR(NULL, "vsw_attach: failed");

	vswp->attach_progress = progress;
	(void) vsw_unattach(vswp);
	ddi_soft_state_free(vsw_state, instance);
	return (DDI_FAILURE);
}

static int vsw_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
	vsw_t			**vswpp, *vswp;
	int			instance;

	instance = ddi_get_instance(dip);
	vswp = ddi_get_soft_state(vsw_state, instance);

	if (vswp == NULL) {
		return (DDI_FAILURE);
	}

	switch (cmd) {
	case DDI_DETACH:
		break;
	case DDI_SUSPEND:
	case DDI_PM_SUSPEND:
	default:
		return (DDI_FAILURE);
	}

	D2(vswp, "detaching instance %d", instance);

	if (vsw_unattach(vswp) != 0) {
		return (DDI_FAILURE);
	}

	ddi_remove_minor_node(dip, NULL);

	WRITE_ENTER(&vsw_rw);
	for (vswpp = &vsw_head; *vswpp; vswpp = &(*vswpp)->next) {
		if (*vswpp == vswp) {
			*vswpp = vswp->next;
			break;
		}
	}
	RW_EXIT(&vsw_rw);

	ddi_soft_state_free(vsw_state, instance);

	return (DDI_SUCCESS);
}


static int vsw_unattach(vsw_t *vswp)
{
	vsw_attach_progress_t	progress;

	progress = vswp->attach_progress;

	
	if (progress & PROG_macreg) {
		if (vsw_mac_unregister(vswp) != 0) {
			cmn_err(CE_WARN, "!vsw%d: Unable to detach from " "MAC layer", vswp->instance);
			return (1);
		}
		progress &= ~PROG_macreg;
	}

	
	if (progress & PROG_mdreg) {
		vsw_mdeg_unregister(vswp);
		vsw_detach_ports(vswp);
		progress &= ~PROG_mdreg;
	}

	
	if (progress & PROG_swmode) {

		vsw_setup_switching_stop(vswp);

		if (vswp->hio_capable == B_TRUE) {
			vsw_hio_cleanup(vswp);
			vswp->hio_capable = B_FALSE;
		}

		mutex_enter(&vswp->mac_lock);
		vsw_mac_close(vswp);
		mutex_exit(&vswp->mac_lock);

		progress &= ~PROG_swmode;
	}

	
	if (progress & PROG_rxp_taskq) {
		ddi_taskq_destroy(vswp->rxp_taskq);
		progress &= ~PROG_rxp_taskq;
	}

	
	if (progress & PROG_taskq) {
		ddi_taskq_destroy(vswp->taskq_p);
		progress &= ~PROG_taskq;
	}

	
	if (progress & PROG_mfdb) {
		mod_hash_destroy_hash(vswp->mfdb);
		progress &= ~PROG_mfdb;
	}

	
	if (progress & PROG_fdb) {
		vsw_destroy_vlans(vswp, VSW_LOCALDEV);
		mod_hash_destroy_hash(vswp->fdb_hashp);
		progress &= ~PROG_fdb;
	}

	if (progress & PROG_readmd) {
		if (VSW_PRI_ETH_DEFINED(vswp)) {
			kmem_free(vswp->pri_types, sizeof (uint16_t) * vswp->pri_num_types);
			(void) vio_destroy_mblks(vswp->pri_tx_vmp);
		}
		progress &= ~PROG_readmd;
	}

	if (progress & PROG_locks) {
		rw_destroy(&vswp->plist.lockrw);
		rw_destroy(&vswp->mfdbrw);
		rw_destroy(&vswp->if_lockrw);
		rw_destroy(&vswp->maccl_rwlock);
		cv_destroy(&vswp->sw_thr_cv);
		mutex_destroy(&vswp->sw_thr_lock);
		mutex_destroy(&vswp->mca_lock);
		mutex_destroy(&vswp->mac_lock);
		progress &= ~PROG_locks;
	}

	vswp->attach_progress = progress;

	return (0);
}

void vsw_destroy_rxpools(void *arg)
{
	vio_mblk_pool_t	*poolp = (vio_mblk_pool_t *)arg;
	vio_mblk_pool_t	*npoolp;

	while (poolp != NULL) {
		npoolp =  poolp->nextp;
		while (vio_destroy_mblks(poolp) != 0) {
			delay(drv_usectohz(vsw_rxpool_cleanup_delay));
		}
		poolp = npoolp;
	}
}


static int vsw_get_md_physname(vsw_t *vswp, md_t *mdp, mde_cookie_t node, char *name)
{
	int		len = 0;
	int		instance;
	char		*physname = NULL;
	char		*dev;
	const char	*dev_name;
	char		myname[MAXNAMELEN];

	dev_name = ddi_driver_name(vswp->dip);
	instance = ddi_get_instance(vswp->dip);
	(void) snprintf(myname, MAXNAMELEN, "%s%d", dev_name, instance);

	if (md_get_prop_data(mdp, node, physdev_propname, (uint8_t **)(&physname), &len) != 0) {
		cmn_err(CE_WARN, "!vsw%d: Unable to get name(s) of physical " "device(s) from MD", vswp->instance);
		return (1);
	} else if ((strlen(physname) + 1) > LIFNAMSIZ) {
		cmn_err(CE_WARN, "!vsw%d: %s is too long a device name", vswp->instance, physname);
		return (1);
	} else if (strcmp(myname, physname) == 0) {
		
		cmn_err(CE_WARN, "!vsw%d: %s is an invalid device name", vswp->instance, physname);
		return (1);
	} else {
		(void) strncpy(name, physname, strlen(physname) + 1);
		D2(vswp, "%s: using first device specified (%s)", __func__, physname);
	}


	
	if (ddi_prop_lookup_string(DDI_DEV_T_ANY, vswp->dip, 0, "vsw_physname", &dev) == DDI_PROP_SUCCESS) {
		if ((strlen(dev) + 1) > LIFNAMSIZ) {
			cmn_err(CE_WARN, "vsw%d: %s is too long a device name", vswp->instance, dev);
			ddi_prop_free(dev);
			return (1);
		} else {
			cmn_err(CE_NOTE, "vsw%d: Using device name (%s) from " "config file", vswp->instance, dev);

			(void) strncpy(name, dev, strlen(dev) + 1);
		}

		ddi_prop_free(dev);
	}


	return (0);
}


static int vsw_get_md_smodes(vsw_t *vswp, md_t *mdp, mde_cookie_t node, uint8_t *mode)
{
	int		len = 0;
	char		*smode = NULL;
	char		*curr_mode = NULL;

	D1(vswp, "%s: enter", __func__);

	
	len = 0;
	if (md_get_prop_data(mdp, node, smode_propname, (uint8_t **)(&smode), &len) != 0) {
		
		cmn_err(CE_WARN, "!vsw%d: Unable to get switch mode property" " from the MD", vswp->instance);
		return (1);
	}

	curr_mode = smode;
	
	while (curr_mode < (smode + len)) {
		D2(vswp, "%s: curr_mode = [%s]", __func__, curr_mode);
		if (strcmp(curr_mode, "switched") == 0) {
			*mode = VSW_LAYER2;
		} else if (strcmp(curr_mode, "promiscuous") == 0) {
			*mode = VSW_LAYER2 | VSW_LAYER2_PROMISC;
		} else if (strcmp(curr_mode, "routed") == 0) {
			*mode = VSW_LAYER3;
		} else {
			cmn_err(CE_WARN, "!vsw%d: Unknown switch mode %s, " "setting to default switched mode", vswp->instance, curr_mode);

			*mode = VSW_LAYER2;
		}
		curr_mode += strlen(curr_mode) + 1;
	}

	D2(vswp, "%s: %d mode", __func__, *mode);

	D1(vswp, "%s: exit", __func__);

	return (0);
}


static int vsw_mac_register(vsw_t *vswp)
{
	mac_register_t	*macp;
	int		rv;

	D1(vswp, "%s: enter", __func__);

	if ((macp = mac_alloc(MAC_VERSION)) == NULL)
		return (EINVAL);
	macp->m_type_ident = MAC_PLUGIN_IDENT_ETHER;
	macp->m_driver = vswp;
	macp->m_dip = vswp->dip;
	macp->m_src_addr = (uint8_t *)&vswp->if_addr;
	macp->m_callbacks = &vsw_m_callbacks;
	macp->m_min_sdu = 0;
	macp->m_max_sdu = vswp->mtu;
	macp->m_margin = VLAN_TAGSZ;
	rv = mac_register(macp, &vswp->if_mh);
	mac_free(macp);
	if (rv != 0) {
		
		cmn_err(CE_NOTE, "!vsw%d: Unable to register as " "a provider with MAC layer", vswp->instance);
		return (rv);
	}

	vswp->if_state |= VSW_IF_REG;

	D1(vswp, "%s: exit", __func__);

	return (rv);
}

static int vsw_mac_unregister(vsw_t *vswp)
{
	int		rv = 0;

	D1(vswp, "%s: enter", __func__);

	WRITE_ENTER(&vswp->if_lockrw);

	if (vswp->if_state & VSW_IF_REG) {
		rv = mac_unregister(vswp->if_mh);
		if (rv != 0) {
			DWARN(vswp, "%s: unable to unregister from MAC " "framework", __func__);

			RW_EXIT(&vswp->if_lockrw);
			D1(vswp, "%s: fail exit", __func__);
			return (rv);
		}

		
		vswp->if_state &= ~(VSW_IF_UP | VSW_IF_REG);
	}
	RW_EXIT(&vswp->if_lockrw);

	D1(vswp, "%s: exit", __func__);

	return (rv);
}

static int vsw_m_stat(void *arg, uint_t stat, uint64_t *val)
{
	vsw_t			*vswp = (vsw_t *)arg;

	D1(vswp, "%s: enter", __func__);

	mutex_enter(&vswp->mac_lock);
	if (vswp->mh == NULL) {
		mutex_exit(&vswp->mac_lock);
		return (EINVAL);
	}

	
	*val = mac_stat_get(vswp->mh, stat);

	mutex_exit(&vswp->mac_lock);

	return (0);
}

static void vsw_m_stop(void *arg)
{
	vsw_t	*vswp = (vsw_t *)arg;

	D1(vswp, "%s: enter", __func__);

	WRITE_ENTER(&vswp->if_lockrw);
	vswp->if_state &= ~VSW_IF_UP;
	RW_EXIT(&vswp->if_lockrw);

	
	vsw_mac_client_cleanup(vswp, NULL, VSW_LOCALDEV);

	D1(vswp, "%s: exit (state = %d)", __func__, vswp->if_state);
}

static int vsw_m_start(void *arg)
{
	int		rv;
	vsw_t		*vswp = (vsw_t *)arg;

	D1(vswp, "%s: enter", __func__);

	WRITE_ENTER(&vswp->if_lockrw);

	vswp->if_state |= VSW_IF_UP;

	if (vswp->switching_setup_done == B_FALSE) {
		
		RW_EXIT(&vswp->if_lockrw);
		return (0);
	}

	
	if (vswp->mh != NULL) {
		
		rv = vsw_mac_client_init(vswp, NULL, VSW_LOCALDEV);
		if (rv != 0) {
			cmn_err(CE_NOTE, "!vsw%d: failed to program interface " "unicast address\n", vswp->instance);

		}
	}

	RW_EXIT(&vswp->if_lockrw);

	D1(vswp, "%s: exit (state = %d)", __func__, vswp->if_state);
	return (0);
}


static int vsw_m_unicst(void *arg, const uint8_t *macaddr)
{
	_NOTE(ARGUNUSED(arg, macaddr))

	return (DDI_FAILURE);
}

static int vsw_m_multicst(void *arg, boolean_t add, const uint8_t *mca)
{
	vsw_t		*vswp = (vsw_t *)arg;
	mcst_addr_t	*mcst_p = NULL;
	uint64_t	addr = 0x0;
	int		i, ret = 0;

	D1(vswp, "%s: enter", __func__);

	
	for (i = 0; i < ETHERADDRL; i++) {
		addr = (addr << 8) | mca[i];
	}

	D2(vswp, "%s: addr = 0x%llx", __func__, addr);

	if (add) {
		D2(vswp, "%s: adding multicast", __func__);
		if (vsw_add_mcst(vswp, VSW_LOCALDEV, addr, NULL) == 0) {
			
			mcst_p = kmem_zalloc(sizeof (mcst_addr_t), KM_NOSLEEP);
			if (mcst_p == NULL) {
				DERR(vswp, "%s unable to alloc mem", __func__);
				(void) vsw_del_mcst(vswp, VSW_LOCALDEV, addr, NULL);
				return (1);
			}
			mcst_p->addr = addr;
			ether_copy(mca, &mcst_p->mca);

			
			ret = vsw_mac_multicast_add(vswp, NULL, mcst_p, VSW_LOCALDEV);
			if (ret != 0) {
				(void) vsw_del_mcst(vswp, VSW_LOCALDEV, addr, NULL);
				kmem_free(mcst_p, sizeof (*mcst_p));
				return (ret);
			}

			mutex_enter(&vswp->mca_lock);
			mcst_p->nextp = vswp->mcap;
			vswp->mcap = mcst_p;
			mutex_exit(&vswp->mca_lock);
		} else {
			cmn_err(CE_WARN, "!vsw%d: unable to add multicast " "address", vswp->instance);
		}
		return (ret);
	}

	D2(vswp, "%s: removing multicast", __func__);
	
	if (vsw_del_mcst(vswp, VSW_LOCALDEV, addr, NULL) == 0) {

		
		mcst_p = vsw_del_addr(VSW_LOCALDEV, vswp, addr);
		ASSERT(mcst_p != NULL);

		vsw_mac_multicast_remove(vswp, NULL, mcst_p, VSW_LOCALDEV);
		kmem_free(mcst_p, sizeof (*mcst_p));
	}

	D1(vswp, "%s: exit", __func__);

	return (0);
}

static int vsw_m_promisc(void *arg, boolean_t on)
{
	vsw_t		*vswp = (vsw_t *)arg;

	D1(vswp, "%s: enter", __func__);

	WRITE_ENTER(&vswp->if_lockrw);
	if (on)
		vswp->if_state |= VSW_IF_PROMISC;
	else vswp->if_state &= ~VSW_IF_PROMISC;
	RW_EXIT(&vswp->if_lockrw);

	D1(vswp, "%s: exit", __func__);

	return (0);
}

static mblk_t * vsw_m_tx(void *arg, mblk_t *mp)
{
	vsw_t		*vswp = (vsw_t *)arg;

	D1(vswp, "%s: enter", __func__);

	mp = vsw_vlan_frame_pretag(vswp, VSW_LOCALDEV, mp);

	if (mp == NULL) {
		return (NULL);
	}

	vswp->vsw_switch_frame(vswp, mp, VSW_LOCALDEV, NULL, NULL);

	D1(vswp, "%s: exit", __func__);

	return (NULL);
}


static int vsw_mdeg_register(vsw_t *vswp)
{
	mdeg_prop_spec_t	*pspecp;
	mdeg_node_spec_t	*inst_specp;
	mdeg_handle_t		mdeg_hdl, mdeg_port_hdl;
	size_t			templatesz;
	int			rv;

	D1(vswp, "%s: enter", __func__);

	
	templatesz = sizeof (vsw_prop_template);
	pspecp = kmem_zalloc(templatesz, KM_SLEEP);

	bcopy(vsw_prop_template, pspecp, templatesz);

	VSW_SET_MDEG_PROP_INST(pspecp, vswp->regprop);

	
	inst_specp = kmem_zalloc(sizeof (mdeg_node_spec_t), KM_SLEEP);
	inst_specp->namep = "virtual-device";
	inst_specp->specp = pspecp;

	D2(vswp, "%s: instance %d registering with mdeg", __func__, vswp->regprop);
	
	rv = mdeg_register(inst_specp, &vdev_match, vsw_mdeg_cb, (void *)vswp, &mdeg_hdl);
	if (rv != MDEG_SUCCESS) {
		DERR(vswp, "%s: mdeg_register failed (%d) for vsw node", __func__, rv);
		goto mdeg_reg_fail;
	}

	
	rv = mdeg_register(inst_specp, &vport_match, vsw_port_mdeg_cb, (void *)vswp, &mdeg_port_hdl);
	if (rv != MDEG_SUCCESS) {
		DERR(vswp, "%s: mdeg_register failed (%d)\n", __func__, rv);
		(void) mdeg_unregister(mdeg_hdl);
		goto mdeg_reg_fail;
	}

	
	vswp->inst_spec = inst_specp;
	vswp->mdeg_hdl = mdeg_hdl;
	vswp->mdeg_port_hdl = mdeg_port_hdl;

	D1(vswp, "%s: exit", __func__);
	return (0);

mdeg_reg_fail:
	cmn_err(CE_WARN, "!vsw%d: Unable to register MDEG callbacks", vswp->instance);
	kmem_free(pspecp, templatesz);
	kmem_free(inst_specp, sizeof (mdeg_node_spec_t));

	vswp->mdeg_hdl = 0;
	vswp->mdeg_port_hdl = 0;

	return (1);
}

static void vsw_mdeg_unregister(vsw_t *vswp)
{
	D1(vswp, "vsw_mdeg_unregister: enter");

	if (vswp->mdeg_hdl != 0)
		(void) mdeg_unregister(vswp->mdeg_hdl);

	if (vswp->mdeg_port_hdl != 0)
		(void) mdeg_unregister(vswp->mdeg_port_hdl);

	if (vswp->inst_spec != NULL) {
		if (vswp->inst_spec->specp != NULL) {
			(void) kmem_free(vswp->inst_spec->specp, sizeof (vsw_prop_template));
			vswp->inst_spec->specp = NULL;
		}

		(void) kmem_free(vswp->inst_spec, sizeof (mdeg_node_spec_t));
		vswp->inst_spec = NULL;
	}

	D1(vswp, "vsw_mdeg_unregister: exit");
}


static int vsw_mdeg_cb(void *cb_argp, mdeg_result_t *resp)
{
	vsw_t		*vswp;
	md_t		*mdp;
	mde_cookie_t	node;
	uint64_t	inst;
	char		*node_name = NULL;

	if (resp == NULL)
		return (MDEG_FAILURE);

	vswp = (vsw_t *)cb_argp;

	D1(vswp, "%s: added %d : removed %d : curr matched %d" " : prev matched %d", __func__, resp->added.nelem, resp->removed.nelem, resp->match_curr.nelem, resp->match_prev.nelem);



	
	if (resp->added.nelem != 0) {

		if (resp->added.nelem != 1) {
			cmn_err(CE_NOTE, "!vsw%d: number of nodes added " "invalid: %d\n", vswp->instance, resp->added.nelem);
			return (MDEG_FAILURE);
		}

		mdp = resp->added.mdp;
		node = resp->added.mdep[0];

	} else if (resp->match_curr.nelem != 0) {

		if (resp->match_curr.nelem != 1) {
			cmn_err(CE_NOTE, "!vsw%d: number of nodes updated " "invalid: %d\n", vswp->instance, resp->match_curr.nelem);

			return (MDEG_FAILURE);
		}

		mdp = resp->match_curr.mdp;
		node = resp->match_curr.mdep[0];

	} else {
		return (MDEG_FAILURE);
	}

	
	if (md_get_prop_str(mdp, node, "name", &node_name) != 0) {
		DERR(vswp, "%s: unable to get node name\n",  __func__);
		return (MDEG_FAILURE);
	}

	
	if (strcmp(node_name, vsw_propname) != 0) {
		DERR(vswp, "%s: Invalid node name: %s\n", __func__, node_name);
		return (MDEG_FAILURE);
	}

	if (md_get_prop_val(mdp, node, "cfg-handle", &inst)) {
		DERR(vswp, "%s: prop(cfg-handle) not found\n", __func__);
		return (MDEG_FAILURE);
	}

	
	if (inst != vswp->regprop) {
		DERR(vswp, "%s: Invalid cfg-handle: %lx\n", __func__, inst);
		return (MDEG_FAILURE);
	}

	vsw_update_md_prop(vswp, mdp, node);

	return (MDEG_SUCCESS);
}


static int vsw_port_mdeg_cb(void *cb_argp, mdeg_result_t *resp)
{
	vsw_t		*vswp;
	int		idx;
	md_t		*mdp;
	mde_cookie_t	node;
	uint64_t	inst;
	int		rv;

	if ((resp == NULL) || (cb_argp == NULL))
		return (MDEG_FAILURE);

	vswp = (vsw_t *)cb_argp;

	D2(vswp, "%s: added %d : removed %d : curr matched %d" " : prev matched %d", __func__, resp->added.nelem, resp->removed.nelem, resp->match_curr.nelem, resp->match_prev.nelem);



	
	for (idx = 0; idx < resp->added.nelem; idx++) {
		mdp = resp->added.mdp;
		node = resp->added.mdep[idx];

		D2(vswp, "%s: adding node(%d) 0x%lx", __func__, idx, node);

		if ((rv = vsw_port_add(vswp, mdp, &node)) != 0) {
			cmn_err(CE_WARN, "!vsw%d: Unable to add new port " "(0x%lx), err=%d", vswp->instance, node, rv);
		}
	}

	
	for (idx = 0; idx < resp->removed.nelem; idx++) {
		mdp = resp->removed.mdp;
		node = resp->removed.mdep[idx];

		if (md_get_prop_val(mdp, node, id_propname, &inst)) {
			DERR(vswp, "%s: prop(%s) not found in port(%d)", __func__, id_propname, idx);
			continue;
		}

		D2(vswp, "%s: removing node(%d) 0x%lx", __func__, idx, node);

		if (vsw_port_detach(vswp, inst) != 0) {
			cmn_err(CE_WARN, "!vsw%d: Unable to remove port %ld", vswp->instance, inst);
		}
	}

	for (idx = 0; idx < resp->match_curr.nelem; idx++) {
		(void) vsw_port_update(vswp, resp->match_curr.mdp, resp->match_curr.mdep[idx], resp->match_prev.mdp, resp->match_prev.mdep[idx]);


	}

	D1(vswp, "%s: exit", __func__);

	return (MDEG_SUCCESS);
}


static int vsw_read_mdprops(vsw_t *vswp)
{
	md_t		*mdp = NULL;
	mde_cookie_t	rootnode;
	mde_cookie_t	*listp = NULL;
	uint64_t	inst;
	uint64_t	cfgh;
	char		*name;
	int		rv = 1;
	int		num_nodes = 0;
	int		num_devs = 0;
	int		listsz = 0;
	int		i;

	
	inst = ddi_prop_get_int(DDI_DEV_T_ANY, vswp->dip, DDI_PROP_DONTPASS, reg_propname, -1);
	if (inst == -1) {
		cmn_err(CE_NOTE, "!vsw%d: Unable to read %s property from " "OBP device tree", vswp->instance, reg_propname);
		return (rv);
	}

	vswp->regprop = inst;

	if ((mdp = md_get_handle()) == NULL) {
		DWARN(vswp, "%s: cannot init MD\n", __func__);
		return (rv);
	}

	num_nodes = md_node_count(mdp);
	ASSERT(num_nodes > 0);

	listsz = num_nodes * sizeof (mde_cookie_t);
	listp = (mde_cookie_t *)kmem_zalloc(listsz, KM_SLEEP);

	rootnode = md_root_node(mdp);

	
	num_devs = md_scan_dag(mdp, rootnode, md_find_name(mdp, vdev_propname), md_find_name(mdp, "fwd"), listp);

	if (num_devs <= 0) {
		DWARN(vswp, "%s: invalid num_devs:%d\n", __func__, num_devs);
		goto vsw_readmd_exit;
	}

	
	for (i = 0; i < num_devs; i++) {

		if (md_get_prop_str(mdp, listp[i], "name", &name) != 0) {
			DWARN(vswp, "%s: name property not found\n", __func__);
			goto vsw_readmd_exit;
		}

		
		if (strcmp(name, vsw_propname) != 0)
			continue;

		if (md_get_prop_val(mdp, listp[i], "cfg-handle", &cfgh) != 0) {
			DWARN(vswp, "%s: cfg-handle property not found\n", __func__);
			goto vsw_readmd_exit;
		}

		
		if (inst != cfgh)
			continue;

		
		rv = vsw_get_initial_md_properties(vswp, mdp, listp[i]);
		break;
	}

vsw_readmd_exit:

	kmem_free(listp, listsz);
	(void) md_fini_handle(mdp);
	return (rv);
}


static int vsw_get_initial_md_properties(vsw_t *vswp, md_t *mdp, mde_cookie_t node)
{
	uint64_t	macaddr = 0;

	D1(vswp, "%s: enter", __func__);

	if (vsw_get_md_physname(vswp, mdp, node, vswp->physname) != 0) {
		return (1);
	}

	
	if (md_get_prop_val(mdp, node, macaddr_propname, &macaddr) != 0) {
		cmn_err(CE_WARN, "!vsw%d: Unable to get MAC address from MD", vswp->instance);
		return (1);
	}

	vsw_save_lmacaddr(vswp, macaddr);

	if (vsw_get_md_smodes(vswp, mdp, node, &vswp->smode)) {
		DWARN(vswp, "%s: Unable to read %s property from MD, " "defaulting to 'switched' mode", __func__, smode_propname);


		vswp->smode = VSW_LAYER2;
	}

	
	vsw_linkprop_read(vswp, mdp, node, &vswp->pls_update);

	
	vsw_mtu_read(vswp, mdp, node, &vswp->mtu);
	if (vswp->mtu < ETHERMTU || vswp->mtu > VNET_MAX_MTU) {
		vswp->mtu = ETHERMTU;
	}
	vswp->max_frame_size = vswp->mtu + sizeof (struct ether_header) + VLAN_TAGSZ;

	
	vsw_vlan_read_ids(vswp, VSW_LOCALDEV, mdp, node, &vswp->pvid, &vswp->vids, &vswp->nvids, &vswp->default_vlan_id);

	
	vsw_read_pri_eth_types(vswp, mdp, node);

	
	vsw_bandwidth_read(vswp, mdp, node, &vswp->bandwidth);

	D1(vswp, "%s: exit", __func__);
	return (0);
}


static void vsw_vlan_read_ids(void *arg, int type, md_t *mdp, mde_cookie_t node, uint16_t *pvidp, vsw_vlanid_t **vidspp, uint16_t *nvidsp, uint16_t *default_idp)


{
	vsw_t		*vswp;
	vsw_port_t	*portp;
	char		*pvid_propname;
	char		*vid_propname;
	uint_t		nvids = 0;
	uint32_t	vids_size;
	int		rv;
	int		i;
	uint64_t	*data;
	uint64_t	val;
	int		size;
	int		inst;

	if (type == VSW_LOCALDEV) {

		vswp = (vsw_t *)arg;
		pvid_propname = vsw_pvid_propname;
		vid_propname = vsw_vid_propname;
		inst = vswp->instance;

	} else if (type == VSW_VNETPORT) {

		portp = (vsw_port_t *)arg;
		vswp = portp->p_vswp;
		pvid_propname = port_pvid_propname;
		vid_propname = port_vid_propname;
		inst = portp->p_instance;

	} else {
		return;
	}

	if (type == VSW_LOCALDEV && default_idp != NULL) {
		rv = md_get_prop_val(mdp, node, vsw_dvid_propname, &val);
		if (rv != 0) {
			DWARN(vswp, "%s: prop(%s) not found", __func__, vsw_dvid_propname);

			*default_idp = vsw_default_vlan_id;
		} else {
			*default_idp = val & 0xFFF;
			D2(vswp, "%s: %s(%d): (%d)\n", __func__, vsw_dvid_propname, inst, *default_idp);
		}
	}

	rv = md_get_prop_val(mdp, node, pvid_propname, &val);
	if (rv != 0) {
		DWARN(vswp, "%s: prop(%s) not found", __func__, pvid_propname);
		*pvidp = vsw_default_vlan_id;
	} else {

		*pvidp = val & 0xFFF;
		D2(vswp, "%s: %s(%d): (%d)\n", __func__, pvid_propname, inst, *pvidp);
	}

	rv = md_get_prop_data(mdp, node, vid_propname, (uint8_t **)&data, &size);
	if (rv != 0) {
		D2(vswp, "%s: prop(%s) not found", __func__, vid_propname);
		size = 0;
	} else {
		size /= sizeof (uint64_t);
	}
	nvids = size;

	if (nvids != 0) {
		D2(vswp, "%s: %s(%d): ", __func__, vid_propname, inst);
		vids_size = sizeof (vsw_vlanid_t) * nvids;
		*vidspp = kmem_zalloc(vids_size, KM_SLEEP);
		for (i = 0; i < nvids; i++) {
			(*vidspp)[i].vl_vid = data[i] & 0xFFFF;
			(*vidspp)[i].vl_set = B_FALSE;
			D2(vswp, " %d ", (*vidspp)[i].vl_vid);
		}
		D2(vswp, "\n");
	}

	*nvidsp = nvids;
}

static void vsw_port_read_bandwidth(vsw_port_t *portp, md_t *mdp, mde_cookie_t node, uint64_t *bw)

{
	int		rv;
	uint64_t	val;
	vsw_t		*vswp;

	vswp = portp->p_vswp;

	rv = md_get_prop_val(mdp, node, port_maxbw_propname, &val);

	if (rv != 0) {
		*bw = 0;
		D3(vswp, "%s: prop(%s) not found\n", __func__, port_maxbw_propname);
	} else {
		*bw = val;
		D3(vswp, "%s: %s nodes found", __func__, port_maxbw_propname);
	}
}


static void vsw_read_pri_eth_types(vsw_t *vswp, md_t *mdp, mde_cookie_t node)
{
	int		rv;
	uint16_t	*types;
	uint64_t	*data;
	int		size;
	int		i;
	size_t		mblk_sz;

	rv = md_get_prop_data(mdp, node, pri_types_propname, (uint8_t **)&data, &size);
	if (rv != 0) {
		
		if (vsw_pri_eth_type != 0) {
			size = sizeof (vsw_pri_eth_type);
			data = &vsw_pri_eth_type;
		} else {
			D3(vswp, "%s: prop(%s) not found", __func__, pri_types_propname);
			size = 0;
		}
	}

	if (size == 0) {
		vswp->pri_num_types = 0;
		return;
	}

	
	size /= sizeof (uint64_t);
	vswp->pri_num_types = size;
	vswp->pri_types = kmem_zalloc(size * sizeof (uint16_t), KM_SLEEP);
	for (i = 0, types = vswp->pri_types; i < size; i++) {
		types[i] = data[i] & 0xFFFF;
	}
	mblk_sz = (VIO_PKT_DATA_HDRSIZE + ETHERMAX + 7) & ~7;
	(void) vio_create_mblks(vsw_pri_tx_nmblks, mblk_sz, NULL, &vswp->pri_tx_vmp);
}

static void vsw_mtu_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, uint32_t *mtu)
{
	int		rv;
	int		inst;
	uint64_t	val;
	char		*mtu_propname;

	mtu_propname = vsw_mtu_propname;
	inst = vswp->instance;

	rv = md_get_prop_val(mdp, node, mtu_propname, &val);
	if (rv != 0) {
		D3(vswp, "%s: prop(%s) not found", __func__, mtu_propname);
		*mtu = vsw_ethermtu;
	} else {

		*mtu = val & 0xFFFF;
		D2(vswp, "%s: %s(%d): (%d)\n", __func__, mtu_propname, inst, *mtu);
	}
}


static int vsw_mtu_update(vsw_t *vswp, uint32_t mtu)
{
	int	rv;

	WRITE_ENTER(&vswp->if_lockrw);

	if (vswp->if_state & VSW_IF_UP) {

		RW_EXIT(&vswp->if_lockrw);

		cmn_err(CE_NOTE, "!vsw%d: Unable to process mtu update" " as the device is plumbed\n", vswp->instance);
		return (EBUSY);

	} else {

		D2(vswp, "%s: curr_mtu(%d) new_mtu(%d)\n", __func__, vswp->mtu, mtu);

		vswp->mtu = mtu;
		vswp->max_frame_size = vswp->mtu + sizeof (struct ether_header) + VLAN_TAGSZ;

		rv = mac_maxsdu_update(vswp->if_mh, mtu);
		if (rv != 0) {
			cmn_err(CE_NOTE, "!vsw%d: Unable to update mtu with mac" " layer\n", vswp->instance);

		}

		RW_EXIT(&vswp->if_lockrw);

		
		vsw_reset_ports(vswp);

	}

	return (0);
}

static void vsw_linkprop_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, boolean_t *pls)

{
	int		rv;
	uint64_t	val;
	char		*linkpropname;

	linkpropname = vsw_linkprop_propname;

	rv = md_get_prop_val(mdp, node, linkpropname, &val);
	if (rv != 0) {
		D3(vswp, "%s: prop(%s) not found", __func__, linkpropname);
		*pls = B_FALSE;
	} else {

		*pls = (val & 0x1) ? B_TRUE : B_FALSE;
		D2(vswp, "%s: %s(%d): (%d)\n", __func__, linkpropname, vswp->instance, *pls);
	}
}

void vsw_mac_link_update(vsw_t *vswp, link_state_t link_state)
{
	READ_ENTER(&vswp->if_lockrw);

	if (vswp->if_state & VSW_IF_REG) {
		mac_link_update(vswp->if_mh, link_state);
	}

	RW_EXIT(&vswp->if_lockrw);
}

void vsw_physlink_state_update(vsw_t *vswp)
{
	if (vswp->pls_update == B_TRUE) {
		vsw_mac_link_update(vswp, vswp->phys_link_state);
	}
	vsw_physlink_update_ports(vswp);
}

static void vsw_bandwidth_read(vsw_t *vswp, md_t *mdp, mde_cookie_t node, uint64_t *bw)
{
	
	int		rv;
	uint64_t	val;

	rv = md_get_prop_val(mdp, node, vsw_maxbw_propname, &val);
	if (rv != 0) {
		*bw = 0;
		D3(vswp, "%s: prop(%s) not found", __func__, vsw_maxbw_propname);
	} else {
		*bw = val;
		D3(vswp, "%s: %s(%d): (%ld)\n", __func__, vsw_maxbw_propname, vswp->instance, *bw);
	}
}


static void vsw_update_md_prop(vsw_t *vswp, md_t *mdp, mde_cookie_t node)
{
	char		physname[LIFNAMSIZ];
	char		drv[LIFNAMSIZ];
	uint_t		ddi_instance;
	uint8_t		new_smode;
	int		i;
	uint64_t	macaddr = 0;
	enum		{MD_init = 0x1, MD_physname = 0x2, MD_macaddr = 0x4, MD_smode = 0x8, MD_vlans = 0x10, MD_mtu = 0x20, MD_pls = 0x40, MD_bw = 0x80} updated;






	int		rv;
	uint16_t	pvid;
	vsw_vlanid_t	*vids;
	uint16_t	nvids;
	uint32_t	mtu;
	boolean_t	pls_update;
	uint64_t	maxbw;

	updated = MD_init;

	D1(vswp, "%s: enter", __func__);

	
	if (vsw_get_md_physname(vswp, mdp, node, (char *)&physname) == 0) {
		
		if ((strlen(physname) != 0) && (ddi_parse(physname, drv, &ddi_instance) != DDI_SUCCESS)) {

			cmn_err(CE_WARN, "!vsw%d: physical device %s is not" " a valid device name/instance", vswp->instance, physname);

			goto fail_reconf;
		}

		if (strcmp(physname, vswp->physname)) {
			D2(vswp, "%s: device name changed from %s to %s", __func__, vswp->physname, physname);

			updated |= MD_physname;
		} else {
			D2(vswp, "%s: device name unchanged at %s", __func__, vswp->physname);
		}
	} else {
		cmn_err(CE_WARN, "!vsw%d: Unable to read name of physical " "device from updated MD.", vswp->instance);
		goto fail_reconf;
	}

	
	if (md_get_prop_val(mdp, node, macaddr_propname, &macaddr) != 0) {
		cmn_err(CE_WARN, "!vsw%d: Unable to get MAC address from MD", vswp->instance);
		goto fail_reconf;
	} else {
		uint64_t maddr = macaddr;
		READ_ENTER(&vswp->if_lockrw);
		for (i = ETHERADDRL - 1; i >= 0; i--) {
			if (vswp->if_addr.ether_addr_octet[i] != (macaddr & 0xFF)) {
				D2(vswp, "%s: octet[%d] 0x%x != 0x%x", __func__, i, vswp->if_addr.ether_addr_octet[i], (macaddr & 0xFF));


				updated |= MD_macaddr;
				macaddr = maddr;
				break;
			}
			macaddr >>= 8;
		}
		RW_EXIT(&vswp->if_lockrw);
		if (updated & MD_macaddr) {
			vsw_save_lmacaddr(vswp, macaddr);
		}
	}

	
	if (vsw_get_md_smodes(vswp, mdp, node, &new_smode)) {
		cmn_err(CE_WARN, "!vsw%d: Unable to read %s property from MD", vswp->instance, smode_propname);
		goto fail_reconf;
	} else {
		if (new_smode != vswp->smode) {
			D2(vswp, "%s: switching mode changed from %d to %d", __func__, vswp->smode, new_smode);

			updated |= MD_smode;
		}
	}

	
	vsw_vlan_read_ids(vswp, VSW_LOCALDEV, mdp, node, &pvid, &vids, &nvids, NULL);

	
	if ((pvid != vswp->pvid) ||		 (nvids != vswp->nvids) || ((nvids != 0) && (vswp->nvids != 0) && !vsw_cmp_vids(vids, vswp->vids, nvids))) {


		updated |= MD_vlans;
	}

	
	vsw_mtu_read(vswp, mdp, node, &mtu);
	if (mtu != vswp->mtu) {
		if (mtu >= ETHERMTU && mtu <= VNET_MAX_MTU) {
			updated |= MD_mtu;
		} else {
			cmn_err(CE_NOTE, "!vsw%d: Unable to process mtu update" " as the specified value:%d is invalid\n", vswp->instance, mtu);

		}
	}

	
	vsw_linkprop_read(vswp, mdp, node, &pls_update);
	if (pls_update != vswp->pls_update) {
		updated |= MD_pls;
	}

	
	vsw_bandwidth_read(vswp, mdp, node, &maxbw);
	if (maxbw != vswp->bandwidth) {
		if (maxbw >= MRP_MAXBW_MINVAL || maxbw == 0) {
			updated |= MD_bw;
		} else {
			cmn_err(CE_NOTE, "!vsw%d: Unable to process bandwidth" " update as the specified value:%ld is invalid\n", vswp->instance, maxbw);

		}
	}

	
	if (updated & MD_pls) {

		
		vswp->pls_update = pls_update;

		if (pls_update == B_FALSE) {
			
			if (vswp->phys_link_state == LINK_STATE_DOWN) {
				vsw_mac_link_update(vswp, LINK_STATE_UP);
			}
		} else {
			
			if (vswp->smode & VSW_LAYER2) {
				vsw_mac_link_update(vswp, vswp->phys_link_state);
			}
		}

	}

	if (updated & (MD_physname | MD_smode | MD_mtu)) {

		
		vsw_setup_switching_stop(vswp);

		
		vsw_hio_cleanup(vswp);

		
		vsw_unset_addrs(vswp);

		
		mutex_enter(&vswp->mac_lock);
		vsw_mac_close(vswp);
		mutex_exit(&vswp->mac_lock);

		
		if (updated & MD_physname) {
			cmn_err(CE_NOTE, "!vsw%d: changing from %s to %s", vswp->instance, vswp->physname, physname);
			(void) strncpy(vswp->physname, physname, strlen(physname) + 1);
		}

		
		if (updated & MD_smode) {
			vswp->smode = new_smode;
		}

		
		if (updated & MD_mtu) {
			rv = vsw_mtu_update(vswp, mtu);
			if (rv != 0) {
				goto fail_update;
			}
		}

		
		rv = vsw_setup_switching(vswp);
		if (rv == EAGAIN) {
			
			if (vsw_setup_switching_start(vswp) != 0) {
				goto fail_update;
			}
			return;

		} else if (rv) {
			goto fail_update;
		}

		vsw_setup_switching_post_process(vswp);
	} else if (updated & MD_macaddr) {
		
		cmn_err(CE_NOTE, "!vsw%d: changing mac address to 0x%lx", vswp->instance, macaddr);

		READ_ENTER(&vswp->if_lockrw);
		if (vswp->if_state & VSW_IF_UP) {
			
			vsw_if_mac_reconfig(vswp, B_FALSE, 0, NULL, 0);

			
			mac_unicst_update(vswp->if_mh, (uint8_t *)&vswp->if_addr);

		}
		RW_EXIT(&vswp->if_lockrw);

	}

	if (updated & MD_vlans) {
		
		vsw_vlan_remove_ids(vswp, VSW_LOCALDEV);

		if (vswp->if_state & VSW_IF_UP) {
			vsw_if_mac_reconfig(vswp, B_TRUE, pvid, vids, nvids);
		} else {
			if (vswp->nvids != 0) {
				kmem_free(vswp->vids, sizeof (vsw_vlanid_t) * vswp->nvids);
			}
			vswp->vids = vids;
			vswp->nvids = nvids;
			vswp->pvid = pvid;
		}

		
		vsw_vlan_add_ids(vswp, VSW_LOCALDEV);
	} else {
		if (nvids != 0) {
			kmem_free(vids, sizeof (vsw_vlanid_t) * nvids);
		}
	}

	if (updated & MD_bw) {
		vsw_update_bandwidth(vswp, NULL, VSW_LOCALDEV, maxbw);
	}

	return;

fail_reconf:
	cmn_err(CE_WARN, "!vsw%d: configuration unchanged", vswp->instance);
	return;

fail_update:
	cmn_err(CE_WARN, "!vsw%d: re-configuration failed", vswp->instance);
}


static int vsw_port_read_props(vsw_port_t *portp, vsw_t *vswp, md_t *mdp, mde_cookie_t *node)

{
	uint64_t		ldc_id;
	uint8_t			*addrp;
	int			i, addrsz;
	int			num_nodes = 0, nchan = 0;
	int			listsz = 0;
	mde_cookie_t		*listp = NULL;
	struct ether_addr	ea;
	uint64_t		macaddr;
	uint64_t		inst = 0;
	uint64_t		val;

	if (md_get_prop_val(mdp, *node, id_propname, &inst)) {
		DWARN(vswp, "%s: prop(%s) not found", __func__, id_propname);
		return (1);
	}

	
	if ((num_nodes = md_node_count(mdp)) <= 0) {
		DERR(vswp, "%s: invalid number of nodes found (%d)", __func__, num_nodes);
		return (1);
	}

	D2(vswp, "%s: %d nodes found", __func__, num_nodes);

	
	listsz = num_nodes * sizeof (mde_cookie_t);
	listp = kmem_zalloc(listsz, KM_SLEEP);

	nchan = md_scan_dag(mdp, *node, md_find_name(mdp, chan_propname), md_find_name(mdp, "fwd"), listp);

	if (nchan <= 0) {
		DWARN(vswp, "%s: no %s nodes found", __func__, chan_propname);
		kmem_free(listp, listsz);
		return (1);
	}

	D2(vswp, "%s: %d %s nodes found", __func__, nchan, chan_propname);

	
	if (md_get_prop_val(mdp, listp[0], id_propname, &ldc_id)) {
		DWARN(vswp, "%s: prop(%s) not found\n", __func__, id_propname);
		kmem_free(listp, listsz);
		return (1);
	}

	
	kmem_free(listp, listsz);

	D2(vswp, "%s: ldc_id 0x%llx", __func__, ldc_id);

	
	if (md_get_prop_data(mdp, *node, remaddr_propname, &addrp, &addrsz)) {
		DWARN(vswp, "%s: prop(%s) not found", __func__, remaddr_propname);
		return (1);
	}

	if (addrsz < ETHERADDRL) {
		DWARN(vswp, "%s: invalid address size", __func__);
		return (1);
	}

	macaddr = *((uint64_t *)addrp);
	D2(vswp, "%s: remote mac address 0x%llx", __func__, macaddr);

	for (i = ETHERADDRL - 1; i >= 0; i--) {
		ea.ether_addr_octet[i] = macaddr & 0xFF;
		macaddr >>= 8;
	}

	
	portp->p_vswp = vswp;
	portp->p_instance = inst;
	portp->addr_set = B_FALSE;
	ether_copy(&ea, &portp->p_macaddr);
	if (nchan > VSW_PORT_MAX_LDCS) {
		D2(vswp, "%s: using first of %d ldc ids", __func__, nchan);
		nchan = VSW_PORT_MAX_LDCS;
	}
	portp->num_ldcs = nchan;
	portp->ldc_ids = kmem_zalloc(sizeof (uint64_t) * nchan, KM_SLEEP);
	bcopy(&ldc_id, (portp->ldc_ids), sizeof (uint64_t) * nchan);

	
	vsw_vlan_read_ids(portp, VSW_VNETPORT, mdp, *node, &portp->pvid, &portp->vids, &portp->nvids, NULL);

	
	if (md_get_prop_val(mdp, *node, hybrid_propname, &val) == 0) {
		D1(vswp, "%s: prop(%s) found\n", __func__, hybrid_propname);
		portp->p_hio_enabled = B_TRUE;
	} else {
		portp->p_hio_enabled = B_FALSE;
	}
	
	portp->p_hio_capable = B_FALSE;

	
	vsw_port_read_bandwidth(portp, mdp, *node, &portp->p_bandwidth);

	return (0);
}


int vsw_port_add(vsw_t *vswp, md_t *mdp, mde_cookie_t *node)
{
	vsw_port_t	*portp;
	int		rv;

	portp = kmem_zalloc(sizeof (vsw_port_t), KM_SLEEP);

	rv = vsw_port_read_props(portp, vswp, mdp, node);
	if (rv != 0) {
		kmem_free(portp, sizeof (*portp));
		return (1);
	}

	rv = vsw_port_attach(portp);
	if (rv != 0) {
		DERR(vswp, "%s: failed to attach port", __func__);
		return (1);
	}

	return (0);
}

static int vsw_port_update(vsw_t *vswp, md_t *curr_mdp, mde_cookie_t curr_mdex, md_t *prev_mdp, mde_cookie_t prev_mdex)

{
	uint64_t	cport_num;
	uint64_t	pport_num;
	vsw_port_list_t	*plistp;
	vsw_port_t	*portp;
	uint16_t	pvid;
	vsw_vlanid_t	*vids;
	uint16_t	nvids;
	uint64_t	val;
	boolean_t	hio_enabled = B_FALSE;
	uint64_t	maxbw;
	enum		{P_MD_init = 0x1, P_MD_vlans = 0x2, P_MD_hio = 0x4, P_MD_maxbw = 0x8} updated;



	updated = P_MD_init;

	
	if (md_get_prop_val(curr_mdp, curr_mdex, id_propname, &cport_num)) {
		return (1);
	}

	if (md_get_prop_val(prev_mdp, prev_mdex, id_propname, &pport_num)) {
		return (1);
	}
	if (cport_num != pport_num)
		return (1);

	plistp = &(vswp->plist);

	READ_ENTER(&plistp->lockrw);

	portp = vsw_lookup_port(vswp, cport_num);
	if (portp == NULL) {
		RW_EXIT(&plistp->lockrw);
		return (1);
	}

	
	vsw_vlan_read_ids(portp, VSW_VNETPORT, curr_mdp, curr_mdex, &pvid, &vids, &nvids, NULL);

	
	if ((pvid != portp->pvid) ||		 (nvids != portp->nvids) || ((nvids != 0) && (portp->nvids != 0) && !vsw_cmp_vids(vids, portp->vids, nvids))) {


		updated |= P_MD_vlans;
	}

	
	if (md_get_prop_val(curr_mdp, curr_mdex, hybrid_propname, &val) == 0) {
		D1(vswp, "%s: prop(%s) found\n", __func__, hybrid_propname);
		hio_enabled = B_TRUE;
	}

	if (portp->p_hio_enabled != hio_enabled) {
		updated |= P_MD_hio;
	}

	
	vsw_port_read_bandwidth(portp, curr_mdp, curr_mdex, &maxbw);
	if (maxbw != portp->p_bandwidth) {
		if (maxbw >= MRP_MAXBW_MINVAL || maxbw == 0) {
			updated |= P_MD_maxbw;
		} else {
			cmn_err(CE_NOTE, "!vsw%d: Unable to process bandwidth" " update for port %d as the specified value:%ld" " is invalid\n", vswp->instance, portp->p_instance, maxbw);


		}
	}

	if (updated & P_MD_vlans) {
		
		vsw_vlan_remove_ids(portp, VSW_VNETPORT);

		
		vsw_mac_port_reconfig_vlans(portp, pvid, vids, nvids);

		
		vsw_vlan_add_ids(portp, VSW_VNETPORT);

		
		vsw_vlan_unaware_port_reset(portp);
	}

	if (updated & P_MD_hio) {
		vsw_hio_port_update(portp, hio_enabled);
	}

	if (updated & P_MD_maxbw) {
		vsw_update_bandwidth(NULL, portp, VSW_VNETPORT, maxbw);
	}

	RW_EXIT(&plistp->lockrw);

	return (0);
}


void vsw_mac_rx(vsw_t *vswp, mac_resource_handle_t mrh, mblk_t *mp, vsw_macrx_flags_t flags)

{
	mblk_t		*mpt;

	D1(vswp, "%s:enter\n", __func__);
	READ_ENTER(&vswp->if_lockrw);
	
	if (!(vswp->if_state & VSW_IF_UP)) {
		RW_EXIT(&vswp->if_lockrw);
		
		if (flags & VSW_MACRX_FREEMSG) {
			freemsgchain(mp);
		}
		D1(vswp, "%s:exit\n", __func__);
		return;
	}
	
	if (flags & VSW_MACRX_PROMISC) {
		if (!(vswp->if_state & VSW_IF_PROMISC)) {
			RW_EXIT(&vswp->if_lockrw);
			
			if (flags & VSW_MACRX_FREEMSG) {
				freemsgchain(mp);
			}
			D1(vswp, "%s:exit\n", __func__);
			return;
		}
	}
	RW_EXIT(&vswp->if_lockrw);
	
	if (flags & VSW_MACRX_COPYMSG) {
		mp = copymsgchain(mp);
		if (mp == NULL) {
			D1(vswp, "%s:exit\n", __func__);
			return;
		}
	}

	D2(vswp, "%s: sending up stack", __func__);

	mpt = NULL;
	(void) vsw_vlan_frame_untag(vswp, VSW_LOCALDEV, &mp, &mpt);
	if (mp != NULL) {
		mac_rx(vswp->if_mh, mrh, mp);
	}
	D1(vswp, "%s:exit\n", __func__);
}


static void vsw_save_lmacaddr(vsw_t *vswp, uint64_t macaddr)
{
	int	i;

	WRITE_ENTER(&vswp->if_lockrw);
	for (i = ETHERADDRL - 1; i >= 0; i--) {
		vswp->if_addr.ether_addr_octet[i] = macaddr & 0xFF;
		macaddr >>= 8;
	}
	RW_EXIT(&vswp->if_lockrw);
}


static boolean_t vsw_cmp_vids(vsw_vlanid_t *vids1, vsw_vlanid_t *vids2, int nvids)
{
	int i, j;
	uint16_t vid;

	for (i = 0; i < nvids; i++) {
		vid = vids1[i].vl_vid;
		for (j = 0; j < nvids; j++) {
			if (vid == vids2[i].vl_vid)
				break;
		}
		if (j == nvids) {
			return (B_FALSE);
		}
	}
	return (B_TRUE);
}
