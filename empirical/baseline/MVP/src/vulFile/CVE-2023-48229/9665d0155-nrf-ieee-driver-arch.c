




























































static int8_t last_rssi;
static uint8_t last_lqi;

PROCESS(nrf_ieee_rf_process, "nRF IEEE RF driver");






























typedef struct timestamps_s {
  rtimer_clock_t sfd;           
  rtimer_clock_t framestart;    
  rtimer_clock_t end;           
  rtimer_clock_t mpdu_duration; 
  uint8_t phr;                  
} timestamps_t;

static timestamps_t timestamps;

typedef struct tx_buf_s {
  uint8_t phr;
  uint8_t mpdu[MAX_PAYLOAD_LEN];
} tx_buf_t;

static tx_buf_t tx_buf;

typedef struct rx_buf_s {
  uint8_t phr;
  uint8_t mpdu[MPDU_LEN];
  bool full; 
} rx_buf_t;

static rx_buf_t rx_buf;

typedef struct rf_cfg_s {
  bool poll_mode;
  nrf_radio_txpower_t txpower;
  uint8_t channel;
  uint8_t send_on_cca; 
  uint8_t cca_mode;
  uint8_t cca_corr_threshold;
  uint8_t cca_corr_count;
  uint8_t ed_threshold;
} rf_cfg_t;

static rf_cfg_t rf_config = {
  .poll_mode = false, .txpower = NRF_RADIO_TXPOWER_0DBM, .send_on_cca = RADIO_TX_MODE_SEND_ON_CCA, .channel = IEEE802154_DEFAULT_CHANNEL, .cca_mode = NRF_CCA_MODE, .cca_corr_threshold = NRF_CCA_CORR_THRESHOLD, .cca_corr_count = NRF_CCA_CORR_COUNT, .ed_threshold = NRF_CCA_ED_THRESHOLD, };








static bool radio_power = false; 


static bool phr_is_valid(uint8_t phr)
{
  if(phr < ACK_MPDU_MIN_LEN || phr > MPDU_LEN) {
    return false;
  }
  return true;
}

static bool radio_is_powered(void)
{
  if(nrf53_errata_16()) {
    return radio_power;
  } else {
    return NRF_RADIO->POWER == 0 ? false : true;
  }
}

static void radio_set_power(bool power)
{
  if(nrf53_errata_16()) {
    radio_power = power;
  } else {
    nrf_radio_power_set(NRF_RADIO, power);
  }
}

static uint8_t radio_rssi_sample_get(void)
{
  uint8_t rssi_sample;
  uint8_t temp;

  rssi_sample = nrf_radio_rssi_sample_get(NRF_RADIO);

  if(nrf53_errata_87()) {
    temp = nrf_temp_result_get(NRF_TEMP);
    return (uint8_t)round( (float)((float)(1.56f * rssi_sample) + (float)(4.9e-5 * pow(rssi_sample, 3)) - (float)(9.9e-3 * pow(rssi_sample, 2)) - (0.05f * ((float)(temp) * 0.25f)) - 7.2f));

  } else {
    return rssi_sample;
  }
}

static uint8_t get_channel(void)
{
  return NRF_RADIO->FREQUENCY / 5 + 10;
}

static void set_channel(uint8_t channel)
{
  NRF_RADIO->FREQUENCY = 5 * (channel - 10);
}

static void cca_reconfigure(void)
{
  nrf_radio_cca_configure(NRF_RADIO, rf_config.cca_mode, rf_config.ed_threshold, rf_config.cca_corr_threshold, rf_config.cca_corr_count);
}

static void crc_init(void)
{
  
  nrf_radio_crc_configure(NRF_RADIO, CRC_IEEE802154_LEN, NRF_RADIO_CRC_ADDR_IEEE802154, CRC_IEEE802154_POLY);

  nrf_radio_crcinit_set(NRF_RADIO, CRC_IEEE802154_INIT);
}

static void packet_init(void)
{
  
  nrf_radio_packet_conf_t conf;

  memset(&conf, 0, sizeof(conf));

  conf.lflen = 8; 
  conf.s1incl = false;
  conf.plen = NRF_RADIO_PREAMBLE_LENGTH_32BIT_ZERO;
  conf.crcinc = true;
  conf.big_endian = false;
  conf.whiteen = false;
  conf.maxlen = MPDU_LEN;

  nrf_radio_packet_configure(NRF_RADIO, &conf);
}

static void setup_interrupts(void)
{
  int_master_status_t stat;
  nrf_radio_int_mask_t interrupts = 0;

  stat = critical_enter();

  if(!rf_config.poll_mode) {
    nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCOK);
    nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCERROR);
    interrupts |= NRF_RADIO_INT_CRCOK_MASK | NRF_RADIO_INT_CRCERROR_MASK;
  }

  
  nrf_radio_int_disable(NRF_RADIO, 0xFFFFFFFF);
  NVIC_ClearPendingIRQ(RADIO_IRQn);

  if(interrupts) {
    nrf_radio_int_enable(NRF_RADIO, interrupts);
    NVIC_EnableIRQ(RADIO_IRQn);
  } else {
    
    NVIC_DisableIRQ(RADIO_IRQn);
  }

  critical_exit(stat);
}


static void setup_ppi_timestamping(void)
{
  nrfx_gppi_channel_endpoints_setup( NRF_PPI_FRAMESTART_CHANNEL, nrf_radio_event_address_get(NRF_RADIO, NRF_RADIO_EVENT_FRAMESTART), nrf_timer_task_address_get(NRF_TIMER0, NRF_TIMER_TASK_CAPTURE3));


  nrfx_gppi_channel_endpoints_setup( NRF_PPI_END_CHANNEL, nrf_radio_event_address_get(NRF_RADIO, NRF_RADIO_EVENT_END), nrf_timer_task_address_get(NRF_TIMER0, NRF_TIMER_TASK_CAPTURE2));


  nrfx_gppi_channels_enable(1uL << NRF_PPI_FRAMESTART_CHANNEL | 1uL << NRF_PPI_END_CHANNEL);
}

static void set_poll_mode(bool enable)
{
  rf_config.poll_mode = enable;
  setup_interrupts();
}

static void rx_buf_clear(void)
{
  memset(&rx_buf, 0, sizeof(rx_buf));
}

static void rx_events_clear()
{
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_FRAMESTART);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_END);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_PHYEND);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCERROR);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCOK);
}


static void configure(void)
{
  nrf_radio_mode_set(NRF_RADIO, NRF_RADIO_MODE_IEEE802154_250KBIT);

  if(nrf53_errata_117()) {
    *((volatile uint32_t *)0x41008588) = *((volatile uint32_t *)0x01FF0084);
  }

  set_channel(rf_config.channel);

  cca_reconfigure();

  
  crc_init();

  
  packet_init();

  
  nrf_radio_modecnf0_set(NRF_RADIO, true, RADIO_MODECNF0_DTX_Center);
}

static void power_on_and_configure(void)
{
  radio_set_power(true);
  configure();
}


static void enter_rx(void)
{
  nrf_radio_state_t curr_state = nrf_radio_state_get(NRF_RADIO);

  LOG_DBG("Enter RX, state=%u", curr_state);

  
  if(curr_state == NRF_RADIO_STATE_RX) {
    LOG_DBG_(". Was in RX");
    LOG_DBG_("\n");
    return;
  }

  
  nrf_radio_packetptr_set(NRF_RADIO, &rx_buf);

  
  setup_ppi_timestamping();

  
  setup_interrupts();

  nrf_radio_shorts_enable(NRF_RADIO, NRF_RADIO_SHORT_ADDRESS_RSSISTART_MASK);
  nrf_radio_shorts_enable(NRF_RADIO, NRF_RADIO_SHORT_RXREADY_START_MASK);

  if(curr_state != NRF_RADIO_STATE_RXIDLE) {
    
    nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_RXREADY);
    nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_RXEN);
  } else {
    
    nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_START);
  }

  LOG_DBG_("--->%u\n", nrf_radio_state_get(NRF_RADIO));

  LOG_DBG("PACKETPTR=0x%08" PRIx32 " (rx_buf @ 0x%08" PRIx32 ")\n", (uint32_t)nrf_radio_packetptr_get(NRF_RADIO), (uint32_t)&rx_buf);
}


static int8_t rssi_read(void)
{
  uint8_t rssi_sample;

  nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_RSSISTART);

  while(nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_RSSIEND) == false);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_RSSIEND);

  rssi_sample = radio_rssi_sample_get();

  return -((int8_t)rssi_sample);
}


static uint8_t lqi_convert_to_802154_scale(uint8_t lqi_hw)
{
  return (uint8_t)lqi_hw > 63 ? 255 : lqi_hw *ED_RSSISCALE;
}



static int on(void)
{
  LOG_DBG("On\n");

  if(radio_is_powered() == false) {
    LOG_DBG("Not powered\n");
    power_on_and_configure();
  }

  enter_rx();

  ENERGEST_ON(ENERGEST_TYPE_LISTEN);
  return NRF_COMMAND_OK;
}

static int channel_clear(void)
{
  bool busy, idle;

  LOG_DBG("channel_clear\n");

  on();

  
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CCABUSY);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CCAIDLE);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CCASTOPPED);

  LOG_DBG("channel_clear: CCACTRL=0x%08" PRIx32 "\n", NRF_RADIO->CCACTRL);

  
  nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_CCASTART);

  while((nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CCABUSY) == false) && (nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CCAIDLE) == false));

  busy = nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CCABUSY);
  idle = nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CCAIDLE);

  LOG_DBG("channel_clear: I=%u, B=%u\n", idle, busy);

  if(busy) {
    return NRF_CCA_BUSY;
  }

  return NRF_CCA_CLEAR;
}

static int init(void)
{
  LOG_DBG("Init\n");

  last_rssi = 0;
  last_lqi = 0;

  timestamps.sfd = 0;
  timestamps.framestart = 0;
  timestamps.end = 0;
  timestamps.mpdu_duration = 0;
  timestamps.phr = 0;

  
  nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
  nrf_clock_task_trigger(NRF_CLOCK, NRF_CLOCK_TASK_HFCLKSTART);
  while(!nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED));
  nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);

  
  process_start(&nrf_ieee_rf_process, NULL);

  
  rx_buf_clear();

  
  power_on_and_configure();

  
  set_poll_mode(rf_config.poll_mode);

  return RADIO_TX_OK;
}

static int prepare(const void *payload, unsigned short payload_len)
{
  LOG_DBG("Prepare %u bytes\n", payload_len);

  if(payload_len > MAX_PAYLOAD_LEN) {
    LOG_ERR("Too long: %u bytes, max %u\n", payload_len, MAX_PAYLOAD_LEN);
    return RADIO_TX_ERR;
  }

  
  tx_buf.phr = (uint8_t)payload_len + FCS_LEN;

  
  memcpy(tx_buf.mpdu, payload, payload_len);

  return RADIO_TX_OK;
}

static int transmit(unsigned short transmit_len)
{
  int i;

  LOG_DBG("TX %u bytes + FCS, channel=%u\n", transmit_len, get_channel());

  if(transmit_len > MAX_PAYLOAD_LEN) {
    LOG_ERR("TX: too long (%u bytes)\n", transmit_len);
    return RADIO_TX_ERR;
  }

  on();

  if(rf_config.send_on_cca) {
    if(channel_clear() == NRF_CCA_BUSY) {
      LOG_DBG("TX: Busy\n");
      return RADIO_TX_COLLISION;
    }
  }

  nrf_radio_txpower_set(NRF_RADIO, rf_config.txpower);

  
  nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_STOP);
  while(nrf_radio_state_get(NRF_RADIO) != NRF_RADIO_STATE_RXIDLE);

  LOG_DBG("Transmit: %u bytes=000000", tx_buf.phr);
  for(i = 0; i < tx_buf.phr - 2; i++) {
    LOG_DBG_(" %02x", tx_buf.mpdu[i]);
  }
  LOG_DBG_("\n");

  LOG_DBG("TX Start. State %u", nrf_radio_state_get(NRF_RADIO));

  
  nrf_radio_packetptr_set(NRF_RADIO, &tx_buf);

  
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_END);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_PHYEND);
  nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_TXREADY);

  
  ENERGEST_SWITCH(ENERGEST_TYPE_LISTEN, ENERGEST_TYPE_TRANSMIT);

  
  nrf_radio_shorts_enable(NRF_RADIO, NRF_RADIO_SHORT_TXREADY_START_MASK);
  nrf_radio_task_trigger(NRF_RADIO, NRF_RADIO_TASK_TXEN);

  
  RTIMER_BUSYWAIT(TXRU_DURATION_TIMER);

  
  if(nrf53_errata_91()) {
    RTIMER_BUSYWAIT(1);
  }

  LOG_DBG_("--->%u\n", nrf_radio_state_get(NRF_RADIO));

  
  while(nrf_radio_state_get(NRF_RADIO) == NRF_RADIO_STATE_TX);

  LOG_DBG("TX: Done\n");

  
  enter_rx();

  
  ENERGEST_SWITCH(ENERGEST_TYPE_TRANSMIT, ENERGEST_TYPE_LISTEN);

  return RADIO_TX_OK;
}

static int send(const void *payload, unsigned short payload_len)
{
  prepare(payload, payload_len);
  return transmit(payload_len);
}

static int read_frame(void *buf, unsigned short bufsize)
{
  int payload_len;

  
  rx_events_clear();

  payload_len = rx_buf.phr - FCS_LEN;

  if(phr_is_valid(rx_buf.phr) == false) {
    LOG_DBG("Incorrect length: %d\n", payload_len);
    rx_buf_clear();
    enter_rx();
    return 0;
  }

  memcpy(buf, rx_buf.mpdu, payload_len);
  last_lqi = lqi_convert_to_802154_scale(rx_buf.mpdu[payload_len]);
  last_rssi = -(radio_rssi_sample_get());

  packetbuf_set_attr(PACKETBUF_ATTR_RSSI, last_rssi);
  packetbuf_set_attr(PACKETBUF_ATTR_LINK_QUALITY, last_lqi);

  
  timestamps.phr = rx_buf.phr;
  timestamps.framestart = nrf_timer_cc_get(NRF_TIMER0, NRF_TIMER_CC_CHANNEL3);
  timestamps.end = nrf_timer_cc_get(NRF_TIMER0, NRF_TIMER_CC_CHANNEL2);
  timestamps.mpdu_duration = rx_buf.phr * BYTE_DURATION_RTIMER;

  
  timestamps.sfd = timestamps.framestart - BYTE_DURATION_RTIMER;

  LOG_DBG("Read frame: len=%d, RSSI=%d, LQI=0x%02x\n", payload_len, last_rssi, last_lqi);

  rx_buf_clear();
  enter_rx();

  return payload_len;
}

static int receiving_packet(void)
{
  
  if(radio_is_powered() == false) {
    return NRF_RECEIVING_NO;
  }

  
  if(nrf_radio_state_get(NRF_RADIO) != NRF_RADIO_STATE_RX) {
    return NRF_RECEIVING_NO;
  }

  if(rf_config.poll_mode) {
    
    if(phr_is_valid(rx_buf.phr) == false) {
      return NRF_RECEIVING_NO;
    }

    
    if((nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CRCOK) == false) && (nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CRCERROR) == false)) {
      return NRF_RECEIVING_YES;
    }

    return NRF_RECEIVING_NO;
  }

  
  if(phr_is_valid(rx_buf.phr) == true && rx_buf.full == false) {
    return NRF_RECEIVING_YES;
  }
  return NRF_RECEIVING_NO;
}

static int pending_packet(void)
{
  
  if(phr_is_valid(rx_buf.phr) == false) {
    return NRF_PENDING_NO;
  }

  
  if((nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CRCOK) == true) || (rx_buf.full == true)) {
    return NRF_PENDING_YES;
  }

  return NRF_PENDING_NO;
}

static int off(void)
{
  radio_set_power(false);

  ENERGEST_OFF(ENERGEST_TYPE_LISTEN);

  return NRF_COMMAND_OK;
}

static radio_result_t get_value(radio_param_t param, radio_value_t *value)
{
  if(!value) {
    return RADIO_RESULT_INVALID_VALUE;
  }

  switch(param) {
  case RADIO_PARAM_POWER_MODE:
    return RADIO_RESULT_OK;
  case RADIO_PARAM_CHANNEL:
    *value = (radio_value_t)get_channel();
    return RADIO_RESULT_OK;
  case RADIO_PARAM_RX_MODE:
    *value = 0;
    if(rf_config.poll_mode) {
      *value |= RADIO_RX_MODE_POLL_MODE;
    }
    return RADIO_RESULT_OK;
  case RADIO_PARAM_TX_MODE:
    *value = 0;
    if(rf_config.send_on_cca) {
      *value |= RADIO_TX_MODE_SEND_ON_CCA;
    }
    return RADIO_RESULT_OK;
  case RADIO_PARAM_TXPOWER:
    *value = (radio_value_t)rf_config.txpower;
    return RADIO_RESULT_OK;
  case RADIO_PARAM_CCA_THRESHOLD:
    *value = (radio_value_t)rf_config.cca_corr_threshold;
    return RADIO_RESULT_OK;
  case RADIO_PARAM_RSSI:
    *value = (radio_value_t)rssi_read();
    return RADIO_RESULT_OK;
  case RADIO_PARAM_LAST_RSSI:
    *value = (radio_value_t)last_rssi;
    return RADIO_RESULT_OK;
  case RADIO_PARAM_LAST_LINK_QUALITY:
    *value = (radio_value_t)last_lqi;
    return RADIO_RESULT_OK;
  case RADIO_CONST_CHANNEL_MIN:
    *value = 11;
    return RADIO_RESULT_OK;
  case RADIO_CONST_CHANNEL_MAX:
    *value = 26;
    return RADIO_RESULT_OK;
  case RADIO_CONST_TXPOWER_MIN:
    *value = (radio_value_t)RADIO_TXPOWER_TXPOWER_Neg40dBm;
    return RADIO_RESULT_OK;
  case RADIO_CONST_TXPOWER_MAX:

    *value = (radio_value_t)RADIO_TXPOWER_TXPOWER_Pos8dBm;

    *value = (radio_value_t)RADIO_TXPOWER_TXPOWER_0dBm;

    return RADIO_RESULT_OK;
  case RADIO_CONST_PHY_OVERHEAD:
    *value = (radio_value_t)RADIO_PHY_OVERHEAD;
    return RADIO_RESULT_OK;
  case RADIO_CONST_BYTE_AIR_TIME:
    *value = (radio_value_t)RADIO_BYTE_AIR_TIME;
    return RADIO_RESULT_OK;
  case RADIO_CONST_DELAY_BEFORE_TX:
    *value = (radio_value_t)RADIO_DELAY_BEFORE_TX;
    return RADIO_RESULT_OK;
  case RADIO_CONST_DELAY_BEFORE_RX:
    *value = (radio_value_t)RADIO_DELAY_BEFORE_RX;
    return RADIO_RESULT_OK;
  case RADIO_CONST_DELAY_BEFORE_DETECT:
    *value = (radio_value_t)RADIO_DELAY_BEFORE_DETECT;
    return RADIO_RESULT_OK;
  case RADIO_CONST_MAX_PAYLOAD_LEN:
    *value = (radio_value_t)MAX_PAYLOAD_LEN;
    return RADIO_RESULT_OK;
  case RADIO_PARAM_PAN_ID:
  case RADIO_PARAM_16BIT_ADDR:
  default:
    return RADIO_RESULT_NOT_SUPPORTED;
  }
}

static radio_result_t set_value(radio_param_t param, radio_value_t value)
{
  switch(param) {
  case RADIO_PARAM_POWER_MODE:
    if(value == RADIO_POWER_MODE_ON) {
      on();
      return RADIO_RESULT_OK;
    }
    if(value == RADIO_POWER_MODE_OFF) {
      off();
      return RADIO_RESULT_OK;
    }
    return RADIO_RESULT_INVALID_VALUE;
  case RADIO_PARAM_CHANNEL:
    if(value < NRF_CHANNEL_MIN || value > NRF_CHANNEL_MAX) {
      return RADIO_RESULT_INVALID_VALUE;
    }
    rf_config.channel = value;

    
    if(radio_is_powered()) {
      off();
      set_channel(value);
      on();
    }
    return RADIO_RESULT_OK;
  case RADIO_PARAM_RX_MODE:
    if(value & ~(RADIO_RX_MODE_ADDRESS_FILTER | RADIO_RX_MODE_AUTOACK | RADIO_RX_MODE_POLL_MODE)) {

      return RADIO_RESULT_INVALID_VALUE;
    }

    set_poll_mode((value & RADIO_RX_MODE_POLL_MODE) != 0);

    return RADIO_RESULT_OK;
  case RADIO_PARAM_TX_MODE:
    if(value & ~(RADIO_TX_MODE_SEND_ON_CCA)) {
      return RADIO_RESULT_INVALID_VALUE;
    }

    rf_config.send_on_cca = (value & RADIO_TX_MODE_SEND_ON_CCA) != 0;
    return RADIO_RESULT_OK;
  case RADIO_PARAM_TXPOWER:
    rf_config.txpower = value;
    
    if(radio_is_powered()) {
      nrf_radio_txpower_set(NRF_RADIO, value);
    }
    return RADIO_RESULT_OK;
  case RADIO_PARAM_CCA_THRESHOLD:
    rf_config.cca_corr_threshold = value;
    
    if(radio_is_powered()) {
      cca_reconfigure();
    }
    return RADIO_RESULT_OK;

  case RADIO_PARAM_SHR_SEARCH:
  case RADIO_PARAM_PAN_ID:
  case RADIO_PARAM_16BIT_ADDR:
  default:
    return RADIO_RESULT_NOT_SUPPORTED;
  }
}

static radio_result_t get_object(radio_param_t param, void *dest, size_t size)
{
  if(param == RADIO_PARAM_LAST_PACKET_TIMESTAMP) {
    if(size != sizeof(rtimer_clock_t) || !dest) {
      return RADIO_RESULT_INVALID_VALUE;
    }
    *(rtimer_clock_t *)dest = timestamps.sfd;
    return RADIO_RESULT_OK;
  }


  if(param == RADIO_CONST_TSCH_TIMING) {
    if(size != sizeof(uint16_t *) || !dest) {
      return RADIO_RESULT_INVALID_VALUE;
    }
    
    *(const uint16_t **)dest = tsch_timeslot_timing_us_10000;
    return RADIO_RESULT_OK;
  }


  
  return RADIO_RESULT_NOT_SUPPORTED;
}

static radio_result_t set_object(radio_param_t param, const void *src, size_t size)
{
  
  return RADIO_RESULT_NOT_SUPPORTED;
}

const struct radio_driver nrf_ieee_driver = {
  init, prepare, transmit, send, read_frame, channel_clear, receiving_packet, pending_packet, on, off, get_value, set_value, get_object, set_object };














PROCESS_THREAD(nrf_ieee_rf_process, ev, data)
{
  int len;
  PROCESS_BEGIN();

  while(1) {
    PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);

    LOG_DBG("Polled\n");

    if(pending_packet()) {
      watchdog_periodic();
      packetbuf_clear();
      len = read_frame(packetbuf_dataptr(), PACKETBUF_SIZE);
      if(len > 0) {
        packetbuf_set_datalen(len);
        NETSTACK_MAC.input();
        LOG_DBG("last frame (%u bytes) timestamps:\n", timestamps.phr);
        LOG_DBG("      SFD=%" PRIu32 " (Derived)\n", timestamps.sfd);
        LOG_DBG("      PHY=%" PRIu32 " (PPI)\n", timestamps.framestart);
        LOG_DBG("     MPDU=%" PRIu32 " (Duration)\n", timestamps.mpdu_duration);
        LOG_DBG("      END=%" PRIu32 " (PPI)\n", timestamps.end);
        LOG_DBG(" Expected=%" PRIu32 " + %u + %" PRIu32 " = %" PRIu32 "\n", timestamps.sfd, BYTE_DURATION_RTIMER, timestamps.mpdu_duration, timestamps.sfd + BYTE_DURATION_RTIMER + timestamps.mpdu_duration);

      }
    }
  }

  PROCESS_END();
}

void RADIO_IRQHandler(void)
{
  if(!rf_config.poll_mode) {
    if(nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CRCOK)) {
      nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCOK);
      rx_buf.full = true;
      process_poll(&nrf_ieee_rf_process);
    } else if(nrf_radio_event_check(NRF_RADIO, NRF_RADIO_EVENT_CRCERROR)) {
      nrf_radio_event_clear(NRF_RADIO, NRF_RADIO_EVENT_CRCERROR);
      rx_buf_clear();
      enter_rx();
    }
  }
}






