
















namespace tensorflow {
namespace grappler {

const char kConstantFoldingConst[] = "ConstantFolding";
const char kConstantFoldingCtrl[] = "ConstantFoldingCtrl";
extern const int64_t kMaxConstantSize;


class ConstantFolding : public GraphOptimizer {
 public:
  
  
  static Status CreateNodeDef(const string& name, const TensorValue& tensor, NodeDef* node, size_t original_size = 0);
  static string AddControlDependency(const string& input_name, GraphDef* graph, NodeMap* node_map);

  explicit ConstantFolding(DeviceBase* cpu_device, bool disable_compressed_tensor_optimization = false, bool fold_quantization_emulation = true);

  ConstantFolding(RewriterConfig::Toggle opt_level, DeviceBase* cpu_device, bool disable_compressed_tensor_optimization = false, bool fold_quantization_emulation = true);


  ~ConstantFolding() override {}

  string name() const override { return "constant_folding"; };

  bool UsesFunctionLibrary() const override { return false; }

  Status Optimize(Cluster* cluster, const GrapplerItem& item, GraphDef* output) override;

 private:
  bool ForwardInputs(NodeDef* node, absl::Span<const int> inputs_to_forward);
  string OptimizedNodeName(const NodeDef& node, StringPiece suffix) const;
  bool OptimizedNodeExists(const NodeDef& node, StringPiece suffix) const;

  bool IsReallyConstant(const NodeDef& node) const;

  bool GetTensorFromConstNode(const string& node_name_or_input, Tensor* tensor);

  Status MaterializeShapes(const GraphProperties& properties);

  Status MaterializeBroadcastGradientArgs(const NodeDef& node, const GraphProperties& properties);
  Status MaterializeReductionIndices(NodeDef* node, const GraphProperties& properties);
  Status MaterializeConstantValuedNode(NodeDef* node, const GraphProperties& properties);
  Status MaterializeOutputValues(NodeDef* node, const GraphProperties& properties);
  Status MaterializeConstants(const GraphProperties& properties);

  bool IsFoldable(const NodeDef& node, const GraphProperties* properties);
  bool IsFoldableUncached(const NodeDef& node, const GraphProperties* properties) const;
  bool MaybeFoldable(const NodeDef& node, const GraphProperties* properties) const;

  Status EvaluateNode(const NodeDef& node, const gtl::InlinedVector<TensorValue, 4>& inputs, gtl::InlinedVector<TensorValue, 4>* output) const;


  Status EvaluateOneFoldable(const NodeDef& node, std::vector<NodeDef>* outputs, bool* result_too_large);

  Status FoldMergeNode(NodeDef* node, GraphDef* output_graph);
  Status FoldNode(NodeDef* node, GraphDef* output_graph, bool* result_too_large);

  bool IsOnes(const NodeDef& node) const;
  bool IsZeros(const NodeDef& node) const;
  bool ReplaceOperationWithBroadcastTo(int input_to_broadcast, const GraphProperties& properties, NodeDef* node, GraphDef* graph);

  void ReplaceOperationWithIdentity(int input_to_forward, const GraphProperties& properties, NodeDef* node, GraphDef* graph);

  void ReplaceOperationWithSnapshot(int input_to_forward, const GraphProperties& properties, NodeDef* node, GraphDef* graph);

  void ReplaceOperationWithNoOp(NodeDef* node, GraphProperties* properties, GraphDef* graph);
  void ReplaceBinaryOperationWithBroadcastTo(int input_to_broadcast, const GraphProperties& properties, NodeDef* node, GraphDef* graph);

  void ReplaceSubtractionFromZeroByNegation(NodeDef* node, GraphDef* graph);
  Status ReplaceOperationWithConstant(double value, const GraphProperties& properties, const TensorShapeProto& shape, NodeDef* node, GraphDef* graph);



  
  Status ReplaceOperationWithConstantTensor(DataType dtype, TensorProto* value, NodeDef* node, GraphDef* graph);

  void ReplaceDivisionOfOnesByReciprocal(NodeDef* node, GraphDef* graph);
  Status FoldGraph(const GraphProperties& properties, GraphDef* output, absl::flat_hash_set<string>* nodes_to_not_simplify);

  bool IsSimplifiableReshape(const NodeDef& node, const GraphProperties& properties) const;
  Status SimplifyGraph(GraphDef* optimized_graph, GraphProperties* properties, absl::flat_hash_set<string>* nodes_to_not_simplify);
  Status SimplifyNode(NodeDef* node, GraphDef* optimized_graph, GraphProperties* properties);

  Status RunOptimizationPass(Cluster* cluster, GrapplerItem* item, GraphProperties* properties, GraphDef* optimized_graph);


  
  
  bool PartialConcatConstFolding(GraphDef* optimized_graph, GraphProperties* properties, NodeDef* node);

  
  
  bool PartialAssocOpConstFolding(GraphDef* optimized_graph, GraphProperties* properties, NodeDef* node);

  
  
  bool PartialConstPropThroughIdentityN(NodeDef* node);

  struct ConstantPushDownContext {
    NodeDef* op_child;
    NodeDef* const_child;
    bool left_child_is_const;
    bool right_child_is_const;
    NodeDef* left_leaf;
    NodeDef* right_leaf;
    bool left_leaf_is_const;
    bool right_leaf_is_const;

    
    const std::vector<OpInfo::TensorProperties>* parent_input_props;
    const std::vector<OpInfo::TensorProperties>* op_child_input_props;
  };

  
  
  
  
  
  
  
  
  
  
  
  
  
  bool PrepareConstantPushDown(const NodeDef& parent, const GraphProperties& properties, bool must_have_properties, ConstantPushDownContext* ctx) const;



  
  
  bool ConstantPushDown(GraphProperties* properties, GraphDef* optimized_graph, NodeDef* node);

  
  
  bool ConstantPushDownBiasAdd(GraphProperties* properties, GraphDef* optimized_graph, NodeDef* node);

  
  
  bool MulConvPushDown(GraphDef* optimized_graph, NodeDef* node, const GraphProperties& properties);

  
  
  bool ReduceDivToReciprocalMul(GraphDef* optimized_graph, NodeDef* node);

  
  
  
  Status SimplifyArithmeticOperations(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);


  
  bool SimplifyReshape(const GraphProperties& properties, bool use_shape_info, NodeDef* node);

  
  
  
  bool IsReductionWithConstantIndices(const NodeDef& node, bool* indices_is_empty) const;
  
  
  bool IsReductionCandidateForSimplification( const NodeDef& node, const GraphProperties& properties, TensorShapeProto* input_tensor_shape, TensorShapeProto* output_tensor_shape, bool* is_single_element_op) const;


  
  
  bool IsReductionSimplifiableToIdentity( const NodeDef& node, const TensorShapeProto& input_shape, bool keep_dims, const gtl::InlinedVector<TensorValue, 4>& reduction_indices_vector) const;

  
  bool ReplaceReductionWithIdentity(NodeDef* node) const;

  
  
  bool SimplifyReduction(GraphDef* optimized_graph, const GraphProperties& properties, NodeDef* node);

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  bool SimplifySwitch(GraphDef* optimized_graph, NodeDef* node);

  
  bool MoveConstantsPastEnter(GraphDef* optimized_graph, NodeDef* node);

  
  bool SimplifyPack(GraphDef* optimized_graph, NodeDef* node);

  
  void SimplifySqueeze(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);

  
  Status SimplifyPad(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);

  
  Status SimplifyTile(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);

  
  Status SimplifyStridedSlice(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);


  
  Status SimplifySlice(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);

  
  bool SimplifyCase(GraphDef* optimized_graph, NodeDef* node);

  
  bool SimplifySelect(const GraphProperties& properties, GraphDef* optimized_graph, NodeDef* node);

  
  void RemoveRedundantVariableUpdates(GraphProperties* properties, GraphDef* optimized_graph, NodeDef* node);

  
  Status RemoveReverse(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);

  
  void RemoveRandomShuffle(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);


  
  Status RemoveShuffleOrTranspose(const GraphProperties& properties, bool use_shape_info, GraphDef* optimized_graph, NodeDef* node);


  
  void RemoveSplitOrSplitV(const GraphProperties& properties, GraphDef* optimized_graph, NodeDef* node);

  bool GetConcatAxis(const NodeDef& node, int* axis);
  bool MergeConcat(bool use_shape_info, GraphProperties* properties, GraphDef* optimized_graph, NodeDef* node);

  Status AddQuantizedMatMulMinMaxOutConstNodes(NodeDef* node, GraphDef* optimized_graph);

  
  RewriterConfig::Toggle opt_level_;
  DeviceBase* cpu_device_;
  std::unique_ptr<DeviceBase> owned_device_;

  std::unique_ptr<ResourceMgr> resource_mgr_;
  GraphDef* graph_;
  std::unique_ptr<NodeMap> node_map_;
  std::unordered_set<string> nodes_to_preserve_;
  
  absl::flat_hash_set<string> nodes_allowlist_;
  absl::flat_hash_set<string> feed_nodes_;
  absl::flat_hash_map<string, bool> maybe_foldable_nodes_;
  bool has_fetch_;
  bool graph_modified_;
  bool graph_contains_assign_or_inplace_op_;
  bool disable_compressed_tensor_optimization_;
  bool fold_quantization_emulation_;
};

}  
}  


