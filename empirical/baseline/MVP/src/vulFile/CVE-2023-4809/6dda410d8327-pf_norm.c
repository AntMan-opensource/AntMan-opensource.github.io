


__FBSDID("$FreeBSD$");

































struct pf_frent {
	TAILQ_ENTRY(pf_frent)	fr_next;
	struct mbuf	*fe_m;
	uint16_t	fe_hdrlen;	
	uint16_t	fe_extoff;	
	uint16_t	fe_len;		
	uint16_t	fe_off;		
	uint16_t	fe_mff;		
};

struct pf_fragment_cmp {
	struct pf_addr	frc_src;
	struct pf_addr	frc_dst;
	uint32_t	frc_id;
	sa_family_t	frc_af;
	uint8_t		frc_proto;
};

struct pf_fragment {
	struct pf_fragment_cmp	fr_key;






	
	struct pf_frent	*fr_firstoff[PF_FRAG_ENTRY_POINTS];
	
	uint8_t	fr_entries[PF_FRAG_ENTRY_POINTS];
	RB_ENTRY(pf_fragment) fr_entry;
	TAILQ_ENTRY(pf_fragment) frag_next;
	uint32_t	fr_timeout;
	uint16_t	fr_maxlen;	
	u_int16_t	fr_holes;	
	TAILQ_HEAD(pf_fragq, pf_frent) fr_queue;
};

struct pf_fragment_tag {
	uint16_t	ft_hdrlen;	
	uint16_t	ft_extoff;	
	uint16_t	ft_maxlen;	
	uint32_t	ft_id;		
};

VNET_DEFINE_STATIC(struct mtx, pf_frag_mtx);





VNET_DEFINE(uma_zone_t, pf_state_scrub_z);	

VNET_DEFINE_STATIC(uma_zone_t, pf_frent_z);

VNET_DEFINE_STATIC(uma_zone_t, pf_frag_z);


TAILQ_HEAD(pf_fragqueue, pf_fragment);
TAILQ_HEAD(pf_cachequeue, pf_fragment);
VNET_DEFINE_STATIC(struct pf_fragqueue,	pf_fragqueue);

RB_HEAD(pf_frag_tree, pf_fragment);
VNET_DEFINE_STATIC(struct pf_frag_tree,	pf_frag_tree);

static int		 pf_frag_compare(struct pf_fragment *, struct pf_fragment *);
static RB_PROTOTYPE(pf_frag_tree, pf_fragment, fr_entry, pf_frag_compare);
static RB_GENERATE(pf_frag_tree, pf_fragment, fr_entry, pf_frag_compare);

static void	pf_flush_fragments(void);
static void	pf_free_fragment(struct pf_fragment *);
static void	pf_remove_fragment(struct pf_fragment *);

static struct pf_frent *pf_create_fragment(u_short *);
static int	pf_frent_holes(struct pf_frent *frent);
static struct pf_fragment *pf_find_fragment(struct pf_fragment_cmp *key, struct pf_frag_tree *tree);
static inline int	pf_frent_index(struct pf_frent *);
static int	pf_frent_insert(struct pf_fragment *, struct pf_frent *, struct pf_frent *);
void			pf_frent_remove(struct pf_fragment *, struct pf_frent *);
struct pf_frent		*pf_frent_previous(struct pf_fragment *, struct pf_frent *);
static struct pf_fragment *pf_fillup_fragment(struct pf_fragment_cmp *, struct pf_frent *, u_short *);
static struct mbuf *pf_join_fragment(struct pf_fragment *);

static int	pf_reassemble(struct mbuf **, struct ip *, int, u_short *);


static int	pf_reassemble6(struct mbuf **, struct ip6_hdr *, struct ip6_frag *, uint16_t, uint16_t, u_short *);









static void pf_ip2key(struct ip *ip, int dir, struct pf_fragment_cmp *key)
{

	key->frc_src.v4 = ip->ip_src;
	key->frc_dst.v4 = ip->ip_dst;
	key->frc_af = AF_INET;
	key->frc_proto = ip->ip_p;
	key->frc_id = ip->ip_id;
}


void pf_normalize_init(void)
{

	V_pf_frag_z = uma_zcreate("pf frags", sizeof(struct pf_fragment), NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
	V_pf_frent_z = uma_zcreate("pf frag entries", sizeof(struct pf_frent), NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
	V_pf_state_scrub_z = uma_zcreate("pf state scrubs", sizeof(struct pf_state_scrub),  NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);


	mtx_init(&V_pf_frag_mtx, "pf fragments", NULL, MTX_DEF);

	V_pf_limits[PF_LIMIT_FRAGS].zone = V_pf_frent_z;
	V_pf_limits[PF_LIMIT_FRAGS].limit = PFFRAG_FRENT_HIWAT;
	uma_zone_set_max(V_pf_frent_z, PFFRAG_FRENT_HIWAT);
	uma_zone_set_warning(V_pf_frent_z, "PF frag entries limit reached");

	TAILQ_INIT(&V_pf_fragqueue);
}

void pf_normalize_cleanup(void)
{

	uma_zdestroy(V_pf_state_scrub_z);
	uma_zdestroy(V_pf_frent_z);
	uma_zdestroy(V_pf_frag_z);

	mtx_destroy(&V_pf_frag_mtx);
}

static int pf_frag_compare(struct pf_fragment *a, struct pf_fragment *b)
{
	int	diff;

	if ((diff = a->fr_id - b->fr_id) != 0)
		return (diff);
	if ((diff = a->fr_proto - b->fr_proto) != 0)
		return (diff);
	if ((diff = a->fr_af - b->fr_af) != 0)
		return (diff);
	if ((diff = pf_addr_cmp(&a->fr_src, &b->fr_src, a->fr_af)) != 0)
		return (diff);
	if ((diff = pf_addr_cmp(&a->fr_dst, &b->fr_dst, a->fr_af)) != 0)
		return (diff);
	return (0);
}

void pf_purge_expired_fragments(void)
{
	u_int32_t	expire = time_uptime - V_pf_default_rule.timeout[PFTM_FRAG];

	pf_purge_fragments(expire);
}

void pf_purge_fragments(uint32_t expire)
{
	struct pf_fragment	*frag;

	PF_FRAG_LOCK();
	while ((frag = TAILQ_LAST(&V_pf_fragqueue, pf_fragqueue)) != NULL) {
		if (frag->fr_timeout > expire)
			break;

		DPFPRINTF(("expiring %d(%p)\n", frag->fr_id, frag));
		pf_free_fragment(frag);
	}

	PF_FRAG_UNLOCK();
}


static void pf_flush_fragments(void)
{
	struct pf_fragment	*frag;
	int			 goal;

	PF_FRAG_ASSERT();

	goal = uma_zone_get_cur(V_pf_frent_z) * 9 / 10;
	DPFPRINTF(("trying to free %d frag entriess\n", goal));
	while (goal < uma_zone_get_cur(V_pf_frent_z)) {
		frag = TAILQ_LAST(&V_pf_fragqueue, pf_fragqueue);
		if (frag)
			pf_free_fragment(frag);
		else break;
	}
}


static void pf_free_fragment(struct pf_fragment *frag)
{
	struct pf_frent		*frent;

	PF_FRAG_ASSERT();

	
	for (frent = TAILQ_FIRST(&frag->fr_queue); frent;
	    frent = TAILQ_FIRST(&frag->fr_queue)) {
		TAILQ_REMOVE(&frag->fr_queue, frent, fr_next);

		m_freem(frent->fe_m);
		uma_zfree(V_pf_frent_z, frent);
	}

	pf_remove_fragment(frag);
}

static struct pf_fragment * pf_find_fragment(struct pf_fragment_cmp *key, struct pf_frag_tree *tree)
{
	struct pf_fragment	*frag;

	PF_FRAG_ASSERT();

	frag = RB_FIND(pf_frag_tree, tree, (struct pf_fragment *)key);
	if (frag != NULL) {
		
		frag->fr_timeout = time_uptime;
		TAILQ_REMOVE(&V_pf_fragqueue, frag, frag_next);
		TAILQ_INSERT_HEAD(&V_pf_fragqueue, frag, frag_next);
	}

	return (frag);
}


static void pf_remove_fragment(struct pf_fragment *frag)
{

	PF_FRAG_ASSERT();
	KASSERT(frag, ("frag != NULL"));

	RB_REMOVE(pf_frag_tree, &V_pf_frag_tree, frag);
	TAILQ_REMOVE(&V_pf_fragqueue, frag, frag_next);
	uma_zfree(V_pf_frag_z, frag);
}

static struct pf_frent * pf_create_fragment(u_short *reason)
{
	struct pf_frent *frent;

	PF_FRAG_ASSERT();

	frent = uma_zalloc(V_pf_frent_z, M_NOWAIT);
	if (frent == NULL) {
		pf_flush_fragments();
		frent = uma_zalloc(V_pf_frent_z, M_NOWAIT);
		if (frent == NULL) {
			REASON_SET(reason, PFRES_MEMORY);
			return (NULL);
		}
	}

	return (frent);
}


static int pf_frent_holes(struct pf_frent *frent)
{
	struct pf_frent *prev = TAILQ_PREV(frent, pf_fragq, fr_next);
	struct pf_frent *next = TAILQ_NEXT(frent, fr_next);
	int holes = 1;

	if (prev == NULL) {
		if (frent->fe_off == 0)
			holes--;
	} else {
		KASSERT(frent->fe_off != 0, ("frent->fe_off != 0"));
		if (frent->fe_off == prev->fe_off + prev->fe_len)
			holes--;
	}
	if (next == NULL) {
		if (!frent->fe_mff)
			holes--;
	} else {
		KASSERT(frent->fe_mff, ("frent->fe_mff"));
		if (next->fe_off == frent->fe_off + frent->fe_len)
			holes--;
	}
	return holes;
}

static inline int pf_frent_index(struct pf_frent *frent)
{
	
	CTASSERT(((u_int16_t)0xffff &~ 7) / (0x10000 / PF_FRAG_ENTRY_POINTS) == 16 - 1);
	CTASSERT(((u_int16_t)0xffff >> 3) / PF_FRAG_ENTRY_POINTS == 512 - 1);

	return frent->fe_off / (0x10000 / PF_FRAG_ENTRY_POINTS);
}

static int pf_frent_insert(struct pf_fragment *frag, struct pf_frent *frent, struct pf_frent *prev)

{
	int index;

	CTASSERT(PF_FRAG_ENTRY_LIMIT <= 0xff);

	
	index = pf_frent_index(frent);
	if (frag->fr_entries[index] >= PF_FRAG_ENTRY_LIMIT)
		return ENOBUFS;
	frag->fr_entries[index]++;

	if (prev == NULL) {
		TAILQ_INSERT_HEAD(&frag->fr_queue, frent, fr_next);
	} else {
		KASSERT(prev->fe_off + prev->fe_len <= frent->fe_off, ("overlapping fragment"));
		TAILQ_INSERT_AFTER(&frag->fr_queue, prev, frent, fr_next);
	}

	if (frag->fr_firstoff[index] == NULL) {
		KASSERT(prev == NULL || pf_frent_index(prev) < index, ("prev == NULL || pf_frent_index(pref) < index"));
		frag->fr_firstoff[index] = frent;
	} else {
		if (frent->fe_off < frag->fr_firstoff[index]->fe_off) {
			KASSERT(prev == NULL || pf_frent_index(prev) < index, ("prev == NULL || pf_frent_index(pref) < index"));
			frag->fr_firstoff[index] = frent;
		} else {
			KASSERT(prev != NULL, ("prev != NULL"));
			KASSERT(pf_frent_index(prev) == index, ("pf_frent_index(prev) == index"));
		}
	}

	frag->fr_holes += pf_frent_holes(frent);

	return 0;
}

void pf_frent_remove(struct pf_fragment *frag, struct pf_frent *frent)
{

	struct pf_frent *prev = TAILQ_PREV(frent, pf_fragq, fr_next);

	struct pf_frent *next = TAILQ_NEXT(frent, fr_next);
	int index;

	frag->fr_holes -= pf_frent_holes(frent);

	index = pf_frent_index(frent);
	KASSERT(frag->fr_firstoff[index] != NULL, ("frent not found"));
	if (frag->fr_firstoff[index]->fe_off == frent->fe_off) {
		if (next == NULL) {
			frag->fr_firstoff[index] = NULL;
		} else {
			KASSERT(frent->fe_off + frent->fe_len <= next->fe_off, ("overlapping fragment"));
			if (pf_frent_index(next) == index) {
				frag->fr_firstoff[index] = next;
			} else {
				frag->fr_firstoff[index] = NULL;
			}
		}
	} else {
		KASSERT(frag->fr_firstoff[index]->fe_off < frent->fe_off, ("frag->fr_firstoff[index]->fe_off < frent->fe_off"));
		KASSERT(prev != NULL, ("prev != NULL"));
		KASSERT(prev->fe_off + prev->fe_len <= frent->fe_off, ("overlapping fragment"));
		KASSERT(pf_frent_index(prev) == index, ("pf_frent_index(prev) == index"));
	}

	TAILQ_REMOVE(&frag->fr_queue, frent, fr_next);

	KASSERT(frag->fr_entries[index] > 0, ("No fragments remaining"));
	frag->fr_entries[index]--;
}

struct pf_frent * pf_frent_previous(struct pf_fragment *frag, struct pf_frent *frent)
{
	struct pf_frent *prev, *next;
	int index;

	
	prev = TAILQ_LAST(&frag->fr_queue, pf_fragq);
	KASSERT(prev != NULL, ("prev != NULL"));
	if (prev->fe_off <= frent->fe_off)
		return prev;
	
	for (index = pf_frent_index(frent); index < PF_FRAG_ENTRY_POINTS;
	    index++) {
		prev = frag->fr_firstoff[index];
		if (prev != NULL)
			break;
	}
	KASSERT(prev != NULL, ("prev != NULL"));
	
	if (prev->fe_off > frent->fe_off) {
		prev = TAILQ_PREV(prev, pf_fragq, fr_next);
		if (prev == NULL)
			return NULL;
		KASSERT(prev->fe_off <= frent->fe_off, ("prev->fe_off <= frent->fe_off"));
		return prev;
	}
	
	for (next = TAILQ_NEXT(prev, fr_next); next != NULL;
	    next = TAILQ_NEXT(next, fr_next)) {
		if (next->fe_off > frent->fe_off)
			break;
		prev = next;
	}
	return prev;
}

static struct pf_fragment * pf_fillup_fragment(struct pf_fragment_cmp *key, struct pf_frent *frent, u_short *reason)

{
	struct pf_frent		*after, *next, *prev;
	struct pf_fragment	*frag;
	uint16_t		total;
	int			old_index, new_index;

	PF_FRAG_ASSERT();

	
	if (frent->fe_len == 0) {
		DPFPRINTF(("bad fragment: len 0\n"));
		goto bad_fragment;
	}

	
	if (frent->fe_mff && (frent->fe_len & 0x7)) {
		DPFPRINTF(("bad fragment: mff and len %d\n", frent->fe_len));
		goto bad_fragment;
	}

	
	if (frent->fe_off + frent->fe_len > IP_MAXPACKET) {
		DPFPRINTF(("bad fragment: max packet %d\n", frent->fe_off + frent->fe_len));
		goto bad_fragment;
	}

	DPFPRINTF((key->frc_af == AF_INET ? "reass frag %d @ %d-%d\n" : "reass frag %#08x @ %d-%d\n", key->frc_id, frent->fe_off, frent->fe_off + frent->fe_len));


	
	frag = pf_find_fragment(key, &V_pf_frag_tree);

	
	if (frag == NULL) {
		frag = uma_zalloc(V_pf_frag_z, M_NOWAIT);
		if (frag == NULL) {
			pf_flush_fragments();
			frag = uma_zalloc(V_pf_frag_z, M_NOWAIT);
			if (frag == NULL) {
				REASON_SET(reason, PFRES_MEMORY);
				goto drop_fragment;
			}
		}

		*(struct pf_fragment_cmp *)frag = *key;
		memset(frag->fr_firstoff, 0, sizeof(frag->fr_firstoff));
		memset(frag->fr_entries, 0, sizeof(frag->fr_entries));
		frag->fr_timeout = time_uptime;
		frag->fr_maxlen = frent->fe_len;
		frag->fr_holes = 1;
		TAILQ_INIT(&frag->fr_queue);

		RB_INSERT(pf_frag_tree, &V_pf_frag_tree, frag);
		TAILQ_INSERT_HEAD(&V_pf_fragqueue, frag, frag_next);

		
		pf_frent_insert(frag, frent, NULL);

		return (frag);
	}

	KASSERT(!TAILQ_EMPTY(&frag->fr_queue), ("!TAILQ_EMPTY()->fr_queue"));

	
	if (frent->fe_len > frag->fr_maxlen)
		frag->fr_maxlen = frent->fe_len;

	
	total = TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_off + TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_len;

	
	if (frent->fe_off + frent->fe_len < total && !frent->fe_mff)
		goto bad_fragment;

	
	if (!TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_mff) {
		if (frent->fe_off + frent->fe_len > total || (frent->fe_off + frent->fe_len == total && frent->fe_mff))
			goto bad_fragment;
	} else {
		if (frent->fe_off + frent->fe_len == total && !frent->fe_mff)
			goto bad_fragment;
	}

	
	prev = pf_frent_previous(frag, frent);
	if (prev == NULL) {
		after = TAILQ_FIRST(&frag->fr_queue);
		KASSERT(after != NULL, ("after != NULL"));
	} else {
		after = TAILQ_NEXT(prev, fr_next);
	}

	if (prev != NULL && prev->fe_off + prev->fe_len > frent->fe_off) {
		uint16_t precut;

		precut = prev->fe_off + prev->fe_len - frent->fe_off;
		if (precut >= frent->fe_len)
			goto bad_fragment;
		DPFPRINTF(("overlap -%d\n", precut));
		m_adj(frent->fe_m, precut);
		frent->fe_off += precut;
		frent->fe_len -= precut;
	}

	for (; after != NULL && frent->fe_off + frent->fe_len > after->fe_off;
	    after = next) {
		uint16_t aftercut;

		aftercut = frent->fe_off + frent->fe_len - after->fe_off;
		DPFPRINTF(("adjust overlap %d\n", aftercut));
		if (aftercut < after->fe_len) {
			m_adj(after->fe_m, aftercut);
			old_index = pf_frent_index(after);
			after->fe_off += aftercut;
			after->fe_len -= aftercut;
			new_index = pf_frent_index(after);
			if (old_index != new_index) {
				DPFPRINTF(("frag index %d, new %d", old_index, new_index));
				
				after->fe_off -= aftercut;
				after->fe_len += aftercut;
				
				pf_frent_remove(frag, after);
				after->fe_off += aftercut;
				after->fe_len -= aftercut;
				
				if (pf_frent_insert(frag, after, prev)) {
					DPFPRINTF( ("fragment requeue limit exceeded"));
					m_freem(after->fe_m);
					uma_zfree(V_pf_frent_z, after);
					
					goto bad_fragment;
				}
			}
			break;
		}

		
		next = TAILQ_NEXT(after, fr_next);
		pf_frent_remove(frag, after);
		m_freem(after->fe_m);
		uma_zfree(V_pf_frent_z, after);
	}

	
	if (pf_frent_insert(frag, frent, prev)) {
		DPFPRINTF(("fragment queue limit exceeded\n"));
		goto bad_fragment;
	}

	return (frag);

bad_fragment:
	REASON_SET(reason, PFRES_FRAG);
drop_fragment:
	uma_zfree(V_pf_frent_z, frent);
	return (NULL);
}

static struct mbuf * pf_join_fragment(struct pf_fragment *frag)
{
	struct mbuf *m, *m2;
	struct pf_frent	*frent, *next;

	frent = TAILQ_FIRST(&frag->fr_queue);
	next = TAILQ_NEXT(frent, fr_next);

	m = frent->fe_m;
	m_adj(m, (frent->fe_hdrlen + frent->fe_len) - m->m_pkthdr.len);
	uma_zfree(V_pf_frent_z, frent);
	for (frent = next; frent != NULL; frent = next) {
		next = TAILQ_NEXT(frent, fr_next);

		m2 = frent->fe_m;
		
		m_adj(m2, frent->fe_hdrlen);
		
		m_adj(m2, frent->fe_len - m2->m_pkthdr.len);

		uma_zfree(V_pf_frent_z, frent);
		m_cat(m, m2);
	}

	
	pf_remove_fragment(frag);

	return (m);
}


static int pf_reassemble(struct mbuf **m0, struct ip *ip, int dir, u_short *reason)
{
	struct mbuf		*m = *m0;
	struct pf_frent		*frent;
	struct pf_fragment	*frag;
	struct pf_fragment_cmp	key;
	uint16_t		total, hdrlen;

	
	if ((frent = pf_create_fragment(reason)) == NULL)
		return (PF_DROP);

	frent->fe_m = m;
	frent->fe_hdrlen = ip->ip_hl << 2;
	frent->fe_extoff = 0;
	frent->fe_len = ntohs(ip->ip_len) - (ip->ip_hl << 2);
	frent->fe_off = (ntohs(ip->ip_off) & IP_OFFMASK) << 3;
	frent->fe_mff = ntohs(ip->ip_off) & IP_MF;

	pf_ip2key(ip, dir, &key);

	if ((frag = pf_fillup_fragment(&key, frent, reason)) == NULL)
		return (PF_DROP);

	
	m = *m0 = NULL;

	if (frag->fr_holes) {
		DPFPRINTF(("frag %d, holes %d\n", frag->fr_id, frag->fr_holes));
		return (PF_PASS);  
	}

	
	frent = TAILQ_FIRST(&frag->fr_queue);
	KASSERT(frent != NULL, ("frent != NULL"));
	total = TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_off + TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_len;
	hdrlen = frent->fe_hdrlen;

	m = *m0 = pf_join_fragment(frag);
	frag = NULL;

	if (m->m_flags & M_PKTHDR) {
		int plen = 0;
		for (m = *m0; m; m = m->m_next)
			plen += m->m_len;
		m = *m0;
		m->m_pkthdr.len = plen;
	}

	ip = mtod(m, struct ip *);
	ip->ip_sum = pf_cksum_fixup(ip->ip_sum, ip->ip_len, htons(hdrlen + total), 0);
	ip->ip_len = htons(hdrlen + total);
	ip->ip_sum = pf_cksum_fixup(ip->ip_sum, ip->ip_off, ip->ip_off & ~(IP_MF|IP_OFFMASK), 0);
	ip->ip_off &= ~(IP_MF|IP_OFFMASK);

	if (hdrlen + total > IP_MAXPACKET) {
		DPFPRINTF(("drop: too big: %d\n", total));
		ip->ip_len = 0;
		REASON_SET(reason, PFRES_SHORT);
		
		return (PF_DROP);
	}

	DPFPRINTF(("complete: %p(%d)\n", m, ntohs(ip->ip_len)));
	return (PF_PASS);
}



static int pf_reassemble6(struct mbuf **m0, struct ip6_hdr *ip6, struct ip6_frag *fraghdr, uint16_t hdrlen, uint16_t extoff, u_short *reason)

{
	struct mbuf		*m = *m0;
	struct pf_frent		*frent;
	struct pf_fragment	*frag;
	struct pf_fragment_cmp	 key;
	struct m_tag		*mtag;
	struct pf_fragment_tag	*ftag;
	int			 off;
	uint32_t		 frag_id;
	uint16_t		 total, maxlen;
	uint8_t			 proto;

	PF_FRAG_LOCK();

	
	if ((frent = pf_create_fragment(reason)) == NULL) {
		PF_FRAG_UNLOCK();
		return (PF_DROP);
	}

	frent->fe_m = m;
	frent->fe_hdrlen = hdrlen;
	frent->fe_extoff = extoff;
	frent->fe_len = sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen) - hdrlen;
	frent->fe_off = ntohs(fraghdr->ip6f_offlg & IP6F_OFF_MASK);
	frent->fe_mff = fraghdr->ip6f_offlg & IP6F_MORE_FRAG;

	key.frc_src.v6 = ip6->ip6_src;
	key.frc_dst.v6 = ip6->ip6_dst;
	key.frc_af = AF_INET6;
	
	key.frc_proto = 0;
	key.frc_id = fraghdr->ip6f_ident;

	if ((frag = pf_fillup_fragment(&key, frent, reason)) == NULL) {
		PF_FRAG_UNLOCK();
		return (PF_DROP);
	}

	
	m = *m0 = NULL;

	if (frag->fr_holes) {
		DPFPRINTF(("frag %d, holes %d\n", frag->fr_id, frag->fr_holes));
		PF_FRAG_UNLOCK();
		return (PF_PASS);  
	}

	
	frent = TAILQ_FIRST(&frag->fr_queue);
	KASSERT(frent != NULL, ("frent != NULL"));
	extoff = frent->fe_extoff;
	maxlen = frag->fr_maxlen;
	frag_id = frag->fr_id;
	total = TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_off + TAILQ_LAST(&frag->fr_queue, pf_fragq)->fe_len;
	hdrlen = frent->fe_hdrlen - sizeof(struct ip6_frag);

	m = *m0 = pf_join_fragment(frag);
	frag = NULL;

	PF_FRAG_UNLOCK();

	
	m = m_getptr(m, hdrlen + offsetof(struct ip6_frag, ip6f_nxt), &off);
	KASSERT(m, ("%s: short mbuf chain", __func__));
	proto = *(mtod(m, uint8_t *) + off);
	m = *m0;

	
	if (ip6_deletefraghdr(m, hdrlen, M_NOWAIT) != 0)
		goto fail;

	if (m->m_flags & M_PKTHDR) {
		int plen = 0;
		for (m = *m0; m; m = m->m_next)
			plen += m->m_len;
		m = *m0;
		m->m_pkthdr.len = plen;
	}

	if ((mtag = m_tag_get(PACKET_TAG_PF_REASSEMBLED, sizeof(struct pf_fragment_tag), M_NOWAIT)) == NULL)
		goto fail;
	ftag = (struct pf_fragment_tag *)(mtag + 1);
	ftag->ft_hdrlen = hdrlen;
	ftag->ft_extoff = extoff;
	ftag->ft_maxlen = maxlen;
	ftag->ft_id = frag_id;
	m_tag_prepend(m, mtag);

	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_plen = htons(hdrlen - sizeof(struct ip6_hdr) + total);
	if (extoff) {
		
		m = m_getptr(m, extoff + offsetof(struct ip6_ext, ip6e_nxt), &off);
		KASSERT(m, ("%s: short mbuf chain", __func__));
		*(mtod(m, char *) + off) = proto;
		m = *m0;
	} else ip6->ip6_nxt = proto;

	if (hdrlen - sizeof(struct ip6_hdr) + total > IPV6_MAXPACKET) {
		DPFPRINTF(("drop: too big: %d\n", total));
		ip6->ip6_plen = 0;
		REASON_SET(reason, PFRES_SHORT);
		
		return (PF_DROP);
	}

	DPFPRINTF(("complete: %p(%d)\n", m, ntohs(ip6->ip6_plen)));
	return (PF_PASS);

fail:
	REASON_SET(reason, PFRES_MEMORY);
	
	return (PF_DROP);
}



int pf_refragment6(struct ifnet *ifp, struct mbuf **m0, struct m_tag *mtag, bool forward)

{
	struct mbuf		*m = *m0, *t;
	struct ip6_hdr		*hdr;
	struct pf_fragment_tag	*ftag = (struct pf_fragment_tag *)(mtag + 1);
	struct pf_pdesc		 pd;
	uint32_t		 frag_id;
	uint16_t		 hdrlen, extoff, maxlen;
	uint8_t			 proto;
	int			 error, action;

	hdrlen = ftag->ft_hdrlen;
	extoff = ftag->ft_extoff;
	maxlen = ftag->ft_maxlen;
	frag_id = ftag->ft_id;
	m_tag_delete(m, mtag);
	mtag = NULL;
	ftag = NULL;

	if (extoff) {
		int off;

		
		m = m_getptr(m, extoff + offsetof(struct ip6_ext, ip6e_nxt), &off);
		KASSERT((m != NULL), ("pf_refragment6: short mbuf chain"));
		proto = *(mtod(m, uint8_t *) + off);
		*(mtod(m, char *) + off) = IPPROTO_FRAGMENT;
		m = *m0;
	} else {
		hdr = mtod(m, struct ip6_hdr *);
		proto = hdr->ip6_nxt;
		hdr->ip6_nxt = IPPROTO_FRAGMENT;
	}

	
	hdr = mtod(m, struct ip6_hdr *);

	in6_setscope(&hdr->ip6_src, ifp, NULL);
	in6_setscope(&hdr->ip6_dst, ifp, NULL);

	
	maxlen = maxlen & ~7;

	
	error = ip6_fragment(ifp, m, hdrlen, proto, maxlen, frag_id);
	m = (*m0)->m_nextpkt;
	(*m0)->m_nextpkt = NULL;
	if (error == 0) {
		
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} else {
		
		DPFPRINTF(("refragment error %d\n", error));
		action = PF_DROP;
	}
	for (; m; m = t) {
		t = m->m_nextpkt;
		m->m_nextpkt = NULL;
		m->m_flags |= M_SKIP_FIREWALL;
		memset(&pd, 0, sizeof(pd));
		pd.pf_mtag = pf_find_mtag(m);
		if (error == 0)
			if (forward) {
				MPASS(m->m_pkthdr.rcvif != NULL);
				ip6_forward(m, 0);
			} else {
				(void)ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
			}
		else m_freem(m);
	}

	return (action);
}



int pf_normalize_ip(struct mbuf **m0, struct pfi_kkif *kif, u_short *reason, struct pf_pdesc *pd)

{
	struct mbuf		*m = *m0;
	struct pf_krule		*r;
	struct ip		*h = mtod(m, struct ip *);
	int			 mff = (ntohs(h->ip_off) & IP_MF);
	int			 hlen = h->ip_hl << 2;
	u_int16_t		 fragoff = (ntohs(h->ip_off) & IP_OFFMASK) << 3;
	u_int16_t		 max;
	int			 ip_len;
	int			 tag = -1;
	int			 verdict;
	int			 srs;

	PF_RULES_RASSERT();

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	
	srs = (r != NULL);
	while (r != NULL) {
		pf_counter_u64_add(&r->evaluations, 1);
		if (pfi_kkif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != pd->dir)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != AF_INET)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != h->ip_p)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, (struct pf_addr *)&h->ip_src.s_addr, AF_INET, r->src.neg, kif, M_GETFIB(m)))

			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, (struct pf_addr *)&h->ip_dst.s_addr, AF_INET, r->dst.neg, NULL, M_GETFIB(m)))

			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->match_tag && !pf_match_tag(m, r, &tag, pd->pf_mtag ? pd->pf_mtag->tag : 0))
			r = TAILQ_NEXT(r, entries);
		else break;
	}

	if (srs) {
		
		if (r == NULL || r->action == PF_NOSCRUB)
			return (PF_PASS);

		pf_counter_u64_critical_enter();
		pf_counter_u64_add_protected(&r->packets[pd->dir == PF_OUT], 1);
		pf_counter_u64_add_protected(&r->bytes[pd->dir == PF_OUT], pd->tot_len);
		pf_counter_u64_critical_exit();
		pf_rule_to_actions(r, &pd->act);
	} else if ((!V_pf_status.reass && (h->ip_off & htons(IP_MF | IP_OFFMASK)))) {
		
		REASON_SET(reason, PFRES_NORM);
		goto drop;
	}

	
	if (hlen < (int)sizeof(struct ip)) {
		REASON_SET(reason, PFRES_NORM);
		goto drop;
	}

	if (hlen > ntohs(h->ip_len)) {
		REASON_SET(reason, PFRES_NORM);
		goto drop;
	}

	
	if ((((r && r->rule_flag & PFRULE_NODF) || (V_pf_status.reass & PF_REASS_NODF)) && h->ip_off & htons(IP_DF)
	)) {
		u_int16_t ip_off = h->ip_off;

		h->ip_off &= htons(~IP_DF);
		h->ip_sum = pf_cksum_fixup(h->ip_sum, ip_off, h->ip_off, 0);
	}

	
	if (!fragoff && !mff)
		goto no_fragment;

	
	if (h->ip_off & htons(IP_DF)) {
		DPFPRINTF(("IP_DF\n"));
		goto bad;
	}

	ip_len = ntohs(h->ip_len) - hlen;

	
	if (mff && (ip_len & 0x7)) {
		DPFPRINTF(("mff and %d\n", ip_len));
		goto bad;
	}

	
	if (fragoff + ip_len > IP_MAXPACKET) {
		DPFPRINTF(("max packet %d\n", fragoff + ip_len));
		goto bad;
	}

	if (r==NULL || !(r->rule_flag & PFRULE_FRAGMENT_NOREASS)) {
		max = fragoff + ip_len;

		
		PF_FRAG_LOCK();
		DPFPRINTF(("reass frag %d @ %d-%d\n", h->ip_id, fragoff, max));
		verdict = pf_reassemble(m0, h, pd->dir, reason);
		PF_FRAG_UNLOCK();

		if (verdict != PF_PASS)
			return (PF_DROP);

		m = *m0;
		if (m == NULL)
			return (PF_DROP);

		h = mtod(m, struct ip *);

 no_fragment:
		
		if (h->ip_off & ~htons(IP_DF)) {
			u_int16_t ip_off = h->ip_off;

			h->ip_off &= htons(IP_DF);
			h->ip_sum = pf_cksum_fixup(h->ip_sum, ip_off, h->ip_off, 0);
		}
	}

	return (PF_PASS);

 bad:
	DPFPRINTF(("dropping bad fragment\n"));
	REASON_SET(reason, PFRES_FRAG);
 drop:
	if (r != NULL && r->log)
		PFLOG_PACKET(kif, m, AF_INET, *reason, r, NULL, NULL, pd, 1);

	return (PF_DROP);
}



int pf_normalize_ip6(struct mbuf **m0, struct pfi_kkif *kif, u_short *reason, struct pf_pdesc *pd)

{
	struct mbuf		*m = *m0;
	struct pf_krule		*r;
	struct ip6_hdr		*h = mtod(m, struct ip6_hdr *);
	int			 extoff;
	int			 off;
	struct ip6_ext		 ext;
	struct ip6_opt		 opt;
	struct ip6_frag		 frag;
	u_int32_t		 plen;
	int			 optend;
	int			 ooff;
	u_int8_t		 proto;
	int			 terminal;
	int			 srs;

	PF_RULES_RASSERT();

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	
	srs = (r != NULL);
	while (r != NULL) {
		pf_counter_u64_add(&r->evaluations, 1);
		if (pfi_kkif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != pd->dir)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != AF_INET6)
			r = r->skip[PF_SKIP_AF].ptr;

		else if (r->proto && r->proto != h->ip6_nxt)
			r = r->skip[PF_SKIP_PROTO].ptr;

		else if (PF_MISMATCHAW(&r->src.addr, (struct pf_addr *)&h->ip6_src, AF_INET6, r->src.neg, kif, M_GETFIB(m)))

			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, (struct pf_addr *)&h->ip6_dst, AF_INET6, r->dst.neg, NULL, M_GETFIB(m)))

			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else break;
	}

	if (srs) {
		
		if (r == NULL || r->action == PF_NOSCRUB)
			return (PF_PASS);

		pf_counter_u64_critical_enter();
		pf_counter_u64_add_protected(&r->packets[pd->dir == PF_OUT], 1);
		pf_counter_u64_add_protected(&r->bytes[pd->dir == PF_OUT], pd->tot_len);
		pf_counter_u64_critical_exit();
		pf_rule_to_actions(r, &pd->act);
	}

	
	if (sizeof(struct ip6_hdr) + IPV6_MAXPACKET < m->m_pkthdr.len)
		goto drop;

	plen = ntohs(h->ip6_plen);
	
	if (plen == 0)
		goto drop;

	extoff = 0;
	off = sizeof(struct ip6_hdr);
	proto = h->ip6_nxt;
	terminal = 0;
	do {
		switch (proto) {
		case IPPROTO_FRAGMENT:
			goto fragment;
			break;
		case IPPROTO_AH:
		case IPPROTO_ROUTING:
		case IPPROTO_DSTOPTS:
			if (!pf_pull_hdr(m, off, &ext, sizeof(ext), NULL, NULL, AF_INET6))
				goto shortpkt;
			extoff = off;
			if (proto == IPPROTO_AH)
				off += (ext.ip6e_len + 2) * 4;
			else off += (ext.ip6e_len + 1) * 8;
			proto = ext.ip6e_nxt;
			break;
		case IPPROTO_HOPOPTS:
			if (!pf_pull_hdr(m, off, &ext, sizeof(ext), NULL, NULL, AF_INET6))
				goto shortpkt;
			extoff = off;
			optend = off + (ext.ip6e_len + 1) * 8;
			ooff = off + sizeof(ext);
			do {
				if (!pf_pull_hdr(m, ooff, &opt.ip6o_type, sizeof(opt.ip6o_type), NULL, NULL, AF_INET6))

					goto shortpkt;
				if (opt.ip6o_type == IP6OPT_PAD1) {
					ooff++;
					continue;
				}
				if (!pf_pull_hdr(m, ooff, &opt, sizeof(opt), NULL, NULL, AF_INET6))
					goto shortpkt;
				if (ooff + sizeof(opt) + opt.ip6o_len > optend)
					goto drop;
				if (opt.ip6o_type == IP6OPT_JUMBO)
					goto drop;
				ooff += sizeof(opt) + opt.ip6o_len;
			} while (ooff < optend);

			off = optend;
			proto = ext.ip6e_nxt;
			break;
		default:
			terminal = 1;
			break;
		}
	} while (!terminal);

	if (sizeof(struct ip6_hdr) + plen > m->m_pkthdr.len)
		goto shortpkt;

	return (PF_PASS);

 fragment:
	if (sizeof(struct ip6_hdr) + plen > m->m_pkthdr.len)
		goto shortpkt;

	if (!pf_pull_hdr(m, off, &frag, sizeof(frag), NULL, NULL, AF_INET6))
		goto shortpkt;

	
	off += sizeof(frag);

	
	if (pf_reassemble6(m0, h, &frag, off, extoff, reason) != PF_PASS)
		return (PF_DROP);
	m = *m0;
	if (m == NULL)
		return (PF_DROP);

	pd->flags |= PFDESC_IP_REAS;
	return (PF_PASS);

 shortpkt:
	REASON_SET(reason, PFRES_SHORT);
	if (r != NULL && r->log)
		PFLOG_PACKET(kif, m, AF_INET6, *reason, r, NULL, NULL, pd, 1);
	return (PF_DROP);

 drop:
	REASON_SET(reason, PFRES_NORM);
	if (r != NULL && r->log)
		PFLOG_PACKET(kif, m, AF_INET6, *reason, r, NULL, NULL, pd, 1);
	return (PF_DROP);
}


int pf_normalize_tcp(struct pfi_kkif *kif, struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)

{
	struct pf_krule	*r, *rm = NULL;
	struct tcphdr	*th = &pd->hdr.tcp;
	int		 rewrite = 0;
	u_short		 reason;
	u_int8_t	 flags;
	sa_family_t	 af = pd->af;
	int		 srs;

	PF_RULES_RASSERT();

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	
	srs = (r != NULL);
	while (r != NULL) {
		pf_counter_u64_add(&r->evaluations, 1);
		if (pfi_kkif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != pd->dir)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg, kif, M_GETFIB(m)))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (r->src.port_op && !pf_match_port(r->src.port_op, r->src.port[0], r->src.port[1], th->th_sport))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg, NULL, M_GETFIB(m)))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op, r->dst.port[0], r->dst.port[1], th->th_dport))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else if (r->os_fingerprint != PF_OSFP_ANY && !pf_osfp_match( pf_osfp_fingerprint(pd, m, off, th), r->os_fingerprint))

			r = TAILQ_NEXT(r, entries);
		else {
			rm = r;
			break;
		}
	}

	if (srs) {
		
		if (rm == NULL || rm->action == PF_NOSCRUB)
			return (PF_PASS);

		pf_counter_u64_critical_enter();
		pf_counter_u64_add_protected(&r->packets[pd->dir == PF_OUT], 1);
		pf_counter_u64_add_protected(&r->bytes[pd->dir == PF_OUT], pd->tot_len);
		pf_counter_u64_critical_exit();
		pf_rule_to_actions(rm, &pd->act);
	}

	if (rm && rm->rule_flag & PFRULE_REASSEMBLE_TCP)
		pd->flags |= PFDESC_TCP_NORM;

	flags = th->th_flags;
	if (flags & TH_SYN) {
		
		if (flags & TH_RST)
			goto tcp_drop;

		if (flags & TH_FIN)
			goto tcp_drop;
	} else {
		
		if (!(flags & (TH_ACK|TH_RST)))
			goto tcp_drop;
	}

	if (!(flags & TH_ACK)) {
		
		if ((flags & TH_FIN) || (flags & TH_PUSH) || (flags & TH_URG))
			goto tcp_drop;
	}

	
	if (th->th_off < (sizeof(struct tcphdr) >> 2))
		goto tcp_drop;

	
	if (flags != th->th_flags || th->th_x2 != 0) {
		u_int16_t	ov, nv;

		ov = *(u_int16_t *)(&th->th_ack + 1);
		th->th_flags = flags;
		th->th_x2 = 0;
		nv = *(u_int16_t *)(&th->th_ack + 1);

		th->th_sum = pf_proto_cksum_fixup(m, th->th_sum, ov, nv, 0);
		rewrite = 1;
	}

	
	if (!(flags & TH_URG) && th->th_urp) {
		th->th_sum = pf_proto_cksum_fixup(m, th->th_sum, th->th_urp, 0, 0);
		th->th_urp = 0;
		rewrite = 1;
	}

	
	if (rewrite)
		m_copyback(m, off, sizeof(*th), (caddr_t)th);

	return (PF_PASS);

 tcp_drop:
	REASON_SET(&reason, PFRES_NORM);
	if (rm != NULL && r->log)
		PFLOG_PACKET(kif, m, AF_INET, reason, r, NULL, NULL, pd, 1);
	return (PF_DROP);
}

int pf_normalize_tcp_init(struct mbuf *m, int off, struct pf_pdesc *pd, struct tcphdr *th, struct pf_state_peer *src, struct pf_state_peer *dst)

{
	u_int32_t tsval, tsecr;
	u_int8_t hdr[60];
	u_int8_t *opt;

	KASSERT((src->scrub == NULL), ("pf_normalize_tcp_init: src->scrub != NULL"));

	src->scrub = uma_zalloc(V_pf_state_scrub_z, M_ZERO | M_NOWAIT);
	if (src->scrub == NULL)
		return (1);

	switch (pd->af) {

	case AF_INET: {
		struct ip *h = mtod(m, struct ip *);
		src->scrub->pfss_ttl = h->ip_ttl;
		break;
	}


	case AF_INET6: {
		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);
		src->scrub->pfss_ttl = h->ip6_hlim;
		break;
	}

	}

	
	if ((th->th_flags & TH_SYN) == 0)
		return (0);

	if (th->th_off > (sizeof(struct tcphdr) >> 2) && src->scrub && pf_pull_hdr(m, off, hdr, th->th_off << 2, NULL, NULL, pd->af)) {
		
		int hlen;
		opt = hdr + sizeof(struct tcphdr);
		hlen = (th->th_off << 2) - sizeof(struct tcphdr);
		while (hlen >= TCPOLEN_TIMESTAMP) {
			switch (*opt) {
			case TCPOPT_EOL:	
			case TCPOPT_NOP:
				opt++;
				hlen--;
				break;
			case TCPOPT_TIMESTAMP:
				if (opt[1] >= TCPOLEN_TIMESTAMP) {
					src->scrub->pfss_flags |= PFSS_TIMESTAMP;
					src->scrub->pfss_ts_mod = htonl(arc4random());

					
					memcpy(&tsval, &opt[2], sizeof(u_int32_t));
					memcpy(&tsecr, &opt[6], sizeof(u_int32_t));
					src->scrub->pfss_tsval0 = ntohl(tsval);
					src->scrub->pfss_tsval = ntohl(tsval);
					src->scrub->pfss_tsecr = ntohl(tsecr);
					getmicrouptime(&src->scrub->pfss_last);
				}
				
			default:
				hlen -= MAX(opt[1], 2);
				opt += MAX(opt[1], 2);
				break;
			}
		}
	}

	return (0);
}

void pf_normalize_tcp_cleanup(struct pf_kstate *state)
{
	uma_zfree(V_pf_state_scrub_z, state->src.scrub);
	uma_zfree(V_pf_state_scrub_z, state->dst.scrub);

	
}

int pf_normalize_tcp_stateful(struct mbuf *m, int off, struct pf_pdesc *pd, u_short *reason, struct tcphdr *th, struct pf_kstate *state, struct pf_state_peer *src, struct pf_state_peer *dst, int *writeback)


{
	struct timeval uptime;
	u_int32_t tsval, tsecr;
	u_int tsval_from_last;
	u_int8_t hdr[60];
	u_int8_t *opt;
	int copyback = 0;
	int got_ts = 0;
	size_t startoff;

	KASSERT((src->scrub || dst->scrub), ("%s: src->scrub && dst->scrub!", __func__));

	
	switch (pd->af) {

	case AF_INET: {
		if (src->scrub) {
			struct ip *h = mtod(m, struct ip *);
			if (h->ip_ttl > src->scrub->pfss_ttl)
				src->scrub->pfss_ttl = h->ip_ttl;
			h->ip_ttl = src->scrub->pfss_ttl;
		}
		break;
	}


	case AF_INET6: {
		if (src->scrub) {
			struct ip6_hdr *h = mtod(m, struct ip6_hdr *);
			if (h->ip6_hlim > src->scrub->pfss_ttl)
				src->scrub->pfss_ttl = h->ip6_hlim;
			h->ip6_hlim = src->scrub->pfss_ttl;
		}
		break;
	}

	}

	if (th->th_off > (sizeof(struct tcphdr) >> 2) && ((src->scrub && (src->scrub->pfss_flags & PFSS_TIMESTAMP)) || (dst->scrub && (dst->scrub->pfss_flags & PFSS_TIMESTAMP))) && pf_pull_hdr(m, off, hdr, th->th_off << 2, NULL, NULL, pd->af)) {


		
		int hlen;
		opt = hdr + sizeof(struct tcphdr);
		hlen = (th->th_off << 2) - sizeof(struct tcphdr);
		while (hlen >= TCPOLEN_TIMESTAMP) {
			startoff = opt - (hdr + sizeof(struct tcphdr));
			switch (*opt) {
			case TCPOPT_EOL:	
			case TCPOPT_NOP:
				opt++;
				hlen--;
				break;
			case TCPOPT_TIMESTAMP:
				

				if (got_ts) {
					
					if (V_pf_status.debug >= PF_DEBUG_MISC) {
						DPFPRINTF(("multiple TS??\n"));
						pf_print_state(state);
						printf("\n");
					}
					REASON_SET(reason, PFRES_TS);
					return (PF_DROP);
				}
				if (opt[1] >= TCPOLEN_TIMESTAMP) {
					memcpy(&tsval, &opt[2], sizeof(u_int32_t));
					if (tsval && src->scrub && (src->scrub->pfss_flags & PFSS_TIMESTAMP)) {

						tsval = ntohl(tsval);
						pf_patch_32_unaligned(m, &th->th_sum, &opt[2], htonl(tsval + src->scrub->pfss_ts_mod), PF_ALGNMNT(startoff), 0);





						copyback = 1;
					}

					
					memcpy(&tsecr, &opt[6], sizeof(u_int32_t));
					if (tsecr && dst->scrub && (dst->scrub->pfss_flags & PFSS_TIMESTAMP)) {

						tsecr = ntohl(tsecr)
						    - dst->scrub->pfss_ts_mod;
						pf_patch_32_unaligned(m, &th->th_sum, &opt[6], htonl(tsecr), PF_ALGNMNT(startoff), 0);




						copyback = 1;
					}
					got_ts = 1;
				}
				
			default:
				hlen -= MAX(opt[1], 2);
				opt += MAX(opt[1], 2);
				break;
			}
		}
		if (copyback) {
			
			*writeback = 1;
			m_copyback(m, off + sizeof(struct tcphdr), (th->th_off << 2) - sizeof(struct tcphdr), hdr + sizeof(struct tcphdr));

		}
	}

	



	getmicrouptime(&uptime);
	if (src->scrub && (src->scrub->pfss_flags & PFSS_PAWS) && (uptime.tv_sec - src->scrub->pfss_last.tv_sec > TS_MAX_IDLE || time_uptime - state->creation > TS_MAX_CONN))  {

		if (V_pf_status.debug >= PF_DEBUG_MISC) {
			DPFPRINTF(("src idled out of PAWS\n"));
			pf_print_state(state);
			printf("\n");
		}
		src->scrub->pfss_flags = (src->scrub->pfss_flags & ~PFSS_PAWS)
		    | PFSS_PAWS_IDLED;
	}
	if (dst->scrub && (dst->scrub->pfss_flags & PFSS_PAWS) && uptime.tv_sec - dst->scrub->pfss_last.tv_sec > TS_MAX_IDLE) {
		if (V_pf_status.debug >= PF_DEBUG_MISC) {
			DPFPRINTF(("dst idled out of PAWS\n"));
			pf_print_state(state);
			printf("\n");
		}
		dst->scrub->pfss_flags = (dst->scrub->pfss_flags & ~PFSS_PAWS)
		    | PFSS_PAWS_IDLED;
	}

	if (got_ts && src->scrub && dst->scrub && (src->scrub->pfss_flags & PFSS_PAWS) && (dst->scrub->pfss_flags & PFSS_PAWS)) {

		
		struct timeval delta_ts;
		int ts_fudge;

		
		if ((ts_fudge = state->rule.ptr->timeout[PFTM_TS_DIFF]) == 0)
			ts_fudge = V_pf_default_rule.timeout[PFTM_TS_DIFF];

		


		delta_ts = uptime;
		timevalsub(&delta_ts, &src->scrub->pfss_last);
		tsval_from_last = (delta_ts.tv_sec + ts_fudge) * TS_MAXFREQ;
		tsval_from_last += delta_ts.tv_usec / (TS_MICROSECS/TS_MAXFREQ);

		if ((src->state >= TCPS_ESTABLISHED && dst->state >= TCPS_ESTABLISHED) && (SEQ_LT(tsval, dst->scrub->pfss_tsecr) || SEQ_GT(tsval, src->scrub->pfss_tsval + tsval_from_last) || (tsecr && (SEQ_GT(tsecr, dst->scrub->pfss_tsval) || SEQ_LT(tsecr, dst->scrub->pfss_tsval0))))) {




			

			DPFPRINTF(("Timestamp failed %c%c%c%c\n", SEQ_LT(tsval, dst->scrub->pfss_tsecr) ? '0' : ' ', SEQ_GT(tsval, src->scrub->pfss_tsval + tsval_from_last) ? '1' : ' ', SEQ_GT(tsecr, dst->scrub->pfss_tsval) ? '2' : ' ', SEQ_LT(tsecr, dst->scrub->pfss_tsval0)? '3' : ' '));




			DPFPRINTF((" tsval: %u  tsecr: %u  +ticks: %u  " "idle: %jus %lums\n", tsval, tsecr, tsval_from_last, (uintmax_t)delta_ts.tv_sec, delta_ts.tv_usec / 1000));



			DPFPRINTF((" src->tsval: %u  tsecr: %u\n", src->scrub->pfss_tsval, src->scrub->pfss_tsecr));
			DPFPRINTF((" dst->tsval: %u  tsecr: %u  tsval0: %u" "\n", dst->scrub->pfss_tsval, dst->scrub->pfss_tsecr, dst->scrub->pfss_tsval0));

			if (V_pf_status.debug >= PF_DEBUG_MISC) {
				pf_print_state(state);
				pf_print_flags(th->th_flags);
				printf("\n");
			}
			REASON_SET(reason, PFRES_TS);
			return (PF_DROP);
		}

		

	} else if (!got_ts && (th->th_flags & TH_RST) == 0 && ((src->state == TCPS_ESTABLISHED && dst->state == TCPS_ESTABLISHED)
	    || pd->p_len > 0 || (th->th_flags & TH_SYN)) && src->scrub && dst->scrub && (src->scrub->pfss_flags & PFSS_PAWS) && (dst->scrub->pfss_flags & PFSS_PAWS)) {


		

		if (pd->p_len > 0 && (src->scrub->pfss_flags & PFSS_DATA_TS)) {
			
			if (V_pf_status.debug >= PF_DEBUG_MISC) {
				DPFPRINTF(("Did not receive expected RFC1323 " "timestamp\n"));
				pf_print_state(state);
				pf_print_flags(th->th_flags);
				printf("\n");
			}
			REASON_SET(reason, PFRES_TS);
			return (PF_DROP);
		}
	}

	
	if (pd->p_len > 0 && src->scrub && (src->scrub->pfss_flags & (PFSS_TIMESTAMP|PFSS_DATA_TS|PFSS_DATA_NOTS)) == PFSS_TIMESTAMP) {
		if (got_ts)
			src->scrub->pfss_flags |= PFSS_DATA_TS;
		else {
			src->scrub->pfss_flags |= PFSS_DATA_NOTS;
			if (V_pf_status.debug >= PF_DEBUG_MISC && dst->scrub && (dst->scrub->pfss_flags & PFSS_TIMESTAMP)) {
				
				DPFPRINTF(("Broken RFC1323 stack did not " "timestamp data packet. Disabled PAWS " "security.\n"));

				pf_print_state(state);
				pf_print_flags(th->th_flags);
				printf("\n");
			}
		}
	}

	
	if (got_ts && src->scrub && PFSS_TIMESTAMP == (src->scrub->pfss_flags & (PFSS_PAWS_IDLED|PFSS_TIMESTAMP))) {
		getmicrouptime(&src->scrub->pfss_last);
		if (SEQ_GEQ(tsval, src->scrub->pfss_tsval) || (src->scrub->pfss_flags & PFSS_PAWS) == 0)
			src->scrub->pfss_tsval = tsval;

		if (tsecr) {
			if (SEQ_GEQ(tsecr, src->scrub->pfss_tsecr) || (src->scrub->pfss_flags & PFSS_PAWS) == 0)
				src->scrub->pfss_tsecr = tsecr;

			if ((src->scrub->pfss_flags & PFSS_PAWS) == 0 && (SEQ_LT(tsval, src->scrub->pfss_tsval0) || src->scrub->pfss_tsval0 == 0)) {

				
				src->scrub->pfss_tsval0 = tsval;
			}

			
			if ((src->scrub->pfss_flags & PFSS_PAWS) == 0)
				src->scrub->pfss_flags |= PFSS_PAWS;
		}
	}

	
	return (0);
}

int pf_normalize_mss(struct mbuf *m, int off, struct pf_pdesc *pd)
{
	struct tcphdr	*th = &pd->hdr.tcp;
	u_int16_t	*mss;
	int		 thoff;
	int		 opt, cnt, optlen = 0;
	u_char		 opts[TCP_MAXOLEN];
	u_char		*optp = opts;
	size_t		 startoff;

	thoff = th->th_off << 2;
	cnt = thoff - sizeof(struct tcphdr);

	if (cnt > 0 && !pf_pull_hdr(m, off + sizeof(*th), opts, cnt, NULL, NULL, pd->af))
		return (0);

	for (; cnt > 0; cnt -= optlen, optp += optlen) {
		startoff = optp - opts;
		opt = optp[0];
		if (opt == TCPOPT_EOL)
			break;
		if (opt == TCPOPT_NOP)
			optlen = 1;
		else {
			if (cnt < 2)
				break;
			optlen = optp[1];
			if (optlen < 2 || optlen > cnt)
				break;
		}
		switch (opt) {
		case TCPOPT_MAXSEG:
			mss = (u_int16_t *)(optp + 2);
			if ((ntohs(*mss)) > pd->act.max_mss) {
				pf_patch_16_unaligned(m, &th->th_sum, mss, htons(pd->act.max_mss), PF_ALGNMNT(startoff), 0);



				m_copyback(m, off + sizeof(*th), thoff - sizeof(*th), opts);
				m_copyback(m, off, sizeof(*th), (caddr_t)th);
			}
			break;
		default:
			break;
		}
	}

	return (0);
}

static int pf_scan_sctp(struct mbuf *m, int ipoff, int off, struct pf_pdesc *pd)
{
	struct sctp_chunkhdr ch = { };
	int chunk_off = sizeof(struct sctphdr);
	int chunk_start;

	while (off + chunk_off < pd->tot_len) {
		if (!pf_pull_hdr(m, off + chunk_off, &ch, sizeof(ch), NULL, NULL, pd->af))
			return (PF_DROP);

		
		if (ntohs(ch.chunk_length) < 4)
			return (PF_DROP);

		chunk_start = chunk_off;
		chunk_off += roundup(ntohs(ch.chunk_length), 4);

		switch (ch.chunk_type) {
		case SCTP_INITIATION: {
			struct sctp_init_chunk init;

			if (!pf_pull_hdr(m, off + chunk_start, &init, sizeof(init), NULL, NULL, pd->af))
				return (PF_DROP);

			
			if (init.init.initiate_tag == 0)
				return (PF_DROP);
			if (init.init.num_inbound_streams == 0)
				return (PF_DROP);
			if (init.init.num_outbound_streams == 0)
				return (PF_DROP);
			if (ntohl(init.init.a_rwnd) < SCTP_MIN_RWND)
				return (PF_DROP);

			
			if (pd->hdr.sctp.v_tag != 0)
				return (PF_DROP);

			pd->sctp_initiate_tag = init.init.initiate_tag;

			pd->sctp_flags |= PFDESC_SCTP_INIT;
			break;
		}
		case SCTP_INITIATION_ACK:
			pd->sctp_flags |= PFDESC_SCTP_INIT_ACK;
			break;
		case SCTP_ABORT_ASSOCIATION:
			pd->sctp_flags |= PFDESC_SCTP_ABORT;
			break;
		case SCTP_SHUTDOWN:
		case SCTP_SHUTDOWN_ACK:
			pd->sctp_flags |= PFDESC_SCTP_SHUTDOWN;
			break;
		case SCTP_SHUTDOWN_COMPLETE:
			pd->sctp_flags |= PFDESC_SCTP_SHUTDOWN_COMPLETE;
			break;
		case SCTP_COOKIE_ECHO:
		case SCTP_COOKIE_ACK:
			pd->sctp_flags |= PFDESC_SCTP_COOKIE;
			break;
		case SCTP_DATA:
			pd->sctp_flags |= PFDESC_SCTP_DATA;
			break;
		default:
			pd->sctp_flags |= PFDESC_SCTP_OTHER;
			break;
		}
	}

	
	if (off + chunk_off != pd->tot_len)
		return (PF_DROP);

	
	if ((pd->sctp_flags & PFDESC_SCTP_INIT) && (pd->sctp_flags & ~PFDESC_SCTP_INIT))
		return (PF_DROP);
	if ((pd->sctp_flags & PFDESC_SCTP_INIT_ACK) && (pd->sctp_flags & ~PFDESC_SCTP_INIT_ACK))
		return (PF_DROP);
	if ((pd->sctp_flags & PFDESC_SCTP_SHUTDOWN_COMPLETE) && (pd->sctp_flags & ~PFDESC_SCTP_SHUTDOWN_COMPLETE))
		return (PF_DROP);

	return (PF_PASS);
}

int pf_normalize_sctp(int dir, struct pfi_kkif *kif, struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)

{
	struct pf_krule	*r, *rm = NULL;
	struct sctphdr	*sh = &pd->hdr.sctp;
	u_short		 reason;
	sa_family_t	 af = pd->af;
	int		 srs;

	PF_RULES_RASSERT();

	
	if (pf_scan_sctp(m, ipoff, off, pd) != PF_PASS)
		goto sctp_drop;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	
	srs = (r != NULL);
	while (r != NULL) {
		pf_counter_u64_add(&r->evaluations, 1);
		if (pfi_kkif_match(r->kif, kif) == r->ifnot)
			r = r->skip[PF_SKIP_IFP].ptr;
		else if (r->direction && r->direction != dir)
			r = r->skip[PF_SKIP_DIR].ptr;
		else if (r->af && r->af != af)
			r = r->skip[PF_SKIP_AF].ptr;
		else if (r->proto && r->proto != pd->proto)
			r = r->skip[PF_SKIP_PROTO].ptr;
		else if (PF_MISMATCHAW(&r->src.addr, pd->src, af, r->src.neg, kif, M_GETFIB(m)))
			r = r->skip[PF_SKIP_SRC_ADDR].ptr;
		else if (r->src.port_op && !pf_match_port(r->src.port_op, r->src.port[0], r->src.port[1], sh->src_port))
			r = r->skip[PF_SKIP_SRC_PORT].ptr;
		else if (PF_MISMATCHAW(&r->dst.addr, pd->dst, af, r->dst.neg, NULL, M_GETFIB(m)))
			r = r->skip[PF_SKIP_DST_ADDR].ptr;
		else if (r->dst.port_op && !pf_match_port(r->dst.port_op, r->dst.port[0], r->dst.port[1], sh->dest_port))
			r = r->skip[PF_SKIP_DST_PORT].ptr;
		else {
			rm = r;
			break;
		}
	}

	if (srs) {
		
		if (rm == NULL || rm->action == PF_NOSCRUB)
			return (PF_PASS);

		pf_counter_u64_critical_enter();
		pf_counter_u64_add_protected(&r->packets[dir == PF_OUT], 1);
		pf_counter_u64_add_protected(&r->bytes[dir == PF_OUT], pd->tot_len);
		pf_counter_u64_critical_exit();
	}

	
	if ((pd->tot_len - off - sizeof(struct sctphdr)) % 4)
		goto sctp_drop;

	
	if (pd->sctp_flags & PFDESC_SCTP_INIT)
		if (pd->sctp_flags & ~PFDESC_SCTP_INIT)
			goto sctp_drop;

	return (PF_PASS);

sctp_drop:
	REASON_SET(&reason, PFRES_NORM);
	if (rm != NULL && r->log)
		PFLOG_PACKET(kif, m, AF_INET, reason, r, NULL, NULL, pd, 1);

	return (PF_DROP);
}


void pf_scrub_ip(struct mbuf **m0, struct pf_pdesc *pd)
{
	struct mbuf		*m = *m0;
	struct ip		*h = mtod(m, struct ip *);

	
	if (pd->act.flags & PFSTATE_NODF && h->ip_off & htons(IP_DF)) {
		u_int16_t ip_off = h->ip_off;

		h->ip_off &= htons(~IP_DF);
		h->ip_sum = pf_cksum_fixup(h->ip_sum, ip_off, h->ip_off, 0);
	}

	
	if (pd->act.min_ttl && h->ip_ttl < pd->act.min_ttl) {
		u_int16_t ip_ttl = h->ip_ttl;

		h->ip_ttl = pd->act.min_ttl;
		h->ip_sum = pf_cksum_fixup(h->ip_sum, ip_ttl, h->ip_ttl, 0);
	}

	
	if (pd->act.flags & PFSTATE_SETTOS) {
		u_int16_t	ov, nv;

		ov = *(u_int16_t *)h;
		h->ip_tos = pd->act.set_tos | (h->ip_tos & IPTOS_ECN_MASK);
		nv = *(u_int16_t *)h;

		h->ip_sum = pf_cksum_fixup(h->ip_sum, ov, nv, 0);
	}

	
	if (pd->act.flags & PFSTATE_RANDOMID && !(h->ip_off & ~htons(IP_DF))) {
		uint16_t ip_id = h->ip_id;

		ip_fillid(h);
		h->ip_sum = pf_cksum_fixup(h->ip_sum, ip_id, h->ip_id, 0);
	}
}



void pf_scrub_ip6(struct mbuf **m0, struct pf_pdesc *pd)
{
	struct mbuf		*m = *m0;
	struct ip6_hdr		*h = mtod(m, struct ip6_hdr *);

	
	if (pd->act.min_ttl && h->ip6_hlim < pd->act.min_ttl)
		h->ip6_hlim = pd->act.min_ttl;

	
	if (pd->act.flags & PFSTATE_SETTOS) {
		h->ip6_flow &= IPV6_FLOWLABEL_MASK | IPV6_VERSION_MASK;
		h->ip6_flow |= htonl((pd->act.set_tos | IPV6_ECN(h)) << 20);
	}
}

