


























































static void freednsentry(void *freethis);


int Curl_num_addresses(const struct Curl_addrinfo *addr)
{
  int i = 0;
  while(addr) {
    addr = addr->ai_next;
    i++;
  }
  return i;
}


void Curl_printable_address(const struct Curl_addrinfo *ai, char *buf, size_t bufsize)
{
  DEBUGASSERT(bufsize);
  buf[0] = 0;

  switch(ai->ai_family) {
  case AF_INET: {
    const struct sockaddr_in *sa4 = (const void *)ai->ai_addr;
    const struct in_addr *ipaddr4 = &sa4->sin_addr;
    (void)Curl_inet_ntop(ai->ai_family, (const void *)ipaddr4, buf, bufsize);
    break;
  }

  case AF_INET6: {
    const struct sockaddr_in6 *sa6 = (const void *)ai->ai_addr;
    const struct in6_addr *ipaddr6 = &sa6->sin6_addr;
    (void)Curl_inet_ntop(ai->ai_family, (const void *)ipaddr6, buf, bufsize);
    break;
  }

  default:
    break;
  }
}


static size_t create_hostcache_id(const char *name, size_t nlen, int port, char *ptr, size_t buflen)


{
  size_t len = nlen ? nlen : strlen(name);
  size_t olen = 0;
  DEBUGASSERT(buflen >= MAX_HOSTCACHE_LEN);
  if(len > (buflen - 7))
    len = buflen - 7;
  
  while(len--) {
    *ptr++ = Curl_raw_tolower(*name++);
    olen++;
  }
  olen += msnprintf(ptr, 7, ":%u", port);
  return olen;
}

struct hostcache_prune_data {
  long cache_timeout;
  time_t now;
};


static int hostcache_timestamp_remove(void *datap, void *hc)
{
  struct hostcache_prune_data *data = (struct hostcache_prune_data *) datap;
  struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc;

  return (0 != c->timestamp)
    && (data->now - c->timestamp >= data->cache_timeout);
}


static void hostcache_prune(struct Curl_hash *hostcache, long cache_timeout, time_t now)
{
  struct hostcache_prune_data user;

  user.cache_timeout = cache_timeout;
  user.now = now;

  Curl_hash_clean_with_criterium(hostcache, (void *) &user, hostcache_timestamp_remove);

}


void Curl_hostcache_prune(struct Curl_easy *data)
{
  time_t now;

  if((data->set.dns_cache_timeout == -1) || !data->dns.hostcache)
    
    return;

  if(data->share)
    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

  time(&now);

  
  hostcache_prune(data->dns.hostcache, data->set.dns_cache_timeout, now);


  if(data->share)
    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
}



sigjmp_buf curl_jmpenv;



static struct Curl_dns_entry *fetch_addr(struct Curl_easy *data, const char *hostname, int port)

{
  struct Curl_dns_entry *dns = NULL;
  char entry_id[MAX_HOSTCACHE_LEN];

  
  size_t entry_len = create_hostcache_id(hostname, 0, port, entry_id, sizeof(entry_id));

  
  dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);

  
  if(!dns && data->state.wildcard_resolve) {
    entry_len = create_hostcache_id("*", 1, port, entry_id, sizeof(entry_id));

    
    dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
  }

  if(dns && (data->set.dns_cache_timeout != -1)) {
    
    struct hostcache_prune_data user;

    time(&user.now);
    user.cache_timeout = data->set.dns_cache_timeout;

    if(hostcache_timestamp_remove(&user, dns)) {
      infof(data, "Hostname in DNS cache was stale, zapped");
      dns = NULL; 
      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
    }
  }

  
  if(dns && data->conn->ip_version != CURL_IPRESOLVE_WHATEVER) {
    int pf = PF_INET;
    bool found = false;
    struct Curl_addrinfo *addr = dns->addr;


    if(data->conn->ip_version == CURL_IPRESOLVE_V6)
      pf = PF_INET6;


    while(addr) {
      if(addr->ai_family == pf) {
        found = true;
        break;
      }
      addr = addr->ai_next;
    }

    if(!found) {
      infof(data, "Hostname in DNS cache doesn't have needed family, zapped");
      dns = NULL; 
      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
    }
  }
  return dns;
}


struct Curl_dns_entry * Curl_fetch_addr(struct Curl_easy *data, const char *hostname, int port)


{
  struct Curl_dns_entry *dns = NULL;

  if(data->share)
    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

  dns = fetch_addr(data, hostname, port);

  if(dns)
    dns->inuse++; 

  if(data->share)
    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);

  return dns;
}


UNITTEST CURLcode Curl_shuffle_addr(struct Curl_easy *data, struct Curl_addrinfo **addr);

UNITTEST CURLcode Curl_shuffle_addr(struct Curl_easy *data, struct Curl_addrinfo **addr)
{
  CURLcode result = CURLE_OK;
  const int num_addrs = Curl_num_addresses(*addr);

  if(num_addrs > 1) {
    struct Curl_addrinfo **nodes;
    infof(data, "Shuffling %i addresses", num_addrs);

    nodes = malloc(num_addrs*sizeof(*nodes));
    if(nodes) {
      int i;
      unsigned int *rnd;
      const size_t rnd_size = num_addrs * sizeof(*rnd);

      
      nodes[0] = *addr;
      for(i = 1; i < num_addrs; i++) {
        nodes[i] = nodes[i-1]->ai_next;
      }

      rnd = malloc(rnd_size);
      if(rnd) {
        
        if(Curl_rand(data, (unsigned char *)rnd, rnd_size) == CURLE_OK) {
          struct Curl_addrinfo *swap_tmp;
          for(i = num_addrs - 1; i > 0; i--) {
            swap_tmp = nodes[rnd[i] % (i + 1)];
            nodes[rnd[i] % (i + 1)] = nodes[i];
            nodes[i] = swap_tmp;
          }

          
          for(i = 1; i < num_addrs; i++) {
            nodes[i-1]->ai_next = nodes[i];
          }

          nodes[num_addrs-1]->ai_next = NULL;
          *addr = nodes[0];
        }
        free(rnd);
      }
      else result = CURLE_OUT_OF_MEMORY;
      free(nodes);
    }
    else result = CURLE_OUT_OF_MEMORY;
  }
  return result;
}



struct Curl_dns_entry * Curl_cache_addr(struct Curl_easy *data, struct Curl_addrinfo *addr, const char *hostname, size_t hostlen, int port)




{
  char entry_id[MAX_HOSTCACHE_LEN];
  size_t entry_len;
  struct Curl_dns_entry *dns;
  struct Curl_dns_entry *dns2;


  
  if(data->set.dns_shuffle_addresses) {
    CURLcode result = Curl_shuffle_addr(data, &addr);
    if(result)
      return NULL;
  }


  
  dns = calloc(1, sizeof(struct Curl_dns_entry));
  if(!dns) {
    return NULL;
  }

  
  entry_len = create_hostcache_id(hostname, hostlen, port, entry_id, sizeof(entry_id));

  dns->inuse = 1;   
  dns->addr = addr; 
  time(&dns->timestamp);
  if(dns->timestamp == 0)
    dns->timestamp = 1;   

  
  dns2 = Curl_hash_add(data->dns.hostcache, entry_id, entry_len + 1, (void *)dns);
  if(!dns2) {
    free(dns);
    return NULL;
  }

  dns = dns2;
  dns->inuse++;         
  return dns;
}



static struct Curl_addrinfo *get_localhost6(int port, const char *name)
{
  struct Curl_addrinfo *ca;
  const size_t ss_size = sizeof(struct sockaddr_in6);
  const size_t hostlen = strlen(name);
  struct sockaddr_in6 sa6;
  unsigned char ipv6[16];
  unsigned short port16 = (unsigned short)(port & 0xffff);
  ca = calloc(sizeof(struct Curl_addrinfo) + ss_size + hostlen + 1, 1);
  if(!ca)
    return NULL;

  sa6.sin6_family = AF_INET6;
  sa6.sin6_port = htons(port16);
  sa6.sin6_flowinfo = 0;
  sa6.sin6_scope_id = 0;
  if(Curl_inet_pton(AF_INET6, "::1", ipv6) < 1)
    return NULL;
  memcpy(&sa6.sin6_addr, ipv6, sizeof(ipv6));

  ca->ai_flags     = 0;
  ca->ai_family    = AF_INET6;
  ca->ai_socktype  = SOCK_STREAM;
  ca->ai_protocol  = IPPROTO_TCP;
  ca->ai_addrlen   = (curl_socklen_t)ss_size;
  ca->ai_next      = NULL;
  ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));
  memcpy(ca->ai_addr, &sa6, ss_size);
  ca->ai_canonname = (char *)ca->ai_addr + ss_size;
  strcpy(ca->ai_canonname, name);
  return ca;
}





static struct Curl_addrinfo *get_localhost(int port, const char *name)
{
  struct Curl_addrinfo *ca;
  const size_t ss_size = sizeof(struct sockaddr_in);
  const size_t hostlen = strlen(name);
  struct sockaddr_in sa;
  unsigned int ipv4;
  unsigned short port16 = (unsigned short)(port & 0xffff);

  
  memset(&sa, 0, sizeof(sa));
  sa.sin_family = AF_INET;
  sa.sin_port = htons(port16);
  if(Curl_inet_pton(AF_INET, "127.0.0.1", (char *)&ipv4) < 1)
    return NULL;
  memcpy(&sa.sin_addr, &ipv4, sizeof(ipv4));

  ca = calloc(sizeof(struct Curl_addrinfo) + ss_size + hostlen + 1, 1);
  if(!ca)
    return NULL;
  ca->ai_flags     = 0;
  ca->ai_family    = AF_INET;
  ca->ai_socktype  = SOCK_STREAM;
  ca->ai_protocol  = IPPROTO_TCP;
  ca->ai_addrlen   = (curl_socklen_t)ss_size;
  ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));
  memcpy(ca->ai_addr, &sa, ss_size);
  ca->ai_canonname = (char *)ca->ai_addr + ss_size;
  strcpy(ca->ai_canonname, name);
  ca->ai_next = get_localhost6(port, name);
  return ca;
}



bool Curl_ipv6works(struct Curl_easy *data)
{
  if(data) {
    
    DEBUGASSERT(data);
    DEBUGASSERT(data->multi);
    if(data->multi->ipv6_up == IPV6_UNKNOWN) {
      bool works = Curl_ipv6works(NULL);
      data->multi->ipv6_up = works ? IPV6_WORKS : IPV6_DEAD;
    }
    return data->multi->ipv6_up == IPV6_WORKS;
  }
  else {
    int ipv6_works = -1;
    
    curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);
    if(s == CURL_SOCKET_BAD)
      
      ipv6_works = 0;
    else {
      ipv6_works = 1;
      sclose(s);
    }
    return (ipv6_works>0)?TRUE:FALSE;
  }
}



bool Curl_host_is_ipnum(const char *hostname)
{
  struct in_addr in;

  struct in6_addr in6;

  if(Curl_inet_pton(AF_INET, hostname, &in) > 0  || Curl_inet_pton(AF_INET6, hostname, &in6) > 0  )



    return TRUE;
  return FALSE;
}



static bool tailmatch(const char *full, const char *part)
{
  size_t plen = strlen(part);
  size_t flen = strlen(full);
  if(plen > flen)
    return FALSE;
  return strncasecompare(part, &full[flen - plen], plen);
}



enum resolve_t Curl_resolv(struct Curl_easy *data, const char *hostname, int port, bool allowDOH, struct Curl_dns_entry **entry)



{
  struct Curl_dns_entry *dns = NULL;
  CURLcode result;
  enum resolve_t rc = CURLRESOLV_ERROR; 
  struct connectdata *conn = data->conn;
  
  size_t hostname_len = strlen(hostname);
  if(hostname_len >= 7 && (curl_strequal(&hostname[hostname_len - 6], ".onion") || curl_strequal(&hostname[hostname_len - 7], ".onion."))) {

    failf(data, "Not resolving .onion address (RFC 7686)");
    return CURLRESOLV_ERROR;
  }
  *entry = NULL;

  conn->bits.doh = FALSE; 

  (void)allowDOH;


  if(data->share)
    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

  dns = fetch_addr(data, hostname, port);

  if(dns) {
    infof(data, "Hostname %s was found in DNS cache", hostname);
    dns->inuse++; 
    rc = CURLRESOLV_RESOLVED;
  }

  if(data->share)
    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);

  if(!dns) {
    

    struct Curl_addrinfo *addr = NULL;
    int respwait = 0;

    struct in_addr in;



    const  bool ipnum = FALSE;



    
    if(data->set.resolver_start) {
      int st;
      Curl_set_in_callback(data, true);
      st = data->set.resolver_start(  data->state.async.resolver,  NULL,  NULL, data->set.resolver_start_client);






      Curl_set_in_callback(data, false);
      if(st)
        return CURLRESOLV_ERROR;
    }


    {
      
      CFDictionaryRef dict = SCDynamicStoreCopyProxies(NULL);
      if(dict)
        CFRelease(dict);
    }



    
    if(Curl_inet_pton(AF_INET, hostname, &in) > 0)
      
      addr = Curl_ip2addr(AF_INET, &in, hostname, port);

    if(!addr) {
      struct in6_addr in6;
      
      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0)
        
        addr = Curl_ip2addr(AF_INET6, &in6, hostname, port);
    }




    
    if(Curl_inet_pton(AF_INET, hostname, &in) > 0)
      
      ipnum = TRUE;

    else {
      struct in6_addr in6;
      
      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0)
        
        ipnum = TRUE;
    }





    if(!addr) {
      if(conn->ip_version == CURL_IPRESOLVE_V6 && !Curl_ipv6works(data))
        return CURLRESOLV_ERROR;

      if(strcasecompare(hostname, "localhost") || tailmatch(hostname, ".localhost"))
        addr = get_localhost(port, hostname);

      else if(allowDOH && data->set.doh && !ipnum)
        addr = Curl_doh(data, hostname, port, &respwait);

      else {
        
        if(!Curl_ipvalid(data, conn))
          return CURLRESOLV_ERROR;
        
        addr = Curl_getaddrinfo(data, hostname, port, &respwait);
      }
    }
    if(!addr) {
      if(respwait) {
        
        
        result = Curl_resolv_check(data, &dns);
        if(result) 
          return CURLRESOLV_ERROR;
        if(dns)
          rc = CURLRESOLV_RESOLVED; 
        else rc = CURLRESOLV_PENDING;
      }
    }
    else {
      if(data->share)
        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

      
      dns = Curl_cache_addr(data, addr, hostname, 0, port);

      if(data->share)
        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);

      if(!dns)
        
        Curl_freeaddrinfo(addr);
      else rc = CURLRESOLV_RESOLVED;
    }
  }

  *entry = dns;

  return rc;
}



static void alarmfunc(int sig)
{
  
  (void)sig;
  siglongjmp(curl_jmpenv, 1);
}




enum resolve_t Curl_resolv_timeout(struct Curl_easy *data, const char *hostname, int port, struct Curl_dns_entry **entry, timediff_t timeoutms)



{


  struct sigaction keep_sigact;   
  volatile bool keep_copysig = FALSE; 
  struct sigaction sigact;


  void (*keep_sigact)(int);       


  volatile long timeout;
  volatile unsigned int prev_alarm = 0;

  enum resolve_t rc;

  *entry = NULL;

  if(timeoutms < 0)
    
    return CURLRESOLV_TIMEDOUT;


  if(data->set.no_signal)
    
    timeout = 0;
  else timeout = (timeoutms > LONG_MAX) ? LONG_MAX : (long)timeoutms;

  if(!timeout)
    
    return Curl_resolv(data, hostname, port, TRUE, entry);

  if(timeout < 1000) {
    
    failf(data, "remaining timeout of %ld too small to resolve via SIGALRM method", timeout);

    return CURLRESOLV_TIMEDOUT;
  }
  
  if(sigsetjmp(curl_jmpenv, 1)) {
    
    failf(data, "name lookup timed out");
    rc = CURLRESOLV_ERROR;
    goto clean_up;
  }
  else {
    

    sigaction(SIGALRM, NULL, &sigact);
    keep_sigact = sigact;
    keep_copysig = TRUE; 
    sigact.sa_handler = alarmfunc;

    
    sigact.sa_flags &= ~SA_RESTART;

    
    sigaction(SIGALRM, &sigact, NULL);

    

    keep_sigact = signal(SIGALRM, alarmfunc);



    
    prev_alarm = alarm(curlx_sltoui(timeout/1000L));
  }



  if(timeoutms)
    infof(data, "timeout on name lookup is not supported");

  (void)timeoutms; 



  
  rc = Curl_resolv(data, hostname, port, TRUE, entry);


clean_up:

  if(!prev_alarm)
    
    alarm(0);


  if(keep_copysig) {
    
    sigaction(SIGALRM, &keep_sigact, NULL); 
  }


  
  signal(SIGALRM, keep_sigact);



  
  if(prev_alarm) {
    
    timediff_t elapsed_secs = Curl_timediff(Curl_now(), data->conn->created) / 1000;

    
    unsigned long alarm_set = (unsigned long)(prev_alarm - elapsed_secs);

    if(!alarm_set || ((alarm_set >= 0x80000000) && (prev_alarm < 0x80000000)) ) {
      
      alarm(1);
      rc = CURLRESOLV_TIMEDOUT;
      failf(data, "Previous alarm fired off");
    }
    else alarm((unsigned int)alarm_set);
  }


  return rc;
}


void Curl_resolv_unlock(struct Curl_easy *data, struct Curl_dns_entry *dns)
{
  if(data && data->share)
    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

  freednsentry(dns);

  if(data && data->share)
    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
}


static void freednsentry(void *freethis)
{
  struct Curl_dns_entry *dns = (struct Curl_dns_entry *) freethis;
  DEBUGASSERT(dns && (dns->inuse>0));

  dns->inuse--;
  if(dns->inuse == 0) {
    Curl_freeaddrinfo(dns->addr);
    free(dns);
  }
}


void Curl_init_dnscache(struct Curl_hash *hash, int size)
{
  Curl_hash_init(hash, size, Curl_hash_str, Curl_str_key_compare, freednsentry);
}



void Curl_hostcache_clean(struct Curl_easy *data, struct Curl_hash *hash)
{
  if(data && data->share)
    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

  Curl_hash_clean(hash);

  if(data && data->share)
    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
}


CURLcode Curl_loadhostpairs(struct Curl_easy *data)
{
  struct curl_slist *hostp;
  char *host_end;

  
  data->state.wildcard_resolve = false;

  for(hostp = data->state.resolve; hostp; hostp = hostp->next) {
    char entry_id[MAX_HOSTCACHE_LEN];
    if(!hostp->data)
      continue;
    if(hostp->data[0] == '-') {
      unsigned long num = 0;
      size_t entry_len;
      size_t hlen = 0;
      host_end = strchr(&hostp->data[1], ':');

      if(host_end) {
        hlen = host_end - &hostp->data[1];
        num = strtoul(++host_end, NULL, 10);
        if(!hlen || (num > 0xffff))
          host_end = NULL;
      }
      if(!host_end) {
        infof(data, "Bad syntax CURLOPT_RESOLVE removal entry '%s'", hostp->data);
        continue;
      }
      
      entry_len = create_hostcache_id(&hostp->data[1], hlen, (int)num, entry_id, sizeof(entry_id));
      if(data->share)
        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

      
      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);

      if(data->share)
        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
    }
    else {
      struct Curl_dns_entry *dns;
      struct Curl_addrinfo *head = NULL, *tail = NULL;
      size_t entry_len;
      char address[64];

      char *addresses = NULL;

      char *addr_begin;
      char *addr_end;
      char *port_ptr;
      int port = 0;
      char *end_ptr;
      bool permanent = TRUE;
      unsigned long tmp_port;
      bool error = true;
      char *host_begin = hostp->data;
      size_t hlen = 0;

      if(host_begin[0] == '+') {
        host_begin++;
        permanent = FALSE;
      }
      host_end = strchr(host_begin, ':');
      if(!host_end)
        goto err;
      hlen = host_end - host_begin;

      port_ptr = host_end + 1;
      tmp_port = strtoul(port_ptr, &end_ptr, 10);
      if(tmp_port > USHRT_MAX || end_ptr == port_ptr || *end_ptr != ':')
        goto err;

      port = (int)tmp_port;

      addresses = end_ptr + 1;


      while(*end_ptr) {
        size_t alen;
        struct Curl_addrinfo *ai;

        addr_begin = end_ptr + 1;
        addr_end = strchr(addr_begin, ',');
        if(!addr_end)
          addr_end = addr_begin + strlen(addr_begin);
        end_ptr = addr_end;

        
        if(*addr_begin == '[') {
          if(addr_end == addr_begin || *(addr_end - 1) != ']')
            goto err;
          ++addr_begin;
          --addr_end;
        }

        alen = addr_end - addr_begin;
        if(!alen)
          continue;

        if(alen >= sizeof(address))
          goto err;

        memcpy(address, addr_begin, alen);
        address[alen] = '\0';


        if(strchr(address, ':')) {
          infof(data, "Ignoring resolve address '%s', missing IPv6 support.", address);
          continue;
        }


        ai = Curl_str2addr(address, port);
        if(!ai) {
          infof(data, "Resolve address '%s' found illegal", address);
          goto err;
        }

        if(tail) {
          tail->ai_next = ai;
          tail = tail->ai_next;
        }
        else {
          head = tail = ai;
        }
      }

      if(!head)
        goto err;

      error = false;
   err:
      if(error) {
        failf(data, "Couldn't parse CURLOPT_RESOLVE entry '%s'", hostp->data);
        Curl_freeaddrinfo(head);
        return CURLE_SETOPT_OPTION_SYNTAX;
      }

      
      entry_len = create_hostcache_id(host_begin, hlen, port, entry_id, sizeof(entry_id));

      if(data->share)
        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);

      
      dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);

      if(dns) {
        infof(data, "RESOLVE %.*s:%d is - old addresses discarded", (int)hlen, host_begin, port);
        

        Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
      }

      
      dns = Curl_cache_addr(data, head, host_begin, hlen, port);
      if(dns) {
        if(permanent)
          dns->timestamp = 0; 
        
        dns->inuse--;
      }

      if(data->share)
        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);

      if(!dns) {
        Curl_freeaddrinfo(head);
        return CURLE_OUT_OF_MEMORY;
      }
      infof(data, "Added %.*s:%d:%s to DNS cache%s", (int)hlen, host_begin, port, addresses, permanent ? "" : " (non-permanent)");


      
      if((hlen == 1) && (host_begin[0] == '*')) {
        infof(data, "RESOLVE *:%d using wildcard", port);
        data->state.wildcard_resolve = true;
      }
    }
  }
  data->state.resolve = NULL; 

  return CURLE_OK;
}

CURLcode Curl_resolv_check(struct Curl_easy *data, struct Curl_dns_entry **dns)
{

  (void)data;
  (void)dns;


  if(data->conn->bits.doh)
    return Curl_doh_is_resolved(data, dns);

  return Curl_resolver_is_resolved(data, dns);
}

int Curl_resolv_getsock(struct Curl_easy *data, curl_socket_t *socks)
{


  if(data->conn->bits.doh)
    
    return GETSOCK_BLANK;

  return Curl_resolver_getsock(data, socks);

  (void)data;
  (void)socks;
  return GETSOCK_BLANK;

}


CURLcode Curl_once_resolved(struct Curl_easy *data, bool *protocol_done)
{
  CURLcode result;
  struct connectdata *conn = data->conn;


  if(data->state.async.dns) {
    conn->dns_entry = data->state.async.dns;
    data->state.async.dns = NULL;
  }


  result = Curl_setup_conn(data, protocol_done);

  if(result) {
    Curl_detach_connection(data);
    Curl_conncache_remove_conn(data, conn, TRUE);
    Curl_disconnect(data, conn, TRUE);
  }
  return result;
}




CURLcode Curl_resolver_error(struct Curl_easy *data)
{
  const char *host_or_proxy;
  CURLcode result;


  struct connectdata *conn = data->conn;
  if(conn->bits.httpproxy) {
    host_or_proxy = "proxy";
    result = CURLE_COULDNT_RESOLVE_PROXY;
  }
  else  {

    host_or_proxy = "host";
    result = CURLE_COULDNT_RESOLVE_HOST;
  }

  failf(data, "Could not resolve %s: %s", host_or_proxy, data->state.async.hostname);

  return result;
}

