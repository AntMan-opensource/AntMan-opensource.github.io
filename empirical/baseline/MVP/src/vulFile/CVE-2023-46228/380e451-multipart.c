











static char *add_boundary_to_regex(zckCtx *zck, const char *regex, const char *boundary) {
    VALIDATE_PTR(zck);

    if(regex == NULL || boundary == NULL)
        return NULL;
    char *regex_b = zmalloc(strlen(regex) + strlen(boundary) + 1);
    if(!regex_b || snprintf(regex_b, strlen(regex) + strlen(boundary), regex, boundary) != strlen(regex) + strlen(boundary) - 2) {
        free(regex_b);
        set_error(zck, "Unable to build regular expression");
        return NULL;
    }
    return regex_b;
}

static bool create_regex(zckCtx *zck, regex_t *reg, const char *regex) {
    VALIDATE_BOOL(zck);

    if(reg == NULL || regex == NULL) {
        set_error(zck, "Regular expression not initialized");
        return false;
    }
    int cflags = REG_ICASE | REG_EXTENDED;

    cflags |= REG_ENHANCED;

    if(regcomp(reg, regex, cflags) != 0) {
        set_error(zck, "Unable to compile regular expression");
        return false;
    }
    return true;
}

static bool gen_regex(zckDL *dl) {
    ALLOCD_BOOL(NULL, dl);
    VALIDATE_BOOL(dl->zck);

    
    char *next = "\r?\n?--%s\r\n.*"  "content-range: *bytes *([0-9]+) *- *([0-9]+) */[0-9]+" char *end =  "\r\n--%s--";
    char *regex_n = add_boundary_to_regex(dl->zck, next, dl->boundary);
    if(regex_n == NULL)
        return false;
    dl->dl_regex = zmalloc(sizeof(regex_t));
    if(!dl->dl_regex || !create_regex(dl->zck, dl->dl_regex, regex_n)) {
        free(regex_n);
        return false;
    }
    free(regex_n);
    char *regex_e = add_boundary_to_regex(dl->zck, end, dl->boundary);
    if(regex_e == NULL)
        return false;
    dl->end_regex = zmalloc(sizeof(regex_t));
    if(!dl->end_regex || !create_regex(dl->zck, dl->end_regex, regex_e)) {
        free(regex_e);
        return false;
    }
    free(regex_e);
    return true;
}

void reset_mp(zckMP *mp) {
    if(mp == NULL)
        return;
    if(mp->buffer)
        free(mp->buffer);
    memset(mp, 0, sizeof(zckMP));
}

size_t multipart_extract(zckDL *dl, char *b, size_t l) {
    ALLOCD_BOOL(NULL, dl);
    VALIDATE_BOOL(dl->zck);

    if(dl->mp == NULL)
        return 0;

    zckMP *mp = dl->mp;
    char *buf = b;
    bool alloc_buf = false;

    
    if(mp->buffer) {
        buf = zrealloc(mp->buffer, mp->buffer_len + l);
        if (!buf) {
            zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
            return 0;
        }
        memcpy(buf + mp->buffer_len, b, l);
        l = mp->buffer_len + l;
        mp->buffer = NULL;  
        mp->buffer_len = 0;
        alloc_buf = true;
    }

    
    if(dl->dl_regex == NULL && !gen_regex(dl)) {
        if(alloc_buf)
            free(buf);
        return 0;
    }

    char *header_start = buf;
    char *i = buf;
    while(i) {
        char *end = buf + l;
        
        if(mp->state != 0) {
            if(i >= end)
                break;
            size_t size = end - i;
            if(mp->length <= size) {
                size = mp->length;
                mp->length = 0;
                mp->state = 0;
                header_start = i + size;
            } else {
                mp->length -= size;
            }
            if(dl_write_range(dl, i, size) != size)
                return 0;
            i += size;
            continue;
        }

        
        if(i >= end) {
            size_t size = buf + l - header_start;
            if(size > 0) {
                mp->buffer = zmalloc(size);
                if (!mp->buffer) {
                    free(buf);
                    zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
                    return 0;
                }
                memcpy(mp->buffer, header_start, size);
                mp->buffer_len = size;
            }
            break;
        }

        
        char *j = i;
        for(; j<end; j++) {
            if(j + 4 >= end) {
                i = j+4;
                break;
            }
            if(memcmp(j, "\r\n\r\n", 4) == 0) {
                j[3] = '\0';
                j += 4;
                break;
            }
        }
        if(i >= end)
            continue;

        
        regmatch_t match[4] = {{0}};
        if(regexec(dl->dl_regex, i, 3, match, 0) != 0) {
            if(regexec(dl->end_regex, i, 3, match, 0) != 0)
                set_error(dl->zck, "Unable to find multipart download range");
            goto end;
        }

        
        size_t rstart = 0;
        for(char *c=i + match[1].rm_so; c < i + match[1].rm_eo; c++)
            rstart = rstart*10 + (size_t)(c[0] - 48);

        
        size_t rend = 0;
        for(char *c=i + match[2].rm_so; c < i + match[2].rm_eo; c++)
            rend = rend*10 + (size_t)(c[0] - 48);

        i = j;
        zck_log(ZCK_LOG_DEBUG, "Download range: %llu-%llu", (long long unsigned) rstart, (long long unsigned) rend );


        mp->length = rend-rstart+1;
        mp->state = 1;
    }
end:
    if(alloc_buf)
        free(buf);
    return l;
}

size_t multipart_get_boundary(zckDL *dl, char *b, size_t size) {
    ALLOCD_BOOL(NULL, dl);
    VALIDATE_BOOL(dl->zck);

    
    if(dl->hdr_regex == NULL) {
        char *regex = "boundary *= *(.*?) *\r";
        dl->hdr_regex = zmalloc(sizeof(regex_t));
        if(!dl->hdr_regex || !create_regex(dl->zck, dl->hdr_regex, regex))
            return 0;
    }

    
    char *buf = zmalloc(size+1);
    if (!buf) {
        zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
        return 0;
    }
    buf[size] = '\0';
    memcpy(buf, b, size);

    
    regmatch_t match[2] = {{0}};
    if(regexec(dl->hdr_regex, buf, 2, match, 0) == 0) {
        reset_mp(dl->mp);
        size_t boundary_length = match[1].rm_eo - match[1].rm_so;
        char *boundary_start = buf + match[1].rm_so;
        if (boundary_start[0] == '\"' && boundary_length > 2 && boundary_start[boundary_length-1] == '\"') {
            
            boundary_start  += 1;
            boundary_length -= 2;
        }
        char *boundary = zmalloc(boundary_length + 1);
        if (!boundary) {
            zck_log(ZCK_LOG_ERROR, "OOM in %s", __func__);
            free(buf);
            return 0;
        }
        memcpy(boundary, boundary_start, boundary_length);
        zck_log(ZCK_LOG_DEBUG, "Multipart boundary: %s", boundary);
        dl->boundary = boundary;
    }
    free(buf);
    return size;
}
