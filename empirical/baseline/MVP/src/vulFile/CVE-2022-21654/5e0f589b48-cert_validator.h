





















namespace Envoy {
namespace Extensions {
namespace TransportSockets {
namespace Tls {

class CertValidator {
public:
  virtual ~CertValidator() = default;

  
  virtual void addClientValidationContext(SSL_CTX* context, bool require_client_cert) PURE;

  
  virtual int doVerifyCertChain(X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert, const Network::TransportSocketOptions* transport_socket_options) PURE;



  
  virtual int initializeSslContexts(std::vector<SSL_CTX*> contexts, bool handshaker_provides_certificates) PURE;

  
  virtual void updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md, uint8_t hash_buffer[EVP_MAX_MD_SIZE], unsigned hash_length) PURE;


  virtual size_t daysUntilFirstCertExpires() const PURE;
  virtual std::string getCaFileName() const PURE;
  virtual Envoy::Ssl::CertificateDetailsPtr getCaCertInformation() const PURE;
};

using CertValidatorPtr = std::unique_ptr<CertValidator>;

} 
} 
} 
} 
