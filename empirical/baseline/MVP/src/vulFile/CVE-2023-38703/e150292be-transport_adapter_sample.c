







static pj_status_t transport_get_info (pjmedia_transport *tp, pjmedia_transport_info *info);
static pj_status_t transport_attach2  (pjmedia_transport *tp, pjmedia_transport_attach_param *att_prm);
static void        transport_detach   (pjmedia_transport *tp, void *strm);
static pj_status_t transport_send_rtp( pjmedia_transport *tp, const void *pkt, pj_size_t size);

static pj_status_t transport_send_rtcp(pjmedia_transport *tp, const void *pkt, pj_size_t size);

static pj_status_t transport_send_rtcp2(pjmedia_transport *tp, const pj_sockaddr_t *addr, unsigned addr_len, const void *pkt, pj_size_t size);



static pj_status_t transport_media_create(pjmedia_transport *tp, pj_pool_t *sdp_pool, unsigned options, const pjmedia_sdp_session *rem_sdp, unsigned media_index);



static pj_status_t transport_encode_sdp(pjmedia_transport *tp, pj_pool_t *sdp_pool, pjmedia_sdp_session *local_sdp, const pjmedia_sdp_session *rem_sdp, unsigned media_index);



static pj_status_t transport_media_start (pjmedia_transport *tp, pj_pool_t *pool, const pjmedia_sdp_session *local_sdp, const pjmedia_sdp_session *rem_sdp, unsigned media_index);



static pj_status_t transport_media_stop(pjmedia_transport *tp);
static pj_status_t transport_simulate_lost(pjmedia_transport *tp, pjmedia_dir dir, unsigned pct_lost);

static pj_status_t transport_destroy  (pjmedia_transport *tp);



static struct pjmedia_transport_op tp_adapter_op =  {
    &transport_get_info, NULL, &transport_detach, &transport_send_rtp, &transport_send_rtcp, &transport_send_rtcp2, &transport_media_create, &transport_encode_sdp, &transport_media_start, &transport_media_stop, &transport_simulate_lost, &transport_destroy, &transport_attach2, };















struct tp_adapter {
    pjmedia_transport    base;
    pj_bool_t            del_base;

    pj_pool_t           *pool;

    
    void                *stream_user_data;
    void                *stream_ref;
    void               (*stream_rtp_cb)(void *user_data, void *pkt, pj_ssize_t);

    void               (*stream_rtp_cb2)(pjmedia_tp_cb_param *param);
    void               (*stream_rtcp_cb)(void *user_data, void *pkt, pj_ssize_t);



    
    pjmedia_transport   *slave_tp;
};



PJ_DEF(pj_status_t) pjmedia_tp_adapter_create( pjmedia_endpt *endpt, const char *name, pjmedia_transport *transport, pj_bool_t del_base, pjmedia_transport **p_tp)



{
    pj_pool_t *pool;
    struct tp_adapter *adapter;

    if (name == NULL)
        name = "tpad%p";

    
    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);
    adapter = PJ_POOL_ZALLOC_T(pool, struct tp_adapter);
    adapter->pool = pool;
    pj_ansi_strxcpy(adapter->base.name, pool->obj_name,  sizeof(adapter->base.name));
    adapter->base.type = (pjmedia_transport_type)
                         (PJMEDIA_TRANSPORT_TYPE_USER + 1);
    adapter->base.op = &tp_adapter_op;

    
    adapter->slave_tp = transport;
    adapter->del_base = del_base;

    
    *p_tp = &adapter->base;
    return PJ_SUCCESS;
}



static pj_status_t transport_get_info(pjmedia_transport *tp, pjmedia_transport_info *info)
{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    
    return pjmedia_transport_get_info(adapter->slave_tp, info);
}



static void transport_rtp_cb2(pjmedia_tp_cb_param *param)
{
    struct tp_adapter *adapter = (struct tp_adapter*)param->user_data;

    pj_assert(adapter->stream_rtp_cb != NULL || adapter->stream_rtp_cb2 != NULL);

    
    if (adapter->stream_rtp_cb2) {
        pjmedia_tp_cb_param cbparam;
        
        pj_memcpy(&cbparam, param, sizeof(cbparam));
        cbparam.user_data = adapter->stream_user_data;
        adapter->stream_rtp_cb2(&cbparam);
    } else {
        adapter->stream_rtp_cb(adapter->stream_user_data, param->pkt, param->size);
    }
}


static void transport_rtcp_cb(void *user_data, void *pkt, pj_ssize_t size)
{
    struct tp_adapter *adapter = (struct tp_adapter*)user_data;

    pj_assert(adapter->stream_rtcp_cb != NULL);

    
    adapter->stream_rtcp_cb(adapter->stream_user_data, pkt, size);
}


static pj_status_t transport_attach2(pjmedia_transport *tp, pjmedia_transport_attach_param *att_param)
{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;
    pj_status_t status;

    
    pj_assert(adapter->stream_user_data == NULL);
    adapter->stream_user_data = att_param->user_data;
    if (att_param->rtp_cb2) {
        adapter->stream_rtp_cb2 = att_param->rtp_cb2;
    } else {
        adapter->stream_rtp_cb = att_param->rtp_cb;
    }
    adapter->stream_rtcp_cb = att_param->rtcp_cb;
    adapter->stream_ref = att_param->stream;

    att_param->rtp_cb2 = &transport_rtp_cb2;
    att_param->rtp_cb = NULL;    
    att_param->rtcp_cb = &transport_rtcp_cb;
    att_param->user_data = adapter;
        
    status = pjmedia_transport_attach2(adapter->slave_tp, att_param);
    if (status != PJ_SUCCESS) {
        adapter->stream_user_data = NULL;
        adapter->stream_rtp_cb = NULL;
        adapter->stream_rtp_cb2 = NULL;
        adapter->stream_rtcp_cb = NULL;
        adapter->stream_ref = NULL;
        return status;
    }

    return PJ_SUCCESS;
}


static void transport_detach(pjmedia_transport *tp, void *strm)
{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;
    
    PJ_UNUSED_ARG(strm);

    if (adapter->stream_user_data != NULL) {
        pjmedia_transport_detach(adapter->slave_tp, adapter);
        adapter->stream_user_data = NULL;
        adapter->stream_rtp_cb = NULL;
        adapter->stream_rtp_cb2 = NULL;
        adapter->stream_rtcp_cb = NULL;
        adapter->stream_ref = NULL;
    }
}



static pj_status_t transport_send_rtp( pjmedia_transport *tp, const void *pkt, pj_size_t size)

{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    

    
    return pjmedia_transport_send_rtp(adapter->slave_tp, pkt, size);
}



static pj_status_t transport_send_rtcp(pjmedia_transport *tp, const void *pkt, pj_size_t size)

{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    

    
    return pjmedia_transport_send_rtcp(adapter->slave_tp, pkt, size);
}



static pj_status_t transport_send_rtcp2(pjmedia_transport *tp, const pj_sockaddr_t *addr, unsigned addr_len, const void *pkt, pj_size_t size)



{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;
    return pjmedia_transport_send_rtcp2(adapter->slave_tp, addr, addr_len,  pkt, size);
}


static pj_status_t transport_media_create(pjmedia_transport *tp, pj_pool_t *sdp_pool, unsigned options, const pjmedia_sdp_session *rem_sdp, unsigned media_index)



{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    
    if (rem_sdp) {
        
    }

    
    return pjmedia_transport_media_create(adapter->slave_tp, sdp_pool, options, rem_sdp, media_index);
}


static pj_status_t transport_encode_sdp(pjmedia_transport *tp, pj_pool_t *sdp_pool, pjmedia_sdp_session *local_sdp, const pjmedia_sdp_session *rem_sdp, unsigned media_index)



{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    
    if (rem_sdp) {
        
    }

    
    if (1) {
        
        pjmedia_sdp_attr *my_attr;

        my_attr = PJ_POOL_ALLOC_T(sdp_pool, pjmedia_sdp_attr);
        pj_strdup2(sdp_pool, &my_attr->name, "X-adapter");
        pj_strdup2(sdp_pool, &my_attr->value, "some value");

        pjmedia_sdp_attr_add(&local_sdp->media[media_index]->attr_count, local_sdp->media[media_index]->attr, my_attr);

    }

    
    return pjmedia_transport_encode_sdp(adapter->slave_tp, sdp_pool, local_sdp, rem_sdp, media_index);
}


static pj_status_t transport_media_start(pjmedia_transport *tp, pj_pool_t *pool, const pjmedia_sdp_session *local_sdp, const pjmedia_sdp_session *rem_sdp, unsigned media_index)



{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    

    
    return pjmedia_transport_media_start(adapter->slave_tp, pool, local_sdp, rem_sdp, media_index);
}


static pj_status_t transport_media_stop(pjmedia_transport *tp)
{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    

    
    return pjmedia_transport_media_stop(adapter->slave_tp);
}


static pj_status_t transport_simulate_lost(pjmedia_transport *tp, pjmedia_dir dir, unsigned pct_lost)

{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;
    return pjmedia_transport_simulate_lost(adapter->slave_tp, dir, pct_lost);
}


static pj_status_t transport_destroy  (pjmedia_transport *tp)
{
    struct tp_adapter *adapter = (struct tp_adapter*)tp;

    
    if (adapter->del_base) {
        pjmedia_transport_close(adapter->slave_tp);
    }

    
    pj_pool_release(adapter->pool);

    return PJ_SUCCESS;
}





