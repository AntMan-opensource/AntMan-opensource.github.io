










































static const char *ntrip_state(unsigned state)
{
    
    const char *ntrip_states[] = {
        "INIT", "SENT_PROBE", "SENT_GET", "ESTABLISHED", "ERR", "CLOSED", "INPROGRESS", "UNKNOWN", };







    unsigned num_states = sizeof(ntrip_states)/sizeof(ntrip_states[0]);

    if (num_states <= state) {
        
        state = num_states - 1;
    }
    return ntrip_states[state];
}


static struct ntrip_fmt_s {
    const char *string;
    const enum ntrip_fmt format;
} const ntrip_fmts[] = {
    {"CMR+", FMT_CMRP},  {"RTCM1_", FMT_RTCM2_3}, {"RTCM 2.0", FMT_RTCM2_0}, {"RTCM 2.1", FMT_RTCM2_1}, {"RTCM 2.2", FMT_RTCM2_2}, {"RTCM22", FMT_RTCM2_2}, {"RTCM 2.3", FMT_RTCM2_3}, {"RTCM2.3", FMT_RTCM2_3}, {"RTCM 2", FMT_RTCM2}, {"RTCM2", FMT_RTCM2}, {"RTCM 3.0", FMT_RTCM3_0}, {"RTCM3.0", FMT_RTCM3_0}, {"RTCM 3.1", FMT_RTCM3_1}, {"RTCM3.1", FMT_RTCM3_1}, {"RTCM 3.2", FMT_RTCM3_2}, {"RTCM3.2", FMT_RTCM3_2}, {"RTCM32", FMT_RTCM3_2}, {"RTCM 3.3", FMT_RTCM3_3}, {"RTCM 3", FMT_RTCM3_0}, {"RTCM3", FMT_RTCM3_0}, {NULL, FMT_UNKNOWN}, };























static char *ntrip_field_iterate(char *start, char *prev, const char *eol, const struct gpsd_errout_t *errout)


{
    char *s, *t, *u;

    if (start) {
        s = start;
    } else {
        if (!prev) {
            return NULL;
        }
        s = prev + strnlen(prev, BUFSIZ) + 1;
        if (s >= eol) {
            return NULL;
        }
    }

    
    t = s;
    while ((u = strstr(t, NTRIP_QSC))) {
        t = u + sizeof(NTRIP_QSC) - 1;
    }

    if ((t = strstr(t, ";"))) {
        *t = '\0';
    }

    GPSD_LOG(LOG_RAW, errout, "NTRIP: Next source table field %s\n", s);

    return s;
}



static void ntrip_str_parse(char *str, size_t len, struct ntrip_stream_t *hold, const struct gpsd_errout_t *errout)

{
    char *s, *eol = str + len;

    memset(hold, 0, sizeof(*hold));

    
    if (NULL != (s = ntrip_field_iterate(str, NULL, eol, errout))) {
        (void)strlcpy(hold->mountpoint, s, sizeof(hold->mountpoint));
    }
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        struct ntrip_fmt_s const *pfmt;

        hold->format = FMT_UNKNOWN;
        for (pfmt = ntrip_fmts; NULL != pfmt->string; pfmt++) {
            if (0 == strcasecmp(pfmt->string, s)) {
                hold->format = pfmt->format;
                break;
            }
        }
        if (FMT_UNKNOWN == hold->format) {
            GPSD_LOG(LOG_WARN, errout, "NTRIP: Got unknown format '%s'\n", s);
        }
    }
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        hold->carrier = atoi(s);
    }
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    hold->latitude = NAN;
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        hold->latitude = safe_atof(s);
    }
    
    hold->longitude = NAN;
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        hold->longitude = safe_atof(s);
    }
    
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        hold->nmea = atoi(s);
    }
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {

        if (('\0' == s[0]) || (0 == strcmp(" ", s)) || (0 == strcasecmp("none", s))) {

            hold->compr_encryp = CMP_ENC_NONE;
        } else {
            hold->compr_encryp = CMP_ENC_UNKNOWN;
            GPSD_LOG(LOG_WARN, errout, "NTRIP: Got unknown {compress,encrypt}ion '%s'\n", s);
        }
    } else {
        GPSD_LOG(LOG_WARN, errout, "NTRIP: STR missing encryption and authentication fields\n");
        return;    
    }
    
    if (NULL != (s = ntrip_field_iterate(NULL, s, eol, errout))) {
        if (0 == strcasecmp("N", s)) {
            hold->authentication = AUTH_NONE;
        } else if (0 == strcasecmp("B", s)) {
            hold->authentication = AUTH_BASIC;
        } else if (0 == strcasecmp("D", s)) {
            hold->authentication = AUTH_DIGEST;
        } else {
            hold->authentication = AUTH_UNKNOWN;
            GPSD_LOG(LOG_WARN, errout, "NTRIP: Got unknown authenticatiion '%s'\n", s);
        }
    } else {
        GPSD_LOG(LOG_WARN, errout, "NTRIP: STR missing authenticatiion field\n");
        return;    
    }
    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    if (NULL == s) {
        
        return;
    }
    hold->fee = atoi(s);

    
    s = ntrip_field_iterate(NULL, s, eol, errout);
    if (NULL == s) {
        
        return;
    }
    hold->bitrate = atoi(s);

    
    
}


static int ntrip_sourcetable_parse(struct gps_device_t *device)
{
    struct ntrip_stream_t hold;
    ssize_t llen, len = 0;
    char *line;
    char buf[BUFSIZ / 2];   
    socket_t fd = device->gpsdata.gps_fd;

    for (;;) {
        ssize_t rlen;

        memset(&buf[len], 0, sizeof(buf) - (size_t)len);
        errno = 0;         
        
        rlen = read(fd, &buf[len], sizeof(buf) - (size_t)(1 + len));
        GPSD_LOG(LOG_RAW, &device->context->errout, "NTRIP: on fd %d len %zd  tried %zd, got %zd\n", fd, len, sizeof(buf) - (size_t)(1 + len), rlen);

        if (-1 == rlen) {
            if (EINTR == errno) {
                continue;
            }
            if (device->ntrip.sourcetable_parse && EAGAIN == errno) {
                
                return 0;
            }
            GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: stream read error %s(%d) on fd %d\n", strerror(errno), errno, fd);

            return -1;
        }
        if (0 == rlen) {     
            GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: stream unexpected close %s(%d) on fd %d " "during sourcetable read\n", strerror(errno), errno, fd);


            return -2;
        }

        line = buf;
        len += rlen;
        rlen = len;
        
        
        

        GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: source table buffer >%.*s<\n", (int)rlen, buf);

        line[rlen] = '\0';      

        if (!device->ntrip.sourcetable_parse) {
            

            if (str_starts_with(line, NTRIP_SOURCETABLE)) {
                
                device->ntrip.sourcetable_parse = true;
            } else if (NULL != strstr(line, NTRIP_SOURCETABLE2)) {
                
                device->ntrip.sourcetable_parse = true;
            } else {
                GPSD_LOG(LOG_WARN, &device->context->errout, "NTRIP: Unexpected reply: %s.\n", buf);

                return -3;
            }
            line = strstr(line, NTRIP_BODY);
            if (NULL == line) {
                return  -4;
            }
            line += 4;        
            len = rlen - (line - buf);
        }

        while (0 < len) {
            char *eol;

            if (str_starts_with(line, NTRIP_ENDSOURCETABLE)) {
                
                
                return -5;
            }

            eol = strstr(line, NTRIP_BR);
            if (NULL == eol){
                
                break;
            }

            *eol = '\0';
            llen = (ssize_t)(eol - line);

            GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: checking: >%s<\n", line);

            if (str_starts_with(line, NTRIP_STR)) {
                
                ntrip_str_parse(line + sizeof(NTRIP_STR) - 1, (size_t)(llen - (sizeof(NTRIP_STR) - 1)), &hold, &device->context->errout);


                if (0 == strcmp(device->ntrip.stream.mountpoint, hold.mountpoint)) {
                    

                    
                    
                    if (FMT_UNKNOWN == hold.format) {
                        GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: stream %s format not supported\n", line);

                        return -6;
                    }
                    
                    if (CMP_ENC_NONE != hold.compr_encryp) {
                        GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP. stream %s compression/encryption " "algorithm not supported\n", line);


                        return -7;
                    }
                    
                    if (AUTH_NONE != hold.authentication && AUTH_BASIC != hold.authentication) {
                        GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP. stream %s authentication method " "not supported\n", line);


                        return -8;
                    }
                    
                    device->ntrip.stream.format = hold.format;
                    device->ntrip.stream.carrier = hold.carrier;
                    device->ntrip.stream.latitude = hold.latitude;
                    device->ntrip.stream.longitude = hold.longitude;
                    device->ntrip.stream.nmea = hold.nmea;
                    device->ntrip.stream.compr_encryp = hold.compr_encryp;
                    device->ntrip.stream.authentication = hold.authentication;
                    device->ntrip.stream.fee = hold.fee;
                    device->ntrip.stream.bitrate = hold.bitrate;
                    device->ntrip.stream.set = true;
                    return 1;
                }
                
            } else if (str_starts_with(line, NTRIP_CAS)) {
                
                
                GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: Skipping: '%s'\n", line);
            } else if (str_starts_with(line, NTRIP_NET)) {
                
                
                GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: Skipping '%s'\n", line);
            }
            

            llen += sizeof(NTRIP_BR) - 1;
            line += llen;        
            len -= llen;         
            GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: Remaining source table buffer len %zd\n", len);
        }

        GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: Remaining source table buffer len %zd\n", len);

        if (0 < len) {
            
            
            memmove(buf, line, (size_t)len);
        }
    }

    
    return -9;
}


static int ntrip_stream_req_probe(const struct ntrip_stream_t *stream, struct gpsd_errout_t *errout)
{
    int dsock;
    ssize_t r, blen;
    char buf[BUFSIZ];
    char outbuf[BUFSIZ];

    
    dsock = netlib_connectsock(AF_UNSPEC, stream->host, stream->port, "tcp");
    if (0 > dsock) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: ntrip_stream_req_probe(%s) connect error %s(%d)\n", stream->url, netlib_errstr(dsock), dsock);

        return -1;
    }
    blen = snprintf(buf, sizeof(buf), "GET / HTTP/1.1\r\n" "Ntrip-Version: Ntrip/2.0\r\n" "User-Agent: NTRIP gpsd/%s\r\n" "Host: %s\r\n" "Connection: close\r\n" "\r\n", VERSION, stream->host);





    if (1 > blen) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: ntrip_stream_req_probe(%s) snprintf() fail\n", stream->url);

        return -1;
    }

    GPSD_LOG(LOG_IO, errout, "NTRIP: ntrip_stream_req_probe(%s) fd %d sending >%s<\n", stream->url, dsock, gps_visibilize(outbuf, sizeof(outbuf), buf, blen));



    r = write(dsock, buf, blen);
    if (blen != r) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: stream write error %s(%d) on fd %d " "during probe request %zd\n", strerror(errno), errno, dsock, r);


        (void)close(dsock);
        return -1;
    }
    
    return dsock;
}


static int ntrip_auth_encode(struct ntrip_stream_t *stream)
{
    char authenc[64];       
    int ret = 0;

    memset(stream->authStr, 0, sizeof(stream->authStr));
    switch (stream->authentication) {
    case AUTH_NONE:
        if ('\0' == *stream->credentials) {
            
            break;
        }
        
        FALLTHROUGH case AUTH_BASIC:
        
        
        memset(authenc, 0, sizeof(authenc));
        if (0 > b64_ntop((const unsigned char *)stream->credentials, strnlen(stream->credentials, sizeof(stream->credentials)), authenc, sizeof(authenc) - 1)) {


            ret = -1;
            break;
        }
        (void)snprintf(stream->authStr, sizeof(stream->authStr), "Authorization: Basic %s\r\n", authenc);
        break;
    case AUTH_DIGEST:
        
        
        
        
        ret = -1;
        break;
    case AUTH_UNKNOWN:
        
        FALLTHROUGH default:
        ret = -1;
        break;
    }
    return ret;
}


static socket_t ntrip_stream_get_req(const struct ntrip_stream_t *stream, const struct gpsd_errout_t *errout)
{
    int dsock;
    char buf[BUFSIZ];
    char outbuf[BUFSIZ];
    ssize_t cnt, cnt1;

    
    dsock = netlib_connectsock(AF_UNSPEC, stream->host, stream->port, "tcp");
    if (BAD_SOCKET(dsock)) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: stream connect error %ss(%d)\n", netlib_errstr(dsock), dsock);

        return -1;
    }

    GPSD_LOG(LOG_SPIN, errout, "NTRIP: netlib_connectsock() returns socket on fd %d\n", dsock);


    cnt = snprintf(buf, sizeof(buf), "GET /%s HTTP/1.1\r\n" "Ntrip-Version: Ntrip/2.0\r\n" "User-Agent: NTRIP gpsd/%s\r\n" "Host: %s\r\n" "Accept: rtk/rtcm, dgps/rtcm\r\n" "%s" "Connection: close\r\n" "\r\n", stream->mountpoint, VERSION, stream->host, stream->authStr);








    if (1 > cnt) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: netlib_connectsock() snprintf fail<\n");
        return -1;
    }

    GPSD_LOG(LOG_IO, errout, "NTRIP: netlib_connectsock() sending >%s<\n", gps_visibilize(outbuf, sizeof(outbuf), buf, cnt));


    cnt1 = write(dsock, buf, cnt);
    if (cnt != cnt1) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: stream write error %s(%d) on fd %d during " "get request\n", strerror(errno), errno, dsock);


        (void)close(dsock);
        return -1;
    }
    return dsock;
}


static void lexer_getline(struct gps_lexer_t *lexer)
{
    unsigned i;

    for (i = 0; i < sizeof(lexer->outbuffer) - 2; i++) {
        unsigned char u = *lexer->inbufptr++;

        lexer->outbuffer[i] = u;
        lexer->inbuflen--;

        if ('\0' == u) {
            
            break;
        }
        if ('\n' == u) {
            
            i++;
            break;
        }

        if (0 == lexer->inbuflen) {
            
            i++;
            break;
        }
    }
    lexer->outbuffer[i] = '\0';  
    lexer->outbuflen = i;
}


static int ntrip_stream_get_parse(struct gps_device_t *device)
{
    char dbgbuf[128];
    int opts;
    const struct ntrip_stream_t *stream = &device->ntrip.stream;
    const int dsock  = device->gpsdata.gps_fd;
    const struct gpsd_errout_t *errout = &device->context->errout;
    ssize_t read_ret;         
    struct gps_lexer_t *lexer = &device->lexer;
    char *ibuf = (char *)lexer->inbuffer;
    char *obuf = (char *)lexer->outbuffer;

    GPSD_LOG(LOG_PROG, errout, "NTRIP: ntrip_stream_get_parse(fd %d)\n", dsock);
    lexer_init(lexer, &device->context->errout);
    
    while (-1 == (read_ret = read(dsock, ibuf, 1024))) {
        if (EINTR == errno) {
            continue;
        }
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: stream read error %s(%d) on fd %d during get rsp\n", strerror(errno), errno, dsock);

        return -1;
    }
    ibuf[read_ret] = '\0';   
    lexer->inbuflen = read_ret;
    lexer_getline(lexer);
    GPSD_LOG(LOG_IO, errout, "NTRIP: lexer_getline() >%s<\n", gps_visibilize(dbgbuf, sizeof(dbgbuf), (char *)lexer->outbuffer, lexer->outbuflen));



    

    if (0 == strncmp(obuf, NTRIP_UNAUTH, sizeof(NTRIP_UNAUTH))) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: not authorized for %s\n", stream->url);
        return -1;
    }
    
    if (0 != strncmp(obuf, NTRIP_ICY, sizeof(NTRIP_ICY)) && 0 != strncmp(obuf, NTRIP_HTTP, sizeof(NTRIP_HTTP))) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: Unknown reply %s from caster: %s:%s/%s\n", obuf, stream->host, stream->port, stream->mountpoint);

        return -1;
    }

    

    

    while (1) {
        lexer_getline(lexer);
        GPSD_LOG(LOG_IO, errout, "NTRIP: lexer_getline() >%s<\n", gps_visibilize(dbgbuf, sizeof(dbgbuf), (char *)lexer->outbuffer, lexer->outbuflen));



        
        if (0 == strncmp(obuf, NTRIP_CHUNKED, sizeof(NTRIP_CHUNKED))) {
            GPSD_LOG(LOG_PROG, errout, "NTRIP: caster sends chunked data\n");
            lexer->chunked = true;
        }
        if ('\0' == *lexer->outbuffer) {
            
            break;
        }
        if (0 == strncmp(obuf, NTRIP_BR, sizeof(NTRIP_BR))) {
            
            break;
        }
    }
    opts = fcntl(dsock, F_GETFL);

    if (-1 == opts) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: fcntl(%d) %s(%d)\n", dsock, strerror(errno), errno);
    } else {
        (void)fcntl(dsock, F_SETFL, opts | O_NONBLOCK);
    }
    
    
    GPSD_LOG(LOG_IO, errout, "NTRIP: ntrip_stream_get_parse(), %zu leftover bytes\n", lexer->inbuflen);

    if (0 == lexer->inbuflen) {
        packet_reset(lexer);
    } else {
        
        if (lexer->inbufptr != lexer->inbuffer) {
            
            memmove(lexer->inbuffer, lexer->inbufptr, lexer->inbuflen);
            lexer->inbufptr = lexer->inbuffer;
        }
        GPSD_LOG(LOG_IO, errout, "NTRIP: leftover: >%s<\n", gps_visibilize(dbgbuf, sizeof(dbgbuf), (char *)lexer->inbuffer, lexer->inbuflen));


    }
    
    lexer->inbufptr = lexer->inbuffer;
    return 0;
}


int ntrip_parse_url(const struct gpsd_errout_t *errout, struct ntrip_stream_t *stream, const char *fullurl)
{
    char dup[256];                       
    char *at;                            
    char *colon;                         
    char *slash;                         
    char *lsb;                           
    char *rsb;                           
    char *auth = NULL;                   
    char *host = NULL;                   
    char *port = NULL;
    char *mountpoint = NULL;             

    
    strlcpy(stream->url, fullurl, sizeof(stream->url) - 1);

    
    strlcpy(dup, fullurl, sizeof(dup) - 1);

    
    if (NULL == (slash = strrchr(dup, '/'))) {
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: can't extract stream from %s\n", dup);
        return -1;
    }
    *slash = '\0';
    mountpoint = slash + 1;
    

    if ('\0' == mountpoint[0]) {
        
        GPSD_LOG(LOG_ERROR, errout, "NTRIP: ntrip_parse_url(%s) missing mountpoint.\n", fullurl);
        return -1;
    }
    (void)strlcpy(stream->mountpoint, mountpoint, sizeof(stream->mountpoint));

    
    
    at = strrchr(dup, '@');         
    colon = strrchr(dup, ':');      
    rsb = strrchr(dup, ']');        
    lsb = strrchr(dup, '[');        

    if (NULL == colon) {
        
        port = NULL;
        auth = NULL;
        host = dup;
    } else {
        

        if (NULL == at) {
            
            
            if (NULL == rsb || NULL == lsb) {
                
                
                auth = NULL;
                host = dup;
                *colon = '\0';
                port = colon + 1;
            } else {
                
                auth = NULL;
                host = dup + 1;
                *rsb = '\0';
                if (rsb < colon) {
                    
                    *colon = '\0';
                    port = colon + 1;
                } else {
                    
                    port = NULL;
                }
            }
        } else {
            
            auth = dup;
            if (colon < at) {
                
                
                *at = '\0';
                host = at + 1;
                port = NULL;
            } else {
                
                
                
                
                *at = '\0';
                if (NULL == rsb || NULL == lsb) {
                    
                    
                    host = at + 1;
                    *colon = '\0';
                    port = colon + 1;
                } else {
                    
                    
                    
                    host = lsb + 1;
                    *rsb = '\0';
                    if (rsb < colon) {
                        
                        port = rsb + 2;
                    } else {
                        
                        port = NULL;
                    }
                }
            }
        }
    }
    if (NULL != auth) {
        (void)strlcpy(stream->credentials, auth, sizeof(stream->credentials));
    }

    if (NULL == port || '\0' == port[0]) {
        port = "rtcm-sc104";
        if (NULL == getservbyname(port, "tcp")) {
            
            port = DEFAULT_RTCM_PORT;
        }
    }
    
    if (NULL != port) {
        (void)strlcpy(stream->port, port, sizeof(stream->port));
    }

    
    if (NULL != host) {
        (void)strlcpy(stream->host, host, sizeof(stream->host));
    }

    GPSD_LOG(LOG_PROG, errout, "NTRIP: ntrip_parse_url(%s) credentials %s host %s port %s " "moutpoint %s\n", fullurl, stream->credentials, stream->host, stream->port, stream->mountpoint);





    return 0;
}


static int ntrip_reconnect(struct gps_device_t *device)
{

    socket_t dsock = -1;
    char addrbuf[50];         

    GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_reconnect() %.60s\n", device->gpsdata.dev.path);

    dsock = netlib_connectsock1(AF_UNSPEC, device->ntrip.stream.host, device->ntrip.stream.port, "tcp", 1, false, addrbuf, sizeof(addrbuf));


    device->gpsdata.gps_fd = dsock;
    
    
    if (0 > dsock) {
        
        GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: ntrip_reconnect(%s) IP %s, failed: %s(%d)\n", device->gpsdata.dev.path, addrbuf, netlib_errstr(dsock), dsock);


        
        (void)clock_gettime(CLOCK_REALTIME, &device->ntrip.stream.stream_time);
        
        device->ntrip.conn_state = NTRIP_CONN_CLOSED;
        return PLACEHOLDING_FD;
    }
    
    
    device->ntrip.conn_state = NTRIP_CONN_INPROGRESS;
    GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_reconnect(%s) IP %s, fd %d NTRIP_CONN_INPROGRESS \n", device->gpsdata.dev.path, addrbuf, dsock);


    GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_reconnect(%s) no SOCK_NONBLOCK, can't reconnect.\n", device->gpsdata.dev.path);

    device->gpsdata.gps_fd = -1;

    return device->gpsdata.gps_fd;
}


int ntrip_open(struct gps_device_t *device, char *orig)
{
    socket_t ret = -1;
    char buf[BUFSIZ];
    char outbuf[BUFSIZ];
    ssize_t blen;

    GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_open(%s) fd %d state = %s(%d)\n", orig, device->gpsdata.gps_fd, ntrip_state(device->ntrip.conn_state), device->ntrip.conn_state);




    switch (device->ntrip.conn_state) {
    case NTRIP_CONN_INIT:     
        
        
        device->servicetype = SERVICE_NTRIP;
        device->ntrip.works = false;
        device->ntrip.sourcetable_parse = false;
        device->ntrip.stream.set = false;
        device->gpsdata.gps_fd = PLACEHOLDING_FD;

        ret = ntrip_parse_url(&device->context->errout, &device->ntrip.stream, orig);
        if (0 > ret) {
            
            device->gpsdata.gps_fd = PLACEHOLDING_FD;
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }

        ret = ntrip_stream_req_probe(&device->ntrip.stream, &device->context->errout);
        GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_stream_req_probe(%s) ret %d\n", device->ntrip.stream.url, ret);

        if (-1 == ret) {
            device->gpsdata.gps_fd = PLACEHOLDING_FD;
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }
        
        
        (void)clock_gettime(CLOCK_REALTIME, &device->ntrip.stream.stream_time);

        device->gpsdata.gps_fd = ret;
        device->ntrip.conn_state = NTRIP_CONN_SENT_PROBE;
        return ret;
    case NTRIP_CONN_SENT_PROBE:     
        ret = ntrip_sourcetable_parse(device);
        GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: ntrip_sourcetable_parse(%s) = %d\n", device->ntrip.stream.mountpoint, ret);

        if (0 > ret) {
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }
        if (0 == ret && false == device->ntrip.stream.set) {
            return ret;
        }
        if (NULL != device->gpsdata.update_fd) {
            device->gpsdata.update_fd(device->gpsdata.gps_fd, false);
        }
        (void)close(device->gpsdata.gps_fd);
        device->gpsdata.gps_fd = PLACEHOLDING_FD;
        GPSD_LOG(LOG_PROG, &device->context->errout, "NTRIP: found %s: %s: %d,%d,%f,%f,%d,%d,%d,%d,%d\n", device->ntrip.stream.url, device->ntrip.stream.mountpoint, device->ntrip.stream.format, device->ntrip.stream.carrier, device->ntrip.stream.latitude, device->ntrip.stream.longitude, device->ntrip.stream.nmea, device->ntrip.stream.compr_encryp, device->ntrip.stream.authentication, device->ntrip.stream.fee, device->ntrip.stream.bitrate);











        if (0 != ntrip_auth_encode(&device->ntrip.stream)) {
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }
        ret = ntrip_stream_get_req(&device->ntrip.stream, &device->context->errout);
        if (-1 == ret) {
            device->gpsdata.gps_fd = PLACEHOLDING_FD;
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }
        device->gpsdata.gps_fd = ret;
        if (NULL != device->gpsdata.update_fd) {
            device->gpsdata.update_fd(device->gpsdata.gps_fd, true);
        }
        device->ntrip.conn_state = NTRIP_CONN_SENT_GET;
        break;
    case NTRIP_CONN_SENT_GET:          
        ret = ntrip_stream_get_parse(device);
        if (-1 == ret) {
            (void)close(device->gpsdata.gps_fd);
            device->gpsdata.gps_fd = PLACEHOLDING_FD;
            device->ntrip.conn_state = NTRIP_CONN_ERR;
            return -1;
        }
        device->ntrip.conn_state = NTRIP_CONN_ESTABLISHED;
        device->ntrip.works = true;   
        break;
    case NTRIP_CONN_CLOSED:           
        if (6 > llabs((time(NULL) - device->ntrip.stream.stream_time.tv_sec))) {
            
            ret = PLACEHOLDING_FD;
            break;
        }
        ret = ntrip_reconnect(device);
        if (0 <= ret && NULL != device->gpsdata.update_fd) {
            device->gpsdata.update_fd(ret, true);
        }
        break;
    case NTRIP_CONN_INPROGRESS:      
        
        
        
        blen = snprintf(buf, sizeof(buf), "GET /%s HTTP/1.1\r\n" "Ntrip-Version: Ntrip/2.0\r\n" "User-Agent: NTRIP gpsd/%s\r\n" "Host: %s\r\n" "Accept: rtk/rtcm, dgps/rtcm\r\n" "%s" "Connection: close\r\n" "\r\n", device->ntrip.stream.mountpoint, VERSION, device->ntrip.stream.host, device->ntrip.stream.authStr);










        if (1 > blen) {
            GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: ntrip_open() snprintf fail<\n");
            return -1;
        }

        GPSD_LOG(LOG_IO, &device->context->errout, "NTRIP: ntrip_open() sending >%s<\n", gps_visibilize(outbuf, sizeof(outbuf), buf, blen));


        if (blen != write(device->gpsdata.gps_fd, buf, blen)) {
            GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: stream write error %s(%d) on fd %d during " "get request\n", strerror(errno), errno, device->gpsdata.gps_fd);


            device->ntrip.conn_state = NTRIP_CONN_ERR;
            
            
        } else {
            GPSD_LOG(LOG_ERROR, &device->context->errout, "NTRIP: stream write success get request\n");
            device->ntrip.conn_state = NTRIP_CONN_SENT_GET;
        }
        ret = device->gpsdata.gps_fd;
        break;
    case NTRIP_CONN_ESTABLISHED:     
        FALLTHROUGH case NTRIP_CONN_ERR:
        return -1;
    }
    return ret;
}


void ntrip_report(struct gps_context_t *context, struct gps_device_t *gps, struct gps_device_t *caster)

{
    static int count = 0;
    char buf[BUFSIZ];
    ssize_t blen;

    if (0 == caster->ntrip.stream.nmea) {
        return;   
    }
    GPSD_LOG(LOG_IO, &context->errout, "NTRIP: = ntrip_report() fixcnt %d count %d caster %d\n", context->fixcnt, count, caster->gpsdata.gps_fd);


    
    if (10 > context->fixcnt) {
        return;   
    }

    
    count++;
    if (0 != (count % 5)) {
        return;   
    }
    if (0 > caster->gpsdata.gps_fd) {
        return;   
    }

    blen = gpsd_position_fix_dump(gps, buf, sizeof(buf));
    if (0 < blen) {
        ssize_t ret;

        ret = write(caster->gpsdata.gps_fd, buf, blen);
        if (blen == ret) {
            GPSD_LOG(LOG_IO, &context->errout, "NTRIP: => caster %s\n", buf);
        } else if (0 > ret) {
            GPSD_LOG(LOG_ERROR, &context->errout, "NTRIP: ntrip_report() write(%d) error %s(%d)\n", caster->gpsdata.gps_fd, strerror(errno), errno);

        } else {
            GPSD_LOG(LOG_ERROR, &context->errout, "NTRIP: ntrip_report() short write(%d) = %zd\n", caster->gpsdata.gps_fd, ret);

        }
    }
}


void ntrip_close(struct gps_device_t *session)
{
    if (0 > session->gpsdata.gps_fd) {
        
        GPSD_LOG(LOG_ERROR, &session->context->errout, "NTRIP: ntrip_close(%s), close(%d) bad fd\n", session->gpsdata.dev.path, session->gpsdata.gps_fd);

        session->gpsdata.gps_fd = PLACEHOLDING_FD;
        return;
    }

    if (-1 == close(session->gpsdata.gps_fd)) {
        GPSD_LOG(LOG_ERROR, &session->context->errout, "NTRIP: ntrip_close(%s), close(%d), %s(%d)\n", session->gpsdata.dev.path, session->gpsdata.gps_fd, strerror(errno), errno);


    } else {
        GPSD_LOG(LOG_IO, &session->context->errout, "NTRIP: ntrip_close(%s), close(%d)\n", session->gpsdata.dev.path, session->gpsdata.gps_fd);


    }
    
    (void)clock_gettime(CLOCK_REALTIME, &session->ntrip.stream.stream_time);

    session->gpsdata.gps_fd = PLACEHOLDING_FD;
    session->ntrip.conn_state = NTRIP_CONN_CLOSED;
}

