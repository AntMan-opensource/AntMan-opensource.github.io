










































static void       xfce_mime_helper_finalize   (GObject        *object);
static XfceMimeHelper *xfce_mime_helper_new        (const gchar    *id, XfceRc         *rc);
static void       clear_bad_entries     (XfceRc         *rc);



struct _XfceMimeHelperClass {
  GObjectClass __parent__;
};

struct _XfceMimeHelper {
  GObject __parent__;

  guint             startup_notify : 1;

  gchar            *id;
  gchar            *icon;
  gchar            *name;
  gchar           **commands;
  gchar           **commands_with_parameter;
  gchar           **commands_with_flag;
  XfceMimeHelperCategory category;
};



G_DEFINE_TYPE (XfceMimeHelper, xfce_mime_helper, G_TYPE_OBJECT)



static void xfce_mime_helper_class_init (XfceMimeHelperClass *klass)
{
  GObjectClass *gobject_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = xfce_mime_helper_finalize;
}



static void xfce_mime_helper_init (XfceMimeHelper *helpers)
{
}



static void xfce_mime_helper_finalize (GObject *object)
{
  XfceMimeHelper *helper = XFCE_MIME_HELPER (object);

  g_strfreev (helper->commands_with_flag);
  g_strfreev (helper->commands_with_parameter);
  g_strfreev (helper->commands);
  g_free (helper->name);
  g_free (helper->icon);
  g_free (helper->id);

  (*G_OBJECT_CLASS (xfce_mime_helper_parent_class)->finalize) (object);
}



static gchar** substitute_binary (const gchar *commands, const gchar *binary)

{
  gchar **result;
  gchar **s, **t;
  gchar  *tmp;

  
  result = g_strsplit (commands, ";", -1);

  
  for (s = t = result; *s != NULL; ++s)
    {
      if (**s == '\0')
        {
          g_free (*s);
        }
      else if (binary != NULL)
        {
          tmp = xfce_str_replace (*s, "%B", binary);
          g_free (*s);
          *t++ = tmp;
        }
      else {
          *t++ = *s;
        }
    }
  *t = NULL;

  return result;
}




static gchar ** substitute_env(const gchar *commands, const gchar *commands_with_parameter, const gchar *binary)


{
  gchar **result;

  result = substitute_binary(commands, binary);

  if (G_UNLIKELY(*result != NULL && g_strcmp0 (*result, "env") == 0))
  {
    gchar **replaced;
    gchar *command = xfce_str_replace(commands_with_parameter, "%s", "");
    gchar *cleaned = xfce_str_replace(command, "\"\"", "");

    replaced = substitute_binary(cleaned, binary);
    if (*replaced != NULL && g_strcmp0 (*replaced, "env") != 0)
    {
      g_strfreev(result);
      result = replaced;
    }
    else {
      g_strfreev(replaced);
    }

    g_free(cleaned);
    g_free(command);
  }

  return result;
}



static XfceMimeHelper* xfce_mime_helper_new (const gchar *id, XfceRc      *rc)

{
  const gchar *commands_with_flag;
  const gchar *commands_with_parameter;
  const gchar *commands;
  const gchar *str;
  XfceMimeHelper   *helper;
  gchar      **binaries;
  gchar       *binary = NULL;
  guint        n;

  g_return_val_if_fail (id != NULL, NULL);
  g_return_val_if_fail (rc != NULL, NULL);

  xfce_rc_set_group (rc, "Desktop Entry");

  
  helper = g_object_new (XFCE_MIME_TYPE_HELPER, NULL);
  helper->id = g_strdup (id);
  helper->startup_notify = xfce_rc_read_bool_entry (rc, "StartupNotify", FALSE);

  
  str = xfce_rc_read_entry_untranslated (rc, "Type", NULL);
  if (G_UNLIKELY (g_strcmp0 (str, "X-XFCE-Helper") != 0))
    goto failed;

  
  str = xfce_rc_read_entry_untranslated (rc, "X-XFCE-Category", NULL);
  if (!xfce_mime_helper_category_from_string (str, &helper->category))
    goto failed;

  
  str = xfce_rc_read_entry (rc, "Name", NULL);
  if (G_UNLIKELY (xfce_str_is_empty (str)))
    goto failed;
  helper->name = g_strdup (str);

  
  str = xfce_rc_read_entry_untranslated (rc, "Icon", NULL);
  if (G_LIKELY (!xfce_str_is_empty (str)))
    helper->icon = g_strdup (str);

  
  commands = xfce_rc_read_entry_untranslated (rc, "X-XFCE-Commands", NULL);
  if (G_UNLIKELY (commands == NULL))
    goto failed;

  commands_with_flag = xfce_str_replace (commands, ";", " %s;");

  
  commands_with_parameter = xfce_rc_read_entry_untranslated (rc, "X-XFCE-CommandsWithParameter", NULL);
  if (G_UNLIKELY (commands_with_parameter == NULL))
    goto failed;

  
  if (strstr (commands, "%B") != NULL || strstr (commands_with_parameter, "%B") != NULL)
    {
      
      str = xfce_rc_read_entry_untranslated (rc, "X-XFCE-Binaries", NULL);
      if (G_UNLIKELY (str == NULL))
        goto failed;

      
      binaries = g_strsplit (str, ";", -1);
      for (binary = NULL, n = 0; binaries[n] != NULL && binary == NULL; ++n)
        if (G_LIKELY (binaries[n][0] != '\0'))
          binary = g_find_program_in_path (binaries[n]);
      g_strfreev (binaries);

      
      if (G_UNLIKELY (binary == NULL))
        goto failed;
    }

  
  helper->commands = substitute_env (commands, commands_with_parameter, binary);
  helper->commands_with_flag = substitute_binary (commands_with_flag, binary);
  helper->commands_with_parameter = substitute_binary (commands_with_parameter, binary);
  g_free (binary);

  
  if (G_UNLIKELY (*helper->commands == NULL || *helper->commands_with_parameter == NULL))
    goto failed;

  return helper;

failed:
  g_object_unref (G_OBJECT (helper));
  return NULL;
}




XfceMimeHelperCategory xfce_mime_helper_get_category (const XfceMimeHelper *helper)
{
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), XFCE_MIME_HELPER_WEBBROWSER);
  return helper->category;
}




const gchar* xfce_mime_helper_get_id (const XfceMimeHelper *helper)
{
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), NULL);
  return helper->id;
}




const gchar* xfce_mime_helper_get_name (const XfceMimeHelper *helper)
{
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), NULL);
  return helper->name;
}




const gchar* xfce_mime_helper_get_icon (const XfceMimeHelper *helper)
{
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), NULL);
  return helper->icon;
}




const gchar* xfce_mime_helper_get_command (const XfceMimeHelper *helper)
{
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), NULL);
  return *helper->commands_with_parameter;
}


static void set_environment (gchar *display)
{
  if (display != NULL)
    g_setenv ("DISPLAY", display, TRUE);
}


gboolean xfce_mime_helper_execute (XfceMimeHelper   *helper, GdkScreen   *screen, const gchar *parameter, GError     **error)



{
  gint64        previous;
  gint64        current;
  GdkDisplay   *display = NULL;
  gboolean      succeed = FALSE;
  GError       *err = NULL;
  gchar       **commands;
  gchar       **argv;
  gchar        *command;
  gchar        *display_name = NULL;
  guint         n;
  gint          status;
  gint          result;
  gint          pid;
  const gchar  *real_parameter = parameter;

  

  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), FALSE);
  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
  g_return_val_if_fail (screen == NULL || GDK_IS_SCREEN (screen), FALSE);

  
  if (G_UNLIKELY (screen == NULL))
    screen = gdk_screen_get_default ();

  
  if (real_parameter != NULL && g_str_has_prefix (real_parameter, "mailto:"))
    real_parameter = parameter + 7;

  
  if (real_parameter != NULL && g_str_has_prefix (real_parameter, "-")) {
    commands = helper->commands_with_flag;
  } else if (xfce_str_is_empty (real_parameter)) {
    commands = helper->commands;
  } else {
    commands = helper->commands_with_parameter;
  }

  
  if (G_UNLIKELY (*commands == NULL))
    {
      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_INVAL, _("No command specified"));
      return FALSE;
    }

  
  for (n = 0; commands[n] != NULL; ++n)
    {
      
      g_clear_error (&err);

      
      command = !xfce_str_is_empty (real_parameter) ? xfce_str_replace (commands[n], "%s", real_parameter) : g_strdup (commands[n]);
      succeed = g_shell_parse_argv (command, NULL, &argv, &err);
      g_free (command);

      
      if (G_UNLIKELY (!succeed))
        continue;

      

      display = gdk_screen_get_display (screen);
      if (display != NULL && GDK_IS_X11_DISPLAY (display))
        display_name = g_strdup (gdk_display_get_name (display));


      
      succeed = g_spawn_async (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH, (GSpawnChildSetupFunc) set_environment, display_name, &pid, &err);







      
      g_strfreev (argv);
      g_free (display_name);

      
      if (G_LIKELY (succeed))
        {
          
          previous = g_get_monotonic_time ();

          
          for (;;)
            {
              
              result = waitpid (pid, &status, WNOHANG);
              if (result < 0)
                {
                  
                  err = g_error_new_literal (G_FILE_ERROR, g_file_error_from_errno (errno), g_strerror (errno));
                  succeed = FALSE;
                  break;
                }
              else if (result > 0 && status != 0)
                {
                  
                  err = g_error_new_literal (G_FILE_ERROR, g_file_error_from_errno (EIO), g_strerror (EIO));
                  succeed = FALSE;
                  break;
                }
              else if (result == pid)
                {
                  
                  succeed = TRUE;
                  break;
                }

              
              current = g_get_monotonic_time ();

              
              if ((current - previous) / G_USEC_PER_SEC > 5)
                break;

              
              g_usleep (50 * 1000);
            }

          
          if (G_LIKELY (succeed))
            break;
        }
    }

  
  if (G_UNLIKELY (!succeed))
    g_propagate_error (error, err);

  return succeed;
}




static void       xfce_mime_helper_database_finalize    (GObject                *object);
static XfceMimeHelper *xfce_mime_helper_database_lookup      (XfceMimeHelperDatabase      *database, XfceMimeHelperCategory       category, const gchar            *id);




struct _XfceMimeHelperDatabaseClass {
  GObjectClass __parent__;
};

struct _XfceMimeHelperDatabase {
  GObject     __parent__;
  GHashTable *helpers;
};



G_DEFINE_TYPE (XfceMimeHelperDatabase, xfce_mime_helper_database, G_TYPE_OBJECT)



static void xfce_mime_helper_database_class_init (XfceMimeHelperDatabaseClass *klass)
{
  GObjectClass *gobject_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = xfce_mime_helper_database_finalize;
}



static void xfce_mime_helper_database_init (XfceMimeHelperDatabase *database)
{
  database->helpers = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
}



static void xfce_mime_helper_database_finalize (GObject *object)
{
  XfceMimeHelperDatabase *database = XFCE_MIME_HELPER_DATABASE (object);

  g_hash_table_destroy (database->helpers);

  (*G_OBJECT_CLASS (xfce_mime_helper_database_parent_class)->finalize) (object);
}



static XfceMimeHelper* xfce_mime_helper_database_lookup (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category, const gchar       *id)


{
  XfceMimeHelper *helper;
  XfceRc    *rc;
  gchar     *file;
  gchar     *spec;

  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), NULL);
  g_return_val_if_fail (id != NULL, NULL);

  
  spec = g_strconcat ("xfce4/helpers/", id, ".desktop", NULL);

  
  helper = g_hash_table_lookup (database->helpers, spec);

  
  if (G_LIKELY (helper == NULL))
    {
      xfce_resource_push_path (XFCE_RESOURCE_DATA, DATADIR);
      file = xfce_resource_lookup (XFCE_RESOURCE_DATA, spec);
      xfce_resource_pop_path (XFCE_RESOURCE_DATA);

      if (G_LIKELY (file != NULL))
        {
          rc = xfce_rc_simple_open (file, TRUE);
          if (G_LIKELY (rc != NULL))
            {
              helper = xfce_mime_helper_new (id, rc);
              xfce_rc_close (rc);
            }
          g_free (file);
        }

      
      if (G_LIKELY (helper != NULL))
        {
          g_hash_table_insert (database->helpers, spec, helper);
          spec = NULL;
        }
    }

  if (G_LIKELY (helper != NULL))
    {
      if (xfce_mime_helper_get_category (helper) == category)
        g_object_ref (G_OBJECT (helper));
      else helper = NULL;
    }

  g_free (spec);

  return helper;
}




XfceMimeHelperDatabase* xfce_mime_helper_database_get (void)
{
  static XfceMimeHelperDatabase *database = NULL;

  if (G_LIKELY (database == NULL))
    {
      database = g_object_new (XFCE_MIME_TYPE_HELPER_DATABASE, NULL);
      g_object_add_weak_pointer (G_OBJECT (database), (gpointer) &database);
    }
  else {
      g_object_ref (G_OBJECT (database));
    }

  return database;
}




XfceMimeHelper* xfce_mime_helper_database_get_default (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category)

{
  const gchar *id;
  XfceMimeHelper   *helper = NULL;
  XfceRc      *rc;
  gchar       *key;

  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), NULL);
  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, NULL);

  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "xfce4/helpers.rc", TRUE);
  if (G_LIKELY (rc != NULL))
    {
      key = xfce_mime_helper_category_to_string (category);
      id = xfce_rc_read_entry_untranslated (rc, key, NULL);
      if (G_LIKELY (id != NULL))
        helper = xfce_mime_helper_database_lookup (database, category, id);

      
      if (helper == NULL && g_strcmp0 (id, "Thunar") == 0)
        helper = xfce_mime_helper_database_lookup (database, category, "thunar");

      xfce_rc_close (rc);
      g_free (key);
    }

  return helper;
}



static XfceRc* mimeapps_open (gboolean readonly)
{
  XfceRc *rc;

  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "mimeapps.list", readonly);
  if (G_UNLIKELY (rc == NULL))
    {
      
      rc = xfce_rc_config_open (XFCE_RESOURCE_DATA, "applications/mimeapps.list", readonly);
    }

  return rc;
}




gboolean xfce_mime_helper_database_set_default (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category, XfceMimeHelper         *helper, GError           **error)



{
  XfceRc       *rc, *desktop_file;
  gchar        *key;
  const gchar  *filename;
  gchar       **mimetypes;
  guint         i;
  gchar        *path;
  gchar        *entry;

  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, FALSE);
  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), FALSE);
  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
  g_return_val_if_fail (XFCE_MIME_IS_HELPER (helper), FALSE);

  
  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "xfce4/helpers.rc", FALSE);
  if (G_UNLIKELY (rc == NULL))
    {
      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Failed to open %s for writing"), "helpers.rc");
      return FALSE;
    }

  
  key = xfce_mime_helper_category_to_string (category);
  xfce_rc_write_entry (rc, key, xfce_mime_helper_get_id (helper));
  g_free (key);

  
  key = g_strconcat (xfce_mime_helper_category_to_string (category), "Dismissed", NULL);
  xfce_rc_delete_entry (rc, key, FALSE);
  xfce_rc_close (rc);
  g_free (key);

  
  switch (category)
    {
      case XFCE_MIME_HELPER_WEBBROWSER:
        filename = "xfce4-web-browser.desktop";
        break;

      case XFCE_MIME_HELPER_MAILREADER:
        filename = "xfce4-mail-reader.desktop";
        break;

      case XFCE_MIME_HELPER_FILEMANAGER:
        filename = "xfce4-file-manager.desktop";
        break;

      default:
        
        return TRUE;
    }

  
  rc = mimeapps_open (FALSE);
  if (G_UNLIKELY (rc == NULL))
    {
      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Failed to open %s for writing"), "mimeapps.list");
      return FALSE;
    }

  
  path = g_build_filename ("applications", filename, NULL);
  desktop_file = xfce_rc_config_open (XFCE_RESOURCE_DATA, path, TRUE);
  g_free (path);

  if (G_UNLIKELY (desktop_file != NULL))
    {
      xfce_rc_set_group (desktop_file, "Desktop Entry");
      mimetypes = xfce_rc_read_list_entry (desktop_file, "X-XFCE-MimeType", ";");
      if (mimetypes != NULL)
        {

          GDesktopAppInfo *info = g_desktop_app_info_new (filename);


          xfce_rc_set_group (rc, "Default Applications");

          for (i = 0; mimetypes[i] != NULL; i++)
            if (!xfce_str_is_empty (mimetypes[i]))
              xfce_rc_write_entry (rc, mimetypes[i], filename);

          xfce_rc_set_group (rc, "Added Associations");

          for (i = 0; mimetypes[i] != NULL; i++)
            if (!xfce_str_is_empty (mimetypes[i]))
              {
                entry = g_strconcat (filename, ";", NULL);
                xfce_rc_write_entry (rc, mimetypes[i], entry);
                g_free (entry);


                if (info != NULL)
                  {
                    g_app_info_set_as_default_for_type (G_APP_INFO (info), mimetypes[i], NULL);

                  }

              }
          g_strfreev (mimetypes);

          if (info != NULL)
            {
              g_object_unref (info);
            }

        }

      xfce_rc_close (desktop_file);
    }

  clear_bad_entries (rc);

  xfce_rc_close (rc);

  return TRUE;
}




gboolean xfce_mime_helper_database_clear_default (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category, GError           **error)


{
  XfceRc       *rc, *desktop_file;
  gchar        *key;
  const gchar  *filename;
  gchar       **mimetypes;
  guint         i;
  gchar        *path;

  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, FALSE);
  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), FALSE);
  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

  
  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "xfce4/helpers.rc", FALSE);
  if (G_UNLIKELY (rc == NULL))
    {
      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Failed to open %s for writing"), "helpers.rc");
      return FALSE;
    }

  
  key = xfce_mime_helper_category_to_string (category);
  xfce_rc_delete_entry (rc, key, FALSE);
  g_free (key);

  
  key = g_strconcat (xfce_mime_helper_category_to_string (category), "Dismissed", NULL);
  xfce_rc_delete_entry (rc, key, FALSE);
  xfce_rc_close (rc);
  g_free (key);

  
  switch (category)
    {
      case XFCE_MIME_HELPER_WEBBROWSER:
        filename = "xfce4-web-browser.desktop";
        break;

      case XFCE_MIME_HELPER_MAILREADER:
        filename = "xfce4-mail-reader.desktop";
        break;

      case XFCE_MIME_HELPER_FILEMANAGER:
        filename = "xfce4-file-manager.desktop";
        break;

      default:
        
        return TRUE;
    }

  
  rc = mimeapps_open (FALSE);
  if (G_UNLIKELY (rc == NULL))
    {
      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Failed to open %s for writing"), "mimeapps.list");
      return FALSE;
    }

  
  path = g_build_filename ("applications", filename, NULL);
  desktop_file = xfce_rc_config_open (XFCE_RESOURCE_DATA, path, TRUE);
  g_free (path);

  if (G_UNLIKELY (desktop_file != NULL))
    {
      xfce_rc_set_group (desktop_file, "Desktop Entry");
      mimetypes = xfce_rc_read_list_entry (desktop_file, "X-XFCE-MimeType", ";");
      if (mimetypes != NULL)
        {
          xfce_rc_set_group (rc, "Default Applications");

          for (i = 0; mimetypes[i] != NULL; i++)
            if (!xfce_str_is_empty (mimetypes[i]))
              xfce_rc_delete_entry (rc, mimetypes[i], FALSE);

          xfce_rc_set_group (rc, "Added Associations");

          for (i = 0; mimetypes[i] != NULL; i++)
            if (!xfce_str_is_empty (mimetypes[i]))
              xfce_rc_delete_entry (rc, mimetypes[i], FALSE);

          g_strfreev (mimetypes);
        }

      xfce_rc_close (desktop_file);
    }

  clear_bad_entries (rc);

  xfce_rc_close (rc);

  return TRUE;
}



static void clear_bad_entry (XfceRc *rc, gchar  *key, gchar  *filename)


{
  gchar **values;

  if (xfce_rc_has_entry (rc, key))
    {
      values = xfce_rc_read_list_entry (rc, key, ";");
      if (values != NULL)
        {
          GSList *list = NULL, *item = NULL;
          gint i;

          for (i = 0; values[i] != NULL; i++)
            {
              if (!xfce_str_is_empty(values[i]) && g_strcmp0(values[i], filename) != 0)
                {
                  list = g_slist_append (list, g_strdup(values[i]));
                }
            }
          g_strfreev(values);

          if (list == NULL)
            {
              xfce_rc_delete_entry (rc, key, FALSE);
            }
          else {
              gchar   *value;
              GString *string = g_string_new (NULL);
              for (item = list; item != NULL; item = g_slist_next (item))
                {
                  g_string_append_printf (string, "%s;", (gchar *)item->data);
                }
              value = g_string_free (string, FALSE);
              xfce_rc_write_entry (rc, key, value);
              g_slist_free_full (list, g_free);
              g_free (value);
            }
        }
    }
}



static void clear_bad_entries (XfceRc *rc)
{
  xfce_rc_set_group (rc, "Added Associations");
  clear_bad_entry (rc, "x-scheme-handler/file", "xfce4-file-manager.desktop"); 
}



static gint helper_compare (gconstpointer a, gconstpointer b)

{
  return g_utf8_collate (xfce_mime_helper_get_name (a), xfce_mime_helper_get_name (b));
}




GList* xfce_mime_helper_database_get_all (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category)

{
  XfceMimeHelper *helper;
  GList     *helpers = NULL;
  gchar    **specs;
  gchar     *id;
  gchar     *s;
  guint      n;

  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), NULL);
  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, NULL);

  xfce_resource_push_path (XFCE_RESOURCE_DATA, DATADIR);
  specs = xfce_resource_match (XFCE_RESOURCE_DATA, "xfce4/helpers/*.desktop", TRUE);
  xfce_resource_pop_path (XFCE_RESOURCE_DATA);

  for (n = 0; specs[n] != NULL; ++n)
    {
      s = strrchr (specs[n], '.');
      if (G_LIKELY (s != NULL))
        *s = '\0';

      id = strrchr (specs[n], '/');
      id = (id != NULL) ? id + 1 : specs[n];

      helper = xfce_mime_helper_database_lookup (database, category, id);
      if (G_LIKELY (helper != NULL))
        helpers = g_list_insert_sorted (helpers, helper, helper_compare);

      g_free (specs[n]);
    }
  g_free (specs);

  return helpers;
}




XfceMimeHelper* xfce_mime_helper_database_get_custom (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category)

{
  gchar *string;
  gchar  id[256];

  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), NULL);
  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, NULL);

  
  string = xfce_mime_helper_category_to_string (category);
  g_snprintf (id, sizeof (id), "custom-%s", string);
  g_free (string);

  return xfce_mime_helper_database_lookup (database, category, id);
}




void xfce_mime_helper_database_set_custom (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category, const gchar       *command)


{
  XfceRc *rc;
  gchar **argv;
  gchar  *category_string;
  gchar  *name;
  gchar  *cmdline;
  gchar  *file;
  gchar   spec[256];

  g_return_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database));
  g_return_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES);
  g_return_if_fail (!xfce_str_is_empty (command));

  
  category_string = xfce_mime_helper_category_to_string (category);
  g_snprintf (spec, sizeof (spec), "xfce4/helpers/custom-%s.desktop", category_string);

  
  file = xfce_resource_save_location (XFCE_RESOURCE_DATA, spec, TRUE);

  
  rc = xfce_rc_simple_open (file, FALSE);
  if (G_LIKELY (rc != NULL))
    {
      xfce_rc_set_group (rc, "Desktop Entry");
      xfce_rc_write_bool_entry (rc, "NoDisplay", TRUE);
      xfce_rc_write_entry (rc, "Version", "1.0");
      xfce_rc_write_entry (rc, "Encoding", "UTF-8");
      xfce_rc_write_entry (rc, "Type", "X-XFCE-Helper");
      xfce_rc_write_entry (rc, "X-XFCE-Category", category_string);

      
      cmdline = (strstr (command, "%s") != NULL) ? g_strdup (command) : g_strconcat (command, " \"%s\"", NULL);

      
      xfce_rc_write_entry (rc, "X-XFCE-CommandsWithParameter", cmdline);

      
      if (g_shell_parse_argv (cmdline, NULL, &argv, NULL))
        {
          
          name = g_path_get_basename (*argv);
          xfce_rc_write_entry (rc, "Icon", name);
          xfce_rc_write_entry (rc, "Name", name);
          g_free (name);

          if (strstr (command, "%s") == NULL) {
            
            xfce_rc_write_entry (rc, "X-XFCE-Commands", command);
          } else {
            
            xfce_rc_write_entry (rc, "X-XFCE-Commands", *argv);
          }

          
          g_strfreev (argv);
        }
      else {
          xfce_rc_write_entry (rc, "Name", command);
          xfce_rc_write_entry (rc, "X-XFCE-Commands", command);
        }

      
      xfce_rc_close (rc);

      
      g_free (cmdline);
    }

  
  g_hash_table_remove (database->helpers, spec);

  
  g_free (category_string);
  g_free (file);
}


gboolean xfce_mime_helper_database_get_dismissed (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category)
{
  XfceRc      *rc;
  gchar       *key;
  gboolean     dismissed = FALSE;

  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), FALSE);
  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, FALSE);

  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "xfce4/helpers.rc", TRUE);
  if (G_LIKELY (rc != NULL))
    {
      key = g_strconcat (xfce_mime_helper_category_to_string (category), "Dismissed", NULL);
      dismissed = xfce_rc_read_bool_entry (rc, key, FALSE);
      xfce_rc_close (rc);
      g_free (key);
    }

  return dismissed;
}


gboolean xfce_mime_helper_database_set_dismissed (XfceMimeHelperDatabase *database, XfceMimeHelperCategory  category, gboolean           dismissed)


{
  XfceRc       *rc;
  gchar        *key;

  g_return_val_if_fail (category < XFCE_MIME_HELPER_N_CATEGORIES, FALSE);
  g_return_val_if_fail (XFCE_MIME_IS_HELPER_DATABASE (database), FALSE);

  
  rc = xfce_rc_config_open (XFCE_RESOURCE_CONFIG, "xfce4/helpers.rc", FALSE);
  if (G_UNLIKELY (rc == NULL))
    {
      return FALSE;
    }

  
  key = g_strconcat (xfce_mime_helper_category_to_string (category), "Dismissed", NULL);
  xfce_rc_write_bool_entry (rc, key, dismissed);
  xfce_rc_close (rc);
  g_free (key);

  return TRUE;
}
