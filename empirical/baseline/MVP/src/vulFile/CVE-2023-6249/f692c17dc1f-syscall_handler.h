














extern const _k_syscall_handler_t _k_syscall_table[K_SYSCALL_LIMIT];

enum _obj_init_check {
	_OBJ_INIT_TRUE = 0, _OBJ_INIT_FALSE = -1, _OBJ_INIT_ANY = 1 };




static inline bool k_is_in_user_syscall(void)
{
	
	return !k_is_in_isr() && _current->syscall_frame != NULL;
}


int k_object_validate(struct k_object *ko, enum k_objects otype, enum _obj_init_check init);


void k_object_dump_error(int retval, const void *obj, struct k_object *ko, enum k_objects otype);


struct k_object *k_object_find(const void *obj);

typedef void (*_wordlist_cb_func_t)(struct k_object *ko, void *context);


void k_object_wordlist_foreach(_wordlist_cb_func_t func, void *context);


void k_thread_perms_inherit(struct k_thread *parent, struct k_thread *child);


void k_thread_perms_set(struct k_object *ko, struct k_thread *thread);


void k_thread_perms_clear(struct k_object *ko, struct k_thread *thread);


void k_thread_perms_all_clear(struct k_thread *thread);


void k_object_uninit(const void *obj);


void k_object_recycle(const void *obj);


static inline size_t k_usermode_string_nlen(const char *src, size_t maxlen, int *err)
{
	return arch_user_string_nlen(src, maxlen, err);
}


void *k_usermode_alloc_from_copy(const void *src, size_t size);


int k_usermode_from_copy(void *dst, const void *src, size_t size);


int k_usermode_to_copy(void *dst, const void *src, size_t size);


char *k_usermode_string_alloc_copy(const char *src, size_t maxlen);


int k_usermode_string_copy(char *dst, const char *src, size_t maxlen);



















































static inline int k_object_validation_check(struct k_object *ko, const void *obj, enum k_objects otype, enum _obj_init_check init)


{
	int ret;

	ret = k_object_validate(ko, otype, init);


	if (ret != 0) {
		k_object_dump_error(ret, obj, ko, otype);
	}

	ARG_UNUSED(obj);


	return ret;
}











































