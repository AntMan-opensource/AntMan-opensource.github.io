












struct lzw_read_ctx {
	const uint8_t *data;    
	uint64_t data_len;      
	uint64_t data_sb_next;  

	const uint8_t *sb_data; 
	uint64_t sb_bit;        
	uint64_t sb_bit_count;  
};


struct lzw_dictionary_entry {
	uint8_t last_value;      
	uint8_t first_value;     
	uint16_t previous_entry; 
};


struct lzw_ctx {
	
	struct lzw_read_ctx input;

	uint32_t previous_code;       
	uint32_t previous_code_first; 

	uint32_t initial_code_size;     
	uint32_t current_code_size;     
	uint32_t current_code_size_max; 

	uint32_t clear_code; 
	uint32_t eoi_code;   

	uint32_t current_entry; 

	
	uint8_t stack_base[1 << LZW_CODE_MAX];

	
	struct lzw_dictionary_entry table[1 << LZW_CODE_MAX];
};



lzw_result lzw_context_create(struct lzw_ctx **ctx)
{
	struct lzw_ctx *c = malloc(sizeof(*c));
	if (c == NULL) {
		return LZW_NO_MEM;
	}

	*ctx = c;
	return LZW_OK;
}



void lzw_context_destroy(struct lzw_ctx *ctx)
{
	free(ctx);
}



static lzw_result lzw__block_advance(struct lzw_read_ctx *ctx)
{
	uint64_t block_size;
	uint64_t next_block_pos = ctx->data_sb_next;
	const uint8_t *data_next = ctx->data + next_block_pos;

	if (next_block_pos >= ctx->data_len) {
		return LZW_NO_DATA;
	}

	block_size = *data_next;

	if ((next_block_pos + block_size) >= ctx->data_len) {
		return LZW_NO_DATA;
	}

	ctx->sb_bit = 0;
	ctx->sb_bit_count = block_size * 8;

	if (block_size == 0) {
		ctx->data_sb_next += 1;
		return LZW_OK_EOD;
	}

	ctx->sb_data = data_next + 1;
	ctx->data_sb_next += block_size + 1;

	return LZW_OK;
}



static inline lzw_result lzw__next_code( struct lzw_read_ctx *ctx, uint8_t code_size, uint32_t *code_out)


{
	uint32_t code = 0;
	uint8_t current_bit = ctx->sb_bit & 0x7;
	uint8_t byte_advance = (current_bit + code_size) >> 3;

	assert(byte_advance <= 2);

	if (ctx->sb_bit + code_size <= ctx->sb_bit_count) {
		
		const uint8_t *data = ctx->sb_data + (ctx->sb_bit >> 3);
		switch (byte_advance) {
			case 2: code |= data[2] << 16; 
			case 1: code |= data[1] <<  8; 
			case 0: code |= data[0] <<  0;
		}
		ctx->sb_bit += code_size;
	} else {
		
		uint8_t byte = 0;
		uint8_t bits_remaining_0 = (code_size < (8 - current_bit)) ? code_size : (8 - current_bit);
		uint8_t bits_remaining_1 = code_size - bits_remaining_0;
		uint8_t bits_used[3] = {
			[0] = bits_remaining_0, [1] = bits_remaining_1 < 8 ? bits_remaining_1 : 8, [2] = bits_remaining_1 - 8, };



		while (true) {
			const uint8_t *data = ctx->sb_data;
			lzw_result res;

			
			while (byte <= byte_advance && ctx->sb_bit < ctx->sb_bit_count) {
				code |= data[ctx->sb_bit >> 3] << (byte << 3);
				ctx->sb_bit += bits_used[byte];
				byte++;
			}

			
			if (byte > byte_advance) {
				break;
			}

			
			res = lzw__block_advance(ctx);
			if (res != LZW_OK) {
				return res;
			}
		}
	}

	*code_out = (code >> current_bit) & ((1 << code_size) - 1);
	return LZW_OK;
}



static lzw_result lzw__clear_codes( struct lzw_ctx *ctx, const uint8_t ** const stack_pos_out)

{
	uint32_t code;
	uint8_t *stack_pos;

	
	ctx->current_code_size = ctx->initial_code_size + 1;
	ctx->current_code_size_max = (1 << ctx->current_code_size) - 1;;
	ctx->current_entry = (1 << ctx->initial_code_size) + 2;

	
	do {
		lzw_result res = lzw__next_code(&ctx->input, ctx->current_code_size, &code);
		if (res != LZW_OK) {
			return res;
		}
	} while (code == ctx->clear_code);

	
	if (code > ctx->clear_code) {
		return LZW_BAD_ICODE;
	}

	
	ctx->previous_code = code;
	ctx->previous_code_first = code;

	
	stack_pos = ctx->stack_base;
	*stack_pos++ = code;

	*stack_pos_out = stack_pos;
	return LZW_OK;
}



lzw_result lzw_decode_init( struct lzw_ctx *ctx, const uint8_t *compressed_data, uint64_t compressed_data_len, uint64_t compressed_data_pos, uint8_t code_size, const uint8_t ** const stack_base_out, const uint8_t ** const stack_pos_out)






{
	struct lzw_dictionary_entry *table = ctx->table;

	
	ctx->input.data = compressed_data;
	ctx->input.data_len = compressed_data_len;
	ctx->input.data_sb_next = compressed_data_pos;

	ctx->input.sb_bit = 0;
	ctx->input.sb_bit_count = 0;

	
	ctx->initial_code_size = code_size;

	ctx->clear_code = (1 << code_size) + 0;
	ctx->eoi_code   = (1 << code_size) + 1;

	
	for (uint32_t i = 0; i < ctx->clear_code; ++i) {
		table[i].first_value = i;
		table[i].last_value  = i;
	}

	*stack_base_out = ctx->stack_base;
	return lzw__clear_codes(ctx, stack_pos_out);
}



lzw_result lzw_decode(struct lzw_ctx *ctx, const uint8_t ** const stack_pos_out)
{
	lzw_result res;
	uint32_t code_new;
	uint32_t code_out;
	uint8_t last_value;
	uint8_t *stack_pos = ctx->stack_base;
	uint32_t clear_code = ctx->clear_code;
	uint32_t current_entry = ctx->current_entry;
	struct lzw_dictionary_entry * const table = ctx->table;

	
	res = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);
	if (res != LZW_OK) {
		return res;
	}

	
	if (code_new == clear_code) {
		
		return lzw__clear_codes(ctx, stack_pos_out);

	} else if (code_new == ctx->eoi_code) {
		
		return LZW_EOI_CODE;

	} else if (code_new > current_entry) {
		
		return LZW_BAD_CODE;

	} else if (code_new < current_entry) {
		
		code_out = code_new;
		last_value = table[code_new].first_value;
	} else {
		
		*stack_pos++ = ctx->previous_code_first;
		code_out = ctx->previous_code;
		last_value = ctx->previous_code_first;
	}

	
	if (current_entry < (1 << LZW_CODE_MAX)) {
		struct lzw_dictionary_entry *entry = table + current_entry;
		entry->last_value     = last_value;
		entry->first_value    = ctx->previous_code_first;
		entry->previous_entry = ctx->previous_code;
		ctx->current_entry++;
	}

	
	if (current_entry == ctx->current_code_size_max) {
		if (ctx->current_code_size < LZW_CODE_MAX) {
			ctx->current_code_size++;
			ctx->current_code_size_max = (1 << ctx->current_code_size) - 1;
		}
	}

	
	ctx->previous_code_first = table[code_new].first_value;
	ctx->previous_code = code_new;

	
	while (code_out > clear_code) {
		struct lzw_dictionary_entry *entry = table + code_out;
		*stack_pos++ = entry->last_value;
		code_out = entry->previous_entry;
	}
	*stack_pos++ = table[code_out].last_value;

	*stack_pos_out = stack_pos;
	return LZW_OK;
}
