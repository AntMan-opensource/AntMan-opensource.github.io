




















void	*wsemul_sun_cnattach(const struct wsscreen_descr *, void *, int, int, uint32_t);
void	*wsemul_sun_attach(int, const struct wsscreen_descr *, void *, int, int, void *, uint32_t);
u_int	wsemul_sun_output(void *, const u_char *, u_int, int);
int	wsemul_sun_translate(void *, kbd_t, keysym_t, const u_char **);
void	wsemul_sun_detach(void *, u_int *, u_int *);
void	wsemul_sun_resetop(void *, enum wsemul_resetops);

const struct wsemul_ops wsemul_sun_ops = {
	"sun", wsemul_sun_cnattach, wsemul_sun_attach, wsemul_sun_output, wsemul_sun_translate, wsemul_sun_detach, wsemul_sun_resetop };
















struct wsemul_sun_emuldata {
	const struct wsdisplay_emulops *emulops;
	struct wsemul_abortstate abortstate;
	void *emulcookie;
	void *cbcookie;
	int scrcapabilities;
	u_int nrows, ncols, crow, ccol;
	uint32_t defattr;		

	u_int state;			
	u_int flags;
	u_int args[SUN_EMUL_NARGS];	
	int nargs;			

	u_int scrolldist;		
	uint32_t curattr, bkgdattr;	
	uint32_t kernattr;		
	int attrflags, fgcol, bgcol;	

	struct wsemul_inputstate instate;	
	struct wsemul_inputstate kstate;	


	u_char translatebuf[4];

	u_char translatebuf[1];



	int console;

};

void	wsemul_sun_init(struct wsemul_sun_emuldata *, const struct wsscreen_descr *, void *, int, int, uint32_t);
int	wsemul_sun_jump_scroll(struct wsemul_sun_emuldata *, const u_char *, u_int, int);
void	wsemul_sun_reset(struct wsemul_sun_emuldata *);
int	wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, struct wsemul_inputstate *, int);
int	wsemul_sun_output_normal(struct wsemul_sun_emuldata *, struct wsemul_inputstate *, int);
int	wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, struct wsemul_inputstate *);
int	wsemul_sun_output_control(struct wsemul_sun_emuldata *, struct wsemul_inputstate *);
int	wsemul_sun_output_percent(struct wsemul_sun_emuldata *, struct wsemul_inputstate *);
int	wsemul_sun_control(struct wsemul_sun_emuldata *, struct wsemul_inputstate *);
int	wsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int, uint32_t *, uint32_t *);
int	wsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);

struct wsemul_sun_emuldata wsemul_sun_console_emuldata;







void wsemul_sun_init(struct wsemul_sun_emuldata *edp, const struct wsscreen_descr *type, void *cookie, int ccol, int crow, uint32_t defattr)


{
	edp->emulops = type->textops;
	edp->emulcookie = cookie;
	edp->scrcapabilities = type->capabilities;
	edp->nrows = type->nrows;
	edp->ncols = type->ncols;
	edp->crow = crow;
	edp->ccol = ccol;
	edp->defattr = defattr;
	wsemul_reset_abortstate(&edp->abortstate);
}

void wsemul_sun_reset(struct wsemul_sun_emuldata *edp)
{
	edp->flags = 0;
	edp->state = SUN_EMUL_STATE_NORMAL;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_BLACK;
	edp->bgcol = WSCOL_WHITE;
	edp->scrolldist = 1;
	edp->instate.inchar = 0;
	edp->instate.lbound = 0;
	edp->instate.mbleft = 0;
	edp->kstate.inchar = 0;
	edp->kstate.lbound = 0;
	edp->kstate.mbleft = 0;
}

void * wsemul_sun_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol, int crow, uint32_t defattr)

{
	struct wsemul_sun_emuldata *edp;
	int res;

	edp = &wsemul_sun_console_emuldata;
	wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);













	if (type->capabilities & WSSCREEN_WSCOLORS)
		res = (*edp->emulops->pack_attr)(cookie, WS_KERNEL_FG, WS_KERNEL_BG, WS_KERNEL_COLATTR | WSATTR_WSCOLORS, &edp->kernattr);


	else res = (*edp->emulops->pack_attr)(cookie, 0, 0, WS_KERNEL_MONOATTR, &edp->kernattr);


	if (res)
		edp->kernattr = defattr;

	edp->cbcookie = NULL;


	edp->console = 1;


	wsemul_sun_reset(edp);
	return (edp);
}

void * wsemul_sun_attach(int console, const struct wsscreen_descr *type, void *cookie, int ccol, int crow, void *cbcookie, uint32_t defattr)

{
	struct wsemul_sun_emuldata *edp;

	if (console) {
		edp = &wsemul_sun_console_emuldata;

		KASSERT(edp->console == 1);

	} else {
		edp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);
		if (edp == NULL)
			return (NULL);
		wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);


		edp->console = 0;

	}

	edp->cbcookie = cbcookie;

	wsemul_sun_reset(edp);
	return (edp);
}

int wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate, int kernel)

{
	u_int n;
	int rc = 0;

	switch (instate->inchar) {
	case ASCII_NUL:
	default:
		
		break;

	case ASCII_BEL:		
		wsdisplay_emulbell(edp->cbcookie);
		break;

	case ASCII_BS:		
		if (edp->ccol > 0)
			edp->ccol--;
		break;

	case ASCII_CR:		
		edp->ccol = 0;
		break;

	case ASCII_HT:		
		n = min(8 - (edp->ccol & 7), COLS_LEFT);
		if (n != 0) {
			WSEMULOP(rc, edp, &edp->abortstate, erasecols, (edp->emulcookie, edp->crow, edp->ccol, n, kernel ? edp->kernattr : edp->bkgdattr));

			if (rc != 0)
				break;
			edp->ccol += n;
		}
		break;

	case ASCII_FF:		
		WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, 0, edp->nrows, edp->bkgdattr));
		if (rc != 0)
			break;
		edp->ccol = edp->crow = 0;
		break;

	case ASCII_VT:		
		if (edp->crow > 0)
			edp->crow--;
		break;

	case ASCII_ESC:		
		if (kernel) {
			printf("wsemul_sun_output_lowchars: ESC in kernel " "output ignored\n");
			break;	
		}

		edp->state = SUN_EMUL_STATE_HAVEESC;
		break;

	case ASCII_LF:		
		
		if (ROWS_LEFT > 0)
			edp->crow++;
		else {
			rc = wsemul_sun_scrollup(edp, edp->scrolldist);
			if (rc != 0)
				break;
		}
		break;
	}

	return rc;
}

int wsemul_sun_output_normal(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate, int kernel)

{
	int rc;
	u_int outchar;

	(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &outchar);
	WSEMULOP(rc, edp, &edp->abortstate, putchar, (edp->emulcookie, edp->crow, edp->ccol, outchar, kernel ? edp->kernattr : edp->curattr));

	if (rc != 0)
		return rc;

	if (++edp->ccol >= edp->ncols) {
		
		if (ROWS_LEFT > 0)
			edp->crow++;
		else {
			rc = wsemul_sun_scrollup(edp, edp->scrolldist);
			if (rc != 0) {
				
				edp->ccol--;

				return rc;
			}
		}
		edp->ccol = 0;
	}

	return 0;
}

int wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate)

{
	switch (instate->inchar) {
	case '[':		
		edp->nargs = 0;
		bzero(edp->args, sizeof (edp->args));
		edp->state = SUN_EMUL_STATE_CONTROL;
		break;

	case '%':
		edp->state = SUN_EMUL_STATE_PERCENT;
		break;

	default:

		printf("ESC %x unknown\n", instate->inchar);

		edp->state = SUN_EMUL_STATE_NORMAL;	
		break;
	}
	return 0;
}

int wsemul_sun_control(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate)

{
	u_int n, src, dst;
	int flags, fgcol, bgcol;
	uint32_t attr, bkgdattr;
	int rc = 0;

	switch (instate->inchar) {
	case '@':		
		n = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);
		src = edp->ccol;
		dst = edp->ccol + n;
		if (dst < edp->ncols) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols, (edp->emulcookie, edp->crow, src, dst, edp->ncols - dst));

			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols, (edp->emulcookie, edp->crow, src, n, edp->bkgdattr));
		break;

	case 'A':		
		edp->crow -= min(NORMALIZE(ARG(0,1)), edp->crow);
		break;

	case 'E':		
		edp->ccol = 0;
		
	case 'B':		
		edp->crow += min(NORMALIZE(ARG(0,1)), ROWS_LEFT);
		break;

	case 'C':		
		edp->ccol += min(NORMALIZE(ARG(0,1)), COLS_LEFT);
		break;

	case 'D':		
		edp->ccol -= min(NORMALIZE(ARG(0,1)), edp->ccol);
		break;

	case 'f':		
	case 'H':		
		edp->crow = min(NORMALIZE(ARG(0,2)), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE(ARG(1,2)), edp->ncols) - 1;
		break;

	case 'J':		
		if (ROWS_LEFT > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, edp->crow + 1, ROWS_LEFT, edp->bkgdattr));

			if (rc != 0)
				break;
		}
		
	case 'K':		
		WSEMULOP(rc, edp, &edp->abortstate, erasecols, (edp->emulcookie, edp->crow, edp->ccol, COLS_LEFT + 1, edp->bkgdattr));

		break;

	case 'L':		
		n = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);
		src = edp->crow;
		dst = edp->crow + n;
		if (dst < edp->nrows) {
			WSEMULOP(rc, edp, &edp->abortstate, copyrows, (edp->emulcookie, src, dst, edp->nrows - dst));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, src, n, edp->bkgdattr));
		break;

	case 'M':		
		n = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);
		src = edp->crow + n;
		dst = edp->crow;
		if (src < edp->nrows) {
			WSEMULOP(rc, edp, &edp->abortstate, copyrows, (edp->emulcookie, src, dst, edp->nrows - src));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, dst + edp->nrows - src, n, edp->bkgdattr));

		break;

	case 'P':		
		n = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);
		src = edp->ccol + n;
		dst = edp->ccol;
		if (src < edp->ncols) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols, (edp->emulcookie, edp->crow, src, dst, edp->ncols - src));

			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols, (edp->emulcookie, edp->crow, edp->ncols - n, n, edp->bkgdattr));

		break;

	case 'm':		
		flags = edp->attrflags;
		fgcol = edp->fgcol;
		bgcol = edp->bgcol;

		for (n = 0; n < edp->nargs; n++) {
			switch (ARG(n,edp->nargs)) {
			
			case 0:
				if (n == edp->nargs - 1) {
					edp->bkgdattr = edp->curattr = edp->defattr;
					edp->attrflags = 0;
					edp->fgcol = WSCOL_BLACK;
					edp->bgcol = WSCOL_WHITE;
					return 0;
				}
				flags = 0;
				fgcol = WSCOL_BLACK;
				bgcol = WSCOL_WHITE;
				break;
			
			case 1:
				flags |= WSATTR_HILIT;
				break;
			
			case 4:
				flags |= WSATTR_UNDERLINE;
				break;
			
			case 7:
				flags |= WSATTR_REVERSE;
				break;
			
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
				fgcol = ARG(n,edp->nargs) - 30;
				break;
			
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
				bgcol = ARG(n,edp->nargs) - 40;
				break;
			}
		}
setattr:
		if (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr, &bkgdattr)) {

			printf("error allocating attr %d/%d/%x\n", fgcol, bgcol, flags);

		} else {
			edp->curattr = attr;
			edp->bkgdattr = bkgdattr;
			edp->attrflags = flags;
			edp->fgcol = fgcol;
			edp->bgcol = bgcol;
		}
		break;

	case 'p':		
		flags = 0;
		fgcol = WSCOL_BLACK;
		bgcol = WSCOL_WHITE;
		goto setattr;

	case 'q':		
		flags = 0;
		fgcol = WSCOL_WHITE;
		bgcol = WSCOL_BLACK;
		goto setattr;

	case 'r':		
		edp->scrolldist = min(ARG(0,1), edp->nrows);
		break;

	case 's':		
		wsemul_sun_reset(edp);
		break;
	}

	return rc;
}

int wsemul_sun_output_control(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate)

{
	int oargs;
	int rc;

	switch (instate->inchar) {
	case '0': case '1': case '2': case '3': case '4': 
	case '5': case '6': case '7': case '8': case '9':
		
		if (edp->nargs > SUN_EMUL_NARGS - 1) {
			bcopy(edp->args + 1, edp->args, (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));
			edp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;
		}
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) + (instate->inchar - '0');
		break;

	case ';':		
		edp->nargs++;
		break;

	default:		
		oargs = edp->nargs++;
		if (edp->nargs > SUN_EMUL_NARGS)
			edp->nargs = SUN_EMUL_NARGS;
		rc = wsemul_sun_control(edp, instate);
		if (rc != 0) {
			
			edp->nargs = oargs;

			return rc;
		}
		edp->state = SUN_EMUL_STATE_NORMAL;
		break;
	}

	return 0;
}


int wsemul_sun_output_percent(struct wsemul_sun_emuldata *edp, struct wsemul_inputstate *instate)

{
	switch (instate->inchar) {
	case 'G':
		edp->flags |= SUN_EMUL_FLAGS_UTF8;
		edp->kstate.mbleft = edp->instate.mbleft = 0;
		break;
	case '@':
		edp->flags &= ~SUN_EMUL_FLAGS_UTF8;
		break;
	}
	edp->state = SUN_EMUL_STATE_NORMAL;
	return 0;
}


u_int wsemul_sun_output(void *cookie, const u_char *data, u_int count, int kernel)
{
	struct wsemul_sun_emuldata *edp = cookie;
	struct wsemul_inputstate *instate;
	u_int prev_count, processed = 0;

	int lines;

	int rc = 0;


	if (kernel && !edp->console)
		panic("wsemul_sun_output: kernel output, not console");


	instate = kernel ? &edp->kstate : &edp->instate;

	switch (edp->abortstate.state) {
	case ABORT_FAILED_CURSOR:
		
		data++, count--;
		processed++;
		wsemul_reset_abortstate(&edp->abortstate);
		break;
	case ABORT_OK:
		
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 0, edp->crow, edp->ccol);
		if (rc != 0)
			return 0;
		break;
	default:
		break;
	}

	for (;;) {

		switch (edp->abortstate.state) {
		case ABORT_FAILED_JUMP_SCROLL:
			
			lines = edp->abortstate.lines;
			break;
		case ABORT_OK:
			
			if ((edp->state == SUN_EMUL_STATE_NORMAL || kernel) && ROWS_LEFT == 0 && edp->scrolldist != 0)
				lines = wsemul_sun_jump_scroll(edp, data, count, kernel);
			else lines = 0;
			break;
		default:
			
			lines = 0;
			break;
		}

		if (lines > 1) {
			wsemul_resume_abort(&edp->abortstate);
			rc = wsemul_sun_scrollup(edp, lines);
			if (rc != 0) {
				wsemul_abort_jump_scroll(&edp->abortstate, lines);
				return processed;
			}
			wsemul_reset_abortstate(&edp->abortstate);
			edp->crow--;
		}


		wsemul_resume_abort(&edp->abortstate);

		prev_count = count;
		if (wsemul_getchar(&data, &count, instate,  (edp->state == SUN_EMUL_STATE_NORMAL && !kernel) ? edp->flags & SUN_EMUL_FLAGS_UTF8 : 0  0  ) != 0)






			break;

		if (instate->inchar < ' ') {
			rc = wsemul_sun_output_lowchars(edp, instate, kernel);
			if (rc != 0)
				break;
			processed += prev_count - count;
			continue;
		}

		if (kernel) {
			rc = wsemul_sun_output_normal(edp, instate, 1);
			if (rc != 0)
				break;
			processed += prev_count - count;
			continue;
		}

		switch (edp->state) {
		case SUN_EMUL_STATE_NORMAL:
			rc = wsemul_sun_output_normal(edp, instate, 0);
			break;
		case SUN_EMUL_STATE_HAVEESC:
			rc = wsemul_sun_output_haveesc(edp, instate);
			break;
		case SUN_EMUL_STATE_CONTROL:
			rc = wsemul_sun_output_control(edp, instate);
			break;

		case SUN_EMUL_STATE_PERCENT:
			rc = wsemul_sun_output_percent(edp, instate);
			break;

		default:

			panic("wsemul_sun: invalid state %d", edp->state);

			
			edp->state = SUN_EMUL_STATE_NORMAL;
			rc = wsemul_sun_output_normal(edp, instate, 0);

			break;
		}
		if (rc != 0)
			break;
		processed += prev_count - count;
	}

	if (rc != 0)
		wsemul_abort_other(&edp->abortstate);
	else {
		
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 1, edp->crow, edp->ccol);
		if (rc != 0) {
			
			wsemul_abort_cursor(&edp->abortstate);
			processed--;
		}
	}

	if (rc == 0)
		wsemul_reset_abortstate(&edp->abortstate);

	return processed;
}


int wsemul_sun_jump_scroll(struct wsemul_sun_emuldata *edp, const u_char *data, u_int count, int kernel)

{
	u_int pos, lines;
	struct wsemul_inputstate tmpstate;

	lines = 0;
	pos = edp->ccol;
	tmpstate = kernel ? edp->kstate : edp->instate;	

	while (wsemul_getchar(&data, &count, &tmpstate,  kernel ? 0 : edp->flags & SUN_EMUL_FLAGS_UTF8  0  ) == 0) {





		if (tmpstate.inchar == ASCII_FF || tmpstate.inchar == ASCII_VT || tmpstate.inchar == ASCII_ESC)

			break;

		switch (tmpstate.inchar) {
		case ASCII_BS:
			if (pos > 0)
				pos--;
			break;
		case ASCII_CR:
			pos = 0;
			break;
		case ASCII_HT:
			pos = (pos + 7) & ~7;
			if (pos >= edp->ncols)
				pos = edp->ncols - 1;
			break;
		case ASCII_LF:
			break;
		default:
			if (++pos >= edp->ncols) {
				pos = 0;
				tmpstate.inchar = ASCII_LF;
			}
			break;
		}
		if (tmpstate.inchar == ASCII_LF) {
			if (++lines >= edp->nrows - 1)
				break;
		}
	}

	return lines;
}



int wsemul_sun_selectattribute(struct wsemul_sun_emuldata *edp, int flags, int fgcol, int bgcol, uint32_t *attr, uint32_t *bkgdattr)

{
	int error;

	
	if (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {
		flags &= ~WSATTR_WSCOLORS;
	} else {
		flags |= WSATTR_WSCOLORS;
	}

	error = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol, flags & WSATTR_WSCOLORS, bkgdattr);
	if (error)
		return (error);

	if ((flags & WSATTR_HILIT) && !(edp->scrcapabilities & WSSCREEN_HILIT)) {
		flags &= ~WSATTR_HILIT;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_RED;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_UNDERLINE) && !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {
		flags &= ~WSATTR_UNDERLINE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_CYAN;
			flags &= ~WSATTR_UNDERLINE;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_BLINK) && !(edp->scrcapabilities & WSSCREEN_BLINK)) {
		flags &= ~WSATTR_BLINK;
	}
	if ((flags & WSATTR_REVERSE) && !(edp->scrcapabilities & WSSCREEN_REVERSE)) {
		flags &= ~WSATTR_REVERSE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			int help;
			help = bgcol;
			bgcol = fgcol;
			fgcol = help;
			flags |= WSATTR_WSCOLORS;
		}
	}
	error = (*edp->emulops->pack_attr)(edp->emulcookie, fgcol, bgcol, flags, attr);
	if (error)
		return (error);

	return (0);
}

static const u_char *sun_fkeys[] = {
	"\033[224z",	 "\033[225z", "\033[226z", "\033[227z", "\033[228z", "\033[229z", "\033[230z", "\033[231z", "\033[232z", "\033[233z", "\033[234z", "\033[235z", };












static const u_char *sun_lkeys[] = {
	"\033[207z",	 NULL, "\033[200z", NULL, "\033[193z", "\033[194z", "\033[195z", "\033[196z", "\033[197z", "\033[198z", "\033[199z", "\033[201z", };












int wsemul_sun_translate(void *cookie, kbd_t layout, keysym_t in, const u_char **out)

{
	struct wsemul_sun_emuldata *edp = cookie;

	if (KS_GROUP(in) == KS_GROUP_Ascii) {
		*out = edp->translatebuf;
		return (wsemul_utf8_translate(KS_VALUE(in), layout, edp->translatebuf, edp->flags & SUN_EMUL_FLAGS_UTF8));
	}

	if (KS_GROUP(in) == KS_GROUP_Keypad && (in & 0x80) == 0) {
		edp->translatebuf[0] = in & 0xff; 
		*out = edp->translatebuf;
		return (1);
	}

	if (in >= KS_f1 && in <= KS_f12) {
		*out = sun_fkeys[in - KS_f1];
		return (6);
	}
	if (in >= KS_F1 && in <= KS_F12) {
		*out = sun_fkeys[in - KS_F1];
		return (6);
	}
	if (in >= KS_KP_F1 && in <= KS_KP_F4) {
		*out = sun_fkeys[in - KS_KP_F1];
		return (6);
	}
	if (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {
		*out = sun_lkeys[in - KS_Help];
		return (6);
	}

	switch (in) {
	case KS_Home:
	case KS_KP_Home:
	case KS_KP_Begin:
		*out = "\033[214z";
		return (6);
	case KS_End:
	case KS_KP_End:
		*out = "\033[220z";
		return (6);
	case KS_Insert:
	case KS_KP_Insert:
		*out = "\033[247z";
		return (6);
	case KS_Prior:
	case KS_KP_Prior:
		*out = "\033[216z";
		return (6);
	case KS_Next:
	case KS_KP_Next:
		*out = "\033[222z";
		return (6);
	case KS_Up:
	case KS_KP_Up:
		*out = "\033[A";
		return (3);
	case KS_Down:
	case KS_KP_Down:
		*out = "\033[B";
		return (3);
	case KS_Left:
	case KS_KP_Left:
		*out = "\033[D";
		return (3);
	case KS_Right:
	case KS_KP_Right:
		*out = "\033[C";
		return (3);
	case KS_KP_Delete:
		*out = "\177";
		return (1);
	}
	return (0);
}

void wsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp)
{
	struct wsemul_sun_emuldata *edp = cookie;

	*crowp = edp->crow;
	*ccolp = edp->ccol;
	if (edp != &wsemul_sun_console_emuldata)
		free(edp, M_DEVBUF, sizeof *edp);
}

void wsemul_sun_resetop(void *cookie, enum wsemul_resetops op)
{
	struct wsemul_sun_emuldata *edp = cookie;

	switch (op) {
	case WSEMUL_RESET:
		wsemul_sun_reset(edp);
		break;
	case WSEMUL_CLEARSCREEN:
		(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows, edp->bkgdattr);
		edp->ccol = edp->crow = 0;
		(*edp->emulops->cursor)(edp->emulcookie, 1, 0, 0);
		break;
	case WSEMUL_CLEARCURSOR:
		(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow, edp->ccol);
		break;
	default:
		break;
	}
}

int wsemul_sun_scrollup(struct wsemul_sun_emuldata *edp, u_int lines)
{
	int rc;

	
	if (lines == 0) {
		WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, 0, 1, edp->bkgdattr));
		if (rc != 0)
			return rc;

		edp->crow = 0;
		return 0;
	}

	
	if (lines < edp->nrows) {
		WSEMULOP(rc, edp, &edp->abortstate, copyrows, (edp->emulcookie, lines, 0, edp->nrows - lines));
		if (rc != 0)
			return rc;
	}
	WSEMULOP(rc, edp, &edp->abortstate, eraserows, (edp->emulcookie, edp->nrows - lines, lines, edp->bkgdattr));
	if (rc != 0)
		return rc;

	edp->crow -= lines - 1;

	return 0;
}
