




























static const char *mnemonic_op6[] = {
  "lbi",  "lhi",   "lwi",  "ldi",    "lbi.bi",  "lhi.bi",  "lwi.bi",  "ldi.bi", "sbi",  "shi",   "swi",  "sdi",    "sbi.bi",  "shi.bi",  "swi.bi",  "sdi.bi", "lbsi", "lhsi",  "lwsi", "dprefi", "lbsi.bi", "lhsi.bi", "lwsi.bi", "lbgp", "lwc",  "swc",   "ldc",  "sdc",    "mem",     "lsmw",    "hwgp",    "sbgp", "alu1", "alu2",  "movi", "sethi",  "ji",      "jreg",    "br1",     "br2", "addi", "subri", "andi", "xori",   "ori",     "br3",     "slti",    "sltsi", "aext", "cext",  "misc", "bitci",  "op_64",   "cop" };







static const char *mnemonic_mem[] = {
  "lb",   "lh",  "lw",   "ld",    "lb.bi",  "lh.bi",  "lw.bi",  "ld.bi", "sb",   "sh",  "sw",   "sd",    "sb.bi",  "sh.bi",  "sw.bi",  "sd.bi", "lbs",  "lhs", "lws",  "dpref", "lbs.bi", "lhs.bi", "lws.bi", "27", "llw",  "scw", "32",   "33",    "34",     "35",     "36",     "37", "lbup", "41",  "lwup", "43",    "44",     "45",     "46",     "47", "sbup", "51",  "swup" };






static const char *mnemonic_alu1[] = {
  "add",  "sub",  "and",   "xor",   "or",       "nor",      "slt",      "slts", "slli", "srli", "srai",  "rotri", "sll",      "srl",      "sra",      "rotr", "seb",  "seh",  "bitc",  "zeh",   "wsbh",     "or_srli",  "divsr",    "divr", "sva",  "svs",  "cmovz", "cmovn", "add_srli", "sub_srli", "and_srli", "xor_srli" };





static const char *mnemonic_alu20[] = {
  "max",     "min",    "ave",     "abs",    "clips",   "clip",   "clo",    "clz", "bset",    "bclr",   "btgl",    "btst",   "bse",     "bsp",    "ffb",    "ffmism", "add.sc",  "sub.sc", "add.wc",  "sub.wc", "24",      "25",     "26",     "ffzmism", "qadd",    "qsub",   "32",      "33",     "34",      "35",     "36",     "37", "mfusr",   "mtusr",  "42",      "43",     "mul",     "45",     "46",     "47", "mults64", "mult64", "madds64", "madd64", "msubs64", "msub64", "divs", "div", "60",      "mult32", "62",      "madd32", "64",      "msub32", "65",   "66", "dmadd",   "dmaddc", "dmsub",   "dmsubc", "rmfhi",   "qmflo" };








static const char *mnemonic_alu21[] = {
  "00",      "01",     "02", "03",      "04", "05",      "06",   "07", "10",      "11",     "12", "13",      "14", "15",      "ffbi", "flmism", "20",      "21",     "22", "23",      "24", "25",      "26",   "27", "30",      "31",     "32", "33",      "34", "35",      "36",   "37", "40",      "41",     "42", "43",      "44", "45",      "46",   "47", "mulsr64", "mulr64", "52", "53",      "54", "55",      "56",   "57", "60",      "61",     "62", "maddr32", "64", "msubr32", "66",   "67", "70",      "71",     "72", "73",      "74", "75",      "76",   "77" };








static const char *mnemonic_br2[] = {
  "ifcall", "01", "beqz", "bnez", "bgez",   "bltz",   "bgtz", "blez", "10",     "11", "12",   "13",   "bgezal", "bltzal" };


static const char *mnemonic_misc[] = {
  "standby", "cctl", "mfsr",  "mtsr",    "iret",  "trap",  "teqz", "tnez", "dsb",     "isb",  "break", "syscall", "msync", "isync", "tlbop" };


static const char *mnemonic_hwgp[] = {
  "lhi.gp", "lhi.gp", "lhsi.gp", "lhsi.gp", "shi.gp", "shi.gp", "lwi.gp", "swi.gp" };


static const char *keyword_dpref[] = {
  "SRD", "MRD", "SWR", "MWR", "PTE", "CLWR", "6",  "7", "8",   "9",   "10",  "11",  "12",  "13",   "14", "15" };


static const char *mnemonic_alu[] = {
  "fadds",   "fsubs",   "fcpynss", "fcpyss",  "fmadds", "fmsubs",  "fcmovns", "fcmovzs", "fnmadds", "fnmsubs", "10",      "11",      "fmuls",   "fdivs",   "faddd", "fsubd",   "fcpynsd", "fcpysd",  "fmaddd",  "fmsubd", "fcmovnd", "fcmovzd", "fnmaddd", "fnmsubd", "24", "25",      "fmuld",   "fdivd" };






static const char *mnemonic_fpu_2op[] = {
  "fs2d",  "fsqrts",  "2",     "3",  "4",       "fabss",  "6",      "7", "fui2s", "9",       "10",    "11", "fsi2s",   "13",     "14",     "15", "fs2ui", "17",      "18",    "19", "fs2ui.z", "21",     "22",     "23", "fs2si", "25",      "26",    "27", "fs2si.z", "fd2s",   "fsqrtd", "31", "32",    "33",      "fabsd", "35", "36",      "fui2d",  "38",     "39", "40",    "fsi2d",   "42",    "43", "44",      "fd2ui",  "46",     "47", "48",    "fd2ui.z", "50",    "51", "52",      "fd2si",  "54",     "55", "56",    "fd2si.z" };








static const char *mnemonic_fs2_cmp[] = {
  "fcmpeqs", "fcmpeqs.e", "fcmplts", "fcmplts.e", "fcmples", "fcmples.e", "fcmpuns", "fcmpuns.e" };


static const char *mnemonic_fd2_cmp[] = {
  "fcmpeqd", "fcmpeqd.e", "fcmpltd", "fcmpltd.e", "fcmpled", "fcmpled.e", "fcmpund", "fcmpund.e" };





static const char *gpr_map[] = {
  "$r0", "$r1", "$r2", "$r3", "$r4", "$r5", "$r6", "$r7", "$r8", "$r9", "$r10", "$r11", "$r12", "$r13", "$r14", "$r15", "$r16", "$r17", "$r18", "$r19", "$r20", "$r21", "$r22", "$r23", "$r24", "$r25", "$r26", "$r27", "$fp", "$gp", "$lp", "$sp" };






static const char *usr_map[][32] = {
  {
    "d0.lo", "d0.hi", "d1.lo", "d1.hi", "4",  "5",  "6",  "7", "8",     "9",     "10",    "11",    "12", "13", "14", "15", "16",    "17",    "18",    "19",    "20", "21", "22", "23", "24",    "25",    "26",    "27",    "28", "29", "30", "pc" }, {




    "DMA_CFG",     "DMA_GCSW",    "DMA_CHNSEL", "DMA_ACT",    "DMA_SETUP", "DMA_ISADDR",  "DMA_ESADDR",  "DMA_TCNT",   "DMA_STATUS", "DMA_2DSET", "10",          "11",          "12",         "13",         "14", "15",          "16",          "17",         "18",         "19", "20",          "21",          "22",         "23",         "24", "DMA_2DSCTL" }, {






    "PFMC0", "PFMC1", "PFMC2", "3", "PFM_CTL" }
};



static const char *sr_map[8][16][8] = {
  {
    {"CPU_VER", "CORE_ID", {"ICM_CFG", {"DCM_CFG", {"MMU_CFG", {"MSC_CFG" }, {





    {"PSW", "IPSW", "P_IPSW", {"0", "IVB", "INT_CTRL", {"0", "EVA", "P_EVA", {"0", "ITYPE", "P_ITYPE", {"0", "MERR", {"0", "IPC", "P_IPC", "OIPC", {"0", "1", "P_P0", {"0", "1", "P_P1", {"INT_MASK", "INT_MASK2", {"INT_PEND", "INT_PEND2", "2", "3", "INT_TRIGGER", {"SP_USR", "SP_PRIV", {"INT_PRI", "INT_PRI2" }, {












    {"MMU_CTL", {"L1_PPTB", {"TLB_VPN", {"TLB_DATA", {"TLB_MISC", {"VLPT_IDX", {"ILMB", {"DLMB", {"CACHE_CTL", {"HSMP_SADDR", "HSMP_EADDR", {"0", {"0", {"0", {"0", {"0", {"SDZ_CTL", "MISC_CTL" }, {
















    {"BPC0", "BPC1", "BPC2", "BPC3", "BPC4", "BPC5", "BPC6", "BPC7", {"BPA0", "BPA1", "BPA2", "BPA3", "BPA4", "BPA5", "BPA6", "BPA7", {"BPAM0", "BPAM1", "BPAM2", "BPAM3", "BPAM4", "BPAM5", "BPAM6", "BPAM7", {"BPV0", "BPV1", "BPV2", "BPV3", "BPV4", "BPV5", "BPV6", "BPV7", {"BPCID0", "BPCID1", "BPCID2", "BPCID3", "BPCID4", "BPCID5", "BPCID6", "BPCID7", {"EDM_CFG", {"EDMSW", {"EDM_CTL", {"EDM_DTR", {"BPMTC", {"DIMBR", {"EDM_PROBE", {"0", {"0", {"TECR0", "TECR1" }, {















    {"PFMC0", "PFMC1", "PFMC2", {"PFM_CTL", {"0", {"0", {"PRUSR_ACC_CTL", {"FUCOP_CTL" }, {






    {"DMA_CFG", {"DMA_GCSW", {"DMA_CHNSEL", {"DMA_ACT", {"DMA_SETUP", {"DMA_ISADDR", {"DMA_ESADDR", {"DMA_TCNT", {"DMA_STATUS", {"DMA_2DSET", "DMA_2DSCTL" }









};

static void print_insn16 (bfd_vma pc, disassemble_info *info, uint32_t insn)
{
  static char r4map[] = {
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 17, 18, 19 };

  const int rt5 = __GF (insn, 5, 5);
  const int ra5 = __GF (insn, 0, 5);
  const int rt4 = r4map[__GF (insn, 5, 4)];
  const int imm5u = IMMU (insn, 5);
  const int imm9u = IMMU (insn, 9);
  const int rt3 = __GF (insn, 6, 3);
  const int ra3 = __GF (insn, 3, 3);
  const int rb3 = __GF (insn, 0, 3);
  const int rt38 = __GF (insn, 8, 3);
  const int imm3u = rb3;
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  static const char *mnemonic_96[] = {
    "0x1",        "0x1",       "0x2",     "0x3", "add45",      "sub45",     "addi45",  "subi45", "srai45",     "srli45",    "slli333", "0xb", "add333",     "sub333",    "addi333", "subi333", "lwi333",     "lwi333.bi", "lhi333",  "lbi333", "swi333",     "swi333.bi", "shi333",  "sbi333", "addri36.sp", "lwi45.fe",  "lwi450",  "swi450", "0x1c",       "0x1d",      "0x1e",    "0x1f", "0x20",       "0x21",      "0x22",    "0x23", "0x24",       "0x25",      "0x26",    "0x27", "0x28",       "0x29",      "0x2a",    "0x2b", "0x2c",       "0x2d",      "0x2e",    "0x2f", "slts45",     "slt45",     "sltsi45", "slti45", "0x34",       "0x35",      "0x36",    "0x37", "0x38",       "0x39",      "0x3a",    "0x3b", "ifcall9",    "movpi45" };
















  static const char *mnemonic_misc33[] = {
    "misc33_0", "misc33_1", "neg33", "not33", "mul33", "xor33", "and33", "or33", };

  static const char *mnemonic_0xb[] = {
    "zeb33", "zeh33", "seb33", "seh33", "xlsb33", "x11b33", "bmski33", "fexti33" };

  static const char *mnemonic_bnes38[] = {
    "jr5", "jral5", "ex9.it", "?", "ret5", "add5.pc" };

  switch (__GF (insn, 7, 8))
    {
    case 0xf8:			
    case 0xf9:			
      {
	uint32_t res[] = { 6, 8, 10, 14 };
	uint32_t re = res[__GF (insn, 5, 2)];

	func (stream, "%s\t%s, %d", (insn & __BIT (7)) ? "pop25" : "push25", gpr_map[re], imm5u << 3);
      }
      return;
    }

  if (__GF (insn, 8, 7) == 0x7d)	
    {
      int rt5e = __GF (insn, 4, 4) << 1;
      int ra5e = IMMU (insn, 4) << 1;

      func (stream, "movd44\t%s, %d", gpr_map[rt5e], ra5e);
      return;
    }

  switch (__GF (insn, 9, 6))
    {
    case 0x4:			
    case 0x5:			
    case 0x30:			
    case 0x31:			
      func (stream, "%s\t%s, %s", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt4], gpr_map[ra5]);
      return;
    case 0x6:			
    case 0x7:			
    case 0x8:			
    case 0x9:			
    case 0x32:			
    case 0x33:			
      func (stream, "%s\t%s, %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt4], ra5);
      return;
    case 0xc:			
    case 0xd:			
      func (stream, "%s\t%s, %s, %s", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], gpr_map[rb3]);
      return;
    case 0xa:			
    case 0xe:			
    case 0xf:			
      func (stream, "%s\t%s, %s, %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], imm3u);
      return;
    case 0x10:			
    case 0x14:			
      func (stream, "%s\t%s, [%s + %d]", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], imm3u << 2);
      return;
    case 0x12:			
    case 0x16:			
      func (stream, "%s\t%s, [%s + %d]", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], imm3u << 1);
      return;
    case 0x13:			
    case 0x17:			
      func (stream, "%s\t%s, [%s + %d]", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], imm3u);
      return;
    case 0x11:			
    case 0x15:			
      func (stream, "%s\t%s, [%s], %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], gpr_map[ra3], imm3u << 2);
      return;
    case 0x18:			
      func (stream, "%s\t%s, %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt3], IMMU (insn, 6) << 2);
      return;
    case 0x19:			
      func (stream, "%s\t%s, %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt4], -((32 - imm5u) << 2));
      return;
    case 0x1a:			
    case 0x1b:			
      func (stream, "%s\t%s, [%s]", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt4], gpr_map[ra5]);
      return;
    case 0x34:			
      func (stream, "%s\t", ((insn & __BIT (8)) ? "bnezs8" : "beqzs8"));
      info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
      return;
    case 0x35:			
      
      if (imm9u < 32)		
        func (stream, "break16\t%d", imm9u);
      else func (stream, "ex9.it\t%d", imm9u);
      return;
    case 0x3c:			
      func (stream, "%s\t", mnemonic_96[__GF (insn, 9, 6)]);
      info->print_address_func ((IMMU (insn, 9) << 1) + pc, info);
      return;
    case 0x3d:			
      func (stream, "%s\t%s, %d", mnemonic_96[__GF (insn, 9, 6)], gpr_map[rt4], ra5 + 16);
      return;
    case 0x3f:			
      func (stream, "%s\t%s, %s", mnemonic_misc33[rb3], gpr_map[rt3], gpr_map[ra3]);
      return;
    case 0xb:			
      func (stream, "%s\t%s, %s", mnemonic_0xb[rb3], gpr_map[rt3], gpr_map[ra3]);
      return;
    }

  switch (__GF (insn, 10, 5))
    {
    case 0x0:			
      
      if (rt5 == ra5 && rt5 == 31)
        func (stream, "ifret16");
      else func (stream, "mov55\t%s, %s", gpr_map[rt5], gpr_map[ra5]);
      return;
    case 0x1:			
      func (stream, "movi55\t%s, %d", gpr_map[rt5], IMMS (insn, 5));
      return;
    case 0x1b:			
      func (stream, "addi10s\t%d", IMMS (insn, 10));
      return;
    }

  switch (__GF (insn, 11, 4))
    {
    case 0x7:			
      func (stream, "%s\t%s, [$fp + 0x%x]", ((insn & __BIT (7)) ? "swi37" : "lwi37"), gpr_map[rt38], IMMU (insn, 7) << 2);

      return;
    case 0x8:			
    case 0x9:			
      func (stream, "%s\t%s, ", ((__GF (insn, 11, 4) & 1) ? "bnez38" : "beqz38"), gpr_map[rt38]);
      info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
      return;
    case 0xa:			
      if (rt38 == 5)
	{
	  func (stream, "j8\t");
	  info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
	}
     else {
	  func (stream, "beqs38\t%s, ", gpr_map[rt38]);
	  info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
	}
      return;
    case 0xb:			
      if (rt38 == 5)
	{
	  switch (__GF (insn, 5, 3))
	    {
	    case 0:		
	    case 1:		
	    case 4:		
	      func (stream, "%s\t%s", mnemonic_bnes38[__GF (insn, 5, 3)], gpr_map[ra5]);
	      return;
	    case 2:		
	    case 5:		
	      func (stream, "%s\t%d", mnemonic_bnes38[__GF (insn, 5, 3)], ra5);
	      return;
	    default:
	      func (stream, UNKNOWN_INSN_MSG);
	      return;
	    }
	}
      else {
	  func (stream, "bnes38\t%s", gpr_map[rt3]);
	  info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
	}
      return;
    case 0xe:			
      func (stream, "%s\t%s, [+ 0x%x]", ((insn & __BIT (7)) ? "swi37.sp" : "lwi37.sp"), gpr_map[rt38], IMMU (insn, 7) << 2);

      return;
    }
}


static void print_insn32_mem (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)

{
  const int rt = RT5 (insn);
  const int ra = RA5 (insn);
  const int rb = RB5 (insn);
  const int sv = __GF (insn, 8, 2);
  const int op = insn & 0xFF;
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  switch (op)
    {
    case 0x0:			
    case 0x1:			
    case 0x2:			
    case 0x3:			
    case 0x8:			
    case 0x9:			
    case 0xa:			
    case 0xb:			
    case 0x10:			
    case 0x11:			
    case 0x12:			
    case 0x18:			
    case 0x19:			
    case 0x20:			
    case 0x22:			
    case 0x28:			
    case 0x2a:			
      func (stream, "%s\t%s, [%s + (%s << %d)]", mnemonic_mem[op], gpr_map[rt], gpr_map[ra], gpr_map[rb], sv);
      break;
    case 0x4:			
    case 0x5:			
    case 0x6:			
    case 0x7:			
    case 0xc:			
    case 0xd:			
    case 0xe:			
    case 0xf:			
    case 0x14:			
    case 0x15:			
    case 0x16:			
      func (stream, "%s\t%s, [%s], (%s << %d)", mnemonic_mem[op], gpr_map[rt], gpr_map[ra], gpr_map[rb], sv);
      break;
    case 0x13:			
      {
	const char *subtype = "???";

	if ((rt & 0xf) < ARRAY_SIZE (keyword_dpref))
	  subtype = keyword_dpref[rt & 0xf];

	func (stream, "%s\t%s, [%s + (%s << %d)]", "dpref", subtype, gpr_map[ra], gpr_map[rb], sv);
      }
      break;
    default:
      func (stream, UNKNOWN_INSN_MSG);
      return;
    }
}

static void print_insn32_alu1 (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)
{
  int op = insn & 0x1f;
  const int rt = RT5 (insn);
  const int ra = RA5 (insn);
  const int rb = RB5 (insn);
  const int rd = RD5 (insn);
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  switch (op)
    {
    case 0x0:			
    case 0x1:			
    case 0x2:			
    case 0x3:			
    case 0x4:			
      if (rd != 0)
	{
	  func (stream, "%s_slli\t%s, %s, %s, #%d", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra], gpr_map[rb], rd);
	}
      else {
	  func (stream, "%s\t%s, %s, %s", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra], gpr_map[rb]);
	}
      return;
    case 0x1c:			
    case 0x1d:			
    case 0x1e:			
    case 0x1f:			
    case 0x15:			
      func (stream, "%s\t%s, %s, %s, #%d", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra], gpr_map[rb], rd);
      return;
    case 0x5:			
    case 0x6:			
    case 0x7:			
    case 0xc:			
    case 0xd:			
    case 0xe:			
    case 0xf:			
    case 0x12:			
    case 0x18:			
    case 0x19:			
    case 0x1a:			
    case 0x1b:			
      func (stream, "%s\t%s, %s, %s", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra], gpr_map[rb]);
      return;
    case 0x9:			
      if (ra ==0 && rb == 0 && rb==0)
	{
	  func (stream, "nop");
	  return;
	}
    case 0x8:			
    case 0xa:			
    case 0xb:			
      func (stream, "%s\t%s, %s, #%d", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra], rb);
      return;
    case 0x10:			
    case 0x11:			
    case 0x13:			
    case 0x14:			
      func (stream, "%s\t%s, %s", mnemonic_alu1[op], gpr_map[rt], gpr_map[ra]);
      return;
    case 0x16:			
    case 0x17:			
      func (stream, "%s\t%s, %s, %s, %s", mnemonic_alu1[op], gpr_map[rt], gpr_map[rd], gpr_map[ra], gpr_map[rb]);
      return;
    default:
      func (stream, UNKNOWN_INSN_MSG);
      return;
    }

  return;
}

static void print_insn32_alu2 (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)


{
  int op = insn & 0x3ff;
  const int rt = RT5 (insn);
  const int ra = RA5 (insn);
  const int rb = RB5 (insn);
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  if ((insn & 0x7f) == 0x4e)	
    {
      func (stream, "ffbi\t%s, %s, #0x%x", gpr_map[rt], gpr_map[ra], __GF (insn, 7, 8));
      return;
    }

  switch (op)
    {
    case 0x0:			
    case 0x1:			
    case 0x2:			
    case 0xc:			
    case 0xd:			
    case 0xe:			
    case 0xf:			
    case 0x17:			
    case 0x24:			
      func (stream, "%s\t%s, %s, %s", mnemonic_alu20[op], gpr_map[rt], gpr_map[ra], gpr_map[rb]);
      return;

    case 0x3:			
    case 0x6:			
    case 0x7:			
      func (stream, "%s\t%s, %s", mnemonic_alu20[op], gpr_map[rt], gpr_map[ra]);
      return;

    case 0x4:			
    case 0x5:			
    case 0x8:			
    case 0x9:			
    case 0xa:			
    case 0xb:			
      func (stream, "%s\t%s, %s, #%d", mnemonic_alu20[op], gpr_map[rt], gpr_map[ra], IMM1U (insn));
      return;

    case 0x20:			
    case 0x21:			
      func (stream, "%s\t%s, $%s", mnemonic_alu20[op], gpr_map[rt], usr_map[__GF (insn, 10, 5)][__GF (insn, 15, 5)]);
      return;
    case 0x28:			
    case 0x29:			
    case 0x2a:			
    case 0x2b:			
    case 0x2c:			
    case 0x2d:			
    case 0x2e:			
    case 0x2f:			
    case 0x31:			
    case 0x33:			
    case 0x35:			
      func (stream, "%s\t$d%d, %s, %s", mnemonic_alu20[op], rt >> 1, gpr_map[ra], gpr_map[rb]);
      return;

    case 0x4f:			
    case 0x68:			
    case 0x69:			
    case 0x73:			
    case 0x75:			
      op = insn & 0x3f;
      func (stream, "%s\t%s, %s, %s", mnemonic_alu21[op], gpr_map[rt], gpr_map[ra], gpr_map[rb]);
      return;
    default:
      func (stream, UNKNOWN_INSN_MSG);
      return;
    }
}

static void print_insn32_jreg (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)
{
  int op = insn & 0xff;
  const int rt = RT5 (insn);
  const int rb = RB5 (insn);
  const char *dtit_on[] = { "", ".iton", ".dton", ".ton" };
  const char *dtit_off[] = { "", ".itoff", ".dtoff", ".toff" };
  const char *mnemonic_jreg[] = { "jr", "jral", "jrnez", "jralnez" };
  const char *mnemonic_ret[] = { "jr", "ret", NULL, "ifret" };
  const int dtit = __GF (insn, 8, 2);
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  switch (op)
    {
    case 0:		
      func (stream, "%s%s\t%s", mnemonic_ret[op >> 5], dtit_on[dtit], gpr_map[rb]);
      return;

    case 0x20:		
      func (stream, "%s%s\t%s", mnemonic_ret[op >> 5], dtit_off[dtit], gpr_map[rb]);
      return;
    case 0x60:		
      break;
    case 1:		
    case 2:		
    case 3:		
      func (stream, "%s%s\t%s, %s", mnemonic_jreg[op], dtit_on[dtit], gpr_map[rt], gpr_map[rb]);
      return;
    default:		
      func (stream, UNKNOWN_INSN_MSG);
      break;
    }
}

static void print_insn32_misc (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)

{
  int op = insn & 0x1f;
  int rt = RT5 (insn);
  unsigned int id;
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  static const char *keyword_standby[] = {
      "no_wake_grant", "wake_grant", "wait_done", };
  static const char *keyword_tlbop[] = {
      "TRD", "TWR", "RWR", "RWLK", "UNLK", "PB", "INV", "FLUA" };

  switch (op)
    {
    case 0x0:			
      id = __GF (insn, 5, 20);
      if (id < ARRAY_SIZE (keyword_standby))
	func (stream, "standby\t%s", keyword_standby[id]);
      else func (stream, "standby\t%d", id);
      return;
    case 0x1:			
      func (stream, "cctl\t!FIXME");
      return;
    case 0x8:			
    case 0x9:			
    case 0xd:			
    case 0xc:			
    case 0x4:			
      func (stream, "%s", mnemonic_misc[op]);
      return;
    case 0x5:			
    case 0xa:			
    case 0xb:			
      id = __GF (insn, 5, 15);
      func (stream, "%s\t%d", mnemonic_misc[op], id);
      return;
    case 0x2:			
    case 0x3:			
      
      func (stream, "%s\t%s, $%s", mnemonic_misc[op], gpr_map[rt], sr_map[__GF(insn, 17, 3)][__GF(insn, 13, 4)][__GF(insn, 10, 3)]);
      return;
    case 0x6:			
    case 0x7:			
      id = __GF (insn, 5, 15);
      func (stream, "%s\t%s, %d", mnemonic_misc[op], gpr_map[rt], id);
      return;
    case 0xe:			
      id = __GF (insn, 5, 5);
      if (id < ARRAY_SIZE (keyword_tlbop))
	func (stream, "tlbop\t%s", keyword_tlbop[id]);
      else func (stream, "tlbop\t%d", id);
      return;
    }
}

static void print_insn32_fpu (bfd_vma pc ATTRIBUTE_UNUSED, disassemble_info *info, uint32_t insn)

{
  int op = insn & 0xf;
  int mask_sub_op = (insn & 0x3c0) >> 6;
  int mask_bi = (insn & 0x80) >> 7;
  int mask_cfg = (insn & 0x7c00) >> 10;
  int mask_f2op = (insn & 0x7c00) >> 10;
  int dp = 0;
  int dp_insn = 0;
  char wd = 's';
  const int rt = RT5 (insn);
  const int ra = RA5 (insn);
  const int rb = RB5 (insn);
  const int sv = __GF (insn, 8, 2);
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  switch (op)
    {
    case 0x0:			
    case 0x8:			
      dp = (op & 0x8) ? 1 : 0;
      if (dp)
	{
	  wd = 'd';
	  dp_insn = 14;
	}
      else {
	  wd = 's';
	  dp_insn = 0;
	}
      switch (mask_sub_op)
	{
	case 0x0:
	case 0x1:
	case 0x2:
	case 0x3:
	case 0x4:
	case 0x5:
	case 0x8:
	case 0x9:
	case 0xc:
	case 0xd:
	  func (stream, "%s\t$f%c%d, $f%c%d, $f%c%d", mnemonic_alu[mask_sub_op + dp_insn], wd, rt, wd, ra, wd, rb);

	  return;
	case 0x6:
	case 0x7:
	  func (stream, "%s\t$f%c%d, $f%c%d, $fs%d", mnemonic_alu[mask_sub_op + dp_insn], wd, rt, wd, ra, rb);

	  return;
	case 0xf:
	  if (dp)
	    {
	      wd = 'd';
	      dp_insn = 0x1d;
	    }
	  else {
	      wd = 's';
	      dp_insn = 0;
	    }

	  switch (mask_f2op)
	    {
	    case 0x0:
	      if (dp)
		func (stream, "%s\t$fs%d, $fd%d", mnemonic_fpu_2op[mask_f2op + dp_insn], rt, ra);
	      else func (stream, "%s\t$fd%d, $fs%d", mnemonic_fpu_2op[mask_f2op + dp_insn], rt, ra);

	      return;
	    case 0x1:
	    case 0x5:
	      func (stream, "%s\t$f%c%d, $f%c%d", mnemonic_fpu_2op[mask_f2op + dp_insn], wd, rt, wd, ra);
	      return;
	    case 0x8:
	    case 0xc:
	      func (stream, "%s\t$f%c%d, $fs%d", mnemonic_fpu_2op[mask_f2op + dp_insn], wd, rt, ra);
	      return;
	    case 0x10:
	    case 0x14:
	    case 0x18:
	    case 0x1c:
	      func (stream, "%s\t$fs%d, $f%c%d", mnemonic_fpu_2op[mask_f2op + dp_insn], rt, wd, ra);
	      return;
	    }
	}
    case 0x1:			
      switch (mask_sub_op)
	{
	case 0x0:
	  func (stream, "fmfsr\t%s, $fs%d", gpr_map[rt], ra);
	  return;
	case 0x1:
	  func (stream, "fmfdr\t%s, $fd%d", gpr_map[rt], ra);
	  return;
	case 0xc:
	  if (mask_cfg)
	    func (stream, "fmfcsr\t%s", gpr_map[rt]);
	  else func (stream, "fmfcfg\t%s", gpr_map[rt]);
	  return;
	}
    case 0x2:			
      if (mask_bi)
	func (stream, "fls.bi\t$fs%d, [%s], (%s << %d)", rt, gpr_map[ra], gpr_map[rb], sv);
      else func (stream, "fls\t$fs%d, [%s + (%s << %d)]", rt, gpr_map[ra], gpr_map[rb], sv);

      return;
    case 0x3:			
      if (mask_bi)
	func (stream, "fld.bi\t$fd%d, [%s], (%s << %d)", rt, gpr_map[ra], gpr_map[rb], sv);
      else func (stream, "fld\t$fd%d, [%s + (%s << %d)]", rt, gpr_map[ra], gpr_map[rb], sv);

      return;
    case 0x4:			
      func (stream, "%s\t$fs%d, $fs%d, $fs%d", mnemonic_fs2_cmp[mask_sub_op], rt, ra, rb);
      return;
    case 0x9:			
      switch (mask_sub_op)
	{
	case 0x0:
	  func (stream, "fmtsr\t%s, $fs%d", gpr_map[rt], ra);
	  return;
	case 0x1:
	  func (stream, "fmtdr\t%s, $fd%d", gpr_map[rt], ra);
	  return;
	case 0xc:
	    func (stream, "fmtcsr\t%s", gpr_map[rt]);
	  return;
	}
    case 0xa:			
      if (mask_bi)
	func (stream, "fss.bi\t$fs%d, [%s], (%s << %d)", rt, gpr_map[ra], gpr_map[rb], sv);
      else func (stream, "fss\t$fs%d, [%s + (%s << %d)]", rt, gpr_map[ra], gpr_map[rb], sv);

      return;
    case 0xb:			
      if (mask_bi)
	func (stream, "fsd.bi\t$fd%d, [%s], (%s << %d)", rt, gpr_map[ra], gpr_map[rb], sv);
      else func (stream, "fsd\t$fd%d, [%s + (%s << %d)]", rt, gpr_map[ra], gpr_map[rb], sv);

      return;
    case 0xc:			
      if (mask_sub_op >= 0 && mask_sub_op < 8) {
      func (stream, "%s\t$fs%d, $fd%d, $fd%d", mnemonic_fd2_cmp[mask_sub_op], rt, ra, rb);
      } else {
      func (stream, "%s%d\t$fs%d, $fd%d, $fd%d", "fd2cmp", mask_sub_op, rt, ra, rb);
      }
      return;
    }
}

static void print_insn32 (bfd_vma pc, disassemble_info *info, uint32_t insn)
{
  int op = OP6 (insn);
  const int rt = RT5 (insn);
  const int ra = RA5 (insn);
  const int rb = RB5 (insn);
  const int imm15s = IMMS (insn, 15);
  const int imm15u = IMMU (insn, 15);
  uint32_t shift;
  fprintf_ftype func = info->fprintf_func;
  void *stream = info->stream;

  switch (op)
    {
    case 0x0:			
    case 0x1:			
    case 0x2:			
    case 0x3:			
    case 0x8:			
    case 0x9:			
    case 0xa:			
    case 0xb:			
    case 0x10:			
    case 0x11:			
    case 0x12:			
      shift = op & 0x3;
      func (stream, "%s\t%s, [%s + #%d]", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift);
      return;
    case 0x4:			
    case 0x5:			
    case 0x6:			
    case 0x7:			
    case 0xc:			
    case 0xd:			
    case 0xe:			
    case 0xf:			
    case 0x14:			
    case 0x15:			
    case 0x16:			
      shift = op & 0x3;
      func (stream, "%s\t%s, [%s], #%d", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift);
      return;
    case 0x13:			
      {
	const char *subtype = "???";
	char wd = 'w';

	shift = 2;

	
	if (rt & 0x10)
	  {
	    wd = 'd';
	    shift = 3;
	  }

	if ((rt & 0xf) < ARRAY_SIZE (keyword_dpref))
	  subtype = keyword_dpref[rt & 0xf];

	func (stream, "%s.%c\t%s, [%s + #%d]", mnemonic_op6[op], wd, subtype, gpr_map[ra], imm15s << shift);
      }
      return;
    case 0x17:			
      func (stream, "%s\t%s, [+ %d]", ((insn & __BIT (19)) ? "lbsi.gp" : "lbi.gp"), gpr_map[rt], IMMS (insn, 19));

      return;
    case 0x18:			
    case 0x19:			
    case 0x1a:			
    case 0x1b:			
      if (__GF (insn, 13, 2) == 0)
	{
	  char ls = (op & 1) ? 's' : 'l';
	  char wd = (op & 2) ? 'd' : 's';

	  if (insn & __BIT (12))
	    {
	      func (stream, "f%c%ci.bi\t$f%c%d, [%s], %d", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2);
	    }
	  else {
	      func (stream, "f%c%ci\t$f%c%d, [%s + %d]", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2);
	    }
	}
      else {
	  char ls = (op & 1) ? 's' : 'l';
	  char wd = (op & 2) ? 'd' : 'w';
	  int cp = __GF (insn, 13, 2);

	  if (insn & __BIT (12))
	    {
	      func (stream, "cp%c%ci\tcp%d, $cpr%d, [%s], %d", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2);
	    }
	  else {
	      func (stream, "cp%c%ci\tcp%d, $cpr%d, [%s + %d]", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2);
	    }
	}
      return;
    case 0x1c:			
      print_insn32_mem (pc, info, insn);
      return;
    case 0x1d:			
      {
	int enb4 = __GF (insn, 6, 4);
	char ls = (insn & __BIT (5)) ? 's' : 'l';
	char ab = (insn & __BIT (4)) ? 'a' : 'b';
	char *di = (insn & __BIT (3)) ? "d" : "i";
	char *m = (insn & __BIT (2)) ? "m" : "";
	static const char *s[] = {"", "a", "zb", "?";

	
	if ((insn & 0x3) == 2)
	  di = "";

	func (stream, "%cmw%s.%c%s%s\t%s, [%s], %s, 0x%x", ls, s[insn & 0x3], ab, di, m, gpr_map[rt], gpr_map[ra], gpr_map[rb], enb4);

      }
      return;
    case 0x1e:			
      op = __GF (insn, 17, 3);
      switch (op)
	{
	case 0: case 1:		
	case 2: case 3:		
	case 4: case 5:		
	  func (stream, "%s\t%s, [+ %d]", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 18) << 1);
	  return;
	case 6:			
	case 7:			
	  func (stream, "%s\t%s, [+ %d]", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 17) << 2);
	  return;
	}
      return;
    case 0x1f:			
      if (insn & __BIT (19))
	func (stream, "addi.gp\t%s, %d", gpr_map[rt], IMMS (insn, 19));
      else func (stream, "sbi.gp\t%s, [+ %d]", gpr_map[rt], IMMS (insn, 19));

      return;
    case 0x20:			
      print_insn32_alu1 (pc, info, insn);
      return;
    case 0x21:			
      print_insn32_alu2 (pc, info, insn);
      return;
    case 0x22:			
      func (stream, "movi\t%s, %d", gpr_map[rt], IMMS (insn, 20));
      return;
    case 0x23:			
      func (stream, "sethi\t%s, 0x%x", gpr_map[rt], IMMU (insn, 20));
      return;
    case 0x24:			
      
      if (info->flags & INSN_HAS_RELOC)
	pc = 0;
      func (stream, "%s\t", ((insn & __BIT (24)) ? "jal" : "j"));
      info->print_address_func ((IMMS (insn, 24) << 1) + pc, info);
      return;
    case 0x25:			
      print_insn32_jreg (pc, info, insn);
      return;
    case 0x26:			
      func (stream, "%s\t%s, %s, ", ((insn & __BIT (14)) ? "bne" : "beq"), gpr_map[rt], gpr_map[ra]);
      info->print_address_func ((IMMS (insn, 14) << 1) + pc, info);
      return;
    case 0x27:			
      func (stream, "%s\t%s, ", mnemonic_br2[__GF (insn, 16, 4)], gpr_map[rt]);
      info->print_address_func ((IMMS (insn, 16) << 1) + pc, info);
      return;
    case 0x28:			
    case 0x2e:			
    case 0x2f:			
    case 0x29:			
      func (stream, "%s\t%s, %s, %d", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s);
      return;
    case 0x2a:			
    case 0x2b:			
    case 0x2c:			
    case 0x33:			
      func (stream, "%s\t%s, %s, %d", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15u);
      return;
    case 0x2d:			
      func (stream, "%s\t%s, %d, ", ((insn & __BIT (19)) ? "bnec" : "beqc"), gpr_map[rt], __SEXT (__GF (insn, 8, 11), 11));
      info->print_address_func ((IMMS (insn, 8) << 1) + pc, info);
      return;
    case 0x32:			
      print_insn32_misc (pc, info, insn);
      return;
    case 0x35:			
      print_insn32_fpu (pc, info, insn);
      return;
    }
}

int print_insn_nds32 (bfd_vma pc, disassemble_info *info)
{
  int status;
  bfd_byte buf[4];
  uint32_t insn;

  status = info->read_memory_func (pc, (bfd_byte *) buf, 2, info);
  if (status)
    return -1;

  
  if (buf[0] & 0x80)
    {
      insn = bfd_getb16 (buf);
      print_insn16 (pc, info, insn);
      return 2;
    }

  
  status = info->read_memory_func (pc + 2, (bfd_byte *) buf + 2, 2, info);
  if (status)
    return -1;

  insn = bfd_getb32 (buf);
  print_insn32 (pc, info, insn);

  return 4;
}
