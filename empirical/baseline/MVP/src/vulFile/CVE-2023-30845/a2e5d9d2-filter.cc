























namespace espv2 {
namespace envoy {
namespace http_filters {
namespace service_control {

void ServiceControlFilter::onDestroy() {
  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);
  if (handler_) {
    handler_->onDestroy();
  }
}

Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders( Envoy::Http::RequestHeaderMap& headers, bool) {
  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);

  if (!headers.Method()) {
    rejectRequest(Envoy::Http::Code::BadRequest, "No method in request headers.", utils::generateRcDetails(utils::kRcDetailFilterServiceControl, utils::kRcDetailErrorTypeBadRequest, utils::kRcDetailErrorMissingMethod));



    return Envoy::Http::FilterHeadersStatus::StopIteration;
  } else if (!headers.Path()) {
    rejectRequest(Envoy::Http::Code::BadRequest, "No path in request headers.", utils::generateRcDetails(utils::kRcDetailFilterServiceControl, utils::kRcDetailErrorTypeBadRequest, utils::kRcDetailErrorMissingPath));


    return Envoy::Http::FilterHeadersStatus::StopIteration;
  }

  
  auto route = decoder_callbacks_->route();

  
  
  if (route == nullptr) {
    return Envoy::Http::FilterHeadersStatus::Continue;
  }

  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);
  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());
  state_ = Calling;
  stopped_ = false;

  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();

  handler_->callCheck(headers, parent_span, *this);

  
  if (state_ == Complete) {
    return Envoy::Http::FilterHeadersStatus::Continue;
  }

  
  ENVOY_LOG(debug, "Called ServiceControl filter : Stop");
  stopped_ = true;
  return Envoy::Http::FilterHeadersStatus::StopIteration;
}

void ServiceControlFilter::onCheckDone( const ::google::protobuf::util::Status& status, absl::string_view rc_detail) {

  if (!status.ok()) {
    
    
    auto http_code = Envoy::Grpc::Utility::grpcToHttpStatus( static_cast<Envoy::Grpc::Status::GrpcStatus>(status.code()));
    rejectRequest(static_cast<Envoy::Http::Code>(http_code), status.ToString(), rc_detail);
    return;
  }

  stats_.filter_.allowed_.inc();
  state_ = Complete;
  if (stopped_) {
    decoder_callbacks_->continueDecoding();
  }
}

void ServiceControlFilter::rejectRequest(Envoy::Http::Code code, absl::string_view error_msg, absl::string_view rc_detail) {

  stats_.filter_.denied_.inc();
  state_ = Responded;

  decoder_callbacks_->sendLocalReply(code, error_msg, nullptr, absl::nullopt, rc_detail);
  decoder_callbacks_->streamInfo().setResponseFlag( Envoy::StreamInfo::ResponseFlag::UnauthorizedExternalService);
}

Envoy::Http::FilterDataStatus ServiceControlFilter::decodeData( Envoy::Buffer::Instance&, bool) {
  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);
  if (state_ == Calling) {
    return Envoy::Http::FilterDataStatus::StopIterationAndWatermark;
  }
  return Envoy::Http::FilterDataStatus::Continue;
}

Envoy::Http::FilterTrailersStatus ServiceControlFilter::decodeTrailers( Envoy::Http::RequestTrailerMap&) {
  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);
  if (state_ == Calling) {
    return Envoy::Http::FilterTrailersStatus::StopIteration;
  }
  return Envoy::Http::FilterTrailersStatus::Continue;
}

void ServiceControlFilter::log( const Envoy::Http::RequestHeaderMap* request_headers, const Envoy::Http::ResponseHeaderMap* response_headers, const Envoy::Http::ResponseTrailerMap* response_trailers, const Envoy::StreamInfo::StreamInfo&) {



  ENVOY_LOG(debug, "Called ServiceControl Filter : {}", __func__);
  if (!handler_) {
    if (!request_headers) return;
    handler_ = factory_.createHandler(*request_headers, decoder_callbacks_, stats_);
  }

  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();
  handler_->callReport(request_headers, response_headers, response_trailers, parent_span);
}

}  
}  
}  
}  
