

















DROGON_EXPORT char *strptime(const char *s, const char *f, struct tm *tm);
DROGON_EXPORT time_t timegm(struct tm *tm);

namespace drogon {
namespace internal {
template <typename T> struct CanConvertFromStringStream {

  private:
    using yes = std::true_type;
    using no = std::false_type;

    template <typename U> static auto test(U *p, std::stringstream &&ss)
        -> decltype((ss >> *p), yes());

    template <typename> static no test(...);

  public:
    static constexpr bool value = std::is_same<decltype(test<T>(nullptr, std::stringstream())), yes>::value;

};
}  
namespace utils {

DROGON_EXPORT bool isInteger(const std::string &str);



DROGON_EXPORT std::string genRandomString(int length);


DROGON_EXPORT std::string binaryStringToHex(const unsigned char *ptr, size_t length);


DROGON_EXPORT std::string hexToBinaryString(const char *ptr, size_t length);


DROGON_EXPORT std::vector<char> hexToBinaryVector(const char *ptr, size_t length);



inline std::vector<std::string> splitString(const std::string &str, const std::string &separator, bool acceptEmptyString = false)

{
    return trantor::splitString(str, separator, acceptEmptyString);
}

DROGON_EXPORT std::set<std::string> splitStringToSet( const std::string &str, const std::string &separator);



DROGON_EXPORT std::string getUuid();


DROGON_EXPORT std::string base64Encode(const unsigned char *bytes_to_encode, unsigned int in_len, bool url_safe = false);



DROGON_EXPORT std::string base64Decode(const std::string &encoded_string);
DROGON_EXPORT std::vector<char> base64DecodeToVector( const std::string &encoded_string);


DROGON_EXPORT bool needUrlDecoding(const char *begin, const char *end);


DROGON_EXPORT std::string urlDecode(const char *begin, const char *end);
inline std::string urlDecode(const std::string &szToDecode)
{
    auto begin = szToDecode.data();
    return urlDecode(begin, begin + szToDecode.length());
}
inline std::string urlDecode(const string_view &szToDecode)
{
    auto begin = szToDecode.data();
    return urlDecode(begin, begin + szToDecode.length());
}

DROGON_EXPORT std::string urlEncode(const std::string &);
DROGON_EXPORT std::string urlEncodeComponent(const std::string &);


DROGON_EXPORT std::string getMd5(const char *data, const size_t dataLen);
inline std::string getMd5(const std::string &originalString)
{
    return getMd5(originalString.data(), originalString.length());
}



DROGON_EXPORT std::string gzipCompress(const char *data, const size_t ndata);
DROGON_EXPORT std::string gzipDecompress(const char *data, const size_t ndata);



DROGON_EXPORT std::string brotliCompress(const char *data, const size_t ndata);
DROGON_EXPORT std::string brotliDecompress(const char *data, const size_t ndata);



DROGON_EXPORT char *getHttpFullDate( const trantor::Date &date = trantor::Date::now());



DROGON_EXPORT trantor::Date getHttpDate(const std::string &httpFullDateString);


DROGON_EXPORT std::string formattedString(const char *format, ...);



DROGON_EXPORT int createPath(const std::string &path);


inline std::string fromWidePath(const std::wstring &strPath)
{
    return trantor::utils::fromWidePath(strPath);
}


inline std::wstring toWidePath(const std::string &strUtf8Path)
{
    return trantor::utils::toWidePath(strUtf8Path);
}



inline std::wstring toNativePath(const std::string &strPath)
{
    return trantor::utils::toNativePath(strPath);
}
inline const std::wstring &toNativePath(const std::wstring &strPath)
{
    return trantor::utils::toNativePath(strPath);
}

inline const std::string &toNativePath(const std::string &strPath)
{
    return trantor::utils::toNativePath(strPath);
}
inline std::string toNativePath(const std::wstring &strPath)
{
    return trantor::utils::toNativePath(strPath);
}


inline const std::string &fromNativePath(const std::string &strPath)
{
    return trantor::utils::fromNativePath(strPath);
}

inline std::string fromNativePath(const std::wstring &strPath)
{
    return trantor::utils::fromNativePath(strPath);
}



DROGON_EXPORT void replaceAll(std::string &s, const std::string &from, const std::string &to);



DROGON_EXPORT bool secureRandomBytes(void *ptr, size_t size);

template <typename T> typename std::enable_if<internal::CanConvertFromStringStream<T>::value, T>::type fromString(const std::string &p) noexcept(false)

{
    T value{};
    if (!p.empty())
    {
        std::stringstream ss(p);
        ss >> value;
    }
    return value;
}

template <typename T> typename std::enable_if<!(internal::CanConvertFromStringStream<T>::value), T>::type fromString(const std::string &) noexcept(false)


{
    throw std::runtime_error("Bad type conversion");
}

template <> inline std::string fromString<std::string>(const std::string &p) noexcept(false)
{
    return p;
}

template <> inline int fromString<int>(const std::string &p) noexcept(false)
{
    return std::stoi(p);
}

template <> inline long fromString<long>(const std::string &p) noexcept(false)
{
    return std::stol(p);
}

template <> inline long long fromString<long long>(const std::string &p) noexcept(false)
{
    return std::stoll(p);
}

template <> inline unsigned long fromString<unsigned long>(const std::string &p) noexcept( false)

{
    return std::stoul(p);
}

template <> inline unsigned long long fromString<unsigned long long>( const std::string &p) noexcept(false)

{
    return std::stoull(p);
}

template <> inline float fromString<float>(const std::string &p) noexcept(false)
{
    return std::stof(p);
}

template <> inline double fromString<double>(const std::string &p) noexcept(false)
{
    return std::stod(p);
}

template <> inline long double fromString<long double>(const std::string &p) noexcept(false)
{
    return std::stold(p);
}

template <> inline bool fromString<bool>(const std::string &p) noexcept(false)
{
    if (p == "1")
    {
        return true;
    }
    if (p == "0")
    {
        return false;
    }
    std::string l{p};
    std::transform(p.begin(), p.end(), l.begin(), [](unsigned char c) {
        return tolower(c);
    });
    if (l == "true")
    {
        return true;
    }
    else if (l == "false")
    {
        return false;
    }
    throw std::runtime_error("Can't convert from string '" + p + "' to bool");
}
}  
}  
