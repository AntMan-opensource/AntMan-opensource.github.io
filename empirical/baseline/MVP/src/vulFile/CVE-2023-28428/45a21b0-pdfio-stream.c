



















static unsigned char	stream_paeth(unsigned char a, unsigned char b, unsigned char c);
static ssize_t		stream_read(pdfio_stream_t *st, char *buffer, size_t bytes);
static bool		stream_write(pdfio_stream_t *st, const void *buffer, size_t bytes);
static const char	*zstrerror(int error);






bool					 pdfioStreamClose(pdfio_stream_t *st)
{
  bool ret = true;			


  
  if (!st)
    return (false);

  
  if (st->pdf->mode == _PDFIO_MODE_READ)
  {
    if (st->filter == PDFIO_FILTER_FLATE)
      inflateEnd(&(st->flate));
  }
  else {
    
    if (st->filter == PDFIO_FILTER_FLATE)
    {
      
      int status;			

      while ((status = deflate(&st->flate, Z_FINISH)) != Z_STREAM_END)
      {
        size_t	bytes = sizeof(st->cbuffer) - st->flate.avail_out,  outbytes;


	if (status < Z_OK && status != Z_BUF_ERROR)
	{
	  _pdfioFileError(st->pdf, "Flate compression failed: %s", zstrerror(status));
	  ret = false;
	  goto done;
	}

	if (st->crypto_cb)
	{
	  
	  outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes & (size_t)~15);
	}
	else {
	  
	  outbytes = bytes;
	}

	if (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))
	{
	  ret = false;
	  goto done;
	}

        if (bytes > outbytes)
        {
          bytes -= outbytes;
          memmove(st->cbuffer, st->cbuffer + outbytes, bytes);
        }
        else {
          bytes = 0;
        }

	st->flate.next_out  = (Bytef *)st->cbuffer + bytes;
	st->flate.avail_out = (uInt)(sizeof(st->cbuffer) - bytes);
      }

      if (st->flate.avail_out < (uInt)sizeof(st->cbuffer))
      {
        
        size_t bytes = sizeof(st->cbuffer) - st->flate.avail_out;
					

	if (st->crypto_cb)
	{
	  
	  bytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, bytes);
	}

	if (!_pdfioFileWrite(st->pdf, st->cbuffer, bytes))
	{
	  ret = false;
	  goto done;
	}
      }

      deflateEnd(&st->flate);
    }
    else if (st->crypto_cb && st->bufptr > st->buffer)
    {
      
      uint8_t	temp[8192];		
      size_t	outbytes;		

      outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, (size_t)(st->bufptr - st->buffer));
      if (!_pdfioFileWrite(st->pdf, temp, outbytes))
      {
        ret = false;
        goto done;
      }
    }

    
    st->obj->stream_length = (size_t)(_pdfioFileTell(st->pdf) - st->obj->stream_offset);

    
    if (!_pdfioFilePuts(st->pdf, "\nendstream\nendobj\n"))
    {
      ret = false;
      goto done;
    }

    
    if (st->length_obj)
    {
      st->length_obj->value.value.number = st->obj->stream_length;
      pdfioObjClose(st->length_obj);
    }
    else if (st->obj->length_offset)
    {
      
      if (_pdfioFileSeek(st->pdf, st->obj->length_offset, SEEK_SET) < 0)
      {
        ret = false;
        goto done;
      }

      
      if (!_pdfioFilePrintf(st->pdf, "%-10lu", (unsigned long)st->obj->stream_length))
      {
        ret = false;
        goto done;
      }

      
      if (_pdfioFileSeek(st->pdf, 0, SEEK_END) < 0)
      {
        ret = false;
        goto done;
      }
    }
  }

  done:

  st->pdf->current_obj = NULL;

  free(st->prbuffer);
  free(st->psbuffer);
  free(st);

  return (ret);
}








pdfio_stream_t *			 _pdfioStreamCreate( pdfio_obj_t    *obj, pdfio_obj_t    *length_obj, pdfio_filter_t compression)



{
  pdfio_stream_t	*st;		


  
  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)
  {
    _pdfioFileError(obj->pdf, "Unable to allocate memory for a stream.");
    return (NULL);
  }

  st->pdf        = obj->pdf;
  st->obj        = obj;
  st->length_obj = length_obj;
  st->filter     = compression;
  st->bufptr     = st->buffer;
  st->bufend     = st->buffer + sizeof(st->buffer);

  if (obj->pdf->encryption)
  {
    uint8_t	iv[64];			
    size_t	ivlen = sizeof(iv);	

    if ((st->crypto_cb = _pdfioCryptoMakeWriter(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)
    {
      
      free(st);
      return (NULL);
    }

    if (ivlen > 0)
      _pdfioFileWrite(st->pdf, iv, ivlen);
  }

  if (compression == PDFIO_FILTER_FLATE)
  {
    
    pdfio_dict_t *params = pdfioDictGetDict(obj->value.value.dict, "DecodeParms");
					
    int bpc = (int)pdfioDictGetNumber(params, "BitsPerComponent");
					
    int colors = (int)pdfioDictGetNumber(params, "Colors");
					
    int columns = (int)pdfioDictGetNumber(params, "Columns");
					
    int predictor = (int)pdfioDictGetNumber(params, "Predictor");
					
    int status;				

    PDFIO_DEBUG("_pdfioStreamCreate: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\n", bpc, colors, columns, predictor);

    if (bpc == 0)
    {
      bpc = 8;
    }
    else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)
    {
      _pdfioFileError(st->pdf, "Unsupported BitsPerColor value %d.", bpc);
      free(st);
      return (NULL);
    }

    if (colors == 0)
    {
      colors = 1;
    }
    else if (colors < 0 || colors > 4)
    {
      _pdfioFileError(st->pdf, "Unsupported Colors value %d.", colors);
      free(st);
      return (NULL);
    }

    if (columns == 0)
    {
      columns = 1;
    }
    else if (columns < 0)
    {
      _pdfioFileError(st->pdf, "Unsupported Columns value %d.", columns);
      free(st);
      return (NULL);
    }

    if ((predictor > 1 && predictor < 10) || predictor > 15)
    {
      _pdfioFileError(st->pdf, "Unsupported Predictor function %d.", predictor);
      free(st);
      return (NULL);
    }
    else if (predictor)
    {
      
      st->predictor = (_pdfio_predictor_t)predictor;
      st->pbpixel   = (size_t)(bpc * colors + 7) / 8;
      st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;
      if (predictor >= 10)
	st->pbsize ++;		

      if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)
      {
	_pdfioFileError(st->pdf, "Unable to allocate %lu bytes for Predictor buffers.", (unsigned long)st->pbsize);
	free(st->prbuffer);
	free(st->psbuffer);
	free(st);
	return (NULL);
      }
    }
    else st->predictor = _PDFIO_PREDICTOR_NONE;

    st->flate.next_out  = (Bytef *)st->cbuffer;
    st->flate.avail_out = (uInt)sizeof(st->cbuffer);

    if ((status = deflateInit(&(st->flate), 9)) != Z_OK)
    {
      _pdfioFileError(st->pdf, "Unable to start Flate filter: %s", zstrerror(status));
      free(st->prbuffer);
      free(st->psbuffer);
      free(st);
      return (NULL);
    }
  }

  return (st);
}






bool					 pdfioStreamConsume(pdfio_stream_t *st, size_t         bytes)

{
  size_t	remaining;		
  ssize_t	rbytes;			


  
  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !bytes)
    return (false);

  
  
  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)
  {
    bytes -= remaining;

    if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)
    {
      st->bufptr = st->buffer;
      st->bufend = st->buffer + rbytes;
    }
    else {
      st->bufptr = st->bufend = st->buffer;
      return (false);
    }
  }

  st->bufptr += bytes;

  return (true);
}













bool					 pdfioStreamGetToken( pdfio_stream_t *st, char           *buffer, size_t         bufsize)



{
  _pdfio_token_t	tb;		
  bool			ret;		


  
  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bufsize)
    return (false);

  
  _pdfioTokenInit(&tb, st->pdf, (_pdfio_tconsume_cb_t)pdfioStreamConsume, (_pdfio_tpeek_cb_t)pdfioStreamPeek, st);

  ret = _pdfioTokenRead(&tb, buffer, bufsize);
  _pdfioTokenFlush(&tb);

  return (ret);
}









pdfio_stream_t *			 _pdfioStreamOpen(pdfio_obj_t *obj, bool        decode)

{
  pdfio_stream_t	*st;		
  pdfio_dict_t		*dict = pdfioObjGetDict(obj);
					


  PDFIO_DEBUG("_pdfioStreamOpen(obj=%p(%u), decode=%s)\n", obj, (unsigned)obj->number, decode ? "true" : "false");

  
  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)
  {
    _pdfioFileError(obj->pdf, "Unable to allocate memory for a stream.");
    return (NULL);
  }

  st->pdf = obj->pdf;
  st->obj = obj;

  if ((st->remaining = pdfioObjGetLength(obj)) == 0)
  {
    free(st);
    return (NULL);
  }

  if (_pdfioFileSeek(st->pdf, obj->stream_offset, SEEK_SET) != obj->stream_offset)
  {
    free(st);
    return (NULL);
  }

  if (obj->pdf->encryption)
  {
    uint8_t	iv[64];			
    size_t	ivlen;			

    ivlen = (size_t)_pdfioFilePeek(st->pdf, iv, sizeof(iv));

    if ((st->crypto_cb = _pdfioCryptoMakeReader(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)
    {
      
      free(st);
      return (NULL);
    }

    if (ivlen > 0)
      _pdfioFileConsume(st->pdf, ivlen);

    if (st->pdf->encryption >= PDFIO_ENCRYPTION_AES_128)
      st->remaining = (st->remaining + 15) & (size_t)~15;
  }

  if (decode)
  {
    
    const char	*filter = pdfioDictGetName(dict, "Filter");
					

    if (!filter)
    {
      
      if (pdfioDictGetArray(dict, "Filter"))
      {
	
	_pdfioFileError(st->pdf, "Unsupported compound stream filter.");
	free(st);
	return (NULL);
      }

      
      st->filter = PDFIO_FILTER_NONE;
    }
    else if (!strcmp(filter, "FlateDecode"))
    {
      
      pdfio_dict_t *params = pdfioDictGetDict(dict, "DecodeParms");
					
      int bpc = (int)pdfioDictGetNumber(params, "BitsPerComponent");
					
      int colors = (int)pdfioDictGetNumber(params, "Colors");
					
      int columns = (int)pdfioDictGetNumber(params, "Columns");
					
      int predictor = (int)pdfioDictGetNumber(params, "Predictor");
					
      int status;			
      ssize_t rbytes;			

      PDFIO_DEBUG("_pdfioStreamOpen: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\n", bpc, colors, columns, predictor);

      st->filter = PDFIO_FILTER_FLATE;

      if (bpc == 0)
      {
        bpc = 8;
      }
      else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)
      {
        _pdfioFileError(st->pdf, "Unsupported BitsPerColor value %d.", bpc);
        free(st);
        return (NULL);
      }

      if (colors == 0)
      {
        colors = 1;
      }
      else if (colors < 0 || colors > 4)
      {
        _pdfioFileError(st->pdf, "Unsupported Colors value %d.", colors);
        free(st);
        return (NULL);
      }

      if (columns == 0)
      {
        columns = 1;
      }
      else if (columns < 0)
      {
        _pdfioFileError(st->pdf, "Unsupported Columns value %d.", columns);
        free(st);
        return (NULL);
      }

      if ((predictor > 2 && predictor < 10) || predictor > 15)
      {
        _pdfioFileError(st->pdf, "Unsupported Predictor function %d.", predictor);
        free(st);
        return (NULL);
      }
      else if (predictor > 1)
      {
        
        st->predictor = (_pdfio_predictor_t)predictor;
        st->pbpixel   = (size_t)(bpc * colors + 7) / 8;
        st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;
        if (predictor >= 10)
          st->pbsize ++;		

        if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)
        {
          _pdfioFileError(st->pdf, "Unable to allocate %lu bytes for Predictor buffers.", (unsigned long)st->pbsize);
	  free(st->prbuffer);
	  free(st->psbuffer);
	  free(st);
	  return (NULL);
        }
      }
      else st->predictor = _PDFIO_PREDICTOR_NONE;

      if (sizeof(st->cbuffer) > st->remaining)
	rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);
      else rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));

      if (rbytes <= 0)
      {
	_pdfioFileError(st->pdf, "Unable to read bytes for stream.");
	free(st->prbuffer);
	free(st->psbuffer);
	free(st);
	return (NULL);
      }

      if (st->crypto_cb)
        rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);

      st->flate.next_in  = (Bytef *)st->cbuffer;
      st->flate.avail_in = (uInt)rbytes;

      if (st->cbuffer[0] == 0x0a)
      {
        st->flate.next_in ++;		
        st->flate.avail_in --;
      }

      PDFIO_DEBUG("_pdfioStreamOpen: avail_in=%u, cbuffer=<%02X%02X%02X%02X%02X%02X%02X%02X...>\n", st->flate.avail_in, st->cbuffer[0], st->cbuffer[1], st->cbuffer[2], st->cbuffer[3], st->cbuffer[4], st->cbuffer[5], st->cbuffer[6], st->cbuffer[7]);

      if ((status = inflateInit(&(st->flate))) != Z_OK)
      {
	_pdfioFileError(st->pdf, "Unable to start Flate filter: %s", zstrerror(status));
	free(st->prbuffer);
	free(st->psbuffer);
	free(st);
	return (NULL);
      }

      st->remaining -= st->flate.avail_in;
    }
    else if (!strcmp(filter, "LZWDecode"))
    {
      
      st->filter = PDFIO_FILTER_LZW;
    }
    else {
      
      _pdfioFileError(st->pdf, "Unsupported stream filter '/%s'.", filter);
      free(st);
      return (NULL);
    }
  }
  else {
    
    st->filter = PDFIO_FILTER_NONE;
  }

  return (st);
}






ssize_t					 pdfioStreamPeek(pdfio_stream_t *st, void           *buffer, size_t         bytes)


{
  size_t	remaining;		


  
  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)
    return (-1);

  
  if ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)
  {
    
    ssize_t	rbytes;			

    if (remaining > 0)
      memmove(st->buffer, st->bufptr, remaining);

    st->bufptr = st->buffer;
    st->bufend = st->buffer + remaining;

    if ((rbytes = stream_read(st, st->bufend, sizeof(st->buffer) - remaining)) > 0)
    {
      st->bufend += rbytes;
      remaining  += (size_t)rbytes;
    }
  }

  
  if (bytes > remaining)
    bytes = remaining;

  memcpy(buffer, st->bufptr, bytes);

  
  return ((ssize_t)bytes);
}






bool					 pdfioStreamPrintf( pdfio_stream_t *st, const char     *format, ...)



{
  char		buffer[8192];		
  va_list	ap;			


  
  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !format)
    return (false);

  
  va_start(ap, format);
  vsnprintf(buffer, sizeof(buffer), format, ap);
  va_end(ap);

  
  return (pdfioStreamWrite(st, buffer, strlen(buffer)));
}






bool					 pdfioStreamPutChar(pdfio_stream_t *st, int            ch)

{
  char	buffer[1];			


  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE)
    return (false);

  buffer[0] = (char)ch;

  return (pdfioStreamWrite(st, buffer, 1));
}






bool					 pdfioStreamPuts(pdfio_stream_t *st, const char     *s)

{
  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !s)
    return (false);
  else return (pdfioStreamWrite(st, s, strlen(s)));
}











ssize_t					 pdfioStreamRead( pdfio_stream_t *st, void           *buffer, size_t         bytes)



{
  char		*bufptr = (char *)buffer;
					
  size_t	remaining;		
  ssize_t	rbytes;			


  
  if (!st || st->pdf->mode != _PDFIO_MODE_READ || !buffer || !bytes)
    return (-1);

  
  while ((remaining = (size_t)(st->bufend - st->bufptr)) < bytes)
  {
    memcpy(bufptr, st->bufptr, remaining);
    bufptr += remaining;
    bytes -= remaining;

    if (bytes >= sizeof(st->buffer))
    {
      
      if ((rbytes = stream_read(st, bufptr, bytes)) > 0)
        bufptr += rbytes;

      bytes      = 0;
      st->bufptr = st->bufend = st->buffer;
      break;
    }
    else if ((rbytes = stream_read(st, st->buffer, sizeof(st->buffer))) > 0)
    {
      st->bufptr = st->buffer;
      st->bufend = st->buffer + rbytes;
    }
    else {
      st->bufptr = st->bufend = st->buffer;
      bytes = 0;
      break;
    }
  }

  
  if (bytes > 0)
  {
    memcpy(bufptr, st->bufptr, bytes);
    bufptr     += bytes;
    st->bufptr += bytes;
  }

  
  return (bufptr - (char *)buffer);
}






bool					 pdfioStreamWrite( pdfio_stream_t *st, const void     *buffer, size_t         bytes)



{
  size_t		pbpixel,	 pbline, remaining;

  const unsigned char	*bufptr,	 *bufsecond;
  unsigned char		*sptr,		 *pptr;


  PDFIO_DEBUG("pdfioStreamWrite(st=%p, buffer=%p, bytes=%lu)\n", st, buffer, (unsigned long)bytes);

  
  if (!st || st->pdf->mode != _PDFIO_MODE_WRITE || !buffer || !bytes)
    return (false);

  
  if (st->filter == PDFIO_FILTER_NONE)
  {
    
    if (st->crypto_cb)
    {
      
      uint8_t	temp[8192];		
      size_t	cbytes,			 outbytes;

      bufptr = (const unsigned char *)buffer;

      while (bytes > 0)
      {
        if (st->bufptr > st->buffer || bytes < 16)
        {
          
          if ((cbytes = bytes) > (size_t)(st->bufend - st->bufptr))
            cbytes = (size_t)(st->bufend - st->bufptr);

          memcpy(st->bufptr, bufptr, cbytes);
          st->bufptr += cbytes;
          if (st->bufptr >= st->bufend)
          {
            
	    outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, (uint8_t *)st->buffer, sizeof(st->buffer));
	    if (!_pdfioFileWrite(st->pdf, temp, outbytes))
	      return (false);

	    st->bufptr = st->buffer;
          }
        }
        else {
          
          if ((cbytes = bytes) > sizeof(temp))
            cbytes = sizeof(temp);
          if (cbytes & 15)
          {
            
            cbytes &= (size_t)~15;
          }

	  outbytes = (st->crypto_cb)(&st->crypto_ctx, temp, bufptr, cbytes);
	  if (!_pdfioFileWrite(st->pdf, temp, outbytes))
	    return (false);
        }

        bytes -= cbytes;
        bufptr += cbytes;
      }

      return (true);
    }
    else {
      
      return (_pdfioFileWrite(st->pdf, buffer, bytes));
    }
  }

  pbline = st->pbsize - 1;

  if (st->predictor == _PDFIO_PREDICTOR_NONE)
  {
    
    return (stream_write(st, buffer, bytes));
  }
  else if ((bytes % pbline) != 0)
  {
    _pdfioFileError(st->pdf, "Write buffer size must be a multiple of a complete row.");
    return (false);
  }

  pbpixel   = st->pbpixel;
  bufptr    = (const unsigned char *)buffer;
  bufsecond = bufptr + pbpixel;

  while (bytes > 0)
  {
    
    if (st->predictor == _PDFIO_PREDICTOR_PNG_AUTO)
      st->psbuffer[0] = 4;		
    else st->psbuffer[0] = (unsigned char)(st->predictor - 10);

    
    sptr = st->psbuffer + 1;
    pptr = st->prbuffer;

    switch (st->predictor)
    {
      default :
          
	  return (false);

      case _PDFIO_PREDICTOR_PNG_NONE :
          
          memcpy(sptr, buffer, pbline);
          break;

      case _PDFIO_PREDICTOR_PNG_SUB :
	  
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - bufptr[-(int)pbpixel];
	    else *sptr = *bufptr;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_UP :
	  
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    *sptr = *bufptr - *pptr;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_AVERAGE :
          
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - (bufptr[-(int)pbpixel] + *pptr) / 2;
	    else *sptr = *bufptr - *pptr / 2;
	  }
	  break;

      case _PDFIO_PREDICTOR_PNG_PAETH :
      case _PDFIO_PREDICTOR_PNG_AUTO :
          
	  for (remaining = pbline; remaining > 0; remaining --, bufptr ++, sptr ++, pptr ++)
	  {
	    if (bufptr >= bufsecond)
	      *sptr = *bufptr - stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);
	    else *sptr = *bufptr - stream_paeth(0, *pptr, 0);
	  }
	  break;
    }

    
    if (!stream_write(st, st->psbuffer, st->pbsize))
      return (false);

    memcpy(st->prbuffer, buffer, pbline);
    bytes -= pbline;
  }

  return (true);
}






static unsigned char			 stream_paeth(unsigned char a, unsigned char b, unsigned char c)


{
  int	p = a + b - c;			
  int	pa = abs(p - a);		
  int	pb = abs(p - b);		
  int	pc = abs(p - c);		

  return ((pa <= pb && pa <= pc) ? a : (pb <= pc) ? b : c);
}






static ssize_t				 stream_read(pdfio_stream_t *st, char           *buffer, size_t         bytes)


{
  ssize_t	rbytes;			


  if (st->filter == PDFIO_FILTER_NONE)
  {
    
    if (bytes > st->remaining)
      rbytes = _pdfioFileRead(st->pdf, buffer, st->remaining);
    else rbytes = _pdfioFileRead(st->pdf, buffer, bytes);

    if (rbytes > 0)
    {
      st->remaining -= (size_t)rbytes;

      if (st->crypto_cb)
        (st->crypto_cb)(&st->crypto_ctx, (uint8_t *)buffer, (uint8_t *)buffer, (size_t)rbytes);
    }

    return (rbytes);
  }
  else if (st->filter == PDFIO_FILTER_FLATE)
  {
    
    int	status;				

    if (st->predictor == _PDFIO_PREDICTOR_NONE)
    {
      
      PDFIO_DEBUG("stream_read: No predictor.\n");

      if (st->flate.avail_in == 0)
      {
	
	if (sizeof(st->cbuffer) > st->remaining)
	  rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);
	else rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));

	if (rbytes <= 0)
	  return (-1);			

	if (st->crypto_cb)
	  rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);

	st->remaining      -= (size_t)rbytes;
	st->flate.next_in  = (Bytef *)st->cbuffer;
	st->flate.avail_in = (uInt)rbytes;
      }

      st->flate.next_out  = (Bytef *)buffer;
      st->flate.avail_out = (uInt)bytes;

      if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)
      {
	_pdfioFileError(st->pdf, "Unable to decompress stream data: %s", zstrerror(status));
	return (-1);
      }

      return (st->flate.next_out - (Bytef *)buffer);
    }
    else if (st->predictor == _PDFIO_PREDICTOR_TIFF2)
    {
      size_t		pbpixel = st->pbpixel,  remaining = st->pbsize;

					
      unsigned char	*bufptr = (unsigned char *)buffer,  *bufsecond = (unsigned char *)buffer + pbpixel,  *sptr = st->psbuffer;



					

      PDFIO_DEBUG("stream_read: TIFF predictor 2.\n");

      if (bytes < st->pbsize)
      {
        _pdfioFileError(st->pdf, "Read buffer too small for stream.");
        return (-1);
      }

      st->flate.next_out  = (Bytef *)sptr;
      st->flate.avail_out = (uInt)st->pbsize;

      while (st->flate.avail_out > 0)
      {
	if (st->flate.avail_in == 0)
	{
	  
	  if (sizeof(st->cbuffer) > st->remaining)
	    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);
	  else rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));

	  if (rbytes <= 0)
	    return (-1);		

	  if (st->crypto_cb)
	    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);

	  st->remaining      -= (size_t)rbytes;
	  st->flate.next_in  = (Bytef *)st->cbuffer;
	  st->flate.avail_in = (uInt)rbytes;
	}

	if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)
	{
	  _pdfioFileError(st->pdf, "Unable to decompress stream data: %s", zstrerror(status));
	  return (-1);
	}
	else if (status == Z_STREAM_END)
	  break;
      }

      if (st->flate.avail_out > 0)
        return (-1);			

      for (; bufptr < bufsecond; remaining --, sptr ++)
	*bufptr++ = *sptr;
      for (; remaining > 0; remaining --, sptr ++, bufptr ++)
	*bufptr = *sptr + bufptr[-(int)pbpixel];

      return ((ssize_t)st->pbsize);
    }
    else {
      
      size_t		pbpixel = st->pbpixel,  remaining = st->pbsize - 1;

					
      unsigned char	*bufptr = (unsigned char *)buffer,  *bufsecond = (unsigned char *)buffer + pbpixel,  *sptr = st->psbuffer + 1,  *pptr = st->prbuffer;





					

      PDFIO_DEBUG("stream_read: PNG predictor.\n");

      if (bytes < (st->pbsize - 1))
      {
        _pdfioFileError(st->pdf, "Read buffer too small for stream.");
        return (-1);
      }

      st->flate.next_out  = (Bytef *)sptr - 1;
      st->flate.avail_out = (uInt)st->pbsize;

      while (st->flate.avail_out > 0)
      {
	if (st->flate.avail_in == 0)
	{
	  
	  if (sizeof(st->cbuffer) > st->remaining)
	    rbytes = _pdfioFileRead(st->pdf, st->cbuffer, st->remaining);
	  else rbytes = _pdfioFileRead(st->pdf, st->cbuffer, sizeof(st->cbuffer));

	  if (rbytes <= 0)
	    return (-1);		

	  if (st->crypto_cb)
	    rbytes = (ssize_t)(st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, (size_t)rbytes);

	  st->remaining      -= (size_t)rbytes;
	  st->flate.next_in  = (Bytef *)st->cbuffer;
	  st->flate.avail_in = (uInt)rbytes;
	}

	if ((status = inflate(&(st->flate), Z_NO_FLUSH)) < Z_OK)
	{
	  _pdfioFileError(st->pdf, "Unable to decompress stream data: %s", zstrerror(status));
	  return (-1);
	}
	else if (status == Z_STREAM_END)
	  break;
      }

      if (st->flate.avail_out > 0)
      {
	
        PDFIO_DEBUG("stream_read: Early EOF (remaining=%u, avail_in=%d, avail_out=%d, data_type=%d, next_in=<%02X%02X%02X%02X...>).\n", (unsigned)st->remaining, st->flate.avail_in, st->flate.avail_out, st->flate.data_type, st->flate.next_in[0], st->flate.next_in[1], st->flate.next_in[2], st->flate.next_in[3]);
        return (-1);
      }

      
      PDFIO_DEBUG("stream_read: Line %02X %02X %02X %02X %02X.\n", sptr[-1], sptr[0], sptr[0], sptr[2], sptr[3]);

      switch (sptr[-1])
      {
        case 0 : 
        case 10 : 
            memcpy(buffer, sptr, remaining);
            break;
        case 1 : 
        case 11 : 
            for (; bufptr < bufsecond; remaining --, sptr ++)
              *bufptr++ = *sptr;
            for (; remaining > 0; remaining --, sptr ++, bufptr ++)
              *bufptr = *sptr + bufptr[-(int)pbpixel];
            break;
        case 2 : 
        case 12 : 
            for (; remaining > 0; remaining --, sptr ++, pptr ++)
              *bufptr++ = *sptr + *pptr;
            break;
        case 3 : 
        case 13 : 
	    for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)
	      *bufptr++ = *sptr + *pptr / 2;
	    for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)
	      *bufptr = *sptr + (bufptr[-(int)pbpixel] + *pptr) / 2;
            break;
        case 4 : 
        case 14 : 
            for (; bufptr < bufsecond; remaining --, sptr ++, pptr ++)
              *bufptr++ = *sptr + stream_paeth(0, *pptr, 0);
            for (; remaining > 0; remaining --, sptr ++, pptr ++, bufptr ++)
              *bufptr = *sptr + stream_paeth(bufptr[-(int)pbpixel], *pptr, pptr[-(int)pbpixel]);
            break;

        default :
            _pdfioFileError(st->pdf, "Bad PNG filter %d in data stream.", sptr[-1]);
            return (-1);
      }

      
      memcpy(st->prbuffer, buffer, st->pbsize - 1);

      
      return ((ssize_t)(st->pbsize - 1));
    }
  }

  
  return (-1);
}






static bool				 stream_write(pdfio_stream_t *st, const void     *buffer, size_t         bytes)


{
  int	status;				


  
  st->flate.avail_in = (uInt)bytes;
  st->flate.next_in  = (Bytef *)buffer;

  while (st->flate.avail_in > 0)
  {
    if (st->flate.avail_out < (sizeof(st->cbuffer) / 8))
    {
      
      size_t	cbytes = sizeof(st->cbuffer) - st->flate.avail_out, outbytes;

      if (st->crypto_cb)
      {
        
        outbytes = (st->crypto_cb)(&st->crypto_ctx, st->cbuffer, st->cbuffer, cbytes & (size_t)~15);
      }
      else {
        outbytes = cbytes;
      }



      if (!_pdfioFileWrite(st->pdf, st->cbuffer, outbytes))
        return (false);

      if (cbytes > outbytes)
      {
        cbytes -= outbytes;
        memmove(st->cbuffer, st->cbuffer + outbytes, cbytes);
      }
      else {
        cbytes = 0;
      }

      st->flate.next_out  = (Bytef *)st->cbuffer + cbytes;
      st->flate.avail_out = (uInt)(sizeof(st->cbuffer) - cbytes);
    }

    
    status = deflate(&st->flate, Z_NO_FLUSH);

    if (status < Z_OK && status != Z_BUF_ERROR)
    {
      _pdfioFileError(st->pdf, "Flate compression failed: %s", zstrerror(status));
      return (false);
    }
  }

  return (true);
}






static const char *			 zstrerror(int error)
{
  switch (error)
  {
    case Z_OK :
        return ("No error.");

    case Z_STREAM_END :
        return ("End of stream.");

    case Z_NEED_DICT :
        return ("Need a huffman dictinary.");

    case Z_ERRNO :
        return (strerror(errno));

    case Z_STREAM_ERROR :
        return ("Stream error.");

    case Z_DATA_ERROR :
        return ("Data error.");

    case Z_MEM_ERROR :
        return ("Out of memory.");

    case Z_BUF_ERROR :
        return ("Out of buffers.");

    case Z_VERSION_ERROR :
        return ("Mismatched zlib library.");

    default :
        return ("Unknown error.");
  }
}
