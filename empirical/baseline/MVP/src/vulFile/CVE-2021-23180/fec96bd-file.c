






































typedef struct		 {
  char	*name;				
  char	*url;				
} cache_t;




char	proxy_scheme[32] = "",		 proxy_host[HTTP_MAX_URI] = "";
int	proxy_port = 0;			
http_t	*http = NULL;			
size_t	web_files = 0,			 web_alloc = 0;
cache_t	*web_cache = NULL;		
int	no_local = 0;			
char	cookies[1024] = "";		
char	referer_url[HTTP_MAX_VALUE] = "";
					




const char *			 file_basename(const char *s)
{
  const char	*basename;	
  static char	buf[1024];	


  if (s == NULL)
    return (NULL);

  if ((basename = strrchr(s, '/')) != NULL)
    basename ++;
  else if ((basename = strrchr(s, '\\')) != NULL)
    basename ++;
  else basename = (char *)s;

  if (basename[0] == '#')
    return (NULL);

  if (strchr(basename, '#') == NULL)
    return (basename);

  strlcpy(buf, basename, sizeof(buf));
  *(char *)strchr(buf, '#') = '\0';

  return (buf);
}




void file_cleanup(void)
{
  size_t	i;			
  char		filename[1024];		
  struct stat	fileinfo;		
  size_t	remotebytes;		
  const char	*tmpdir;		

  char		tmppath[1024];		

  const char	*debug;			


  if (http)
  {
    httpClose(http);
    http = NULL;
  }


  if ((tmpdir = getenv("TEMP")) == NULL)
  {
    GetTempPath(sizeof(tmppath), tmppath);
    tmpdir = tmppath;
  }

  if ((tmpdir = getenv("TMPDIR")) == NULL)
    tmpdir = "/var/tmp";


 

  debug = getenv("HTMLDOC_DEBUG");

  if (debug && (strstr(debug, "all") != NULL || strstr(debug, "remotebytes") != NULL))
  {
    for (i = 0, remotebytes = 0; i < web_files; i ++)
      if (web_cache[i].url)
      {
	snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));
        if (!stat(filename, &fileinfo))
	  remotebytes += (size_t)fileinfo.st_size;
      }

    progress_error(HD_ERROR_NONE, "REMOTEBYTES: %ld", (long)remotebytes);
  }

 

  if (debug && (strstr(debug, "all") != NULL || strstr(debug, "tempfiles") != NULL))
  {
   

    progress_error(HD_ERROR_NONE, "DEBUG: Temporary File Summary");
    progress_error(HD_ERROR_NONE, "DEBUG:");
    progress_error(HD_ERROR_NONE, "DEBUG: URL                             Filename");
    progress_error(HD_ERROR_NONE, "DEBUG: ------------------------------- ---------------------");

    for (i = 0; i < web_files; i ++)
    {
      snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));
      progress_error(HD_ERROR_NONE, "DEBUG: %-31.31s %s\n", web_cache[i].url ? web_cache[i].url : "none", filename);
    }

    progress_error(HD_ERROR_NONE, "DEBUG:");

    return;
  }

  while (web_files > 0)
  {
    snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)web_files);

    if (unlink(filename))
      progress_error(HD_ERROR_DELETE_ERROR, "Unable to delete temporary file \"%s\": %s", filename, strerror(errno));


    web_files --;

    if (web_cache[web_files].name)
      free(web_cache[web_files].name);
    if (web_cache[web_files].url)
      free(web_cache[web_files].url);
  }

  if (web_alloc)
  {
    free(web_cache);

    web_alloc = 0;
    web_cache = NULL;
  }
}




void file_cookies(const char *s)
{
  if (s)
    strlcpy(cookies, s, sizeof(cookies));
  else cookies[0] = '\0';
}




const char *			 file_directory(const char *s)
{
  char		*dir;		
  static char	buf[1024];	


  if (s == NULL || !strncmp(s, "data:", 5))
    return (NULL);

  if (strncmp(s, "http://", 7) == 0 || strncmp(s, "https://", 8) == 0)
  {
   

    char	scheme[HTTP_MAX_URI], username[HTTP_MAX_URI], hostname[HTTP_MAX_URI], resource[HTTP_MAX_URI];


    int		port;


    httpSeparateURI(HTTP_URI_CODING_ALL, s, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, resource, sizeof(resource));

    if ((dir = strrchr(resource, '/')) != NULL)
      *dir = '\0';

    httpAssembleURI(HTTP_URI_CODING_ALL, buf, sizeof(buf), scheme, username, hostname, port, resource);
  }
  else {
   

    strlcpy(buf, s, sizeof(buf));

    if ((dir = strrchr(buf, '/')) != NULL)
      *dir = '\0';
    else if ((dir = strrchr(buf, '\\')) != NULL)
      *dir = '\0';
    else return (".");

    if (strncmp(buf, "file:", 5) == 0)
      hd_strcpy(buf, buf + 5);

    if (!buf[0])
      
      strlcpy(buf, "/", sizeof(buf));
  }

  return (buf);
}




const char *			 file_extension(const char *s)
{
  const char	*extension;	
  static char	buf[1024];	


  if (s == NULL)
    return (NULL);
  else if (!strncmp(s, "data:image/bmp;", 15))
    return ("bmp");
  else if (!strncmp(s, "data:image/gif;", 15))
    return ("gif");
  else if (!strncmp(s, "data:image/jpeg;", 16))
    return ("jpg");
  else if (!strncmp(s, "data:image/png;", 15))
    return ("png");
  else if ((extension = strrchr(s, '/')) != NULL)
    extension ++;
  else if ((extension = strrchr(s, '\\')) != NULL)
    extension ++;
  else extension = s;

  if ((extension = strrchr(extension, '.')) == NULL)
    return ("");
  else extension ++;

  if (strchr(extension, '#') == NULL)
    return (extension);

  strlcpy(buf, extension, sizeof(buf));

  *(char *)strchr(buf, '#') = '\0';

  return (buf);
}




static const char *			 file_find_check(const char *filename)
{
  int		i;			
  int		retry;			
  char		scheme[HTTP_MAX_URI],	 username[HTTP_MAX_URI], hostname[HTTP_MAX_URI], resource[HTTP_MAX_URI];


  int		port;			
  const char	*connscheme;		
  const char	*connhost;		
  int		connport;		
  char		connpath[HTTP_MAX_URI],	 connauth[HTTP_MAX_VALUE];
  http_status_t	status;			
  FILE		*fp;			
  ssize_t	bytes,			 count;
  off_t		total;			
  char		tempname[HTTP_MAX_URI];	


  DEBUG_printf(("file_find_check(filename=\"%s\")\n", filename));

  if (strncmp(filename, "http:", 5) == 0 || strncmp(filename, "//", 2) == 0)
    strlcpy(scheme, "http", sizeof(scheme));
  else if (strncmp(filename, "https:", 6) == 0)
    strlcpy(scheme, "https", sizeof(scheme));
  else if (strncmp(filename, "data:", 5) == 0)
    strlcpy(scheme, "data", sizeof(scheme));
  else strlcpy(scheme, "file", sizeof(scheme));

  if (strcmp(scheme, "file") == 0)
  {
   

    if (no_local)
      return (NULL);

   

    if (!access(filename, 0))
    {
      DEBUG_printf(("file_find_check: Returning \"%s\"!\n", filename));
      return (filename);
    }
  }
  else if (!strcmp(scheme, "data"))
  {
   

    const char	*data;			
    int		len;			
    char	buffer[8192];		

    for (i = 0; i < (int)web_files; i ++)
    {
      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)
      {
        DEBUG_printf(("file_find_check: Returning \"%s\" for \"%s\".\n", web_cache[i].name, filename));
        return (web_cache[i].name);
      }
    }

    if ((data = strstr(filename, ";base64,")) != NULL)
    {
      len = sizeof(buffer);
      httpDecode64_2(buffer, &len, data + 8);

      if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)
      {
	progress_hide();
	progress_error(HD_ERROR_WRITE_ERROR, "Unable to create temporary file \"%s\": %s", tempname, strerror(errno));
	return (NULL);
      }

      fwrite(buffer, 1, (size_t)len, fp);
      fclose(fp);

      progress_hide();

      web_cache[web_files - 1].url = strdup(filename);

      DEBUG_printf(("file_find_check: Returning \"%s\" for \"%s\".\n", tempname, filename));

      return (web_cache[web_files - 1].name);
    }
  }
  else {
   

    for (i = 0; i < (int)web_files; i ++)
    {
      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)
      {
        DEBUG_printf(("file_find_check: Returning \"%s\" for \"%s\".\n", web_cache[i].name, filename));
        return (web_cache[i].name);
      }
    }

    httpSeparateURI(HTTP_URI_CODING_ALL, filename, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, resource, sizeof(resource));


    for (status = HTTP_STATUS_ERROR, retry = 0; status != HTTP_STATUS_OK && retry < 5; retry ++)
    {
      if (proxy_port)
      {
        
        connscheme = proxy_scheme;
        connhost   = proxy_host;
        connport   = proxy_port;
        httpAssembleURI(HTTP_URI_CODING_ALL, connpath, sizeof(connpath), scheme, NULL, hostname, port, resource);
      }
      else {
        
        connscheme = scheme;
        connhost   = hostname;
        connport   = port;
        strlcpy(connpath, resource, sizeof(connpath));
      }

      if (connport != httpAddrPort(httpGetAddress(http)) ||  (!strcmp(connscheme, "https") && !httpIsEncrypted(http)) || (!strcmp(connscheme, "http") && httpIsEncrypted(http)) ||  strcasecmp(httpGetHostname(http, tempname, sizeof(tempname)), hostname))




      {
        httpClose(http);
        http = NULL;
      }

      if (http == NULL)
      {
        progress_show("Connecting to %s...", connhost);

        http_encryption_t encryption = !strcmp(connscheme, "http") ? HTTP_ENCRYPTION_IF_REQUESTED : HTTP_ENCRYPTION_ALWAYS;

        if ((http = httpConnect2(connhost, connport, NULL, AF_UNSPEC, encryption, 1, 30000, NULL)) == NULL)
	{
          progress_hide();
          progress_error(HD_ERROR_NETWORK_ERROR, "Unable to connect to %s:%d", connhost, connport);
          return (NULL);
        }
      }

      progress_show("Getting %s...", connpath);

      httpClearFields(http);
      httpSetField(http, HTTP_FIELD_HOST, hostname);
      httpSetField(http, HTTP_FIELD_CONNECTION, "Keep-Alive");
      httpSetField(http, HTTP_FIELD_REFERER, referer_url);

      if (username[0])
      {
        strlcpy(connauth, "Basic ", sizeof(connauth));
        httpEncode64_2(connauth + 6, sizeof(connauth) - 6, username, strlen(username));
        httpSetField(http, HTTP_FIELD_AUTHORIZATION, connauth);
      }

      if (cookies[0])
        httpSetCookie(http, cookies);

      if (!httpGet(http, connpath))
      {
	while ((status = httpUpdate(http)) == HTTP_CONTINUE);
      }
      else status = HTTP_ERROR;

      if (status >= HTTP_STATUS_MULTIPLE_CHOICES && status < HTTP_STATUS_BAD_REQUEST)
      {
        
        const char *newurl = httpGetField(http, HTTP_FIELD_LOCATION);
					
        char	newresource[256];	

        progress_show("Redirecting to %s...", newurl);
	httpSeparateURI(HTTP_URI_CODING_ALL, newurl, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, newresource, sizeof(newresource));

        
        if (strchr(newurl + strlen(scheme) + 3, '/'))
          strlcpy(resource, newresource, sizeof(resource));

        
	httpFlush(http);
      }
    }

    if (status != HTTP_OK)
    {
      progress_hide();
      progress_error((HDerror)status, "%s (%s)", httpStatus(status), filename);
      httpFlush(http);
      return (NULL);
    }

    if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)
    {
      progress_hide();
      progress_error(HD_ERROR_WRITE_ERROR, "Unable to create temporary file \"%s\": %s", tempname, strerror(errno));

      httpFlush(http);
      return (NULL);
    }

    if ((total = httpGetLength2(http)) == 0)
      total = 8192;

    count = 0;
    while ((bytes = httpRead2(http, resource, sizeof(resource))) > 0)
    {
      count += bytes;
      progress_update((100 * count / total) % 101);
      fwrite(resource, 1, (size_t)bytes, fp);
    }

    progress_hide();

    fclose(fp);

    web_cache[web_files - 1].url = strdup(filename);

    DEBUG_printf(("file_find_check: Returning \"%s\" for \"%s\".\n", tempname, filename));

    return (web_cache[web_files - 1].name);
  }

  return (NULL);
}




const char *				 file_find(const char *path, const char *s)

{
  int		i;			
  char		*temp;			
  const char	*sptr;			
  int		ch;			
  char		basename[HTTP_MAX_URI];	
  const char	*realname;		
  static char	filename[HTTP_MAX_URI];	


 

  if (s == NULL)
    return (NULL);

  DEBUG_printf(("file_find(path=\"%s\", s=\"%s\")\n", path ? path : "(null)", s));

 

  for (i = 0; i < (int)web_files; i ++)
  {
    if (strcmp(s, web_cache[i].name) == 0)
    {
      DEBUG_printf(("file_find: Returning cache file \"%s\"!\n", s));
      return (web_cache[i].name);
    }
  }

  DEBUG_printf(("file_find: \"%s\" not in web cache of %d files...\n", s, (int)web_files));

 

  if (strchr(s, '%') == NULL)
  {
    strlcpy(basename, s, sizeof(basename));
  }
  else {
    for (sptr = s, temp = basename;
	 *sptr && temp < (basename + sizeof(basename) - 1);)
    {
      if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))
      {
       

	if (isalpha(sptr[1]))
	  ch = (tolower(sptr[1]) - 'a' + 10) << 4;
	else ch = (sptr[1] - '0') << 4;

	if (isalpha(sptr[2]))
	  ch |= tolower(sptr[2]) - 'a' + 10;
	else ch |= sptr[2] - '0';

	*temp++ = (char)ch;

	sptr += 3;
      }
      else *temp++ = *sptr++;
    }

    *temp = '\0';
  }

 

  if (path != NULL && !path[0])
  {
    DEBUG_puts("file_find: Resetting path to NULL since path is empty...");
    path = NULL;
  }

  if (strncmp(s, "http:", 5) == 0 || strncmp(s, "https:", 6) == 0 || strncmp(s, "//", 2) == 0)

  {
    DEBUG_puts("file_find: Resetting path to NULL since filename is a URL...");
    path = NULL;
  }

 

  if (path != NULL)
  {
    filename[sizeof(filename) - 1] = '\0';

    while (*path != '\0')
    {
     

      temp = filename;

      while (*path != ';' && *path && temp < (filename + sizeof(filename) - 1))
	*temp++ = *path++;

      if (*path == ';')
	path ++;

     

      if (temp > filename && temp < (filename + sizeof(filename) - 1) && basename[0] != '/')
	*temp++ = '/';

      strlcpy(temp, basename, sizeof(filename) - (size_t)(temp - filename));

     

      if ((realname = file_find_check(filename)) != NULL)
	return (realname);
    }
  }

  return (file_find_check(s));
}




char *				 file_gets(char  *buf, int   buflen, FILE  *fp)


{
  int		ch;		
  char		*ptr,		 *end;


 

  if (fp == NULL || buf == NULL || buflen < 2)
    return (NULL);

 

  ptr = buf;
  end = buf + buflen - 1;

  for (;;)
  {
    if ((ch = getc(fp)) == EOF)
      break;
    else if (ch == '\r')
    {
     

      int nextch = getc(fp);

      if (nextch == EOF || nextch == '\n')
        break;

     

      ungetc(nextch, fp);

      break;
    }
    else if (ch == '\n')
      break;
    else if (ch == '\\')
    {
     

      int nextch = getc(fp);

      if (nextch == EOF)
        break;
      else if (nextch == '\r')
      {
        nextch = getc(fp);

	if (nextch == EOF)
	  break;
	else if (nextch != '\n')
	  ungetc(nextch, fp);
      }
      else if (nextch != '\n' && ptr < end)
        *ptr++ = (char)nextch;
    }
    else if (ptr < end)
      *ptr++ = (char)ch;
  }

  *ptr = '\0';

  if (ch != EOF || ptr > buf)
    return (buf);
  else return (NULL);
}




const char *				 file_localize(const char *filename, const char *newcwd)

{
  const char	*newslash;		
  char		*slash;			
  char		cwd[1024];		
  char		temp[1024];		
  static char	newfilename[1024];	


  if (filename[0] == '\0')
    return ("");

  if (file_method(filename))
    return (filename);

  getcwd(cwd, sizeof(cwd));
  if (newcwd == NULL)
    newcwd = cwd;


  if (filename[0] != '/' && filename[0] != '\\' && !(isalpha(filename[0]) && filename[1] == ':'))


  if (filename[0] != '/')

  {
    for (newslash = filename; strncmp(newslash, "../", 3) == 0; newslash += 3)

    {
      if ((slash = strrchr(cwd, '/')) == NULL)
        slash = strrchr(cwd, '\\');
      if (slash != NULL)
        *slash = '\0';
    }

      if ((slash = strrchr(cwd, '/')) != NULL)
        *slash = '\0';


    snprintf(temp, sizeof(temp), "%s/%s", cwd, newslash);
  }
  else strlcpy(temp, filename, sizeof(temp));

  for (slash = temp, newslash = newcwd;
       *slash != '\0' && *newslash != '\0';
       slash ++, newslash ++)
    if ((*slash == '/' || *slash == '\\') && (*newslash == '/' || *newslash == '\\'))
      continue;
    else if (*slash != *newslash)
      break;

  while (*slash != '/' && *slash != '\\' && slash > temp)
    slash --;

  if (*slash == '/' || *slash == '\\')
    slash ++;


  if (isalpha(slash[0]) && slash[1] == ':')
    return ((char *)filename); 


  if (*newslash != '\0')
    while (*newslash != '/' && *newslash != '\\' && newslash > newcwd)
      newslash --;

  newfilename[0] = '\0';

  while (*newslash != '\0')
  {
    if (*newslash == '/' || *newslash == '\\')
      strlcat(newfilename, "../", sizeof(newfilename));
    newslash ++;
  }

  strlcat(newfilename, slash, sizeof(newfilename));

  return (newfilename);
}




const char *			 file_method(const char *s)
{
  if (strncmp(s, "data:", 5) == 0)
    return ("data");
  else if (strncmp(s, "http:", 5) == 0)
    return ("http");
  else if (strncmp(s, "https:", 6) == 0)
    return ("https");
  else if (strncmp(s, "ftp:", 4) == 0)
    return ("ftp");
  else if (strncmp(s, "mailto:", 7) == 0)
    return ("mailto");
  else return (NULL);
}




void file_nolocal(void)
{
  no_local = 1;
}




void file_proxy(const char *url)
{
   char	scheme[HTTP_MAX_URI],	 username[HTTP_MAX_URI], hostname[HTTP_MAX_URI], resource[HTTP_MAX_URI];


  int	port;			


  if (url == NULL || url[0] == '\0')
  {
    proxy_host[0] = '\0';
    proxy_port    = 0;
  }
  else {
    httpSeparateURI(HTTP_URI_CODING_ALL, url, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, resource, sizeof(resource));


    if (strcmp(scheme, "http") == 0)
    {
      strlcpy(proxy_host, hostname, sizeof(proxy_host));
      proxy_port = port;
    }
  }
}




void file_referer(const char *referer)
{
  if (referer)
    strlcpy(referer_url, referer, sizeof(referer_url));
  else referer_url[0] = '\0';
}




const char *				 file_rlookup(const char *filename)
{
  int		i;			
  cache_t	*wc;			


  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)
    if (!strcmp(wc->name, filename))
      return (wc->url);

  return (filename);
}




const char *			 file_target(const char *s)
{
  const char	*basename;	
  const char	*target;	


  if (s == NULL)
    return (NULL);

  if ((basename = strrchr(s, '/')) != NULL)
    basename ++;
  else if ((basename = strrchr(s, '\\')) != NULL)
    basename ++;
  else basename = s;

  if ((target = strchr(basename, '#')) != NULL)
    return (target + 1);
  else return (NULL);
}




FILE *					 file_temp(char *name, int  len)

{
  cache_t	*temp;			
  FILE		*fp;			
  int		fd;			
  const char	*tmpdir;		

  char		tmppath[1024];		



 

  if (web_files >= web_alloc)
  {
    web_alloc += ALLOC_FILES;
    if (web_files == 0)
      temp = (cache_t *)malloc(sizeof(cache_t) * web_alloc);
    else temp = (cache_t *)realloc(web_cache, sizeof(cache_t) * web_alloc);

    if (temp == NULL)
    {
      progress_error(HD_ERROR_OUT_OF_MEMORY, "Unable to allocate memory for %d file entries - %s", (int)web_alloc, strerror(errno));

      web_alloc -= ALLOC_FILES;
      return (NULL);
    }

    web_cache = temp;
  }

 

  temp = web_cache + web_files;

  temp->name = NULL;
  temp->url  = NULL;
  web_files ++;


  if ((tmpdir = getenv("TEMP")) == NULL)
  {
    GetTempPath(sizeof(tmppath), tmppath);
    tmpdir = tmppath;
  }

  if ((tmpdir = getenv("TMPDIR")) == NULL)
    tmpdir = "/var/tmp";


  snprintf(name, (size_t)len, TEMPLATE, tmpdir, (long)getpid(), (int)web_files);

  if ((fd = open(name, OPENMODE, OPENPERM)) >= 0)
    fp = fdopen(fd, "w+b");
  else fp = NULL;

  if (!fp)
    web_files --;

  temp->name = strdup(name);

  return (fp);
}
