























static void LeaveStack(int signal);



static DWORD executeEventLoop(LPVOID thread_arg);




volatile int g_end_stack = 0;


int main(int argc, char *arg[]) {

	if (argc != 2) {
		fprintf(stderr, "Wrong number of command line parameters!\n");
		fprintf(stderr, "Usage: %s [interface index | interface name]\n", arg[0]);
		fprintf(stderr, "\te.g. ./OpENer \"Ethernet 2\"\n");
		exit(EXIT_FAILURE);
	}

	DoublyLinkedListInitialize(&connection_list, CipConnectionObjectListArrayAllocator, CipConnectionObjectListArrayFree);

	
	uint8_t iface_mac[6];
	if (kEipStatusError == IfaceGetMacAddress(arg[1], iface_mac)) {
		printf("Network interface %s not found.\n", arg[1]);
		exit(EXIT_FAILURE);
	}

	
	SetDeviceSerialNumber(123456789);

	
	srand(time(NULL));
	EipUint16 unique_connection_id = rand();

	
	CipStackInit(unique_connection_id);

	CipEthernetLinkSetMac(iface_mac);

	
	GetHostName(&g_tcpip.hostname);

	
	if (kEipStatusError == NvdataLoad()) {
		OPENER_TRACE_WARN("Loading of some NV data failed. Maybe the first start?\n");
	}

	
	EipStatus status = BringupNetwork(arg[1], g_tcpip.config_control, &g_tcpip.interface_configuration, &g_tcpip.hostname);


	if (status < 0) {
		OPENER_TRACE_ERR("BringUpNetwork() failed\n");
	}

	
	g_end_stack = 0;
	signal(SIGINT, LeaveStack);
	signal(SIGTERM, LeaveStack);

	
	CipDword network_config_method = g_tcpip.config_control & kTcpipCfgCtrlMethodMask;
	if (kTcpipCfgCtrlStaticIp == network_config_method) {
		OPENER_TRACE_INFO("Static network configuration done\n");
	}
	if (kTcpipCfgCtrlDhcp == network_config_method) {
		OPENER_TRACE_INFO("DHCP network configuration started\n");
		
		status = IfaceWaitForIp(arg[1], -1, &g_end_stack);
		OPENER_TRACE_INFO("DHCP wait for interface: status %d, g_end_stack=%d\n", status, g_end_stack);
		if (kEipStatusOk == status && 0 == g_end_stack) {
			
			status = IfaceGetConfiguration(arg[1], &g_tcpip.interface_configuration);
			if (status < 0) {
				OPENER_TRACE_WARN("Problems getting interface configuration\n");
			}
		}
	}


	
	if (!g_end_stack && kEipStatusOk == NetworkHandlerInitialize()) {

		(void)executeEventLoop(NULL);

		
		NetworkHandlerFinish();
	}

	
	ShutdownCipStack();

	
	(void)ShutdownNetwork(arg[1]);

	if (0 != g_end_stack) {
		printf("OpENer aborted by signal %d.\n", g_end_stack);
		return RET_SHOW_SIGNAL + g_end_stack;
	}

	return EXIT_SUCCESS;
}

static void LeaveStack(int signal) {
	if (SIGINT == signal || SIGTERM == signal) {
		g_end_stack = signal;
	}
	OPENER_TRACE_STATE("got signal %d\n", signal);
}

static DWORD executeEventLoop(LPVOID thread_arg) {
	
	while (0 == g_end_stack) {
		if (kEipStatusOk != NetworkHandlerProcessCyclic()) {
			break;
		}
	}
	return NO_ERROR;
}
