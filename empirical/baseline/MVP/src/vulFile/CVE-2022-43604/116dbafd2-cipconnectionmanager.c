


























const size_t g_kForwardOpenHeaderLength = 36; 
const size_t g_kLargeForwardOpenHeaderLength = 40; 

static const int g_kNumberOfConnectableObjects = 2 + OPENER_CIP_NUM_APPLICATION_SPECIFIC_CONNECTABLE_OBJECTS;

typedef struct {
  EipUint32 class_id;
  OpenConnectionFunction open_connection_function;
} ConnectionManagementHandling;



ConnectionManagementHandling g_connection_management_list[2 + OPENER_CIP_NUM_APPLICATION_SPECIFIC_CONNECTABLE_OBJECTS ];



CipConnectionObject g_dummy_connection_object;


EipUint32 g_incarnation_id;


EipStatus ForwardOpen(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);




EipStatus LargeForwardOpen(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);




EipStatus ForwardClose(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);




EipStatus GetConnectionOwner(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);




EipStatus GetConnectionData(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);


EipStatus SearchConnectionData(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);


void AssembleConnectionDataResponseMessage( CipMessageRouterResponse *message_router_response, CipConnectionObject *connection_object);


EipStatus AssembleForwardOpenResponse(CipConnectionObject *connection_object, CipMessageRouterResponse *message_router_response, EipUint8 general_status, EipUint16 extended_status);



EipStatus AssembleForwardCloseResponse(EipUint16 connection_serial_number, EipUint16 originatior_vendor_id, EipUint32 originator_serial_number, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, EipUint16 extended_error_code);






CipConnectionObject *CheckForExistingConnection( const CipConnectionObject *const connection_object);


EipStatus CheckElectronicKeyData(EipUint8 key_format, void *key_data, EipUint16 *extended_status);



EipUint8 ParseConnectionPath(CipConnectionObject *connection_object, CipMessageRouterRequest *message_router_request, EipUint16 *extended_error);


ConnectionManagementHandling *GetConnectionManagementEntry( const EipUint32 class_id);

void InitializeConnectionManagerData(void);

void AddNullAddressItem( CipCommonPacketFormatData *common_data_packet_format_data);


unsigned int GetPaddedLogicalPath(const EipUint8 **logical_path_segment) {
  unsigned int padded_logical_path = *(*logical_path_segment)++;

  if( (padded_logical_path & 3) == 0 ) {
    padded_logical_path = *(*logical_path_segment)++;
  } else if( (padded_logical_path & 3) == 1 ) {
    (*logical_path_segment)++; 
    padded_logical_path = *(*logical_path_segment)++;
    padded_logical_path |= *(*logical_path_segment)++ << 8;
  } else {
    OPENER_TRACE_ERR("illegal logical path segment\n");
  }
  return padded_logical_path;
}


CipUdint GetConnectionId(void) {

  static CipUint connection_id = 18;
  connection_id++;

  CipUint connection_id = NextXorShiftUint32();

  return (g_incarnation_id | (connection_id & 0x0000FFFF) );
}

void InitializeConnectionManager(CipClass *class) {

  CipClass *meta_class = class->class_instance.cip_class;

  InsertAttribute( (CipInstance *) class, 1, kCipUint, EncodeCipUint, NULL, (void *) &class->revision, kGetableSingleAndAll );
  InsertAttribute( (CipInstance *) class, 2, kCipUint, EncodeCipUint, NULL, (void *) &class->number_of_instances, kGetableSingleAndAll );
  InsertAttribute( (CipInstance *) class, 3, kCipUint, EncodeCipUint, NULL, (void *) &class->number_of_instances, kGetableSingle );
  InsertAttribute( (CipInstance *) class, 4, kCipUint, EncodeCipUint, NULL, (void *) &kCipUintZero, kNotSetOrGetable );
  InsertAttribute( (CipInstance *) class, 5, kCipUint, EncodeCipUint, NULL, (void *) &kCipUintZero, kNotSetOrGetable );
  InsertAttribute( (CipInstance *) class, 6, kCipUint, EncodeCipUint, NULL, (void *) &meta_class->highest_attribute_number, kGetableSingleAndAll );

  InsertAttribute( (CipInstance *) class, 7, kCipUint, EncodeCipUint, NULL, (void *) &class->highest_attribute_number, kGetableSingleAndAll );


  InsertService(meta_class, kGetAttributeAll, &GetAttributeAll, "GetAttributeAll");


  InsertService(meta_class, kGetAttributeSingle, &GetAttributeSingle, "GetAttributeSingle");



}

EipStatus ConnectionManagerInit(EipUint16 unique_connection_id) {
  InitializeConnectionManagerData();

  CipClass *connection_manager = CreateCipClass(kCipConnectionManagerClassCode,  0, 7, 2, 0, 14, 8, 1, "connection manager", 1, &InitializeConnectionManager);









  if(connection_manager == NULL) {
    return kEipStatusError;
  }
  InsertService(connection_manager, kGetAttributeSingle, &GetAttributeSingle, "GetAttributeSingle");


  InsertService(connection_manager, kGetAttributeAll, &GetAttributeAll, "GetAttributeAll");


  InsertService(connection_manager, kForwardOpen, &ForwardOpen, "ForwardOpen");
  InsertService(connection_manager, kLargeForwardOpen, &LargeForwardOpen, "LargeForwardOpen");


  InsertService(connection_manager, kForwardClose, &ForwardClose, "ForwardClose");
  InsertService(connection_manager, kGetConnectionOwner, &GetConnectionOwner, "GetConnectionOwner");


  InsertService(connection_manager, kGetConnectionData, &GetConnectionData, "GetConnectionData");


  InsertService(connection_manager, kSearchConnectionData, &SearchConnectionData, "SearchConnectionData");



  g_incarnation_id = ( (EipUint32) unique_connection_id ) << 16;

  AddConnectableObject(kCipMessageRouterClassCode, EstablishClass3Connection);
  AddConnectableObject(kCipAssemblyClassCode, EstablishIoConnection);

  return kEipStatusOk;
}

EipStatus HandleReceivedConnectedData(const EipUint8 *const data, int data_length, struct sockaddr_in *from_address) {


  if( (CreateCommonPacketFormatStructure(data, data_length, &g_common_packet_format_data_item) ) == kEipStatusError ) {

    return kEipStatusError;
  } else {
    
    if( (g_common_packet_format_data_item.address_item.type_id == kCipItemIdConnectionAddress)
        || (g_common_packet_format_data_item.address_item.type_id == kCipItemIdSequencedAddressItem) ) {
      if(g_common_packet_format_data_item.data_item.type_id == kCipItemIdConnectedDataItem) {

        CipConnectionObject *connection_object = GetConnectedObject( g_common_packet_format_data_item.address_item.data.connection_identifier);
        if(connection_object == NULL) {
          return kEipStatusError;
        }

        
        if(connection_object->originator_address.sin_addr.s_addr == from_address->sin_addr.s_addr) {
          ConnectionObjectResetLastPackageInactivityTimerValue(connection_object);

          if(SEQ_GT32(g_common_packet_format_data_item.address_item.data. sequence_number, connection_object->eip_level_sequence_count_consuming) || !connection_object->eip_first_level_sequence_count_received) {


            
            ConnectionObjectResetInactivityWatchdogTimerValue(connection_object);

            
            connection_object->eip_level_sequence_count_consuming = g_common_packet_format_data_item.address_item.data.sequence_number;
            connection_object->eip_first_level_sequence_count_received = true;

            if(NULL != connection_object->connection_receive_data_function) {
              return connection_object->connection_receive_data_function( connection_object, g_common_packet_format_data_item.data_item.data, g_common_packet_format_data_item.data_item.length);


            }
          }
        } else {
          OPENER_TRACE_WARN( "Connected Message Data Received with wrong address information\n");
        }
      }
    }
  }
  return kEipStatusOk;
}


typedef EipStatus (*HandleForwardOpenRequestFunction)(CipConnectionObject * connection_object, CipInstance *instance, CipMessageRouterRequest * message_router_request, CipMessageRouterResponse * message_router_response);







EipStatus HandleNullNonMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);




EipStatus HandleNullNonMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response) {



  OPENER_TRACE_INFO("Right now we cannot handle Null requests\n");
  return AssembleForwardOpenResponse(connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeNullForwardOpenNotSupported);


}


EipStatus HandleNullMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);




EipStatus HandleNullMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response) {



  OPENER_TRACE_INFO("Right now we cannot handle Null requests\n");
  return AssembleForwardOpenResponse(connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeNullForwardOpenNotSupported);


}


EipStatus HandleNonNullMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);




EipStatus HandleNonNullMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response) {



  OPENER_TRACE_INFO("Right now we cannot handle reconfiguration requests\n");
  return AssembleForwardOpenResponse(connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeErrorConnectionInUseOrDuplicateForwardOpen);


}


EipStatus HandleNonNullNonMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response);




EipStatus HandleNonNullNonMatchingForwardOpenRequest( CipConnectionObject *connection_object, CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response) {




  EipUint16 connection_status = kConnectionManagerExtendedStatusCodeSuccess;

  
  if(kConnectionObjectTransportClassTriggerProductionTriggerInvalid == ConnectionObjectGetTransportClassTriggerProductionTrigger(& g_dummy_connection_object) )

  {
    return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeErrorTransportClassAndTriggerCombinationNotSupported);


  }

  EipUint32 temp = ParseConnectionPath(&g_dummy_connection_object, message_router_request, &connection_status);

  if(kEipStatusOk != temp) {
    return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, temp, connection_status);


  }

  
  ConnectionManagementHandling *connection_management_entry = GetConnectionManagementEntry( g_dummy_connection_object.configuration_path.class_id);

  if(NULL != connection_management_entry) {
    temp = connection_management_entry->open_connection_function( &g_dummy_connection_object, &connection_status);

  } else {
    temp = kEipStatusError;
    connection_status = kConnectionManagerExtendedStatusCodeInconsistentApplicationPathCombo;
  }

  if(kEipStatusOk != temp) {
    OPENER_TRACE_INFO("connection manager: connect failed\n");
    
    return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, temp, connection_status);


  } else {
    OPENER_TRACE_INFO("connection manager: connect succeeded\n");
    
    return AssembleForwardOpenResponse(connection_list.first->data, message_router_response, kCipErrorSuccess, 0);


  }
}


static const HandleForwardOpenRequestFunction handle_forward_open_request_functions[2][2] = { { HandleNonNullNonMatchingForwardOpenRequest, HandleNonNullMatchingForwardOpenRequest }, { HandleNullNonMatchingForwardOpenRequest, HandleNullMatchingForwardOpenRequest } };





EipStatus ForwardOpenRoutine(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session);





EipStatus LargeForwardOpen(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  g_dummy_connection_object.is_large_forward_open = true;
  return ForwardOpenRoutine(instance, message_router_request, message_router_response, originator_address, encapsulation_session);



}


EipStatus ForwardOpen(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  g_dummy_connection_object.is_large_forward_open = false;
  return ForwardOpenRoutine(instance, message_router_request, message_router_response, originator_address, encapsulation_session);



}
EipStatus ForwardOpenRoutine(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  (void) instance; 

  bool is_null_request = false; 
  bool is_matching_request = false; 

  
  ConnectionObjectInitializeFromMessage(&(message_router_request->data), &g_dummy_connection_object);
  g_dummy_connection_object.associated_encapsulation_session = encapsulation_session;

  memcpy(&(g_dummy_connection_object.originator_address), originator_address, sizeof(g_dummy_connection_object.originator_address) );


  ConnectionObjectConnectionType o_to_t_connection_type = ConnectionObjectGetOToTConnectionType(&g_dummy_connection_object);
  ConnectionObjectConnectionType t_to_o_connection_type = ConnectionObjectGetTToOConnectionType(&g_dummy_connection_object);

  
  if(kConnectionObjectConnectionTypeInvalid == o_to_t_connection_type) {
    return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeErrorInvalidOToTConnectionType);


  }

  if(kConnectionObjectConnectionTypeInvalid == t_to_o_connection_type) {
    return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeErrorInvalidTToOConnectionType);


  }

  if(kConnectionObjectConnectionTypeMulticast == t_to_o_connection_type) {
    
    CipUdint originator_ip = ( (struct sockaddr_in *) originator_address )->sin_addr.s_addr;
    CipUdint interface_ip = g_network_status.ip_address;
    CipUdint interface_mask = g_network_status.network_mask;
    if( (originator_ip & interface_mask) != (interface_ip & interface_mask) ) {
      return AssembleForwardOpenResponse(&g_dummy_connection_object, message_router_response, kCipErrorConnectionFailure, kConnectionManagerExtendedStatusCodeNotConfiguredForOffSubnetMulticast);


    }
  }

  
  if(kConnectionObjectConnectionTypeNull == o_to_t_connection_type && kConnectionObjectConnectionTypeNull == t_to_o_connection_type) {
    is_null_request = true;
    OPENER_TRACE_INFO("We have a Null request\n");
  } else {
    is_null_request = false;
    OPENER_TRACE_INFO("We have a Non-Null request\n");
  }

  
  if(NULL != CheckForExistingConnection(&g_dummy_connection_object) ) {
    OPENER_TRACE_INFO("We have a Matching request\n");
    is_matching_request = true;

  } else {
    OPENER_TRACE_INFO("We have a Non-Matching request\n");
    is_matching_request = false;
  }

  HandleForwardOpenRequestFunction choosen_function = handle_forward_open_request_functions[is_null_request][is_matching_request];

  return choosen_function(&g_dummy_connection_object, instance, message_router_request, message_router_response);


}

EipStatus ForwardClose(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  
  (void) instance;

  
  ConnectionManagerExtendedStatusCode connection_status = kConnectionManagerExtendedStatusCodeErrorConnectionTargetConnectionNotFound;

  
  g_common_packet_format_data_item.address_info_item[0].type_id = 0;
  g_common_packet_format_data_item.address_info_item[1].type_id = 0;

  message_router_request->data += 2; 

  EipUint16 connection_serial_number = GetUintFromMessage( &message_router_request->data);
  EipUint16 originator_vendor_id = GetUintFromMessage( &message_router_request->data);
  EipUint32 originator_serial_number = GetUdintFromMessage( &message_router_request->data);

  OPENER_TRACE_INFO("ForwardClose: ConnSerNo %d\n", connection_serial_number);

  DoublyLinkedListNode *node = connection_list.first;

  while(NULL != node) {
    
    CipConnectionObject *connection_object = node->data;
    if( (kConnectionObjectStateEstablished == ConnectionObjectGetState(connection_object) )
        || (kConnectionObjectStateTimedOut == ConnectionObjectGetState(connection_object) ) ) {
      if( (connection_object->connection_serial_number == connection_serial_number) && (connection_object->originator_vendor_id == originator_vendor_id)

          && (connection_object->originator_serial_number == originator_serial_number) ) {
        
        OPENER_ASSERT(NULL != connection_object->connection_close_function);
        if( ( (struct sockaddr_in *) originator_address )->sin_addr.s_addr == connection_object->originator_address.sin_addr.s_addr ) {
          connection_object->connection_close_function(connection_object);
          connection_status = kConnectionManagerExtendedStatusCodeSuccess;
        } else {
          connection_status = kConnectionManagerExtendedStatusWrongCloser;
        }
        break;
      }
    }
    node = node->next;
  }
  if(kConnectionManagerExtendedStatusCodeErrorConnectionTargetConnectionNotFound == connection_status) {
    OPENER_TRACE_INFO( "Connection not found! Requested connection tried: %u, %u, %i\n", connection_serial_number, originator_vendor_id, originator_serial_number);



  }

  return AssembleForwardCloseResponse(connection_serial_number, originator_vendor_id, originator_serial_number, message_router_request, message_router_response, connection_status);




}


EipStatus GetConnectionOwner(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  
  (void) instance;
  (void) message_router_request;
  (void) message_router_response;

  return kEipStatusOk;
}

EipStatus GetConnectionData(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response) {


  CIPServiceCode service_code = kGetConnectionData;
  message_router_response->reply_service = (0x80 | service_code);

  
  EipUint16 Connection_number = GetUintFromMessage(&message_router_request->data);

  OPENER_TRACE_INFO("GetConnectionData for Connection_number: %d\n", Connection_number);

  
  DoublyLinkedListNode *iterator = connection_list.first;
  CipConnectionObject *search_connection_object = NULL;
  CipConnectionObject *connection_object = NULL;

  while(NULL != iterator) {
    search_connection_object = iterator->data;

    if( (search_connection_object->connection_number == Connection_number) ) {
      connection_object = search_connection_object;
      break;
    }
    iterator = iterator->next;
  }

  if(NULL != connection_object) {
    
    AssembleConnectionDataResponseMessage(message_router_response, connection_object);
    message_router_response->general_status = kEipStatusOk;
    OPENER_TRACE_INFO("Connection found!\n");
  } else {
    message_router_response->general_status = kCipErrorPathDestinationUnknown;
    OPENER_TRACE_INFO("Connection not found!\n");
  }

  return kEipStatusOk;
}

EipStatus SearchConnectionData(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response)

{

  CIPServiceCode service_code = kSearchConnectionData;
  message_router_response->reply_service = (0x80 | service_code);

  
  EipUint16 Connection_serial_number = GetUintFromMessage( &message_router_request->data);
  EipUint16 Originator_vendor_id = GetUintFromMessage( &message_router_request->data);
  EipUint32 Originator_serial_number = GetUdintFromMessage( &message_router_request->data);

  OPENER_TRACE_INFO( "SearchConnectionData for ConnSerNo: %d, OrigVendId: %d, OrigSerNo: %i,\n", Connection_serial_number, Originator_vendor_id, Originator_serial_number);




  
  DoublyLinkedListNode *iterator = connection_list.first;
  CipConnectionObject *search_connection_object = NULL;
  CipConnectionObject *connection_object = NULL;

  while(NULL != iterator) {
    search_connection_object = iterator->data;

    if( (search_connection_object->connection_serial_number == Connection_serial_number)
        && (search_connection_object->originator_vendor_id == Originator_vendor_id)
        && (search_connection_object->originator_serial_number == Originator_serial_number) ) {

      connection_object = search_connection_object;
      break;
    }
    iterator = iterator->next;
  }
  if(NULL != connection_object) {
    
    AssembleConnectionDataResponseMessage(message_router_response, connection_object);
    message_router_response->general_status = kEipStatusOk;
    OPENER_TRACE_INFO("Connection found!\n");
  } else {
    message_router_response->general_status = kCipErrorPathDestinationUnknown;
    OPENER_TRACE_INFO("Connection not found!\n");
  }

  return kEipStatusOk;
}

void AssembleConnectionDataResponseMessage( CipMessageRouterResponse *message_router_response, CipConnectionObject *connection_object) {


  
  AddIntToMessage(connection_object->connection_number, &message_router_response->message);
  
  AddIntToMessage(connection_object->state, &message_router_response->message);
  
  AddIntToMessage(connection_object->originator_address.sin_port, &message_router_response->message);
  
  AddIntToMessage(connection_object->remote_address.sin_port, &message_router_response->message);
  
  AddIntToMessage(connection_object->connection_serial_number, &message_router_response->message);
  
  AddIntToMessage(connection_object->originator_vendor_id, &message_router_response->message);
  
  AddDintToMessage(connection_object->originator_serial_number, &message_router_response->message);
  
  AddDintToMessage(connection_object->cip_consumed_connection_id, &message_router_response->message);
  
  AddDintToMessage(connection_object->cip_consumed_connection_id, &message_router_response->message);
  
  AddSintToMessage(connection_object->connection_timeout_multiplier, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddDintToMessage(connection_object->o_to_t_requested_packet_interval, &message_router_response->message);
  
  AddDintToMessage(connection_object->transmission_trigger_timer, &message_router_response->message);
  
  AddDintToMessage(connection_object->cip_produced_connection_id, &message_router_response->message);
  
  AddDintToMessage(connection_object->cip_produced_connection_id, &message_router_response->message);
  
  AddSintToMessage(connection_object->connection_timeout_multiplier, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddSintToMessage(0, &message_router_response->message);
  
  AddDintToMessage(connection_object->t_to_o_requested_packet_interval, &message_router_response->message);
  
  AddDintToMessage(connection_object->transmission_trigger_timer, &message_router_response->message);
}

EipStatus ManageConnections(MilliSeconds elapsed_time) {
  
  
  HandleApplication();
  ManageEncapsulationMessages(elapsed_time);

  DoublyLinkedListNode *node = connection_list.first;

  while(NULL != node) {
    
    CipConnectionObject *connection_object = node->data;
    if(kConnectionObjectStateEstablished == ConnectionObjectGetState(connection_object) ) {
      if( (NULL != connection_object->consuming_instance) ||  (kConnectionObjectTransportClassTriggerDirectionServer == ConnectionObjectGetTransportClassTriggerDirection(connection_object) ) )

      {
        if(elapsed_time >= connection_object->inactivity_watchdog_timer) {
          
          OPENER_TRACE_INFO(">>>>>>>>>>Connection ConnNr: %u timed out\n", connection_object->connection_serial_number);
          OPENER_ASSERT(NULL != connection_object->connection_timeout_function);
          connection_object->connection_timeout_function(connection_object);
        } else {
          connection_object->inactivity_watchdog_timer -= elapsed_time;
          connection_object->last_package_watchdog_timer -= elapsed_time;
        }
      }
      
      if(kConnectionObjectStateEstablished == ConnectionObjectGetState(connection_object) ) {
        
        if( (0 != ConnectionObjectGetExpectedPacketRate(connection_object) )
            && (kEipInvalidSocket != connection_object->socket[kUdpCommuncationDirectionProducing]) )
        {
          if(kConnectionObjectTransportClassTriggerProductionTriggerCyclic != ConnectionObjectGetTransportClassTriggerProductionTrigger( connection_object) ) {

            
            if(elapsed_time <= connection_object->production_inhibit_timer) {
              
            } else {
              connection_object->production_inhibit_timer -= elapsed_time;
            }
          }

          if(connection_object->transmission_trigger_timer <= elapsed_time) { 
            OPENER_ASSERT( NULL != connection_object->connection_send_data_function);
            EipStatus eip_status = connection_object->connection_send_data_function(connection_object);
            if(eip_status == kEipStatusError) {
              OPENER_TRACE_ERR( "sending of UDP data in manage Connection failed\n");
            }
            
            connection_object->transmission_trigger_timer += ConnectionObjectGetRequestedPacketInterval(connection_object);
            
            if (connection_object->transmission_trigger_timer > elapsed_time) {
              connection_object->transmission_trigger_timer -= elapsed_time;
            } else {  
              connection_object->transmission_trigger_timer = 0;
              OPENER_TRACE_INFO("elapsed time: %lu ms was longer than RPI: %u ms\n", elapsed_time, ConnectionObjectGetRequestedPacketInterval(connection_object));

            }
            if(kConnectionObjectTransportClassTriggerProductionTriggerCyclic != ConnectionObjectGetTransportClassTriggerProductionTrigger( connection_object) ) {

              
              ConnectionObjectResetProductionInhibitTimer(connection_object);
            }
          } else {
            connection_object->transmission_trigger_timer -= elapsed_time;
          }
        }
      }
    }
    node = node->next;
  }
  return kEipStatusOk;
}


EipStatus AssembleForwardOpenResponse(CipConnectionObject *connection_object, CipMessageRouterResponse *message_router_response, EipUint8 general_status, EipUint16 extended_status) {


  
  CipCommonPacketFormatData *cip_common_packet_format_data = &g_common_packet_format_data_item;
  cip_common_packet_format_data->item_count = 2;
  cip_common_packet_format_data->data_item.type_id = kCipItemIdUnconnectedDataItem;

  AddNullAddressItem(cip_common_packet_format_data);

  CIPServiceCode service_code = kForwardOpen;
  if(connection_object->is_large_forward_open) {
    service_code = kLargeForwardOpen;
  }

  message_router_response->reply_service = (0x80 | service_code);
  message_router_response->general_status = general_status;

  if(kCipErrorSuccess == general_status) {
    OPENER_TRACE_INFO("assembleFWDOpenResponse: sending success response\n");
    
    message_router_response->size_of_additional_status = 0;

    if(cip_common_packet_format_data->address_info_item[0].type_id != 0) {
      cip_common_packet_format_data->item_count = 3;
      if(cip_common_packet_format_data->address_info_item[1].type_id != 0) {
        cip_common_packet_format_data->item_count = 4; 
      }
    }

    AddDintToMessage(connection_object->cip_consumed_connection_id, &message_router_response->message);
    AddDintToMessage(connection_object->cip_produced_connection_id, &message_router_response->message);
  } else {
    
    OPENER_TRACE_WARN("AssembleForwardOpenResponse: sending error response, general/extended status=%d/%d\n", general_status, extended_status);
    ConnectionObjectSetState(connection_object, kConnectionObjectStateNonExistent);
    

    switch(general_status) {
      case kCipErrorNotEnoughData:
      case kCipErrorTooMuchData: {
        message_router_response->size_of_additional_status = 0;
        break;
      }

      default: {
        switch(extended_status) {
          case kConnectionManagerExtendedStatusCodeErrorInvalidOToTConnectionSize:
          {
            message_router_response->size_of_additional_status = 2;
            message_router_response->additional_status[0] = extended_status;
            message_router_response->additional_status[1] = connection_object->correct_originator_to_target_size;
            break;
          }

          case kConnectionManagerExtendedStatusCodeErrorInvalidTToOConnectionSize:
          {
            message_router_response->size_of_additional_status = 2;
            message_router_response->additional_status[0] = extended_status;
            message_router_response->additional_status[1] = connection_object->correct_target_to_originator_size;
            break;
          }

          default: {
            message_router_response->size_of_additional_status = 1;
            message_router_response->additional_status[0] = extended_status;
            break;
          }
        }
        break;
      }
    }
  }

  AddIntToMessage(connection_object->connection_serial_number, &message_router_response->message);
  AddIntToMessage(connection_object->originator_vendor_id, &message_router_response->message);
  AddDintToMessage(connection_object->originator_serial_number, &message_router_response->message);

  if(kCipErrorSuccess == general_status) {
    
    AddDintToMessage(connection_object->o_to_t_requested_packet_interval, &message_router_response->message);
    AddDintToMessage(connection_object->t_to_o_requested_packet_interval, &message_router_response->message);
  }

  AddSintToMessage(0, &message_router_response->message); 
  AddSintToMessage(0, &message_router_response->message); 

  return kEipStatusOkSend; 
}


void AddNullAddressItem( CipCommonPacketFormatData *common_data_packet_format_data) {
  
  assert( common_data_packet_format_data->data_item.type_id == kCipItemIdUnconnectedDataItem);


  common_data_packet_format_data->address_item.type_id = kCipItemIdNullAddress;
  common_data_packet_format_data->address_item.length = 0;
}


EipStatus AssembleForwardCloseResponse(EipUint16 connection_serial_number, EipUint16 originatior_vendor_id, EipUint32 originator_serial_number, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, EipUint16 extended_error_code) {




  
  CipCommonPacketFormatData *common_data_packet_format_data = &g_common_packet_format_data_item;
  common_data_packet_format_data->item_count = 2;
  common_data_packet_format_data->data_item.type_id = kCipItemIdUnconnectedDataItem;

  AddNullAddressItem(common_data_packet_format_data);

  AddIntToMessage(connection_serial_number, &message_router_response->message);
  AddIntToMessage(originatior_vendor_id, &message_router_response->message);
  AddDintToMessage(originator_serial_number, &message_router_response->message);

  message_router_response->reply_service = (0x80 | message_router_request->service);
  

  if(kConnectionManagerExtendedStatusCodeSuccess == extended_error_code) {
    AddSintToMessage(0, &message_router_response->message); 
    message_router_response->general_status = kCipErrorSuccess;
    message_router_response->size_of_additional_status = 0;
  } else {
    AddSintToMessage(*message_router_request->data, &message_router_response->message);
    if(kConnectionManagerExtendedStatusWrongCloser == extended_error_code) {
      message_router_response->general_status = kCipErrorPrivilegeViolation;
    } else {
      message_router_response->general_status = kCipErrorConnectionFailure;
      message_router_response->additional_status[0] = extended_error_code;
      message_router_response->size_of_additional_status = 1;
    }
  }

  AddSintToMessage(0, &message_router_response->message); 

  return kEipStatusOkSend;
}

CipConnectionObject *GetConnectedObject(const EipUint32 connection_id) {
  DoublyLinkedListNode *iterator = connection_list.first;

  while(NULL != iterator) {
    if(kConnectionObjectStateEstablished == ConnectionObjectGetState(iterator->data)
       && connection_id == ConnectionObjectGetCipConsumedConnectionID(iterator->data) ) {
      return iterator->data;
    }
    iterator = iterator->next;
  }
  return NULL;
}

CipConnectionObject *GetConnectedOutputAssembly( const EipUint32 output_assembly_id) {
  DoublyLinkedListNode *iterator = connection_list.first;

  while(NULL != iterator) {
    if(kConnectionObjectInstanceTypeIOExclusiveOwner == ConnectionObjectGetInstanceType(iterator->data)
       && (kConnectionObjectStateEstablished == ConnectionObjectGetState(iterator->data)
           || kConnectionObjectStateTimedOut == ConnectionObjectGetState(iterator->data) )
       && output_assembly_id == ( (CipConnectionObject *) iterator->data )->produced_path.instance_id) {
      return iterator->data;
    }
    iterator = iterator->next;
  }
  return NULL;
}

CipConnectionObject *CheckForExistingConnection( const CipConnectionObject *const connection_object) {

  DoublyLinkedListNode *iterator = connection_list.first;

  while(NULL != iterator) {
    if(kConnectionObjectStateEstablished == ConnectionObjectGetState(iterator->data) ) {
      if(EqualConnectionTriad(connection_object, iterator->data) ) {
        return iterator->data;
      }
    }
    iterator = iterator->next;
  }

  return NULL;
}

EipStatus CheckElectronicKeyData(EipUint8 key_format, void *key_data, EipUint16 *extended_status) {

  
  *extended_status = kConnectionManagerExtendedStatusCodeSuccess;

  
  if(4 != key_format) {
    *extended_status = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
    return kEipStatusError;
  }

  bool compatiblity_mode = ElectronicKeyFormat4GetMajorRevisionCompatibility( key_data);

  
  if( ( (ElectronicKeyFormat4GetVendorId(key_data) != g_identity.vendor_id) && (ElectronicKeyFormat4GetVendorId(key_data) != 0) )
      || ( (ElectronicKeyFormat4GetProductCode(key_data) != g_identity.product_code) && (ElectronicKeyFormat4GetProductCode(key_data) != 0) ) ) {

    *extended_status = kConnectionManagerExtendedStatusCodeErrorVendorIdOrProductcodeError;
    return kEipStatusError;
  } else {
    

    
    if( (ElectronicKeyFormat4GetDeviceType(key_data) != g_identity.device_type) && (ElectronicKeyFormat4GetDeviceType(key_data) != 0) ) {

      *extended_status = kConnectionManagerExtendedStatusCodeErrorDeviceTypeError;
      return kEipStatusError;
    } else {
      

      if(false == compatiblity_mode) {
        
        if(0 == ElectronicKeyFormat4GetMajorRevision(key_data) ) {
          return kEipStatusOk;
        }

        
        if( (ElectronicKeyFormat4GetMajorRevision(key_data) != g_identity.revision.major_revision)
            || ( (ElectronicKeyFormat4GetMinorRevision(key_data) != g_identity.revision.minor_revision) && (ElectronicKeyFormat4GetMinorRevision(key_data) != 0) ) ) {

          *extended_status = kConnectionManagerExtendedStatusCodeErrorRevisionMismatch;
          return kEipStatusError;
        }
      } else {
        

        
        if( (ElectronicKeyFormat4GetMajorRevision(key_data) == g_identity.revision.major_revision) && (ElectronicKeyFormat4GetMinorRevision(key_data) > 0)

            && (ElectronicKeyFormat4GetMinorRevision(key_data) <= g_identity.revision.minor_revision) ) {
          return kEipStatusOk;
        } else {
          *extended_status = kConnectionManagerExtendedStatusCodeErrorRevisionMismatch;
          return kEipStatusError;
        }
      } 
    }
  }

  return (*extended_status == kConnectionManagerExtendedStatusCodeSuccess) ? kEipStatusOk :
         kEipStatusError;
}

EipUint8 ParseConnectionPath(CipConnectionObject *connection_object, CipMessageRouterRequest *message_router_request, EipUint16 *extended_error) {

  const EipUint8 *message = message_router_request->data;
  const size_t connection_path_size = GetUsintFromMessage(&message); 
  size_t remaining_path = connection_path_size;
  OPENER_TRACE_INFO("Received connection path size: %zu \n", connection_path_size);
  CipClass *class = NULL;

  CipDword class_id = 0x0;
  CipDword instance_id = 0x0;

  
  ConnectionObjectSetProductionInhibitTime(connection_object, 256);

  size_t header_length = g_kForwardOpenHeaderLength;
  if(connection_object->is_large_forward_open) {
    header_length = g_kLargeForwardOpenHeaderLength;
  }

  if( (header_length + remaining_path * 2) < message_router_request->request_data_size ) {
    
    *extended_error = 0;
    return kCipErrorTooMuchData;
  }

  if( (header_length + remaining_path * 2) > message_router_request->request_data_size ) {
    
    *extended_error = 0;
    OPENER_TRACE_INFO("Message not long enough for path\n");
    return kCipErrorNotEnoughData;
  }

  if(remaining_path > 0) {
    
    if(kSegmentTypeLogicalSegment == GetPathSegmentType(message) ) {
      if(kLogicalSegmentLogicalTypeSpecial == GetPathLogicalSegmentLogicalType(message) ) {
        if(kLogicalSegmentSpecialTypeLogicalFormatElectronicKey == GetPathLogicalSegmentSpecialTypeLogicalType(message) ) {
          if(kElectronicKeySegmentFormatKeyFormat4 == GetPathLogicalSegmentElectronicKeyFormat(message) ) {
            
            if(remaining_path < 5) {
              *extended_error = 0;
              OPENER_TRACE_INFO("Message not long enough for electronic key\n");
              return kCipErrorNotEnoughData;
            }
            
            connection_object->electronic_key.key_format = 4;
            ElectronicKeyFormat4 *electronic_key = ElectronicKeyFormat4New();
            GetElectronicKeyFormat4FromMessage(&message, electronic_key);
            
            connection_object->electronic_key.key_data = electronic_key;

            remaining_path -= 5; 
            OPENER_TRACE_INFO( "key: ven ID %d, dev type %d, prod code %d, major %d, minor %d\n", ElectronicKeyFormat4GetVendorId(connection_object->electronic_key. key_data), ElectronicKeyFormat4GetDeviceType(connection_object-> electronic_key.key_data), ElectronicKeyFormat4GetProductCode(connection_object-> electronic_key.key_data), ElectronicKeyFormat4GetMajorRevision(connection_object-> electronic_key.key_data), ElectronicKeyFormat4GetMinorRevision(connection_object-> electronic_key.key_data) );










            if(kEipStatusOk != CheckElectronicKeyData(connection_object->electronic_key. key_format, connection_object->electronic_key. key_data, extended_error) ) {




              ElectronicKeyFormat4Delete(&electronic_key);
              return kCipErrorConnectionFailure;
            }
            ElectronicKeyFormat4Delete(&electronic_key);
          }

        } else {
          OPENER_TRACE_INFO("no key\n");
        }
      }
    }

    
    if(kConnectionObjectTransportClassTriggerProductionTriggerCyclic != ConnectionObjectGetTransportClassTriggerProductionTrigger( connection_object) )

    {
      
      if(kSegmentTypeNetworkSegment == GetPathSegmentType(message) ) {
        NetworkSegmentSubtype network_segment_subtype = GetPathNetworkSegmentSubtype(message);
        if(kNetworkSegmentSubtypeProductionInhibitTimeInMilliseconds == network_segment_subtype) {
          OPENER_TRACE_INFO("PIT segment available - value: %u\n",message[1]);
          connection_object->production_inhibit_time = message[1];
          message += 2;
          remaining_path -= 1;
        }
      }
    }

    if(kSegmentTypeLogicalSegment == GetPathSegmentType(message) && kLogicalSegmentLogicalTypeClassId == GetPathLogicalSegmentLogicalType(message) ) {


      class_id = CipEpathGetLogicalValue(&message);
      class = GetCipClass(class_id);
      if(NULL == class) {
        OPENER_TRACE_ERR("classid %" PRIx32 " not found\n", class_id);

        if(class_id >= 0xC8) { 
          *extended_error = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
        } else {
          *extended_error = kConnectionManagerExtendedStatusCodeInconsistentApplicationPathCombo;
        }
        return kCipErrorConnectionFailure;
      }

      OPENER_TRACE_INFO("classid %" PRIx32 " (%s)\n", class_id, class->class_name);

    } else {
      *extended_error = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
      return kCipErrorConnectionFailure;
    }
    remaining_path -= 1; 

    
    if(kSegmentTypeLogicalSegment == GetPathSegmentType(message) && kLogicalSegmentLogicalTypeInstanceId == GetPathLogicalSegmentLogicalType(message) ) {

      instance_id = CipEpathGetLogicalValue(&message);

      OPENER_TRACE_INFO("Configuration instance id %" PRId32 "\n", instance_id);
      if(NULL == GetCipInstance(class, instance_id) ) {
        
        *extended_error = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
        return kCipErrorConnectionFailure;
      }
      
      remaining_path -= (instance_id > 0xFF) ? 2 : 1; 
    } else {
      OPENER_TRACE_INFO("no config data\n");
    }

    if(kConnectionObjectTransportClassTriggerTransportClass3 == ConnectionObjectGetTransportClassTriggerTransportClass(connection_object) )
    {
      
      if(remaining_path > 0) {
        OPENER_TRACE_WARN( "Too much data in connection path for class 3 connection\n");
        *extended_error = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
        return kCipErrorConnectionFailure;
      }

      
      if( (class_id != kCipMessageRouterClassCode) || (1 != instance_id) ) {
        *extended_error = kConnectionManagerExtendedStatusCodeInconsistentApplicationPathCombo;
        return kCipErrorConnectionFailure;
      }
      
      CipConnectionPathEpath connection_epath = { .class_id = class_id, .instance_id = instance_id, .attribute_id_or_connection_point = 0 };


      memcpy(&(connection_object->configuration_path), &connection_epath, sizeof(connection_object->configuration_path) );

      memcpy(&(connection_object->produced_path), &connection_epath, sizeof(connection_object->produced_path) );

      
    } else { 
      CipConnectionPathEpath connection_epath = { .class_id = class_id, .instance_id = instance_id, .attribute_id_or_connection_point = 0 };

      memcpy(&(connection_object->configuration_path), &connection_epath, sizeof(connection_object->configuration_path) );

      ConnectionObjectConnectionType originator_to_target_connection_type = ConnectionObjectGetOToTConnectionType(connection_object);
      ConnectionObjectConnectionType target_to_originator_connection_type = ConnectionObjectGetTToOConnectionType(connection_object);

      connection_object->consumed_connection_path_length = 0;
      connection_object->consumed_connection_path = NULL;
      

      size_t number_of_encoded_paths = 0;
      CipConnectionPathEpath *paths_to_encode[2] = { 0 };
      if(kConnectionObjectConnectionTypeNull == originator_to_target_connection_type) {
        if(kConnectionObjectConnectionTypeNull == target_to_originator_connection_type) {
          number_of_encoded_paths = 0;
          OPENER_TRACE_WARN("assembly: type invalid\n");
        } else { 
          OPENER_TRACE_INFO("assembly: type produce\n");
          number_of_encoded_paths = 1;
          paths_to_encode[0] = &(connection_object->produced_path);
        }
      } else {
        if(kConnectionObjectConnectionTypeNull == target_to_originator_connection_type) {
          OPENER_TRACE_INFO("assembly: type consume\n");
          number_of_encoded_paths = 1;
          paths_to_encode[0] = &(connection_object->consumed_path);
        } else { 
          OPENER_TRACE_INFO("assembly: type bidirectional\n");
          paths_to_encode[0] = &(connection_object->consumed_path);
          paths_to_encode[1] = &(connection_object->produced_path);
          number_of_encoded_paths = 2;
        }
      }

      for(size_t i = 0; i < number_of_encoded_paths; i++) 
      {
        if(kSegmentTypeLogicalSegment == GetPathSegmentType(message)
           && (kLogicalSegmentLogicalTypeInstanceId == GetPathLogicalSegmentLogicalType(message)
               || kLogicalSegmentLogicalTypeConnectionPoint == GetPathLogicalSegmentLogicalType(message) ) )
        {   
          CipDword attribute_id = CipEpathGetLogicalValue(&message);
          CipConnectionPathEpath path = { .class_id = class_id, .instance_id = attribute_id, .attribute_id_or_connection_point = 0 };

          memcpy(paths_to_encode[i], &path, sizeof(connection_object->produced_path) );
          OPENER_TRACE_INFO( "connection point %" PRIu32 "\n", attribute_id);

          if(NULL == GetCipInstance(class, attribute_id) ) { 
            *extended_error = kConnectionManagerExtendedStatusCodeInconsistentApplicationPathCombo;
            return kCipErrorConnectionFailure;
          }
          
          remaining_path -= (attribute_id > 0xFF) ? 2 : 1;
        } else {
          *extended_error = kConnectionManagerExtendedStatusCodeErrorInvalidSegmentTypeInPath;
          return kCipErrorConnectionFailure;
        }
      }

      g_config_data_length = 0;
      g_config_data_buffer = NULL;

      while(remaining_path > 0) { 

        SegmentType segment_type = GetPathSegmentType(message);
        switch(segment_type) {
          case kSegmentTypeDataSegment: {
            DataSegmentSubtype data_segment_type = GetPathDataSegmentSubtype( message);
            switch(data_segment_type) {
              case kDataSegmentSubtypeSimpleData:
                g_config_data_length = message[1] * 2; 
                g_config_data_buffer = (EipUint8 *) message + 2;
                remaining_path -= (g_config_data_length + 2) / 2;
                message += (g_config_data_length + 2);
                break;
              default:
                OPENER_TRACE_ERR("Not allowed in connection manager");
                return kCipErrorPathSegmentError;
            }
          }
          break;
          case kSegmentTypeNetworkSegment: {
            NetworkSegmentSubtype subtype = GetPathNetworkSegmentSubtype(message);
            switch(subtype) {
              case kNetworkSegmentSubtypeProductionInhibitTimeInMilliseconds:
                if(kConnectionObjectTransportClassTriggerProductionTriggerCyclic != ConnectionObjectGetTransportClassTriggerProductionTrigger( connection_object) ) {

                  
                  connection_object->production_inhibit_time = message[1];
                  message += 2;
                  remaining_path -= 2;
                } else {
                  *extended_error = connection_path_size - remaining_path; 
                  return kCipErrorPathSegmentError; 
                }
                break;
              default:
                OPENER_TRACE_ERR("Not allowed in connection manager");
                return kCipErrorPathSegmentError;
            }
          }
          break;

          default:
            OPENER_TRACE_WARN( "No data segment identifier found for the configuration data\n");
            *extended_error = connection_path_size - remaining_path; 
            return kConnectionManagerGeneralStatusPathSegmentErrorInUnconnectedSend;
        }
      }
    }
  }

  OPENER_TRACE_INFO("Resulting PIT value: %u\n", connection_object->production_inhibit_time);
  
  message_router_request->data = message;
  return kEipStatusOk;
}

void CloseConnection(CipConnectionObject *RESTRICT connection_object) {

  OPENER_TRACE_INFO("cipconnectionmanager: CloseConnection, trigger: %d \n", ConnectionObjectGetTransportClassTriggerTransportClass(connection_object));

  if(kConnectionObjectTransportClassTriggerTransportClass3 != ConnectionObjectGetTransportClassTriggerTransportClass(connection_object) )
  {
    
    CloseUdpSocket(connection_object->socket[kUdpCommuncationDirectionConsuming]);
    connection_object->socket[kUdpCommuncationDirectionConsuming] = kEipInvalidSocket;
    CloseUdpSocket(connection_object->socket[kUdpCommuncationDirectionProducing]);
    connection_object->socket[kUdpCommuncationDirectionProducing] = kEipInvalidSocket;
  }
  RemoveFromActiveConnections(connection_object);
  ConnectionObjectInitializeEmpty(connection_object);

}

void AddNewActiveConnection(CipConnectionObject *const connection_object) {
  DoublyLinkedListInsertAtHead(&connection_list, connection_object);
  ConnectionObjectSetState(connection_object, kConnectionObjectStateEstablished);
}

void RemoveFromActiveConnections(CipConnectionObject *const connection_object) {
  for(DoublyLinkedListNode *iterator = connection_list.first; iterator != NULL;
      iterator = iterator->next) {
    if(iterator->data == connection_object) {
      DoublyLinkedListRemoveNode(&connection_list, &iterator);
      return;
    }
  } OPENER_TRACE_ERR("Connection not found in active connection list\n");
}

EipBool8 IsConnectedOutputAssembly(const EipUint32 instance_number) {
  EipBool8 is_connected = false;

  DoublyLinkedListNode *node = connection_list.first;

  while(NULL != node) {
    CipConnectionObject *connection_object = (CipConnectionObject *) node->data;
    CipDword consumed_connection_point = connection_object->consumed_path.instance_id;
    if(instance_number == consumed_connection_point && true == ConnectionObjectIsTypeIOConnection(connection_object) ) {
      is_connected = true;
      break;
    }
    node = node->next;
  }
  return is_connected;
}

EipStatus AddConnectableObject(const CipUdint class_code, OpenConnectionFunction open_connection_function)
{
  EipStatus status = kEipStatusError;

  
  for(size_t i = 0; i < g_kNumberOfConnectableObjects; ++i) {
    if( (0 == g_connection_management_list[i].class_id) || (class_code == g_connection_management_list[i].class_id) ) {
      g_connection_management_list[i].class_id = class_code;
      g_connection_management_list[i].open_connection_function = open_connection_function;
      status = kEipStatusOk;
      break;
    }
  }

  return status;
}

ConnectionManagementHandling * GetConnectionManagementEntry(const EipUint32 class_id) {

  ConnectionManagementHandling *connection_management_entry = NULL;

  for(size_t i = 0; i < g_kNumberOfConnectableObjects; ++i) {
    if(class_id == g_connection_management_list[i].class_id) {
      connection_management_entry = &(g_connection_management_list[i]);
      break;
    }
  }
  return connection_management_entry;
}

EipStatus TriggerConnections(unsigned int output_assembly, unsigned int input_assembly) {
  EipStatus status = kEipStatusError;

  DoublyLinkedListNode *node = connection_list.first;
  while(NULL != node) {
    CipConnectionObject *connection_object = node->data;
    if( (output_assembly == connection_object->consumed_path.instance_id) && (input_assembly == connection_object->produced_path.instance_id) ) {
      if( kConnectionObjectTransportClassTriggerProductionTriggerApplicationObject == ConnectionObjectGetTransportClassTriggerProductionTrigger( connection_object) ) {


        
        connection_object->transmission_trigger_timer = connection_object->production_inhibit_time;
        status = kEipStatusOk;
      }
      break;
    }
    node = node->next;
  }
  return status;
}

void CheckForTimedOutConnectionsAndCloseTCPConnections( const CipConnectionObject *const connection_object, CloseSessionFunction CloseSessions)

{

  DoublyLinkedListNode *search_node = connection_list.first;
  bool non_timed_out_connection_found = false;
  while(NULL != search_node) {
    CipConnectionObject *search_connection = search_node->data;
    if(ConnectionObjectEqualOriginator(connection_object, search_connection) && connection_object != search_connection && kConnectionObjectStateTimedOut != ConnectionObjectGetState(search_connection) ) {



      non_timed_out_connection_found = true;
      break;
    }
    search_node = search_node->next;
  }
  if(false == non_timed_out_connection_found) {
    CloseSessions(connection_object);
  }
}

void InitializeConnectionManagerData() {
  memset(g_connection_management_list, 0, g_kNumberOfConnectableObjects * sizeof(ConnectionManagementHandling) );

  InitializeClass3ConnectionData();
  InitializeIoConnectionData();
}
