

















  #include "cipdlr.h"










  #include "OpENerFileObject/cipfile.h"



  #include "SecurityObjects/CipSecurityObject/cipsecurity.h"
  #include "SecurityObjects/EtherNetIPSecurityObject/ethernetipsecurity.h"
  #include "SecurityObjects/CertificateManagementObject/certificatemanagement.h"



EipStatus CipStackInit(const EipUint16 unique_connection_id) {
  
  EipStatus eip_status = CipMessageRouterInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = CipIdentityInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = CipTcpIpInterfaceInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = CipEthernetLinkInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = ConnectionManagerInit(unique_connection_id);
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = CipAssemblyInitialize();
  OPENER_ASSERT(kEipStatusOk == eip_status);

  eip_status = CipDlrInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);

  eip_status = CipQoSInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);


  eip_status = CipFileInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);



  eip_status = CipSecurityInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = EIPSecurityInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);
  eip_status = CertificateManagementObjectInit();
  OPENER_ASSERT(kEipStatusOk == eip_status);


  
  eip_status = ApplicationInitialization();
  OPENER_ASSERT(kEipStatusOk == eip_status);

  return eip_status;
}

void ShutdownCipStack(void) {
  
  CloseAllConnections();
  
  EncapsulationShutDown();
  
  ShutdownAssemblies();

  ShutdownTcpIpInterface();

  
  DeleteAllClasses();
}

EipStatus NotifyClass(const CipClass *RESTRICT const cip_class, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  
  EipUint16 instance_number = message_router_request->request_path.instance_number;
  CipInstance *instance = GetCipInstance(cip_class, instance_number); 
  if(instance) 
  {
    OPENER_TRACE_INFO("notify: found instance %d%s\n", instance_number, instance_number == 0 ? " (class object)" : "");


    CipServiceStruct *service = instance->cip_class->services; 
    if(NULL != service) 
    {
      for(size_t i = 0; i < instance->cip_class->number_of_services; i++) 
      {
        if(message_router_request->service == service->service_number) 
        {
          
          OPENER_TRACE_INFO("notify: calling %s service\n", service->name);
          OPENER_ASSERT(NULL != service->service_function);
          return service->service_function(instance, message_router_request, message_router_response, originator_address, encapsulation_session);



        } else {
          service++;
        }
      }
    } OPENER_TRACE_WARN( "notify: service 0x%x not supported\n", message_router_request->service);
    message_router_response->general_status = kCipErrorServiceNotSupported; 
  } else {
    OPENER_TRACE_WARN("notify: instance number %d unknown\n", instance_number);
    
    message_router_response->general_status = kCipErrorPathDestinationUnknown;
    
  }

  
  message_router_response->size_of_additional_status = 0; 
  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);

  return kEipStatusOkSend;
}

CipUint GetMaxInstanceNumber(CipClass *RESTRICT const cip_class) {
  CipUint max_instance = 0;
  CipInstance *instance = cip_class->instances;
  while (NULL != instance) { 
    if(instance->instance_number > max_instance) {
      max_instance = instance->instance_number;
    }
    instance = instance->next;
  }
  return max_instance;
}

CipInstance *AddCipInstances(CipClass *RESTRICT const cip_class, const int number_of_instances) {
  CipInstance **next_instance = NULL;
  CipInstance *first_instance = NULL; 
  EipUint32 instance_number = 1; 
  int new_instances = 0;

  OPENER_TRACE_INFO("adding %d instances to class %s\n", number_of_instances, cip_class->class_name);


  
  for(new_instances = 0; new_instances < number_of_instances; new_instances++) {

    
    CipBool found_free_number = false;

    while (!found_free_number) {
      next_instance = &cip_class->instances;           

      found_free_number = true; 

      
      while (*next_instance)           
      {
        
        if(instance_number == (*next_instance)->instance_number) {
          found_free_number = false;  
          break;
        }
        next_instance = &(*next_instance)->next;                
      }

      if(!found_free_number) {
        instance_number++;                         
      }

    }

    CipInstance *current_instance = (CipInstance *) CipCalloc( 1, sizeof(CipInstance) );
    OPENER_ASSERT(NULL != current_instance); 
    if(NULL == current_instance) {
      break;
    }
    if(NULL == first_instance) {
      first_instance = current_instance; 
    }

    current_instance->instance_number = instance_number; 
    current_instance->cip_class = cip_class; 

    if(cip_class->number_of_attributes) 
    { 
      current_instance->attributes = (CipAttributeStruct *) CipCalloc( cip_class->number_of_attributes, sizeof(CipAttributeStruct) );

      OPENER_ASSERT(NULL != current_instance->attributes);
      if(NULL == current_instance->attributes) {
        break;
      }
    }

    *next_instance = current_instance; 
    next_instance = &current_instance->next; 
    cip_class->number_of_instances += 1; 
    instance_number++; 
  }

  cip_class->max_instance = GetMaxInstanceNumber(cip_class); 

  if(new_instances != number_of_instances) {
    
    OPENER_TRACE_ERR( "ERROR: Allocated only %d instances of requested %d for class %s\n", new_instances, number_of_instances, cip_class->class_name);



    first_instance = NULL; 
  }
  return first_instance;
}

CipInstance *AddCipInstance(CipClass *RESTRICT const cip_class, const EipUint32 instance_id) {
  CipInstance *instance = GetCipInstance(cip_class, instance_id);

  if(NULL == instance) { 
    instance = AddCipInstances(cip_class, 1);
    instance->instance_number = instance_id;
  }

  cip_class->max_instance = GetMaxInstanceNumber(cip_class); 

  return instance;
}

CipClass *CreateCipClass(const CipUdint class_code, const int number_of_class_attributes, const EipUint32 highest_class_attribute_number, const int number_of_class_services, const int number_of_instance_attributes, const EipUint32 highest_instance_attribute_number, const int number_of_instance_services, const int number_of_instances, const char *const name, const EipUint16 revision, InitializeCipClass initializer) {










  OPENER_TRACE_INFO("creating class '%s' with code: 0x%" PRIX32 "\n", name, class_code);

  OPENER_ASSERT( NULL == GetCipClass(class_code) ); 
  

  

  CipClass *const cip_class = (CipClass *) CipCalloc( 1, sizeof(CipClass) ); 
  CipClass *const meta_class = (CipClass *) CipCalloc( 1, sizeof(CipClass) ); 

  
  cip_class->class_code = class_code; 
  cip_class->revision = revision; 
  cip_class->max_instance = 0; 
  cip_class->number_of_instances = 0; 
  cip_class->instances = 0;
  cip_class->number_of_attributes = number_of_instance_attributes; 
  cip_class->highest_attribute_number = highest_instance_attribute_number; 
  cip_class->number_of_services = number_of_instance_services; 
  cip_class->services = 0;
  cip_class->class_name = name; 
  meta_class->class_code = 0xffffffff; 
  meta_class->number_of_instances = 1; 
  meta_class->instances = (CipInstance *) cip_class;
  meta_class->number_of_attributes = number_of_class_attributes + 7; 
  meta_class->highest_attribute_number = highest_class_attribute_number; 
  meta_class->number_of_services = number_of_class_services; 
  meta_class->class_name = (char *) CipCalloc(1, strlen(name) + 6); 
  snprintf(meta_class->class_name, strlen(name) + 6, "meta-%s", name);

  
  cip_class->class_instance.instance_number = 0; 
  cip_class->class_instance.attributes = 0; 
  cip_class->class_instance.cip_class = meta_class; 
  cip_class->class_instance.next = 0; 

  meta_class->class_instance.instance_number = 0xffffffff; 
  meta_class->class_instance.attributes = NULL;
  meta_class->class_instance.cip_class = NULL; 
  meta_class->class_instance.next = NULL; 

  

  cip_class->class_instance.attributes = (CipAttributeStruct *) CipCalloc( meta_class->number_of_attributes, sizeof(CipAttributeStruct) );

  

  meta_class->services = (CipServiceStruct *) CipCalloc( meta_class->number_of_services, sizeof(CipServiceStruct) );


  cip_class->services = (CipServiceStruct *) CipCalloc( cip_class->number_of_services, sizeof(CipServiceStruct) );


  if(number_of_instances > 0) {
    AddCipInstances(cip_class, number_of_instances); 
  }

  if(RegisterCipClass(cip_class) == kEipStatusError) {
    return 0; 
  }

  AllocateAttributeMasks(meta_class); 
  AllocateAttributeMasks(cip_class); 

  if(NULL == initializer) {
    InsertAttribute( (CipInstance *) cip_class, 1, kCipUint, EncodeCipUint, NULL, (void *) &cip_class->revision, kGetableSingleAndAll );

    InsertAttribute( (CipInstance *) cip_class, 2, kCipUint, EncodeCipUint, NULL, (void *) &cip_class->max_instance, kGetableSingleAndAll );

    InsertAttribute( (CipInstance *) cip_class, 3, kCipUint, EncodeCipUint, NULL, (void *) &cip_class->number_of_instances, kGetableSingleAndAll );

    InsertAttribute( (CipInstance *) cip_class, 4, kCipUint, EncodeCipUint, NULL, (void *) &kCipUintZero, kGetableAllDummy );
    InsertAttribute( (CipInstance *) cip_class, 5, kCipUint, EncodeCipUint, NULL, (void *) &kCipUintZero, kNotSetOrGetable );
    InsertAttribute( (CipInstance *) cip_class, 6, kCipUint, EncodeCipUint, NULL, (void *) &meta_class->highest_attribute_number, kGetableSingle );

    InsertAttribute( (CipInstance *) cip_class, 7, kCipUint, EncodeCipUint, NULL, (void *) &cip_class->highest_attribute_number, kGetableSingle );

    if(number_of_class_services > 0) {
      if(number_of_class_services > 1) { 
        InsertService(meta_class, kGetAttributeAll, &GetAttributeAll, "GetAttributeAll");


      }
      InsertService(meta_class, kGetAttributeSingle, &GetAttributeSingle, "GetAttributeSingle");


    }
  } else {
    initializer(cip_class);
  }

  
  return cip_class;
}

void InsertAttribute(CipInstance *const instance, const EipUint16 attribute_number, const EipUint8 cip_type, CipAttributeEncodeInMessage encode_function, CipAttributeDecodeFromMessage decode_function, void *const data, const EipByte cip_flags) {






  OPENER_ASSERT(NULL != data); 

  CipAttributeStruct *attribute = instance->attributes;
  CipClass *cip_class = instance->cip_class;

  OPENER_ASSERT(NULL != attribute);
  
  for(int i = 0; i < instance->cip_class->number_of_attributes; i++) {
    if(attribute->data == NULL) { 
      attribute->attribute_number = attribute_number;
      attribute->type = cip_type;
      attribute->encode = encode_function;
      attribute->decode = decode_function;
      attribute->attribute_flags = cip_flags;
      attribute->data = data;

      OPENER_ASSERT(attribute_number <= cip_class->highest_attribute_number);

      size_t index = CalculateIndex(attribute_number);

      cip_class->get_single_bit_mask[index] |= (cip_flags & kGetableSingle) ? 1 << (attribute_number) % 8 : 0;
      cip_class->get_all_bit_mask[index] |= ( cip_flags & (kGetableAll | kGetableAllDummy) ) ? 1 << (attribute_number) % 8 : 0;

      cip_class->set_bit_mask[index] |= ( (cip_flags & kSetable) ? 1 : 0 ) << ( (attribute_number) % 8 );

      return;
    }
    attribute++;
  } OPENER_TRACE_ERR( "Tried to insert too many attributes into class: %" PRIu32 " '%s', instance %" PRIu32 "\n", cip_class->class_code, cip_class->class_name, instance->instance_number);



  OPENER_ASSERT(false);
  
}

void InsertService(const CipClass *const cip_class, const EipUint8 service_number, const CipServiceFunction service_function, char *const service_name) {



  CipServiceStruct *service = cip_class->services; 
  OPENER_TRACE_INFO("%s, number of services:%d, service number:%d\n", cip_class->class_name, cip_class->number_of_services, service_number);

  OPENER_ASSERT(service != NULL);
  
  for(int i = 0; i < cip_class->number_of_services; i++) 
  {
    if(service->service_number == service_number || service->service_function == NULL)
    {
      service->service_number = service_number; 
      service->service_function = service_function; 
      service->name = service_name;
      return;
    }
    ++service;
  }
  OPENER_ASSERT(false);
  
}

void InsertGetSetCallback(CipClass *const cip_class, CipGetSetCallback callback_function, CIPAttributeFlag callbacks_to_install) {

  if( 0 != (kPreGetFunc & callbacks_to_install) ) {
    cip_class->PreGetCallback = callback_function;
  }
  if( 0 != (kPostGetFunc & callbacks_to_install) ) {
    cip_class->PostGetCallback = callback_function;
  }
  if( 0 != (kPreSetFunc & callbacks_to_install) ) {
    cip_class->PreSetCallback = callback_function;
  }
  
  if( 0 != ( (kPostSetFunc | kNvDataFunc) & callbacks_to_install ) ) {
    cip_class->PostSetCallback = callback_function;
  }
}

CipAttributeStruct *GetCipAttribute(const CipInstance *const instance, const EipUint16 attribute_number) {

  CipAttributeStruct *attribute = instance->attributes; 
  for(int i = 0; i < instance->cip_class->number_of_attributes; i++) {
    if(attribute_number == attribute->attribute_number) {
      return attribute;
    } else {
      ++attribute;
    }
  }

  OPENER_TRACE_WARN("attribute %d not defined\n", attribute_number);

  return NULL;
}

void GenerateGetAttributeSingleHeader( const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {

  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorAttributeNotSupported;
  message_router_response->size_of_additional_status = 0;
}


EipStatus GetAttributeSingle(CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  

  CipAttributeStruct *attribute = GetCipAttribute(instance, message_router_request->request_path.attribute_number);

  GenerateGetAttributeSingleHeader(message_router_request, message_router_response);

  EipUint16 attribute_number = message_router_request->request_path.attribute_number;

  if( (NULL != attribute) && (NULL != attribute->data) ) {
    uint8_t get_bit_mask = (instance->cip_class->get_single_bit_mask[CalculateIndex(attribute_number)
       ]);
    if( 0 != ( get_bit_mask & ( 1 << (attribute_number % 8) ) ) ) {
      OPENER_TRACE_INFO("getAttribute %d\n", message_router_request->request_path.attribute_number);

      
      if( (attribute->attribute_flags & kPreGetFunc) && NULL != instance->cip_class->PreGetCallback ) {
        instance->cip_class->PreGetCallback(instance, attribute, message_router_request->service);

      }

      OPENER_ASSERT(NULL != attribute);
      attribute->encode(attribute->data, &message_router_response->message);
      message_router_response->general_status = kCipErrorSuccess;

      
      if( (attribute->attribute_flags & kPostGetFunc) && NULL != instance->cip_class->PostGetCallback ) {
        instance->cip_class->PostGetCallback(instance, attribute, message_router_request->service);

      }
    }
  }

  return kEipStatusOkSend;
}

void EncodeCipBool(const CipBool *const data, ENIPMessage *const outgoing_message) {
  AddSintToMessage(*(EipUint8 *) (data), outgoing_message);
}

void EncodeCipByte(const CipByte *const data, ENIPMessage *const outgoing_message) {
  AddSintToMessage(*(EipUint8 *) (data), outgoing_message);
}

void EncodeCipWord(const CipWord *const data, ENIPMessage *const outgoing_message) {
  AddIntToMessage(*(EipUint16 *) (data), outgoing_message);
}

void EncodeCipDword(const CipDword *const data, ENIPMessage *const outgoing_message) {
  AddDintToMessage(*(EipUint32 *) (data), outgoing_message);
}

void EncodeCipLword(const CipLword *const data, ENIPMessage *const outgoing_message) {
  AddLintToMessage(*(EipUint64 *) (data), outgoing_message);
}

void EncodeCipUsint(const CipUsint *const data, ENIPMessage *const outgoing_message) {
  AddSintToMessage(*(EipUint8 *) (data), outgoing_message);
}

void EncodeCipUint(const CipUint *const data, ENIPMessage *const outgoing_message) {
  AddIntToMessage(*(EipUint16 *) (data), outgoing_message);
}

void EncodeCipUdint(const CipUdint *const data, ENIPMessage *const outgoing_message) {
  AddDintToMessage(*(EipUint32 *) (data), outgoing_message);
}

void EncodeCipUlint(const CipUlint *const data, ENIPMessage *const outgoing_message) {
  AddLintToMessage(*(EipUint64 *) (data), outgoing_message);
}

void EncodeCipSint(const CipSint *const data, ENIPMessage *const outgoing_message) {
  AddSintToMessage(*(EipUint8 *) (data), outgoing_message);
}

void EncodeCipInt(const CipInt *const data, ENIPMessage *const outgoing_message) {
  AddIntToMessage(*(EipUint16 *) (data), outgoing_message);
}

void EncodeCipDint(const CipDint *const data, ENIPMessage *const outgoing_message) {
  AddDintToMessage(*(EipUint32 *) (data), outgoing_message);
}

void EncodeCipLint(const CipLint *const data, ENIPMessage *const outgoing_message) {
  AddLintToMessage(*(EipUint64 *) (data), outgoing_message);
}

void EncodeCipReal(const CipReal *const data, ENIPMessage *const outgoing_message) {
  AddDintToMessage(*(EipUint32 *) (data), outgoing_message);
}

void EncodeCipLreal(const CipLreal *const data, ENIPMessage *const outgoing_message) {
  AddLintToMessage(*(EipUint64 *) (data), outgoing_message);
}

void EncodeCipShortString(const CipShortString *const data, ENIPMessage *const outgoing_message) {
  CipShortString *const short_string = (CipShortString *) data;

  AddSintToMessage(short_string->length, outgoing_message);

  memcpy(outgoing_message->current_message_position, short_string->string, short_string->length);

  outgoing_message->current_message_position += short_string->length;
  outgoing_message->used_message_length += short_string->length;
}

void EncodeCipString(const CipString *const data, ENIPMessage *const outgoing_message) {
  CipString *const string = (CipString *) data;

  AddIntToMessage(*(EipUint16 *) &(string->length), outgoing_message);
  if(0 != string->length) {
    memcpy(outgoing_message->current_message_position, string->string, string->length);

    outgoing_message->current_message_position += string->length;
    outgoing_message->used_message_length += string->length;

    if(outgoing_message->used_message_length & 0x01) {
      
      AddSintToMessage(0, outgoing_message);
    }
  }
}

void EncodeCipString2(const CipString2 *const data, ENIPMessage *const outgoing_message) {
  OPENER_ASSERT(false); 
}

void EncodeCipStringN(const CipStringN *const data, ENIPMessage *const outgoing_message) {
  OPENER_ASSERT(false); 
}

static void CipStringIHeaderEncoding(const CipStringIStruct *const string, ENIPMessage *const outgoing_message) {
  EncodeCipUsint(&(string->language_char_1), outgoing_message);
  EncodeCipUsint(&(string->language_char_2), outgoing_message);
  EncodeCipUsint(&(string->language_char_3), outgoing_message);
  EncodeCipUsint(&(string->char_string_struct), outgoing_message);
  EncodeCipUint(&(string->character_set), outgoing_message);
}

void EncodeCipStringI(const CipStringI *const data, ENIPMessage *const outgoing_message) {
  const CipStringI *const string_i = data;
  EncodeCipUsint(&(string_i->number_of_strings), outgoing_message);
  for(size_t i = 0; i < string_i->number_of_strings; ++i) {
    CipStringIHeaderEncoding( (string_i->array_of_string_i_structs) + i, outgoing_message );
    switch(string_i->array_of_string_i_structs[i].char_string_struct) {
      case kCipString:
        EncodeCipString(string_i->array_of_string_i_structs[i].string, outgoing_message);
        break;
      case kCipString2:
        EncodeCipString2(string_i->array_of_string_i_structs[i].string, outgoing_message);
        break;
      case kCipStringN:
        EncodeCipStringN(string_i->array_of_string_i_structs[i].string, outgoing_message);
        break;
      case kCipShortString:
        EncodeCipShortString(string_i->array_of_string_i_structs[i].string, outgoing_message);
        break;
      default:
        OPENER_ASSERT(false);
        break;
    }
  }
}

void EncodeCipByteArray(const CipByteArray *const data, ENIPMessage *const outgoing_message) {
  OPENER_TRACE_INFO(" -> get attribute byte array\r\n");
  CipByteArray *cip_byte_array = (CipByteArray *) data;
  memcpy(outgoing_message->current_message_position, cip_byte_array->data, cip_byte_array->length);

  outgoing_message->current_message_position += cip_byte_array->length;
  outgoing_message->used_message_length += cip_byte_array->length;
}

void EncodeCipEPath(const CipEpath *const data, ENIPMessage *const outgoing_message) {
  AddIntToMessage(data->path_size, outgoing_message);
  EncodeEPath( (CipEpath *) data, outgoing_message );
}

void EncodeCipEthernetLinkPhyisicalAddress(const void *const data, ENIPMessage *const outgoing_message)
{
  EipUint8 *p = (EipUint8 *) data;
  memcpy(outgoing_message->current_message_position, p, 6);
  outgoing_message->current_message_position += 6;
  outgoing_message->used_message_length += 6;
}

void GenerateSetAttributeSingleHeader( const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {

  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorAttributeNotSupported;
  message_router_response->size_of_additional_status = 0;
}

EipStatus SetAttributeSingle(CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  CipAttributeStruct *attribute = GetCipAttribute(instance, message_router_request->request_path.attribute_number);

  GenerateSetAttributeSingleHeader(message_router_request, message_router_response);

  EipUint16 attribute_number = message_router_request->request_path.attribute_number;

  
  if( (NULL != attribute) && (NULL != attribute->data) ) {

    if( (attribute->attribute_flags == kGetableAllDummy) || (attribute->attribute_flags == kNotSetOrGetable) || (attribute->attribute_flags == kGetableAll) ) {

      OPENER_TRACE_WARN("SetAttributeSingle: Attribute %d not supported!\n\r", attribute_number);
    } else {
      uint8_t set_bit_mask = (instance->cip_class->set_bit_mask[CalculateIndex(attribute_number)]);
      if( 0 != ( set_bit_mask & ( 1 << (attribute_number % 8) ) ) ) {
        OPENER_TRACE_INFO("setAttribute %d\n", attribute_number);

        
        if( (attribute->attribute_flags & kPreSetFunc) && NULL != instance->cip_class->PreSetCallback ) {
          instance->cip_class->PreSetCallback(instance, attribute, message_router_request->service);

        }

        OPENER_ASSERT(NULL != attribute);

        attribute->decode(attribute->data, message_router_request, message_router_response);


        
        if( ( attribute->attribute_flags & (kPostSetFunc | kNvDataFunc) ) && NULL != instance->cip_class->PostSetCallback ) {
          instance->cip_class->PostSetCallback(instance, attribute, message_router_request->service);

        }
      } else {
        message_router_response->general_status = kCipErrorAttributeNotSetable;
        OPENER_TRACE_WARN("SetAttributeSingle: Attribute %d not setable!\n\r", attribute_number);
      }

    }
  }

  return kEipStatusOkSend;
}

int DecodeCipBool(CipBool *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetBoolFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 1;
}

int DecodeCipByte(CipByte *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetByteFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 1;
}

int DecodeCipByteArray(CipByteArray *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response)

{

  const EipUint8 **const cip_message = message_router_request->data;

  int number_of_decoded_bytes = -1;
  OPENER_TRACE_INFO(" -> set attribute byte array\r\n");
  CipByteArray *cip_byte_array = data;

  if(message_router_request->request_data_size < data->length) {
    OPENER_TRACE_INFO( "DecodeCipByteArray: not enough data received.\n");
    message_router_response->general_status = kCipErrorNotEnoughData;
    return number_of_decoded_bytes;
  }
  if(message_router_request->request_data_size > data->length) {
    OPENER_TRACE_INFO( "DecodeCipByteArray: too much data received.\n");
    message_router_response->general_status = kCipErrorTooMuchData;
    return number_of_decoded_bytes;
  }

  
  memcpy(cip_byte_array->data, &cip_message, cip_byte_array->length);
  number_of_decoded_bytes = cip_byte_array->length;

  message_router_response->general_status = kCipErrorSuccess;
  return number_of_decoded_bytes;
}

int DecodeCipWord(CipWord *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetWordFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 2;
}

int DecodeCipDword(CipDword *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetDintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 4;
}

int DecodeCipLword(CipLword *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetLintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 4;
}

int DecodeCipUsint(CipUsint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetUsintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 1;
}

int DecodeCipUint(CipUint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetUintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 2;
}

int DecodeCipUdint(CipUdint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetUdintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 4;
}

int DecodeCipUlint(CipUlint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetLintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 8;
}

int DecodeCipSint(CipSint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetSintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 1;
}

int DecodeCipInt(CipInt *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetIntFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 2;
}

int DecodeCipDint(CipDint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetDintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 4;
}

int DecodeCipLint(CipLint *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetLintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 8;
}

int DecodeCipReal(CipReal *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetDintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 4;
}

int DecodeCipLreal(CipLreal *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  *data = GetLintFromMessage(&message_router_request->data);
  message_router_response->general_status = kCipErrorSuccess;
  return 8;
}

int DecodeCipString(CipString *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response) {


  const EipUint8 **const cip_message = message_router_request->data;

  int number_of_decoded_bytes = -1;
  CipString *string = data;
  string->length = GetIntFromMessage(&cip_message);
  memcpy(string->string, cip_message, string->length);
  *cip_message += string->length;

  number_of_decoded_bytes = string->length + 2; 
  if(number_of_decoded_bytes & 0x01) {
    
    ++(*cip_message);
    number_of_decoded_bytes++;
  }
  message_router_response->general_status = kCipErrorSuccess;
  return number_of_decoded_bytes;
}

int DecodeCipShortString(CipShortString *const data, const CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response)

{

  const EipUint8 **const cip_message = message_router_request->data;

  int number_of_decoded_bytes = -1;
  CipShortString *short_string = data;

  short_string->length = **cip_message;
  ++(*cip_message);

  memcpy(short_string->string, &cip_message, short_string->length);
  *cip_message += short_string->length;

  number_of_decoded_bytes = short_string->length + 1;
  message_router_response->general_status = kCipErrorSuccess;
  return number_of_decoded_bytes;
}

CipServiceStruct *GetCipService(const CipInstance *const instance, CipUsint service_number) {
  CipServiceStruct *service = instance->cip_class->services;
  for(size_t i = 0; i < instance->cip_class->number_of_services; i++) 
  {
    if(service->service_number == service_number) {
      return service; 
    }
    service++;
  }
  return NULL; 
}

EipStatus GetAttributeAll(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  InitializeENIPMessage(&message_router_response->message);
  CipAttributeStruct *attribute = instance->attributes; 

  

  if(0 == instance->cip_class->number_of_attributes) {
    
    message_router_response->reply_service = (0x80 | message_router_request->service);
    message_router_response->general_status = kCipErrorServiceNotSupported;
    message_router_response->size_of_additional_status = 0;
  } else {
    GenerateGetAttributeSingleHeader(message_router_request, message_router_response);
    message_router_response->general_status = kCipErrorSuccess;
    for(size_t j = 0; j < instance->cip_class->number_of_attributes; j++) {
      
      EipUint16 attribute_number = attribute->attribute_number;
      if( (instance->cip_class->get_all_bit_mask[CalculateIndex(attribute_number)
           ]) & ( 1 << (attribute_number % 8) ) ) {
        
        message_router_request->request_path.attribute_number = attribute_number;

        attribute->encode(attribute->data, &message_router_response->message);
      }
      attribute++;
    }
  }
  return kEipStatusOkSend;
}

EipStatus GetAttributeList(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorSuccess;
  message_router_response->size_of_additional_status = 0;

  CipUint attribute_count_request = GetUintFromMessage( &message_router_request->data);

  if(0 != attribute_count_request) {

    EipUint16 attribute_number = 0;
    CipAttributeStruct *attribute = NULL;

    AddIntToMessage(attribute_count_request, &message_router_response->message); 

    for(size_t j = 0; j < attribute_count_request; j++) {

      attribute_number = GetUintFromMessage(&message_router_request->data);
      attribute = GetCipAttribute(instance, attribute_number);

      AddIntToMessage(attribute_number, &message_router_response->message); 

      if(NULL != attribute) {

        uint8_t get_bit_mask = (instance->cip_class->get_single_bit_mask[CalculateIndex( attribute_number)]);

        if( 0 != ( get_bit_mask & ( 1 << (attribute_number % 8) ) ) ) { 
          AddSintToMessage(kCipErrorSuccess, &message_router_response->message); 
          AddSintToMessage(0, &message_router_response->message); 
          attribute->encode(attribute->data, &message_router_response->message); 
        } else {
          AddSintToMessage(kCipErrorAttributeNotGettable, &message_router_response->message);
          AddSintToMessage(0, &message_router_response->message); 
          message_router_response->general_status = kCipErrorAttributeListError;
        }

      } else {
        AddSintToMessage(kCipErrorAttributeNotSupported, &message_router_response->message);
        AddSintToMessage(0, &message_router_response->message); 
        message_router_response->general_status = kCipErrorAttributeListError;
      }
    }
  } else {
    message_router_response->general_status = kCipErrorAttributeListError;
  }

  return kEipStatusOkSend;
}

EipStatus SetAttributeList(CipInstance *instance, CipMessageRouterRequest *message_router_request, CipMessageRouterResponse *message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorSuccess;
  message_router_response->size_of_additional_status = 0;

  CipUint attribute_count_request = GetUintFromMessage( &message_router_request->data);

  if(0 != attribute_count_request) {

    EipUint16 attribute_number = 0;
    CipAttributeStruct *attribute = NULL;

    AddIntToMessage(attribute_count_request, &message_router_response->message); 

    for(size_t j = 0; j < attribute_count_request; j++) {

      attribute_number = GetUintFromMessage(&message_router_request->data);
      attribute = GetCipAttribute(instance, attribute_number);

      AddIntToMessage(attribute_number, &message_router_response->message); 

      if(NULL != attribute) {

        uint8_t set_bit_mask = (instance->cip_class->set_bit_mask[CalculateIndex(attribute_number)]);
        if( 0 != ( set_bit_mask & ( 1 << (attribute_number % 8) ) ) ) { 
          AddSintToMessage(kCipErrorSuccess, &message_router_response->message); 
          AddSintToMessage(0, &message_router_response->message); 
          attribute->decode(attribute->data, message_router_request, message_router_response);

        } else {
          AddSintToMessage(kCipErrorAttributeNotSetable, &message_router_response->message);
          AddSintToMessage(0, &message_router_response->message); 

          
          int attribute_data_length = GetCipDataTypeLength(attribute->type, message_router_request->data);
          if(0 != attribute_data_length) {
            message_router_request->data += attribute_data_length;
            message_router_response->general_status = kCipErrorAttributeListError;
          } else {
            message_router_response->general_status = kCipErrorPartialTransfer;
            return kEipStatusOkSend;
          }
        }
      } else {
        AddSintToMessage(kCipErrorAttributeNotSupported, &message_router_response->message);
        AddSintToMessage(0, &message_router_response->message); 
        message_router_response->general_status = kCipErrorAttributeListError;
      }
    }
  } else {
    message_router_response->general_status = kCipErrorAttributeListError;
  }

  return kEipStatusOkSend;
}

void EncodeEPath(const CipEpath *const epath, ENIPMessage *const message) {
  unsigned int length = epath->path_size;
  size_t start_length = message->used_message_length;

  if(epath->class_id < 256) {
    AddSintToMessage(0x20, message); 
    AddSintToMessage( (EipUint8) epath->class_id, message );
    length -= 1;
  } else {
    AddSintToMessage(0x21, message); 
    AddSintToMessage(0, message); 
    AddIntToMessage(epath->class_id, message);
    length -= 2;
  }

  if(0 < length) {
    if(epath->instance_number < 256) {
      AddSintToMessage(0x24, message); 
      AddSintToMessage(epath->instance_number, message);
      length -= 1;
    } else {
      AddSintToMessage(0x25, message); 
      AddSintToMessage(0, message); 
      AddIntToMessage(epath->instance_number, message);
      length -= 2;
    }

    if(0 < length) {
      if(epath->attribute_number < 256) {
        AddSintToMessage(0x30, message); 
        AddSintToMessage(epath->attribute_number, message);
        length -= 1;
      } else {
        AddSintToMessage(0x31, message); 
        AddSintToMessage(0, message); 
        AddIntToMessage(epath->attribute_number, message);
        length -= 2;
      }
    }
  }

  OPENER_ASSERT( epath->path_size * 2 == message->used_message_length - start_length);
}

int DecodePaddedEPath(CipEpath *epath, const EipUint8 **message) {
  unsigned int number_of_decoded_elements = 0;
  const EipUint8 *message_runner = *message;

  epath->path_size = *message_runner;
  message_runner++;
  
  epath->class_id = 0;
  epath->instance_number = 0;
  epath->attribute_number = 0;

  while(number_of_decoded_elements < epath->path_size) {
    if( kSegmentTypeReserved == ( (*message_runner) & kSegmentTypeReserved ) ) {
      
      return kEipStatusError;
    }

    number_of_decoded_elements++; 
    switch(*message_runner) {
      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_CLASS_ID + LOGICAL_SEGMENT_FORMAT_EIGHT_BIT:
        epath->class_id = *(EipUint8 *) (message_runner + 1);
        message_runner += 2;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_CLASS_ID + LOGICAL_SEGMENT_FORMAT_SIXTEEN_BIT:
        message_runner += 2;
        epath->class_id = GetUintFromMessage( &(message_runner) );
        number_of_decoded_elements++;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_INSTANCE_ID + LOGICAL_SEGMENT_FORMAT_EIGHT_BIT:
        epath->instance_number = *(EipUint8 *) (message_runner + 1);
        message_runner += 2;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_INSTANCE_ID + LOGICAL_SEGMENT_FORMAT_SIXTEEN_BIT:
        message_runner += 2;
        epath->instance_number = GetUintFromMessage( &(message_runner) );
        number_of_decoded_elements++;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_ATTRIBUTE_ID + LOGICAL_SEGMENT_FORMAT_EIGHT_BIT:
        epath->attribute_number = *(EipUint8 *) (message_runner + 1);
        message_runner += 2;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_ATTRIBUTE_ID + LOGICAL_SEGMENT_FORMAT_SIXTEEN_BIT:
        message_runner += 2;
        epath->attribute_number = GetUintFromMessage( &(message_runner) );
        number_of_decoded_elements++;
        break;

      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_MEMBER_ID + LOGICAL_SEGMENT_FORMAT_EIGHT_BIT:
        message_runner += 2;
        break;
      case SEGMENT_TYPE_LOGICAL_SEGMENT + LOGICAL_SEGMENT_TYPE_MEMBER_ID + LOGICAL_SEGMENT_FORMAT_SIXTEEN_BIT:
        message_runner += 2;
        number_of_decoded_elements++;
        break;

      default:
        OPENER_TRACE_ERR("wrong path requested\n");
        return kEipStatusError;
    }
  }

  *message = message_runner;
  return number_of_decoded_elements * 2 + 1; 
}

EipStatus CipCreateService(CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);
  message_router_response->general_status = kCipErrorSuccess;
  message_router_response->size_of_additional_status = 0;

  CipClass *class = GetCipClass(message_router_request->request_path.class_id);

  EipStatus internal_state = kEipStatusOk;

  
  if( NULL != class->PreCreateCallback) {
    internal_state = class->PreCreateCallback(instance, message_router_request, message_router_response);

  }

  if (kEipStatusOk == internal_state) {
    CipInstance *new_instance = AddCipInstances(class, 1); 
    OPENER_ASSERT(NULL != new_instance); 

    
    if (NULL != class->PostCreateCallback) {
      class->PostCreateCallback(new_instance, message_router_request, message_router_response);

    }
    OPENER_TRACE_INFO("Instance number %d created\n", new_instance->instance_number);
  }
  return kEipStatusOkSend;
}

EipStatus CipDeleteService(CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {




  message_router_response->general_status = kCipErrorInstanceNotDeletable;
  message_router_response->size_of_additional_status = 0;
  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);

  EipStatus internal_state = kEipStatusOk;

  CipClass *const class = instance->cip_class;

  
  if (NULL != class->PreDeleteCallback) {
    internal_state = class->PreDeleteCallback(instance, message_router_request, message_router_response);
  }

  if (kEipStatusOk == internal_state) {
    CipInstance *instances = class->instances;

    
    instances = class->instances; 
    if (instances->instance_number == instance->instance_number) {
      class->instances = instances->next;
    } else {
      while (NULL != instances->next)  
      {
        CipInstance *next_instance = instances->next;
        if (next_instance->instance_number == instance->instance_number) {
          instances->next = next_instance->next;
          break;
        }
        instances = instances->next;
      }
    }

    
    if (NULL != class->PostDeleteCallback) {
      class->PostDeleteCallback(instance, message_router_request, message_router_response);
    }

    CipFree(instance);  

    class->number_of_instances--; 

    class->max_instance = GetMaxInstanceNumber(class); 

    message_router_response->general_status = kCipErrorSuccess;
  }
  return kEipStatusOk;
}

EipStatus CipResetService(CipInstance *RESTRICT const instance, CipMessageRouterRequest *const message_router_request, CipMessageRouterResponse *const message_router_response, const struct sockaddr *originator_address, const int encapsulation_session) {



  message_router_response->general_status = kCipErrorSuccess;
  message_router_response->size_of_additional_status = 0;
  InitializeENIPMessage(&message_router_response->message);
  message_router_response->reply_service = (0x80 | message_router_request->service);

  EipStatus internal_state = kEipStatusOk;

  CipClass *const class = instance->cip_class;

  
  if (NULL != class->PreResetCallback) {
    internal_state = class->PreResetCallback(instance, message_router_request, message_router_response);
  }

  if (kEipStatusError != internal_state) {
    
    if (NULL != class->PostResetCallback) {
      class->PostResetCallback(instance, message_router_request, message_router_response);
    }
  }
  return internal_state;
}

void AllocateAttributeMasks(CipClass *target_class) {
  unsigned size = 1 + CalculateIndex(target_class->highest_attribute_number);
  OPENER_TRACE_INFO( ">>> Allocate memory for %s %u bytes times 3 for masks\n", target_class->class_name, size);

  target_class->get_single_bit_mask = CipCalloc( size, sizeof(uint8_t) );
  target_class->set_bit_mask = CipCalloc( size, sizeof(uint8_t) );
  target_class->get_all_bit_mask = CipCalloc( size, sizeof(uint8_t) );
}

size_t CalculateIndex(EipUint16 attribute_number) {
  size_t index = attribute_number / 8;
  return index;
}
