



















static const CipUsint s_0xFF_default = 0xFFU;
static const CipUint s_0xFFFF_default = 0xFFFFU;

static const CipUsint s_0x00_default = 0x00U;
static const CipUint s_0x0000_default = 0x0000U;
static const CipUdint s_0x00000000_default = 0x00000000U;

static const CipNodeAddress s_zero_node = {
  .device_ip = 0, .device_mac = {
    0, 0, 0, 0, 0, 0, }
};


CipDlrObject g_dlr;  



static void EncodeCipRingSupervisorConfig(const void *const data, ENIPMessage *const outgoing_message) {
  const size_t kRingSupStructSize = 12u;
  FillNextNMessageOctetsWithValueAndMoveToNextPosition(0, kRingSupStructSize, outgoing_message);

}

static void EncodeCipNodeAddress(const void *const data, ENIPMessage *const outgoing_message) {
  CipNodeAddress *node_address = (CipNodeAddress *)data;
  EncodeCipUdint(&node_address->device_ip, outgoing_message);
  EncodeCipEthernetLinkPhyisicalAddress(&node_address->device_mac, outgoing_message);
}



EipStatus CipDlrInit(void) {
  CipClass *dlr_class = NULL;

  dlr_class = CreateCipClass(kCipDlrClassCode, 0, 7, 2, 11, 12, 2, 1, "DLR", DLR_CLASS_REVISION, NULL );











  if (NULL == dlr_class) {
    return kEipStatusError;
  }

  
  InsertService(dlr_class, kGetAttributeSingle, GetAttributeSingle, "GetAttributeSingle");
  InsertService(dlr_class, kGetAttributeAll, GetAttributeAll, "GetAttributeAll");

  
  CipInstance *dlr_instance = GetCipInstance(dlr_class, 1u);

  InsertAttribute(dlr_instance, 1, kCipUsint, EncodeCipUsint, NULL, &g_dlr.network_topology, kGetableSingleAndAll);





  InsertAttribute(dlr_instance, 2, kCipUsint, EncodeCipUsint, NULL, &g_dlr.network_status, kGetableSingleAndAll);





  InsertAttribute(dlr_instance, 3, kCipUsint, EncodeCipUsint, NULL, (void *)&s_0xFF_default, kGetableAll);





  InsertAttribute(dlr_instance, 4, kCipAny, EncodeCipRingSupervisorConfig, NULL, (void *)&s_0x00000000_default, kGetableAllDummy);





  InsertAttribute(dlr_instance, 5, kCipUint, EncodeCipUint, NULL, (void *)&s_0x0000_default, kGetableAll);





  InsertAttribute(dlr_instance, 6, kCipAny, EncodeCipNodeAddress, NULL, (void *)&s_zero_node, kGetableAll);





  InsertAttribute(dlr_instance, 7, kCipAny, EncodeCipNodeAddress, NULL, (void *)&s_zero_node, kGetableAll);





  InsertAttribute(dlr_instance, 8, kCipUint, EncodeCipUint, NULL, (void *)&s_0xFFFF_default, kGetableAll);





  
  InsertAttribute(dlr_instance, 10, kCipAny, EncodeCipNodeAddress, NULL, &g_dlr.active_supervisor_address, kGetableSingleAndAll);





  InsertAttribute(dlr_instance, 11, kCipUsint, EncodeCipUsint, NULL, (void *)&s_0x00_default, kGetableAll);





  InsertAttribute(dlr_instance, 12, kCipDword, EncodeCipDword, NULL, &g_dlr.capability_flags, kGetableSingleAndAll);






  
  
  g_dlr.capability_flags = (kDlrCapBeaconBased | kDlrCapFlushTableFrame);

  return kEipStatusOk;
}
