











namespace tensorflow {

class CompositeTensorVariantFromComponents : public OpKernel {
 public:
  explicit CompositeTensorVariantFromComponents(OpKernelConstruction* context)
      : OpKernel(context) {
    string type_spec_string;
    OP_REQUIRES_OK(context, context->GetAttr("metadata", &type_spec_string));
    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string), errors::InvalidArgument("Error parsing metadata"));
  }

  void Compute(OpKernelContext* context) override {
    OpInputList components_in;
    OP_REQUIRES_OK(context, context->input_list("components", &components_in));

    Tensor* encoded;
    OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}), &encoded));

    std::vector<Tensor> components{components_in.begin(), components_in.end()};
    encoded->flat<Variant>()(0) = CompositeTensorVariant(metadata_, absl::MakeSpan(components));
  }

 private:
  CompositeTensorVariantMetadata metadata_;
};

class CompositeTensorVariantToComponents : public OpKernel {
 public:
  explicit CompositeTensorVariantToComponents(OpKernelConstruction* context)
      : OpKernel(context) {
    string type_spec_string;
    OP_REQUIRES_OK(context, context->GetAttr("metadata", &type_spec_string));
    OP_REQUIRES(context, metadata_.ParseFromString(type_spec_string), errors::InvalidArgument("Error parsing `metadata`"));

    OP_REQUIRES_OK(context, context->GetAttr("Tcomponents", &component_dtypes_));
  }

  void Compute(OpKernelContext* context) override {
    Tensor encoded_t = context->input(0);
    OP_REQUIRES( context, encoded_t.flat<Variant>().size() > 0, errors::InvalidArgument("Input `encoded` must not be an empty variant " "tensor, but got ", encoded_t.DebugString()));



    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();

    
    
    
    
    
    
    
    auto expected_class = metadata_.type_spec_proto().type_spec_class();
    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();
    OP_REQUIRES( context, expected_class == actual_class, errors::InvalidArgument( "Expected a ", TypeSpecProto::TypeSpecClass_Name(expected_class), " (based on `type_spec`), but `encoded` contains a ", TypeSpecProto::TypeSpecClass_Name(actual_class)));





    
    OpOutputList components;
    OP_REQUIRES_OK(context, context->output_list("components", &components));
    int num_components = encoded->flat_components().size();

    OP_REQUIRES(context, component_dtypes_.size() == num_components, errors::InvalidArgument("Encoded value has ", num_components, " tensor components; expected ", component_dtypes_.size(), " components based on type_spec"));




    for (int i = 0; i < component_dtypes_.size(); i++) {
      const Tensor& component = encoded->flat_components()[i];
      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(), errors::InvalidArgument("Tensor component ", i, " had dtype ", DataType_Name(component.dtype()), "; expected dtype ", DataType_Name(component_dtypes_[i])));



      components.set(i, component);
    }
  }

 private:
  CompositeTensorVariantMetadata metadata_;
  std::vector<DataType> component_dtypes_;
};

REGISTER_KERNEL_BUILDER( Name("CompositeTensorVariantToComponents").Device(DEVICE_CPU), CompositeTensorVariantToComponents);

REGISTER_KERNEL_BUILDER( Name("CompositeTensorVariantFromComponents").Device(DEVICE_CPU), CompositeTensorVariantFromComponents);


}  
