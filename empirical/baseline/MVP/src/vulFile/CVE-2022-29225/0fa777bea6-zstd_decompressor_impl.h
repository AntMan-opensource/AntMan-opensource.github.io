










namespace Envoy {
namespace Extensions {
namespace Compression {
namespace Zstd {
namespace Decompressor {

using ZstdDDictManager = Common::DictionaryManager<ZSTD_DDict, ZSTD_freeDDict, ZSTD_getDictID_fromDDict>;
using ZstdDDictManagerPtr = std::unique_ptr<ZstdDDictManager>;








struct ZstdDecompressorStats {
  ALL_ZSTD_DECOMPRESSOR_STATS(GENERATE_COUNTER_STRUCT)
};


class ZstdDecompressorImpl : public Common::Base, public Envoy::Compression::Decompressor::Decompressor, NonCopyable {

public:
  ZstdDecompressorImpl(Stats::Scope& scope, const std::string& stats_prefix, const ZstdDDictManagerPtr& ddict_manager, uint32_t chunk_size);

  
  void decompress(const Buffer::Instance& input_buffer, Buffer::Instance& output_buffer) override;

private:
  static ZstdDecompressorStats generateStats(const std::string& prefix, Stats::Scope& scope) {
    return ZstdDecompressorStats{ALL_ZSTD_DECOMPRESSOR_STATS(POOL_COUNTER_PREFIX(scope, prefix))};
  }

  friend class ZstdDecompressorStatsTest;
  bool process(Buffer::Instance& output_buffer);
  bool isError(size_t result);

  std::unique_ptr<ZSTD_DCtx, decltype(&ZSTD_freeDCtx)> dctx_;
  const ZstdDDictManagerPtr& ddict_manager_;
  const ZstdDecompressorStats stats_;
  bool is_dictionary_set_{false};
};

} 
} 
} 
} 
} 
