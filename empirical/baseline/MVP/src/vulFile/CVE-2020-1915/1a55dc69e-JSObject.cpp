














namespace hermes {
namespace vm {

ObjectVTable JSObject::vt{
    VTable( CellKind::ObjectKind, cellSize<JSObject>(), nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, VTable::HeapSnapshotMetadata{HeapSnapshot::NodeType::Object, JSObject::_snapshotNameImpl, JSObject::_snapshotAddEdgesImpl, nullptr, JSObject::_snapshotAddLocationsImpl}), JSObject::_getOwnIndexedRangeImpl, JSObject::_haveOwnIndexedImpl, JSObject::_getOwnIndexedPropertyFlagsImpl, JSObject::_getOwnIndexedImpl, JSObject::_setOwnIndexedImpl, JSObject::_deleteOwnIndexedImpl, JSObject::_checkAllOwnIndexedImpl, };





















void ObjectBuildMeta(const GCCell *cell, Metadata::Builder &mb) {
  
  mb.addJSObjectOverlapSlots(JSObject::numOverlapSlots<JSObject>());

  const auto *self = static_cast<const JSObject *>(cell);
  mb.addField("parent", &self->parent_);
  mb.addField("class", &self->clazz_);
  mb.addField("propStorage", &self->propStorage_);

  
  static const char *directPropName[JSObject::DIRECT_PROPERTY_SLOTS] = {
      "directProp0", "directProp1", "directProp2", "directProp3";
  for (unsigned i = mb.getJSObjectOverlapSlots();
       i < JSObject::DIRECT_PROPERTY_SLOTS;
       ++i) {
    mb.addField(directPropName[i], self->directProps() + i);
  }
}


void JSObject::serializeObjectImpl( Serializer &s, const GCCell *cell, unsigned overlapSlots) {


  auto *self = vmcast<const JSObject>(cell);
  s.writeData(&self->flags_, sizeof(ObjectFlags));
  s.writeRelocation(self->parent_.get(s.getRuntime()));
  s.writeRelocation(self->clazz_.get(s.getRuntime()));
  
  
  bool hasArray = (bool)self->propStorage_;
  s.writeInt<uint8_t>(hasArray);
  if (hasArray) {
    ArrayStorage::serializeArrayStorage( s, self->propStorage_.get(s.getRuntime()));
  }

  
  
  s.writeInt<uint8_t>(overlapSlots);
  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {
    s.writeHermesValue(self->directProps()[i]);
  }
}

void ObjectSerialize(Serializer &s, const GCCell *cell) {
  JSObject::serializeObjectImpl(s, cell, JSObject::numOverlapSlots<JSObject>());
  s.endObject(cell);
}

void ObjectDeserialize(Deserializer &d, CellKind kind) {
  assert(kind == CellKind::ObjectKind && "Expected JSObject");
  void *mem = d.getRuntime()->alloc< true>(cellSize<JSObject>());
  auto *obj = new (mem) JSObject(d, &JSObject::vt.base);

  d.endObject(obj);
}

JSObject::JSObject(Deserializer &d, const VTable *vtp)
    : GCCell(&d.getRuntime()->getHeap(), vtp) {
  d.readData(&flags_, sizeof(ObjectFlags));
  d.readRelocation(&parent_, RelocationKind::GCPointer);
  d.readRelocation(&clazz_, RelocationKind::GCPointer);
  if (d.readInt<uint8_t>()) {
    propStorage_.set( d.getRuntime(), ArrayStorage::deserializeArrayStorage(d), &d.getRuntime()->getHeap());


  }

  auto overlapSlots = d.readInt<uint8_t>();
  for (size_t i = overlapSlots; i < JSObject::DIRECT_PROPERTY_SLOTS; i++) {
    d.readHermesValue(&directProps()[i]);
  }
}


PseudoHandle<JSObject> JSObject::create( Runtime *runtime, Handle<JSObject> parentHandle) {

  JSObjectAlloc<JSObject> mem{runtime};
  return mem.initToPseudoHandle(new (mem) JSObject( runtime, &vt.base, *parentHandle, runtime->getHiddenClassForPrototypeRaw( *parentHandle, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS), GCPointerBase::NoBarriers()));






}

PseudoHandle<JSObject> JSObject::create(Runtime *runtime) {
  JSObjectAlloc<JSObject> mem{runtime};
  JSObject *objProto = runtime->objectPrototypeRawPtr;
  return mem.initToPseudoHandle(new (mem) JSObject( runtime, &vt.base, objProto, runtime->getHiddenClassForPrototypeRaw( objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS), GCPointerBase::NoBarriers()));





}

PseudoHandle<JSObject> JSObject::create( Runtime *runtime, unsigned propertyCount) {

  JSObjectAlloc<JSObject> mem{runtime};
  JSObject *objProto = runtime->objectPrototypeRawPtr;
  auto self = mem.initToPseudoHandle(new (mem) JSObject( runtime, &vt.base, objProto, runtime->getHiddenClassForPrototypeRaw( objProto, numOverlapSlots<JSObject>() + ANONYMOUS_PROPERTY_SLOTS), GCPointerBase::NoBarriers()));






  return runtime->ignoreAllocationFailure( JSObject::allocatePropStorage(std::move(self), runtime, propertyCount));
}

PseudoHandle<JSObject> JSObject::create( Runtime *runtime, Handle<HiddenClass> clazz) {

  auto obj = JSObject::create(runtime, clazz->getNumProperties());
  obj->clazz_.set(runtime, *clazz, &runtime->getHeap());
  
  
  if (LLVM_UNLIKELY(obj->clazz_.get(runtime)->getHasIndexLikeProperties()))
    obj->flags_.fastIndexProperties = false;
  return obj;
}

void JSObject::initializeLazyObject( Runtime *runtime, Handle<JSObject> lazyObject) {

  assert(lazyObject->flags_.lazyObject && "object must be lazy");
  
  lazyObject->flags_.lazyObject = 0;

  
  assert(vmisa<Callable>(lazyObject.get()) && "unexpected lazy object");
  Callable::defineLazyProperties(Handle<Callable>::vmcast(lazyObject), runtime);
}

ObjectID JSObject::getObjectID(JSObject *self, Runtime *runtime) {
  if (LLVM_LIKELY(self->flags_.objectID))
    return self->flags_.objectID;

  
  self->flags_.objectID = runtime->generateNextObjectID();
  
  if (LLVM_UNLIKELY(!self->flags_.objectID))
    --self->flags_.objectID;
  return self->flags_.objectID;
}

CallResult<PseudoHandle<JSObject>> JSObject::getPrototypeOf( PseudoHandle<JSObject> selfHandle, Runtime *runtime) {

  if (LLVM_LIKELY(!selfHandle->isProxyObject())) {
    return createPseudoHandle(selfHandle->getParent(runtime));
  }

  return JSProxy::getPrototypeOf( runtime->makeHandle(std::move(selfHandle)), runtime);
}

namespace {

CallResult<bool> proxyOpFlags( Runtime *runtime, PropOpFlags opFlags, const char *msg, CallResult<bool> res) {



  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  if (!*res && opFlags.getThrowOnError()) {
    return runtime->raiseTypeError(msg);
  }
  return res;
}

} 

CallResult<bool> JSObject::setParent( JSObject *self, Runtime *runtime, JSObject *parent, PropOpFlags opFlags) {



  if (LLVM_UNLIKELY(self->isProxyObject())) {
    return proxyOpFlags( runtime, opFlags, "Object is not extensible.", JSProxy::setPrototypeOf( runtime->makeHandle(self), runtime, runtime->makeHandle(parent)));




  }
  
  
  if (self->parent_.get(runtime) == parent)
    return true;
  
  if (!self->isExtensible()) {
    if (opFlags.getThrowOnError()) {
      return runtime->raiseTypeError("Object is not extensible.");
    } else {
      return false;
    }
  }
  
  for (JSObject *cur = parent; cur; cur = cur->parent_.get(runtime)) {
    if (cur == self) {
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeError("Prototype cycle detected");
      } else {
        return false;
      }
    } else if (LLVM_UNLIKELY(cur->isProxyObject())) {
      
      
      break;
    }
  }
  
  self->parent_.set(runtime, parent, &runtime->getHeap());
  
  return true;
}

void JSObject::allocateNewSlotStorage( Handle<JSObject> selfHandle, Runtime *runtime, SlotIndex newSlotIndex, Handle<> valueHandle) {



  
  if (LLVM_LIKELY(newSlotIndex < DIRECT_PROPERTY_SLOTS)) {
    selfHandle->directProps()[newSlotIndex].set( *valueHandle, &runtime->getHeap());
    return;
  }

  
  newSlotIndex -= DIRECT_PROPERTY_SLOTS;

  
  if (LLVM_UNLIKELY(!selfHandle->propStorage_)) {
    
    assert(newSlotIndex == 0 && "allocated slot must be at end");
    auto arrRes = runtime->ignoreAllocationFailure( PropStorage::create(runtime, DEFAULT_PROPERTY_CAPACITY));
    selfHandle->propStorage_.set( runtime, vmcast<PropStorage>(arrRes), &runtime->getHeap());
  } else if (LLVM_UNLIKELY( newSlotIndex >= selfHandle->propStorage_.get(runtime)->capacity())) {

    
    assert( newSlotIndex == selfHandle->propStorage_.get(runtime)->size() && "allocated slot must be at end");

    auto hnd = runtime->makeMutableHandle(selfHandle->propStorage_);
    PropStorage::resize(hnd, runtime, newSlotIndex + 1);
    selfHandle->propStorage_.set(runtime, *hnd, &runtime->getHeap());
  }

  {
    NoAllocScope scope{runtime};
    auto *const propStorage = selfHandle->propStorage_.getNonNull(runtime);
    if (newSlotIndex >= propStorage->size()) {
      assert( newSlotIndex == propStorage->size() && "allocated slot must be at end");

      PropStorage::resizeWithinCapacity(propStorage, runtime, newSlotIndex + 1);
    }
    
    propStorage->at(newSlotIndex).set(*valueHandle, &runtime->getHeap());
  }
}

CallResult<PseudoHandle<>> JSObject::getNamedPropertyValue_RJS( Handle<JSObject> selfHandle, Runtime *runtime, Handle<JSObject> propObj, NamedPropertyDescriptor desc) {



  assert( !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject && "getNamedPropertyValue_RJS cannot be used with proxy objects");


  if (LLVM_LIKELY(!desc.flags.accessor))
    return createPseudoHandle(getNamedSlotValue(propObj.get(), runtime, desc));

  auto *accessor = vmcast<PropertyAccessor>(getNamedSlotValue(propObj.get(), runtime, desc));
  if (!accessor->getter)
    return createPseudoHandle(HermesValue::encodeUndefinedValue());

  
  return accessor->getter.get(runtime)->executeCall0( runtime->makeHandle(accessor->getter), runtime, selfHandle);
}

CallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS( Handle<JSObject> selfHandle, Runtime *runtime, Handle<JSObject> propObj, ComputedPropertyDescriptor desc) {



  assert( !selfHandle->flags_.proxyObject && !propObj->flags_.proxyObject && "getComputedPropertyValue_RJS cannot be used with proxy objects");


  if (LLVM_LIKELY(!desc.flags.accessor))
    return createPseudoHandle( getComputedSlotValue(propObj.get(), runtime, desc));

  auto *accessor = vmcast<PropertyAccessor>( getComputedSlotValue(propObj.get(), runtime, desc));
  if (!accessor->getter)
    return createPseudoHandle(HermesValue::encodeUndefinedValue());

  
  return accessor->getter.get(runtime)->executeCall0( runtime->makeHandle(accessor->getter), runtime, selfHandle);
}

CallResult<PseudoHandle<>> JSObject::getComputedPropertyValue_RJS( Handle<JSObject> selfHandle, Runtime *runtime, Handle<JSObject> propObj, ComputedPropertyDescriptor desc, Handle<> nameValHandle) {




  if (!propObj) {
    return createPseudoHandle(HermesValue::encodeEmptyValue());
  }

  if (LLVM_LIKELY(!desc.flags.proxyObject)) {
    return JSObject::getComputedPropertyValue_RJS( selfHandle, runtime, propObj, desc);
  }

  CallResult<Handle<>> keyRes = toPropertyKey(runtime, nameValHandle);
  if (LLVM_UNLIKELY(keyRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  CallResult<bool> hasRes = JSProxy::hasComputed(propObj, runtime, *keyRes);
  if (LLVM_UNLIKELY(hasRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  if (!*hasRes) {
    return createPseudoHandle(HermesValue::encodeEmptyValue());
  }
  return JSProxy::getComputed(propObj, runtime, *keyRes, selfHandle);
}

CallResult<Handle<JSArray>> JSObject::getOwnPropertyKeys( Handle<JSObject> selfHandle, Runtime *runtime, OwnKeysFlags okFlags) {


  assert( (okFlags.getIncludeNonSymbols() || okFlags.getIncludeSymbols()) && "Can't exclude symbols and strings");

  if (LLVM_UNLIKELY( selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {
    if (selfHandle->flags_.proxyObject) {
      CallResult<PseudoHandle<JSArray>> proxyRes = JSProxy::ownPropertyKeys(selfHandle, runtime, okFlags);
      if (LLVM_UNLIKELY(proxyRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      return runtime->makeHandle(std::move(*proxyRes));
    }
    assert(selfHandle->flags_.lazyObject && "descriptor flags are impossible");
    initializeLazyObject(runtime, selfHandle);
  }

  auto range = getOwnIndexedRange(selfHandle.get(), runtime);

  
  
  uint32_t capacity = okFlags.getIncludeNonSymbols()
      ? (selfHandle->clazz_.get(runtime)->getNumProperties() + range.second - range.first)
      : 0;

  auto arrayRes = JSArray::create(runtime, capacity, 0);
  if (LLVM_UNLIKELY(arrayRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto array = runtime->makeHandle(std::move(*arrayRes));

  
  llvh::Optional<Handle<JSArray>> hostObjectSymbols;
  size_t hostObjectSymbolCount = 0;

  
  llvh::SmallSet<SymbolID::RawType, 16> dedupSet;

  
  uint32_t index = 0;

  
  MutableHandle<> tmpHandle{runtime};

  
  uint32_t numIndexed = 0;

  
  
  llvh::SmallVector<uint32_t, 8> indexNames{};

  
  if (okFlags.getIncludeNonSymbols()) {
    
    if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {
      assert( range.first == range.second && "Host objects cannot own indexed range");

      auto hostSymbolsRes = vmcast<HostObject>(selfHandle.get())->getHostPropertyNames();
      if (hostSymbolsRes == ExecutionStatus::EXCEPTION) {
        return ExecutionStatus::EXCEPTION;
      }
      if ((hostObjectSymbolCount = (**hostSymbolsRes)->getEndIndex()) != 0) {
        Handle<JSArray> hostSymbols = *hostSymbolsRes;
        hostObjectSymbols = std::move(hostSymbols);
        capacity += hostObjectSymbolCount;
      }
    }

    
    GCScopeMarkerRAII marker{runtime};
    for (auto i = range.first; i != range.second; ++i) {
      auto res = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, i);
      if (!res)
        continue;

      
      if (!okFlags.getIncludeNonEnumerable() && !res->enumerable)
        continue;

      tmpHandle = HermesValue::encodeDoubleValue(i);
      JSArray::setElementAt(array, runtime, index++, tmpHandle);
      marker.flush();
    }

    numIndexed = index;

    HiddenClass::forEachProperty( runtime->makeHandle(selfHandle->clazz_), runtime, [runtime, okFlags, array, hostObjectSymbolCount, &index, &indexNames, &tmpHandle, &dedupSet](SymbolID id, NamedPropertyDescriptor desc) {









          if (!isPropertyNamePrimitive(id)) {
            return;
          }

          
          if (!okFlags.getIncludeNonEnumerable()) {
            if (!desc.flags.enumerable)
              return;
          }

          
          
          
          if (LLVM_UNLIKELY(hostObjectSymbolCount > 0)) {
            dedupSet.insert(id.unsafeGetRaw());
          }

          
          
          
          auto propNameAsIndex = toArrayIndex( runtime->getIdentifierTable().getStringView(runtime, id));
          if (LLVM_UNLIKELY(propNameAsIndex)) {
            indexNames.push_back(*propNameAsIndex);
            return;
          }

          tmpHandle = HermesValue::encodeStringValue( runtime->getStringPrimFromSymbolID(id));
          JSArray::setElementAt(array, runtime, index++, tmpHandle);
        });

    
    
    if (LLVM_UNLIKELY(hostObjectSymbols)) {
      for (size_t i = 0; i < hostObjectSymbolCount; ++i) {
        assert( (*hostObjectSymbols)->at(runtime, i).isSymbol() && "Host object needs to return array of SymbolIDs");

        marker.flush();
        SymbolID id = (*hostObjectSymbols)->at(runtime, i).getSymbol();
        if (dedupSet.count(id.unsafeGetRaw()) == 0) {
          dedupSet.insert(id.unsafeGetRaw());

          assert( !InternalProperty::isInternal(id) && "host object returned reserved symbol");

          auto propNameAsIndex = toArrayIndex( runtime->getIdentifierTable().getStringView(runtime, id));
          if (LLVM_UNLIKELY(propNameAsIndex)) {
            indexNames.push_back(*propNameAsIndex);
            continue;
          }
          tmpHandle = HermesValue::encodeStringValue( runtime->getStringPrimFromSymbolID(id));
          JSArray::setElementAt(array, runtime, index++, tmpHandle);
        }
      }
    }
  }

  
  
  
  if (okFlags.getIncludeSymbols()) {
    MutableHandle<SymbolID> idHandle{runtime};
    HiddenClass::forEachProperty( runtime->makeHandle(selfHandle->clazz_), runtime, [runtime, okFlags, array, &index, &idHandle]( SymbolID id, NamedPropertyDescriptor desc) {



          if (!isSymbolPrimitive(id)) {
            return;
          }
          
          if (!okFlags.getIncludeNonEnumerable()) {
            if (!desc.flags.enumerable)
              return;
          }
          idHandle = id;
          JSArray::setElementAt(array, runtime, index++, idHandle);
        });
  }

  
  uint32_t endNamed = index;

  
  auto cr = JSArray::setLength( array, runtime, endNamed + indexNames.size(), PropOpFlags{});
  (void)cr;
  assert( cr != ExecutionStatus::EXCEPTION && *cr && "JSArray::setLength() failed");

  
  if (LLVM_LIKELY(indexNames.empty()))
    return array;

  
  
  
  std::sort(indexNames.begin(), indexNames.end());

  
  
  JSArray::setStorageEndIndex(array, runtime, endNamed + indexNames.size());

  
  
  
  for (uint32_t last = endNamed, toLast = array->getEndIndex();
       last != numIndexed;) {
    --last;
    --toLast;
    tmpHandle = array->at(runtime, last);
    JSArray::setElementAt(array, runtime, toLast, tmpHandle);
  }

  
  
  
  
  for (uint32_t toLast = numIndexed + indexNames.size(), indexNamesLast = indexNames.size();
       toLast != 0;) {
    if (numIndexed) {
      uint32_t a = (uint32_t)array->at(runtime, numIndexed - 1).getNumber();
      uint32_t b;

      if (indexNamesLast && (b = indexNames[indexNamesLast - 1]) > a) {
        tmpHandle = HermesValue::encodeDoubleValue(b);
        --indexNamesLast;
      } else {
        tmpHandle = HermesValue::encodeDoubleValue(a);
        --numIndexed;
      }
    } else {
      assert(indexNamesLast && "prematurely ran out of source values");
      tmpHandle = HermesValue::encodeDoubleValue(indexNames[indexNamesLast - 1]);
      --indexNamesLast;
    }

    --toLast;
    JSArray::setElementAt(array, runtime, toLast, tmpHandle);
  }

  return array;
}















































static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable && dpf.writable && dpf.setConfigurable && dpf.configurable && !dpf.setSetter && !dpf.setGetter;

}

struct JSObject::Helper {
 public:
  LLVM_ATTRIBUTE_ALWAYS_INLINE static ObjectFlags &flags(JSObject *self) {
    return self->flags_;
  }

  LLVM_ATTRIBUTE_ALWAYS_INLINE static OptValue<PropertyFlags> getOwnIndexedPropertyFlags(JSObject *self, Runtime *runtime, uint32_t index) {

    return JSObject::getOwnIndexedPropertyFlags(self, runtime, index);
  }

  LLVM_ATTRIBUTE_ALWAYS_INLINE static NamedPropertyDescriptor &castToNamedPropertyDescriptorRef( ComputedPropertyDescriptor &desc) {

    return desc.castToNamedPropertyDescriptorRef();
  }
};

namespace {









LLVM_ATTRIBUTE_ALWAYS_INLINE CallResult<bool> getOwnComputedPrimitiveDescriptorImpl( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, JSObject::IgnoreProxy ignoreProxy, SymbolID &id, ComputedPropertyDescriptor &desc) {






  assert( !nameValHandle->isObject() && "nameValHandle passed to " "getOwnComputedPrimitiveDescriptor " "cannot be an object");




  
  
  if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {
    if (JSObject::Helper::flags(*selfHandle).fastIndexProperties) {
      auto res = JSObject::Helper::getOwnIndexedPropertyFlags( selfHandle.get(), runtime, *arrayIndex);
      if (res) {
        
        desc.flags = *res;
        desc.flags.indexed = 1;
        desc.slot = *arrayIndex;
        return true;
      }

      
      
      return false;
    }

    if (!selfHandle->getClass(runtime)->getHasIndexLikeProperties() && !selfHandle->isHostObject() && !selfHandle->isLazy() && !selfHandle->isProxyObject()) {

      
      
      
      return false;
    }
  }

  
  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);

  
  if (JSObject::getOwnNamedDescriptor( selfHandle, runtime, id, JSObject::Helper::castToNamedPropertyDescriptorRef(desc))) {



    return true;
  }

  if (LLVM_LIKELY( !JSObject::Helper::flags(*selfHandle).indexedStorage && !selfHandle->isLazy() && !selfHandle->isProxyObject())) {

    return false;
  }
  MutableHandle<StringPrimitive> strPrim{runtime};

  
  
  if (JSObject::Helper::flags(*selfHandle).indexedStorage) {
    
    OptValue<uint32_t> arrayIndex;

    
    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);

    if (arrayIndex) {
      auto res = JSObject::Helper::getOwnIndexedPropertyFlags( selfHandle.get(), runtime, *arrayIndex);
      if (res) {
        desc.flags = *res;
        desc.flags.indexed = 1;
        desc.slot = *arrayIndex;
        return true;
      }
    }
    return false;
  }

  if (selfHandle->isLazy()) {
    JSObject::initializeLazyObject(runtime, selfHandle);
    return JSObject::getOwnComputedPrimitiveDescriptor( selfHandle, runtime, nameValHandle, ignoreProxy, desc);
  }

  assert(selfHandle->isProxyObject() && "descriptor flags are impossible");
  if (ignoreProxy == JSObject::IgnoreProxy::Yes) {
    return false;
  }
  return JSProxy::getOwnProperty( selfHandle, runtime, nameValHandle, desc, nullptr);
}

} 

CallResult<bool> JSObject::getOwnComputedPrimitiveDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, JSObject::IgnoreProxy ignoreProxy, ComputedPropertyDescriptor &desc) {




  SymbolID id{};

  return getOwnComputedPrimitiveDescriptorImpl( selfHandle, runtime, nameValHandle, ignoreProxy, id, desc);
}

CallResult<bool> JSObject::getOwnComputedDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, ComputedPropertyDescriptor &desc) {



  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  return JSObject::getOwnComputedPrimitiveDescriptor( selfHandle, runtime, *converted, IgnoreProxy::No, desc);
}

CallResult<bool> JSObject::getOwnComputedDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, ComputedPropertyDescriptor &desc, MutableHandle<> &valueOrAccessor) {




  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  
  
  
  
  CallResult<bool> res = JSObject::getOwnComputedPrimitiveDescriptor( selfHandle, runtime, *converted, IgnoreProxy::Yes, desc);
  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  if (*res) {
    valueOrAccessor = getComputedSlotValue(selfHandle.get(), runtime, desc);
    return true;
  }
  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {
    return JSProxy::getOwnProperty( selfHandle, runtime, nameValHandle, desc, &valueOrAccessor);
  }
  return false;
}

JSObject *JSObject::getNamedDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, PropertyFlags expectedFlags, NamedPropertyDescriptor &desc) {




  if (findProperty(selfHandle, runtime, name, expectedFlags, desc))
    return *selfHandle;

  
  
  
  
  
  
  
  if (LLVM_UNLIKELY(selfHandle->flags_.hostObject)) {
    desc.flags.hostObject = true;
    desc.flags.writable = true;
    return *selfHandle;
  }

  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {
    assert( !selfHandle->flags_.proxyObject && "Proxy objects should never be lazy");

    
    JSObject::initializeLazyObject(runtime, selfHandle);

    if (findProperty(selfHandle, runtime, name, expectedFlags, desc))
      return *selfHandle;
  }

  if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {
    desc.flags.proxyObject = true;
    return *selfHandle;
  }

  if (selfHandle->parent_) {
    MutableHandle<JSObject> mutableSelfHandle{
        runtime, selfHandle->parent_.getNonNull(runtime)};

    do {
      
      if (LLVM_LIKELY( !mutableSelfHandle->flags_.lazyObject && !mutableSelfHandle->flags_.hostObject && !mutableSelfHandle->flags_.proxyObject)) {


      findProp:
        if (findProperty( mutableSelfHandle, runtime, name, PropertyFlags::invalid(), desc)) {




          assert( !selfHandle->flags_.proxyObject && "Proxy object parents should never have own properties");

          return *mutableSelfHandle;
        }
      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.lazyObject)) {
        JSObject::initializeLazyObject(runtime, mutableSelfHandle);
        goto findProp;
      } else if (LLVM_UNLIKELY(mutableSelfHandle->flags_.hostObject)) {
        desc.flags.hostObject = true;
        desc.flags.writable = true;
        return *mutableSelfHandle;
      } else {
        assert( mutableSelfHandle->flags_.proxyObject && "descriptor flags are impossible");

        desc.flags.proxyObject = true;
        return *mutableSelfHandle;
      }
    } while ((mutableSelfHandle = mutableSelfHandle->parent_.get(runtime)));
  }

  return nullptr;
}

ExecutionStatus JSObject::getComputedPrimitiveDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, MutableHandle<JSObject> &propObj, ComputedPropertyDescriptor &desc) {




  assert( !nameValHandle->isObject() && "nameValHandle passed to " "getComputedPrimitiveDescriptor cannot " "be an object");




  propObj = selfHandle.get();

  SymbolID id{};

  GCScopeMarkerRAII marker{runtime};
  do {
    
    

    Handle<JSObject> loopHandle = propObj;

    CallResult<bool> res = getOwnComputedPrimitiveDescriptorImpl( loopHandle, runtime, nameValHandle, IgnoreProxy::Yes, id, desc);
    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    if (*res) {
      return ExecutionStatus::RETURNED;
    }

    if (LLVM_UNLIKELY(propObj->flags_.hostObject)) {
      desc.flags.hostObject = true;
      desc.flags.writable = true;
      return ExecutionStatus::RETURNED;
    }
    if (LLVM_UNLIKELY(propObj->flags_.proxyObject)) {
      desc.flags.proxyObject = true;
      return ExecutionStatus::RETURNED;
    }
    
    
    propObj = propObj->getParent(runtime);
    
    
    marker.flush();
  } while (propObj);
  return ExecutionStatus::RETURNED;
}

ExecutionStatus JSObject::getComputedDescriptor( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, MutableHandle<JSObject> &propObj, ComputedPropertyDescriptor &desc) {




  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  return getComputedPrimitiveDescriptor( selfHandle, runtime, *converted, propObj, desc);
}

CallResult<PseudoHandle<>> JSObject::getNamedWithReceiver_RJS( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, Handle<> receiver, PropOpFlags opFlags, PropertyCacheEntry *cacheEntry) {





  NamedPropertyDescriptor desc;
  
  
  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);
  if (!propObj) {
    if (LLVM_UNLIKELY(opFlags.getMustExist())) {
      return runtime->raiseReferenceError( TwineChar16("Property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "' doesn't exist");


    }
    return createPseudoHandle(HermesValue::encodeUndefinedValue());
  }

  if (LLVM_LIKELY( !desc.flags.accessor && !desc.flags.hostObject && !desc.flags.proxyObject)) {

    
    if (cacheEntry && !propObj->getClass(runtime)->isDictionaryNoCache()) {
      cacheEntry->clazz = propObj->getClassGCPtr().getStorageType();
      cacheEntry->slot = desc.slot;
    }
    return createPseudoHandle(getNamedSlotValue(propObj, runtime, desc));
  }

  if (desc.flags.accessor) {
    auto *accessor = vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));
    if (!accessor->getter)
      return createPseudoHandle(HermesValue::encodeUndefinedValue());

    
    return Callable::executeCall0( runtime->makeHandle(accessor->getter), runtime, receiver);
  } else if (desc.flags.hostObject) {
    auto res = vmcast<HostObject>(propObj)->get(name);
    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    return createPseudoHandle(*res);
  } else {
    assert(desc.flags.proxyObject && "descriptor flags are impossible");
    return JSProxy::getNamed( runtime->makeHandle(propObj), runtime, name, receiver);
  }
}

CallResult<PseudoHandle<>> JSObject::getNamedOrIndexed( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, PropOpFlags opFlags) {



  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {
    
    
    const auto strView = runtime->getIdentifierTable().getStringView(runtime, name);
    if (auto nameAsIndex = toArrayIndex(strView)) {
      return getComputed_RJS( selfHandle, runtime, runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)));


    }
    
    
  }
  return getNamed_RJS(selfHandle, runtime, name, opFlags);
}

CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, Handle<> receiver) {



  
  
  if (selfHandle->flags_.fastIndexProperties) {
    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {
      
      PseudoHandle<> ourValue = createPseudoHandle( getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));
      if (LLVM_LIKELY(!ourValue->isEmpty()))
        return ourValue;
    }
  }

  
  
  
  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto nameValPrimitiveHandle = *converted;

  ComputedPropertyDescriptor desc;

  
  
  MutableHandle<JSObject> propObj{runtime};
  if (LLVM_UNLIKELY( getComputedPrimitiveDescriptor( selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) == ExecutionStatus::EXCEPTION)) {


    return ExecutionStatus::EXCEPTION;
  }

  if (!propObj)
    return createPseudoHandle(HermesValue::encodeUndefinedValue());

  if (LLVM_LIKELY( !desc.flags.accessor && !desc.flags.hostObject && !desc.flags.proxyObject))

    return createPseudoHandle( getComputedSlotValue(propObj.get(), runtime, desc));

  if (desc.flags.accessor) {
    auto *accessor = vmcast<PropertyAccessor>( getComputedSlotValue(propObj.get(), runtime, desc));
    if (!accessor->getter)
      return createPseudoHandle(HermesValue::encodeUndefinedValue());

    
    return accessor->getter.get(runtime)->executeCall0( runtime->makeHandle(accessor->getter), runtime, receiver);
  } else if (desc.flags.hostObject) {
    SymbolID id{};
    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);
    auto propRes = vmcast<HostObject>(propObj.get())->get(id);
    if (propRes == ExecutionStatus::EXCEPTION)
      return ExecutionStatus::EXCEPTION;
    return createPseudoHandle(*propRes);
  } else {
    assert(desc.flags.proxyObject && "descriptor flags are impossible");
    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);
    if (key == ExecutionStatus::EXCEPTION)
      return ExecutionStatus::EXCEPTION;
    return JSProxy::getComputed(propObj, runtime, *key, receiver);
  }
}

CallResult<bool> JSObject::hasNamed( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name) {


  NamedPropertyDescriptor desc;
  JSObject *propObj = getNamedDescriptor(selfHandle, runtime, name, desc);
  if (propObj == nullptr) {
    return false;
  }
  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {
    return JSProxy::hasNamed(runtime->makeHandle(propObj), runtime, name);
  }
  return true;
}

CallResult<bool> JSObject::hasNamedOrIndexed( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name) {


  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {
    const auto strView = runtime->getIdentifierTable().getStringView(runtime, name);
    if (auto nameAsIndex = toArrayIndex(strView)) {
      if (haveOwnIndexed(selfHandle.get(), runtime, *nameAsIndex)) {
        return true;
      }
      if (selfHandle->flags_.fastIndexProperties) {
        return false;
      }
    }
    
    
    
  }
  return hasNamed(selfHandle, runtime, name);
}

CallResult<bool> JSObject::hasComputed( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle) {


  
  
  if (selfHandle->flags_.fastIndexProperties) {
    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {
      
      if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {
        return true;
      }
    }
  }

  
  
  
  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto nameValPrimitiveHandle = *converted;

  ComputedPropertyDescriptor desc;
  MutableHandle<JSObject> propObj{runtime};
  if (getComputedPrimitiveDescriptor( selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) == ExecutionStatus::EXCEPTION) {

    return ExecutionStatus::EXCEPTION;
  }
  if (!propObj) {
    return false;
  }
  if (LLVM_UNLIKELY(desc.flags.proxyObject)) {
    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);
    if (key == ExecutionStatus::EXCEPTION)
      return ExecutionStatus::EXCEPTION;
    return JSProxy::hasComputed(propObj, runtime, *key);
  }
  
  
  
  
  
  
  
  
  
  return true;
}

static ExecutionStatus raiseErrorForOverridingStaticBuiltin( Handle<JSObject> selfHandle, Runtime *runtime, Handle<SymbolID> name) {


  Handle<StringPrimitive> methodNameHnd = runtime->makeHandle(runtime->getStringPrimFromSymbolID(name.get()));
  
  
  NamedPropertyDescriptor desc;
  auto *obj = JSObject::getNamedDescriptor( selfHandle, runtime, Predefined::getSymbolID(Predefined::name), desc);
  assert( !selfHandle->isProxyObject() && "raiseErrorForOverridingStaticBuiltin cannot be used with proxy objects");


  if (!obj || desc.flags.accessor) {
    return runtime->raiseTypeError( TwineChar16("Attempting to override read-only builtin method '") + TwineChar16(methodNameHnd.get()) + "'");

  }

  
  StringPrimitive *objName = dyn_vmcast<StringPrimitive>( JSObject::getNamedSlotValue(selfHandle.get(), runtime, desc));
  if (!objName) {
    return runtime->raiseTypeError( TwineChar16("Attempting to override read-only builtin method '") + TwineChar16(methodNameHnd.get()) + "'");

  }

  return runtime->raiseTypeError( TwineChar16("Attempting to override read-only builtin method '") + TwineChar16(objName) + "." + TwineChar16(methodNameHnd.get()) + "'");

}

CallResult<bool> JSObject::putNamedWithReceiver_RJS( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, Handle<> valueHandle, Handle<> receiver, PropOpFlags opFlags) {





  NamedPropertyDescriptor desc;

  
  JSObject *propObj = getNamedDescriptor( selfHandle, runtime, name, PropertyFlags::defaultNewNamedPropertyFlags(), desc);





  
  
  if (propObj) {
    
    
    
    
    

    if (LLVM_LIKELY( *selfHandle == propObj && selfHandle.getHermesValue().getRaw() == receiver->getRaw() && !desc.flags.accessor && !desc.flags.internalSetter && !desc.flags.hostObject && !desc.flags.proxyObject && desc.flags.writable)) {




      setNamedSlotValue( *selfHandle, runtime, desc, valueHandle.getHermesValue());
      return true;
    }

    if (LLVM_UNLIKELY(desc.flags.accessor)) {
      auto *accessor = vmcast<PropertyAccessor>(getNamedSlotValue(propObj, runtime, desc));

      
      if (!accessor->setter) {
        if (opFlags.getThrowOnError()) {
          return runtime->raiseTypeError( TwineChar16("Cannot assign to property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "' which has only a getter");


        }
        return false;
      }

      
      if (accessor->setter.get(runtime)->executeCall1( runtime->makeHandle(accessor->setter), runtime, receiver, *valueHandle) == ExecutionStatus::EXCEPTION) {



        return ExecutionStatus::EXCEPTION;
      }
      return true;
    }

    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {
      assert( !opFlags.getMustExist() && "MustExist cannot be used with Proxy objects");

      CallResult<bool> setRes = JSProxy::setNamed( runtime->makeHandle(propObj), runtime, name, valueHandle, receiver);
      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      if (!*setRes && opFlags.getThrowOnError()) {
        return runtime->raiseTypeError( TwineChar16("Proxy set returned false for property '") + runtime->getIdentifierTable().getStringView(runtime, name) + "'");

      }
      return setRes;
    }

    if (LLVM_UNLIKELY(!desc.flags.writable)) {
      if (desc.flags.staticBuiltin) {
        return raiseErrorForOverridingStaticBuiltin( selfHandle, runtime, runtime->makeHandle(name));
      }
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeError( TwineChar16("Cannot assign to read-only property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "'");


      }
      return false;
    }

    if (*selfHandle == propObj && desc.flags.internalSetter) {
      return internalSetter( selfHandle, runtime, name, desc, valueHandle, opFlags);
    }
  }

  
  

  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};
  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() || receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {
    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {
      receiverHandle = dyn_vmcast<JSObject>(*receiver);
    }
    if (!receiverHandle) {
      return false;
    }

    if (getOwnNamedDescriptor(receiverHandle, runtime, name, desc)) {
      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {
        return false;
      }

      assert( !receiverHandle->isHostObject() && !receiverHandle->isProxyObject() && "getOwnNamedDescriptor never sets hostObject or proxyObject flags");


      setNamedSlotValue( *receiverHandle, runtime, desc, valueHandle.getHermesValue());
      return true;
    }

    
    
    
    if (LLVM_UNLIKELY( receiverHandle->isHostObject() || receiverHandle->isProxyObject())) {

      if (receiverHandle->isHostObject()) {
        return vmcast<HostObject>(receiverHandle.get())
            ->set(name, *valueHandle);
      }
      ComputedPropertyDescriptor desc;
      Handle<> nameValHandle = runtime->makeHandle(name);
      CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor( receiverHandle, runtime, nameValHandle, IgnoreProxy::No, desc);
      if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      DefinePropertyFlags dpf;
      if (*descDefinedRes) {
        dpf.setValue = 1;
      } else {
        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();
      }
      return JSProxy::defineOwnProperty( receiverHandle, runtime, nameValHandle, dpf, valueHandle, opFlags);
    }
  }

  
  if (LLVM_UNLIKELY(opFlags.getMustExist())) {
    return runtime->raiseReferenceError( TwineChar16("Property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "' doesn't exist");


  }

  

  return addOwnProperty( receiverHandle, runtime, name, DefinePropertyFlags::getDefaultNewPropertyFlags(), valueHandle, opFlags);





}

CallResult<bool> JSObject::putNamedOrIndexed( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, Handle<> valueHandle, PropOpFlags opFlags) {




  if (LLVM_UNLIKELY(selfHandle->flags_.indexedStorage)) {
    
    
    const auto strView = runtime->getIdentifierTable().getStringView(runtime, name);
    if (auto nameAsIndex = toArrayIndex(strView)) {
      return putComputed_RJS( selfHandle, runtime, runtime->makeHandle(HermesValue::encodeNumberValue(*nameAsIndex)), valueHandle, opFlags);




    }
    
    
  }
  return putNamed_RJS(selfHandle, runtime, name, valueHandle, opFlags);
}

CallResult<bool> JSObject::putComputedWithReceiver_RJS( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, Handle<> valueHandle, Handle<> receiver, PropOpFlags opFlags) {





  assert( !opFlags.getMustExist() && "mustExist flag cannot be used with computed properties");


  
  
  
  if (selfHandle->flags_.fastIndexProperties) {
    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {
      if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {
        if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {
          auto result = setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);
          if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))
            return ExecutionStatus::EXCEPTION;
          if (LLVM_LIKELY(*result))
            return true;
          if (opFlags.getThrowOnError()) {
            
            return runtime->raiseTypeError( "Cannot assign to read-only property");
          }
          return false;
        }
      }
    }
  }

  
  
  
  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  auto nameValPrimitiveHandle = *converted;

  ComputedPropertyDescriptor desc;

  
  MutableHandle<JSObject> propObj{runtime};
  if (LLVM_UNLIKELY( getComputedPrimitiveDescriptor( selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) == ExecutionStatus::EXCEPTION)) {


    return ExecutionStatus::EXCEPTION;
  }

  
  
  if (propObj) {
    
    
    
    
    

    if (LLVM_LIKELY( selfHandle == propObj && selfHandle.getHermesValue().getRaw() == receiver->getRaw() && !desc.flags.accessor && !desc.flags.internalSetter && !desc.flags.hostObject && !desc.flags.proxyObject && desc.flags.writable)) {




      if (LLVM_UNLIKELY( setComputedSlotValue(selfHandle, runtime, desc, valueHandle) == ExecutionStatus::EXCEPTION)) {

        return ExecutionStatus::EXCEPTION;
      }
      return true;
    }

    
    if (LLVM_UNLIKELY(desc.flags.accessor)) {
      auto *accessor = vmcast<PropertyAccessor>( getComputedSlotValue(propObj.get(), runtime, desc));

      
      if (!accessor->setter) {
        if (opFlags.getThrowOnError()) {
          return runtime->raiseTypeErrorForValue( "Cannot assign to property ", nameValPrimitiveHandle, " which has only a getter");


        }
        return false;
      }

      
      if (accessor->setter.get(runtime)->executeCall1( runtime->makeHandle(accessor->setter), runtime, receiver, valueHandle.get()) == ExecutionStatus::EXCEPTION) {



        return ExecutionStatus::EXCEPTION;
      }
      return true;
    }

    if (LLVM_UNLIKELY(desc.flags.proxyObject)) {
      assert( !opFlags.getMustExist() && "MustExist cannot be used with Proxy objects");

      CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);
      if (key == ExecutionStatus::EXCEPTION)
        return ExecutionStatus::EXCEPTION;
      CallResult<bool> setRes = JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);
      if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }
      if (!*setRes && opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError( TwineChar16("Proxy trap returned false for property"));
      }
      return setRes;
    }

    if (LLVM_UNLIKELY(!desc.flags.writable)) {
      if (desc.flags.staticBuiltin) {
        SymbolID id{};
        LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);
        return raiseErrorForOverridingStaticBuiltin( selfHandle, runtime, runtime->makeHandle(id));
      }
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeErrorForValue( "Cannot assign to read-only property ", nameValPrimitiveHandle, "");
      }
      return false;
    }

    if (selfHandle == propObj && desc.flags.internalSetter) {
      SymbolID id{};
      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);
      return internalSetter( selfHandle, runtime, id, desc.castToNamedPropertyDescriptorRef(), valueHandle, opFlags);





    }
  }

  
  

  MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};
  if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() || receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {
    if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {
      receiverHandle = dyn_vmcast<JSObject>(*receiver);
    }
    if (!receiverHandle) {
      return false;
    }
    CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor( receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);
    if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    DefinePropertyFlags dpf;
    if (*descDefinedRes) {
      if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {
        return false;
      }

      if (LLVM_LIKELY( !desc.flags.internalSetter && !receiverHandle->isHostObject() && !receiverHandle->isProxyObject())) {

        if (LLVM_UNLIKELY( setComputedSlotValue( receiverHandle, runtime, desc, valueHandle) == ExecutionStatus::EXCEPTION)) {


          return ExecutionStatus::EXCEPTION;
        }
        return true;
      }
    }

    if (LLVM_UNLIKELY( desc.flags.internalSetter || receiverHandle->isHostObject() || receiverHandle->isProxyObject())) {

      SymbolID id{};
      LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);
      if (desc.flags.internalSetter) {
        return internalSetter( receiverHandle, runtime, id, desc.castToNamedPropertyDescriptorRef(), valueHandle, opFlags);





      } else if (receiverHandle->isHostObject()) {
        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);
      }
      assert( receiverHandle->isProxyObject() && "descriptor flags are impossible");
      if (*descDefinedRes) {
        dpf.setValue = 1;
      } else {
        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();
      }
      return JSProxy::defineOwnProperty( receiverHandle, runtime, nameValPrimitiveHandle, dpf, valueHandle, opFlags);





    }
  }

  
  if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {
    if (opFlags.getThrowOnError()) {
      return runtime->raiseTypeError( "cannot add a new property");
    }
    return false;
  }

  
  
  if (receiverHandle->flags_.indexedStorage) {
    OptValue<uint32_t> arrayIndex;
    MutableHandle<StringPrimitive> strPrim{runtime};
    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);
    if (arrayIndex) {
      
      if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {
        if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {
          auto cr = putNamed_RJS( receiverHandle, runtime, Predefined::getSymbolID(Predefined::length), runtime->makeHandle( HermesValue::encodeNumberValue(*arrayIndex + 1)), opFlags);





          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))
            return ExecutionStatus::EXCEPTION;
          if (LLVM_UNLIKELY(!*cr))
            return false;
        }
      }

      auto result = setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);
      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      if (LLVM_LIKELY(*result))
        return true;

      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError("Cannot assign to read-only property");
      }
      return false;
    }
  }

  SymbolID id{};
  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);

  
  return addOwnProperty( receiverHandle, runtime, id, DefinePropertyFlags::getDefaultNewPropertyFlags(), valueHandle, opFlags);





}

CallResult<bool> JSObject::deleteNamed( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, PropOpFlags opFlags) {



  assert( !opFlags.getMustExist() && "mustExist cannot be specified when deleting");

  
  NamedPropertyDescriptor desc;
  auto pos = findProperty(selfHandle, runtime, name, desc);

  
  if (!pos) {
    if (LLVM_LIKELY( !selfHandle->flags_.lazyObject && !selfHandle->flags_.proxyObject)) {

      return true;
    } else if (selfHandle->flags_.lazyObject) {
      
      initializeLazyObject(runtime, selfHandle);
      pos = findProperty(selfHandle, runtime, name, desc);
      if (!pos) 
        return true;
    } else {
      assert(selfHandle->flags_.proxyObject && "object flags are impossible");
      return proxyOpFlags( runtime, opFlags, "Proxy delete returned false", JSProxy::deleteNamed(selfHandle, runtime, name));



    }
  }
  
  if (LLVM_UNLIKELY(!desc.flags.configurable)) {
    if (opFlags.getThrowOnError()) {
      return runtime->raiseTypeError( TwineChar16("Property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "' is not configurable");


    }
    return false;
  }

  
  setNamedSlotValue( *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());

  
  auto newClazz = HiddenClass::deleteProperty( runtime->makeHandle(selfHandle->clazz_), runtime, *pos);
  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());

  return true;
}

CallResult<bool> JSObject::deleteComputed( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, PropOpFlags opFlags) {



  assert( !opFlags.getMustExist() && "mustExist cannot be specified when deleting");

  
  
  
  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }

  auto nameValPrimitiveHandle = *converted;

  
  OptValue<uint32_t> arrayIndex;

  
  
  if (selfHandle->flags_.indexedStorage) {
    MutableHandle<StringPrimitive> strPrim{runtime};
    TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);
  }

  
  
  if (arrayIndex && selfHandle->flags_.fastIndexProperties) {
    
    if (deleteOwnIndexed(selfHandle, runtime, *arrayIndex))
      return true;

    
    if (opFlags.getThrowOnError()) {
      
      return runtime->raiseTypeError("Cannot delete property");
    }
    return false;
  }

  
  if (LLVM_UNLIKELY(selfHandle->flags_.lazyObject)) {
    
    initializeLazyObject(runtime, selfHandle);
    return deleteComputed(selfHandle, runtime, nameValHandle, opFlags);
  }

  
  SymbolID id;
  LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);

  
  NamedPropertyDescriptor desc;
  auto pos = findProperty(selfHandle, runtime, id, desc);

  
  if (pos) {
    
    if (LLVM_UNLIKELY(!desc.flags.configurable)) {
      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError("Property is not configurable");
      }
      return false;
    }
  }

  
  

  
  
  if (arrayIndex) {
    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {
      
      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError("Cannot delete property");
      }
      return false;
    }
  }

  if (pos) {
    
    
    setNamedSlotValue( *selfHandle, runtime, desc, HermesValue::encodeEmptyValue());

    
    auto newClazz = HiddenClass::deleteProperty( runtime->makeHandle(selfHandle->clazz_), runtime, *pos);
    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());
  } else if (LLVM_UNLIKELY(selfHandle->flags_.proxyObject)) {
    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);
    if (key == ExecutionStatus::EXCEPTION)
      return ExecutionStatus::EXCEPTION;
    return proxyOpFlags( runtime, opFlags, "Proxy delete returned false", JSProxy::deleteComputed(selfHandle, runtime, *key));



  }

  return true;
}

CallResult<bool> JSObject::defineOwnPropertyInternal( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, DefinePropertyFlags dpFlags, Handle<> valueOrAccessor, PropOpFlags opFlags) {





  assert( !opFlags.getMustExist() && "cannot use mustExist with defineOwnProperty");
  assert( !(dpFlags.setValue && dpFlags.isAccessor()) && "Cannot set both value and accessor");

  assert( (dpFlags.setValue || dpFlags.isAccessor() || valueOrAccessor.get().isUndefined()) && "value must be undefined when all of setValue/setSetter/setGetter are " "false");




  if (dpFlags.isAccessor()) {
    assert(valueOrAccessor.get().isPointer() && "accessor must be non-empty");
    assert( !dpFlags.setWritable && !dpFlags.writable && "writable must not be set with accessors");

  }


  
  NamedPropertyDescriptor desc;
  auto pos = findProperty(selfHandle, runtime, name, desc);
  if (pos) {
    return updateOwnProperty( selfHandle, runtime, name, *pos, desc, dpFlags, valueOrAccessor, opFlags);







  }

  if (LLVM_UNLIKELY( selfHandle->flags_.lazyObject || selfHandle->flags_.proxyObject)) {
    if (selfHandle->flags_.proxyObject) {
      return JSProxy::defineOwnProperty( selfHandle, runtime, name.isUniqued() ? runtime->makeHandle(HermesValue::encodeStringValue( runtime->getStringPrimFromSymbolID(name)))



                           : runtime->makeHandle(name), dpFlags, valueOrAccessor, opFlags);


    }
    assert(selfHandle->flags_.lazyObject && "descriptor flags are impossible");
    
    
    JSObject::initializeLazyObject(runtime, selfHandle);
    return defineOwnPropertyInternal( selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);
  }

  return addOwnProperty( selfHandle, runtime, name, dpFlags, valueOrAccessor, opFlags);
}

ExecutionStatus JSObject::defineNewOwnProperty( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, PropertyFlags propertyFlags, Handle<> valueOrAccessor) {




  assert( !selfHandle->flags_.proxyObject && "definedNewOwnProperty cannot be used with proxy objects");

  assert( !(propertyFlags.accessor && !valueOrAccessor.get().isPointer()) && "accessor must be non-empty");

  assert( !(propertyFlags.accessor && propertyFlags.writable) && "writable must not be set with accessors");

  assert( !HiddenClass::debugIsPropertyDefined( selfHandle->clazz_.get(runtime), runtime, name) && "new property is already defined");



  return addOwnPropertyImpl( selfHandle, runtime, name, propertyFlags, valueOrAccessor);
}

CallResult<bool> JSObject::defineOwnComputedPrimitive( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, DefinePropertyFlags dpFlags, Handle<> valueOrAccessor, PropOpFlags opFlags) {





  assert( !nameValHandle->isObject() && "nameValHandle passed to " "defineOwnComputedPrimitive() cannot be " "an object");



  assert( !opFlags.getMustExist() && "cannot use mustExist with defineOwnProperty");
  assert( !(dpFlags.setValue && dpFlags.isAccessor()) && "Cannot set both value and accessor");

  assert( (dpFlags.setValue || dpFlags.isAccessor() || valueOrAccessor.get().isUndefined()) && "value must be undefined when all of setValue/setSetter/setGetter are " "false");



  assert( !dpFlags.enableInternalSetter && "Cannot set internalSetter on a computed property");


  if (dpFlags.isAccessor()) {
    assert(valueOrAccessor.get().isPointer() && "accessor must be non-empty");
    assert( !dpFlags.setWritable && !dpFlags.writable && "writable must not be set with accessors");

  }


  
  OptValue<uint32_t> arrayIndex;

  
  
  if (selfHandle->flags_.indexedStorage) {
    MutableHandle<StringPrimitive> strPrim{runtime};
    TO_ARRAY_INDEX(runtime, nameValHandle, strPrim, arrayIndex);
  }

  SymbolID id{};

  
  
  if (!arrayIndex) {
    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);
    return defineOwnPropertyInternal( selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);
  }

  
  

  
  if (selfHandle->clazz_.get(runtime)->getHasIndexLikeProperties()) {
    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);

    NamedPropertyDescriptor desc;
    auto pos = findProperty(selfHandle, runtime, id, desc);
    
    if (pos) {
      return updateOwnProperty( selfHandle, runtime, id, *pos, desc, dpFlags, valueOrAccessor, opFlags);







    }
  }

  
  auto indexedPropPresent = getOwnIndexedPropertyFlags(selfHandle.get(), runtime, *arrayIndex);
  if (indexedPropPresent) {
    
    HermesValue curValueOrAccessor = getOwnIndexed(selfHandle.get(), runtime, *arrayIndex);

    auto updateStatus = checkPropertyUpdate( runtime, *indexedPropPresent, dpFlags, curValueOrAccessor, valueOrAccessor, opFlags);





    if (updateStatus == ExecutionStatus::EXCEPTION)
      return ExecutionStatus::EXCEPTION;
    if (updateStatus->first == PropertyUpdateStatus::failed)
      return false;

    
    
    
    if (updateStatus->second == *indexedPropPresent) {
      
      if (updateStatus->first == PropertyUpdateStatus::done)
        return true;

      
      auto result = setOwnIndexed(selfHandle, runtime, *arrayIndex, valueOrAccessor);
      if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))
        return ExecutionStatus::EXCEPTION;
      if (*result)
        return true;

      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError( "cannot change read-only property value");
      }

      return false;
    }

    

    
    
    MutableHandle<> value{runtime};
    if (dpFlags.setValue || dpFlags.isAccessor()) {
      value = valueOrAccessor.get();
    } else {
      value = curValueOrAccessor;
    }

    
    dpFlags.setEnumerable = 1;
    dpFlags.setWritable = 1;
    dpFlags.setConfigurable = 1;
    dpFlags.enumerable = updateStatus->second.enumerable;
    dpFlags.writable = updateStatus->second.writable;
    dpFlags.configurable = updateStatus->second.configurable;

    
    if (!deleteOwnIndexed(selfHandle, runtime, *arrayIndex)) {
      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError("Cannot define property");
      }
      return false;
    }

    
    LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);
    return addOwnProperty(selfHandle, runtime, id, dpFlags, value, opFlags);
  }

  
  if (!selfHandle->isExtensible()) {
    if (opFlags.getThrowOnError()) {
      return runtime->raiseTypeError( "cannot add a new property");
    }
    return false;
  }

  
  
  bool updateLength = false;
  if (auto arrayHandle = Handle<JSArray>::dyn_vmcast(selfHandle)) {
    if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(*arrayHandle))) {
      NamedPropertyDescriptor lengthDesc;
      bool lengthPresent = getOwnNamedDescriptor( arrayHandle, runtime, Predefined::getSymbolID(Predefined::length), lengthDesc);



      (void)lengthPresent;
      assert(lengthPresent && ".length must be present in JSArray");

      if (!lengthDesc.flags.writable) {
        if (opFlags.getThrowOnError()) {
          return runtime->raiseTypeError( "Cannot assign to read-only 'length' property of array");
        }
        return false;
      }

      updateLength = true;
    }
  }

  bool newIsIndexed = canNewPropertyBeIndexed(dpFlags);
  if (newIsIndexed) {
    auto result = setOwnIndexed( selfHandle, runtime, *arrayIndex, dpFlags.setValue ? valueOrAccessor : Runtime::getUndefinedValue());



    if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))
      return ExecutionStatus::EXCEPTION;
    if (!*result) {
      if (opFlags.getThrowOnError()) {
        
        return runtime->raiseTypeError("Cannot define property");
      }
      return false;
    }
  }

  
  if (updateLength) {
    
    auto res = JSArray::setLength( Handle<JSArray>::vmcast(selfHandle), runtime, *arrayIndex + 1, opFlags);
    (void)res;
    assert( res != ExecutionStatus::EXCEPTION && *res && "JSArray::setLength() failed unexpectedly");

  }

  if (newIsIndexed)
    return true;

  
  LAZY_TO_IDENTIFIER(runtime, nameValHandle, id);
  return addOwnProperty( selfHandle, runtime, id, dpFlags, valueOrAccessor, opFlags);
}

CallResult<bool> JSObject::defineOwnComputed( Handle<JSObject> selfHandle, Runtime *runtime, Handle<> nameValHandle, DefinePropertyFlags dpFlags, Handle<> valueOrAccessor, PropOpFlags opFlags) {





  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);
  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION))
    return ExecutionStatus::EXCEPTION;
  return defineOwnComputedPrimitive( selfHandle, runtime, *converted, dpFlags, valueOrAccessor, opFlags);
}

std::string JSObject::getHeuristicTypeName(GC *gc) {
  PointerBase *const base = gc->getPointerBase();
  if (auto constructorVal = tryGetNamedNoAlloc( this, base, Predefined::getSymbolID(Predefined::constructor))) {
    if (auto *constructor = dyn_vmcast<JSObject>(*constructorVal)) {
      auto name = constructor->getNameIfExists(base);
      
      
      if (!name.empty() && name != "Object")
        return name;
    }
  }

  std::string name = getVT()->base.snapshotMetaData.defaultNameForNode(this);
  
  
  if (getClass(base)->isDictionary()) {
    return name + "(Dictionary)";
  }

  
  if (getKind() != CellKind::ObjectKind) {
    return name;
  }

  
  
  std::vector<std::string> propertyNames;
  HiddenClass::forEachPropertyNoAlloc( getClass(base), base, [gc, &propertyNames](SymbolID id, NamedPropertyDescriptor) {


        if (InternalProperty::isInternal(id)) {
          
          return;
        }
        propertyNames.emplace_back(gc->convertSymbolToUTF8(id));
      });
  
  
  
  

  
  
  constexpr int kMaxPropertiesForTypeName = 5;
  bool truncated = false;
  if (propertyNames.size() > kMaxPropertiesForTypeName) {
    propertyNames.erase( propertyNames.begin() + kMaxPropertiesForTypeName, propertyNames.end());
    truncated = true;
  }
  
  if (propertyNames.empty()) {
    
    return name;
  }
  name += "(";
  bool first = true;
  for (const auto &prop : propertyNames) {
    if (!first) {
      name += ", ";
    }
    first = false;
    name += prop;
  }
  if (truncated) {
    
    
    static_assert( kMaxPropertiesForTypeName >= 1, "Property truncation should not happen for 0 properties");

    name += ", ...";
  }
  name += ")";
  return name;
}

std::string JSObject::getNameIfExists(PointerBase *base) {
  
  if (auto nameVal = tryGetNamedNoAlloc( this, base, Predefined::getSymbolID(Predefined::displayName))) {
    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {
      return converter(name);
    }
  }
  
  if (auto nameVal = tryGetNamedNoAlloc( this, base, Predefined::getSymbolID(Predefined::name))) {
    if (auto *name = dyn_vmcast<StringPrimitive>(*nameVal)) {
      return converter(name);
    }
  }
  
  return "";
}

std::string JSObject::_snapshotNameImpl(GCCell *cell, GC *gc) {
  auto *const self = vmcast<JSObject>(cell);
  return self->getHeuristicTypeName(gc);
}

void JSObject::_snapshotAddEdgesImpl(GCCell *cell, GC *gc, HeapSnapshot &snap) {
  auto *const self = vmcast<JSObject>(cell);

  
  
  if (self->parent_) {
    snap.addNamedEdge( HeapSnapshot::EdgeType::Property,  "__proto__", gc->getObjectID(self->parent_));



  }

  HiddenClass::forEachPropertyNoAlloc( self->clazz_.get(gc->getPointerBase()), gc->getPointerBase(), [self, gc, &snap](SymbolID id, NamedPropertyDescriptor desc) {


        if (InternalProperty::isInternal(id)) {
          
          return;
        }
        
        GCHermesValue &prop = namedSlotRef(self, gc->getPointerBase(), desc.slot);
        const llvh::Optional<HeapSnapshot::NodeID> idForProp = gc->getSnapshotID(prop);
        if (!idForProp) {
          return;
        }
        std::string propName = gc->convertSymbolToUTF8(id);
        
        
        
        
        if (auto index = ::hermes::toArrayIndex(propName)) {
          snap.addIndexedEdge( HeapSnapshot::EdgeType::Element, index.getValue(), idForProp.getValue());


        } else {
          snap.addNamedEdge( HeapSnapshot::EdgeType::Property, propName, idForProp.getValue());
        }
      });
}

void JSObject::_snapshotAddLocationsImpl( GCCell *cell, GC *gc, HeapSnapshot &snap) {


  auto *const self = vmcast<JSObject>(cell);
  PointerBase *const base = gc->getPointerBase();
  
  
  if (auto constructorVal = tryGetNamedNoAlloc( self, base, Predefined::getSymbolID(Predefined::constructor))) {
    if (constructorVal->isObject()) {
      if (auto *constructor = dyn_vmcast<JSFunction>(*constructorVal)) {
        constructor->addLocationToSnapshot(snap, gc->getObjectID(self));
      }
    }
  }
}

std::pair<uint32_t, uint32_t> JSObject::_getOwnIndexedRangeImpl( JSObject *self, Runtime *runtime) {

  return {0, 0};
}

bool JSObject::_haveOwnIndexedImpl(JSObject *self, Runtime *, uint32_t) {
  return false;
}

OptValue<PropertyFlags> JSObject::_getOwnIndexedPropertyFlagsImpl( JSObject *self, Runtime *runtime, uint32_t) {


  return llvh::None;
}

HermesValue JSObject::_getOwnIndexedImpl(JSObject *, Runtime *, uint32_t) {
  return HermesValue::encodeEmptyValue();
}

CallResult<bool> JSObject::_setOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t, Handle<>) {
  return false;
}

bool JSObject::_deleteOwnIndexedImpl(Handle<JSObject>, Runtime *, uint32_t) {
  return false;
}

bool JSObject::_checkAllOwnIndexedImpl( JSObject * , Runtime * , ObjectVTable::CheckAllOwnIndexedMode ) {


  return true;
}

void JSObject::preventExtensions(JSObject *self) {
  assert( !self->flags_.proxyObject && "[[Extensible]] slot cannot be set directly on Proxy objects");

  self->flags_.noExtend = true;
}

CallResult<bool> JSObject::preventExtensions( Handle<JSObject> selfHandle, Runtime *runtime, PropOpFlags opFlags) {


  if (LLVM_UNLIKELY(selfHandle->isProxyObject())) {
    return JSProxy::preventExtensions(selfHandle, runtime, opFlags);
  }
  JSObject::preventExtensions(*selfHandle);
  return true;
}

ExecutionStatus JSObject::seal(Handle<JSObject> selfHandle, Runtime *runtime) {
  CallResult<bool> statusRes = JSObject::preventExtensions( selfHandle, runtime, PropOpFlags().plusThrowOnError());
  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  assert( *statusRes && "seal preventExtensions with ThrowOnError returned false");

  
  if (selfHandle->flags_.sealed)
    return ExecutionStatus::RETURNED;

  auto newClazz = HiddenClass::makeAllNonConfigurable( runtime->makeHandle(selfHandle->clazz_), runtime);
  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());

  selfHandle->flags_.sealed = true;

  return ExecutionStatus::RETURNED;
}

ExecutionStatus JSObject::freeze( Handle<JSObject> selfHandle, Runtime *runtime) {

  CallResult<bool> statusRes = JSObject::preventExtensions( selfHandle, runtime, PropOpFlags().plusThrowOnError());
  if (LLVM_UNLIKELY(statusRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  assert( *statusRes && "freeze preventExtensions with ThrowOnError returned false");


  
  if (selfHandle->flags_.frozen)
    return ExecutionStatus::RETURNED;

  auto newClazz = HiddenClass::makeAllReadOnly( runtime->makeHandle(selfHandle->clazz_), runtime);
  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());

  selfHandle->flags_.frozen = true;
  selfHandle->flags_.sealed = true;

  return ExecutionStatus::RETURNED;
}

void JSObject::updatePropertyFlagsWithoutTransitions( Handle<JSObject> selfHandle, Runtime *runtime, PropertyFlags flagsToClear, PropertyFlags flagsToSet, OptValue<llvh::ArrayRef<SymbolID>> props) {




  auto newClazz = HiddenClass::updatePropertyFlagsWithoutTransitions( runtime->makeHandle(selfHandle->clazz_), runtime, flagsToClear, flagsToSet, props);




  selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());
}

CallResult<bool> JSObject::isExtensible( PseudoHandle<JSObject> self, Runtime *runtime) {

  if (LLVM_UNLIKELY(self->isProxyObject())) {
    return JSProxy::isExtensible(runtime->makeHandle(std::move(self)), runtime);
  }
  return self->isExtensible();
}

bool JSObject::isSealed(PseudoHandle<JSObject> self, Runtime *runtime) {
  if (self->flags_.sealed)
    return true;
  if (!self->flags_.noExtend)
    return false;

  auto selfHandle = runtime->makeHandle(std::move(self));

  if (!HiddenClass::areAllNonConfigurable( runtime->makeHandle(selfHandle->clazz_), runtime)) {
    return false;
  }

  if (!checkAllOwnIndexed( *selfHandle, runtime, ObjectVTable::CheckAllOwnIndexedMode::NonConfigurable)) {


    return false;
  }

  
  selfHandle->flags_.sealed = true;
  return true;
}

bool JSObject::isFrozen(PseudoHandle<JSObject> self, Runtime *runtime) {
  if (self->flags_.frozen)
    return true;
  if (!self->flags_.noExtend)
    return false;

  auto selfHandle = runtime->makeHandle(std::move(self));

  if (!HiddenClass::areAllReadOnly( runtime->makeHandle(selfHandle->clazz_), runtime)) {
    return false;
  }

  if (!checkAllOwnIndexed( *selfHandle, runtime, ObjectVTable::CheckAllOwnIndexedMode::ReadOnly)) {


    return false;
  }

  
  selfHandle->flags_.frozen = true;
  selfHandle->flags_.sealed = true;
  return true;
}

CallResult<bool> JSObject::addOwnProperty( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, DefinePropertyFlags dpFlags, Handle<> valueOrAccessor, PropOpFlags opFlags) {





  
  if (!selfHandle->isExtensible() && !opFlags.getInternalForce()) {
    if (opFlags.getThrowOnError()) {
      return runtime->raiseTypeError( TwineChar16("Cannot add new property '") + runtime->getIdentifierTable().getStringViewForDev(runtime, name) + "'");


    }
    return false;
  }

  PropertyFlags flags{};

  
  if (dpFlags.isAccessor()) {
    dpFlags.setWritable = 0;
    flags.accessor = 1;
  }

  
  if (dpFlags.setEnumerable)
    flags.enumerable = dpFlags.enumerable;
  if (dpFlags.setWritable)
    flags.writable = dpFlags.writable;
  if (dpFlags.setConfigurable)
    flags.configurable = dpFlags.configurable;
  flags.internalSetter = dpFlags.enableInternalSetter;

  if (LLVM_UNLIKELY( addOwnPropertyImpl( selfHandle, runtime, name, flags, valueOrAccessor) == ExecutionStatus::EXCEPTION)) {


    return ExecutionStatus::EXCEPTION;
  }

  return true;
}

ExecutionStatus JSObject::addOwnPropertyImpl( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, PropertyFlags propertyFlags, Handle<> valueOrAccessor) {




  assert( !selfHandle->flags_.proxyObject && "Internal properties cannot be added to Proxy objects");

  
  
  
  auto addResult = HiddenClass::addProperty( runtime->makeHandle(selfHandle->clazz_), runtime, name, propertyFlags);
  if (LLVM_UNLIKELY(addResult == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  selfHandle->clazz_.set(runtime, *addResult->first, &runtime->getHeap());

  allocateNewSlotStorage( selfHandle, runtime, addResult->second, valueOrAccessor);

  
  if (LLVM_UNLIKELY( selfHandle->clazz_.getNonNull(runtime)->getHasIndexLikeProperties()))
    selfHandle->flags_.fastIndexProperties = false;

  return ExecutionStatus::RETURNED;
}

CallResult<bool> JSObject::updateOwnProperty( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, HiddenClass::PropertyPos propertyPos, NamedPropertyDescriptor desc, const DefinePropertyFlags dpFlags, Handle<> valueOrAccessor, PropOpFlags opFlags) {







  auto updateStatus = checkPropertyUpdate( runtime, desc.flags, dpFlags, getNamedSlotValue(selfHandle.get(), runtime, desc), valueOrAccessor, opFlags);





  if (updateStatus == ExecutionStatus::EXCEPTION)
    return ExecutionStatus::EXCEPTION;
  if (updateStatus->first == PropertyUpdateStatus::failed)
    return false;

  
  if (updateStatus->second != desc.flags) {
    desc.flags = updateStatus->second;
    auto newClazz = HiddenClass::updateProperty( runtime->makeHandle(selfHandle->clazz_), runtime, propertyPos, desc.flags);



    selfHandle->clazz_.set(runtime, *newClazz, &runtime->getHeap());
  }

  if (updateStatus->first == PropertyUpdateStatus::done)
    return true;
  assert( updateStatus->first == PropertyUpdateStatus::needSet && "unexpected PropertyUpdateStatus");


  if (dpFlags.setValue) {
    if (LLVM_LIKELY(!desc.flags.internalSetter))
      setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());
    else return internalSetter( selfHandle, runtime, name, desc, valueOrAccessor, opFlags);

  } else if (dpFlags.isAccessor()) {
    setNamedSlotValue(selfHandle.get(), runtime, desc, valueOrAccessor.get());
  } else {
    
    
    setNamedSlotValue( selfHandle.get(), runtime, desc, HermesValue::encodeUndefinedValue());
  }

  return true;
}

CallResult<std::pair<JSObject::PropertyUpdateStatus, PropertyFlags>> JSObject::checkPropertyUpdate( Runtime *runtime, const PropertyFlags currentFlags, DefinePropertyFlags dpFlags, const HermesValue curValueOrAccessor, Handle<> valueOrAccessor, PropOpFlags opFlags) {






  
  if (dpFlags.isEmpty())
    return std::make_pair(PropertyUpdateStatus::done, currentFlags);

  assert( (!dpFlags.isAccessor() || (!dpFlags.setWritable && !dpFlags.writable)) && "can't set both accessor and writable");

  assert( !dpFlags.enableInternalSetter && "cannot change the value of internalSetter");


  
  
  
  
  if ((!dpFlags.setEnumerable || dpFlags.enumerable == currentFlags.enumerable) && (!dpFlags.setConfigurable || dpFlags.configurable == currentFlags.configurable)) {


    if (dpFlags.isAccessor()) {
      if (currentFlags.accessor) {
        auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);
        auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());

        if ((!dpFlags.setGetter || curAccessor->getter == newAccessor->getter) && (!dpFlags.setSetter || curAccessor->setter == newAccessor->setter)) {


          return std::make_pair(PropertyUpdateStatus::done, currentFlags);
        }
      }
    } else {
      if (!currentFlags.accessor && (!dpFlags.setValue || isSameValue(curValueOrAccessor, valueOrAccessor.get())) && (!dpFlags.setWritable || dpFlags.writable == currentFlags.writable)) {


        return std::make_pair(PropertyUpdateStatus::done, currentFlags);
      }
    }
  }

  
  
  if (!currentFlags.configurable) {
    
    if (dpFlags.configurable) {
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeError( "property is not configurable");
      }
      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
    }

    
    if (dpFlags.setEnumerable && dpFlags.enumerable != currentFlags.enumerable) {
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeError( "property is not configurable");
      }
      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
    }
  }

  PropertyFlags newFlags = currentFlags;

  
  
  if (!(dpFlags.setValue || dpFlags.setWritable || dpFlags.setGetter || dpFlags.setSetter)) {
    
  }
  
  
  else if (currentFlags.accessor != dpFlags.isAccessor()) {
    if (!currentFlags.configurable) {
      if (opFlags.getThrowOnError()) {
        return runtime->raiseTypeError( "property is not configurable");
      }
      return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
    }

    
    
    
    
    
    
    newFlags.writable = 0;

    
    
    if (!dpFlags.isAccessor())
      dpFlags.setValue = 1;
  }
  
  else if (!currentFlags.accessor) {
    if (!currentFlags.configurable) {
      if (!currentFlags.writable) {
        
        if (dpFlags.writable) {
          if (opFlags.getThrowOnError()) {
            return runtime->raiseTypeError( "property is not configurable");
          }
          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
        }

        
        if (dpFlags.setValue && !isSameValue(curValueOrAccessor, valueOrAccessor.get())) {
          if (opFlags.getThrowOnError()) {
            return runtime->raiseTypeError( "property is not writable");
          }
          return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
        }
      }
    }
  }
  
  else {
    auto *curAccessor = vmcast<PropertyAccessor>(curValueOrAccessor);
    auto *newAccessor = vmcast<PropertyAccessor>(valueOrAccessor.get());

    
    if (!currentFlags.configurable) {
      if ((dpFlags.setGetter && newAccessor->getter != curAccessor->getter) || (dpFlags.setSetter && newAccessor->setter != curAccessor->setter)) {
        if (opFlags.getThrowOnError()) {
          return runtime->raiseTypeError( "property is not configurable");
        }
        return std::make_pair(PropertyUpdateStatus::failed, PropertyFlags{});
      }
    }

    
    if (!dpFlags.setGetter)
      newAccessor->getter.set( runtime, curAccessor->getter, &runtime->getHeap());
    if (!dpFlags.setSetter)
      newAccessor->setter.set( runtime, curAccessor->setter, &runtime->getHeap());
  }

  
  
  
  if (dpFlags.setEnumerable)
    newFlags.enumerable = dpFlags.enumerable;
  if (dpFlags.setWritable)
    newFlags.writable = dpFlags.writable;
  if (dpFlags.setConfigurable)
    newFlags.configurable = dpFlags.configurable;

  if (dpFlags.setValue)
    newFlags.accessor = false;
  else if (dpFlags.isAccessor())
    newFlags.accessor = true;
  else return std::make_pair(PropertyUpdateStatus::done, newFlags);

  return std::make_pair(PropertyUpdateStatus::needSet, newFlags);
}

CallResult<bool> JSObject::internalSetter( Handle<JSObject> selfHandle, Runtime *runtime, SymbolID name, NamedPropertyDescriptor , Handle<> value, PropOpFlags opFlags) {





  if (vmisa<JSArray>(selfHandle.get())) {
    if (name == Predefined::getSymbolID(Predefined::length)) {
      return JSArray::setLength( Handle<JSArray>::vmcast(selfHandle), runtime, value, opFlags);
    }
  }

  llvm_unreachable("unhandled property in Object::internalSetter()");
}

namespace {




CallResult<uint32_t> appendAllPropertyNames( Handle<JSObject> obj, Runtime *runtime, MutableHandle<BigStorage> &arr, uint32_t beginIndex) {



  uint32_t size = beginIndex;
  
  
  
  bool needDedup = false;
  MutableHandle<> prop(runtime);
  MutableHandle<JSObject> head(runtime, obj.get());
  MutableHandle<StringPrimitive> tmpVal{runtime};
  while (head.get()) {
    GCScope gcScope(runtime);

    
    
    
    
    
    
    auto cr = JSObject::getOwnPropertyNames(head, runtime, true );
    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    auto enumerableProps = *cr;
    auto marker = gcScope.createMarker();
    for (unsigned i = 0, e = enumerableProps->getEndIndex(); i < e; ++i) {
      gcScope.flushToMarker(marker);
      prop = enumerableProps->at(runtime, i);
      if (!needDedup) {
        
        if (LLVM_UNLIKELY( BigStorage::push_back(arr, runtime, prop) == ExecutionStatus::EXCEPTION)) {

          return ExecutionStatus::EXCEPTION;
        }
        ++size;
        continue;
      }
      
      
      bool dupFound = false;
      if (prop->isNumber()) {
        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {
          HermesValue val = arr->at(j);
          if (val.isNumber()) {
            dupFound = val.getNumber() == prop->getNumber();
          } else {
            
            tmpVal = val.getString();
            auto valNum = toArrayIndex( StringPrimitive::createStringView(runtime, tmpVal));
            dupFound = valNum && valNum.getValue() == prop->getNumber();
          }
        }
      } else {
        for (uint32_t j = beginIndex; j < size && !dupFound; ++j) {
          HermesValue val = arr->at(j);
          if (val.isNumber()) {
            
            auto propNum = toArrayIndex(StringPrimitive::createStringView( runtime, Handle<StringPrimitive>::vmcast(prop)));
            dupFound = propNum && (propNum.getValue() == val.getNumber());
          } else {
            dupFound = val.getString()->equals(prop->getString());
          }
        }
      }
      if (LLVM_LIKELY(!dupFound)) {
        if (LLVM_UNLIKELY( BigStorage::push_back(arr, runtime, prop) == ExecutionStatus::EXCEPTION)) {

          return ExecutionStatus::EXCEPTION;
        }
        ++size;
      }
    }
    
    CallResult<PseudoHandle<JSObject>> parentRes = JSObject::getPrototypeOf(head, runtime);
    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    head = parentRes->get();
    needDedup = true;
  }
  return size;
}








ExecutionStatus setProtoClasses( Runtime *runtime, Handle<JSObject> obj, MutableHandle<BigStorage> &arr) {


  
  

  if (!obj->shouldCacheForIn(runtime)) {
    arr->clear(runtime);
    return ExecutionStatus::RETURNED;
  }
  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));
  MutableHandle<> clazz(runtime);
  GCScopeMarkerRAII marker{runtime};
  while (head.get()) {
    if (!head->shouldCacheForIn(runtime)) {
      arr->clear(runtime);
      return ExecutionStatus::RETURNED;
    }
    if (JSObject::Helper::flags(*head).lazyObject) {
      
      
      
      JSObject::initializeLazyObject(runtime, head);
    }
    clazz = HermesValue::encodeObjectValue(head->getClass(runtime));
    if (LLVM_UNLIKELY( BigStorage::push_back(arr, runtime, clazz) == ExecutionStatus::EXCEPTION)) {

      return ExecutionStatus::EXCEPTION;
    }
    head = head->getParent(runtime);
    marker.flush();
  }
  clazz = HermesValue::encodeNullValue();
  return BigStorage::push_back(arr, runtime, clazz);
}








uint32_t matchesProtoClasses( Runtime *runtime, Handle<JSObject> obj, Handle<BigStorage> arr) {


  MutableHandle<JSObject> head(runtime, obj->getParent(runtime));
  uint32_t i = 0;
  while (head.get()) {
    HermesValue protoCls = arr->at(i++);
    if (protoCls.isNull() || protoCls.getObject() != head->getClass(runtime) || head->isProxyObject()) {
      return 0;
    }
    head = head->getParent(runtime);
  }
  
  if (head || !arr->at(i++).isNull()) {
    return 0;
  }
  assert(i > 0 && "success should be positive");
  return i;
}

} 

CallResult<Handle<BigStorage>> getForInPropertyNames( Runtime *runtime, Handle<JSObject> obj, uint32_t &beginIndex, uint32_t &endIndex) {



  Handle<HiddenClass> clazz(runtime, obj->getClass(runtime));

  
  MutableHandle<BigStorage> arr(runtime, clazz->getForInCache(runtime));
  if (arr) {
    beginIndex = matchesProtoClasses(runtime, obj, arr);
    if (beginIndex) {
      
      endIndex = arr->size();
      return arr;
    }
    
    
    clazz->clearForInCache(runtime);
    
    arr = nullptr;
  }

  
  auto ownPropEstimate = clazz->getNumProperties();
  auto arrRes = obj->shouldCacheForIn(runtime)
      ? BigStorage::createLongLived(runtime, ownPropEstimate)
      : BigStorage::create(runtime, ownPropEstimate);
  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  arr = std::move(*arrRes);
  if (setProtoClasses(runtime, obj, arr) == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  beginIndex = arr->size();
  
  
  bool canCache = beginIndex;
  auto end = appendAllPropertyNames(obj, runtime, arr, beginIndex);
  if (end == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  endIndex = *end;
  
  
  const bool tooMuchProto = *end / 4 > ownPropEstimate;
  if (canCache && !tooMuchProto) {
    assert(beginIndex > 0 && "cached array must start with proto classes");

    assert(beginIndex == matchesProtoClasses(runtime, obj, arr) && "matches");

    clazz->setForInCache(*arr, runtime);
  }
  return arr;
}




VTable PropertyAccessor::vt{CellKind::PropertyAccessorKind, cellSize<PropertyAccessor>()};

void PropertyAccessorBuildMeta(const GCCell *cell, Metadata::Builder &mb) {
  const auto *self = static_cast<const PropertyAccessor *>(cell);
  mb.addField("getter", &self->getter);
  mb.addField("setter", &self->setter);
}


PropertyAccessor::PropertyAccessor(Deserializer &d)
    : GCCell(&d.getRuntime()->getHeap(), &vt) {
  d.readRelocation(&getter, RelocationKind::GCPointer);
  d.readRelocation(&setter, RelocationKind::GCPointer);
}

void PropertyAccessorSerialize(Serializer &s, const GCCell *cell) {
  auto *self = vmcast<const PropertyAccessor>(cell);
  s.writeRelocation(self->getter.get(s.getRuntime()));
  s.writeRelocation(self->setter.get(s.getRuntime()));
  s.endObject(cell);
}

void PropertyAccessorDeserialize(Deserializer &d, CellKind kind) {
  assert(kind == CellKind::PropertyAccessorKind && "Expected PropertyAccessor");
  void *mem = d.getRuntime()->alloc(cellSize<PropertyAccessor>());
  auto *cell = new (mem) PropertyAccessor(d);
  d.endObject(cell);
}


CallResult<HermesValue> PropertyAccessor::create( Runtime *runtime, Handle<Callable> getter, Handle<Callable> setter) {


  void *mem = runtime->alloc(cellSize<PropertyAccessor>());
  return HermesValue::encodeObjectValue( new (mem) PropertyAccessor(runtime, *getter, *setter));
}

} 
} 
