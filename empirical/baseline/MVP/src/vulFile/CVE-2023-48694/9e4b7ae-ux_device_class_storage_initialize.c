
































UCHAR _ux_system_slave_class_storage_vendor_id[] =                          "AzureRTO";
UCHAR _ux_system_slave_class_storage_product_id[] =                         "USBX storage dev";
UCHAR _ux_system_slave_class_storage_product_rev[] =                        "2000";
UCHAR _ux_system_slave_class_storage_product_serial[] =                     "12345678901234567890";

















































UINT  _ux_device_class_storage_initialize(UX_SLAVE_CLASS_COMMAND *command)
{

UINT                                    status = UX_SUCCESS;
UX_SLAVE_CLASS_STORAGE                  *storage;
UX_SLAVE_CLASS_STORAGE_PARAMETER        *storage_parameter;
UX_SLAVE_CLASS                          *class_inst;
ULONG                                   lun_index;


    
    storage_parameter =  command -> ux_slave_class_command_parameter;

    
    if (storage_parameter -> ux_slave_class_storage_parameter_number_lun > UX_MAX_SLAVE_LUN)
        return UX_ERROR;

    
    class_inst =  command -> ux_slave_class_command_class_ptr;

    
    storage =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_STORAGE));

    
    if (storage == UX_NULL)
        return(UX_MEMORY_INSUFFICIENT);



    
    class_inst -> ux_slave_class_thread_stack = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);

    
    if (class_inst -> ux_slave_class_thread_stack != UX_NULL)

        
        status =  _ux_device_thread_create(&class_inst -> ux_slave_class_thread, "ux_slave_storage_thread", _ux_device_class_storage_thread, (ULONG) (ALIGN_TYPE) class_inst, (VOID *) class_inst -> ux_slave_class_thread_stack, UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);



    else status = UX_MEMORY_INSUFFICIENT;


    
    class_inst -> ux_slave_class_task_function = _ux_device_class_storage_tasks_run;

    status = UX_SUCCESS;


    
    if (status == UX_SUCCESS)
    {

        UX_THREAD_EXTENSION_PTR_SET(&(class_inst -> ux_slave_class_thread), class_inst)

        
        storage -> ux_slave_class_storage_number_lun = storage_parameter -> ux_slave_class_storage_parameter_number_lun;

        
        for (lun_index = 0; lun_index < storage -> ux_slave_class_storage_number_lun; lun_index++)
        {

            
            if (storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
            {
                
                status = (UX_MEMORY_INSUFFICIENT);
                break;
            }

            
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_last_lba       = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_last_lba;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_block_length   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_type           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_type;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_removable_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_removable_flag;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read_only_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read_only_flag;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_flush          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_flush;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_write          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_write;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_status         = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_status;
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_notification   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_notification;
        }

        
        if (status == UX_SUCCESS)
        {

            
            storage -> ux_slave_class_storage_instance_activate = storage_parameter -> ux_slave_class_storage_instance_activate;
            storage -> ux_slave_class_storage_instance_deactivate = storage_parameter -> ux_slave_class_storage_instance_deactivate;

            
            if (storage_parameter -> ux_slave_class_storage_parameter_vendor_id)
                storage -> ux_slave_class_storage_vendor_id = storage_parameter -> ux_slave_class_storage_parameter_vendor_id;
            else storage -> ux_slave_class_storage_vendor_id = _ux_system_slave_class_storage_vendor_id;

            if (storage_parameter -> ux_slave_class_storage_parameter_product_id)
                storage -> ux_slave_class_storage_product_id = storage_parameter -> ux_slave_class_storage_parameter_product_id;
            else storage -> ux_slave_class_storage_product_id = _ux_system_slave_class_storage_product_id;

            if (storage_parameter -> ux_slave_class_storage_parameter_product_rev)
                storage -> ux_slave_class_storage_product_rev = storage_parameter -> ux_slave_class_storage_parameter_product_rev;
            else storage -> ux_slave_class_storage_product_rev = _ux_system_slave_class_storage_product_rev;

            if (storage_parameter -> ux_slave_class_storage_parameter_product_serial)
                storage -> ux_slave_class_storage_product_serial = storage_parameter -> ux_slave_class_storage_parameter_product_serial;
            else storage -> ux_slave_class_storage_product_serial = _ux_system_slave_class_storage_product_serial;

            
            class_inst -> ux_slave_class_instance = (VOID *) storage;

            return(UX_SUCCESS);
        }

        
        _ux_device_thread_delete(&class_inst -> ux_slave_class_thread);
    }


    if (class_inst -> ux_slave_class_thread_stack != UX_NULL)
        _ux_utility_memory_free(&class_inst -> ux_slave_class_thread_stack);


    
    _ux_utility_memory_free(storage);

    
    return(status);
}

