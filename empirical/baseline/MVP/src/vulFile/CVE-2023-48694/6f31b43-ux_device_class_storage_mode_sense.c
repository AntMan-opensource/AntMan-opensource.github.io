













 
 

















UCHAR usbx_device_class_storage_mode_sense_page_cdrom[USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_CDROM_LENGTH] = { 

    0x2A, 0x42, 0x3F, 0x37, 0xF1, 0x77, 0x29, 0x23, 0x10, 0x89, 0x01, 0x00, 0x02, 0x00, 0x05, 0x84, 0x00, 0x10, 0x10, 0x89, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  };
























 
 
 
 
 






 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 




 
 
 

 
 
 
 
 














UINT  _ux_device_class_storage_mode_sense(UX_SLAVE_CLASS_STORAGE *storage,  ULONG               lun, UX_SLAVE_ENDPOINT   *endpoint_in, UX_SLAVE_ENDPOINT   *endpoint_out, UCHAR               *cbwcb)



{

UINT                    status;
UX_SLAVE_TRANSFER       *transfer_request;
ULONG                   mode_sense_reply_length;
ULONG                   page_code;
ULONG                   mode_sense_command;
UCHAR                   read_only_flag;
ULONG                   response_header_length;
ULONG                   flags_index;
ULONG                   mode_data_length;
UCHAR                   *page_pointer;
ULONG                   page_length;


    UX_PARAMETER_NOT_USED(endpoint_out);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_MODE_SENSE, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;

    
    mode_sense_command =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_OPERATION);
    
    
    page_code =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PC_PAGE_CODE);

    
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
    {

        
        mode_sense_reply_length =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_6);
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_6;
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_6;
    }

    else {

        
        mode_sense_reply_length =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_10);
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_10;
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_10;
    }

    
    if (mode_sense_reply_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
        mode_sense_reply_length = UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;

    
    _ux_utility_memory_set(transfer_request -> ux_slave_transfer_request_data_pointer, 0, mode_sense_reply_length); 

    
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read_only_flag == UX_TRUE)
    
        
        read_only_flag = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAG_WP;
    
    else   read_only_flag = 0;



    

    
    mode_data_length = response_header_length;
    page_pointer = transfer_request -> ux_slave_transfer_request_data_pointer + response_header_length;


    
    if(page_code == UX_SLAVE_CLASS_STORAGE_MMC2_PAGE_CODE_CDROM || page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL)
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_CDROM_LENGTH;

        
        _ux_utility_memory_copy(page_pointer, usbx_device_class_storage_mode_sense_page_cdrom, page_length); 

        
        mode_data_length += page_length;
        page_pointer += page_length;
    }


    
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush != UX_NULL && (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE || page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL))

    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_CACHE_LENGTH;

        
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE;

        
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_LENGTH) = UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_PAGE_LENGTH;

        
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAGS) |= UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAG_WCE;

        mode_data_length += page_length;
        page_pointer += page_length;
    }

    
    if (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC || page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL)
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_IEC_LENGTH;

        
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC;

        
        *(page_pointer + 1) = UX_SLAVE_CLASS_STORAGE_IEC_MODE_PAGE_PAGE_LENGTH;

        mode_data_length += page_length;
    }

    
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
        * transfer_request -> ux_slave_transfer_request_data_pointer = (UCHAR)(mode_data_length);
    else _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer, (USHORT)mode_data_length);

    
    *(transfer_request -> ux_slave_transfer_request_data_pointer + flags_index) = read_only_flag;



    
    storage -> ux_device_class_storage_state = UX_DEVICE_CLASS_STORAGE_STATE_TRANS_START;
    storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_READ;

    storage -> ux_device_class_storage_transfer = transfer_request;
    storage -> ux_device_class_storage_device_length = mode_data_length;
    storage -> ux_device_class_storage_data_length = mode_data_length;
    storage -> ux_device_class_storage_data_count = 0;



    
    _ux_device_stack_transfer_request(transfer_request, mode_sense_reply_length, mode_sense_reply_length); 


    
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
    status = UX_SUCCESS;

    
    return(status);
}
    
