
































































 



 
extern   "C" { 

























































































































































































































































































































































































































typedef struct UX_SLAVE_CLASS_STORAGE_LUN_STRUCT {
    ULONG           ux_slave_class_storage_media_last_lba;
    ULONG           ux_slave_class_storage_media_block_length;
    ULONG           ux_slave_class_storage_media_type;
    ULONG           ux_slave_class_storage_media_removable_flag;
    ULONG           ux_slave_class_storage_media_read_only_flag;
    ULONG           ux_slave_class_storage_media_id;
    ULONG           ux_slave_class_storage_request_sense_status;
    ULONG           ux_slave_class_storage_disk_status;
    ULONG           ux_slave_class_storage_last_session_state;

    UINT            (*ux_slave_class_storage_media_read)(VOID *storage, ULONG lun, UCHAR *data_pointer, ULONG number_blocks, ULONG lba, ULONG *media_status);
    UINT            (*ux_slave_class_storage_media_write)(VOID *storage, ULONG lun, UCHAR *data_pointer, ULONG number_blocks, ULONG lba, ULONG *media_status);
    UINT            (*ux_slave_class_storage_media_flush)(VOID *storage, ULONG lun, ULONG number_blocks, ULONG lba, ULONG *media_status);
    UINT            (*ux_slave_class_storage_media_status)(VOID *storage, ULONG lun, ULONG media_id, ULONG *media_status);
    UINT            (*ux_slave_class_storage_media_notification)(VOID *storage, ULONG lun, ULONG media_id, ULONG notification_class, UCHAR **media_notification, ULONG *media_notification_length);
} UX_SLAVE_CLASS_STORAGE_LUN;











typedef struct UX_SLAVE_CLASS_STORAGE_STRUCT {
    UX_SLAVE_INTERFACE          *ux_slave_class_storage_interface;
    ULONG                       ux_slave_class_storage_number_lun;
    UX_SLAVE_CLASS_STORAGE_LUN  ux_slave_class_storage_lun[UX_MAX_SLAVE_LUN];
    ULONG                       ux_slave_class_storage_host_length;
    UCHAR                       ux_slave_class_storage_cbw_flags;
    UCHAR                       ux_slave_class_storage_cbw_lun;
    UCHAR                       ux_slave_class_storage_reserved[2];
    ULONG                       ux_slave_class_storage_scsi_tag;
    ULONG                       ux_slave_class_storage_csw_residue;
    ULONG                       ux_slave_class_storage_csw_status;
    VOID                        (*ux_slave_class_storage_instance_activate)(VOID *);
    VOID                        (*ux_slave_class_storage_instance_deactivate)(VOID *);
    UCHAR                       *ux_slave_class_storage_vendor_id;
    UCHAR                       *ux_slave_class_storage_product_id;
    UCHAR                       *ux_slave_class_storage_product_rev;
    UCHAR                       *ux_slave_class_storage_product_serial;


    UCHAR                       *ux_device_class_storage_buffer[2];
    UCHAR                       ux_device_class_storage_buffer_state[2];
    UCHAR                       ux_device_class_storage_buffer_usb;
    UCHAR                       ux_device_class_storage_buffer_disk;

    UCHAR                       ux_device_class_storage_cmd;
    UCHAR                       ux_device_class_storage_cmd_state;
    UCHAR                       ux_device_class_storage_disk_state;
    UCHAR                       ux_device_class_storage_state;

    UX_SLAVE_ENDPOINT           *ux_device_class_storage_ep_out;
    UX_SLAVE_ENDPOINT           *ux_device_class_storage_ep_in;
    UX_SLAVE_TRANSFER           *ux_device_class_storage_transfer;

    ULONG                       ux_device_class_storage_device_length;
    UCHAR                       *ux_device_class_storage_data_buffer;
    ULONG                       ux_device_class_storage_data_length;
    ULONG                       ux_device_class_storage_data_count;
    ULONG                       ux_device_class_storage_trans_host_length;
    ULONG                       ux_device_class_storage_trans_device_length;

    ULONG                       ux_device_class_storage_cmd_lba;
    ULONG                       ux_device_class_storage_cmd_n_lb;
    ULONG                       ux_device_class_storage_disk_n_lb;
    ULONG                       ux_device_class_storage_media_status;


} UX_SLAVE_CLASS_STORAGE;






typedef struct UX_SLAVE_CLASS_STORAGE_PARAMETER_STRUCT {
    VOID                        (*ux_slave_class_storage_instance_activate)(VOID *);
    VOID                        (*ux_slave_class_storage_instance_deactivate)(VOID *);
    ULONG                       ux_slave_class_storage_parameter_number_lun;
    UX_SLAVE_CLASS_STORAGE_LUN  ux_slave_class_storage_parameter_lun[UX_MAX_SLAVE_LUN];
    UCHAR                       *ux_slave_class_storage_parameter_vendor_id;
    UCHAR                       *ux_slave_class_storage_parameter_product_id;
    UCHAR                       *ux_slave_class_storage_parameter_product_rev;
    UCHAR                       *ux_slave_class_storage_parameter_product_serial;

} UX_SLAVE_CLASS_STORAGE_PARAMETER;



UINT    _ux_device_class_storage_initialize(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_uninitialize(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_activate(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_control_request(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_csw_send(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UCHAR csw_status);
UINT    _ux_device_class_storage_deactivate(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_entry(UX_SLAVE_CLASS_COMMAND *command);
UINT    _ux_device_class_storage_format(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_inquiry(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_mode_select(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_mode_sense(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_prevent_allow_media_removal(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb);
UINT    _ux_device_class_storage_read(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb, UCHAR scsi_command);
UINT    _ux_device_class_storage_read_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_read_format_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_read_toc(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb);
UINT    _ux_device_class_storage_request_sense(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_start_stop(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_test_ready(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
VOID    _ux_device_class_storage_thread(ULONG storage_instance);
UINT    _ux_device_class_storage_verify(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);
UINT    _ux_device_class_storage_write(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb, UCHAR scsi_command);
UINT    _ux_device_class_storage_synchronize_cache(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb, UCHAR scsi_command);
UINT    _ux_device_class_storage_read_disk_information(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);


UINT    _ux_device_class_storage_get_configuration(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);

UINT    _ux_device_class_storage_get_status_notification(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);

UINT    _ux_device_class_storage_report_key(UX_SLAVE_CLASS_STORAGE *storage, ULONG               lun, UX_SLAVE_ENDPOINT   *endpoint_in, UX_SLAVE_ENDPOINT   *endpoint_out, UCHAR               *cbwcb);




UINT    _ux_device_class_storage_get_performance(UX_SLAVE_CLASS_STORAGE *storage, ULONG               lun, UX_SLAVE_ENDPOINT   *endpoint_in, UX_SLAVE_ENDPOINT   *endpoint_out, UCHAR               *cbwcb);



UINT    _ux_device_class_storage_read_dvd_structure(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb);


UINT    _ux_device_class_storage_tasks_run(VOID *instance);





   

} 



