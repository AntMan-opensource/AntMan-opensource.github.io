













 
 















UX_COMPILE_TIME_ASSERT(!UX_OVERFLOW_CHECK_MULC_ULONG(UX_HOST_CLASS_HID_MAX_CLIENTS, sizeof(UX_HOST_CLASS_HID_CLIENT)), UX_HOST_CLASS_HID_MAX_CLIENTS_mem_alloc_ovf)

 
 
 
 
 






 
 
 
 




 
 




 
 

 
 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 











UINT  _ux_host_class_hid_client_register(UCHAR *hid_client_name, UINT (*hid_client_handler)(struct UX_HOST_CLASS_HID_CLIENT_COMMAND_STRUCT *))
{

UX_HOST_CLASS               *class_ptr;
ULONG                       hid_client_index;
UINT                        status;
UX_HOST_CLASS_HID_CLIENT    *hid_client;
UINT                        client_name_length =  0;
                            
    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HID_CLIENT_REGISTER, hid_client_name, 0, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    
    status =  _ux_utility_string_length_check(hid_client_name, &client_name_length, UX_HOST_CLASS_HID_MAX_CLIENT_NAME_LENGTH);
    if (status)
        return(status);

    
    status =  _ux_host_stack_class_get(_ux_system_host_class_hid_name, &class_ptr);

    
    if (status != UX_SUCCESS)
        return(status);

    
    if (class_ptr -> ux_host_class_client == UX_NULL)
    {

        
        class_ptr -> ux_host_class_client =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY,  sizeof(UX_HOST_CLASS_HID_CLIENT)*UX_HOST_CLASS_HID_MAX_CLIENTS);
        
        
        if (class_ptr -> ux_host_class_client == UX_NULL)
            return(UX_MEMORY_INSUFFICIENT);
    }

    
    hid_client =  (UX_HOST_CLASS_HID_CLIENT *) class_ptr -> ux_host_class_client;

    
    for (hid_client_index = 0; hid_client_index < UX_HOST_CLASS_HID_MAX_CLIENTS; hid_client_index++)
    {

        
        if (hid_client -> ux_host_class_hid_client_status == UX_UNUSED)
        {

            
            _ux_utility_memory_copy(hid_client -> ux_host_class_hid_client_name, hid_client_name, client_name_length + 1); 
            
            
            hid_client -> ux_host_class_hid_client_handler =  hid_client_handler;

            
            hid_client -> ux_host_class_hid_client_status =  UX_USED;

            
            return(UX_SUCCESS);
        }
        else {

            
               if (hid_client -> ux_host_class_hid_client_handler == hid_client_handler)
            {

                
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_ALREADY_INSTALLED);

                
                UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_ALREADY_INSTALLED, hid_client_name, 0, 0, UX_TRACE_ERRORS, 0, 0)

                return(UX_HOST_CLASS_ALREADY_INSTALLED);
            }
        }

        
        hid_client++;
    }    

    
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_MEMORY_ARRAY_FULL);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_ARRAY_FULL, hid_client_name, 0, 0, UX_TRACE_ERRORS, 0, 0)

    
    return(UX_MEMORY_ARRAY_FULL);
}

