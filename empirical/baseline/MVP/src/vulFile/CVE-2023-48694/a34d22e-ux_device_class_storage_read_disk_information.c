













 
 



















UCHAR usbx_device_class_storage_disk_information[] = { 

        0x00, 0x00,                      0x0e, 0x01, 0x01, 0x01, 0x01,  0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  };






















 
 
 
 
 






 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











UINT  _ux_device_class_storage_read_disk_information(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)

{

UINT                    status;
UX_SLAVE_TRANSFER       *transfer_request;
ULONG                   allocation_length;

    UX_PARAMETER_NOT_USED(endpoint_out);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_GET_CONFIGURATION, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)
    
    
    _ux_utility_short_put_big_endian(usbx_device_class_storage_disk_information, (USBX_DEVICE_CLASS_STORAGE_DISK_INFORMATION_LENGTH - 2));
    
    
    usbx_device_class_storage_disk_information[2] &= (UCHAR)~3;

    
    usbx_device_class_storage_disk_information[2] = (UCHAR)(usbx_device_class_storage_disk_information[2] | (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_disk_status & 3));

    
    usbx_device_class_storage_disk_information[2] &= (UCHAR)~0x0c;

    
    usbx_device_class_storage_disk_information[2] = (UCHAR)(usbx_device_class_storage_disk_information[2] | ((storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_last_session_state << 2) & 0x0c));

    
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
    
    
    allocation_length =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_DISK_INFORMATION_ALLOCATION_LENGTH);

    
    if (allocation_length > USBX_DEVICE_CLASS_STORAGE_DISK_INFORMATION_LENGTH)
    
        
        allocation_length = USBX_DEVICE_CLASS_STORAGE_DISK_INFORMATION_LENGTH;
    
    
    _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,  usbx_device_class_storage_disk_information, allocation_length);

    


        
        storage -> ux_device_class_storage_state = UX_DEVICE_CLASS_STORAGE_STATE_TRANS_START;
        storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_READ;

        storage -> ux_device_class_storage_transfer = transfer_request;
        storage -> ux_device_class_storage_device_length = allocation_length;
        storage -> ux_device_class_storage_data_length = allocation_length;
        storage -> ux_device_class_storage_data_count = 0;
        UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);



    
    _ux_device_stack_transfer_request(transfer_request,  allocation_length, allocation_length);



    
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
    status = UX_SUCCESS;
    
    
    return(status);
}

