














































































UINT    _ux_host_class_audio_interrupt_start(UX_HOST_CLASS_AUDIO_AC *audio, VOID(*callback_function)(UX_HOST_CLASS_AUDIO_AC *audio, UCHAR *message, ULONG length, VOID *arg), VOID *arg)



{

    UX_PARAMETER_NOT_USED(audio);
    UX_PARAMETER_NOT_USED(callback_function);
    UX_PARAMETER_NOT_USED(arg);
    return(UX_FUNCTION_NOT_SUPPORTED);

UX_ENDPOINT     *endpoint;
UX_TRANSFER     *transfer;
UINT            status;


    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_audio_name, (VOID *) audio) != UX_SUCCESS)
    {

        
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_INSTANCE_UNKNOWN);

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, audio, 0, 0, UX_TRACE_ERRORS, 0, 0)

        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
    }

    
    endpoint = audio -> ux_host_class_audio_interrupt_endpoint;
    if (endpoint == UX_NULL)
        return(UX_FUNCTION_NOT_SUPPORTED);
    
    
    if (audio -> ux_host_class_audio_interrupt_started)
        return(UX_ALREADY_ACTIVATED);

    
    audio -> ux_host_class_audio_interrupt_callback_arg = arg;
    audio -> ux_host_class_audio_interrupt_callback = callback_function;

    
    transfer = &endpoint -> ux_endpoint_transfer_request;

    
    transfer -> ux_transfer_request_class_instance = (VOID *)audio;

    
    transfer -> ux_transfer_request_completion_function = _ux_host_class_audio_interrupt_notification;

    
    status =  _ux_host_stack_transfer_request(transfer);
    if (status == UX_SUCCESS)
        audio -> ux_host_class_audio_interrupt_started = UX_TRUE;

    
    return(status);

}
