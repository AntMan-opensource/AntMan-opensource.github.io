


















































































UINT _ux_host_class_audio_descriptors_parse(UX_HOST_CLASS_AUDIO *audio, UINT(*parse_function)(VOID  *arg, UCHAR *packed_interface_descriptor, UCHAR *packed_endpoint_descriptor, UCHAR *packed_audio_descriptor), VOID* arg)




{

UCHAR                                           *descriptor;
UCHAR                                           *interface_descriptor;
UCHAR                                           *endpoint_descriptor;
ULONG                                           ac_interface, as_interface;
ULONG                                           total_descriptor_length;
ULONG                                           descriptor_length;
ULONG                                           descriptor_type;
UINT                                            status;


    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_audio_name, (VOID *) audio) != UX_SUCCESS)
    {        

        
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_INSTANCE_UNKNOWN);

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, audio, 0, 0, UX_TRACE_ERRORS, 0, 0)
        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
    }

    
    if (audio -> ux_host_class_audio_device -> ux_device_state != UX_DEVICE_CONFIGURED)
        return(UX_INVALID_STATE);

    
    descriptor =  audio -> ux_host_class_audio_configuration_descriptor;
    total_descriptor_length =  audio -> ux_host_class_audio_configuration_descriptor_length;

    
    ac_interface = audio -> ux_host_class_audio_control_interface_number;
    as_interface = audio -> ux_host_class_audio_streaming_interface -> ux_interface_descriptor.bInterfaceNumber;

    
    interface_descriptor = UX_NULL;
    endpoint_descriptor = UX_NULL;

    
    while (total_descriptor_length)
    {

        
        descriptor_length =   *descriptor;
        descriptor_type =     *(descriptor + 1);

        
        if (descriptor_length < 3)
            return(UX_DESCRIPTOR_CORRUPTED);

        
        switch (descriptor_type)
        {

        case UX_INTERFACE_DESCRIPTOR_ITEM:

            
            if (descriptor[2] == ac_interface || descriptor[2] == as_interface)
            {

                
                interface_descriptor = descriptor;
            }
            else {

                
                interface_descriptor = UX_NULL;
            }
            break;

        case UX_ENDPOINT_DESCRIPTOR_ITEM:

            
            endpoint_descriptor = descriptor;
            break;

        case UX_HOST_CLASS_AUDIO_CS_ENDPOINT:
        case UX_HOST_CLASS_AUDIO_CS_INTERFACE:

            
            if (interface_descriptor != UX_NULL)
            {

                
                status = parse_function(arg, interface_descriptor, endpoint_descriptor, descriptor);

                
                if (status)
                {

                    
                    return(UX_SUCCESS);
                }
            }
            break;

        default:
            break;
        }

        
        if (descriptor_length > total_descriptor_length)
            return(UX_DESCRIPTOR_CORRUPTED);

        
        descriptor +=  descriptor_length;

        
        total_descriptor_length -=  descriptor_length;
    }

    
    return(UX_SUCCESS);
}
