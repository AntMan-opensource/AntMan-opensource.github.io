






































































































UINT  _ux_host_class_audio_streaming_sampling_set(UX_HOST_CLASS_AUDIO *audio, UX_HOST_CLASS_AUDIO_SAMPLING *audio_sampling)
{

UINT                    status;
UINT                    alternate_setting;
UX_CONFIGURATION        *configuration;
UX_INTERFACE            *interface_ptr;
UINT                    streaming_interface;
UCHAR                   *descriptor;
ULONG                   set_frequency;
UCHAR                   *control_buffer;
UX_DEVICE               *device;
UX_TRANSFER             *transfer;
ULONG                   frequency = 0;
ULONG                   res_bytes;

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_AUDIO_STREAMING_SAMPLING_SET, audio, audio_sampling, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_audio_name, (VOID *) audio) != UX_SUCCESS)
        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);

    
    _ux_host_mutex_on(&audio -> ux_host_class_audio_mutex);

    
    status =  _ux_host_class_audio_alternate_setting_locate(audio, audio_sampling, &alternate_setting);

    
    if (status != UX_SUCCESS)
    {

        
        _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
        return(status);
    }

    
    configuration =        audio -> ux_host_class_audio_streaming_interface -> ux_interface_configuration;
    interface_ptr =        configuration -> ux_configuration_first_interface;
    streaming_interface =  audio -> ux_host_class_audio_streaming_interface -> ux_interface_descriptor.bInterfaceNumber;
    device =               audio -> ux_host_class_audio_device;

    
    while (interface_ptr != UX_NULL)
    {

        
        if ((interface_ptr -> ux_interface_descriptor.bInterfaceNumber == streaming_interface) && (interface_ptr -> ux_interface_descriptor.bAlternateSetting == alternate_setting))
        {

            
            status =  _ux_host_stack_interface_setting_select(interface_ptr);

            
            if (status == UX_SUCCESS)
            {

                
                audio -> ux_host_class_audio_streaming_interface =  interface_ptr;

                
                status = _ux_host_class_audio_endpoints_get(audio);
                if (status != UX_SUCCESS)
                {

                    
                    _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                    return(status);
                }

                
                set_frequency = UX_TRUE;
                descriptor = audio -> ux_host_class_audio_sampling_descriptor;

                if (_ux_host_class_audio_protocol_get(audio) != UX_HOST_CLASS_AUDIO_PROTOCOL_IP_VERSION_01_00)
                {

                    
                    
                    if ((descriptor[5] & UX_CLASS_AUDIO20_CONTROL_MASK) != UX_CLASS_AUDIO20_CONTROL_PROGRAMMABLE)
                        set_frequency = UX_FALSE;
                }
                else  {


                    
                    
                    if ((descriptor[7] == 1) || ((descriptor[7] == 0) && (descriptor[8] == descriptor[11]) && (descriptor[9] == descriptor[12]) && (descriptor[10] == descriptor[13])))


                        set_frequency = UX_FALSE;
                }

                
                if (set_frequency)
                {

                    
                    control_buffer = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, 4);
                    if (control_buffer == UX_NULL)
                    {
                        _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                        return(UX_MEMORY_INSUFFICIENT);
                    }

                    
                    transfer = &device -> ux_device_control_endpoint.ux_endpoint_transfer_request;

                    
                    control_buffer[0] = (UCHAR)UX_DW0(audio_sampling -> ux_host_class_audio_sampling_frequency);
                    control_buffer[1] = (UCHAR)UX_DW1(audio_sampling -> ux_host_class_audio_sampling_frequency);
                    control_buffer[2] = (UCHAR)UX_DW2(audio_sampling -> ux_host_class_audio_sampling_frequency);

                    
                    status =  _ux_host_semaphore_get(&device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
                    if (status != UX_SUCCESS)
                    {
                        _ux_utility_memory_free(control_buffer);
                        _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                        return(status);
                    }


                    if (_ux_host_class_audio_protocol_get(audio) != UX_HOST_CLASS_AUDIO_PROTOCOL_IP_VERSION_01_00)
                    {

                        
                        control_buffer[3] = (UCHAR)UX_DW3(audio_sampling -> ux_host_class_audio_sampling_frequency);

                        
                        transfer -> ux_transfer_request_data_pointer =      control_buffer;
                        transfer -> ux_transfer_request_requested_length =  4;
                        transfer -> ux_transfer_request_function =          UX_CLASS_AUDIO20_CUR;
                        transfer -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TARGET_INTERFACE | UX_REQUEST_TYPE_CLASS;
                        transfer -> ux_transfer_request_value =             UX_CLASS_AUDIO20_CS_SAM_FREQ_CONTROL << 8;
                        transfer -> ux_transfer_request_index =             audio -> ux_host_class_audio_control_interface_number | ((UINT)descriptor[3] << 8);
                        status = _ux_host_stack_transfer_request(transfer);
                        if (status != UX_SUCCESS)
                        {
                            _ux_utility_memory_free(control_buffer);
                            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                            return(status);
                        }

                        
                        status =  _ux_host_semaphore_get(&device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
                        if (status != UX_SUCCESS)
                        {
                            _ux_utility_memory_free(control_buffer);
                            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                            return(status);
                        }

                        
                        transfer -> ux_transfer_request_data_pointer =      control_buffer;
                        transfer -> ux_transfer_request_requested_length =  4;
                        transfer -> ux_transfer_request_function =          UX_CLASS_AUDIO20_CUR;
                        transfer -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TARGET_INTERFACE | UX_REQUEST_TYPE_CLASS;
                        transfer -> ux_transfer_request_value =             UX_CLASS_AUDIO20_CS_SAM_FREQ_CONTROL << 8;
                        transfer -> ux_transfer_request_index =             audio -> ux_host_class_audio_control_interface_number | ((UINT)descriptor[3] << 8);
                        status = _ux_host_stack_transfer_request(transfer);
                    }
                    else  {


                        
                        transfer -> ux_transfer_request_data_pointer =      control_buffer;
                        transfer -> ux_transfer_request_requested_length =  3;
                        transfer -> ux_transfer_request_function =          UX_CLASS_AUDIO10_SET_CUR;
                        transfer -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TARGET_ENDPOINT | UX_REQUEST_TYPE_CLASS;
                        transfer -> ux_transfer_request_value =             UX_CLASS_AUDIO10_EP_SAMPLING_FREQ_CONTROL << 8;
                        transfer -> ux_transfer_request_index =             audio -> ux_host_class_audio_isochronous_endpoint -> ux_endpoint_descriptor.bEndpointAddress;
                        status = _ux_host_stack_transfer_request(transfer);
                        if (status != UX_SUCCESS)
                        {
                            _ux_utility_memory_free(control_buffer);
                            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                            return(status);
                        }

                        
                        status =  _ux_host_semaphore_get(&device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
                        if (status != UX_SUCCESS)
                        {
                            _ux_utility_memory_free(control_buffer);
                            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                            return(status);
                        }

                        
                        transfer -> ux_transfer_request_data_pointer =      control_buffer;
                        transfer -> ux_transfer_request_requested_length =  3;
                        transfer -> ux_transfer_request_function =          UX_CLASS_AUDIO10_GET_CUR;
                        transfer -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TARGET_ENDPOINT | UX_REQUEST_TYPE_CLASS;
                        transfer -> ux_transfer_request_value =             UX_CLASS_AUDIO10_EP_SAMPLING_FREQ_CONTROL << 8;
                        transfer -> ux_transfer_request_index =             audio -> ux_host_class_audio_isochronous_endpoint -> ux_endpoint_descriptor.bEndpointAddress;
                        status = _ux_host_stack_transfer_request(transfer);

                        
                        control_buffer[3] = 0;
                    }

                    
                    if (status == UX_SUCCESS)
                    {
                        frequency = _ux_utility_long_get(control_buffer);
                        if (audio_sampling -> ux_host_class_audio_sampling_frequency != frequency)
                            status = UX_HOST_CLASS_AUDIO_WRONG_FREQUENCY;
                    }

                    
                    _ux_utility_memory_free(control_buffer);
                }

                
                if (status == UX_SUCCESS)
                {
                    audio -> ux_host_class_audio_packet_freq = (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) ? 8000 : 1000;

                    audio -> ux_host_class_audio_packet_freq <<= audio -> ux_host_class_audio_isochronous_endpoint -> ux_endpoint_descriptor.bInterval - 1;

                    res_bytes = audio_sampling -> ux_host_class_audio_sampling_resolution;
                    if (UX_OVERFLOW_CHECK_ADD_ULONG(res_bytes, 7))
                        status = UX_MATH_OVERFLOW;
                }
                if (status == UX_SUCCESS)
                {
                    res_bytes += 7;
                    res_bytes >>= 3;

                    frequency = audio_sampling -> ux_host_class_audio_sampling_frequency;
                    if (UX_OVERFLOW_CHECK_MULV_ULONG(frequency, audio_sampling -> ux_host_class_audio_sampling_channels))
                        status = UX_MATH_OVERFLOW;
                }
                if (status == UX_SUCCESS)
                {
                    frequency *= audio_sampling -> ux_host_class_audio_sampling_channels;
                    if (UX_OVERFLOW_CHECK_MULV_ULONG(frequency, res_bytes))
                        status = UX_MATH_OVERFLOW;
                }
                if (status == UX_SUCCESS)
                {
                    frequency *= res_bytes;
                    audio -> ux_host_class_audio_packet_fraction = frequency % audio -> ux_host_class_audio_packet_freq;
                    audio -> ux_host_class_audio_packet_size = frequency / audio -> ux_host_class_audio_packet_freq;
                }

                
                _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);

                
                return(status);
            }
        }

        
        interface_ptr =  interface_ptr -> ux_interface_next_interface;
    }

    
    _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);

    
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_NO_ALTERNATE_SETTING);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_NO_ALTERNATE_SETTING, audio, 0, 0, UX_TRACE_ERRORS, 0, 0)

    
    return(UX_NO_ALTERNATE_SETTING);
}
