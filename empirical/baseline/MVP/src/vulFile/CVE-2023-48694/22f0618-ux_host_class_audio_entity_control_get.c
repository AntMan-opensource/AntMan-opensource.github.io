


















































































UINT  _ux_host_class_audio_entity_control_get(UX_HOST_CLASS_AUDIO *audio, UX_HOST_CLASS_AUDIO_CONTROL *audio_control)
{

UINT            status;
UCHAR *         control_buffer;
ULONG           actual_size;

ULONG           n_subs, sub, pos, min, max, res, size;



    
    if (audio_control -> ux_host_class_audio_control_size > 4)
        return(UX_INVALID_PARAMETER);

    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_audio_name, (VOID *) audio) != UX_SUCCESS)
    {

        
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_INSTANCE_UNKNOWN);

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, audio, 0, 0, UX_TRACE_ERRORS, 0, 0)

        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
    }

    
    _ux_host_mutex_on(&audio -> ux_host_class_audio_mutex);


    if (_ux_host_class_audio_protocol_get(audio) == UX_HOST_CLASS_AUDIO_PROTOCOL_IP_VERSION_02_00)
    {

        
        
        control_buffer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 16);
        if (control_buffer == UX_NULL)
        {

            
            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
            return(UX_MEMORY_INSUFFICIENT);
        }

        
        status = _ux_host_class_audio_control_request(audio, 0, UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE, UX_CLASS_AUDIO20_RANGE, audio_control -> ux_host_class_audio_control_channel | (audio_control -> ux_host_class_audio_control << 8), audio_control -> ux_host_class_audio_control_entity, control_buffer, 16, &actual_size);






        
        if (status == UX_SUCCESS)
        {

            
            if (actual_size < 2)
            {

                
                _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                _ux_utility_memory_free(control_buffer);
                return(UX_TRANSFER_ERROR);
            }

            
            n_subs = _ux_utility_short_get(control_buffer);
            if (n_subs > 1)
            {

                
                size = 2 + n_subs * audio_control -> ux_host_class_audio_control_size;
                if (size > 16)
                {

                    
                    _ux_utility_memory_free(control_buffer);
                    control_buffer = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, size);
                    if (control_buffer == UX_NULL)
                    {

                        
                        _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                        return(UX_MEMORY_INSUFFICIENT);
                    }

                    
                    status = _ux_host_class_audio_control_request(audio, 0, UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE, UX_CLASS_AUDIO20_RANGE, audio_control -> ux_host_class_audio_control_channel | (audio_control -> ux_host_class_audio_control << 8), audio_control -> ux_host_class_audio_control_entity, control_buffer, size, &actual_size);






                    if ((status != UX_SUCCESS) || (actual_size != size))
                    {

                        
                        _ux_utility_memory_free(control_buffer);
                        _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
                        return(UX_TRANSFER_ERROR);
                    }
                }
            }

            
            audio_control -> ux_host_class_audio_control_max = 0;
            audio_control -> ux_host_class_audio_control_min = 0xFFFFFFFF;
            audio_control -> ux_host_class_audio_control_res = 0;
            pos = 2;
            for (sub = 0; sub < n_subs; sub ++)
            {

                
                switch(audio_control -> ux_host_class_audio_control_size)
                {
                case 1:
                    min = *(control_buffer + pos);
                    pos ++;
                    max = *(control_buffer + pos);
                    pos ++;
                    res = *(control_buffer + pos);
                    pos ++;
                    break;

                case 2:
                    min = _ux_utility_short_get(control_buffer + pos);
                    pos += 2;
                    max = _ux_utility_short_get(control_buffer + pos);
                    pos += 2;
                    res = _ux_utility_short_get(control_buffer + pos);
                    pos += 2;
                    break;

                default:
                    min = _ux_utility_long_get(control_buffer + pos);
                    pos += 4;
                    max = _ux_utility_long_get(control_buffer + pos);
                    pos += 4;
                    res = _ux_utility_long_get(control_buffer + pos);
                    pos += 4;
                    break;
                }

                
                if (audio_control -> ux_host_class_audio_control_max < max)
                    audio_control -> ux_host_class_audio_control_max = max;

                
                if (audio_control -> ux_host_class_audio_control_min > min)
                    audio_control -> ux_host_class_audio_control_min = min;

                
                if (audio_control -> ux_host_class_audio_control_res == 0)
                    audio_control -> ux_host_class_audio_control_res = res;
                else if (res < audio_control -> ux_host_class_audio_control_res)
                    audio_control -> ux_host_class_audio_control_res = res;
            }

            
            if (n_subs > 1 && audio_control -> ux_host_class_audio_control_res == 0)
            {
                audio_control -> ux_host_class_audio_control_res = (audio_control -> ux_host_class_audio_control_max - audio_control -> ux_host_class_audio_control_min) / n_subs;

            }
        }
    }
    else  {


        
        control_buffer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 4);
        if (control_buffer == UX_NULL)
        {

            
            _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);
            return(UX_MEMORY_INSUFFICIENT);
        }

        
        * (ULONG *)control_buffer = 0;
        status = _ux_host_class_audio_control_request(audio, 0, UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE, UX_HOST_CLASS_AUDIO_GET_MIN, audio_control -> ux_host_class_audio_control_channel | (audio_control -> ux_host_class_audio_control << 8), audio_control -> ux_host_class_audio_control_entity, control_buffer, 4, &actual_size);






        
        if (status == UX_SUCCESS)
        {

            
            audio_control -> ux_host_class_audio_control_min = _ux_utility_long_get(control_buffer);

            
            * (ULONG *)control_buffer = 0;
            status = _ux_host_class_audio_control_request(audio, 0, UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE, UX_HOST_CLASS_AUDIO_GET_MAX, audio_control -> ux_host_class_audio_control_channel | (audio_control -> ux_host_class_audio_control << 8), audio_control -> ux_host_class_audio_control_entity, control_buffer, 4, &actual_size);





        }

        
        if (status == UX_SUCCESS)
        {

            
            audio_control -> ux_host_class_audio_control_max = _ux_utility_long_get(control_buffer);

            
            * (ULONG *)control_buffer = 0;
            status = _ux_host_class_audio_control_request(audio, 0, UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE, UX_HOST_CLASS_AUDIO_GET_RES, audio_control -> ux_host_class_audio_control_channel | (audio_control -> ux_host_class_audio_control << 8), audio_control -> ux_host_class_audio_control_entity, control_buffer, 4, &actual_size);





        }

        
        if (status == UX_SUCCESS)
        {

            
            audio_control -> ux_host_class_audio_control_res = _ux_utility_long_get(control_buffer);
        }
    }

    
    _ux_utility_memory_free(control_buffer);

    
    _ux_host_mutex_off(&audio -> ux_host_class_audio_mutex);

    
    return(status);
}
