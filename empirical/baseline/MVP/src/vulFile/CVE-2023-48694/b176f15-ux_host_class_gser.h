













 
 







 
 
 
 
 






 

 
 
 
 
 
 
















 



 
extern   "C" { 









































































































typedef struct UX_HOST_CLASS_GSER_INTERFACE_STRUCT {

    UX_INTERFACE                                *ux_host_class_gser_interface;
    UX_ENDPOINT                                 *ux_host_class_gser_bulk_out_endpoint;
    UX_ENDPOINT                                 *ux_host_class_gser_bulk_in_endpoint;
    UX_SEMAPHORE                                ux_host_class_gser_semaphore;
    struct UX_HOST_CLASS_GSER_RECEPTION_STRUCT  *ux_host_class_gser_reception;
    ULONG                                       ux_host_class_gser_notification_count;
} UX_HOST_CLASS_GSER_INTERFACE;



typedef struct UX_HOST_CLASS_GSER_STRUCT {

    struct UX_HOST_CLASS_GSER_STRUCT            *ux_host_class_gser_next_instance;
    UX_HOST_CLASS                               *ux_host_class_gser_class;
    UX_DEVICE                                   *ux_host_class_gser_device;
    UINT                                        ux_host_class_gser_state;
    struct UX_HOST_CLASS_GSER_INTERFACE_STRUCT  ux_host_class_gser_interface_array[UX_HOST_CLASS_GSER_INTERFACE_NUMBER];
    ULONG                                       ux_host_class_gser_device_state;
    VOID                                        (*ux_host_class_gser_device_status_change_callback)(struct UX_HOST_CLASS_GSER_STRUCT *gser,  ULONG  notification_type, ULONG notification_value);
} UX_HOST_CLASS_GSER;




typedef struct UX_HOST_CLASS_GSER_RECEPTION_STRUCT {

    ULONG           ux_host_class_gser_reception_interface_index;
    ULONG           ux_host_class_gser_reception_state;
    ULONG           ux_host_class_gser_reception_block_size;
    UCHAR           *ux_host_class_gser_reception_data_buffer;
    ULONG           ux_host_class_gser_reception_data_buffer_size;
    UCHAR           *ux_host_class_gser_reception_data_head;
    UCHAR           *ux_host_class_gser_reception_data_tail;
    VOID            (*ux_host_class_gser_reception_callback)(struct UX_HOST_CLASS_GSER_STRUCT *gser,  UINT  status, UCHAR *reception_buffer, ULONG reception_size);



} UX_HOST_CLASS_GSER_RECEPTION;




typedef struct UX_HOST_CLASS_GSER_LINE_CODING_STRUCT {

    ULONG           ux_host_class_gser_line_coding_dter;
    ULONG           ux_host_class_gser_line_coding_stop_bit;
    ULONG           ux_host_class_gser_line_coding_parity;
    ULONG           ux_host_class_gser_line_coding_data_bits;

} UX_HOST_CLASS_GSER_LINE_CODING;



typedef struct UX_HOST_CLASS_GSER_LINE_STATE_STRUCT {

    ULONG           ux_host_class_gser_line_state_rts;
    ULONG           ux_host_class_gser_line_state_dtr;

} UX_HOST_CLASS_GSER_LINE_STATE;



typedef struct UX_HOST_CLASS_GSER_LINE_BREAK_STRUCT {

    ULONG           ux_host_class_gser_line_break;

} UX_HOST_CLASS_GSER_LINE_BREAK;




UINT    _ux_host_class_gser_activate(UX_HOST_CLASS_COMMAND *command);
UINT    _ux_host_class_gser_configure(UX_HOST_CLASS_GSER *gser);
UINT    _ux_host_class_gser_deactivate(UX_HOST_CLASS_COMMAND *command);
UINT    _ux_host_class_gser_endpoints_get(UX_HOST_CLASS_GSER *gser);
UINT    _ux_host_class_gser_entry(UX_HOST_CLASS_COMMAND *command);
UINT    _ux_host_class_gser_read (UX_HOST_CLASS_GSER *gser, ULONG interface_index,UCHAR *data_pointer,  ULONG requested_length, ULONG *actual_length);
UINT    _ux_host_class_gser_write(UX_HOST_CLASS_GSER *gser, ULONG interface_index,UCHAR *data_pointer,  ULONG requested_length, ULONG *actual_length);
UINT    _ux_host_class_gser_command(UX_HOST_CLASS_GSER *gser, ULONG interface_index, ULONG command, ULONG value, UCHAR *data_buffer, ULONG data_length);
UINT    _ux_host_class_gser_ioctl(UX_HOST_CLASS_GSER *gser, ULONG interface_index, ULONG ioctl_function, VOID *parameter);
VOID    _ux_host_class_gser_reception_callback (UX_TRANSFER *transfer_request);
UINT    _ux_host_class_gser_reception_stop (UX_HOST_CLASS_GSER *gser,  UX_HOST_CLASS_GSER_RECEPTION *gser_reception);
UINT    _ux_host_class_gser_reception_start (UX_HOST_CLASS_GSER *gser,  UX_HOST_CLASS_GSER_RECEPTION *gser_reception);
                                    









   

} 



