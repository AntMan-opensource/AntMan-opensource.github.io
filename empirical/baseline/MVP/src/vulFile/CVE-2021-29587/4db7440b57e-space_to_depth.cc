











namespace tflite {
namespace ops {
namespace builtin {
namespace space_to_depth {



enum KernelType {
  kReference, kGenericOptimized, };


constexpr int kInputTensor = 0;
constexpr int kOutputTensor = 0;

TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);

  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);

  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output));

  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);

  auto data_type = output->type;
  TF_LITE_ENSURE(context, data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 || data_type == kTfLiteInt8 || data_type == kTfLiteInt32 || data_type == kTfLiteInt64);


  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);

  const int block_size = params->block_size;
  const int input_height = input->dims->data[1];
  const int input_width = input->dims->data[2];
  int output_height = input_height / block_size;
  int output_width = input_width / block_size;

  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);
  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);

  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);
  output_size->data[0] = input->dims->data[0];
  output_size->data[1] = output_height;
  output_size->data[2] = output_width;
  output_size->data[3] = input->dims->data[3] * block_size * block_size;

  return context->ResizeTensor(context, output, output_size);
}

template <KernelType kernel_type> TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);

  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));
  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output));






  switch (input->type) {  
    case kTfLiteFloat32:
      if (kernel_type == kReference) {
        TF_LITE_SPACE_TO_DEPTH(reference_ops, float);
      } else {
        TF_LITE_SPACE_TO_DEPTH(optimized_ops, float);
      }
      break;
    case kTfLiteUInt8:
      if (kernel_type == kReference) {
        TF_LITE_SPACE_TO_DEPTH(reference_ops, uint8_t);
      } else {
        TF_LITE_SPACE_TO_DEPTH(optimized_ops, uint8_t);
      }
      break;
    case kTfLiteInt8:
      if (kernel_type == kReference) {
        TF_LITE_SPACE_TO_DEPTH(reference_ops, int8_t);
      } else {
        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int8_t);
      }
      break;
    case kTfLiteInt32:
      if (kernel_type == kReference) {
        TF_LITE_SPACE_TO_DEPTH(reference_ops, int32_t);
      } else {
        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int32_t);
      }
      break;
    case kTfLiteInt64:
      if (kernel_type == kReference) {
        TF_LITE_SPACE_TO_DEPTH(reference_ops, int64_t);
      } else {
        TF_LITE_SPACE_TO_DEPTH(optimized_ops, int64_t);
      }
      break;
    default:
      context->ReportError(context, "Type '%s' not currently supported.", TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }


  return kTfLiteOk;
}

}  

TfLiteRegistration* Register_SPACE_TO_DEPTH_REF() {
  static TfLiteRegistration r = {
      nullptr, nullptr, space_to_depth::Prepare, space_to_depth::Eval<space_to_depth::kReference>};
  return &r;
}

TfLiteRegistration* Register_SPACE_TO_DEPTH_GENERIC_OPT() {
  static TfLiteRegistration r = {
      nullptr, nullptr, space_to_depth::Prepare, space_to_depth::Eval<space_to_depth::kGenericOptimized>};
  return &r;
}

TfLiteRegistration* Register_SPACE_TO_DEPTH() {
  return Register_SPACE_TO_DEPTH_GENERIC_OPT();
}

}  
}  
}  
