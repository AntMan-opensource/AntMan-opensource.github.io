






















LibzipPluginFactory::LibzipPluginFactory()
{
    registerPlugin<LibzipPlugin>();
}

LibzipPluginFactory::~LibzipPluginFactory()
{

}



LibzipPlugin::LibzipPlugin(QObject *parent, const QVariantList &args)
    : ReadWriteArchiveInterface(parent, args)
{
    qInfo() << "LibzipPlugin";
    m_ePlugintype = PT_Libzip;
    m_listCodecs.clear();
    m_listCodecs << "UTF-8" << "GB18030" << "GBK" << "Big5" << "us-ascii";  
}

LibzipPlugin::~LibzipPlugin()
{

}

PluginFinishType LibzipPlugin::list()
{
    qInfo() << "LibzipPlugin插件加载压缩包数据";
    setPassword(QString());
    m_mapFileCode.clear();
    m_setHasHandlesDirs.clear();
    m_setHasRootDirs.clear();
    DataManager::get_instance().resetArchiveData();

    
    int errcode = 0;
    zip_error_t err;

    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   
    zip_error_init_with_code(&err, errcode);

    
    if (nullptr == archive) {
        m_eErrorType = ET_ArchiveDamaged;
        return PFT_Error;
    }

    
    const auto nofEntries = zip_get_num_entries(archive, 0);

    
    QByteArray strCode;
    m_strComment = m_common->trans2uft8(zip_get_archive_comment(archive, nullptr, ZIP_FL_ENC_RAW), strCode);

    
    for (zip_int64_t i = 0; i < nofEntries; i++) {
        if (QThread::currentThread()->isInterruptionRequested()) {
            break;
        }

        handleArchiveData(archive, i);  
    }

    zip_close(archive);

    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::testArchive()
{
    m_workStatus = WT_Test;
    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::extractFiles(const QList<FileEntry> &files, const ExtractionOptions &options)
{
    qInfo() << "解压缩数据";

    setPassword(QString());
    m_workStatus = WT_Extract;
    int errcode = 0;
    m_bOverwriteAll = false;        
    m_bSkipAll = false;             
    m_mapLongName.clear();
    m_setLongName.clear();
    m_mapLongDirName.clear();
    m_mapRealDirValue.clear();

    zip_error_t err;

    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);
    zip_error_init_with_code(&err, errcode);
    if (nullptr == archive) {
        
        
        m_eErrorType = ET_ArchiveDamaged ;
        return PFT_Error;
    }

    
    if (!options.bExistList) {
        m_dScaleSize = 100.0 / options.qComressSize;
    } else {
        m_dScaleSize = 100.0 / options.qSize;
    }
    m_bDlnfs = m_common->isSubpathOfDlnfs(options.strTargetPath);

    
    bool bHandleLongName = false;
    if (options.bAllExtract) {  
        qlonglong qExtractSize = 0;
        zip_int64_t nofEntries = zip_get_num_entries(archive, 0);
        for (zip_int64_t i = 0; i < nofEntries; ++i) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                m_bCancel = false;      
                break;
            }

            QString strFileName;

            
            m_eErrorType = extractEntry(archive, i, options, qExtractSize, strFileName, bHandleLongName);

            
            if (!options.bExistList && 0 == i) {
                FileEntry entry;
                entry.strFullPath = strFileName;
                DataManager::get_instance().archiveData().listRootEntry << entry;
            }

            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  
                continue;
            } else if (ET_UserCancelOpertion == m_eErrorType) {    
                zip_close(archive);
                return PFT_Cancel;
            } else {    
                
                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {
                    PasswordNeededQuery query(strFileName);
                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        setPassword(QString());
                        zip_close(archive);
                        return PFT_Cancel;
                    } else {
                        setPassword(query.password());
                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());
                        i--;
                    }
                }  else {
                    zip_close(archive);
                    return PFT_Error;
                }

            }
        }
    } else { 
        qlonglong qExtractSize = 0;
        m_listCurIndex.clear();
        getIndexBySelEntry(files);    

        
        for (int i = 0; i < m_listCurIndex.count(); ++i) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            QString strFileName;

            
            m_eErrorType = extractEntry(archive, m_listCurIndex[i], options, qExtractSize, strFileName, bHandleLongName);

            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  
                continue;
            } else if (ET_UserCancelOpertion == m_eErrorType) {    
                zip_close(archive);
                return PFT_Cancel;
            } else {    
                
                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {

                    PasswordNeededQuery query(strFileName);
                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        setPassword(QString());
                        zip_close(archive);
                        return PFT_Cancel;
                    } else {
                        setPassword(query.password());
                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());
                        i--;
                    }
                } else {
                    zip_close(archive);
                    return PFT_Error;
                }

            }
        }
    }

    if (bHandleLongName == true) {
        m_eErrorType = ET_LongNameError;
    }

    zip_close(archive);
    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::addFiles(const QList<FileEntry> &files, const CompressOptions &options)
{
    setPassword(QString());
    m_workStatus = WT_Add;
    qInfo() << "添加压缩包数据";
    int errcode = 0;
    zip_error_t err;

    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); 
    zip_error_init_with_code(&err, errcode);
    if (!archive) {
        emit error(("Failed to open the archive: %1")); 
        return PFT_Error;
    }

    m_curFileCount = 0;
    for (const FileEntry &e : files) {
        
        QString strPath = QFileInfo(e.strFullPath).absolutePath() + QDir::separator();

        
        if (QThread::currentThread()->isInterruptionRequested()) {
            break;
        }

        
        QFileInfo info(e.strFullPath);
        if (QFileInfo(e.strFullPath).isDir() && !info.isSymLink()) {
            if (!writeEntry(archive, e.strFullPath, options, true, strPath)) {
                if (zip_close(archive)) {
                    emit error(("Failed to write archive."));
                    return PFT_Error;
                }
                return PFT_Error;
            }

            QDirIterator it(e.strFullPath, QDir::AllEntries | QDir::Readable | QDir::Hidden | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);



            while (!QThread::currentThread()->isInterruptionRequested() && it.hasNext()) {
                const QString path = it.next();

                if (QFileInfo(path).isDir()&&!QFileInfo(path).isSymLink()) {
                    if (!writeEntry(archive, path, options, true, strPath)) {
                        if (zip_close(archive)) {
                            emit error(("Failed to write archive."));
                            return PFT_Error;
                        }
                        return PFT_Error;
                    }
                } else {
                    if (!writeEntry(archive, path, options, false, strPath)) {
                        if (zip_close(archive)) {
                            emit error(("Failed to write archive."));
                            return PFT_Error;
                        }
                        return PFT_Error;
                    }
                }
                ++m_curFileCount;
            }
        } else {
            if (!writeEntry(archive, e.strFullPath, options, false, strPath)) {
                if (zip_close(archive)) {
                    emit error(("Failed to write archive."));
                    return PFT_Error;
                }
                return PFT_Error;
            }
        }
        ++m_curFileCount;
    }


    m_pCurArchive = archive;
    
    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);
    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);

    if (zip_close(archive)) {
        emit error(("Failed to write archive."));
        
        
        if (zip_error_code_zip(zip_get_error(archive)) == ZIP_ER_WRITE && zip_error_code_system(zip_get_error(archive)) == ENOSPC) {
            m_eErrorType = ET_InsufficientDiskSpace;
        }

        return PFT_Error;
    }

    
    


    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::moveFiles(const QList<FileEntry> &files, const CompressOptions &options)
{
    Q_UNUSED(files)
    Q_UNUSED(options)
    m_workStatus = WT_Move;
    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::copyFiles(const QList<FileEntry> &files, const CompressOptions &options)
{
    Q_UNUSED(files)
    Q_UNUSED(options)
    m_workStatus = WT_Copy;
    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::deleteFiles(const QList<FileEntry> &files)
{
    
    setPassword(QString());
    m_workStatus = WT_Delete;
    int errcode = 0;
    zip_error_t err;

    
    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);
    zip_error_init_with_code(&err, errcode);
    if (nullptr == archive) {
        
        emit error(("Failed to open the archive: %1"));
        m_eErrorType = ET_FileOpenError;
        return PFT_Error;
    }

    m_curFileCount = 0;
    m_pCurArchive = archive; 
    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); 
    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        

    m_listCurIndex.clear();
    getIndexBySelEntry(files);    

    
    for (int i = 0; i < m_listCurIndex.count(); i++) {
        deleteEntry(m_listCurIndex[i], archive);        
    }

    if (zip_close(archive)) {
        emit error(("Failed to write archive."));
        m_eErrorType = ET_FileWriteError;
        return PFT_Error;
    }

    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::renameFiles(const QList<FileEntry> &files)
{
    
    setPassword(QString());
    m_workStatus = WT_Rename;
    int errcode = 0;
    zip_error_t err;

    
    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);
    zip_error_init_with_code(&err, errcode);
    if (nullptr == archive) {
        
        emit error(("Failed to open the archive: %1"));
        m_eErrorType = ET_FileOpenError;
        return PFT_Error;
    }

    m_curFileCount = 0;
    m_pCurArchive = archive; 
    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); 
    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        

    m_listCurIndex.clear();
    getIndexBySelEntry(files, true);    

    
    for (int i = 0; i < m_listCurIndex.count(); i++) {
        QString strAlias;
        if (!files[0].strFullPath.endsWith(QDir::separator())) { 
            QString strPath = QFileInfo(files[0].strFullPath).path();
            if(strPath == "." || strPath.isEmpty() || strPath.isNull()) {
                strAlias = files[0].strAlias;
            } else {
                strAlias = strPath + QDir::separator() + files[0].strAlias;
            }
        } else { 
            QString strPath = QFileInfo(files[0].strFullPath.left(files[0].strFullPath.length() - 1)).path();
            if(strPath == "."){
                strAlias = files[0].strAlias + QDir::separator();
            } else {
                strAlias = strPath + QDir::separator() + files[0].strAlias + QDir::separator();
            }
            strAlias = strAlias + m_listCurName[i].right(m_listCurName[i].length()-files[0].strFullPath.length());
        }
        renameEntry(m_listCurIndex[i], archive,  strAlias);        
    }
    if (zip_close(archive)) {
        emit error(("Failed to write archive."));
        m_eErrorType = ET_FileWriteError;
        return PFT_Error;
    }
    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::addComment(const QString &comment)
{
    setPassword(QString());
    m_workStatus = WT_Comment;

    
    int errcode = 0;
    zip_error_t err;

    
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); 
    zip_error_init_with_code(&err, errcode);
    if (!archive) {
        return PFT_Error;
    }

    
    QByteArray tmp = comment.toUtf8();
    const char *commentstr = tmp.constData();

    zip_uint16_t commentlength = static_cast<zip_uint16_t>(strlen(commentstr));     

    
    errcode = zip_set_archive_comment(archive, commentstr, commentlength);

    
    if (ZIP_ER_OK != errcode) {
        return PFT_Error;
    }

    
    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);

    
    if (zip_close(archive)) {
        m_eErrorType = ET_FileWriteError;
        return PFT_Error;
    }

    return PFT_Nomral;
}

PluginFinishType LibzipPlugin::updateArchiveData(const UpdateOptions &)
{
    m_mapFileCode.clear();
    m_setHasHandlesDirs.clear();
    m_setHasRootDirs.clear();
    DataManager::get_instance().resetArchiveData();

    
    int errcode = 0;
    zip_error_t err;

    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   
    zip_error_init_with_code(&err, errcode);

    
    if (!archive) {


    }

    
    const auto nofEntries = zip_get_num_entries(archive, 0);

    
    for (zip_int64_t i = 0; i < nofEntries; i++) {
        if (QThread::currentThread()->isInterruptionRequested()) {
            break;
        }

        handleArchiveData(archive, i);  
    }

    zip_close(archive);

    return PFT_Nomral;
}

void LibzipPlugin::pauseOperation()
{
    m_bPause = true;
}

void LibzipPlugin::continueOperation()
{
    m_bPause = false;
}

bool LibzipPlugin::doKill()
{
    m_bPause = false;
    m_bCancel = true;
    return false;
}

bool LibzipPlugin::writeEntry(zip_t *archive, const QString &entry, const CompressOptions &options, bool isDir, const QString &strRoot)
{
    Q_ASSERT(archive);
    QFileInfo info(entry);
    QString str;
    if (!options.strDestination.isEmpty()) {
        str = QString(options.strDestination + entry.mid(strRoot.length()));
    } else {
        
        str = entry.mid(strRoot.length());
    }
    zip_int64_t index;
    if (isDir && !info.isSymLink()) {
        index = zip_dir_add(archive, str.toUtf8().constData(), ZIP_FL_ENC_GUESS);
        if (-1 == index) {
            
            return false;
        }
    } else if(info.isSymLink()) { 
        QByteArray strLinkArr = info.symLinkTarget().toUtf8();
        struct zip_source *source = zip_source_buffer(archive , strLinkArr, strLinkArr.length(), 0);
        if (source)
        {
            index = zip_add(archive, str.toUtf8().constData(), source);
        }
        else {
            zip_source_free(source);
            emit error(("Failed to add entry: %1"));
            return false;
        }
        zip_source_commit_write(source);
        zip_source_close(source);
     } else {
        
        zip_source_t *src = zip_source_file(archive, QFile::encodeName(entry).constData(), 0, -1);
        if (!src) {
            emit error(("Failed to add entry: %1"));
            return false;
        }

        
        index = zip_file_add(archive, str.toUtf8().constData(), src, ZIP_FL_ENC_GUESS | ZIP_FL_OVERWRITE);
        if (-1 == index) {
            zip_source_free(src);
            emit error(("Failed to add entry: %1"));
            return false;
        }
        zip_source_commit_write(src);
        zip_source_close(src);
    }
    zip_uint64_t uindex = static_cast<zip_uint64_t>(index);

    
    QT_STATBUF result;
    if (QT_LSTAT(QFile::encodeName(entry).constData(), &result) != 0) {
    } else {
        zip_uint32_t attributes = result.st_mode << 16;
        if (zip_file_set_external_attributes(archive, uindex, 0, ZIP_OPSYS_UNIX, attributes) != 0) {
        }
    }


    
    if (options.bEncryption && !options.strEncryptionMethod.isEmpty()) { 
        int ret = 0;
        if (QLatin1String("AES128") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_128, options.strPassword.toUtf8().constData());
        } else if (QLatin1String("AES192") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_192, options.strPassword.toUtf8().constData());
        } else if (QLatin1String("AES256") == options.strEncryptionMethod) {
            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_256, options.strPassword.toUtf8().constData());
        }
        if (ret != 0) {
            emit error(("Failed to set compression options for entry: %1"));
            return false;
        }
    }

    
    zip_int32_t compMethod = ZIP_CM_DEFAULT;
    if (!options.strCompressionMethod.isEmpty()) {
        if (QLatin1String("Deflate") == options.strCompressionMethod) {
            compMethod = ZIP_CM_DEFLATE;
        } else if (QLatin1String("BZip2") == options.strCompressionMethod) {
            compMethod = ZIP_CM_BZIP2;
        } else if (QLatin1String("Store") == options.strCompressionMethod) {
            compMethod = ZIP_CM_STORE;
        }
    }

    
    const int compLevel = (options.iCompressionLevel != -1) ? options.iCompressionLevel : 6;
    if (zip_set_file_compression(archive, uindex, compMethod, zip_uint32_t(compLevel)) != 0) {
        emit error(("Failed to set compression options for entry: %1"));
        return false;
    }
    return true;
}


void LibzipPlugin::progressCallback(zip_t *, double progress, void *that)
{
    static_cast<LibzipPlugin *>(that)->emitProgress(progress);      
}


int LibzipPlugin::cancelCallback(zip_t *, void *that)
{
    return static_cast<LibzipPlugin *>(that)->cancelResult();       
}

bool LibzipPlugin::handleArchiveData(zip_t *archive, zip_int64_t index)
{
    if (nullptr == archive) {
        return false;
    }

    zip_stat_t statBuffer;
    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer)) {
        return false;
    }

    QByteArray strCode;
    
    QString name = m_common->trans2uft8(statBuffer.name, strCode);
    m_mapFileCode[index] = strCode;
    if(name.contains(QLatin1Char('\\')))
        name = name.replace(QLatin1Char('\\'), QDir::separator());
    
    if(name.startsWith(QDir::separator())) {
        name.remove(0,1);
    }
    FileEntry entry;
    entry.iIndex = int(index);
    entry.strFullPath = name;
    statBuffer2FileEntry(statBuffer, entry);

    handleEntry(entry);

    
    DataManager::get_instance().archiveData().mapFileEntry[name] = entry;

    return true;
}

void LibzipPlugin::statBuffer2FileEntry(const zip_stat_t &statBuffer, FileEntry &entry)
{
    

    
    if (statBuffer.valid & ZIP_STAT_NAME) {
        const QStringList pieces = entry.strFullPath.split(QLatin1Char('/'), QString::SkipEmptyParts);
        entry.strFileName = pieces.isEmpty() ? QString() : pieces.last();
    }

    
    if (entry.strFullPath.endsWith(QDir::separator())) {
        entry.isDirectory = true;
    }

    
    if (statBuffer.valid & ZIP_STAT_SIZE) {
        if (!entry.isDirectory) {
            entry.qSize = qlonglong(statBuffer.size);
            DataManager::get_instance().archiveData().qSize += statBuffer.size;
            DataManager::get_instance().archiveData().qComressSize += statBuffer.comp_size;
        } else {
            entry.qSize = 0;
        }
    }

    
    if (statBuffer.valid & ZIP_STAT_MTIME) {
        entry.uLastModifiedTime = uint(statBuffer.mtime);
    }

    DataManager::get_instance().archiveData().strComment = m_strComment;
}

ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)
{
    zip_stat_t statBuffer;
    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {
        return ET_FileReadError;
    }

    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    
    if(strFileName.contains(QLatin1Char('\\')))
        strFileName = strFileName.replace(QLatin1Char('\\'), QDir::separator());
    QString strOriginName = strFileName;

    









    QString strFilePath;
    QString strTempFileName = strFileName;
    int iIndex = strFileName.lastIndexOf(QDir::separator());

    if (iIndex >= 0) {
        strFilePath = strFileName.left(iIndex);   
        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);
    }

    QString tempFilePathName;
    if(!m_bDlnfs) {
        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);
        if(sDir.length() > 0) {
           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;
           if(strFileName.endsWith(QDir::separator())) {
               strFileName = sDir;
           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {
               strFileName = sDir + strTempFileName;
           }
           if(!m_mapLongDirName.isEmpty()) {
               bHandleLongName = true;
           }
        }
        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {
            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);

            
            tempFilePathName = strFilePath + QDir::separator() + strTemp;   
            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {
                return ET_LongNameError;
            }
            bHandleLongName = true;
            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();
            if(10 < sSuffix.length()){
                sSuffix = QFileInfo(strTempFileName).suffix();
                if(10 < sSuffix.length()) {
                    sSuffix = sSuffix.right(10);
                }
            }
            strTempFileName = strTemp + QString("(%1)").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + "." + sSuffix;

            strFileName = strTempFileName;
            if (iIndex >= 0) {
                strFileName = strFilePath + QDir::separator() + strTempFileName;
            }

        }
    }

    
    if (!options.strDestination.isEmpty()) {
        if(bHandleLongName) {
            int nCnt = options.strDestination.count(QDir::separator());
            int nIndex = 0;
            for(int i = 0; i < nCnt; i++){
                nIndex = strFileName.indexOf(QDir::separator(), nIndex);
                nIndex++;
            }
            strFileName = strFileName.remove(0, nIndex);
        } else {
            strFileName = strFileName.remove(0, options.strDestination.size());
        }
    }


    if (bHandleLongName) {
        emit signalCurFileName(strOriginName); 
    } else {
        emit signalCurFileName(strFileName); 
    }

    bool bIsDirectory = strFileName.endsWith(QDir::separator());    

    
    if (QDir().exists(options.strTargetPath) == false)
        QDir().mkpath(options.strTargetPath);

    
    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;

    QFile file(strDestFileName);

    
    QString parentDir;
    if (strFileName.endsWith(QDir::separator())) {
        QDir pDir = QFileInfo(strDestFileName).dir();
        pDir.cdUp();
        parentDir = pDir.path();
    } else {
        parentDir = QFileInfo(strDestFileName).path();
    }
    
    const bool restoreParentMtime = (parentDir != options.strTargetPath);

    time_t parent_mtime;
    if (restoreParentMtime) {
        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;
    }

    
    zip_uint8_t opsys;
    zip_uint32_t attributes;
    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {
        emit error(("Failed to read metadata for entry: %1"));
    }

    
    mode_t value = mode_t();
    switch (opsys) {
    case ZIP_OPSYS_UNIX:
        value = attributes >> 16;
        break;
    default:    
        break;
    }
    bool isLink = false;
    if(S_ISLNK(value)) {
        isLink = true;
    }
    QFileDevice::Permissions per = getPermissions(value);

    if (bIsDirectory && !isLink) {     
        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())
            return ET_LongNameError;

        QDir dir;
        dir.mkpath(strDestFileName);

        
        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
    } else if(isLink) { 
        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        char buf[READBYTES] = {0};
        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));
        if (readBytes > 0) {
            QString strBuf = QString(buf).toLocal8Bit();
            if (QFile::link(strBuf, strDestFileName)) {
                qInfo() << "Symlink's created:" << buf << strFileName;
            } else {
                qInfo() << "Can't create symlink" << buf << strFileName;
            }
        }
        file.close();
        zip_fclose(zipFile);
    } else {        

        
        if (file.exists()) {
            if (m_bSkipAll) {       
                m_mapLongName[tempFilePathName]++;   
                return ET_NoError;
            } else {
                if (!m_bOverwriteAll) {     

                    OverwriteQuery query(strDestFileName);

                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        emit signalCancel();
                        return ET_UserCancelOpertion;
                    } else if (query.responseSkip()) {
                        m_mapLongName[tempFilePathName]++;   
                        return ET_NoError;
                    } else if (query.responseSkipAll()) {
                        m_bSkipAll = true;
                        m_mapLongName[tempFilePathName]++;   
                        return ET_NoError;
                    }  else if (query.responseOverwriteAll()) {
                        m_bOverwriteAll = true;
                    }
                }
            }
        }

        if (bHandleLongName) {
            m_setLongName << strFileName;
        }

        
        if (file.exists() && !file.isWritable()) {
            file.remove();
            file.setFileName(strDestFileName);
            file.setPermissions(QFileDevice::WriteUser);
        }

        
        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
            QDir().mkpath(QFileInfo(strDestFileName).path());

        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        
        if (nullptr == zipFile) {
            int iErr = zip_error_code_zip(zip_get_error(archive));
            if (ZIP_ER_WRONGPASSWD == iErr) {

                
                bool bCheckFinished = false;
                int iCodecIndex = 0;
                while (nullptr == zipFile && false == bCheckFinished) {
                    if (m_listCodecs.length() == iCodecIndex) {
                        bCheckFinished = true;
                        if (file.exists()) {
                            file.remove();
                        }

                        return ET_WrongPassword;
                    } else {
                        
                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());
                        iCodecIndex++;
                        zip_error_clear(archive);
                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
                        iErr = zip_error_code_zip(zip_get_error(archive));
                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {
                            bCheckFinished = true;
                        }
                    }
                }
            } else if (ZIP_ER_NOPASSWD == iErr) {   
                return ET_NeedPassword;
            } else {
                return ET_FileOpenError;
            }
        }

        
        if (file.open(QIODevice::WriteOnly) == false) {
            zip_fclose(zipFile);

            QList<QString> entryNameList = strDestFileName.split('/');
            foreach (auto &tmp, entryNameList) {
                
                if (NAME_MAX < tmp.toLocal8Bit().length()) {
                    return ET_LongNameError;
                }
            }

            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
            return ET_FileWriteError;
        }

        
        QDataStream out(&file);
        zip_int64_t sum = 0;
        char buf[READBYTES];
        int writeSize = 0;
        double dScale = 1;
        
        if (!options.bExistList) {
            dScale = double(statBuffer.comp_size) / statBuffer.size;
        }
        while (sum != zip_int64_t(statBuffer.size)) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            if (m_bPause) { 
                sleep(1);
                continue;
            }

            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));

            if (readBytes < 0) {
                file.close();
                zip_fclose(zipFile);
                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                return ET_FileWriteError;
            }

            if (out.writeRawData(buf, int(readBytes)) != readBytes) {
                file.close();
                zip_fclose(zipFile);

                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  
                    return ET_InsufficientDiskSpace;
                } else {
                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                    return ET_FileWriteError;
                }
            }

            sum += readBytes;
            writeSize += readBytes;

            
            qExtractSize += readBytes * dScale;
            emit signalprogress((double(qExtractSize)) * m_dScaleSize);
        }

        file.close();
        zip_fclose(zipFile);
    }
    if(!isLink) {
        
        file.setPermissions(per);

        
        utimbuf times;
        times.modtime = statBuffer.mtime;
        utime(strDestFileName.toUtf8().constData(), &times);

        if (restoreParentMtime) {
            
            times.modtime = parent_mtime;
            utime(parentDir.toUtf8().constData(), &times);
        }
    }
    m_mapLongName[tempFilePathName]++;   
    return ET_NoError;
}

void LibzipPlugin::emitProgress(double dPercentage)
{
    bool flag = true;
    while (flag) {
        if (QThread::currentThread()->isInterruptionRequested()) { 
            break;
        }

        
        if (m_bPause) {
            sleep(1);
            continue;
        }

        
        if (m_pCurArchive) {
            if (WT_Add == m_workStatus) {
                
                zip_uint64_t index = zip_uint64_t(m_curFileCount * dPercentage);
                
                emit signalCurFileName(m_common->trans2uft8(zip_get_name(m_pCurArchive, index, ZIP_FL_ENC_RAW), m_mapFileCode[zip_int64_t(index)]));
            } else if (WT_Delete == m_workStatus) {
                
                int iSpan = qRound(m_listCurName.count() * dPercentage);    
                QString strCurFileName;
                
                if (iSpan < 0) {
                    strCurFileName = m_listCurName[0];
                } else if (iSpan >= m_listCurIndex.count()) {
                    strCurFileName = m_listCurName[m_listCurName.count() - 1];
                } else {
                    strCurFileName = m_listCurName[iSpan];
                }

                
                emit signalCurFileName(strCurFileName);
            }

        }

        
        emit signalprogress(dPercentage * 100);

        flag = false;
    }

    m_bPause = false;
}

int LibzipPlugin::cancelResult()
{
    if (m_bCancel) {
        m_bCancel = false;
        return 1;
    } else {
        return 0;
    }
}

QByteArray LibzipPlugin::passwordUnicode(const QString &strPassword, int iIndex)
{
    if (m_strArchiveName.endsWith(".zip")) {
        
        int nCount = strPassword.count();
        bool b = false;

        
        for (int i = 0 ; i < nCount ; i++) {
            QChar cha = strPassword.at(i);
            ushort uni = cha.unicode();
            if (uni >= 0x4E00 && uni <= 0x9FA5) {   
                b = true;
                break;
            }
        }

        
        if (b) {
            QTextCodec *utf8 = QTextCodec::codecForName("UTF-8");
            QTextCodec *gbk = QTextCodec::codecForName(m_listCodecs[iIndex].toUtf8().data());
            

            
            
            QString strUnicode = utf8->toUnicode(strPassword.toUtf8().data());
            
            QByteArray gb_bytes = gbk->fromUnicode(strUnicode);
            return gb_bytes; 
        } else {
            return strPassword.toUtf8();
        }
    } else {
        return strPassword.toUtf8();
    }

}

bool LibzipPlugin::deleteEntry(int index, zip_t *archive)
{
    
    if (QThread::currentThread()->isInterruptionRequested()) {
        if (zip_close(archive)) {
            
            emit error(("Failed to write archive."));
            m_eErrorType = ET_FileWriteError;
            return false;
        }
        return false;
    }

    int statusDel = zip_delete(archive, zip_uint64_t(index));   
    if (-1 == statusDel) {
        
        emit error(("Failed to delete entry: %1"));
        m_eErrorType = ET_DeleteError;
        return false;
    }

    return true;
}

bool LibzipPlugin::renameEntry(int index, zip_t *archive, const QString &strAlisa)
{
    
    if (QThread::currentThread()->isInterruptionRequested()) {
        if (zip_close(archive)) {
            
            emit error(("Failed to write archive."));
            m_eErrorType = ET_FileWriteError;
            return false;
        }
        return false;
    }

    int statusDel = zip_rename(archive, zip_uint64_t(index), strAlisa.toUtf8().data());   
    if (-1 == statusDel) {
        
        emit error(("Failed to rename entry: %1"));
        m_eErrorType = ET_RenameError;
        return false;
    }

    return true;
}

void LibzipPlugin::getIndexBySelEntry(const QList<FileEntry> &listEntry, bool isRename)
{
    m_listCurIndex.clear();
    m_listCurName.clear();
    ArchiveData stArchiveData = DataManager::get_instance().archiveData();

    
    for (FileEntry entry : listEntry) {
        auto iter = stArchiveData.mapFileEntry.find(entry.strFullPath);
        for (; iter != stArchiveData.mapFileEntry.end();) {
            if (!iter.key().startsWith(entry.strFullPath)) {
                break;
            } else {
                
                if (iter.value().iIndex >= 0) {
                    m_listCurIndex << iter.value().iIndex;      
                    m_listCurName << iter.value().strFullPath;  
                }

                ++iter;

                
                if (!entry.strFullPath.endsWith(QDir::separator())) {
                    break;
                }
            }
        }
    }
    if(isRename) return;
    
    std::stable_sort(m_listCurIndex.begin(), m_listCurIndex.end());
}
