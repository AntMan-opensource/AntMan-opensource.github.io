













































































void main_outI1(struct fd *whack_sock, struct connection *c, struct state *predecessor, lset_t policy, unsigned long try, const threadtime_t *inception, shunk_t sec_label)





{
	struct ike_sa *ike = new_v1_istate(c, whack_sock);
	struct state *st = &ike->sa;
	statetime_t start = statetime_backdate(st, inception);

	
	initialize_new_state(st, policy, try);

	change_v1_state(st, STATE_MAIN_I1);

	if (HAS_IPSEC_POLICY(policy)) {
		add_v1_pending(whack_sock, ike, c, policy, 1, predecessor == NULL ? SOS_NOBODY : predecessor->st_serialno, sec_label, true );


	}

	if (predecessor == NULL) {
		log_state(RC_LOG, &ike->sa, "initiating IKEv1 Main Mode connection");
	} else {
		log_state(RC_LOG, &ike->sa, "initiating IKEv1 Main Mode connection to replace #%lu", predecessor->st_serialno);
	}

	
	reply_stream = open_pbs_out("reply packet", reply_buffer, sizeof(reply_buffer), st->st_logger);

	
	pb_stream rbody;
	{
		struct isakmp_hdr hdr = {
			.isa_version = ISAKMP_MAJOR_VERSION << ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION, .isa_xchg = ISAKMP_XCHG_IDPROT, };


		hdr.isa_ike_initiator_spi = st->st_ike_spis.initiator;
		

		if (impair.send_bogus_isakmp_flag) {
			hdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;
		}

		if (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream, &rbody)) {
			return;
		}
	}

	
	{
		uint8_t *sa_start = rbody.cur;

		if (!ikev1_out_sa(&rbody, IKEv1_oakley_main_mode_db_sa(c), st, true, false)) {

			log_state(RC_LOG, st, "outsa fail");
			return;
		}

		
		passert(st->st_p1isa.ptr == NULL);

		
		st->st_p1isa = clone_bytes_as_chunk(sa_start, rbody.cur - sa_start, "sa in main_outI1");
	}

	
	if (!out_v1VID_set(&rbody, c)) {
		return;
	}

	
	if (!nat_traversal_insert_vid(&rbody, c)) {
		return;
	}

	if (!ikev1_close_message(&rbody, st)) {
		return;
	}

	close_output_pbs(&reply_stream);

	
	record_and_send_v1_ike_msg(st, &reply_stream, "reply packet for main_outI1");

	delete_event(st);
	clear_retransmits(st);
	start_retransmits(st);

	if (predecessor != NULL) {
		update_pending(pexpect_ike_sa(predecessor), pexpect_ike_sa(st));
		log_state(RC_NEW_V1_STATE + st->st_state->kind, &ike->sa, "%s, replacing #%lu", st->st_state->story, predecessor->st_serialno);


	} else {
		log_state(RC_NEW_V1_STATE + st->st_state->kind, &ike->sa, "%s", st->st_state->story);
	}

	statetime_stop(&start, "%s()", __func__);
}



static void main_mode_hash_body(struct state *st, enum sa_role role, const pb_stream *idpl, struct crypt_prf *ctx)


{
	switch (role) {
	case SA_INITIATOR:
		crypt_prf_update_hunk(ctx, "gi", st->st_gi);
		crypt_prf_update_hunk(ctx, "gr", st->st_gr);
		crypt_prf_update_thing(ctx, "initiator", st->st_ike_spis.initiator);
		crypt_prf_update_thing(ctx, "responder", st->st_ike_spis.responder);
		break;
	case SA_RESPONDER:
		crypt_prf_update_hunk(ctx, "gr", st->st_gr);
		crypt_prf_update_hunk(ctx, "gi", st->st_gi);
		crypt_prf_update_thing(ctx, "respoder", st->st_ike_spis.responder);
		crypt_prf_update_thing(ctx, "initiator", st->st_ike_spis.initiator);
		break;
	default:
		bad_case(role);
	}

	if (DBGP(DBG_CRYPT)) {
		DBG_log("hashing %zu bytes of SA", st->st_p1isa.len - sizeof(struct isakmp_generic));
	}

	
	crypt_prf_update_bytes(ctx, "p1isa", st->st_p1isa.ptr + sizeof(struct isakmp_generic), st->st_p1isa.len - sizeof(struct isakmp_generic));


	
	crypt_prf_update_bytes(ctx, "idpl", idpl->start + sizeof(struct isakmp_generic), pbs_offset(idpl) - sizeof(struct isakmp_generic));

}

struct crypt_mac main_mode_hash(struct state *st, enum sa_role role, const pb_stream *idpl)

{
	struct crypt_prf *ctx = crypt_prf_init_symkey("main mode", st->st_oakley.ta_prf, "skeyid", st->st_skeyid_nss, st->st_logger);


	main_mode_hash_body(st, role, idpl, ctx);
	return crypt_prf_final_mac(&ctx, NULL);
}



struct hash_signature v1_sign_hash_RSA(const struct connection *c, const struct crypt_mac *hash, struct logger *logger)

{
	const struct secret_stuff *pks = get_local_private_key(c, &pubkey_type_rsa, logger);
	if (pks == NULL) {
		llog(RC_LOG_SERIOUS, logger, "unable to locate my private key for RSA Signature");
		return (struct hash_signature) { .len = 0, }; 
	}

	struct hash_signature sig = pubkey_signer_raw_rsa.sign_hash(pks, hash->ptr, hash->len, &ike_alg_hash_sha1, logger);
	return sig;
}


bool ikev1_encrypt_message(pb_stream *pbs, struct state *st)
{
	const struct encrypt_desc *e = st->st_oakley.ta_encrypt;
	uint8_t *enc_start = pbs->start + sizeof(struct isakmp_hdr);
	size_t enc_len = pbs_offset(pbs) - sizeof(struct isakmp_hdr);

	if (DBGP(DBG_CRYPT)) {
		DBG_dump("encrypting:", enc_start, enc_len);
		DBG_dump_hunk("IV:", st->st_v1_new_iv);
		DBG_log("unpadded size is: %u", (unsigned int)enc_len);
	}

	
	{
		size_t padding = pad_up(enc_len, e->enc_blocksize);

		if (padding != 0) {
			if (!pbs_out_zero(pbs, padding, "encryption padding")) {
				
				return false; 
			}

			enc_len += padding;
		}
	}

	if (DBGP(DBG_CRYPT)) {
		DBG_log("encrypting %zu using %s", enc_len, st->st_oakley.ta_encrypt->common.fqn);
	}

	passert(st->st_v1_new_iv.len >= e->enc_blocksize);
	st->st_v1_new_iv.len = e->enc_blocksize;   

	
	if (!ikev1_close_message(pbs, st))
		return false;

	e->encrypt_ops->do_crypt(e, enc_start, enc_len, st->st_enc_key_nss, st->st_v1_new_iv.ptr, true, st->st_logger);



	update_iv(st);
	if (DBGP(DBG_CRYPT)) {
		DBG_dump_hunk("next IV:", st->st_v1_iv);
	}

	return true;
}


bool ikev1_close_message(pb_stream *pbs, const struct state *st)
{
	passert(st->st_ike_version == IKEv1);
	size_t padding = pad_up(pbs_offset(pbs), 4);

	if (padding == 0) {
		dbg("no IKEv1 message padding required");
	} else if (pexpect(st != NULL) && pexpect(st->st_connection != NULL) && (st->st_connection->policy & POLICY_NO_IKEPAD)) {
		dbg("IKEv1 message padding of %zu bytes skipped by policy", padding);
	} else {
		dbg("padding IKEv1 message with %zu bytes", padding);
		if (!pbs_out_zero(pbs, padding, "message padding")) {
			
			return false; 
		}
	}

	close_output_pbs(pbs);
	return true;
}





stf_status main_inI1_outR1(struct state *unused_st UNUSED, struct msg_digest *md)
{
	
	struct payload_digest *const sa_pd = md->chain[ISAKMP_NEXT_SA];
	pb_stream r_sa_pbs;

	if (drop_new_exchanges()) {
		return STF_IGNORE;
	}

	struct connection *c = find_v1_main_mode_connection(md);
	if (c == NULL) {
		
		
		return STF_IGNORE;
	}

	
	struct ike_sa *ike = new_v1_rstate(c, md);
	struct state *st = md->v1_st = &ike->sa;

	passert(!st->st_oakley.doing_xauth);

	st->st_try = 0; 
	
	st->st_policy = c->policy & ~POLICY_IPSEC_MASK;
	change_v1_state(st, STATE_MAIN_R0);

	binlog_refresh_state(st);

	merge_quirks(st, md);

	set_nat_traversal(st, md);

	if (DBGP(DBG_BASE)) {
		DBG_dump_thing("  ICOOKIE-DUMP:", st->st_ike_spis.initiator);
	}

	if (c->kind == CK_INSTANCE) {
		endpoint_buf b;
		log_state(RC_LOG, st, "responding to Main Mode from unknown peer %s", str_endpoint_sensitive(&md->sender, &b));
	} else {
		log_state(RC_LOG, st, "responding to Main Mode");
	}

	

	
	reply_stream = open_pbs_out("reply packet", reply_buffer, sizeof(reply_buffer), st->st_logger);
	struct pbs_out rbody;
	{
		struct isakmp_hdr hdr = md->hdr;

		hdr.isa_flags = 0; 
		hdr.isa_ike_responder_spi = st->st_ike_spis.responder;
		hdr.isa_np = ISAKMP_NEXT_NONE; 

		if (impair.send_bogus_isakmp_flag) {
			hdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;
		}

		if (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream, &rbody))
			return STF_INTERNAL_ERROR;
	}

	
	{
		struct isakmp_sa r_sa = {
			.isasa_doi = ISAKMP_DOI_IPSEC, };
		if (!out_struct(&r_sa, &isakmp_sa_desc, &rbody, &r_sa_pbs))
			return STF_INTERNAL_ERROR;
	}

	
	RETURN_STF_FAIL_v1NURE(parse_isakmp_sa_body(&sa_pd->pbs, &sa_pd->payload.sa, &r_sa_pbs, false, st));


	
	if (!out_v1VID_set(&rbody, c))
		return STF_INTERNAL_ERROR;

	
	if (st->hidden_variables.st_nat_traversal != LEMPTY) {
		if (!out_v1VID(&rbody, md->quirks.qnat_traversal_vid))
			return STF_INTERNAL_ERROR;
	}

	if (!ikev1_close_message(&rbody, st))
		return STF_INTERNAL_ERROR;

	
	replace_chunk(&st->st_p1isa, clone_pbs_in_as_chunk(&sa_pd->pbs, "sa in main_inI1_outR1()"));

	return STF_OK;
}



static ke_and_nonce_cb main_inR1_outI2_continue;	

stf_status main_inR1_outI2(struct state *st, struct msg_digest *md)
{
	if (impair.drop_i2) {
		dbg("dropping Main Mode I2 packet as per impair");
		return STF_IGNORE;
	}

	
	{
		struct payload_digest *const sapd = md->chain[ISAKMP_NEXT_SA];

		RETURN_STF_FAIL_v1NURE(parse_isakmp_sa_body(&sapd->pbs, &sapd->payload.sa, NULL, true, st));

	}

	if (libreswan_fipsmode() && st->st_oakley.ta_prf == NULL) {
		log_state(RC_LOG_SERIOUS, st, "Missing prf - algo not allowed in fips mode (inR1_outI2)?");
		return STF_FAIL_v1N + v1N_SITUATION_NOT_SUPPORTED;
	}

	merge_quirks(st, md);

	set_nat_traversal(st, md);

	submit_ke_and_nonce(st, st->st_oakley.ta_dh, main_inR1_outI2_continue, HERE);
	return STF_SUSPEND;
}



static stf_status main_inR1_outI2_continue(struct state *st, struct msg_digest *md, struct dh_local_secret *local_secret, chunk_t *nonce)


{
	dbg("main_inR1_outI2_continue for #%lu: calculated ke+nonce, sending I2", st->st_serialno);

	
	struct pbs_out rbody;
	ikev1_init_pbs_out_from_md_hdr(md, false, &reply_stream, reply_buffer, sizeof(reply_buffer), &rbody, st->st_logger);


	
	if (!ikev1_ship_KE(st, local_secret, &st->st_gi, &rbody))
		return STF_INTERNAL_ERROR;

	
	if (!ikev1_ship_nonce(&st->st_ni, nonce, &rbody, "Ni"))
		return STF_INTERNAL_ERROR;

	if (impair.bust_mi2) {
		
		pb_stream vid_pbs;

		
		if (!ikev1_out_generic(&isakmp_vendor_id_desc, &rbody, &vid_pbs))

			return STF_INTERNAL_ERROR;

		if (!pbs_out_zero(&vid_pbs, 1500, "Filler VID")) {
			
			return STF_INTERNAL_ERROR;
		}

		close_output_pbs(&vid_pbs);
	}

	dbg("NAT-T checking st_nat_traversal");
	if (st->hidden_variables.st_nat_traversal != LEMPTY) {
		dbg("NAT-T found (implies NAT_T_WITH_NATD)");
		
		if (!ikev1_nat_traversal_add_natd(&rbody, md))
			return STF_INTERNAL_ERROR;
	}

	
	if (!ikev1_close_message(&rbody, st))
		return STF_INTERNAL_ERROR;

	
	rehash_state(st, &md->hdr.isa_ike_responder_spi);

	return STF_OK;
}



static ke_and_nonce_cb main_inI2_outR2_continue1; 

stf_status main_inI2_outR2(struct state *st, struct msg_digest *md)
{
	
	if (!unpack_KE(&st->st_gi, "Gi", st->st_oakley.ta_dh, md->chain[ISAKMP_NEXT_KE], st->st_logger)) {
		return STF_FAIL_v1N + v1N_INVALID_KEY_INFORMATION;
	}

	
	RETURN_STF_FAIL_v1NURE(accept_v1_nonce(st->st_logger, md, &st->st_ni, "Ni"));

	
	decode_v1_certificate_requests(st, md);

	ikev1_natd_init(st, md);

	submit_ke_and_nonce(st, st->st_oakley.ta_dh, main_inI2_outR2_continue1, HERE);
	return STF_SUSPEND;
}


static dh_shared_secret_cb main_inI2_outR2_continue2;	

static stf_status main_inI2_outR2_continue2(struct state *st, struct msg_digest *md)
{
	dbg("main_inI2_outR2_calcdone for #%lu: calculate DH finished", st->st_serialno);

	
	if (st->st_dh_shared_secret != NULL) {
		calc_v1_skeyid_and_iv(st);
		update_iv(st);
	}

	
	if (md != NULL) {
		
		process_packet_tail(md);
	}
	return STF_SKIP_COMPLETE_STATE_TRANSITION;
}


static stf_status main_inI2_outR2_continue1(struct state *st, struct msg_digest *md, struct dh_local_secret *local_secret, chunk_t *nonce)


{
	dbg("main_inI2_outR2_continue for #%lu: calculated ke+nonce, sending R2", st->st_serialno);

	passert(md != NULL);

	if (libreswan_fipsmode() && st->st_oakley.ta_prf == NULL) {
		log_state(RC_LOG_SERIOUS, st, "Missing prf - algo not allowed in fips mode (inI2_outR2)?");
		return STF_FAIL_v1N + v1N_SITUATION_NOT_SUPPORTED;
	}

	
	bool send_cr = false;

	

	send_cr = (st->st_oakley.auth == OAKLEY_RSA_SIG) && !remote_has_preloaded_pubkey(st) && st->st_connection->remote->config->host.ca.ptr != NULL;


	
	struct pbs_out rbody;
	ikev1_init_pbs_out_from_md_hdr(md, false, &reply_stream, reply_buffer, sizeof(reply_buffer), &rbody, st->st_logger);


	
	passert(ikev1_ship_KE(st, local_secret, &st->st_gr, &rbody));

	
	if (!ikev1_ship_nonce(&st->st_nr, nonce, &rbody, "Nr"))
		return STF_INTERNAL_ERROR;

	if (impair.bust_mr2) {
		
		struct pbs_out vid_pbs;
		if (!ikev1_out_generic(&isakmp_vendor_id_desc, &rbody, &vid_pbs))
			return STF_INTERNAL_ERROR;
		if (!pbs_out_zero(&vid_pbs, 1500, "Filler VID")) {
			
			return STF_INTERNAL_ERROR;
		}

		close_output_pbs(&vid_pbs);
	}

	
	if (send_cr) {
		if (st->st_connection->kind == CK_PERMANENT) {
			if (!ikev1_build_and_ship_CR(CERT_X509_SIGNATURE, st->st_connection->remote->config->host.ca, &rbody))

				return STF_INTERNAL_ERROR;
		} else {
			generalName_t *ca = collect_rw_ca_candidates(md);

			if (ca != NULL) {
				generalName_t *gn;

				for (gn = ca; gn != NULL; gn = gn->next) {
					if (!ikev1_build_and_ship_CR(CERT_X509_SIGNATURE, gn->name, &rbody)) {

						free_generalNames(ca, false);
						return STF_INTERNAL_ERROR;
					}
				}
				free_generalNames(ca, false);
			} else {
				if (!ikev1_build_and_ship_CR(CERT_X509_SIGNATURE, EMPTY_CHUNK, &rbody))

					return STF_INTERNAL_ERROR;
			}
		}
	}

	if (st->hidden_variables.st_nat_traversal != LEMPTY) {
		
		if (!ikev1_nat_traversal_add_natd(&rbody, md))
			return STF_INTERNAL_ERROR;
	}

	
	if (!ikev1_close_message(&rbody, st))
		return STF_INTERNAL_ERROR;

	
	dbg("main inI2_outR2: starting async DH calculation (group=%d)", st->st_oakley.ta_dh->group);
	submit_dh_shared_secret(st, st, st->st_gi, main_inI2_outR2_continue2, HERE);
	
	dbg("#%lu %s:%u st->st_calculating = false;", st->st_serialno, __func__, __LINE__);
	st->st_offloaded_task_in_background = true;

	return STF_OK;
}



static dh_shared_secret_cb main_inR2_outI3_continue;	

stf_status main_inR2_outI3(struct state *st, struct msg_digest *md)
{
	
	release_symkey(__func__, "DH shared secret", &st->st_dh_shared_secret);
	release_symkey(__func__, "skeyid", &st->st_skeyid_nss);
	release_symkey(__func__, "skeyid_d", &st->st_skeyid_d_nss);
	release_symkey(__func__, "skeyid_a", &st->st_skeyid_a_nss);
	release_symkey(__func__, "skeyid_e", &st->st_skeyid_e_nss);
	release_symkey(__func__, "enc_key", &st->st_enc_key_nss);

	
	if (!unpack_KE(&st->st_gr, "Gr", st->st_oakley.ta_dh, md->chain[ISAKMP_NEXT_KE], st->st_logger)) {
		return STF_FAIL_v1N + v1N_INVALID_KEY_INFORMATION;
	}

	
	RETURN_STF_FAIL_v1NURE(accept_v1_nonce(st->st_logger, md, &st->st_nr, "Nr"));
	submit_dh_shared_secret(st, st, st->st_gr, main_inR2_outI3_continue, HERE);
	return STF_SUSPEND;
}

static stf_status main_inR2_outI3_continue(struct state *st, struct msg_digest *md)
{
	dbg("main_inR2_outI3_continue for #%lu: calculated DH, sending R1", st->st_serialno);

	passert(md != NULL);	

	if (st->st_dh_shared_secret == NULL) {
		return STF_FAIL_v1N + v1N_INVALID_KEY_INFORMATION;
	}

	calc_v1_skeyid_and_iv(st);

	struct pbs_out rbody[1]; 
	ikev1_init_pbs_out_from_md_hdr(md, true, &reply_stream, reply_buffer, sizeof(reply_buffer), rbody, st->st_logger);


	const struct connection *c = st->st_connection;
	const struct cert *mycert = c->local->config->host.cert.nss_cert != NULL ? &c->local->config->host.cert : NULL;

	
	decode_v1_certificate_requests(st, md);
	bool cert_requested = (st->st_v1_requested_ca != NULL);

	
	bool send_cert = (st->st_oakley.auth == OAKLEY_RSA_SIG && mycert != NULL && ((c->local->config->host.sendcert == CERT_SENDIFASKED && cert_requested) || (c->local->config->host.sendcert == CERT_ALWAYSSEND)));


	bool send_authcerts = (send_cert && c->send_ca != CA_SEND_NONE);

	

	chunk_t auth_chain[MAX_CA_PATH_LEN] = { { NULL, 0 } };
	int chain_len = 0;

	if (send_authcerts) {
		chain_len = get_auth_chain(auth_chain, MAX_CA_PATH_LEN, mycert, c->send_ca == CA_SEND_ALL);
		if (chain_len == 0)
			send_authcerts = false;
	}

	doi_log_cert_thinking(st->st_oakley.auth, cert_ike_type(mycert), c->local->config->host.sendcert, cert_requested, send_cert, send_authcerts);


	
	bool send_cr = send_cert && !remote_has_preloaded_pubkey(st);

	dbg(" I am %ssending a certificate request", send_cr ? "" : "not ");

	
	bool initial_contact = c->config->send_initial_contact;
	dbg("I will %ssend an initial contact payload", initial_contact ? "" : "NOT ");

	

	ikev1_natd_init(st, md);

	

	

	
	pb_stream id_pbs; 
	enum next_payload_types_ikev1 auth_payload = st->st_oakley.auth == OAKLEY_PRESHARED_KEY ? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;


	{
		
		shunk_t id_b;
		struct isakmp_ipsec_id id_hd = build_v1_id_payload(&c->spd.this, &id_b);
		if (!out_struct(&id_hd, &isakmp_ipsec_identification_desc, rbody, &id_pbs) || !out_hunk(id_b, &id_pbs, "my identity")) {



			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}

		close_output_pbs(&id_pbs);
	}

	
	if (send_cert && impair.send_pkcs7_thingie) {
		log_state(RC_LOG, st, "IMPAIR: sending cert as pkcs7 blob");
		SECItem *pkcs7 = nss_pkcs7_blob(mycert, send_authcerts);
		if (!pexpect(pkcs7 != NULL)) {
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}
		if (!ikev1_ship_CERT(CERT_PKCS7_WRAPPED_X509, same_secitem_as_shunk(*pkcs7), rbody)) {

			SECITEM_FreeItem(pkcs7, PR_TRUE);
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}
	} else if (send_cert) {
		log_state(RC_LOG, st, "I am sending my cert");

		if (!ikev1_ship_CERT(cert_ike_type(mycert), cert_der(mycert), rbody)) {
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}

		if (send_authcerts) {
			
			log_state(RC_LOG, st, "I am sending a CA cert chain");
			if (!ikev1_ship_chain(auth_chain, chain_len, rbody, cert_ike_type(mycert))) {


				free_auth_chain(auth_chain, chain_len);
				return STF_INTERNAL_ERROR;
			}
		}
	}

	free_auth_chain(auth_chain, chain_len);

	

	
	if (send_cr) {
		log_state(RC_LOG, st, "I am sending a certificate request");
		if (!ikev1_build_and_ship_CR(cert_ike_type(mycert), c->remote->config->host.ca, rbody))

			return STF_INTERNAL_ERROR;
	}

	
	{
		struct crypt_mac hash = main_mode_hash(st, SA_INITIATOR, &id_pbs);

		if (auth_payload == ISAKMP_NEXT_HASH) {
			
			if (!ikev1_out_generic_raw(&isakmp_hash_desc, rbody, hash.ptr, hash.len, "HASH_I"))

				return STF_INTERNAL_ERROR;
		} else {
			
			struct hash_signature sig;
			sig = v1_sign_hash_RSA(c, &hash, st->st_logger);
			if (sig.len == 0) {
				
				return STF_FAIL_v1N + v1N_AUTHENTICATION_FAILED;
			}

			if (!ikev1_out_generic_raw(&isakmp_signature_desc, rbody, sig.ptr, sig.len, "SIG_I"))


				return STF_INTERNAL_ERROR;
		}
	}

	
	if (initial_contact) {
		pb_stream notify_pbs;
		struct isakmp_notification isan = {
			.isan_doi = ISAKMP_DOI_IPSEC, .isan_protoid = PROTO_ISAKMP, .isan_spisize = COOKIE_SIZE * 2, .isan_type = v1N_IPSEC_INITIAL_CONTACT, };




		log_state(RC_LOG, st, "sending INITIAL_CONTACT");

		if (!out_struct(&isan, &isakmp_notification_desc, rbody, &notify_pbs) || !out_raw(st->st_ike_spis.initiator.bytes, COOKIE_SIZE, &notify_pbs, "notify icookie") || !out_raw(st->st_ike_spis.responder.bytes, COOKIE_SIZE, &notify_pbs, "notify rcookie"))




			return STF_INTERNAL_ERROR;

		
		close_output_pbs(&notify_pbs);
	} else {
		dbg("Not sending INITIAL_CONTACT");
	}

	

	
	if (!ikev1_encrypt_message(rbody, st))
		return STF_INTERNAL_ERROR; 

	return STF_OK;
}



stf_status main_inI3_outR3(struct state *st, struct msg_digest *md)
{
	pexpect(st == md->v1_st);
	st = md->v1_st;

	
	if (st->st_dh_shared_secret == NULL)
		return STF_FAIL_v1N + v1N_INVALID_KEY_INFORMATION;

	if (!v1_decode_certs(md)) {
		log_state(RC_LOG, st, "X509: CERT payload bogus or revoked");
		return STF_FAIL_v1N + v1N_INVALID_ID_INFORMATION;
	}

	

	if (!ikev1_decode_peer_id_main_mode_responder(st, md)) {
		dbg("Peer ID failed to decode");
		return STF_FAIL_v1N + v1N_INVALID_ID_INFORMATION;
	}

	

	stf_status r = oakley_auth(md, false);
	if (r != STF_OK) {
		return r;
	}

	struct connection *c = st->st_connection; 

	
	const struct cert *mycert = c->local->config->host.cert.nss_cert != NULL ? &c->local->config->host.cert : NULL;

	pexpect(st->st_clonedfrom == SOS_NOBODY); 
	bool cert_requested = (st->st_v1_requested_ca != NULL);
	bool send_cert = (st->st_oakley.auth == OAKLEY_RSA_SIG && mycert != NULL && ((c->local->config->host.sendcert == CERT_SENDIFASKED && cert_requested) || (c->local->config->host.sendcert == CERT_ALWAYSSEND)));


	bool send_authcerts = (send_cert && c->send_ca != CA_SEND_NONE);

	

	chunk_t auth_chain[MAX_CA_PATH_LEN] = { { NULL, 0 } };
	int chain_len = 0;

	if (send_authcerts) {
		chain_len = get_auth_chain(auth_chain, MAX_CA_PATH_LEN, mycert, c->send_ca == CA_SEND_ALL);
		if (chain_len == 0)
			send_authcerts = false;
	}

	doi_log_cert_thinking(st->st_oakley.auth, cert_ike_type(mycert), c->local->config->host.sendcert, cert_requested, send_cert, send_authcerts);


	

	
	struct pbs_out rbody;
	ikev1_init_pbs_out_from_md_hdr(md, true, &reply_stream, reply_buffer, sizeof(reply_buffer), &rbody, st->st_logger);


	enum next_payload_types_ikev1 auth_payload = st->st_oakley.auth == OAKLEY_PRESHARED_KEY ? ISAKMP_NEXT_HASH : ISAKMP_NEXT_SIG;

	
	pb_stream r_id_pbs; 

	{
		
		shunk_t id_b;
		struct isakmp_ipsec_id id_hd = build_v1_id_payload(&c->spd.this, &id_b);
		if (!out_struct(&id_hd, &isakmp_ipsec_identification_desc, &rbody, &r_id_pbs) || !out_hunk(id_b, &r_id_pbs, "my identity")) {

			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}

		close_output_pbs(&r_id_pbs);
	}

	
	if (send_cert && impair.send_pkcs7_thingie) {
		log_state(RC_LOG, st, "IMPAIR: sending cert as pkcs7 blob");
		SECItem *pkcs7 = nss_pkcs7_blob(mycert, send_authcerts);
		if (!pexpect(pkcs7 != NULL)) {
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}
		if (!ikev1_ship_CERT(CERT_PKCS7_WRAPPED_X509, same_secitem_as_shunk(*pkcs7), &rbody)) {

			SECITEM_FreeItem(pkcs7, PR_TRUE);
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}
	} else if (send_cert) {
		log_state(RC_LOG, st, "I am sending my cert");
		if (!ikev1_ship_CERT(cert_ike_type(mycert), cert_der(mycert), &rbody)) {
			free_auth_chain(auth_chain, chain_len);
			return STF_INTERNAL_ERROR;
		}

		if (send_authcerts) {
			log_state(RC_LOG, st, "I am sending a CA cert chain");
			if (!ikev1_ship_chain(auth_chain, chain_len, &rbody, cert_ike_type(mycert))) {
				free_auth_chain(auth_chain, chain_len);
				return STF_INTERNAL_ERROR;
			}
		}
	}

	free_auth_chain(auth_chain, chain_len);

	

	

	
	{
		struct crypt_mac hash = main_mode_hash(st, SA_RESPONDER, &r_id_pbs);

		if (auth_payload == ISAKMP_NEXT_HASH) {
			
			if (!ikev1_out_generic_raw(&isakmp_hash_desc, &rbody, hash.ptr, hash.len, "HASH_R"))
				return STF_INTERNAL_ERROR;
		} else {
			
			struct hash_signature sig;
			sig = v1_sign_hash_RSA(c, &hash, st->st_logger);
			if (sig.len == 0) {
				
				return STF_FAIL_v1N + v1N_AUTHENTICATION_FAILED;
			}

			if (!ikev1_out_generic_raw(&isakmp_signature_desc, &rbody, sig.ptr, sig.len, "SIG_R"))

				return STF_INTERNAL_ERROR;
		}
	}

	

	if (!ikev1_encrypt_message(&rbody, st))
		return STF_INTERNAL_ERROR; 

	
	if (DBGP(DBG_CRYPT)) {
		DBG_dump_hunk("last encrypted block of Phase 1:", st->st_v1_new_iv);
	}

	set_ph1_iv_from_new(st);

	

	if (c->remotepeertype == CISCO && c->newest_ike_sa != SOS_NOBODY && c->local->config->host.xauth.client) {

		dbg("Skipping XAUTH for rekey for Cisco Peer compatibility.");
		st->hidden_variables.st_xauth_client_done = true;
		st->st_oakley.doing_xauth = false;

		if (c->spd.this.modecfg_client) {
			dbg("Skipping ModeCFG for rekey for Cisco Peer compatibility.");
			st->hidden_variables.st_modecfg_vars_set = true;
			st->hidden_variables.st_modecfg_started = true;
		}
	}

	ISAKMP_SA_established(pexpect_ike_sa(st));

	if (c->xfrmi != NULL && c->xfrmi->if_id != 0)
		if (add_xfrmi(c, st->st_logger))
			return STF_FATAL;

	linux_audit_conn(st, LAK_PARENT_START);
	return STF_OK;
}



stf_status main_inR3(struct state *st, struct msg_digest *md)
{
	if (!v1_decode_certs(md)) {
		log_state(RC_LOG, st, "X509: CERT payload bogus or revoked");
		return STF_FAIL_v1N + v1N_INVALID_ID_INFORMATION;
	}

	

	struct connection *c = st->st_connection;

	if (!ikev1_decode_peer_id_initiator(st, md)) {
		dbg("Peer ID failed to decode");
		return STF_FAIL_v1N + v1N_INVALID_ID_INFORMATION;
	}

	passert(c == st->st_connection); 

	

	stf_status r = oakley_auth(md, true);
	if (r != STF_OK) {
		return r;
	}

	

	
	if (c->remotepeertype == CISCO && c->newest_ike_sa != SOS_NOBODY && c->local->config->host.xauth.client) {

		dbg("Skipping XAUTH for rekey for Cisco Peer compatibility.");
		st->hidden_variables.st_xauth_client_done = true;
		st->st_oakley.doing_xauth = false;

		if (c->spd.this.modecfg_client) {
			dbg("Skipping ModeCFG for rekey for Cisco Peer compatibility.");
			st->hidden_variables.st_modecfg_vars_set = true;
			st->hidden_variables.st_modecfg_started = true;
		}
	}

	ISAKMP_SA_established(pexpect_ike_sa(st));

	if (c->xfrmi != NULL && c->xfrmi->if_id != 0)
		if (add_xfrmi(c, st->st_logger))
			return STF_FATAL;

	linux_audit_conn(st, LAK_PARENT_START);

	passert((st->st_policy & POLICY_PFS) == 0 || st->st_pfs_group != NULL);

	
	set_ph1_iv_from_new(st);

	update_iv(st); 

	return STF_OK;
}

stf_status send_isakmp_notification(struct state *st, uint16_t type, const void *data, size_t len)

{
	msgid_t msgid;
	pb_stream rbody;

	msgid = generate_msgid(st);

	reply_stream = open_pbs_out("reply packet", reply_buffer, sizeof(reply_buffer), st->st_logger);

	
	{
		struct isakmp_hdr hdr = {
			.isa_version = ISAKMP_MAJOR_VERSION << ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION, .isa_xchg = ISAKMP_XCHG_INFO, .isa_flags = ISAKMP_FLAGS_v1_ENCRYPTION, .isa_msgid = msgid, };




		hdr.isa_ike_initiator_spi = st->st_ike_spis.initiator;
		hdr.isa_ike_responder_spi = st->st_ike_spis.responder;
		if (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream, &rbody))
			return STF_INTERNAL_ERROR;
	}

	struct v1_hash_fixup hash_fixup;
	if (!emit_v1_HASH(V1_HASH_1, "notification", IMPAIR_v1_NOTIFICATION_EXCHANGE, st, &hash_fixup, &rbody)) {

		return STF_INTERNAL_ERROR;
	}

	
	{
		pb_stream notify_pbs;
		struct isakmp_notification isan = {
			.isan_doi = ISAKMP_DOI_IPSEC, .isan_protoid = PROTO_ISAKMP, .isan_spisize = COOKIE_SIZE * 2, .isan_type = type, };



		if (!out_struct(&isan, &isakmp_notification_desc, &rbody, &notify_pbs) || !out_raw(st->st_ike_spis.initiator.bytes, COOKIE_SIZE, &notify_pbs, "notify icookie") || !out_raw(st->st_ike_spis.responder.bytes, COOKIE_SIZE, &notify_pbs, "notify rcookie"))




			return STF_INTERNAL_ERROR;

		if (data != NULL && len > 0)
			if (!out_raw(data, len, &notify_pbs, "notify data"))
				return STF_INTERNAL_ERROR;

		close_output_pbs(&notify_pbs);
	}

	fixup_v1_HASH(st, &hash_fixup, msgid, rbody.cur);

	
	{
		struct crypt_mac old_new_iv;
		struct crypt_mac old_iv;

		save_iv(st, old_iv);
		save_new_iv(st, old_new_iv);

		init_phase2_iv(st, &msgid);
		if (!ikev1_encrypt_message(&rbody, st))
			return STF_INTERNAL_ERROR;

		send_pbs_out_using_state(st, "ISAKMP notify", &reply_stream);

		
		restore_iv(st, old_iv);
		restore_new_iv(st, old_new_iv);
	}

	return STF_IGNORE;
}


static monotime_t last_malformed = MONOTIME_EPOCH;

static void send_v1_notification(struct logger *logger, struct state *sndst , v1_notification_t type, struct state *encst, msgid_t msgid, uint8_t *icookie, uint8_t *rcookie, uint8_t protoid)




{
	pb_stream r_hdr_pbs;
	const monotime_t now = mononow();

	switch (type) {
	case v1N_PAYLOAD_MALFORMED:
		
		
		if (monobefore(last_malformed, now))
			return;

		last_malformed = now;

		
		sndst->hidden_variables.st_malformed_sent++;
		if (sndst->hidden_variables.st_malformed_sent > MAXIMUM_MALFORMED_NOTIFY) {
			llog(RC_LOG, logger, "too many (%d) malformed payloads. Deleting state", sndst->hidden_variables.st_malformed_sent);
			delete_state(sndst);
			
			return;
		}

		if (sndst->st_v1_iv.len != 0) {
			LLOG_JAMBUF(RC_LOG, logger, buf) {
				jam(buf, "payload malformed.  IV: ");
				jam_dump_bytes(buf, sndst->st_v1_iv.ptr, sndst->st_v1_iv.len);
			}
		}

		
		encst = NULL;
		break;

	case v1N_INVALID_FLAGS:
		
		encst = NULL;
		break;
	default:
		
		break;
	}

	if (encst != NULL && !IS_V1_ISAKMP_ENCRYPTED(encst->st_state->kind))
		encst = NULL;

	{
		
		endpoint_buf b;
		enum_buf nb;
		llog(RC_NOTIFICATION + type, logger, "sending %snotification %s to %s", encst ? "encrypted " : "", str_enum_short(&v1_notification_names, type, &nb), str_endpoint(&sndst->st_remote_endpoint, &b));



	}

	uint8_t buffer[1024];	
	struct pbs_out pbs = open_pbs_out("notification msg", buffer, sizeof(buffer), logger);

	
	{
		
		struct isakmp_hdr hdr = {
			.isa_version = ISAKMP_MAJOR_VERSION << ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION, .isa_xchg = ISAKMP_XCHG_INFO, .isa_msgid = msgid, .isa_flags = encst ? ISAKMP_FLAGS_v1_ENCRYPTION : 0, };




		if (icookie != NULL)
			memcpy(hdr.isa_ike_initiator_spi.bytes, icookie, COOKIE_SIZE);
		if (rcookie != NULL)
			memcpy(hdr.isa_ike_responder_spi.bytes, rcookie, COOKIE_SIZE);
		passert(out_struct(&hdr, &isakmp_hdr_desc, &pbs, &r_hdr_pbs));
	}

	
	struct v1_hash_fixup hash_fixup;
	if (encst != NULL) {
		if (!emit_v1_HASH(V1_HASH_1, "send notification", IMPAIR_v1_NOTIFICATION_EXCHANGE, encst, &hash_fixup, &r_hdr_pbs)) {

			
			return;
		}
	}

	
	{
		pb_stream not_pbs;
		struct isakmp_notification isan = {
			.isan_doi = ISAKMP_DOI_IPSEC, .isan_type = type, .isan_spisize = 0, .isan_protoid = protoid, };




		if (!out_struct(&isan, &isakmp_notification_desc, &r_hdr_pbs, &not_pbs)) {
			llog(RC_LOG, logger, "failed to build notification in send_notification");
			return;
		}

		close_output_pbs(&not_pbs);
	}

	
	if (encst != NULL) {
		fixup_v1_HASH(encst, &hash_fixup, msgid, r_hdr_pbs.cur);
	}

	if (encst != NULL) {
		
		
		struct crypt_mac old_iv;

		save_iv(encst, old_iv);

		if (!IS_V1_ISAKMP_SA_ESTABLISHED(encst)) {
			update_iv(encst);
		}
		init_phase2_iv(encst, &msgid);
		passert(ikev1_encrypt_message(&r_hdr_pbs, encst));

		restore_iv(encst, old_iv);
	} else {
		close_output_pbs(&r_hdr_pbs);
	}

	send_pbs_out_using_state(sndst, "notification packet", &pbs);
}

void send_v1_notification_from_state(struct state *st, enum state_kind from_state, v1_notification_t type)
{
	struct state *p1st;

	passert(st != NULL);

	if (from_state == STATE_UNDEFINED)
		from_state = st->st_state->kind;

	if (IS_V1_QUICK(from_state)) {
		p1st = find_phase1_state(st->st_connection, V1_ISAKMP_SA_ESTABLISHED_STATES);
		if ((p1st == NULL) || (!IS_V1_ISAKMP_SA_ESTABLISHED(p1st))) {
			log_state(RC_LOG_SERIOUS, st, "no Phase1 state for Quick mode notification");
			return;
		}
		send_v1_notification(st->st_logger, st, type, p1st, generate_msgid(p1st), st->st_ike_spis.initiator.bytes, st->st_ike_spis.responder.bytes, PROTO_ISAKMP);


	} else if (IS_V1_ISAKMP_ENCRYPTED(from_state)) {
		send_v1_notification(st->st_logger, st, type, st, generate_msgid(st), st->st_ike_spis.initiator.bytes, st->st_ike_spis.responder.bytes, PROTO_ISAKMP);


	} else {
		
		send_v1_notification(st->st_logger, st, type, NULL, v1_MAINMODE_MSGID, st->st_ike_spis.initiator.bytes, st->st_ike_spis.responder.bytes, PROTO_ISAKMP);


	}
}

void send_v1_notification_from_md(struct msg_digest *md, v1_notification_t type)
{
	pb_stream r_hdr_pbs;
	monotime_t n = mononow();

	switch (type) {
	case v1N_PAYLOAD_MALFORMED:
		
		
		if (monobefore(last_malformed, n))
			return;
		last_malformed = n;
		break;

	case v1N_INVALID_FLAGS:
		break;

	default:
		
		break;
	}

	endpoint_buf b;
	enum_buf nb;
	llog(RC_NOTIFICATION + type, md->md_logger, "sending notification %s to %s", str_enum_short(&v1_notification_names, type, &nb), str_endpoint(&md->sender, &b));



	uint8_t buffer[1024];	
	struct pbs_out pbs = open_pbs_out("notification msg", buffer, sizeof(buffer), md->md_logger);


	

	{
		
		struct isakmp_hdr hdr = {
			.isa_version = ISAKMP_MAJOR_VERSION << ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION, .isa_xchg = ISAKMP_XCHG_INFO, .isa_msgid = 0, .isa_flags = 0, .isa_ike_initiator_spi = md->hdr.isa_ike_initiator_spi, .isa_ike_responder_spi = md->hdr.isa_ike_responder_spi, };






		passert(out_struct(&hdr, &isakmp_hdr_desc, &pbs, &r_hdr_pbs));
	}

	

	{
		pb_stream not_pbs;
		struct isakmp_notification isan = {
			.isan_doi = ISAKMP_DOI_IPSEC, .isan_type = type, .isan_spisize = 0, .isan_protoid = PROTO_ISAKMP, };




		if (!out_struct(&isan, &isakmp_notification_desc, &r_hdr_pbs, &not_pbs)) {
			llog(RC_LOG, md->md_logger, "failed to build notification in send_notification");
			return;
		}

		close_output_pbs(&not_pbs);
	}

	close_output_pbs(&r_hdr_pbs);
	send_pbs_out_using_md(md, "notification packet", &pbs);
}


void send_v1_delete(struct state *st)
{
	pb_stream r_hdr_pbs;
	msgid_t msgid;
	struct state *p1st;
	ip_said said[EM_MAXRELSPIS];
	ip_said *ns = said;
	bool isakmp_sa = false;

	
	if (IS_IPSEC_SA_ESTABLISHED(st)) {
		
		p1st = find_phase1_state(st->st_connection, V1_ISAKMP_SA_ESTABLISHED_STATES);
		if (p1st == NULL) {
			dbg("no Phase 1 state for Delete");
			return;
		}

		if (st->st_ah.present) {
			*ns = said_from_address_protocol_spi(st->st_connection->local->host.addr, &ip_protocol_ah, st->st_ah.inbound.spi);

			ns++;
		}
		if (st->st_esp.present) {
			*ns = said_from_address_protocol_spi(st->st_connection->local->host.addr, &ip_protocol_esp, st->st_esp.inbound.spi);

			ns++;
		}

		passert(ns != said); 
	} else if (IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
		
		p1st = st;
		isakmp_sa = true;
	} else {
		return; 
	}

	msgid = generate_msgid(p1st);

	uint8_t buffer[8192];	
	struct pbs_out reply_pbs = open_pbs_out("delete msg", buffer, sizeof(buffer), st->st_logger);

	
	{
		struct isakmp_hdr hdr = {
			.isa_version = ISAKMP_MAJOR_VERSION << ISA_MAJ_SHIFT | ISAKMP_MINOR_VERSION, .isa_xchg = ISAKMP_XCHG_INFO, .isa_msgid = msgid, .isa_flags = ISAKMP_FLAGS_v1_ENCRYPTION, };




		hdr.isa_ike_initiator_spi = p1st->st_ike_spis.initiator;
		hdr.isa_ike_responder_spi = p1st->st_ike_spis.responder;
		passert(out_struct(&hdr, &isakmp_hdr_desc, &reply_pbs, &r_hdr_pbs));
	}

	
	struct v1_hash_fixup hash_fixup;
	if (!emit_v1_HASH(V1_HASH_1, "send delete", IMPAIR_v1_DELETE_EXCHANGE, p1st, &hash_fixup, &r_hdr_pbs)) {

		return ;
	}

	
	if (isakmp_sa) {
		struct isakmp_delete isad = {
			.isad_doi = ISAKMP_DOI_IPSEC, .isad_spisize = 2 * COOKIE_SIZE, .isad_protoid = PROTO_ISAKMP, .isad_nospi = 1, };




		pb_stream del_pbs;
		switch (impair.v1_isakmp_delete_payload) {
		case IMPAIR_EMIT_NO:
			passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
			passert(out_raw(st->st_ike_spis.initiator.bytes, COOKIE_SIZE, &del_pbs, "initiator SPI"));
			passert(out_raw(st->st_ike_spis.responder.bytes, COOKIE_SIZE, &del_pbs, "responder SPI"));
			close_output_pbs(&del_pbs);
			break;
		case IMPAIR_EMIT_OMIT:
			llog(RC_LOG, st->st_logger, "IMPAIR: omitting ISKMP delete payload");
			break;
		case IMPAIR_EMIT_EMPTY:
			passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
			llog(RC_LOG, st->st_logger, "IMPAIR: emitting empty (i.e., no SPI) ISKMP delete payload");
			close_output_pbs(&del_pbs);
			break;
		case IMPAIR_EMIT_DUPLICATE:
			llog(RC_LOG, st->st_logger, "IMPAIR: emitting duplicate ISKMP delete payloads");
			for (unsigned nr = 0; nr < 2; nr++) {
				passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
				passert(out_raw(st->st_ike_spis.initiator.bytes, COOKIE_SIZE, &del_pbs, "initiator SPI"));
				passert(out_raw(st->st_ike_spis.responder.bytes, COOKIE_SIZE, &del_pbs, "responder SPI"));
				close_output_pbs(&del_pbs);
			}
			break;
		case IMPAIR_EMIT_ROOF:
			bad_case(impair.v1_ipsec_delete_payload);

		}

	} else {
		while (ns != said) {
			ns--;
			const struct ip_protocol *proto = said_protocol(*ns);
			struct isakmp_delete isad = {
				.isad_doi = ISAKMP_DOI_IPSEC, .isad_spisize = sizeof(ipsec_spi_t), .isad_protoid = proto->ikev1_protocol_id, .isad_nospi = 1, };




			pb_stream del_pbs;
			switch (impair.v1_ipsec_delete_payload) {
			case IMPAIR_EMIT_NO:
				passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
				passert(out_raw(&ns->spi, sizeof(ipsec_spi_t), &del_pbs, "delete payload"));
				close_output_pbs(&del_pbs);
				break;
			case IMPAIR_EMIT_OMIT:
				llog(RC_LOG, st->st_logger, "IMPAIR: omitting IPsec delete payload");
				break;
			case IMPAIR_EMIT_EMPTY:
				passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
				llog(RC_LOG, st->st_logger, "IMPAIR: emitting empty (i.e., no SPI) IPsec delete payload");
				close_output_pbs(&del_pbs);
				break;
			case IMPAIR_EMIT_DUPLICATE:
				llog(RC_LOG, st->st_logger, "IMPAIR: emitting duplicte IPsec delete payloads");
				for (unsigned nr = 0; nr < 2; nr++) {
					passert(out_struct(&isad, &isakmp_delete_desc, &r_hdr_pbs, &del_pbs));
					passert(out_raw(&ns->spi, sizeof(ipsec_spi_t), &del_pbs, "delete payload"));
					close_output_pbs(&del_pbs);
				}
				break;
			case IMPAIR_EMIT_ROOF:
				bad_case(impair.v1_ipsec_delete_payload);
			}

			if (impair.ikev1_del_with_notify) {
				pb_stream cruft_pbs;

				log_state(RC_LOG, st, "IMPAIR: adding bogus Notify payload after IKE Delete payload");
				struct isakmp_notification isan = {
					.isan_doi = ISAKMP_DOI_IPSEC, .isan_protoid = PROTO_ISAKMP, .isan_spisize = COOKIE_SIZE * 2, .isan_type = v1N_INVALID_PAYLOAD_TYPE, };




				passert(out_struct(&isan, &isakmp_notification_desc, &r_hdr_pbs, &cruft_pbs));
				passert(out_raw(&ns->spi, sizeof(ipsec_spi_t), &cruft_pbs, "notify payload"));
				close_output_pbs(&cruft_pbs);
			}
		}
	}

	
	fixup_v1_HASH(p1st, &hash_fixup, msgid, r_hdr_pbs.cur);

	
	{
		struct crypt_mac old_iv;

		save_iv(p1st, old_iv);
		init_phase2_iv(p1st, &msgid);

		passert(ikev1_encrypt_message(&r_hdr_pbs, p1st));

		send_pbs_out_using_state(p1st, "delete notify", &reply_pbs);

		
		restore_iv(p1st, old_iv);
	}
}


bool accept_delete(struct msg_digest *md, struct payload_digest *p)
{
	struct state *st = md->v1_st;
	struct isakmp_delete *d = &(p->payload.delete);
	size_t sizespi;
	int i;
	bool self_delete = false;

	
	if (!md->encrypted) {
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: not encrypted");
		return false;
	}

	
	if (!IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
		
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: ISAKMP SA not established");
		return false;
	}

	if (d->isad_nospi == 0) {
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: no SPI");
		return false;
	}

	switch (d->isad_protoid) {
	case PROTO_ISAKMP:
		sizespi = 2 * COOKIE_SIZE;
		break;

	case PROTO_IPSEC_AH:
	case PROTO_IPSEC_ESP:
		sizespi = sizeof(ipsec_spi_t);
		break;

	case PROTO_IPCOMP:
		
		return false;

	default:
	{
		esb_buf b;
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: unknown Protocol ID (%s)", enum_show(&ikev1_protocol_names, d->isad_protoid, &b));

		return false;
	}
	}

	if (d->isad_spisize != sizespi) {
		esb_buf b;
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: bad SPI size (%d) for %s", d->isad_spisize, enum_show(&ikev1_protocol_names, d->isad_protoid, &b));


		return false;
	}

	if (pbs_left(&p->pbs) != d->isad_nospi * sizespi) {
		log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: invalid payload size");
		return false;
	}

	for (i = 0; i < d->isad_nospi; i++) {
		if (d->isad_protoid == PROTO_ISAKMP) {
			
			ike_spis_t cookies;
			diag_t d;

			d = pbs_in_raw(&p->pbs, &cookies.initiator, COOKIE_SIZE, "iCookie");
			if (d != NULL) {
				llog_diag(RC_LOG, st->st_logger, &d, "%s", "");
				return false;
			}

			d = pbs_in_raw(&p->pbs, &cookies.responder, COOKIE_SIZE, "rCookie");
			if (d != NULL) {
				llog_diag(RC_LOG, st->st_logger, &d, "%s", "");
				return false;
			}

			struct state *dst = find_state_ikev1(&cookies, v1_MAINMODE_MSGID);

			if (dst == NULL) {
				log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: ISAKMP SA not found (maybe expired)");
			} else if (!same_peer_ids(st->st_connection, dst->st_connection, NULL)) {

				
				log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: ISAKMP SA used to convey Delete has different IDs from ISAKMP SA it deletes");
			} else if (dst == st) {
				
				self_delete = true;
			} else {
				
				log_state(RC_LOG_SERIOUS, st, "received Delete SA payload: deleting ISAKMP State #%lu", dst->st_serialno);
				if (nat_traversal_enabled && dst->st_connection->ikev1_natt != NATT_NONE) {
					nat_traversal_change_port_lookup(md, dst);
					v1_maybe_natify_initiator_endpoints(st, HERE);
			}
				delete_state(dst);
			}
		} else {
			
			ipsec_spi_t spi;	
			diag_t dt = pbs_in_raw(&p->pbs, &spi, sizeof(spi), "SPI");
			if (dt != NULL) {
				llog_diag(RC_LOG, st->st_logger, &dt, "%s", "");
				return false;
			}

			bool bogus;
			struct state *dst = find_phase2_state_to_delete(st, d->isad_protoid, spi, &bogus);



			passert(dst != st);	
			if (dst == NULL) {
				esb_buf b;
				log_state(RC_LOG_SERIOUS, st, "ignoring Delete SA payload: %s SA(0x%08" PRIx32 ") not found (maybe expired)", enum_show(&ikev1_protocol_names, d->isad_protoid, &b), ntohl(spi));


			} else {
				if (bogus) {
					esb_buf b;
					log_state(RC_LOG_SERIOUS, st, "warning: Delete SA payload: %s SA(0x%08" PRIx32 ") is our own SPI (bogus implementation) - deleting anyway", enum_show(&ikev1_protocol_names, d->isad_protoid, &b), ntohl(spi));


				}

				
				co_serial_t rc_serialno = dst->st_connection->serialno;

				if (nat_traversal_enabled && dst->st_connection->ikev1_natt != NATT_NONE) {
					nat_traversal_change_port_lookup(md, dst);
					v1_maybe_natify_initiator_endpoints(st, HERE);
				}

				if (dst->st_connection->newest_ipsec_sa == dst->st_serialno && (dst->st_connection->policy & POLICY_UP)) {
					
					log_state(RC_LOG_SERIOUS, st, "received Delete SA payload: replace IPsec State #%lu now", dst->st_serialno);

					dst->st_replace_margin = deltatime(0);
					event_force(EVENT_SA_REPLACE, dst);
				} else {
					log_state(RC_LOG_SERIOUS, st, "received Delete SA(0x%08" PRIx32 ") payload: deleting IPsec State #%lu", ntohl(spi), dst->st_serialno);


					delete_state(dst);
					if (md->v1_st == dst)
						md->v1_st = NULL;
				}

				
				struct connection *rc = connection_by_serialno(rc_serialno);
				if (rc != NULL && rc->newest_ipsec_sa == SOS_NOBODY) {
					dbg("%s() connection '%s' -POLICY_UP", __func__, rc->name);
					rc->policy &= ~POLICY_UP;
					if (!shared_phase1_connection(rc)) {
						flush_pending_by_connection(rc);
						
						delete_states_by_connection(&rc);
						md->v1_st = NULL;
					}
				}
			}
		}
	}

	return self_delete;
}


void accept_self_delete(struct msg_digest *md)
{
	struct state *st = md->v1_st;

	
	log_state(RC_LOG_SERIOUS, st, "received Delete SA payload: self-deleting ISAKMP State #%lu", st->st_serialno);
	if (nat_traversal_enabled && st->st_connection->ikev1_natt != NATT_NONE) {
		nat_traversal_change_port_lookup(md, st);
		v1_maybe_natify_initiator_endpoints(st, HERE);
	}
	delete_state(st);
	md->v1_st = st = NULL;
}
