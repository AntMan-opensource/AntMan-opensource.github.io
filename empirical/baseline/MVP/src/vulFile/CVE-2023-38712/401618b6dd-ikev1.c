




































































struct state_v1_microcode {
	enum state_kind state, next_state;
	lset_t flags;
	lset_t req_payloads;    
	lset_t opt_payloads;    
	enum event_type timeout_event;
	ikev1_state_transition_fn *processor;
	const char *message;
	enum v1_hash_type hash_type;
};

void jam_v1_transition(struct jambuf *buf, const struct state_v1_microcode *transition)
{
	if (transition == NULL) {
		jam(buf, "NULL");
	} else {
		jam(buf, "%s->%s", finite_states[transition->state]->short_name, finite_states[transition->next_state]->short_name);

	}
}






























static ikev1_state_transition_fn unexpected;      
static ikev1_state_transition_fn informational;      



static const struct state_v1_microcode v1_state_microcode_table[] = {




	

	

	
	{ STATE_MAIN_R0, STATE_MAIN_R1, SMF_ALL_AUTH | SMF_REPLY, P(SA), P(VID) | P(CR), EVENT_SA_DISCARD, FM(main_inI1_outR1), .hash_type = V1_HASH_NONE, },   { STATE_MAIN_I1, STATE_MAIN_I2, SMF_ALL_AUTH | SMF_INITIATOR | SMF_REPLY, P(SA), P(VID) | P(CR), EVENT_RETRANSMIT, FM(main_inR1_outI2), .hash_type = V1_HASH_NONE, },   { STATE_MAIN_R1, STATE_MAIN_R2, SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE, P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), EVENT_RETRANSMIT, FM(main_inI2_outR2), .hash_type = V1_HASH_NONE, },  { STATE_MAIN_R1, STATE_UNDEFINED, SMF_PKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE, P(KE) | P(ID) | P(NONCE), P(VID) | P(CR) | P(HASH), EVENT_RETRANSMIT, FM(unexpected) , .hash_type = V1_HASH_NONE, },  { STATE_MAIN_R1, STATE_UNDEFINED, SMF_RPKE_AUTH | SMF_REPLY | SMF_RETRANSMIT_ON_DUPLICATE, P(NONCE) | P(KE) | P(ID), P(VID) | P(CR) | P(HASH) | P(CERT), EVENT_RETRANSMIT, FM(unexpected) , .hash_type = V1_HASH_NONE, },     { STATE_MAIN_I2, STATE_MAIN_I3, SMF_PSK_AUTH | SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY, P(KE) | P(NONCE), P(VID) | P(CR) | P(NATD_RFC), EVENT_RETRANSMIT, FM(main_inR2_outI3),  .hash_type = V1_HASH_NONE, },  { STATE_MAIN_I2, STATE_UNDEFINED, SMF_PKE_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY, P(KE) | P(ID) | P(NONCE), P(VID) | P(CR), EVENT_RETRANSMIT, FM(unexpected) , .hash_type = V1_HASH_NONE, },  { STATE_MAIN_I2, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY, P(NONCE) | P(KE) | P(ID), P(VID) | P(CR), EVENT_RETRANSMIT, FM(unexpected) , .hash_type = V1_HASH_NONE, },     { STATE_MAIN_R2, STATE_MAIN_R3, SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(ID) | P(HASH), P(VID) | P(CR), EVENT_SA_REPLACE, FM(main_inI3_outR3),   .hash_type = V1_HASH_NONE, },  { STATE_MAIN_R2, STATE_MAIN_R3, SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), EVENT_SA_REPLACE, FM(main_inI3_outR3),   .hash_type = V1_HASH_NONE, },  { STATE_MAIN_R2, STATE_UNDEFINED, SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(HASH), P(VID) | P(CR), EVENT_SA_REPLACE, FM(unexpected) , .hash_type = V1_HASH_NONE, },   { STATE_MAIN_I3, STATE_MAIN_I4, SMF_PSK_AUTH | SMF_INITIATOR | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2, P(ID) | P(HASH), P(VID) | P(CR), EVENT_SA_REPLACE, FM(main_inR3),   .hash_type = V1_HASH_NONE, },  { STATE_MAIN_I3, STATE_MAIN_I4, SMF_DS_AUTH | SMF_INITIATOR | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2, P(ID) | P(SIG), P(VID) | P(CR) | P(CERT), EVENT_SA_REPLACE, FM(main_inR3),   .hash_type = V1_HASH_NONE, },  { STATE_MAIN_I3, STATE_UNDEFINED, SMF_PKE_AUTH | SMF_RPKE_AUTH | SMF_INITIATOR | SMF_FIRST_ENCRYPTED_INPUT | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2, P(HASH), P(VID) | P(CR), EVENT_SA_REPLACE, FM(unexpected) , .hash_type = V1_HASH_NONE, },   { STATE_MAIN_R3, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },   { STATE_MAIN_I4, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },       { STATE_AGGR_R0, STATE_AGGR_R1, SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY, P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC), EVENT_SA_DISCARD, FM(aggr_inI1_outR1),  .hash_type = V1_HASH_NONE, },   { STATE_AGGR_I1, STATE_AGGR_I2, SMF_PSK_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(SA) | P(KE) | P(NONCE) | P(ID) | P(HASH), P(VID) | P(NATD_RFC), EVENT_SA_REPLACE, FM(aggr_inR1_outI2),   .hash_type = V1_HASH_NONE, },  { STATE_AGGR_I1, STATE_AGGR_I2, SMF_DS_AUTH | SMF_INITIATOR | SMF_OUTPUT_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(SA) | P(KE) | P(NONCE) | P(ID) | P(SIG), P(VID) | P(NATD_RFC), EVENT_SA_REPLACE, FM(aggr_inR1_outI2),   .hash_type = V1_HASH_NONE, },   { STATE_AGGR_R1, STATE_AGGR_R2, SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 | SMF_RETRANSMIT_ON_DUPLICATE, P(HASH), P(VID) | P(NATD_RFC), EVENT_SA_REPLACE, FM(aggr_inI2),   .hash_type = V1_HASH_NONE, },  { STATE_AGGR_R1, STATE_AGGR_R2, SMF_DS_AUTH | SMF_FIRST_ENCRYPTED_INPUT | SMF_OUTPUT_ENCRYPTED | SMF_RELEASE_PENDING_P2 | SMF_RETRANSMIT_ON_DUPLICATE, P(SIG), P(VID) | P(NATD_RFC), EVENT_SA_REPLACE, FM(aggr_inI2),   .hash_type = V1_HASH_NONE, },   { STATE_AGGR_I2, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_INITIATOR | SMF_RETRANSMIT_ON_DUPLICATE, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },   { STATE_AGGR_R2, STATE_UNDEFINED, SMF_ALL_AUTH, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },       { STATE_QUICK_R0, STATE_QUICK_R1, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY, P(HASH) | P(SA) | P(NONCE),  P(KE) | P(ID) | P(NATOA_RFC), EVENT_RETRANSMIT, FM(quick_inI1_outR1),  .hash_type = V1_HASH_1, },   { STATE_QUICK_I1, STATE_QUICK_I2, SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_REPLY, P(HASH) | P(SA) | P(NONCE),  P(KE) | P(ID) | P(NATOA_RFC), EVENT_SA_REPLACE, FM(quick_inR1_outI2),  .hash_type = V1_HASH_2, },   { STATE_QUICK_R1, STATE_QUICK_R2, SMF_ALL_AUTH | SMF_ENCRYPTED, P(HASH), LEMPTY, EVENT_SA_REPLACE, FM(quick_inI2),  .hash_type = V1_HASH_3, },   { STATE_QUICK_I2, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_INITIATOR | SMF_ENCRYPTED | SMF_RETRANSMIT_ON_DUPLICATE, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },   { STATE_QUICK_R2, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_ENCRYPTED, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },      { STATE_INFO, STATE_UNDEFINED, SMF_ALL_AUTH, LEMPTY, LEMPTY, EVENT_NULL, FM(informational), .hash_type = V1_HASH_NONE, },    { STATE_INFO_PROTECTED, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_ENCRYPTED, P(HASH), LEMPTY, EVENT_NULL, FM(informational),  .hash_type = V1_HASH_1, },  { STATE_XAUTH_R0, STATE_XAUTH_R1, SMF_ALL_AUTH | SMF_ENCRYPTED, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_NULL, FM(xauth_inR0),  .hash_type = V1_HASH_1, },  { STATE_XAUTH_R1, STATE_MAIN_R3, SMF_ALL_AUTH | SMF_ENCRYPTED, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(xauth_inR1),  .hash_type = V1_HASH_1, },    { STATE_XAUTH_R2, STATE_XAUTH_R3, SMF_ALL_AUTH | SMF_ENCRYPTED, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(xauth_inR2), },  { STATE_XAUTH_R3, STATE_MAIN_R3, SMF_ALL_AUTH | SMF_ENCRYPTED, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(xauth_inR3), },     { STATE_MODE_CFG_R0, STATE_MODE_CFG_R1, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(modecfg_inR0),  .hash_type = V1_HASH_1, },  { STATE_MODE_CFG_R1, STATE_MODE_CFG_R2, SMF_ALL_AUTH | SMF_ENCRYPTED, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(modecfg_inR1),  .hash_type = V1_HASH_1, },  { STATE_MODE_CFG_R2, STATE_UNDEFINED, SMF_ALL_AUTH | SMF_ENCRYPTED, LEMPTY, LEMPTY, EVENT_NULL, FM(unexpected), .hash_type = V1_HASH_NONE, },  { STATE_MODE_CFG_I1, STATE_MAIN_I4, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_RELEASE_PENDING_P2, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_SA_REPLACE, FM(modecfg_inR1),  .hash_type = V1_HASH_1, },  { STATE_XAUTH_I0, STATE_XAUTH_I1, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_RETRANSMIT, FM(xauth_inI0),  .hash_type = V1_HASH_1, },  { STATE_XAUTH_I1, STATE_MAIN_I4, SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2, P(MCFG_ATTR) | P(HASH), P(VID), EVENT_RETRANSMIT, FM(xauth_inI1),  .hash_type = V1_HASH_1, },  { STATE_IKEv1_ROOF, STATE_IKEv1_ROOF, LEMPTY, LEMPTY, LEMPTY, EVENT_NULL, NULL, .hash_type = V1_HASH_NONE, },    };















































































































































































































































































































































































void init_ikev1(struct logger *logger)
{
	dbg("checking IKEv1 state table");

	
	for (enum state_kind kind = STATE_IKEv1_FLOOR; kind < STATE_IKEv1_ROOF; kind++) {
		
		const struct finite_state *fs = &v1_states[kind - STATE_IKEv1_FLOOR];
		passert(fs->kind == kind);
		passert(finite_states[kind] == NULL);
		finite_states[kind] = fs;
	}

	
	for (const struct state_v1_microcode *t = v1_state_microcode_table;
	     t->state < STATE_IKEv1_ROOF; t++) {

		passert(t->state >= STATE_IKEv1_FLOOR);
		passert(t->state < STATE_IKEv1_ROOF);

		struct finite_state *from = &v1_states[t->state - STATE_IKEv1_FLOOR];
		passert(from->kind == t->state);
		passert(from->ike_version == IKEv1);

		
		enum state_kind next_state = (t->next_state == STATE_UNDEFINED ? t->state : t->next_state);
		passert(STATE_IKEv1_FLOOR <= next_state && next_state < STATE_IKEv1_ROOF);
		const struct finite_state *to = finite_states[next_state];
		passert(to != NULL);

		if (DBGP(DBG_BASE)) {
			if (from->nr_transitions == 0) {
				LSWLOG_DEBUG(buf) {
					jam_string(buf, "  ");
					lswlog_finite_state(buf, from);
					jam_string(buf, ":");
				}
			}
			DBG_log("    -> %s %s (%s)", to->short_name, enum_name_short(&event_type_names, t->timeout_event), t->message);


		}

		
		if (from->v1.transitions == NULL) {
			from->v1.transitions = t;
		} else {
			passert(t[-1].state == t->state);
		}
		from->nr_transitions++;

		if (t->message == NULL) {
			llog_pexpect(logger, HERE, "transition %s -> %s missing .message", from->short_name, to->short_name);
		}

		
		if ((t->flags & from->v1.flags) != from->v1.flags) {
			DBGF(DBG_BASE, "transition %s -> %s (%s) missing flags 0x%"PRIxLSET, from->short_name, to->short_name, t->message, from->v1.flags);

		}
		from->v1.flags |= t->flags & SMF_RETRANSMIT_ON_DUPLICATE;

		if (!(t->flags & SMF_FIRST_ENCRYPTED_INPUT) && (t->flags & SMF_INPUT_ENCRYPTED) && t->processor != unexpected) {

			
			if (!(t->req_payloads & LELEM(ISAKMP_NEXT_HASH))) {
				llog_pexpect(logger, HERE, "transition %s -> %s (%s) missing HASH payload", from->short_name, to->short_name, t->message);


			}
			if (t->hash_type == V1_HASH_NONE) {
				llog_pexpect(logger, HERE, "transition %s -> %s (%s) missing HASH protection", from->short_name, to->short_name, t->message);


			}
		}
	}
}

static stf_status unexpected(struct state *st, struct msg_digest *md UNUSED)
{
	log_state(RC_LOG_SERIOUS, st, "unexpected message received in state %s", st->st_state->name);
	return STF_IGNORE;
}


static stf_status informational(struct state *st, struct msg_digest *md)
{
	
	pexpect(st == md->v1_st);
	st = md->v1_st;    

	struct payload_digest *const n_pld = md->chain[ISAKMP_NEXT_N];

	
	if (n_pld != NULL) {
		pb_stream *const n_pbs = &n_pld->pbs;
		struct isakmp_notification *const n = &n_pld->payload.notification;

		
		
		enum_buf eb;
		dbg("processing informational %s (%d)", str_enum_short(&v1_notification_names, n->isan_type, &eb), n->isan_type);


		pstats(ikev1_recv_notifies_e, n->isan_type);

		switch (n->isan_type) {
		
		case v1N_R_U_THERE:
			if (st == NULL) {
				llog(RC_LOG, md->md_logger, "received bogus R_U_THERE informational message");
				return STF_IGNORE;
			}
			return dpd_inI_outR(st, n, n_pbs);

		case v1N_R_U_THERE_ACK:
			if (st == NULL) {
				llog(RC_LOG, md->md_logger, "received bogus R_U_THERE_ACK informational message");
				return STF_IGNORE;
			}
			return dpd_inR(st, n, n_pbs);

		case v1N_PAYLOAD_MALFORMED:
			if (st != NULL) {
				st->hidden_variables.st_malformed_received++;

				log_state(RC_LOG, st, "received %u malformed payload notifies", st->hidden_variables.st_malformed_received);

				if (st->hidden_variables.st_malformed_sent > MAXIMUM_MALFORMED_NOTIFY / 2 && ((st->hidden_variables.st_malformed_sent + st->hidden_variables. st_malformed_received) > MAXIMUM_MALFORMED_NOTIFY)) {




					log_state(RC_LOG, st, "too many malformed payloads (we sent %u and received %u", st->hidden_variables.st_malformed_sent, st->hidden_variables.st_malformed_received);

					delete_state(st);
					md->v1_st = st = NULL;
				}
			}

			return STF_IGNORE;

		default:
		{
			struct logger *logger = st != NULL ? st->st_logger :
							     md->md_logger;
			enum_buf eb;
			llog(RC_LOG_SERIOUS, logger, "received and ignored notification payload: %s", str_enum_short(&v1_notification_names, n->isan_type, &eb));

			return STF_IGNORE;
		}
		}
	} else {
		
		if (md->chain[ISAKMP_NEXT_D] == NULL) {
			const struct logger *logger = (st != NULL ? st->st_logger :
						 md->md_logger);
			llog(RC_LOG_SERIOUS, logger, "received and ignored empty informational notification payload");
		}
		return STF_IGNORE;
	}
}


void ikev1_init_pbs_out_from_md_hdr(struct msg_digest *md, bool enc, struct pbs_out *output_stream, uint8_t *output_buffer, size_t sizeof_output_buffer, struct pbs_out *rbody, struct logger *logger)



{
	struct isakmp_hdr hdr = md->hdr; 

	
	*output_stream = open_pbs_out("reply packet", output_buffer, sizeof_output_buffer, logger);

	hdr.isa_flags = 0; 
	if (enc)
		hdr.isa_flags |= ISAKMP_FLAGS_v1_ENCRYPTION;

	if (impair.send_bogus_isakmp_flag) {
		hdr.isa_flags |= ISAKMP_FLAGS_RESERVED_BIT6;
	}

	
	hdr.isa_np = 0;
	
	passert(out_struct(&hdr, &isakmp_hdr_desc, output_stream, rbody));
}


static bool ikev1_duplicate(struct state *st, struct msg_digest *md)
{
	passert(st != NULL);
	if (st->st_v1_rpacket.ptr != NULL && st->st_v1_rpacket.len == pbs_room(&md->packet_pbs) && memeq(st->st_v1_rpacket.ptr, md->packet_pbs.start, st->st_v1_rpacket.len)) {


		
		bool replied = (st->st_v1_last_transition != NULL && (st->st_v1_last_transition->flags & SMF_REPLY));
		bool retransmit_on_duplicate = (st->st_state->v1.flags & SMF_RETRANSMIT_ON_DUPLICATE);
		if (replied && retransmit_on_duplicate) {
			
			if (st->st_v1_last_transition->timeout_event == EVENT_SA_DISCARD || count_duplicate(st, MAXIMUM_v1_ACCEPTED_DUPLICATES)) {
				log_state(RC_RETRANSMISSION, st, "retransmitting in response to duplicate packet; already %s", st->st_state->name);

				resend_recorded_v1_ike_msg(st, "retransmit in response to duplicate");
			} else {
				log_state(RC_LOG_SERIOUS, st, "discarding duplicate packet -- exhausted retransmission; already %s", st->st_state->name);

			}
		} else {
			dbg("#%lu discarding duplicate packet; already %s; replied=%s retransmit_on_duplicate=%s", st->st_serialno, st->st_state->name, bool_str(replied), bool_str(retransmit_on_duplicate));

		}
		return true;
	}
	return false;
}


void process_v1_packet(struct msg_digest *md)
{
	bool new_iv_set = false;
	struct state *st = NULL;
	enum state_kind from_state = STATE_UNDEFINED;   

	
















	switch (md->hdr.isa_xchg) {
	case ISAKMP_XCHG_AGGR:
	case ISAKMP_XCHG_IDPROT: 
		if (md->hdr.isa_msgid != v1_MAINMODE_MSGID) {
			LOG_PACKET(RC_LOG, "Message ID was 0x%08" PRIx32 " but should be zero in phase 1", md->hdr.isa_msgid);
			SEND_NOTIFICATION(v1N_INVALID_MESSAGE_ID);
			return;
		}

		if (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {
			LOG_PACKET(RC_LOG, "Initiator Cookie must not be zero in phase 1 message");
			SEND_NOTIFICATION(v1N_INVALID_COOKIE);
			return;
		}

		if (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {
			
			if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {
				LOG_PACKET(RC_LOG, "initial phase 1 message is invalid: its Encrypted Flag is on");
				SEND_NOTIFICATION(v1N_INVALID_FLAGS);
				return;
			}

			
			st = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi, md->hdr.isa_msgid);
			if (st != NULL) {
				if (!ikev1_duplicate(st, md)) {
					
					log_state(RC_LOG, st, "discarding initial packet; already %s", st->st_state->name);
				}
				return;
			}
			passert(st == NULL); 
			
			from_state = (md->hdr.isa_xchg == ISAKMP_XCHG_IDPROT ? STATE_MAIN_R0 : STATE_AGGR_R0);
		} else {
			

			st = find_state_ikev1(&md->hdr.isa_ike_spis, md->hdr.isa_msgid);

			if (st == NULL) {
				
				st = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi, md->hdr.isa_msgid);

				if (st == NULL) {
					llog(RC_LOG, md->md_logger, "phase 1 message is part of an unknown exchange");
					
					return;
				}
				if (st->st_state->kind == STATE_AGGR_R0) {
					
					llog_pexpect(md->md_logger, HERE, "phase 1 message matching AGGR_R0 state");
					return;
				}
			}
			from_state = st->st_state->kind;
		}
		break;

	case ISAKMP_XCHG_INFO:  
		st = find_v1_info_state(&md->hdr.isa_ike_spis, v1_MAINMODE_MSGID);

		if (st == NULL) {
			
			st = find_state_ikev1_init(&md->hdr.isa_ike_initiator_spi, v1_MAINMODE_MSGID);
		}

		if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {
			bool quiet = (st == NULL);

			if (st == NULL) {
				if (DBGP(DBG_BASE)) {
					DBG_log("Informational Exchange is for an unknown (expired?) SA with MSGID:0x%08" PRIx32, md->hdr.isa_msgid);
					DBG_dump_thing("- unknown SA's md->hdr.isa_ike_initiator_spi.bytes:", md->hdr.isa_ike_initiator_spi);
					DBG_dump_thing("- unknown SA's md->hdr.isa_ike_responder_spi.bytes:", md->hdr.isa_ike_responder_spi);
				}

				
				return;
			}

			if (!IS_V1_ISAKMP_ENCRYPTED(st->st_state->kind)) {
				if (!quiet) {
					log_state(RC_LOG_SERIOUS, st, "encrypted Informational Exchange message is invalid because no key is known");
				}
				
				return;
			}

			if (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {
				if (!quiet) {
					log_state(RC_LOG_SERIOUS, st, "Informational Exchange message is invalid because it has a Message ID of 0");
				}
				
				return;
			}

			if (!unique_msgid(st, md->hdr.isa_msgid)) {
				if (!quiet) {
					log_state(RC_LOG_SERIOUS, st, "Informational Exchange message is invalid because it has a previously used Message ID (0x%08" PRIx32 " )", md->hdr.isa_msgid);

				}
				
				return;
			}
			st->st_v1_msgid.reserved = false;

			init_phase2_iv(st, &md->hdr.isa_msgid);
			new_iv_set = true;

			from_state = STATE_INFO_PROTECTED;
		} else {
			if (st != NULL && IS_V1_ISAKMP_AUTHENTICATED(st->st_state)) {
				log_state(RC_LOG_SERIOUS, st, "Informational Exchange message must be encrypted");
				
				return;
			}
			from_state = STATE_INFO;
		}
		break;

	case ISAKMP_XCHG_QUICK: 

		if (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {
			dbg("Quick Mode message is invalid because it has an Initiator Cookie of 0");
			SEND_NOTIFICATION(v1N_INVALID_COOKIE);
			return;
		}

		if (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {
			dbg("Quick Mode message is invalid because it has a Responder Cookie of 0");
			SEND_NOTIFICATION(v1N_INVALID_COOKIE);
			return;
		}

		if (md->hdr.isa_msgid == v1_MAINMODE_MSGID) {
			dbg("Quick Mode message is invalid because it has a Message ID of 0");
			SEND_NOTIFICATION(v1N_INVALID_MESSAGE_ID);
			return;
		}

		st = find_state_ikev1(&md->hdr.isa_ike_spis, md->hdr.isa_msgid);

		if (st == NULL) {
			
			st = find_state_ikev1(&md->hdr.isa_ike_spis, v1_MAINMODE_MSGID);

			if (st == NULL) {
				dbg("Quick Mode message is for a non-existent (expired?) ISAKMP SA");
				
				return;
			}

			if (st->st_oakley.doing_xauth) {
				dbg("Cannot do Quick Mode until XAUTH done.");
				return;
			}

			
			if (st->st_state->kind == STATE_MODE_CFG_R2) {
				
				change_v1_state(st, STATE_MAIN_R3);
			}


			
			if (st->st_state->kind == STATE_MODE_CFG_R1) {
				log_state(RC_LOG, st, "SoftRemote workaround: Cannot do Quick Mode until MODECFG done.");
				return;
			}



			if (!IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
				log_state(RC_LOG_SERIOUS, st, "Quick Mode message is unacceptable because it is for an incomplete ISAKMP SA");
				SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED );
				return;
			}

			if (!unique_msgid(st, md->hdr.isa_msgid)) {
				log_state(RC_LOG_SERIOUS, st, "Quick Mode I1 message is unacceptable because it uses a previously used Message ID 0x%08" PRIx32 " (perhaps this is a duplicated packet)", md->hdr.isa_msgid);

				SEND_NOTIFICATION(v1N_INVALID_MESSAGE_ID);
				return;
			}
			st->st_v1_msgid.reserved = false;

			
			init_phase2_iv(st, &md->hdr.isa_msgid);
			new_iv_set = true;

			from_state = STATE_QUICK_R0;
		} else {
			if (st->st_oakley.doing_xauth) {
				log_state(RC_LOG, st, "Cannot do Quick Mode until XAUTH done.");
				return;
			}
			from_state = st->st_state->kind;
		}

		break;

	case ISAKMP_XCHG_MODE_CFG:
		if (ike_spi_is_zero(&md->hdr.isa_ike_initiator_spi)) {
			dbg("Mode Config message is invalid because it has an Initiator Cookie of 0");
			
			return;
		}

		if (ike_spi_is_zero(&md->hdr.isa_ike_responder_spi)) {
			dbg("Mode Config message is invalid because it has a Responder Cookie of 0");
			
			return;
		}

		if (md->hdr.isa_msgid == 0) {
			dbg("Mode Config message is invalid because it has a Message ID of 0");
			
			return;
		}

		st = find_v1_info_state(&md->hdr.isa_ike_spis, md->hdr.isa_msgid);

		if (st == NULL) {
			
			dbg("No appropriate Mode Config state yet. See if we have a Main Mode state");

			st = find_v1_info_state(&md->hdr.isa_ike_spis, 0);

			if (st == NULL) {
				dbg("Mode Config message is for a non-existent (expired?) ISAKMP SA");
				
				
				return;
			}


			const struct end *this = &st->st_connection->spd.this;
			esb_buf b;
			dbg(" processing received isakmp_xchg_type %s; this is a%s%s%s%s", enum_show(&ikev1_exchange_names, md->hdr.isa_xchg, &b), this->config->host.xauth.server ? " xauthserver" : "", this->config->host.xauth.client ? " xauthclient" : "", this->modecfg_server ? " modecfgserver" : "", this->modecfg_client ? " modecfgclient" : "");





			if (!IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
				dbg("Mode Config message is unacceptable because it is for an incomplete ISAKMP SA (state=%s)", st->st_state->name);
				
				return;
			}
			dbg(" call init_phase2_iv");
			init_phase2_iv(st, &md->hdr.isa_msgid);
			new_iv_set = true;

			

			if (this->config->host.xauth.server && st->st_state->kind == STATE_XAUTH_R1 && st->quirks.xauth_ack_msgid) {

				from_state = STATE_XAUTH_R1;
				dbg(" set from_state to %s state is STATE_XAUTH_R1 and quirks.xauth_ack_msgid is TRUE", st->st_state->name);
			} else if (this->config->host.xauth.client && IS_V1_PHASE1(st->st_state->kind)) {
				from_state = STATE_XAUTH_I0;
				dbg(" set from_state to %s this is xauthclient and IS_PHASE1() is TRUE", st->st_state->name);
			} else if (this->config->host.xauth.client && st->st_state->kind == STATE_XAUTH_I1) {
				
				from_state = STATE_XAUTH_I0;
				dbg(" set from_state to %s this is xauthclient and state == STATE_XAUTH_I1", st->st_state->name);
			} else if (this->modecfg_server && IS_V1_PHASE1(st->st_state->kind)) {
				from_state = STATE_MODE_CFG_R0;
				dbg(" set from_state to %s this is modecfgserver and IS_PHASE1() is TRUE", st->st_state->name);
			} else if (this->modecfg_client && IS_V1_PHASE1(st->st_state->kind)) {
				from_state = STATE_MODE_CFG_R1;
				dbg(" set from_state to %s this is modecfgclient and IS_PHASE1() is TRUE", st->st_state->name);
			} else {
				esb_buf b;
				dbg("received isakmp_xchg_type %s; this is a%s%s%s%s in state %s. Reply with UNSUPPORTED_EXCHANGE_TYPE", enum_show(&ikev1_exchange_names, md->hdr.isa_xchg, &b), st->st_connection ->local->config->host.xauth.server ? " xauthserver" : "", st->st_connection->local->config->host.xauth.client ? " xauthclient" : "", st->st_connection->spd.this.modecfg_server ? " modecfgserver" : "", st->st_connection->spd.this.modecfg_client ? " modecfgclient" : "", st->st_state->name);





				return;
			}
		} else {
			if (st->st_connection->local->config->host.xauth.server && IS_V1_PHASE1(st->st_state->kind)) {
				
				dbg("We were in phase 1, with no state, so we went to XAUTH_R0");
				change_v1_state(st, STATE_XAUTH_R0);
			}

			
			from_state = st->st_state->kind;
		}

		break;

	case ISAKMP_XCHG_NONE:
	case ISAKMP_XCHG_BASE:
	case ISAKMP_XCHG_AO:
	case ISAKMP_XCHG_NGRP:
	default:
	{
		esb_buf b;
		dbg("unsupported exchange type %s in message", enum_show(&ikev1_exchange_names, md->hdr.isa_xchg, &b));
		SEND_NOTIFICATION(v1N_UNSUPPORTED_EXCHANGE_TYPE);
		return;
	}
	}

	

	
	if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_COMMIT)
		dbg("IKE message has the Commit Flag set but Pluto doesn't implement this feature due to security concerns; ignoring flag");

	
	if (md->hdr.isa_np == ISAKMP_NEXT_IKE_FRAGMENTATION) {
		struct isakmp_ikefrag fraghdr;
		int last_frag_index = 0;  
		pb_stream frag_pbs;

		if (st == NULL) {
			dbg("received IKE fragment, but have no state. Ignoring packet.");
			return;
		}

		if ((st->st_connection->policy & POLICY_IKE_FRAG_ALLOW) == 0) {
			dbg("discarding IKE fragment packet - fragmentation not allowed by local policy (ike_frag=no)");
			return;
		}

		diag_t d = pbs_in_struct(&md->message_pbs, &isakmp_ikefrag_desc, &fraghdr, sizeof(fraghdr), &frag_pbs);
		if (d != NULL) {
			llog_diag(RC_LOG, LOGGER, &d, "%s", "");
			SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
			return;
		}
		if (pbs_room(&frag_pbs) != fraghdr.isafrag_length || fraghdr.isafrag_np != ISAKMP_NEXT_NONE || fraghdr.isafrag_number == 0 || fraghdr.isafrag_number > 16) {


			SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
			return;
		}

		dbg("received IKE fragment id '%d', number '%u'%s", fraghdr.isafrag_id, fraghdr.isafrag_number, (fraghdr.isafrag_flags == 1) ? "(last)" : "");



		struct v1_ike_rfrag *ike_frag = alloc_thing(struct v1_ike_rfrag, "ike_frag");
		ike_frag->md = md_addref(md);
		ike_frag->index = fraghdr.isafrag_number;
		ike_frag->last = (fraghdr.isafrag_flags & 1);
		ike_frag->size = pbs_left(&frag_pbs);
		ike_frag->data = frag_pbs.cur;

		
		struct v1_ike_rfrag **i = &st->st_v1_rfrags;
		for (;;) {
			if (ike_frag != NULL) {
				
				if (*i == NULL || (*i)->index > ike_frag->index) {
					ike_frag->next = *i;
					*i = ike_frag;
					ike_frag = NULL;
				} else if ((*i)->index == ike_frag->index) {
					
					struct v1_ike_rfrag *old = *i;

					ike_frag->next = old->next;
					*i = ike_frag;
					pexpect(old->md != NULL);
					md_delref(&old->md);
					pfree(old);
					ike_frag = NULL;
				}
			}

			if (*i == NULL)
				break;

			if ((*i)->last)
				last_frag_index = (*i)->index;

			i = &(*i)->next;
		}

		
		if (last_frag_index != 0) {
			size_t size = 0;
			int prev_index = 0;

			for (struct v1_ike_rfrag *frag = st->st_v1_rfrags; frag; frag = frag->next) {
				size += frag->size;
				if (frag->index != ++prev_index) {
					break; 
				} else if (frag->index == last_frag_index) {
					struct msg_digest *whole_md = alloc_md(frag->md->iface, &frag->md->sender, NULL, size, HERE);



					
					frag = st->st_v1_rfrags;
					uint8_t *buffer = whole_md->packet_pbs.start;
					size_t offset = 0;
					while (frag != NULL && frag->index <= last_frag_index) {
						passert(offset + frag->size <= size);
						memcpy(buffer + offset, frag->data, frag->size);
						offset += frag->size;
						frag = frag->next;
					}

					
					process_md(whole_md);
					md_delref(&whole_md);
					free_v1_message_queues(st);
					
					st->st_v1_seen_fragments = true;
					dbg(" updated IKE fragment state to respond using fragments without waiting for re-transmits");
					break;
				}
			}
		}

		return;
	}

	
	passert(STATE_IKEv1_FLOOR <= from_state && from_state < STATE_IKEv1_ROOF);
	const struct finite_state *fs = finite_states[from_state];
	passert(fs != NULL);
	const struct state_v1_microcode *smc = fs->v1.transitions;
	passert(smc != NULL);

	
	if (st != NULL) {
		oakley_auth_t baseauth = xauth_calcbaseauth(st->st_oakley.auth);

		while (!LHAS(smc->flags, baseauth)) {
			smc++;
			passert(smc->state == from_state);
		}
	}

	
	if (verbose_state_busy(st))
		return;

	
	if (st != NULL && ikev1_duplicate(st, md)) {
		return;
	}

	
	md->v1_st = st;
	md->smc = smc;
	md->new_iv_set = new_iv_set;

	
	if ((md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) && st != NULL && !st->hidden_variables.st_skeyid_calculated) {

		endpoint_buf b;
		dbg("received encrypted packet from %s but exponentiation still in progress", str_endpoint(&md->sender, &b));

		
		if (st->st_suspended_md != NULL) {
			dbg("suspend: releasing suspended operation for "PRI_SO" MD@%p before completion "PRI_WHERE, st->st_serialno, st->st_suspended_md, pri_where(HERE));

			md_delref(&st->st_suspended_md);
		}
		suspend_any_md(st, md);
		return;
	}

	process_packet_tail(md);
	
}


void process_packet_tail(struct msg_digest *md)
{
	struct state *st = md->v1_st;
	const struct state_v1_microcode *smc = md->smc;
	enum state_kind from_state = smc->state;
	bool new_iv_set = md->new_iv_set;
	bool self_delete = false;

	if (md->hdr.isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION) {

		endpoint_buf b;
		dbg("received encrypted packet from %s", str_endpoint(&md->sender, &b));

		if (st == NULL) {
			LOG_PACKET(RC_LOG, "discarding encrypted message for an unknown ISAKMP SA");
			return;
		}
		if (st->st_skeyid_e_nss == NULL) {
			LOG_PACKET(RC_LOG_SERIOUS, "discarding encrypted message because we haven't yet negotiated keying material");
			return;
		}

		
		md->encrypted = true;

		
		const struct encrypt_desc *e = st->st_oakley.ta_encrypt;

		if (pbs_left(&md->message_pbs) % e->enc_blocksize != 0) {
			LOG_PACKET(RC_LOG_SERIOUS, "malformed message: not a multiple of encryption blocksize");
			return;
		}

		

		
		md->raw_packet = clone_bytes_as_chunk(md->packet_pbs.start, pbs_room(&md->packet_pbs), "raw packet");


		
		if (!new_iv_set) {
			if (st->st_v1_iv.len == 0) {
				init_phase2_iv(st, &md->hdr.isa_msgid);
			} else {
				
				restore_new_iv(st, st->st_v1_iv);
			}
		}

		passert(st->st_v1_new_iv.len >= e->enc_blocksize);
		st->st_v1_new_iv.len = e->enc_blocksize;   

		if (DBGP(DBG_CRYPT)) {
			DBG_log("decrypting %u bytes using algorithm %s", (unsigned) pbs_left(&md->message_pbs), st->st_oakley.ta_encrypt->common.fqn);

			DBG_dump_hunk("IV before:", st->st_v1_new_iv);
		}
		e->encrypt_ops->do_crypt(e, md->message_pbs.cur, pbs_left(&md->message_pbs), st->st_enc_key_nss, st->st_v1_new_iv.ptr, false, st->st_logger);



		if (DBGP(DBG_CRYPT)) {
			DBG_dump_hunk("IV after:", st->st_v1_new_iv);
			DBG_log("decrypted payload (starts at offset %td):", md->message_pbs.cur - md->message_pbs.roof);
			DBG_dump(NULL, md->message_pbs.start, md->message_pbs.roof - md->message_pbs.start);
		}
	} else {
		

		if (smc->flags & SMF_INPUT_ENCRYPTED) {
			LOG_PACKET(RC_LOG_SERIOUS, "packet rejected: should have been encrypted");
			SEND_NOTIFICATION(v1N_INVALID_FLAGS);
			return;
		}
	}

	
	{
		enum next_payload_types_ikev1 np = md->hdr.isa_np;
		lset_t needed = smc->req_payloads;
		const char *excuse = LIN(SMF_PSK_AUTH | SMF_FIRST_ENCRYPTED_INPUT, smc->flags) ? "probable authentication failure (mismatch of preshared secrets?): " :



			"";

		while (np != ISAKMP_NEXT_NONE) {
			struct_desc *sd = v1_payload_desc(np);

			if (md->digest_roof >= elemsof(md->digest)) {
				LOG_PACKET(RC_LOG_SERIOUS, "more than %zu payloads in message; ignored", elemsof(md->digest));

				if (!md->encrypted) {
					SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
				}
				return;
			}
			struct payload_digest *const pd = md->digest + md->digest_roof;

			
			if (st != NULL && st->st_connection != NULL && (st->st_connection->policy & POLICY_AGGRESSIVE) == LEMPTY)
			{
				switch (np) {
				case ISAKMP_NEXT_NATD_RFC:
				case ISAKMP_NEXT_NATOA_RFC:
					if ((st->hidden_variables.st_nat_traversal & NAT_T_WITH_RFC_VALUES) == LEMPTY) {
						
						lset_buf lb;
						dbg("st_nat_traversal was: %s", str_lset(&natt_method_names, st->hidden_variables.st_nat_traversal, &lb));


						sd = NULL;
					}
					break;
				default:
					break;
				}
			}

			if (sd == NULL) {
				
				switch (np) {
				case ISAKMP_NEXT_ID:
					
					sd = (IS_V1_PHASE1(from_state) || IS_V1_PHASE15(from_state)) ? &isakmp_identification_desc :

						&isakmp_ipsec_identification_desc;
					break;

				case ISAKMP_NEXT_NATD_DRAFTS: 
					
					np = ISAKMP_NEXT_NATD_RFC;
					sd = &isakmp_nat_d_drafts;
					break;

				case ISAKMP_NEXT_NATOA_DRAFTS: 
					
					np = ISAKMP_NEXT_NATOA_RFC;
					sd = &isakmp_nat_oa_drafts;
					break;

				case ISAKMP_NEXT_SAK: 
					
					LOG_PACKET(RC_LOG_SERIOUS, "%smessage with unsupported payload ISAKMP_NEXT_SAK (or ISAKMP_NEXT_NATD_BADDRAFTS) ignored", excuse);

					
					diag_t d = pbs_in_struct(&md->message_pbs, &isakmp_ignore_desc, &pd->payload, sizeof(pd->payload), &pd->pbs);
					if (d != NULL) {
						llog_diag(RC_LOG, LOGGER, &d, "%s", "");
						LOG_PACKET(RC_LOG_SERIOUS, "%smalformed payload in packet", excuse);

						if (!md->encrypted) {
							SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
						}
						return;
					}
					np = pd->payload.generic.isag_np;
					
					continue;  

				default:
				{
					esb_buf b;
					LOG_PACKET(RC_LOG_SERIOUS, "%smessage ignored because it contains an unknown or unexpected payload type (%s) at the outermost level", excuse, enum_show(&ikev1_payload_names, np, &b));


					if (!md->encrypted) {
						SEND_NOTIFICATION(v1N_INVALID_PAYLOAD_TYPE);
					}
					return;
				}
				}
				passert(sd != NULL);
			}

			passert(np < LELEM_ROOF);

			{
				lset_t s = LELEM(np);

				if (LDISJOINT(s, needed | smc->opt_payloads | LELEM(ISAKMP_NEXT_VID) | LELEM(ISAKMP_NEXT_N) | LELEM(ISAKMP_NEXT_D) | LELEM(ISAKMP_NEXT_CR) | LELEM(ISAKMP_NEXT_CERT))) {





					esb_buf b;
					LOG_PACKET(RC_LOG_SERIOUS, "%smessage ignored because it contains a payload type (%s) unexpected by state %s", excuse, enum_show(&ikev1_payload_names, np, &b), finite_states[smc->state]->name);



					if (!md->encrypted) {
						SEND_NOTIFICATION(v1N_INVALID_PAYLOAD_TYPE);
					}
					return;
				}

				esb_buf b;
				dbg("got payload 0x%" PRIxLSET"  (%s) needed: 0x%" PRIxLSET " opt: 0x%" PRIxLSET, s, enum_show(&ikev1_payload_names, np, &b), needed, smc->opt_payloads);

				needed &= ~s;
			}

			
			pd->payload_type = np;
			diag_t d = pbs_in_struct(&md->message_pbs, sd, &pd->payload, sizeof(pd->payload), &pd->pbs);

			if (d != NULL) {
				llog_diag(RC_LOG, LOGGER, &d, "%s", "");
				LOG_PACKET(RC_LOG_SERIOUS, "%smalformed payload in packet", excuse);

				if (!md->encrypted) {
					SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
				}
				return;
			}

			
			switch (np) {
			case ISAKMP_NEXT_ID:
			case ISAKMP_NEXT_NATOA_RFC:
				
				if (DBGP(DBG_BASE)) {
					DBG_dump("     obj: ", pd->pbs.cur, pbs_left(&pd->pbs));
				}
				break;
			default:
				break;
			}


			
			{
				
				passert(np < elemsof(md->chain));
				struct payload_digest **p = &md->chain[np];

				while (*p != NULL)
					p = &(*p)->next;
				*p = pd;
				pd->next = NULL;
			}

			np = pd->payload.generic.isag_np;
			md->digest_roof++;

			
			excuse = "";
		}

		if (DBGP(DBG_BASE) && pbs_left(&md->message_pbs) != 0) {
			DBG_log("removing %d bytes of padding", (int) pbs_left(&md->message_pbs));
		}

		md->message_pbs.roof = md->message_pbs.cur;

		

		if (needed != 0) {
			LOG_PACKET_JAMBUF(RC_LOG_SERIOUS, buf) {
				jam(buf, "message for %s is missing payloads ", finite_states[from_state]->name);
				jam_lset_short(buf, &ikev1_payload_names, "+", needed);
			}
			if (!md->encrypted) {
				SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
			}
			return;
		}
	}

	if (!check_v1_HASH(smc->hash_type, smc->message, st, md)) {
		
		return;
	}

	

	if (IS_V1_PHASE1(from_state) || IS_V1_PHASE15(from_state)) {
		
		if (md->chain[ISAKMP_NEXT_SA] != NULL && md->hdr.isa_np != ISAKMP_NEXT_SA) {
			LOG_PACKET(RC_LOG_SERIOUS, "malformed Phase 1 message: does not start with an SA payload");
			if (!md->encrypted) {
				SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
			}
			return;
		}
	} else if (IS_V1_QUICK(from_state)) {
		

		if (md->hdr.isa_np != ISAKMP_NEXT_HASH) {
			LOG_PACKET(RC_LOG_SERIOUS, "malformed Quick Mode message: does not start with a HASH payload");
			if (!md->encrypted) {
				SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
			}
			return;
		}

		{
			struct payload_digest *p;
			int i;

			p = md->chain[ISAKMP_NEXT_SA];
			i = 1;
			while (p != NULL) {
				if (p != &md->digest[i]) {
					LOG_PACKET(RC_LOG_SERIOUS, "malformed Quick Mode message: SA payload is in wrong position");
					if (!md->encrypted) {
						SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
					}
					return;
				}
				p = p->next;
				i++;
			}
		}

		
		{
			struct payload_digest *id = md->chain[ISAKMP_NEXT_ID];

			if (id != NULL) {
				if (id->next == NULL || id->next->next != NULL) {
					LOG_PACKET(RC_LOG_SERIOUS, "malformed Quick Mode message: if any ID payload is present, there must be exactly two");
					SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
					return;
				}
				if (id + 1 != id->next) {
					LOG_PACKET(RC_LOG_SERIOUS, "malformed Quick Mode message: the ID payloads are not adjacent");
					SEND_NOTIFICATION(v1N_PAYLOAD_MALFORMED);
					return;
				}
			}
		}
	}

	
	
	for (struct payload_digest *p = md->chain[ISAKMP_NEXT_N];
	     p != NULL; p = p->next) {

		enum_buf nb; 
		const char *nname = str_enum_short(&v1_notification_names, p->payload.notification.isan_type, &nb);

		switch (p->payload.notification.isan_type) {
		case v1N_R_U_THERE:
		case v1N_R_U_THERE_ACK:
		case v1N_PAYLOAD_MALFORMED:
		case v1N_INVALID_MESSAGE_ID:
		case v1N_IPSEC_RESPONDER_LIFETIME:
			if (md->hdr.isa_xchg == ISAKMP_XCHG_INFO) {
				
				if (DBGP(DBG_BASE)) {
					DBG_log("%s:", nname);
					DBG_dump_pbs(&p->pbs);
				}
				continue;
			}
		}

		if (st == NULL) {
			dbg("ignoring informational payload %s, no corresponding state", nname);
		} else {
			LOG_PACKET(RC_LOG_SERIOUS, "ignoring informational payload %s, msgid=%08" PRIx32 ", length=%d", nname, st->st_v1_msgid.id, p->payload.notification.isan_length);


		}
		if (DBGP(DBG_BASE)) {
			DBG_dump_pbs(&p->pbs);
		}
	}

	for (struct payload_digest *p = md->chain[ISAKMP_NEXT_D];
	     p != NULL; p = p->next) {
		self_delete |= accept_delete(md, p);
		if (DBGP(DBG_BASE)) {
			DBG_dump("del:", p->pbs.cur, pbs_left(&p->pbs));
		}
		if (md->v1_st != st) {
			pexpect(md->v1_st == NULL);
			dbg("zapping ST as accept_delete() zapped MD.ST");
			st = md->v1_st;
		}
	}

	for (struct payload_digest *p = md->chain[ISAKMP_NEXT_VID];
	     p != NULL; p = p->next) {
		handle_v1_vendorid(md, pbs_in_left_as_shunk(&p->pbs), (st != NULL ? st->st_logger : md->md_logger));
	}

	if (self_delete) {
		accept_self_delete(md);
		st = md->v1_st;
		
	}

	pexpect(st == md->v1_st);
	statetime_t start = statetime_start(md->v1_st);
	
	stf_status e = smc->processor(st, md);
	complete_v1_state_transition(md->v1_st, md, e);
	statetime_stop(&start, "%s()", __func__);
	
}


static void remember_received_packet(struct state *st, struct msg_digest *md)
{
	if (md->encrypted) {
		
		if (md->raw_packet.ptr != NULL) {
			pfreeany(st->st_v1_rpacket.ptr);
			st->st_v1_rpacket = md->raw_packet;
			md->raw_packet = EMPTY_CHUNK;
		}
	} else {
		
		replace_chunk(&st->st_v1_rpacket, clone_bytes_as_chunk(md->packet_pbs.start, pbs_room(&md->packet_pbs), "raw packet"));


	}
}

static void jam_v1_ipsec_details(struct jambuf *buf, struct state *st)
{
	struct connection *const c = st->st_connection;
	jam_string(buf, c->policy & POLICY_TUNNEL ? "tunnel mode" : "transport mode");
	jam(buf, " ");
	jam_child_sa_details(buf, st);
}

static void jam_v1_isakmp_details(struct jambuf *buf, struct state *st)
{
	jam_parent_sa_details(buf, st);
}


void complete_v1_state_transition(struct state *st, struct msg_digest *md, stf_status result)
{
	

	
	pstat(stf_status, result);

	enum_buf neb;
	dbg("complete v1 state transition with %s", result > STF_FAIL_v1N ? str_enum_short(&v1_notification_names, result - STF_FAIL_v1N, &neb) :

	    enum_name(&stf_status_names, result));

	switch (result) {
	case STF_SUSPEND:
		
		passert(md != NULL);
		pexpect(md->v1_st == st);
		suspend_any_md(md->v1_st, md);
		if (DBGP(DBG_BASE)) {
			check_state(md->v1_st, HERE);
		}
		return;
	case STF_IGNORE:
		
		return;
	case STF_SKIP_COMPLETE_STATE_TRANSITION:
		
		return;
	default:
		break;
	}

	passert(md != NULL);
	pexpect(md->v1_st == st);

	

	enum state_kind from_state = md->smc->state;
	st = md->v1_st;

	if (DBGP(DBG_BASE)) {
		check_state(st, HERE);
	}

	passert(st != NULL);
	pexpect(!state_is_busy(st));

	if (result > STF_OK) {
		linux_audit_conn(md->v1_st, IS_V1_ISAKMP_SA_ESTABLISHED(md->v1_st) ? LAK_CHILD_FAIL : LAK_PARENT_FAIL);
	}

	switch (result) {
	case STF_OK:
	{
		
		const struct state_v1_microcode *smc = md->smc;

		dbg("doing_xauth:%s, t_xauth_client_done:%s", bool_str(st->st_oakley.doing_xauth), bool_str(st->hidden_variables.st_xauth_client_done));


		

		

		if (md->fragvid) {
			dbg("peer supports fragmentation");
			st->st_seen_fragmentation_supported = true;
		}

		if (md->dpd) {
			dbg("peer supports DPD");
			st->hidden_variables.st_peer_supports_dpd = true;
			if (dpd_active_locally(st->st_connection)) {
				dbg("DPD is configured locally");
			}
		}

		if (!st->st_v1_msgid.reserved && IS_CHILD_SA(st) && st->st_v1_msgid.id != v1_MAINMODE_MSGID) {

			struct state *p1st = state_by_serialno(st->st_clonedfrom);

			if (p1st != NULL) {
				
				reserve_msgid(p1st, st->st_v1_msgid.id);
			}

			st->st_v1_msgid.reserved = true;
		}

		dbg("IKEv1: transition from state %s to state %s", finite_states[from_state]->name, finite_states[smc->next_state]->name);


		change_v1_state(st, smc->next_state);

		
		if (st->st_connection->local->config->host.xauth.client && st->hidden_variables.st_xauth_client_done && !st->st_connection->spd.this.modecfg_client && st->st_state->kind == STATE_XAUTH_I1)


		{
			bool aggrmode = LHAS(st->st_connection->policy, POLICY_AGGRESSIVE_IX);

			log_state(RC_LOG, st, "XAUTH completed; ModeCFG skipped as per configuration");
			change_v1_state(st, aggrmode ? STATE_AGGR_I2 : STATE_MAIN_I4);
			st->st_v1_msgid.phase15 = v1_MAINMODE_MSGID;
		}

		

		
		delete_event(st);
		clear_retransmits(st);

		
		free_v1_message_queues(st);

		
		free_chunk_content(&st->st_v1_rpacket);
		free_chunk_content(&st->st_v1_tpacket);

		
		if (nat_traversal_enabled && st->st_connection->ikev1_natt != NATT_NONE) {
			
			nat_traversal_change_port_lookup(md, st);
			v1_maybe_natify_initiator_endpoints(st, HERE);
		}

		
		remember_received_packet(st, md);
		st->st_v1_last_transition = md->smc;

		
		if (smc->flags & SMF_REPLY) {
			endpoint_buf b;
			endpoint_buf b2;
			dbg("sending reply packet to %s (from %s)", str_endpoint(&st->st_remote_endpoint, &b), str_endpoint(&st->st_interface->local_endpoint, &b2));


			close_output_pbs(&reply_stream); 

			if (st->st_state->kind == STATE_MAIN_R2 && impair.send_no_main_r2) {
				
				record_outbound_v1_ike_msg(st, &reply_stream, finite_states[from_state]->name);
				log_state(RC_LOG, st, "IMPAIR: Skipped sending STATE_MAIN_R2 response packet");
			} else {
				record_and_send_v1_ike_msg(st, &reply_stream, finite_states[from_state]->name);
			}
		}

		

		enum event_type event_type = smc->timeout_event;
		struct connection *c = st->st_connection;

		
		if (c->local->config->host.xauth.client && st->hidden_variables.st_xauth_client_done && !c->spd.this.modecfg_client && (st->st_state->kind == STATE_MAIN_I4 || st->st_state->kind == STATE_AGGR_I2)) {


			dbg("fixup XAUTH without ModeCFG event from EVENT_RETRANSMIT to EVENT_SA_REPLACE");
			event_type = EVENT_SA_REPLACE;
		}

		switch (event_type) {
		case EVENT_RETRANSMIT: 
			start_retransmits(st);
			break;

		case EVENT_SA_REPLACE: 
		{
			deltatime_t event_delay;
			bool agreed_time = false;
			if (IS_V1_PHASE1(st->st_state->kind) || IS_V1_PHASE15(st->st_state->kind)) {
				
				event_delay = c->sa_ike_life_seconds;
				if ((c->policy & POLICY_DONT_REKEY) || deltatime_cmp(event_delay, >=, st->st_oakley.life_seconds)) {
					agreed_time = true;
					event_delay = st->st_oakley.life_seconds;
				}
			} else {
				
				event_delay = c->sa_ipsec_life_seconds;








				clamp_delay(st_ah);
				clamp_delay(st_esp);
				clamp_delay(st_ipcomp);

			}

			
			if (agreed_time && (c->policy & POLICY_DONT_REKEY)) {
				event_type = ((smc->flags & SMF_INITIATOR) ? EVENT_v1_REPLACE_IF_USED :
					      EVENT_SA_EXPIRE);
			}
			if (event_type != EVENT_SA_EXPIRE) {
				deltatime_t marg = fuzz_rekey_margin(st->st_sa_role, c->sa_rekey_margin, c->sa_rekey_fuzz);

				if (deltatime_cmp(event_delay, >, marg)) {
					st->st_replace_margin = marg;
				} else {
					marg = deltatime(0);
				}
				event_delay = deltatime_sub(event_delay, marg);
			}
			event_schedule(event_type, event_delay, st);
			break;
		}
		case EVENT_SA_DISCARD:
			event_schedule(EVENT_SA_DISCARD, c->config->retransmit_timeout, st);
			break;

		default:
			bad_case(event_type);
		}

		
		{
			enum rc_type w;
			void (*jam_details)(struct jambuf *buf, struct state *st);

			if (IS_IPSEC_SA_ESTABLISHED(st)) {
				pstat_sa_established(st);
				jam_details = jam_v1_ipsec_details;
				w = RC_SUCCESS; 
			} else if (IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
				pstat_sa_established(st);
				jam_details = jam_v1_isakmp_details;
				w = RC_SUCCESS; 
			} else {
				jam_details = NULL;
				w = RC_NEW_V1_STATE + st->st_state->kind;
			}

			passert(st->st_state->kind < STATE_IKEv1_ROOF);

			
			LLOG_JAMBUF(w, st->st_logger, buf) {
				jam(buf, "%s", st->st_state->story);
				
				if (jam_details != NULL) {
					jam(buf, " ");
					jam_details(buf, st);
				}
			}
		}

		
		if (IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
			if (dpd_init(st) != STF_OK) {
				log_state(RC_LOG_SERIOUS, st, "DPD initialization failed - continuing without DPD");
			}
		}

		
		if (st->st_connection->local->config->host.xauth.server) {
			if (st->st_oakley.doing_xauth && IS_V1_ISAKMP_SA_ESTABLISHED(st)) {
				dbg("XAUTH: Sending XAUTH Login/Password Request");
				event_schedule(EVENT_v1_SEND_XAUTH, deltatime_ms(EVENT_v1_SEND_XAUTH_DELAY_MS), st);

				break;
			}
		}

		
		if (!IS_V1_QUICK(st->st_state->kind) && st->st_connection->local->config->host.xauth.client && !st->hidden_variables.st_xauth_client_done) {

			dbg("XAUTH client is not yet authenticated");
			break;
		}

		
		dbg("modecfg pull: %s policy:%s %s", (st->quirks.modecfg_pull_mode ? "quirk-poll" : "noquirk"), (st->st_connection->policy & POLICY_MODECFG_PULL) ? "pull" : "push", (st->st_connection->spd.this.modecfg_client ? "modecfg-client" : "not-client"));






		if (st->st_connection->spd.this.modecfg_client && IS_V1_ISAKMP_SA_ESTABLISHED(st) && (st->quirks.modecfg_pull_mode || st->st_connection->policy & POLICY_MODECFG_PULL) && !st->hidden_variables.st_modecfg_started) {



			dbg("modecfg client is starting due to %s", st->quirks.modecfg_pull_mode ? "quirk" :
			    "policy");
			modecfg_send_request(st);
			break;
		}

		
		if (st->st_connection->spd.this.modecfg_server && IS_V1_ISAKMP_SA_ESTABLISHED(st) && !st->hidden_variables.st_modecfg_vars_set && !(st->st_connection->policy & POLICY_MODECFG_PULL)) {


			change_v1_state(st, STATE_MODE_CFG_R1);
			log_state(RC_LOG, st, "Sending MODE CONFIG set");
			
			modecfg_start_set(st);
			break;
		}

		
		if (st->st_connection->spd.this.modecfg_client && IS_V1_ISAKMP_SA_ESTABLISHED(st) && !st->hidden_variables.st_modecfg_vars_set) {

			dbg("waiting for modecfg set from server");
			break;
		}

		dbg("phase 1 is done, looking for phase 2 to unpend");

		if (smc->flags & SMF_RELEASE_PENDING_P2) {
			
			unpend(pexpect_ike_sa(st), NULL);
		}

		if (IS_V1_ISAKMP_SA_ESTABLISHED(st) || IS_IPSEC_SA_ESTABLISHED(st))
			release_whack(st->st_logger, HERE);

		if (IS_V1_QUICK(st->st_state->kind))
			break;

		break;
	}

	case STF_INTERNAL_ERROR:
		
		remember_received_packet(st, md);
		log_state(RC_INTERNALERR + md->v1_note, st, "state transition function for %s had internal error", st->st_state->name);

		release_pending_whacks(st, "internal error");
		break;

	case STF_FATAL:
		passert(st != NULL);
		
		remember_received_packet(st, md);
		log_state(RC_FATAL, st, "encountered fatal error in state %s", st->st_state->name);

		if (st->st_connection->remotepeertype == CISCO && st->st_connection->nmconfigured) {
			if (!do_command(st->st_connection, &st->st_connection->spd, "disconnectNM", st, st->st_logger))


				dbg("sending disconnect to NM failed, you may need to do it manually");
		}

		release_pending_whacks(st, "fatal error");
		delete_state(st);
		md->v1_st = st = NULL;
		break;

	case STF_FAIL_v1N:
	default:
	{
		passert(result >= STF_FAIL_v1N);
		md->v1_note = result - STF_FAIL_v1N;
		
		
		enum_buf neb; 
		const char *notify_name = (md->v1_note == v1N_NOTHING_WRONG ? "failed" :
					   str_enum_short(&v1_notification_names, md->v1_note, &neb));
		if (notify_name == NULL) {
			notify_name = "internal error";
		}
		

		if (md->v1_note != v1N_NOTHING_WRONG) {
			
			SEND_NOTIFICATION(md->v1_note);
		} else {
			
			log_state(WHACK_STREAM | (RC_NOTIFICATION + md->v1_note), st, "state transition failed: %s", notify_name);
		}

		dbg("state transition function for %s failed: %s", st->st_state->name, notify_name);


		if (st->st_connection->remotepeertype == CISCO && st->st_connection->nmconfigured) {
			if (!do_command(st->st_connection, &st->st_connection->spd, "disconnectNM", st, st->st_logger))


				dbg("sending disconnect to NM failed, you may need to do it manually");
		}

		if (IS_V1_QUICK(st->st_state->kind)) {
			delete_state(st);
			
			md->v1_st = NULL;
		} else if  (st->st_state->kind == STATE_AGGR_R0 || st->st_state->kind == STATE_AGGR_R1 || st->st_state->kind == STATE_MAIN_R0) {

			
			delete_state(st);
			
			md->v1_st = NULL;
		}

		break;
	}
	}
}

void doi_log_cert_thinking(uint16_t auth, enum ike_cert_type certtype, enum certpolicy policy, bool gotcertrequest, bool send_cert, bool send_chain)




{
	if (DBGP(DBG_BASE)) {
		DBG_log("thinking about whether to send my certificate:");

		esb_buf oan;
		esb_buf ictn;
		DBG_log("  I have RSA key: %s cert.type: %s ", enum_show(&oakley_auth_names, auth, &oan), enum_show(&ike_cert_type_names, certtype, &ictn));


		esb_buf cptn;
		DBG_log("  sendcert: %s and I did%s get a certificate request ", enum_show(&certpolicy_type_names, policy, &cptn), gotcertrequest ? "" : " not");


		DBG_log("  so %ssend cert.", send_cert ? "" : "do not ");

		if (!send_cert) {
			if (auth == OAKLEY_PRESHARED_KEY) {
				DBG_log("I did not send a certificate because digital signatures are not being used. (PSK)");
			} else if (certtype == CERT_NONE) {
				DBG_log("I did not send a certificate because I do not have one.");
			} else if (policy == CERT_SENDIFASKED) {
				DBG_log("I did not send my certificate because I was not asked to.");
			} else {
				DBG_log("INVALID AUTH SETTING: %d", auth);
			}
		}
		if (send_chain)
			DBG_log("Sending one or more authcerts");
	}
}



void ISAKMP_SA_established(const struct ike_sa *ike)
{
	struct connection *c = ike->sa.st_connection;
	
	bool new_uses_authnull = c->remote->config->host.auth == AUTH_NULL;

	if (c->local->config->host.xauth.server && c->remote->config->host.auth == AUTH_PSK) {
		
		dbg("We are a server using PSK and clients are using a group ID");
	} else if (!uniqueIDs) {
		dbg("uniqueIDs disabled, not contemplating releasing older self");
	} else {
		
		struct connection_filter cf = { .where = HERE, };
		while (next_connection_new2old(&cf)) {
			struct connection *d = cf.c;

			
			if (c != d && c->kind == d->kind && streq(c->name, d->name) && same_id(&c->local->host.id, &d->local->host.id) && same_id(&c->remote->host.id, &d->remote->host.id)) {



				bool old_uses_nullauth = d->remote->config->host.auth == AUTH_NULL;
				bool same_remote_ip = sameaddr(&c->remote->host.addr, &d->remote->host.addr);

				if (same_remote_ip && !old_uses_nullauth && new_uses_authnull) {
					llog_sa(RC_LOG, ike, "cannot replace old authenticated connection with authnull connection");
				} else if (!same_remote_ip && old_uses_nullauth && new_uses_authnull) {
					llog_sa(RC_LOG, ike, "NULL auth ID for different IP's cannot replace each other");
				} else {
					dbg("unorienting old connection with same IDs");
					
					suppress_delete_notify(ike, "ISAKMP", d->newest_ike_sa);
					suppress_delete_notify(ike, "IKE", d->newest_ipsec_sa);
					
					if (d->kind == CK_INSTANCE) {
						delete_connection(&d);
					} else {
						
						release_connection(d);
					}
				}
			}
		}
	}

	
	if (DBGP(DBG_PRIVATE)) {
		DBG_tcpdump_ike_sa_keys(&ike->sa);
	}

	c->newest_ike_sa = ike->sa.st_serialno;
}



pb_stream reply_stream;
