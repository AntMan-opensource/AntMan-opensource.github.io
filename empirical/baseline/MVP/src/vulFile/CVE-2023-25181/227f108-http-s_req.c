
































static  void                 HTTPsReq_MethodParse                    (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  CPU_BOOLEAN          HTTPsReq_URI_Parse                      (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  void                 HTTPsReq_QueryStrParse                  (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);



static  CPU_BOOLEAN          HTTPsReq_QueryStrKeyValBlkAdd           (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, CPU_CHAR         *p_str, CPU_SIZE_T        str_len, HTTPs_ERR        *p_err);





static  void                 HTTPsReq_ProtocolVerParse               (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  void                 HTTPsReq_HdrParse                       (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  CPU_CHAR            *HTTPsReq_HdrParseValGet                 (CPU_CHAR         *p_field, CPU_INT16U        field_len, CPU_CHAR         *p_field_end, CPU_INT16U       *p_len_rem);




static  CPU_BOOLEAN          HTTPsReq_BodyForm                       (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  CPU_BOOLEAN          HTTPsReq_BodyFormAppParse               (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_connn, HTTPs_ERR        *p_err);


static  CPU_BOOLEAN          HTTPsReq_BodyFormAppKeyValBlkAdd        (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, CPU_CHAR         *p_str, CPU_SIZE_T        str_len, HTTPs_ERR        *p_err);





static  CPU_BOOLEAN          HTTPsReq_BodyFormMultipartParse         (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  CPU_CHAR            *HTTPsReq_BodyFormMultipartBoundarySrch  (CPU_CHAR         *p_boundary, CPU_INT08U        boundary_len, CPU_CHAR         *p_buf, CPU_INT16U        buf_len, CPU_CHAR        **p_boundary_sep);




static  CPU_BOOLEAN          HTTPsReq_BodyFormMultipartCtrlParse     (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);


static  CPU_BOOLEAN          HTTPsReq_BodyFormMultipartFileWr        (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_ERR        *p_err);





static  CPU_BOOLEAN          HTTPsReq_URL_EncodeStrParse             (HTTPs_INSTANCE   *p_instance, HTTPs_CONN       *p_conn, HTTPs_KEY_VAL   *p_key_val, CPU_BOOLEAN      from_query, CPU_CHAR         *p_str, CPU_SIZE_T        str_len);









void  HTTPsReq_Handle (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn)
{
    const  HTTPs_CFG             *p_cfg;
           CPU_BOOLEAN            accepted;
           HTTPs_INSTANCE_STATS  *p_ctr_stats;
           HTTPs_INSTANCE_ERRS   *p_ctr_err;
           HTTPs_ERR              err;
           CPU_BOOLEAN            done;
           CPU_BOOLEAN            hook_def;
           CPU_BOOLEAN            is_query_str_found;


    p_cfg = (HTTPs_CFG *)p_instance->CfgPtr;

    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);
    HTTPs_SET_PTR_ERRS( p_ctr_err,   p_instance);

    done = DEF_NO;
    while (done != DEF_YES) {
        switch (p_conn->State) {

            case HTTPs_CONN_STATE_REQ_INIT:
                 HTTPs_STATS_INC(p_ctr_stats->Req_StatRxdCtr);

                 p_conn->HdrType = HTTPs_HDR_TYPE_REQ;

                 p_conn->State   = HTTPs_CONN_STATE_REQ_PARSE_METHOD;
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_PARSE_METHOD:
                 HTTPsReq_MethodParse(p_instance, p_conn, &err);
                 switch (err) {
                     case HTTPs_ERR_NONE:                                    
                          p_conn->State = HTTPs_CONN_STATE_REQ_PARSE_URI;    
                          break;

                     default:                                                
                          HTTPs_ERR_INC(p_ctr_err->Req_ErrInvalidCtr);       
                          p_conn->ErrCode   = err;
                          p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                          p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                          done              = DEF_YES;                       
                          break;
                 }
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_PARSE_URI:
                 is_query_str_found = HTTPsReq_URI_Parse(p_instance, p_conn, &err);
                 switch (err) {
                     case HTTPs_ERR_NONE:                            
                          if (is_query_str_found == DEF_YES) {       
                              p_conn->State = HTTPs_CONN_STATE_REQ_PARSE_QUERY_STRING;
                          } else {
                              p_conn->State = HTTPs_CONN_STATE_REQ_PARSE_PROTOCOL_VERSION;
                          }
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:          
                          p_conn->SockState = HTTPs_SOCK_STATE_RX;   
                          done                = DEF_YES;
                          break;

                     default:                                        
                          HTTPs_ERR_INC(p_ctr_err->Req_ErrInvalidCtr); 
                          p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                          p_conn->ErrCode   = err;
                          p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                          done              = DEF_YES;               
                          break;
                 }
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_PARSE_QUERY_STRING:
                 HTTPsReq_QueryStrParse(p_instance, p_conn, &err);
                 switch (err) {
                     case HTTPs_ERR_NONE:                            
                                                                     
                          p_conn->State = HTTPs_CONN_STATE_REQ_PARSE_PROTOCOL_VERSION;
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:          
                          p_conn->SockState = HTTPs_SOCK_STATE_RX;   
                          done              = DEF_YES;
                          break;

                     default:                                        
                          HTTPs_ERR_INC(p_ctr_err->Req_ErrInvalidCtr); 
                          p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                          p_conn->ErrCode   = err;
                          p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                          done              = DEF_YES;               
                          break;
                 }
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_PARSE_PROTOCOL_VERSION:
                 HTTPsReq_ProtocolVerParse(p_instance, p_conn, &err);
                    switch (err) {
                        case HTTPs_ERR_NONE:                            
                                                                        
                             p_conn->State        = HTTPs_CONN_STATE_REQ_PARSE_HDR;
                             p_conn->SockState    = HTTPs_SOCK_STATE_NONE;
                             DEF_BIT_CLR(p_conn->Flags, HTTPs_FLAG_RESP_LOCATION);
                             break;

                        case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:          
                             p_conn->SockState = HTTPs_SOCK_STATE_RX;   
                             done              = DEF_YES;               
                             break;

                        default:                                      
                             HTTPs_ERR_INC(p_ctr_err->Req_ErrInvalidCtr); 
                             p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                             p_conn->ErrCode   = err;
                             p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                             done                = DEF_YES;             
                             break;
                    }
                    break;

                                                                
            case HTTPs_CONN_STATE_REQ_PARSE_HDR:
                 HTTPsReq_HdrParse(p_instance, p_conn, &err);   
                 switch (err) {
                     case HTTPs_ERR_NONE:                       
                                                                
                          p_conn->State     = HTTPs_CONN_STATE_REQ_LINE_HDR_HOOK;
                          p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                          HTTPs_STATS_INC(p_ctr_stats->Req_StatProcessedCtr);
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:     
                          p_conn->SockState = HTTPs_SOCK_STATE_RX; 
                          done              = DEF_YES;          
                          break;

                     default:                                    
                         HTTPs_ERR_INC(p_ctr_err->Req_ErrInvalidCtr); 
                         p_conn->ErrCode = err;
                         p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
                         done            = DEF_YES;              
                         break;
                 }
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_LINE_HDR_HOOK:
                 hook_def = HTTPs_HOOK_DEFINED(p_cfg->HooksPtr, OnReqHook);
                 if (hook_def == DEF_YES) {
                     accepted = p_cfg->HooksPtr->OnReqHook(p_instance, p_conn, p_cfg->Hooks_CfgPtr);

                     if (accepted != DEF_YES) {
                                                                
                         if (p_conn->StatusCode == HTTP_STATUS_OK) {
                             p_conn->StatusCode = HTTP_STATUS_UNAUTHORIZED;
                         }
                         DEF_BIT_SET(p_conn->Flags, HTTPs_FLAG_REQ_FLUSH);
                         p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FLUSH_DATA;
                     }
                 }
                                                                
                 p_conn->State     = HTTPs_CONN_STATE_REQ_BODY_INIT;
                 done              = DEF_YES;                   
                 break;


            default:
                HTTPs_ERR_INC(p_ctr_err->Req_ErrStateUnkownCtr);
                p_conn->ErrCode = HTTPs_ERR_STATE_UNKNOWN;
                p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
                done            = DEF_YES;
                break;
        }
    }
}




void  HTTPsReq_Body (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn)
{
    const  HTTPs_CFG             *p_cfg;
           HTTPs_INSTANCE_STATS  *p_ctr_stats;
           HTTPs_INSTANCE_ERRS   *p_ctr_err;
           CPU_SIZE_T             data_len_rd;
           CPU_BOOLEAN            hook_continue;
           CPU_BOOLEAN            done;
           CPU_BOOLEAN            body_hook_def;
           CPU_BOOLEAN            req_flushed;

           CPU_BOOLEAN            parse_done;
           HTTPs_ERR              err;



    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);
    HTTPs_SET_PTR_ERRS (p_ctr_err, p_instance);

    p_cfg = p_instance->CfgPtr;

    done = DEF_NO;
    while (done == DEF_NO) {
        switch (p_conn->State) {
                                                                
            case HTTPs_CONN_STATE_REQ_BODY_INIT:

                 p_conn->ReqContentLenRxd = 0u;                 

                                                                
                 if (p_conn->ReqContentLen == 0) {              
                                                                
                     p_conn->SockState   = HTTPs_SOCK_STATE_NONE;
                     p_conn->State       = HTTPs_CONN_STATE_REQ_READY_SIGNAL;
                     p_conn->RxBufLenRem = 0;
                     done                = DEF_YES;

                 } else {                                       

                     switch (p_conn->Method) {                  
                        case HTTP_METHOD_GET:
                             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodGetProcessedCtr);
                             break;

                        case HTTP_METHOD_HEAD:
                             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodHeadProcessedCtr);
                             break;

                        case HTTP_METHOD_DELETE:
                             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodDeleteProcessedCtr);
                             break;

                        case HTTP_METHOD_PUT:
                             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodPutProcessedCtr);
                             break;

                        case HTTP_METHOD_POST:
                                                                
                                                                

                             if (p_conn->ReqContentType == HTTP_CONTENT_TYPE_APP_FORM) {
                                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_APP_PARSE;
                             } else if (p_conn->ReqContentType == HTTP_CONTENT_TYPE_MULTIPART_FORM) {
                                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT;
                             } else {
                                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             }

                             HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyFormNotEn);
                             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_DATA;

                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodPostProcessedCtr);
                             break;

                        default:
                             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodUnsupportedProcessedCtr);
                             p_conn->ErrCode = HTTPs_ERR_REQ_METHOD_NOT_SUPPORTED;
                             p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
                             goto exit;
                     }

                     if (p_conn->RxBufLenRem == 0) {            
                         p_conn->SockState = HTTPs_SOCK_STATE_RX;  
                         done              = DEF_YES;
                     } else {
                         p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                     }
                 }
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_BODY_DATA:
                 body_hook_def = HTTPs_HOOK_DEFINED(p_cfg->HooksPtr, OnReqBodyRxHook);
                                                                
                 if (body_hook_def == DEF_TRUE) {
                                                                
                     hook_continue = p_cfg->HooksPtr->OnReqBodyRxHook(p_instance, p_conn, p_cfg->Hooks_CfgPtr, p_conn->RxBufPtr, p_conn->RxBufLenRem, &data_len_rd);





                     if ((data_len_rd         > p_conn->RxBufLenRem) && (p_conn->RxBufLenRem > 0)                   ){
                         p_conn->ErrCode = HTTPs_ERR_REQ_BODY_FAULT;
                         p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
                         goto exit;
                     }

                                                                
                     p_conn->RxBufLenRem      -= data_len_rd;
                     p_conn->ReqContentLenRxd += data_len_rd;
                     p_conn->RxBufPtr         += data_len_rd;

                     if (hook_continue == DEF_NO) {             
                                                                
                         p_conn->State     = HTTPs_CONN_STATE_REQ_BODY_FLUSH_DATA;
                         p_conn->SockState = HTTPs_SOCK_STATE_RX;

                     } else {
                                                                
                         if (p_conn->ReqContentLenRxd < p_conn->ReqContentLen) {
                                                                
                             p_conn->State     = HTTPs_CONN_STATE_REQ_BODY_DATA;
                             p_conn->SockState = HTTPs_SOCK_STATE_RX;
                         } else {
                                                                
                             p_conn->State     = HTTPs_CONN_STATE_REQ_READY_SIGNAL;
                             p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                         }
                     }
                 } else {                                       
                    p_conn->State     = HTTPs_CONN_STATE_REQ_BODY_FLUSH_DATA;
                    p_conn->SockState = HTTPs_SOCK_STATE_RX;
                 }
                 done = DEF_YES;
                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_BODY_FORM_APP_PARSE:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_PARSE:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR:

                 parse_done = HTTPsReq_BodyForm(p_instance, p_conn, &err);
                 switch (err) {
                     case HTTPs_ERR_NONE:
                          if (parse_done == DEF_YES) {
                              p_conn->State     = HTTPs_CONN_STATE_REQ_READY_SIGNAL;
                              p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                              done = DEF_YES;
                          }
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:
                          done              = DEF_YES;
                          p_conn->SockState = HTTPs_SOCK_STATE_RX;
                          break;

                     default:
                         done              = DEF_YES;
                         p_conn->ErrCode   = err;
                         p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                         p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                         HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyPostFormCtr);
                         break;
                 }

                 HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyFormNotEn);
                 p_conn->ErrCode   = HTTPs_ERR_CFG_INVALID_FORM_EN;
                 p_conn->State     = HTTPs_CONN_STATE_ERR_INTERNAL;
                 p_conn->SockState = HTTPs_SOCK_STATE_NONE;

                 break;

                                                                
            case HTTPs_CONN_STATE_REQ_BODY_FLUSH_DATA:
                 p_conn->ReqContentLenRxd += p_conn->RxBufLenRem;
                 p_conn->RxBufLenRem       = 0;

                 if ((p_conn->ReqContentLen    == 0                    ) || (p_conn->ReqContentLenRxd >= p_conn->ReqContentLen)) {

                                                                
                     req_flushed = DEF_BIT_IS_SET(p_conn->Flags, HTTPs_FLAG_REQ_FLUSH);
                     if (req_flushed == DEF_YES) {
                         p_conn->State = HTTPs_CONN_STATE_RESP_PREPARE;
                     } else {
                         p_conn->State = HTTPs_CONN_STATE_REQ_READY_SIGNAL;
                     }
                     p_conn->SockState = HTTPs_SOCK_STATE_NONE;
                 } else {
                                                                
                     p_conn->State     = HTTPs_CONN_STATE_REQ_BODY_FLUSH_DATA;
                     p_conn->SockState = HTTPs_SOCK_STATE_RX;
                 }
                 done = DEF_YES;
                 break;


            default:
                 HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyStateUnknownCtr);
                 p_conn->ErrCode = HTTPs_ERR_STATE_UNKNOWN;
                 p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
                 goto exit;
            }
    }


exit:
    return;
}




CPU_BOOLEAN  HTTPsReq_RdySignal (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn)
{
    const  HTTPs_CFG      *p_cfg        = p_instance->CfgPtr;
           HTTPs_KEY_VAL  *p_key_val    = DEF_NULL;
           CPU_BOOLEAN     hook_def     = DEF_NO;
           CPU_BOOLEAN     process_done = DEF_NO;



    p_key_val = p_conn->FormDataListPtr;


    switch (p_conn->State) {
                                                                
        case HTTPs_CONN_STATE_REQ_READY_SIGNAL:
             hook_def = HTTPs_HOOK_DEFINED(p_cfg->HooksPtr, OnReqRdySignalHook);
             if (hook_def == DEF_YES) {
                                                                
                 process_done = p_cfg->HooksPtr->OnReqRdySignalHook(p_instance, p_conn, p_cfg->Hooks_CfgPtr, (const HTTPs_KEY_VAL *)p_key_val);



                 if (process_done != DEF_YES) {
                     p_conn->State = HTTPs_CONN_STATE_REQ_READY_POLL;
                 }

             } else {
                 process_done = DEF_YES;
             }
             break;


                                                                
        case HTTPs_CONN_STATE_REQ_READY_POLL:
             hook_def = HTTPs_HOOK_DEFINED(p_cfg->HooksPtr, OnReqRdyPollHook);
             if (hook_def == DEF_YES) {
                                                                
                 process_done = p_cfg->HooksPtr->OnReqRdyPollHook(p_instance, p_conn, p_cfg->Hooks_CfgPtr);


             } else {
                 process_done = DEF_YES;
             }
             break;


        default:
             process_done    = DEF_YES;
             p_conn->ErrCode = HTTPs_ERR_STATE_UNKNOWN;
             p_conn->State   = HTTPs_CONN_STATE_ERR_INTERNAL;
    }

    return (process_done);
}







static  void  HTTPsReq_MethodParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    CPU_CHAR              *p_request_method_start;
    CPU_CHAR              *p_request_method_end;
    CPU_SIZE_T             len;
    HTTPs_INSTANCE_STATS  *p_ctr_stats;
    CPU_INT32U             method;


    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);

    len = p_conn->RxBufLenRem;

    if (len <= sizeof(HTTP_STR_METHOD_GET)) {                   
       *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
        return;
    }
                                                                
    p_request_method_start = HTTP_StrGraphSrchFirst(p_conn->RxBufPtr, len);
    if (p_request_method_start == DEF_NULL) {
       *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
        return;
    }
    len -= p_request_method_start - p_conn->RxBufPtr ;
                                                                
    p_request_method_end =  Str_Char_N(p_request_method_start, len, ASCII_CHAR_SPACE);
    if (p_request_method_end == DEF_NULL) {
       *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
        return;
    }
    len = p_request_method_end - p_request_method_start;
                                                                
    method = HTTP_Dict_KeyGet(HTTP_Dict_ReqMethod, HTTP_Dict_ReqMethodSize, p_request_method_start, DEF_YES, len);



                                                                
    if (method == HTTP_DICT_KEY_INVALID) {
        p_conn->Method = HTTP_METHOD_UNKNOWN;
    } else {
        p_conn->Method = (HTTP_METHOD)method;
    }

    switch (p_conn->Method) {
        case HTTP_METHOD_GET:
             p_conn->RespBodyDataType = HTTPs_BODY_DATA_TYPE_FILE;
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodGetRxdCtr);
             break;

        case HTTP_METHOD_HEAD:
             p_conn->RespBodyDataType = HTTPs_BODY_DATA_TYPE_FILE;
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodHeadRxdCtr);
             break;

        case HTTP_METHOD_POST:
             p_conn->RespBodyDataType = HTTPs_BODY_DATA_TYPE_NONE;
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodPostRxdCtr);
             break;

        case HTTP_METHOD_DELETE:
             p_conn->RespBodyDataType = HTTPs_BODY_DATA_TYPE_NONE;
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodDeleteRxdCtr);
             break;

        case HTTP_METHOD_PUT:
             p_conn->RespBodyDataType = HTTPs_BODY_DATA_TYPE_NONE;
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodPutRxdCtr);
             break;

        case HTTP_METHOD_TRACE:
        case HTTP_METHOD_CONNECT:
        case HTTP_METHOD_UNKNOWN:
        default:
             HTTPs_STATS_INC(p_ctr_stats->Req_StatMethodUnsupportedRxdCtr);
            *p_err = HTTPs_ERR_REQ_METHOD_NOT_SUPPORTED;
             return;
    }
                                                                
    p_conn->RxBufLenRem -= len;
    p_conn->RxBufPtr     = p_request_method_end;

   *p_err = HTTPs_ERR_NONE;
}



static  CPU_BOOLEAN  HTTPsReq_URI_Parse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    const  HTTPs_CFG   *p_cfg;
           CPU_CHAR    *p_request_uri_start;
           CPU_CHAR    *p_request_uri_end;
           CPU_CHAR    *p_request_uri_separator;
           CPU_INT32U   len;
           CPU_SIZE_T   len_decoded;
           CPU_BOOLEAN  is_query_found;


    p_cfg          = p_instance->CfgPtr;
    is_query_found = DEF_NO;
    len            = p_conn->RxBufLenRem;
                                                                
    p_request_uri_start = HTTP_StrGraphSrchFirst(p_conn->RxBufPtr, len);
    if (p_request_uri_start == DEF_NULL) {
       *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
        return (is_query_found);
    }
                                                                
                                                                
    len -= p_request_uri_start - p_conn->RxBufPtr ;
    p_request_uri_end =  Str_Char_N(p_request_uri_start, len, ASCII_CHAR_SPACE);
    if (p_request_uri_end != DEF_NULL) {
        len = p_request_uri_end - p_request_uri_start;          
    }
                                                                
    p_request_uri_separator = Str_Char_N(p_request_uri_start, len, ASCII_CHAR_QUESTION_MARK);
    if (p_request_uri_separator == DEF_NULL) {                  
        if (p_request_uri_end == DEF_NULL) {
            if (p_conn->RxBufPtr != p_conn->BufPtr) {           
                                                                
               *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
            } else {
                                                                
               *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
            }
            return (is_query_found);
        }

    } else {
        is_query_found = DEF_YES;
        len            = p_request_uri_separator - p_request_uri_start;
    }

    if (len > p_conn->PathLenMax) {                             
       *p_err = HTTPs_ERR_REQ_URI_LEN;                          
        return (is_query_found);
    }

    p_request_uri_start[len] = ASCII_CHAR_NULL;                 



    if (len > 1) {                                              
                                                                
        len_decoded = len;

        HTTP_URL_DecodeStr(p_request_uri_start, p_conn->PathPtr, &len_decoded);


        p_conn->PathPtr[len_decoded] = ASCII_CHAR_NULL;

    } else {                                                    
                                                                
        Str_Copy_N(p_conn->PathPtr, p_cfg->DfltResourceNamePtr, p_conn->PathLenMax);

    }
                                                                
    p_conn->RxBufLenRem -= (&p_request_uri_start[len] - p_conn->RxBufPtr) + 1;
    p_conn->RxBufPtr     =  &p_request_uri_start[len] + 1;

   *p_err = HTTPs_ERR_NONE;

    return (is_query_found);
}




static  void  HTTPsReq_QueryStrParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    CPU_CHAR     *p_req_line_end   = DEF_NULL;
    CPU_CHAR     *p_query_str_end  = DEF_NULL;
    CPU_CHAR     *p_field_start    = DEF_NULL;
    CPU_CHAR     *p_field_end      = DEF_NULL;
    CPU_INT32U    len              = p_conn->RxBufLenRem;
    CPU_INT32U    len_rd           = 0;
    CPU_INT32U    key_val_pair_len = 0;
    CPU_BOOLEAN   done             = DEF_NO;

    CPU_BOOLEAN   success          = DEF_NO;



                                                                
    p_req_line_end = Str_Str_N(p_conn->RxBufPtr, STR_CR_LF, len);
    if (p_req_line_end != DEF_NULL) {
        len = p_req_line_end - p_conn->RxBufPtr;
    }

                                                                
    p_query_str_end = Str_Char_N(p_conn->RxBufPtr, len, ASCII_CHAR_SPACE);
    if (p_query_str_end != DEF_NULL) {
        len = p_query_str_end - p_conn->RxBufPtr + 1;           
    }

    p_field_start = p_conn->RxBufPtr;

    while (done == DEF_NO) {
                                                                
        p_field_end = Str_Char_N(p_field_start, len, ASCII_CHAR_AMPERSAND);
        if (p_field_end == DEF_NULL) {                          
            if (p_query_str_end == DEF_NULL) {
                if (len == p_conn->BufLen) {
                   *p_err = HTTPs_ERR_CFG_INVALID_BUF_LEN;
                } else {
                   *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                }
                goto exit_update;
            } else {
                done        = DEF_YES;                          
                p_field_end = p_query_str_end;
            }
        }

                                                                
        key_val_pair_len = p_field_end - p_field_start;
        if (key_val_pair_len == 0u){                            
           *p_err = HTTPs_ERR_NONE;                             
            goto exit_update;
        }


        success = HTTPsReq_QueryStrKeyValBlkAdd(p_instance, p_conn, p_field_start, key_val_pair_len, p_err);



        if (success == DEF_FAIL) {
            goto exit_update;
        }


        p_field_start += (key_val_pair_len + 1);
        len           -= (key_val_pair_len + 1);
        len_rd        += (key_val_pair_len + 1);
    }

   *p_err = HTTPs_ERR_NONE;


exit_update:
    p_conn->RxBufLenRem -= len_rd;
    p_conn->RxBufPtr    += len_rd;

    return;
}




static  CPU_BOOLEAN  HTTPsReq_QueryStrKeyValBlkAdd (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, CPU_CHAR        *p_str, CPU_SIZE_T       str_len, HTTPs_ERR       *p_err)



{
    const  HTTPs_CFG       *p_cfg;
           HTTPs_KEY_VAL   *p_key_val;
           CPU_BOOLEAN      result;


    p_cfg = p_instance->CfgPtr;

    if (p_cfg->QueryStrCfgPtr != DEF_NULL) {

        if (p_cfg->QueryStrCfgPtr->NbrPerConnMax != LIB_MEM_BLK_QTY_UNLIMITED) {
            if (p_conn->QueryStrBlkAcquiredCtr >= p_cfg->QueryStrCfgPtr->NbrPerConnMax) {
               *p_err = HTTPs_ERR_KEY_VAL_CFG_POOL_SIZE_INV;
                return (DEF_FAIL);
            }
        }

        p_key_val = HTTPsMem_QueryStrKeyValBlkGet(p_instance,    p_conn, p_err);

        if (p_key_val == DEF_NULL) {                            
            return (DEF_FAIL);
        }

        result = HTTPsReq_URL_EncodeStrParse(p_instance, p_conn, p_key_val, DEF_YES, p_str, str_len);




        if (result == DEF_FAIL) {
           *p_err = HTTPs_ERR_QUERY_STR_PARSE_FAULT;
            return (DEF_FAIL);
        }

        if (p_conn->QueryStrListPtr == DEF_NULL) {
            p_key_val->NextPtr = DEF_NULL;
        } else {
            p_key_val->NextPtr = p_conn->QueryStrListPtr;
        }

        p_conn->QueryStrListPtr = p_key_val;

    }

   *p_err = HTTPs_ERR_NONE;

    return (DEF_OK);
}





static  void  HTTPsReq_ProtocolVerParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{

    const  HTTPs_CFG             *p_cfg = p_instance->CfgPtr;

           CPU_CHAR              *p_protocol_ver_start;
           CPU_CHAR              *p_protocol_ver_end;
           CPU_INT32U             len;
           CPU_INT32U             protocol_ver;
           HTTPs_INSTANCE_STATS  *p_ctr_stats;


    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);

    len = p_conn->RxBufLenRem;
    if (len == 0) {                                             
       *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
        return;
    }
                                                                
    p_protocol_ver_start = HTTP_StrGraphSrchFirst(p_conn->RxBufPtr, len);
    if (p_protocol_ver_start == DEF_NULL) {
       *p_err               = HTTPs_ERR_REQ_FORMAT_INVALID;
        return;
    }
                                                                
    p_protocol_ver_end = Str_Str_N(p_protocol_ver_start, STR_CR_LF, len);
    if (p_protocol_ver_end == DEF_NULL) {                       
        if (p_conn->RxBufPtr != p_conn->BufPtr) {
           *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
        } else {
           *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
        }
        return;
    }

    len          = p_protocol_ver_end - p_protocol_ver_start;
                                                                
    protocol_ver = HTTP_Dict_KeyGet(HTTP_Dict_ProtocolVer, HTTP_Dict_ProtocolVerSize, p_protocol_ver_start, DEF_YES, len);




                                                                
    if (protocol_ver == HTTP_DICT_KEY_INVALID) {
         p_conn->ProtocolVer =  HTTP_PROTOCOL_VER_UNKNOWN;
    } else {
         p_conn->ProtocolVer = (HTTP_PROTOCOL_VER)protocol_ver;
    }

    switch (p_conn->ProtocolVer) {
        case HTTP_PROTOCOL_VER_0_9:
             HTTPs_STATS_INC(p_ctr_stats->Req_StatProtocolVer0_9Ctr);
             break;

        case HTTP_PROTOCOL_VER_1_0:
             HTTPs_STATS_INC(p_ctr_stats->Req_StatProtocolVer1_0Ctr);
             break;

        case HTTP_PROTOCOL_VER_1_1:

             if (p_cfg->ConnPersistentEn == DEF_ENABLED)
             DEF_BIT_SET(p_conn->Flags, HTTPs_FLAG_CONN_PERSISTENT);

             HTTPs_STATS_INC(p_ctr_stats->Req_StatProtocolVer1_1Ctr);
             break;

        case HTTP_PROTOCOL_VER_UNKNOWN:
        default:
             HTTPs_STATS_INC(p_ctr_stats->Req_StatProtocolVerUnsupportedCtr);
             p_conn->ProtocolVer = HTTP_PROTOCOL_VER_1_1;
            *p_err               = HTTPs_ERR_REQ_PROTOCOL_VER_NOT_SUPPORTED;
             return;
    }
                                                                
    p_conn->RxBufLenRem      -= (p_protocol_ver_end - p_conn->RxBufPtr) + 2;
    p_conn->RxBufPtr          =  p_protocol_ver_end + 2;

   *p_err = HTTPs_ERR_NONE;
}




static  void  HTTPsReq_HdrParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
           CPU_CHAR              *p_field;
           CPU_CHAR              *p_field_end;
           CPU_CHAR              *p_val;
           CPU_INT32U             field_key;
           HTTP_HDR_FIELD         field;
           CPU_INT16U             len;
           HTTPs_INSTANCE_STATS  *p_ctr_stats;

           CPU_CHAR              *p_str;
           HTTPs_INSTANCE_ERRS   *p_ctr_errs;
           HTTP_DICT             *p_field_dict_entry;
           HTTP_HDR_BLK          *p_req_hdr_blk;
           HTTP_HDR_VAL_TYPE      val_type;
           CPU_BOOLEAN            keep;


    const  HTTP_DICT             *p_dictionary;


    const  HTTPs_CFG             *p_cfg;



    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);

    HTTPs_SET_PTR_ERRS( p_ctr_errs,  p_instance);



    p_cfg = p_instance->CfgPtr;


                                                                

    p_field = p_conn->RxBufPtr;                                 
    while (p_field  != DEF_NULL) {                              
        p_field_end  = Str_Str_N(p_field,                        STR_CR_LF, p_conn->RxBufLenRem);



                                                                
        if ((p_field_end != DEF_NULL) &&                         (p_field_end  > p_field) ) {
            len = p_field_end - p_field;
                                                                
            field_key = HTTP_Dict_KeyGet(HTTP_Dict_HdrField, HTTP_Dict_HdrFieldSize, p_field, DEF_NO, len);



            if (field_key != HTTP_DICT_KEY_INVALID) {
                field = (HTTP_HDR_FIELD)field_key;

                                                                
                p_field_dict_entry = HTTP_Dict_EntryGet(HTTP_Dict_HdrField, HTTP_Dict_HdrFieldSize, field);



                                                                
                switch (field) {


                                                                
                    case HTTP_HDR_FIELD_CONTENT_TYPE:
                                                                
                         p_val = HTTPsReq_HdrParseValGet(p_field, HTTP_STR_HDR_FIELD_CONTENT_TYPE_LEN, p_field_end, &len);


                         if (p_val != DEF_NULL) {
                             len       = p_field_end - p_val;
                                                                
                             field_key = HTTP_Dict_KeyGet(HTTP_Dict_ContentType, HTTP_Dict_ContentTypeSize, p_val, DEF_YES, len);



                             if (field_key != HTTP_DICT_KEY_INVALID) {
                                 field = (HTTP_HDR_FIELD)field_key;
                                 p_conn->ReqContentType = (HTTP_CONTENT_TYPE)field;
                                 switch (field) {

                                                                
                                     case HTTP_CONTENT_TYPE_APP_FORM:
                                          HTTPs_STATS_INC(p_ctr_stats->Req_StatContentTypeFormAppRxdCtr);
                                                                
                                          break;


                                                                
                                     case HTTP_CONTENT_TYPE_MULTIPART_FORM:
                                          HTTPs_STATS_INC(p_ctr_stats->Req_StatContentTypeFormMultipartRxdCtr);
                                                                


                                                                
                                                                
                                                                

                                          if ((p_cfg->FormCfgPtr       != DEF_NULL)  && (p_conn->FormBoundaryPtr != DEF_NULL)) {
                                                                
                                              p_dictionary =  HTTP_Dict_EntryGet(HTTP_Dict_ContentType, HTTP_Dict_ContentTypeSize, HTTP_CONTENT_TYPE_MULTIPART_FORM);

                                              p_val        =  p_val + p_dictionary->StrLen + 1;
                                              p_val        =  HTTP_StrGraphSrchFirst(p_val, len);
                                              len          =  len - (p_val - p_field);

                                                                
                                              p_val        =  Str_Str_N(p_val, HTTP_STR_MULTIPART_BOUNDARY, sizeof(HTTP_STR_MULTIPART_BOUNDARY));


                                              if (p_val == DEF_NULL) {
                                                 *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
                                                  return;
                                              }

                                                                
                                              p_val = Str_Char_N(p_val, len, ASCII_CHAR_EQUALS_SIGN);
                                              if (p_val == DEF_NULL) {
                                                 *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
                                                  return;
                                              }

                                              p_val++;          
                                              p_val = HTTP_StrGraphSrchFirst(p_val, len);
                                              len   = p_field_end - p_val;

                                                                
                                              Str_Copy_N(p_conn->FormBoundaryPtr, p_val, len);

                                                                
                                              p_conn->FormBoundaryPtr[len] = ASCII_CHAR_NULL;

                                              p_conn->FormBoundaryLen      = len;
                                          }

                                          break;

                                     case HTTP_CONTENT_TYPE_UNKNOWN:
                                         HTTPs_STATS_INC(p_ctr_stats->Req_StatContentTypeUnknownRxdCtr);
                                         break;

                                     default:
                                         HTTPs_STATS_INC(p_ctr_stats->Req_StatContentTypeOtherRxdCtr);
                                         break;
                                 }
                             }

                         } else {                               
                            *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                             return;
                         }
                         break;


                                                                
                    case HTTP_HDR_FIELD_CONTENT_LEN:
                                                                
                         p_val = HTTPsReq_HdrParseValGet(p_field, HTTP_STR_HDR_FIELD_CONTENT_LEN_LEN, p_field_end, &len);



                                                                
                         p_conn->ReqContentLen = Str_ParseNbr_Int32U(p_val, 0, DEF_NBR_BASE_DEC);
                         break;


                                                                
                    case HTTP_HDR_FIELD_HOST:

                                                                
                         p_val = HTTPsReq_HdrParseValGet(p_field, HTTP_STR_HDR_FIELD_HOST_LEN, p_field_end, &len);



                         len   = DEF_MIN(len, p_cfg->HostNameLenMax);

                                                                
                         (void)Str_Copy_N(p_conn->HostPtr, p_val, len);
                                                                
                         p_conn->HostPtr[len] = ASCII_CHAR_NULL;

                         break;


                                                                
                    case HTTP_HDR_FIELD_CONN:
                                                                
                         p_val = HTTPsReq_HdrParseValGet(p_field, HTTP_STR_HDR_FIELD_CONN_LEN, p_field_end, &len);


                         if (p_val != DEF_NULL) {
                             len = p_field_end - p_val;
                                                                
                             field_key = HTTP_Dict_KeyGet(HTTP_Dict_HdrFieldConnVal, HTTP_Dict_HdrFieldConnValSize, p_val, DEF_NO, len);



                             if (field_key != HTTP_DICT_KEY_INVALID) {
                                 switch (field_key) {
                                     case HTTP_HDR_FIELD_CONN_CLOSE:
                                          DEF_BIT_CLR(p_conn->Flags, HTTPs_FLAG_CONN_PERSISTENT);
                                          break;

                                     case HTTP_HDR_FIELD_CONN_PERSISTENT:
                                     default:
                                          break;
                                 }
                             }
                         }
                         break;


                    default:

                         if ((p_cfg->HdrRxCfgPtr != DEF_NULL) && (p_cfg->HooksPtr    != DEF_NULL)) {
                             keep = p_cfg->HooksPtr->OnReqHdrRxHook(p_instance, p_conn, p_cfg->Hooks_CfgPtr, field);



                             if ((keep                              == DEF_YES                  ) && (p_cfg->HdrRxCfgPtr->NbrPerConnMax != LIB_MEM_BLK_QTY_UNLIMITED)) {
                                 if (p_conn->HdrCtr >= p_cfg->HdrRxCfgPtr->NbrPerConnMax) {
                                    *p_err = HTTPs_ERR_REQ_HDR_OVERFLOW;
                                     return;
                                 }
                             }

                             if (keep == DEF_YES) {
                                val_type = HTTP_HDR_VAL_TYPE_STR_DYN;   

                                                                
                                p_req_hdr_blk = HTTPsMem_ReqHdrGet(                p_instance, p_conn, (HTTP_HDR_FIELD)field, val_type, p_err);



                                if (p_req_hdr_blk == DEF_NULL) {
                                    return;
                                }

                                p_val = HTTPsReq_HdrParseValGet(p_field, p_field_dict_entry->StrLen, p_field_end, &len);


                                if (p_val != DEF_NULL) {
                                    len = p_field_end - p_val;

                                    if (len > p_cfg->HdrRxCfgPtr->DataLenMax) {
                                        HTTPs_ERR_INC(p_ctr_errs->Req_ErrHdrDataLenInv);
                                       *p_err = HTTPS_ERR_REQ_HDR_INVALID_VAL_LEN;
                                        return;
                                    }

                                                                
                                    Mem_Copy((void       *) p_req_hdr_blk->ValPtr, (const void *) p_val, (CPU_SIZE_T  ) len);

                                                                
                                    p_str                 = (CPU_CHAR *)p_req_hdr_blk->ValPtr + len;
                                   *p_str                 =  ASCII_CHAR_NULL;
                                    p_req_hdr_blk->ValLen =  len + 1;

                                } else {
                                   *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                                    return;
                                }
                            }
                         }

                         break;
                }
            }

                                                                
            p_field_end         += STR_CR_LF_LEN;
            p_conn->RxBufLenRem -= p_field_end - p_field;
            p_field              = p_field_end;
            p_conn->RxBufPtr     = p_field;

        } else if (p_field_end  == p_field) {                   
            p_conn->RxBufPtr    += STR_CR_LF_LEN;
            p_conn->RxBufLenRem -= STR_CR_LF_LEN;
           *p_err = HTTPs_ERR_NONE;
            return;

        } else {                                                
            if (p_conn->RxBufPtr != p_conn->BufPtr) {           
               *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
            } else {
               *p_err = HTTPs_ERR_REQ_FORMAT_INVALID;
            }
            return;
        }
    }
}



static  CPU_CHAR  *HTTPsReq_HdrParseValGet (CPU_CHAR    *p_field, CPU_INT16U   field_len, CPU_CHAR    *p_field_end, CPU_INT16U  *p_len_rem)


{
    CPU_INT16U   len;
    CPU_CHAR    *p_val;


    p_val     =  p_field + field_len;
    len       = (p_field_end - p_val);

    p_val     =  Str_Char_N(p_val, len, ASCII_CHAR_COLON);      
    p_val++;

    len       = (p_field_end - p_val);
    p_val     =  HTTP_StrGraphSrchFirst(p_val, len);            

   *p_len_rem = (p_field_end - p_val);

    return (p_val);
}




static  CPU_BOOLEAN  HTTPsReq_BodyForm (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    HTTPs_INSTANCE_ERRS   *p_ctr_err;
    CPU_BOOLEAN            done;


    HTTPs_SET_PTR_ERRS (p_ctr_err, p_instance);

    done = DEF_YES;

    switch (p_conn->State) {
                                                                
        case HTTPs_CONN_STATE_REQ_BODY_FORM_APP_PARSE:
                                                                
             done = HTTPsReq_BodyFormAppParse(p_instance, p_conn, p_err);
             break;

        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT:
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_PARSE:
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN:
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR:
                                                                

             done = HTTPsReq_BodyFormMultipartParse(p_instance, p_conn, p_err);

             HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyFormMultipartNotEn);
            *p_err = HTTPs_ERR_CFG_INVALID_FORM_MULTIPART_EN;

             break;

        default:
             HTTPs_ERR_INC(p_ctr_err->Req_ErrBodyStateUnknownCtr);
            *p_err = HTTPs_ERR_STATE_UNKNOWN;
             break;
    }

    return (done);
}





static  CPU_BOOLEAN  HTTPsReq_BodyFormAppParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    CPU_CHAR     *p_key_name;
    CPU_CHAR     *p_key_next;
    CPU_INT32U    len_content_rxd;
    CPU_INT16U    len_str;
    CPU_BOOLEAN   done;
    CPU_BOOLEAN   result;


    done = DEF_NO;
                                                                
                                                                
    p_key_name =  HTTP_StrGraphSrchFirst(p_conn->RxBufPtr, p_conn->RxBufLenRem);
    if (p_key_name == DEF_NULL) {
       *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
        goto exit;
    }

    p_conn->RxBufLenRem      -= (p_key_name - p_conn->RxBufPtr); 
    p_conn->ReqContentLenRxd += (p_key_name - p_conn->RxBufPtr); 
    p_conn->RxBufPtr          =  p_key_name;                     

    while (done != DEF_YES) {
                                                                
        p_key_next = Str_Char_N(p_key_name,                      p_conn->RxBufLenRem, ASCII_CHAR_AMPERSAND);


        if (p_key_next == DEF_NULL) {                           
                                                                
                                                                
            len_content_rxd = p_conn->ReqContentLenRxd + p_conn->RxBufLenRem;

            if (len_content_rxd < p_conn->ReqContentLen) {      
               *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;       
                goto exit;

            } else {                                            
                len_str = p_conn->RxBufLenRem;                  
            }

        } else {                                                
            len_str = (p_key_next - p_key_name);                
        }

                                                                
        result = HTTPsReq_BodyFormAppKeyValBlkAdd(p_instance, p_conn, p_key_name, len_str, p_err);



        if (result == DEF_FAIL) {
            goto exit;
        }

                                                                
        if (p_key_next != DEF_NULL) {                           

            len_str = p_key_next                                 - p_key_name + 1;


            p_conn->ReqContentLenRxd += len_str;                
            p_conn->RxBufLenRem      -= len_str;                
            p_key_name                = p_key_next + 1;         
            p_conn->RxBufPtr          = p_key_name;             

        } else {                                                
            p_conn->ReqContentLenRxd += p_conn->RxBufLenRem;    
            p_conn->RxBufLenRem       = 0u;                     

            if (p_conn->ReqContentLenRxd >= p_conn->ReqContentLen) {
                                                                
                done = DEF_YES;

            } else {                                            
               *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;       
                goto exit;
            }
        }
    }

   *p_err = HTTPs_ERR_NONE;


exit:
    return (done);
}





static  CPU_BOOLEAN  HTTPsReq_BodyFormAppKeyValBlkAdd (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, CPU_CHAR        *p_str, CPU_SIZE_T       str_len, HTTPs_ERR       *p_err)



{
    const  HTTPs_CFG       *p_cfg;
           HTTPs_KEY_VAL   *p_key_val;
           CPU_BOOLEAN      result;


    p_cfg = p_instance->CfgPtr;

    if (p_cfg->FormCfgPtr != DEF_NULL) {

                                                                
        if (p_cfg->FormCfgPtr->NbrPerConnMax != LIB_MEM_BLK_QTY_UNLIMITED) {
            if (p_conn->FormBlkAcquiredCtr >= p_cfg->FormCfgPtr->NbrPerConnMax) {
               *p_err = HTTPs_ERR_KEY_VAL_CFG_POOL_SIZE_INV;
                return (DEF_FAIL);
            }
        }

        p_key_val = HTTPsMem_FormKeyValBlkGet(p_instance, p_conn, p_err);
        if (p_key_val == DEF_NULL) {                            
            return (DEF_FAIL);
        }

        result = HTTPsReq_URL_EncodeStrParse(p_instance, p_conn, p_key_val, DEF_NO, p_str, str_len);




        if (result == DEF_FAIL) {
           *p_err = HTTPs_ERR_FORM_APP_PARSE_FAULT;
            return (DEF_FAIL);
        }

        if (p_conn->FormDataListPtr == DEF_NULL) {
            p_key_val->NextPtr  = DEF_NULL;
        } else {
            p_key_val->NextPtr  = p_conn->FormDataListPtr;
        }
        p_conn->FormDataListPtr = p_key_val;

    }

   *p_err = HTTPs_ERR_NONE;

    return (DEF_OK);
}





static  CPU_BOOLEAN  HTTPsReq_BodyFormMultipartParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    CPU_BOOLEAN  done;
    CPU_BOOLEAN  file_done;
    CPU_BOOLEAN  is_file;


    done = DEF_NO;
    while (done != DEF_YES) {

        switch (p_conn->State) {
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_PARSE:
                                                                
                 is_file =  HTTPsReq_BodyFormMultipartCtrlParse(p_instance, p_conn, p_err);

                 switch (*p_err) {
                     case HTTPs_ERR_NONE:
                          if (is_file == DEF_YES) {
                              p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN;
                          } else {
                              if (p_conn->ReqContentLenRxd >= p_conn->ReqContentLen) {
                                  done = DEF_YES;
                              }
                          }
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:
                          goto exit;

                     default:
                          goto exit;
                 }
                 break;


            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN:
            case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR:
                 file_done = HTTPsReq_BodyFormMultipartFileWr(p_instance, p_conn, p_err);

                 switch (*p_err) {
                     case HTTPs_ERR_NONE:
                          if (file_done == DEF_YES) {
                              p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT;
                          } else {
                              p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR;
                          }
                          break;

                     case HTTPs_ERR_REQ_MORE_DATA_REQUIRED:
                          p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR;
                          goto exit;

                     default:
                          goto exit;
                 }
                 break;


            default:
               *p_err = HTTPs_ERR_STATE_UNKNOWN;
                goto exit;
        }
    }

   *p_err = HTTPs_ERR_NONE;


exit:
    return (done);
}





static  CPU_CHAR  *HTTPsReq_BodyFormMultipartBoundarySrch (CPU_CHAR     *p_boundary, CPU_INT08U    boundary_len, CPU_CHAR     *p_buf, CPU_INT16U    buf_len, CPU_CHAR    **p_boundary_sep)



{
    CPU_CHAR    *p_boundary_found;
    CPU_CHAR    *p_str;
    CPU_INT16U   len;


   (void)p_boundary_sep;

    if (buf_len <= 0)  {
       *p_boundary_sep = DEF_NULL;
        p_boundary_found = DEF_NULL;
        goto exit;
    }

    p_str = DEF_NULL;
    len   = HTTPs_STR_MULTIPART_DATA_START_LEN;

    p_str = HTTPs_StrMemSrch(p_buf,                              buf_len, HTTPs_STR_MULTIPART_DATA_START, len);


    if (p_str == DEF_NULL) {
        if ((p_buf[buf_len - 1] == ASCII_CHAR_CARRIAGE_RETURN) || (p_buf[buf_len - 1] == ASCII_CHAR_LINE_FEED)       || (p_buf[buf_len - 1] == ASCII_CHAR_HYPHEN_MINUS)   ) {

            *p_boundary_sep   = p_buf + buf_len - 1;
             p_boundary_found = DEF_NULL;
             goto exit;
        } else {
            *p_boundary_sep   = DEF_NULL;
             p_boundary_found = DEF_NULL;
             goto exit;
        }
    }

   *p_boundary_sep = p_str;

    len = buf_len - (p_str - p_buf);
    if (len > boundary_len) {
        p_boundary_found = HTTPs_StrMemSrch(p_str,               len, p_boundary, boundary_len);



        p_str = p_buf + buf_len - boundary_len - HTTPs_STR_MULTIPART_DATA_START_LEN;

                                                                
        if (( p_boundary_found == DEF_NULL) &&                   (*p_boundary_sep    <  p_str)  ) {
                                                                
             *p_boundary_sep = p_str;
        }
                                                                
        if (p_boundary_found != DEF_NULL) {                     
           *p_boundary_sep = p_boundary_found - 2;              
        }

    } else {
        p_boundary_found = DEF_NULL;
        goto exit;
    }


exit:
    return (p_boundary_found);
}





static  CPU_BOOLEAN  HTTPsReq_BodyFormMultipartCtrlParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    const  HTTPs_CFG      *p_cfg          = p_instance->CfgPtr;
           CPU_CHAR       *p_buf          = p_conn->RxBufPtr;
           CPU_CHAR       *p_boundary     = DEF_NULL;
           CPU_CHAR       *p_boundary_sep = DEF_NULL;
           CPU_CHAR       *p_key          = DEF_NULL;
           CPU_CHAR       *p_filename     = DEF_NULL;
           CPU_CHAR       *p_filename_end = DEF_NULL;
           CPU_CHAR       *p_end          = DEF_NULL;
           CPU_CHAR       *p_str          = DEF_NULL;
           CPU_CHAR       *p_data         = DEF_NULL;
           HTTPs_KEY_VAL  *p_key_val      = DEF_NULL;
           CPU_CHAR        path_sep;
           CPU_SIZE_T      len            = 0;
           CPU_BOOLEAN     is_file        = DEF_NO;


    if (p_cfg->FormCfgPtr == DEF_NULL) {
       *p_err = HTTPs_ERR_CFG_NULL_PTR_FORM;
        return (DEF_YES);
    }

    switch (p_conn->State) {
                                                                
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT:

                                                                
             p_boundary = HTTPsReq_BodyFormMultipartBoundarySrch(p_conn->FormBoundaryPtr, p_conn->FormBoundaryLen, p_conn->RxBufPtr, p_conn->RxBufLenRem, &p_boundary_sep);



             if (p_boundary == DEF_NULL) {
                 if (p_conn->RxBufLenRem == p_conn->BufLen) {
                    *p_err = HTTPs_ERR_CFG_INVALID_BUF_LEN;
                 } else {
                    *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                 }
                 goto exit;
             }

             if ((p_conn->FormDataListPtr != DEF_NULL) &&        (p_boundary_sep          != p_buf)   ) {
                 p_key_val = p_conn->FormDataListPtr;
                 if (p_key_val->DataType != HTTPs_KEY_VAL_TYPE_FILE) {
                     len = (p_boundary - p_buf) - HTTPs_STR_MULTIPART_DATA_START_LEN - STR_CR_LF_LEN;
                     len = DEF_MIN(len, p_cfg->FormCfgPtr->ValLenMax - 1);
                     Str_Copy_N(p_key_val->ValPtr, p_buf, len);
                     p_key_val->ValPtr[len] = ASCII_CHAR_NULL;
                     p_key_val->ValLen      = len;
                 }
             }

                                                                
             len = (p_conn->RxBufPtr + p_conn->RxBufLenRem) - p_boundary;
             if (len < (p_conn->FormBoundaryLen + HTTPs_STR_MULTIPART_LAST_LEN)) {
                 p_conn->ReqContentLenRxd += (p_boundary_sep - p_buf);
                 p_conn->RxBufLenRem      -= (p_boundary_sep - p_buf);
                 p_conn->RxBufPtr         += (p_boundary_sep - p_buf);
                *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                 goto exit;
             }

             p_str = p_boundary + p_conn->FormBoundaryLen;

             p_str = Str_Str_N(p_str,                            HTTPs_STR_MULTIPART_LAST, p_conn->RxBufLenRem);

             if ((p_str != DEF_NULL) && (p_str == (p_boundary + p_conn->FormBoundaryLen))) {
                 p_conn->ReqContentLenRxd += p_conn->RxBufLenRem;
                 p_conn->RxBufPtr         += p_conn->RxBufLenRem;
                 p_conn->RxBufLenRem       = 0;
                *p_err = HTTPs_ERR_NONE;
                 goto exit;
             }

             p_str = p_boundary + p_conn->FormBoundaryLen;

             p_str = Str_Str_N(p_str,                            STR_CR_LF, p_conn->RxBufLenRem);

             if ((p_str == DEF_NULL)                               || (p_str != (p_boundary + p_conn->FormBoundaryLen))) {
                *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                 goto exit;
             }

             p_str +=  STR_CR_LF_LEN;

                                                                
             p_conn->ReqContentLenRxd += (p_str - p_buf);
             p_conn->RxBufLenRem      -= (p_str - p_buf);
             p_conn->RxBufPtr         += (p_str - p_buf);

             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_PARSE;
             break;


                                                                
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_PARSE:
             p_data = Str_Str_N(p_buf,                           HTTPs_STR_MULTIPART_CTRL_END_SEC, p_conn->RxBufLenRem);

             if (p_data == DEF_NULL) {
                if (p_conn->RxBufLenRem == p_conn->BufLen) {
                   *p_err = HTTPs_ERR_CFG_INVALID_BUF_LEN;
                } else {
                   *p_err = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                }
                goto exit;
             }

             p_data += HTTPs_STR_MULTIPART_CTRL_END_SEC_LEN;    

             len = p_data - p_buf;

                                                                
             p_filename = HTTP_Dict_StrKeySrch(HTTP_Dict_MultipartField, HTTP_Dict_MultipartFieldSize, HTTP_MULTIPART_FIELD_FILE_NAME, p_conn->RxBufPtr, len);



             if (p_filename != DEF_NULL) {
                 is_file = DEF_YES;

                 len = p_data - p_filename;
                                                                
                 p_filename = Str_Char_N(p_filename, len, ASCII_CHAR_QUOTATION_MARK);
                 if (p_filename == DEF_NULL) {
                    *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                     goto exit;
                 }
                 p_filename++;
                                                                
                 p_filename_end = Str_Char_N(p_filename, len, ASCII_CHAR_QUOTATION_MARK);
                 if (p_filename_end == DEF_NULL) {
                    *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                     goto exit;
                 }
                *p_filename_end = ASCII_CHAR_NULL;

             }

                                                            
             p_key = HTTP_Dict_StrKeySrch(HTTP_Dict_MultipartField, HTTP_Dict_MultipartFieldSize, HTTP_MULTIPART_FIELD_NAME, p_conn->RxBufPtr, p_conn->RxBufLenRem);



             if (p_key != DEF_NULL) {
                 len = p_data - p_key;
                                                             
                 p_key = Str_Char_N(p_key, len, ASCII_CHAR_QUOTATION_MARK);
                 if (p_key == DEF_NULL) {
                    *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                     goto exit;
                 }
                 p_key++;
                                                             
                 p_end = Str_Char_N(p_key, len, ASCII_CHAR_QUOTATION_MARK);
                 if (p_end == DEF_NULL) {
                    *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                     goto exit;
                 }
             }


             if ((p_filename == DEF_NULL) &&                     (p_key      == DEF_NULL)) {
                 *p_err = HTTPs_ERR_FORM_FORMAT_INV;
                  goto exit;
             }

                                                                
             if (p_cfg->FormCfgPtr->NbrPerConnMax != LIB_MEM_BLK_QTY_UNLIMITED) {
                 if (p_conn->FormBlkAcquiredCtr >= p_cfg->FormCfgPtr->NbrPerConnMax) {
                    *p_err = HTTPs_ERR_KEY_VAL_CFG_POOL_SIZE_INV;
                     goto exit;
                 }
             }

             p_key_val = HTTPsMem_FormKeyValBlkGet(p_instance, p_conn, p_err);

             if (p_key_val == DEF_NULL) {                       
                 goto exit;                                     
             } else {
                 if (p_conn->FormDataListPtr == DEF_NULL) {
                     p_key_val->NextPtr = DEF_NULL;
                 } else {
                     p_key_val->NextPtr = p_conn->FormDataListPtr;
                 }
                 p_conn->FormDataListPtr = p_key_val;
             }

             if (p_key != DEF_NULL) {                           
                 len = p_end - p_key;
                 len = DEF_MIN(len, p_cfg->FormCfgPtr->KeyLenMax - 1);
                 Str_Copy_N(p_key_val->KeyPtr, p_key, len);
                 p_key_val->KeyPtr[len] = ASCII_CHAR_NULL;
                 p_key_val->KeyLen      = len;

                 if (p_filename == DEF_NULL) {
                     p_key_val->DataType = HTTPs_KEY_VAL_TYPE_PAIR;
                 }

                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_INIT;

             }

             if (p_filename != DEF_NULL) {
                 p_key_val->DataType = HTTPs_KEY_VAL_TYPE_FILE;

                 if (p_key == DEF_NULL) {
                     p_key_val->KeyPtr[0] = ASCII_CHAR_NULL;
                 }

                 switch (p_cfg->FS_Type) {
                     case HTTPs_FS_TYPE_NONE:
                          path_sep = HTTPs_PATH_SEP_CHAR_DFLT;
                          break;

                     case HTTPs_FS_TYPE_STATIC:
                     case HTTPs_FS_TYPE_DYN:

                          path_sep = p_instance->FS_PathSepChar;

                         *p_err = HTTPs_ERR_CFG_INVALID_FS_EN;
                          goto exit;

                          break;

                     default:
                         *p_err = HTTPs_ERR_CFG_INVALID_FS_TYPE;
                          goto exit;
                 }

                 HTTPs_StrPathFormat(p_filename,                 p_cfg->FormCfgPtr->MultipartFileUploadFolderPtr, p_key_val->ValPtr, p_cfg->FormCfgPtr->ValLenMax, path_sep);




                 len = Str_Len_N(p_key_val->ValPtr, p_cfg->FormCfgPtr->ValLenMax);

                 p_key_val->ValLen = len;

                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN;
             }

             p_conn->ReqContentLenRxd += (p_data - p_buf);
             p_conn->RxBufPtr         += (p_data - p_buf);
             p_conn->RxBufLenRem      -= (p_data - p_buf);
             break;


        default:
            *p_err = HTTPs_ERR_STATE_UNKNOWN;
             goto exit;

    }

   *p_err = HTTPs_ERR_NONE;


exit:
    return (is_file);
}





static  CPU_BOOLEAN  HTTPsReq_BodyFormMultipartFileWr (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_ERR       *p_err)

{
    const  HTTPs_CFG             *p_cfg = p_instance->CfgPtr;
    const  NET_FS_API            *p_fs_api;
           CPU_CHAR              *p_boundary;
           CPU_CHAR              *p_boundary_sep;
           CPU_SIZE_T             len;
           CPU_SIZE_T             tmp;
           CPU_SIZE_T             len_wr;
           CPU_SIZE_T             len_wr_tot;
           CPU_BOOLEAN            fs_op;
           CPU_BOOLEAN            done;
           HTTPs_INSTANCE_STATS  *p_ctr_stats;


    HTTPs_SET_PTR_STATS(p_ctr_stats, p_instance);

    switch (p_cfg->FS_Type) {
        case HTTPs_FS_TYPE_NONE:
             p_fs_api = DEF_NULL;
             break;

        case HTTPs_FS_TYPE_STATIC:

            p_fs_api = ((HTTPs_CFG_FS_STATIC *)p_cfg->FS_CfgPtr)->FS_API_Ptr;

            p_fs_api = DEF_NULL;

            break;

        case HTTPs_FS_TYPE_DYN:

            p_fs_api = ((HTTPs_CFG_FS_DYN *)p_cfg->FS_CfgPtr)->FS_API_Ptr;

            p_fs_api = DEF_NULL;

            break;

        default:
           *p_err = HTTPs_ERR_CFG_INVALID_FS_TYPE;
            goto exit;
    }

    done = DEF_NO;

    if (p_fs_api == DEF_NULL) {
        HTTPs_STATS_INC(p_ctr_stats->Req_StatFormFileUploadNoFS_Ctr);
    }

    switch (p_conn->State) {
        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_OPEN:
             if ((p_fs_api                                 != DEF_NULL)    && (p_cfg->FormCfgPtr->MultipartFileUploadEn == DEF_ENABLED)) {

                 if (p_cfg->FormCfgPtr->MultipartFileUploadOverWrEn == DEF_ENABLED) {

                     p_conn->DataPtr = p_fs_api->Open(p_conn->FormDataListPtr->ValPtr, NET_FS_FILE_MODE_CREATE, NET_FS_FILE_ACCESS_WR);

                     if (p_conn->DataPtr == DEF_NULL) {
                        *p_err = HTTPs_ERR_FORM_FILE_UPLOAD_OPEN;
                         goto exit;
                     }
                     HTTPs_STATS_INC(p_ctr_stats->Req_StatFormFileUploadOpenedCtr);

                 } else {

                     p_conn->DataPtr = p_fs_api->Open(p_conn->FormDataListPtr->ValPtr, NET_FS_FILE_MODE_CREATE_NEW, NET_FS_FILE_ACCESS_WR);


                 }

             }
             p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR;
             break;


        case HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR:
             p_boundary_sep = DEF_NULL;
                                                               
             p_boundary = HTTPsReq_BodyFormMultipartBoundarySrch(p_conn->FormBoundaryPtr, p_conn->FormBoundaryLen, p_conn->RxBufPtr, p_conn->RxBufLenRem, &p_boundary_sep);




             if (p_boundary_sep == DEF_NULL) {                  
                 len = p_conn->RxBufLenRem;
             } else {
                 tmp = p_boundary_sep - p_conn->RxBufPtr;
                 if (tmp < STR_CR_LF_LEN) {
                     len = 0;
                 } else {
                     len = tmp - STR_CR_LF_LEN;
                 }
             }
                                                                
             if ((p_fs_api                                 != DEF_NULL)    && (p_cfg->FormCfgPtr->MultipartFileUploadEn == DEF_ENABLED) && (p_conn->DataPtr                          != DEF_NULL)   ) {

                 len_wr_tot = 0;
                 fs_op      = DEF_OK;
                 while ((fs_op      != DEF_FAIL) && (len_wr_tot  < len)     ) {
                     fs_op = p_fs_api->Wr(              p_conn->DataPtr, (CPU_INT08U *)p_conn->RxBufPtr, len, &len_wr);



                     len_wr_tot += len_wr;
                 }

                 if (fs_op == DEF_FAIL) {                       
                     p_conn->ReqContentLenRxd += p_conn->RxBufLenRem;
                     p_conn->RxBufPtr         += p_conn->RxBufLenRem;
                     p_conn->RxBufLenRem       = 0;

                     HTTPs_STATS_INC(p_ctr_stats->Req_StatFormFileUploadClosedCtr);
                     p_fs_api->Close(p_conn->DataPtr);
                     p_conn->DataPtr = DEF_NULL;

                     done  = DEF_YES;
                    *p_err = HTTPs_ERR_FILE_WR_FAULT;
                     goto exit;
                 }
             } else {
                 len_wr_tot = len;
             }

                                                                
             p_conn->RxBufPtr         += len_wr_tot;
             p_conn->RxBufLenRem      -= len_wr_tot;
             p_conn->ReqContentLenRxd += len_wr_tot;

             if (p_boundary == DEF_NULL) {
                 p_conn->State = HTTPs_CONN_STATE_REQ_BODY_FORM_MULTIPART_FILE_WR;
                *p_err         = HTTPs_ERR_REQ_MORE_DATA_REQUIRED;
                 goto exit;

             } else {
                 p_conn->RxBufPtr         += STR_CR_LF_LEN;
                 p_conn->RxBufLenRem      -= STR_CR_LF_LEN;
                 p_conn->ReqContentLenRxd += STR_CR_LF_LEN;

                 if ((p_fs_api                                 != DEF_NULL)    && (p_cfg->FormCfgPtr->MultipartFileUploadEn == DEF_ENABLED) && (p_conn->DataPtr                          != DEF_NULL)   ) {

                     HTTPs_STATS_INC(p_ctr_stats->Req_StatFormFileUploadClosedCtr);
                     p_fs_api->Close(p_conn->DataPtr);
                 }
                 p_conn->DataPtr = DEF_NULL;

                 done            = DEF_YES;
             }
             break;


        default:
            *p_err = HTTPs_ERR_STATE_UNKNOWN;
             goto exit;
    }

   *p_err = HTTPs_ERR_NONE;


exit:
   return (done);
}





static  CPU_BOOLEAN  HTTPsReq_URL_EncodeStrParse (HTTPs_INSTANCE  *p_instance, HTTPs_CONN      *p_conn, HTTPs_KEY_VAL   *p_key_val, CPU_BOOLEAN      from_query, CPU_CHAR        *p_str, CPU_SIZE_T       str_len)




{
    const  HTTPs_CFG       *p_cfg;
           CPU_CHAR        *p_key;
           CPU_CHAR        *p_val;
           CPU_CHAR        *p_str_sep;
           CPU_SIZE_T       key_len;
           CPU_SIZE_T       val_len;
           CPU_SIZE_T       key_len_cfg;
           CPU_SIZE_T       val_len_cfg;
           CPU_BOOLEAN      result;


    p_cfg = p_instance->CfgPtr;

    if (from_query == DEF_YES) {
        if (p_cfg->QueryStrCfgPtr != DEF_NULL) {
            key_len_cfg = p_cfg->QueryStrCfgPtr->KeyLenMax - 1;
            val_len_cfg = p_cfg->QueryStrCfgPtr->ValLenMax - 1;
        } else {
            p_conn->ErrCode = HTTPs_ERR_CFG_NULL_PTR_QUERY_STR;
            return (DEF_FAIL);
        }
    } else {
        if (p_cfg->FormCfgPtr != DEF_NULL) {
            key_len_cfg = p_cfg->FormCfgPtr->KeyLenMax - 1;
            val_len_cfg = p_cfg->FormCfgPtr->ValLenMax - 1;
        } else {
            p_conn->ErrCode = HTTPs_ERR_CFG_NULL_PTR_FORM;
            return (DEF_FAIL);
        }
    }

                                                                
    p_str_sep = Str_Char_N(p_str, str_len, ASCII_CHAR_EQUALS_SIGN);

    p_str[str_len] = ASCII_CHAR_NULL;

    if (p_str_sep != DEF_NULL) {
        p_val = p_str_sep + 1;
        p_key = p_str;
    } else {
        p_val = p_str_sep;
        p_key = DEF_NULL;
    }

                                                                
                                                                
    if (p_key != DEF_NULL) {

        key_len = p_str_sep - p_key;
        key_len = DEF_MIN(key_len, key_len_cfg);

        Str_Copy_N(p_key_val->KeyPtr, p_key, key_len);


        p_key_val->DataType = HTTPs_KEY_VAL_TYPE_PAIR;

    } else {

        key_len = 0;
        p_key_val->DataType = HTTPs_KEY_VAL_TYPE_VAL;
    }

    p_key_val->KeyPtr[key_len] = ASCII_CHAR_NULL;
    p_key_val->KeyLen          = key_len;

                                                                
    val_len = p_str + str_len - p_val;
    val_len = DEF_MIN(val_len, val_len_cfg);

    Str_Copy_N(p_key_val->ValPtr, p_val, val_len);


    p_key_val->ValPtr[val_len] = ASCII_CHAR_NULL;
    p_key_val->ValLen          = val_len;

    result = HTTP_URL_DecodeReplaceStr(p_key_val->KeyPtr, &p_key_val->KeyLen);
    if (result == DEF_FAIL) {
        return (DEF_FAIL);
    }

    result = HTTP_URL_DecodeReplaceStr(p_key_val->ValPtr, &p_key_val->ValLen);
    if (result == DEF_FAIL) {
        return (DEF_FAIL);
    }

    return (DEF_OK);
}

