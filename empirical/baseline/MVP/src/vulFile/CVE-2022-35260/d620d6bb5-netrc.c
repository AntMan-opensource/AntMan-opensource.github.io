




















enum host_lookup_state {
  NOTHING, HOSTFOUND, HOSTVALID, MACDEF };









static int parsenetrc(const char *host, char **loginp, char **passwordp, char *netrcfile)


{
  FILE *file;
  int retcode = NETRC_FILE_MISSING;
  char *login = *loginp;
  char *password = *passwordp;
  bool specific_login = (login && *login != 0);
  bool login_alloc = FALSE;
  bool password_alloc = FALSE;
  enum host_lookup_state state = NOTHING;

  char state_login = 0;      
  char state_password = 0;   
  int state_our_login = TRUE;  

  DEBUGASSERT(netrcfile);

  file = fopen(netrcfile, FOPEN_READTEXT);
  if(file) {
    bool done = FALSE;
    char netrcbuffer[4096];
    int  netrcbuffsize = (int)sizeof(netrcbuffer);

    while(!done && fgets(netrcbuffer, netrcbuffsize, file)) {
      char *tok;
      char *tok_end;
      bool quoted;
      if(state == MACDEF) {
        if((netrcbuffer[0] == '\n') || (netrcbuffer[0] == '\r'))
          state = NOTHING;
        else continue;
      }
      tok = netrcbuffer;
      while(tok) {
        while(ISBLANK(*tok))
          tok++;
        
        if(!*tok || (*tok == '#'))
          
          break;

        
        quoted = (*tok == '\"');

        tok_end = tok;
        if(!quoted) {
          while(!ISSPACE(*tok_end))
            tok_end++;
          *tok_end = 0;
        }
        else {
          bool escape = FALSE;
          bool endquote = FALSE;
          char *store = tok;
          tok_end++; 
          while(*tok_end) {
            char s = *tok_end;
            if(escape) {
              escape = FALSE;
              switch(s) {
              case 'n':
                s = '\n';
                break;
              case 'r':
                s = '\r';
                break;
              case 't':
                s = '\t';
                break;
              }
            }
            else if(s == '\\') {
              escape = TRUE;
              tok_end++;
              continue;
            }
            else if(s == '\"') {
              tok_end++; 
              endquote = TRUE;
              break;
            }
            *store++ = s;
            tok_end++;
          }
          *store = 0;
          if(escape || !endquote) {
            
            retcode = NETRC_FAILED;
            goto out;
          }
        }

        if((login && *login) && (password && *password)) {
          done = TRUE;
          break;
        }

        switch(state) {
        case NOTHING:
          if(strcasecompare("macdef", tok)) {
            
            state = MACDEF;
          }
          else if(strcasecompare("machine", tok)) {
            
            state = HOSTFOUND;
          }
          else if(strcasecompare("default", tok)) {
            state = HOSTVALID;
            retcode = NETRC_SUCCESS; 
          }
          break;
        case MACDEF:
          if(!strlen(tok)) {
            state = NOTHING;
          }
          break;
        case HOSTFOUND:
          if(strcasecompare(host, tok)) {
            
            state = HOSTVALID;
            retcode = NETRC_SUCCESS; 
          }
          else  state = NOTHING;

          break;
        case HOSTVALID:
          
          if(state_login) {
            if(specific_login) {
              state_our_login = !Curl_timestrcmp(login, tok);
            }
            else if(!login || Curl_timestrcmp(login, tok)) {
              if(login_alloc) {
                free(login);
                login_alloc = FALSE;
              }
              login = strdup(tok);
              if(!login) {
                retcode = NETRC_FAILED; 
                goto out;
              }
              login_alloc = TRUE;
            }
            state_login = 0;
          }
          else if(state_password) {
            if((state_our_login || !specific_login)
               && (!password || Curl_timestrcmp(password, tok))) {
              if(password_alloc) {
                free(password);
                password_alloc = FALSE;
              }
              password = strdup(tok);
              if(!password) {
                retcode = NETRC_FAILED; 
                goto out;
              }
              password_alloc = TRUE;
            }
            state_password = 0;
          }
          else if(strcasecompare("login", tok))
            state_login = 1;
          else if(strcasecompare("password", tok))
            state_password = 1;
          else if(strcasecompare("machine", tok)) {
            
            state = HOSTFOUND;
            state_our_login = FALSE;
          }
          break;
        } 
        tok = ++tok_end;
      }
    } 

    out:
    if(!retcode) {
      
      if(login_alloc) {
        if(*loginp)
          free(*loginp);
        *loginp = login;
      }
      if(password_alloc) {
        if(*passwordp)
          free(*passwordp);
        *passwordp = password;
      }
    }
    else {
      if(login_alloc)
        free(login);
      if(password_alloc)
        free(password);
    }
    fclose(file);
  }

  return retcode;
}


int Curl_parsenetrc(const char *host, char **loginp, char **passwordp, char *netrcfile)
{
  int retcode = 1;
  char *filealloc = NULL;

  if(!netrcfile) {

    char pwbuf[1024];

    char *home = NULL;
    char *homea = curl_getenv("HOME"); 
    if(homea) {
      home = homea;

    }
    else {
      struct passwd pw, *pw_res;
      if(!getpwuid_r(geteuid(), &pw, pwbuf, sizeof(pwbuf), &pw_res)
         && pw_res) {
        home = pw.pw_dir;
      }

    }
    else {
      struct passwd *pw;
      pw = getpwuid(geteuid());
      if(pw) {
        home = pw->pw_dir;
      }

    }
    else {
      homea = curl_getenv("USERPROFILE");
      if(homea) {
        home = homea;
      }

    }

    if(!home)
      return retcode; 

    filealloc = curl_maprintf("%s%s.netrc", home, DIR_CHAR);
    if(!filealloc) {
      free(homea);
      return -1;
    }
    retcode = parsenetrc(host, loginp, passwordp, filealloc);
    free(filealloc);

    if(retcode == NETRC_FILE_MISSING) {
      
      filealloc = curl_maprintf("%s%s_netrc", home, DIR_CHAR);
      if(!filealloc) {
        free(homea);
        return -1;
      }
      retcode = parsenetrc(host, loginp, passwordp, filealloc);
      free(filealloc);
    }

    free(homea);
  }
  else retcode = parsenetrc(host, loginp, passwordp, netrcfile);
  return retcode;
}


