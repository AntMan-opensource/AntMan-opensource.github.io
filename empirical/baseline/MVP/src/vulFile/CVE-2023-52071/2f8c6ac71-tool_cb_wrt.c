






























bool tool_create_output_file(struct OutStruct *outs, struct OperationConfig *config)
{
  struct GlobalConfig *global;
  FILE *file = NULL;
  char *fname = outs->filename;
  char *aname = NULL;
  DEBUGASSERT(outs);
  DEBUGASSERT(config);
  global = config->global;
  if(!fname || !*fname) {
    warnf(global, "Remote filename has no length");
    return FALSE;
  }

  if(config->output_dir && outs->is_cd_filename) {
    aname = aprintf("%s/%s", config->output_dir, fname);
    if(!aname) {
      errorf(global, "out of memory");
      return FALSE;
    }
    fname = aname;
  }

  if(config->file_clobber_mode == CLOBBER_ALWAYS || (config->file_clobber_mode == CLOBBER_DEFAULT && !outs->is_cd_filename)) {

    
    file = fopen(fname, "wb");
  }
  else {
    int fd;
    do {
      fd = open(fname, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, OPENMODE);
      
    } while(fd == -1 && errno == EINTR);
    if(config->file_clobber_mode == CLOBBER_NEVER && fd == -1) {
      int next_num = 1;
      size_t len = strlen(fname);
      size_t newlen = len + 13; 
      char *newname;
      
      if(newlen < len) {
        free(aname);
        errorf(global, "overflow in filename generation");
        return FALSE;
      }
      newname = malloc(newlen);
      if(!newname) {
        errorf(global, "out of memory");
        free(aname);
        return FALSE;
      }
      memcpy(newname, fname, len);
      newname[len] = '.';
      while(fd == -1 &&  (errno == EEXIST || errno == EISDIR) &&  next_num < 100  ) {


        curlx_msnprintf(newname + len + 1, 12, "%d", next_num);
        next_num++;
        do {
          fd = open(newname, O_CREAT | O_WRONLY | O_EXCL | O_BINARY, OPENMODE);
          
        } while(fd == -1 && errno == EINTR);
      }
      outs->filename = newname; 
      outs->alloc_filename = TRUE;
    }
    
    if(fd != -1) {
      file = fdopen(fd, "wb");
      if(!file)
        close(fd);
    }
  }

  if(!file) {
    warnf(global, "Failed to open the file %s: %s", fname, strerror(errno));
    free(aname);
    return FALSE;
  }
  free(aname);
  outs->s_isreg = TRUE;
  outs->fopened = TRUE;
  outs->stream = file;
  outs->bytes = 0;
  outs->init = 0;
  return TRUE;
}



size_t tool_write_cb(char *buffer, size_t sz, size_t nmemb, void *userdata)
{
  size_t rc;
  struct per_transfer *per = userdata;
  struct OutStruct *outs = &per->outs;
  struct OperationConfig *config = per->config;
  size_t bytes = sz * nmemb;
  bool is_tty = config->global->isatty;

  CONSOLE_SCREEN_BUFFER_INFO console_info;
  intptr_t fhnd;



  {
    char *tty = curlx_getenv("CURL_ISATTY");
    if(tty) {
      is_tty = TRUE;
      curl_free(tty);
    }
  }

  if(config->show_headers) {
    if(bytes > (size_t)CURL_MAX_HTTP_HEADER) {
      warnf(config->global, "Header data size exceeds single call write " "limit");
      return CURL_WRITEFUNC_ERROR;
    }
  }
  else {
    if(bytes > (size_t)CURL_MAX_WRITE_SIZE) {
      warnf(config->global, "Data size exceeds single call write limit");
      return CURL_WRITEFUNC_ERROR;
    }
  }

  {
    
    bool check_fails = FALSE;
    if(outs->filename) {
      
      if(!*outs->filename)
        check_fails = TRUE;
      if(!outs->s_isreg)
        check_fails = TRUE;
      if(outs->fopened && !outs->stream)
        check_fails = TRUE;
      if(!outs->fopened && outs->stream)
        check_fails = TRUE;
      if(!outs->fopened && outs->bytes)
        check_fails = TRUE;
    }
    else {
      
      if(!outs->stream || outs->s_isreg || outs->fopened)
        check_fails = TRUE;
      if(outs->alloc_filename || outs->is_cd_filename || outs->init)
        check_fails = TRUE;
    }
    if(check_fails) {
      warnf(config->global, "Invalid output struct data for write callback");
      return CURL_WRITEFUNC_ERROR;
    }
  }


  if(!outs->stream && !tool_create_output_file(outs, per->config))
    return CURL_WRITEFUNC_ERROR;

  if(is_tty && (outs->bytes < 2000) && !config->terminal_binary_ok) {
    
    if(memchr(buffer, 0, bytes)) {
      warnf(config->global, "Binary output can mess up your terminal. " "Use \"--output -\" to tell curl to output it to your terminal " "anyway, or consider \"--output <FILE>\" to save to a file.");

      config->synthetic_error = TRUE;
      return CURL_WRITEFUNC_ERROR;
    }
  }


  fhnd = _get_osfhandle(fileno(outs->stream));
  
  if(isatty(fileno(outs->stream)) && GetConsoleScreenBufferInfo((HANDLE)fhnd, &console_info)) {
    wchar_t *wc_buf;
    DWORD wc_len;
    unsigned char *rbuf = (unsigned char *)buffer;
    DWORD rlen = (DWORD)bytes;



    
    if(outs->utf8seq[0] && rlen) {
      bool complete = false;
      
      if(0xC0 <= outs->utf8seq[0] && outs->utf8seq[0] < 0xE0) {
        outs->utf8seq[1] = *rbuf++;
        --rlen;
        complete = true;
      }
      
      else if(0xE0 <= outs->utf8seq[0] && outs->utf8seq[0] < 0xF0) {
        if(!outs->utf8seq[1]) {
          outs->utf8seq[1] = *rbuf++;
          --rlen;
        }
        if(rlen && !outs->utf8seq[2]) {
          outs->utf8seq[2] = *rbuf++;
          --rlen;
          complete = true;
        }
      }
      
      else if(0xF0 <= outs->utf8seq[0] && outs->utf8seq[0] < 0xF8) {
        if(!outs->utf8seq[1]) {
          outs->utf8seq[1] = *rbuf++;
          --rlen;
        }
        if(rlen && !outs->utf8seq[2]) {
          outs->utf8seq[2] = *rbuf++;
          --rlen;
        }
        if(rlen && !outs->utf8seq[3]) {
          outs->utf8seq[3] = *rbuf++;
          --rlen;
          complete = true;
        }
      }

      if(complete) {
        WCHAR prefix[3] = {0};  

        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)outs->utf8seq, -1, prefix, sizeof(prefix)/sizeof(prefix[0]))) {
          DEBUGASSERT(prefix[3] == L'\0');
          if(!WriteConsoleW( (HANDLE) fhnd, prefix, prefix[1] ? 2 : 1, NULL, NULL)) {




            return CURL_WRITEFUNC_ERROR;
          }
        }
        

        memset(outs->utf8seq, 0, sizeof(outs->utf8seq));
      }
    }

    
    if(!outs->utf8seq[0] && rlen && (rbuf[rlen - 1] & 0x80)) {
      
      if(0xC0 <= rbuf[rlen - 1] && rbuf[rlen - 1] < 0xF8) {
        outs->utf8seq[0] = rbuf[rlen - 1];
        rlen -= 1;
      }
      else if(rlen >= 2 && IS_TRAILING_BYTE(rbuf[rlen - 1])) {
        
        if(0xE0 <= rbuf[rlen - 2] && rbuf[rlen - 2] < 0xF8) {
          outs->utf8seq[0] = rbuf[rlen - 2];
          outs->utf8seq[1] = rbuf[rlen - 1];
          rlen -= 2;
        }
        else if(rlen >= 3 && IS_TRAILING_BYTE(rbuf[rlen - 2])) {
          
          if(0xF0 <= rbuf[rlen - 3] && rbuf[rlen - 3] < 0xF8) {
            outs->utf8seq[0] = rbuf[rlen - 3];
            outs->utf8seq[1] = rbuf[rlen - 2];
            outs->utf8seq[2] = rbuf[rlen - 1];
            rlen -= 3;
          }
        }
      }
    }

    if(rlen) {
      
      wc_len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)rbuf, rlen, NULL, 0);
      if(!wc_len)
        return CURL_WRITEFUNC_ERROR;

      wc_buf = (wchar_t*) malloc(wc_len * sizeof(wchar_t));
      if(!wc_buf)
        return CURL_WRITEFUNC_ERROR;

      wc_len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)rbuf, rlen, wc_buf, wc_len);
      if(!wc_len) {
        free(wc_buf);
        return CURL_WRITEFUNC_ERROR;
      }

      if(!WriteConsoleW( (HANDLE) fhnd, wc_buf, wc_len, NULL, NULL)) {




        free(wc_buf);
        return CURL_WRITEFUNC_ERROR;
      }
      free(wc_buf);
    }

    rc = bytes;
  }
  else  rc = fwrite(buffer, sz, nmemb, outs->stream);


  if(bytes == rc)
    
    outs->bytes += bytes;

  if(config->readbusy) {
    config->readbusy = FALSE;
    curl_easy_pause(per->curl, CURLPAUSE_CONT);
  }

  if(config->nobuffer) {
    
    int res = fflush(outs->stream);
    if(res)
      return CURL_WRITEFUNC_ERROR;
  }

  return rc;
}
