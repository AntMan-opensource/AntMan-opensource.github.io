







extern dw_str *key_s[];
extern dw_str *key_d[];
extern int32_t key_n[];


extern int64_t the_time;
extern dwr_rg *rng_seed;


extern tcp_pend_T *tcp_pend;
extern SOCKET tcp_b_local[]; 



in_addr_t global_source_ip4 = INADDR_ANY;

u_long global_source_ip4 = INADDR_ANY;



ip_addr_T bind_address[DW_MAXIPS + 1];
ip_addr_T upstream_address[DW_MAXIPS + 1];


ip_mask_T recursive_acl[DW_MAXIPS + 1];


SOCKET b_local[DW_MAXIPS + 1];
SOCKET *b_remote;


remote_T *rem;


extern dw_hash *cache;


int_fast32_t maxprocs = 1024;
int max_tcp_procs = 8;

int timeout_seconds = 1;
int timeout_seconds_tcp = 4;

int timeout_seconds = 2;
int timeout_seconds_tcp = 4;

int_fast32_t dns_port = 53;
int_fast32_t upstream_port = 53;
int handle_overload = 1;
int handle_noreply = 1;
int resurrections = 1;
int_fast32_t min_bind = 15000;
int_fast32_t num_ports = 4096;
int_fast32_t maradns_uid = 99;
int_fast32_t maradns_gid = 99;
int_fast32_t max_ttl = 86400;
int_fast32_t min_ttl = 30;
int num_retries = 5;
dwd_dict *blocklist_dict = 0;


u_long dont_block = 0;




int inet_pton(int z, char *c, uint8_t *ip) {
        uint32_t ipt = 0xffffffff;
        if(c != 0 && *c != 0) {
                ipt = inet_addr(c);
        } else {
                return -1;
        }
        ipt = htonl(ipt);
        ip[0] = (ipt & 0xff000000) >> 24;
        ip[1] = (ipt & 0x00ff0000) >> 16;
        ip[2] = (ipt & 0x0000ff00) >>  8;
        ip[3] = (ipt & 0x000000ff);
        if(ipt != 0xffffffff) {
                return 1;
        } else {
                return -1;
        }
}



void reset_rem(int_fast32_t a) {
        if(rem[a].socket != INVALID_SOCKET) {
                closesocket(rem[a].socket);
                rem[a].socket = INVALID_SOCKET;
        }
        rem[a].die = 0;
        rem[a].remote_id = 0;
        rem[a].retries = num_retries;
        if(rem[a].ns != 0) {
                dw_destroy(rem[a].ns);
                rem[a].ns = 0;
        }
        rem[a].is_upstream = 0;
        if(rem[a].query != 0) {
                zap_inflight(rem[a].query);
                dw_destroy(rem[a].query);
                rem[a].query = 0;
        }
        rem[a].recurse_depth = 0;
        rem[a].current_ns = -1;
        rem[a].child_id = -1;
        if(rem[a].glueless != 0) {
                dw_destroy(rem[a].glueless);
                rem[a].glueless = 0;
        }
        if(rem[a].local != 0) {
                int qq;
                for(qq = 0; qq < rem[a].num_locals; qq++) {
                        if(rem[a].local[qq] != 0) {
                                dw_destroy(rem[a].local[qq]->orig_query);
                                dw_destroy(rem[a].local[qq]->action);
                                free(rem[a].local[qq]);
                                rem[a].local[qq] = 0; }
                }
                free(rem[a].local);
        }
        rem[a].local = 0;
        rem[a].num_locals = 0;
}


SOCKET bind_set_dns(ip_addr_T *ip, sockaddr_all_T *dns_do, int type) {
        SOCKET sock = INVALID_SOCKET;

        if(ip == 0 || dns_do == 0) {
                return INVALID_SOCKET;
        }

        memset(dns_do,0,sizeof(sockaddr_all_T));

        
        if ( ip->len == 4 ) { 
                dns_do->V4.sin_family = AF_INET;
                memcpy(&(dns_do->V4.sin_addr.s_addr), ip->ip, ip->len);
                dns_do->V4.sin_port = htons(dns_port);
                sock = socket(AF_INET,type,0);

        } else if( ip->len == 16) { 
                dns_do->V6.sin6_family = AF_INET6;
                memcpy(&(dns_do->V6.sin6_addr), ip->ip, ip->len);
                dns_do->V6.sin6_port = htons(dns_port);
                sock = socket(AF_INET6,type,0);

        }

        if(sock != INVALID_SOCKET) {
                make_socket_nonblock(sock);
        }

        return sock;
}


SOCKET do_bind(ip_addr_T *ip,int type) {
        int on = 1;
        SOCKET sock = INVALID_SOCKET;
        sockaddr_all_T dns_do;
        unsigned int len_inet = sizeof(struct sockaddr_in);

        sock = bind_set_dns(ip,&dns_do,type);
        if(sock == INVALID_SOCKET) {
                return INVALID_SOCKET;
        }

        if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof (on)))
        {
                closesocket(sock);
                return INVALID_SOCKET;
        }


        if (ip->len == 16)
                len_inet = sizeof(struct sockaddr_in6);


        if(bind(sock,(struct sockaddr *)&dns_do,len_inet) == -1) {
                closesocket(sock);
                return INVALID_SOCKET;
        }

        if(type == SOCK_STREAM && listen(sock,250) == -1) {
                closesocket(sock);
                return INVALID_SOCKET;
        }

        return sock;
}


void pop_ip_core(dw_str *list, ip_addr_T *ip,char *c) {
        if(c == 0 || ip == 0) { 
                return;
        }
        ip->len = 0;
        if( inet_pton(AF_INET, c, (uint8_t *)(ip->ip)) > 0 ) {
                ip->len = 4;

        } else {
                if ( inet_pton(AF_INET6, c, (uint8_t *)(ip->ip)) > 0 ) {
                        ip->len = 16;
                }

        }
}


void pop_ip(dw_str *list, ip_addr_T *ip) {
        char *c = 0;

        c = pop_last_item(list);
        pop_ip_core(list,ip,c);

        if(c != 0) {
                free(c);
                c = 0;
        }
}


dw_str *make_ip_str(ip_addr_T *in) {
        dw_str *out = 0;
        int counter = 0;

        if(in == 0) {
                goto catch_make_ip_str;
        }

        if(in->len != 4 && in->len != 16) {
                goto catch_make_ip_str;
        }

        out = dw_create(in->len + 1);

        if(out == 0) {
                goto catch_make_ip_str;
        }

        out->len = in->len;

        for(counter = 0; counter < in->len; counter++) {
                *(out->str + counter) = in->ip[counter];
        }

        return out;

catch_make_ip_str:
        if(out != 0) {
                dw_destroy(out);
        }
        return 0;
}


dwd_dict *make_ip_dict(dw_str *in) {
        dwd_dict *out = 0;
        dw_str *key = 0, *value = 0;
        int counter = 0;
        ip_addr_T ip;

        if(in == 0) {
                return 0;
        }

        value = dw_create(2);
        if(value == 0) {
                return 0;
        }

        value->len = 1;
        *(value->str) = 'y'; 

        out = dwd_init();

        ip.len = 1;
        for(counter = 0; counter < 1000 && ip.len != 0; counter++) {
                pop_ip(in, &ip);
                if(ip.len != 0) {
                        key = make_ip_str(&ip);
                        if(key != 0) {
                                dwd_add(out, key, value);
                                dw_destroy(key);
                                key = 0;
                        }
                }
        }

        dw_destroy(value);
        return out;
}


void pop_ip_mask(dw_str *list, ip_mask_T *ip_mask) {
        char *c = 0;
        char *q = 0; 
        int n;

        c = pop_last_item(list);
        if(c == 0) {
                goto catch_pop_ip_mask;
        }

        q = strchr(c,'/');
        if(q == 0 || *q != '/') {
                pop_ip_core(list,(ip_addr_T *)ip_mask,c);
                make_netmask(ip_mask->len * 8,ip_mask->mask,ip_mask->len);
                goto catch_pop_ip_mask;
        }
        *q = 0; 
        pop_ip_core(list,(ip_addr_T *)ip_mask,c);
        *q = '/';

        q++;
        if(*q == 0) {
                goto catch_pop_ip_mask;
        }

        n = atoi(q);
        if(ip_mask->len != 4 && ip_mask->len != 16) {
                goto catch_pop_ip_mask;
        }
        if(n < 0 || n > (ip_mask->len * 8)) {
                n = ip_mask->len * 8;
        }
        make_netmask(n,ip_mask->mask,ip_mask->len);

catch_pop_ip_mask:
        if(c != 0) {
                free(c);
                c = 0;
        }
}


void set_ip_list(ip_addr_T *list, dw_str *str) {
        int a = 0;

        if(list == 0 || str == 0) {
                return;
        }

        
        while(a < DW_MAXIPS - 1) {
                pop_ip(str, &list[a]);
                if(list[a].len == 0) {
                        break;
                }
                a++;
        }
        
        while(a < DW_MAXIPS) {
                list[a].len = 0;
                a++;
        }
}


void set_ipmask_list(ip_mask_T *list, dw_str *str) {
        int a = 0;

        if(list == 0 || str == 0) {
                return;
        }

        
        while(a < DW_MAXIPS - 1) {
                pop_ip_mask(str, &list[a]);
                if(list[a].len == 0) {
                        break;
                }
                a++;
        }
        
        while(a < DW_MAXIPS) {
                list[a].len = 0;
                a++;
        }
}


uint16_t get_from_ip_port(ip_addr_T *from_ip, sockaddr_all_T *client) {
        uint16_t from_port = 0;

        if(from_ip == 0 || client == 0) {
                return 0;
        }

        if(client->Family == AF_INET) {
                from_ip->len = 4;
                
                memcpy(from_ip->ip,&(client->V4.sin_addr.s_addr),4);
                
                from_port = ntohs(client->V4.sin_port);

        } else if (client->Family == AF_INET6) {
                from_ip->len = 16;
                
                memcpy(from_ip->ip, &(client->V6.sin6_addr),16);
                
                from_port = ntohs(client->V6.sin6_port);

        }
        return from_port;
}


int check_ip_acl(ip_addr_T *ip) {
        int a = 0;
        int b = 0;
        uint8_t m;

        for(a = 0; a < DW_MAXIPS; a++) {
                if(recursive_acl[a].len == 0) {
                        return 0;
                }
                if(ip->len != recursive_acl[a].len) {
                        continue;
                }
                for(b = 0; b < ip->len; b++) {
                        m = recursive_acl[a].mask[b];
                        if((recursive_acl[a].ip[b] & m) != (ip->ip[b] & m)) {
                                break;
                        }
                }
                if(b == ip->len) {
                        return 1;
                }
        }
        return 0;
}


void process_numeric_mararc_params() {

        maxprocs =        get_key_n(DWM_N_maxprocs,       8,8388608,-1);
        max_tcp_procs =   get_key_n(DWM_N_max_tcp_procs,  4,1024,-1);

        timeout_seconds = get_key_n(DWM_N_timeout_seconds,1,300,-1);
        timeout_seconds_tcp = get_key_n(DWM_N_timeout_seconds_tcp,1,300,-1);

        timeout_seconds = get_key_n(DWM_N_timeout_seconds,2,300,-1);
        timeout_seconds_tcp = get_key_n(DWM_N_timeout_seconds_tcp,2,300,-1);

        dns_port =        get_key_n(DWM_N_dns_port,       1,65535,53);
        upstream_port =   get_key_n(DWM_N_upstream_port,  1,65535,53);
        handle_overload = get_key_n(DWM_N_handle_overload,0,1,1);
        handle_noreply  = get_key_n(DWM_N_handle_noreply,0,1,1);
        min_bind = get_key_n(DWM_N_recurse_min_bind_port,1025,32767,15000);
        num_ports = get_key_n(DWM_N_recurse_number_ports,256,32768,4096);
        maradns_uid = get_key_n(DWM_N_maradns_uid,10,16777216,707);
        maradns_gid = get_key_n(DWM_N_maradns_gid,10,16777216,707);
        resurrections = get_key_n(DWM_N_resurrections,0,1,1);
        num_retries = get_key_n(DWM_N_num_retries,0,32,5);
        max_ttl = get_key_n(DWM_N_max_ttl, 300 , 7776000 , 86400 );


        min_ttl = get_key_n(DWM_N_min_ttl, 5 , 86400 , 60 );



        if((num_ports & (num_ports - 1)) != 0) {
                dw_fatal("num_ports must be a power of 2");
        }
        num_ports--;

}


int process_root_upstream_servers(int param, int is_upstream, char *bad) {
        dw_str *q = 0, *r = 0, *s = 0, *ns_refer = 0, *check = 0;
        int a = 0, out = 0;

        q = 0;
        
        for(a=0;a<20000;a++) {
                r = dwm_dict_nextkey(param,q);
                dw_destroy(q);
                if(r == 0) {
                        break;
                }
                out = 1;
                s = dwm_dict_fetch(param,r);
                q = dw_dnsname_convert(r);
                ns_refer = dwx_ns_convert(s,is_upstream,q);
                if(q == 0 || ns_refer == 0 || ns_refer->len < 4) {
                        dw_log_dwstr_str(bad,r,"\"]",0);
                        dw_fatal("Please fix this line");
                }
                dw_put_u16(q, 65395, -1); 

                
                check = dwh_get(cache,q,1,1);
                if(check != 0) {
                        dw_log_dwstr_str(bad,r, "\"] (used in both root_servers and upstream_servers)",0);
                        dw_fatal("Same entry can not be in both");
                        }

                dwh_add(cache,q,ns_refer,1,2);
                dw_destroy(q);
                dw_destroy(s);
                dw_destroy(ns_refer);
                q = dw_copy(r);
                dw_destroy(r);
        }
        if(a == 20000) {
                dw_fatal("Too many upstream servers, limit 20,000");
        }

        return out;

}


dw_str *make_synth_record(dw_str *rawname, dw_str *record, int type, int ttl) {
        dw_str *out = 0;
        if(rawname == 0 || record == 0) {
                return 0;
        }
        out = dw_create(rawname->len + record->len + 35);
        if(out == 0) {
                return 0;
        }
        
        if(ttl < 0) {
                ttl = 0;
        } else if(ttl > 65535) {
                ttl = 65535;
        }
        if(dw_append(rawname, out) == -1 ||  dw_push_u16(type, out) == -1 || dw_push_u16(1, out) == -1 || dw_push_u16(0, out) == -1 || dw_push_u16(ttl, out) == -1 || dw_push_u16(record->len, out) == -1 || dw_append(record, out) == -1 || dw_push_u16(0, out) == -1 || dw_push_u16(rawname->len, out) == 1 || dw_push_u16(1, out) == -1 || dw_push_u16(0, out) == -1 || dw_push_u16(0, out) == -1 || dw_addchar(TYPE_ANSWER,out) == -1) {











                dw_destroy(out);
                return 0;
        }
        return out;
}


dw_str *make_synth_ip4(dw_str *rawname, char *ipv4, int ttl) {
        dw_str *ip = 0;
        dw_str *out = 0;
        ip = dw_create(18); 
        if(ip == 0 || rawname == 0 || ipv4 == 0) {
                return 0;
        }
        ip->len = 4;
        if(inet_pton(AF_INET, ipv4, ip->str) != 1) { 
                dw_destroy(ip);
                return 0;
        }
        out = make_synth_record(rawname, ip, 1 , ttl);
        dw_destroy(ip);
        return out;
}


dw_str *make_synth_ip6(dw_str *rawname, dw_str *ipv6, int ttl) {
        dw_str *ip = 0;
        dw_str *out = 0;
        int a, n, v = 0, l, seen;
        ip = dw_create(18);
        if(ip == 0 || rawname == 0 || ipv6 == 0 || ipv6->len < 32 || ipv6->len > 64) {
                if(ip != 0) { dw_destroy(ip); }
                return 0;
        }
        ip->len = 16;
	l = 0; 
        for(a = 0; a < ipv6->len; a++) {
		seen = 1;
                n = *(ipv6->str + a);
                if(n >= '0' && n <= '9') {
                        v = n - '0';
                } else if(n == '_') {
                        v = 0;
                } else if(n >= 'a' && n <= 'f') {
                        v = 10 + (n - 'a');
                } else if(n >= 'A' && n <= 'F') {
                        v = 10 + (n - 'A');
		} else if(n == '-' || n == ' ') {
			seen = 0;
		} else {
                        dw_destroy(ip);
                        return 0; 
                }
                if(seen == 1 && (l & 1) == 0) {
                        v <<= 4;
                        *(ip->str + (l >> 1)) = 0;
                }
		if(seen == 1 && l < 32) {
                	*(ip->str + (l >> 1)) |= v;
			l++;
		} else if(seen == 1) {
                        dw_destroy(ip);
                        return 0; 
                }
        }
	if(l != 32) {
                dw_destroy(ip);
                return 0;
        }
        out = make_synth_record(rawname, ip, 28, ttl);
        dw_destroy(ip);
        return out;
}


int process_ip4_params() {
        dw_str *lastkey = 0, *key = 0, *value = 0, *rawname = 0, *cache_key = 0, *cache_data = 0;
        char *ip_human = 0;
        int a = 0, out = 0;
        dw_log_string("Begin processing of ip4",100);
        for(a=0;a<500000;a++) {
                key = dwm_dict_nextkey(DWM_D_ip4,lastkey);
                dw_destroy(lastkey);
                if(key == 0) { 
                        break;
                }
                value = dwm_dict_fetch(DWM_D_ip4,key);
                rawname = dw_dnsname_convert(key);
                if(value != 0 && value->len == 1 && value->str !=0 && *(value->str) == 'X') {
                        cache_data = dw_create(2);
                        if(dw_addchar(TYPE_BLOCKLIST_ENTRY,cache_data) == -1) {
                                dw_log_dwstr("Problem processing ",key,0);
                                dw_log_dwstr("With ip4 value ",value,0);
                                dw_fatal("Fatal error processing ip4 entry");
                        }
                        ip_human = 0;
                } else {
                        ip_human = (char *)dw_to_cstr(value);
                        if(ip_human == 0) {
                                dw_log_dwstr("Problem processing ",key,0);
                                dw_log_dwstr("With ip4 value ",value,0);
                                dw_fatal("Fatal error processing ip4 entry");
                        }
                        cache_data = make_synth_ip4(rawname, ip_human, 30);
                }
                if(value == 0 || rawname == 0 || cache_data == 0) {
                        dw_log_dwstr("Problem processing ",key,0);
                        dw_log_dwstr("With ip4 value ",value,0);
                        dw_fatal("Fatal error processing ip4 entry");
                }
                cache_key = dw_create(rawname->len + 3);
                if(cache_key == 0 || dw_append(rawname, cache_key) == -1 || dw_push_u16(1, cache_key) == -1) {

                        dw_log_dwstr_str("",value," is ip4 entry name",0);
                        dw_fatal("Fatal error processing ip4 cache_key");
                }
                
                dwh_add(cache, cache_key, cache_data, 1, 2);
                out = 1;
                lastkey = dw_copy(key);
                
                dw_destroy(key);
                dw_destroy(value);
                dw_destroy(rawname);
                dw_destroy(cache_key);
                dw_destroy(cache_data);
                if(ip_human != 0) {
                        free(ip_human);
                }
        }
        if(a >= 500000) {
                dw_fatal("Too many ip4 entries, limit 500,000");
        }
        dw_log_string("End processing of ip4",100);
        return out;
}


int process_ip6_params() {
        dw_str *lastkey = 0, *key = 0, *value = 0, *rawname = 0, *cache_key = 0, *cache_data = 0;
        int a = 0, out = 0;
        for(a=0;a<20000;a++) {
                key = dwm_dict_nextkey(DWM_D_ip6,lastkey);
                dw_destroy(lastkey);
                if(key == 0) { 
                        break;
                }
                value = dwm_dict_fetch(DWM_D_ip6,key);
                rawname = dw_dnsname_convert(key);
                cache_data = make_synth_ip6(rawname, value, 30);
                if(value == 0 || rawname == 0 || cache_data == 0) {
                        dw_log_dwstr_str("",value," is ip6 entry name",0);
                        dw_fatal("Fatal error processing ip6 entry");
                }
                cache_key = dw_create(rawname->len + 3);
                if(cache_key == 0 || dw_append(rawname, cache_key) == -1 || dw_push_u16(28, cache_key) == -1) {

                        dw_log_dwstr_str("",value," is ip6 entry name",0);
                        dw_fatal("Fatal error processing ip6 cache_key");
                }
                
                dwh_add(cache, cache_key, cache_data, 1, 2);
                out = 1;
                lastkey = dw_copy(key);
                
                dw_destroy(key);
                dw_destroy(value);
                dw_destroy(rawname);
                dw_destroy(cache_key);
                dw_destroy(cache_data);
        }
        if(a >= 20000) {
                dw_fatal("Too many ip6 entries, limit 20,000.\n" "Use ip4[\"evil.example.com\"] = \"X\" instead.");
        }
        return out;
}


void process_root_upstream() {
        int elements_in_cache = 0;
        dw_str *s = 0, *q = 0, *ns_refer = 0;

        elements_in_cache += process_root_upstream_servers(DWM_D_upstream_servers,1, "Bad dwood3rc line looks like:\nupstream_servers[\"");

        elements_in_cache += process_root_upstream_servers(DWM_D_root_servers,0, "Bad dwood3rc line looks like:\nroot_servers[\"");


        if(elements_in_cache == 0) { 
                dw_log_3strings("Using https://quad9.net upstream servers:", " ", UPSTREAM_SERVERS,1);

                s = dw_create(256);
                q = dw_create(16);
                dw_qrappend((uint8_t *)UPSTREAM_SERVERS,s,0);
                ns_refer = dwx_ns_convert(s,1,0);
                dw_put_u8(q,0,-1); 
                dw_put_u16(q,65395,-1); 
                dwh_add(cache,q,ns_refer,1,2);
                dw_destroy(q);
                dw_destroy(s);
                dw_destroy(ns_refer);
        }
}


void process_mararc_params() {
        dw_str *bind = 0, *r_acl = 0, *source_ip4 = 0;
        int a;

        bind = get_bind_addrs();
        if(bind == 0) {
                dw_fatal("Could not bind");
        }
        set_ip_list(bind_address,bind);

        r_acl = dw_copy(key_s[DWM_S_recursive_acl]);
        if(r_acl == 0) {
                dw_fatal("Could not get recursive_acl");
        }
        set_ipmask_list(recursive_acl,r_acl);

	source_ip4 = dw_copy(key_s[DWM_S_source_ip4]);
	if(source_ip4) {
		global_source_ip4 = inet_addr((char *)source_ip4->str);
		if(global_source_ip4 == INADDR_NONE) {
			dw_fatal("Invalid source_ip4 value");
		}
	}


        
        for(a = 0; a < DW_MAXIPS; a++) {
                if(bind_address[a].len == 0) {
                        break;
                }
                if(check_ip_acl(&(bind_address[a])) != 1) {
                        dw_log_ip("This IP is not in recursive_acl: ", &(bind_address[a]),0);
                        dw_fatal("All bind_address values must be in" " recursive_acl");
                }
        }
        if(DW_MAXIPS == a) {
                dw_fatal("Too many bind_address IPs");
        }


        process_numeric_mararc_params();

        
        b_remote = dw_malloc((maxprocs + 1) * sizeof(int));
        rem = dw_malloc((maxprocs + 1) * sizeof(remote_T));

        
        if(b_remote == 0) {
                dw_fatal("Could not allocate b_remote!");
        }
        if(rem == 0) {
                dw_fatal("Could not allocate rem!");
        }

        if(key_s[DWM_S_ip_blocklist] != 0 && key_s[DWM_S_ip_blacklist] != 0) {
                dw_fatal( "Both ip_blacklist and ip_blocklist are set.  Use ip_blocklist.");
        }
        if(key_s[DWM_S_ip_blocklist] != 0) {
                blocklist_dict = make_ip_dict(key_s[DWM_S_ip_blocklist]);
        } else if(key_s[DWM_S_ip_blacklist] != 0) {
                
                dw_log_string("ip_blacklist is now ip_blocklist",100);
                blocklist_dict = make_ip_dict(key_s[DWM_S_ip_blacklist]);
        }

        if(bind != 0) {
                dw_destroy(bind);
                bind = 0;
        }
        if(r_acl != 0) {
                dw_destroy(r_acl);
                r_acl = 0;
        }
}


void init_b_remote() {
        int_fast32_t a = 0;
        for(a = 0; a < maxprocs; a++) {
                b_remote[a] = INVALID_SOCKET;
                rem[a].socket = INVALID_SOCKET;
                rem[a].query = 0;
                rem[a].glueless = 0;
                rem[a].local = 0;
                rem[a].ns = 0;
                reset_rem(a);
        }
}


SOCKET find_max(int *list, int_fast32_t max) {
        int_fast32_t a = 0;
        int ret = -1;
        for(a = 0; a < max ; a++) {
                if(list[a] > ret) {
                        ret = list[a];
                }
        }
        return ret;
}


SOCKET get_max() {
        int a = 0;
        int b = 0;
        int c = 0;
        int max = 0;

        
        c = find_max(b_local,DW_MAXIPS);
        b = find_max(b_remote,maxprocs);
        if(c > b) {
                max = c;
        } else {
                max = b;
        }

        
        for(a = 0; a < DW_MAXIPS; a++) {
                if(tcp_b_local[a] > max) {
                        max = tcp_b_local[a];
                }
        }

        
        return max + 1;
}


void set_rx_fd(fd_set *rx_fd) {
        int_fast32_t a = 0;
        FD_ZERO(rx_fd);

        
        for(a = 0; a < DW_MAXIPS; a++) {
                if(b_local[a] != -1) {
                        FD_SET(b_local[a],rx_fd);
                }
        }
        for(a = 0; a < maxprocs; a++) {
                if(b_remote[a] != -1) {
                        FD_SET(b_remote[a],rx_fd);
                }
        }

        
        if(key_n[DWM_N_tcp_listen] == 1) {
                for(a = 0; a < DW_MAXIPS; a++) {
                        if(tcp_b_local[a] != -1) {
                                FD_SET(tcp_b_local[a],rx_fd);
                        }
                }
        }

}


int_fast32_t find_free_remote() {
        int_fast32_t a = 0;
        for(a = 0; a < maxprocs; a++) {
                if(rem[a].socket == INVALID_SOCKET && rem[a].local == 0) {
                        return a;
                }
        }
        return -1; 
}


dw_str *get_upstream_ns(dw_str *query, int connection_number) {
        dw_str *q = 0, *r = 0;
        int a = 0;

        
        r = dw_copy(query);
        dw_pop_u16(r);
        dw_put_u16(r, 65395, -1); 

        
        for(a=0; q == 0 && a < 260; a++) {
                q = dwh_get(cache,r,0,1);
                if(q == 0) {
                        q = dw_dnslabel_chop(r);
                        dw_destroy(r);
                        r = 0;
                        r = dw_copy(q);
                        dw_destroy(q);
                        q = 0;
                }
                if(r == 0) {
                        break;
                }
        }

        dw_destroy(r);
        r = 0;

        
        if(dw_fetch_u8(q,-1) == TYPE_UPSTREAM_REFER) {
                rem[connection_number].is_upstream = 1;
        }

        
        return q;
}


ip_addr_T get_upstream_ip(dw_str *query, int b) {
        ip_addr_T addr = {0,{0,0},0,0};

        if(rem[b].ns == 0) {
                rem[b].ns = get_upstream_ns(query,b);
        }

        if(rem[b].ns == 0) {
                return addr; 
        }

        return dwx_ns_getip(rem[b].ns,rng_seed,b);

}





void process_results(int a, fd_set *rx_fd) {
        int_fast32_t b = 0, z = 0;

        
        while(a > 0 && z < 50000) {
                
                for(b = 0; b < DW_MAXIPS; b++) {
                        if(b_local[b] != -1 && FD_ISSET(b_local[b],rx_fd)) {
                                get_local_udp_packet(b_local[b]);
                                dec_a();
                        }
                }
                
                for(b = 0; b < maxprocs; b++) {
                        if(b_remote[b] != -1 && FD_ISSET(b_remote[b],rx_fd)) {
                                get_remote_udp_packet(b, b_remote[b]);
                                dec_a();
                        }
                }
                
                for(b = 0; b < DW_MAXIPS; b++) {
                        if(tcp_b_local[b] != INVALID_SOCKET && FD_ISSET(tcp_b_local[b],rx_fd)) {
                                local_tcp_accept(tcp_b_local[b]);
                                dec_a();
                        }
                }
                z++;
        }
}


int handle_resurrections(int a) {
        dw_str *value = 0;
        dw_str *packet = 0;
        int ret = 0;
        int local_num = 0;

        value = dwh_get(cache,rem[a].query,1,1);
        if(value == 0) {
                goto catch_handle_resurrections;
        }

        for(local_num = 0; local_num < rem[a].num_locals; local_num++) {
                if(rem[a].local[local_num]->glueless_type != 0) {
                        continue;
                }
                packet = make_dns_packet(rem[a].query,value, rem[a].local[local_num]->local_id);
                if(packet == 0) {
                        goto catch_handle_resurrections;
                }

                if(rem[a].local[local_num]->tcp_num == -1) {
                        forward_remote_reply((unsigned char *)packet->str, packet->len, &rem[a], local_num);
                } else {
                        tcp_return_reply(rem[a].local[local_num]->tcp_num, (void *)packet->str, packet->len);
                }
                if(packet != 0) {
                        dw_destroy(packet);
                        packet = 0;
                }
        }

        ret = 1;

catch_handle_resurrections:
        if(value != 0) {
                dw_destroy(value);
                value = 0;
        }
        if(packet != 0) {
                dw_destroy(packet);
                packet = 0;
        }
        return ret;
}


int handle_expired(int a) {
        dw_str *packet = 0;
        int ret = 0, t = 0, local_num = 0;

        if(rem[a].retries > 0) {
                
                rem[a].retries--;
                closesocket(rem[a].socket);
                rem[a].socket = INVALID_SOCKET;
                
                rem[a].remote_id = dwr_rng(rng_seed);
                if(rem[a].is_upstream == 1) {
                        packet = make_dns_header(rem[a].remote_id,0x180,0,0,0);
                } else {
                        packet = make_dns_header(rem[a].remote_id,0x080,0,0,0);
                }
                if(dw_append(rem[a].query,packet) == -1 || dw_put_u16(packet,1,-1) == -1 ) {
                        goto catch_handle_expired;
                }
                dw_log_dwstr_str("Connection for query ",rem[a].query, " did not respond; trying again",128);
                make_remote_connection(a,(unsigned char *)packet->str, packet->len,rem[a].query,INVALID_SOCKET);
                rem[a].die = get_time() + ((int64_t)timeout_seconds << 8);
                ret = 1; 
                goto catch_handle_expired;
        }
        if(resurrections == 1) {
                if(handle_resurrections(a) == 1) {
                        goto catch_handle_expired;
                }
        }
        for(local_num = 0; local_num < rem[a].num_locals; local_num++) {
                if(handle_noreply == 1) {
                        server_fail_noreply(a, local_num);
                } else if(rem[a].local[local_num]->tcp_num != -1) {
                        t = rem[a].local[local_num]->tcp_num;
                        
                        closesocket(tcp_pend[t].local);
                        reset_tcp_pend(t);
                }
        }

catch_handle_expired:
        if(packet != 0) {
                dw_destroy(packet);
                packet = 0;
        }
        return ret;
}


void kill_expired() {
        int_fast32_t a = 0;
        for(a = 0; a < maxprocs; a++) {
                if(rem[a].die > 0 && rem[a].die < get_time()) {
                        if(handle_expired(a) == 1) {
                                continue;
                        }
                        closesocket(rem[a].socket);
                        b_remote[a] = INVALID_SOCKET;
                        reset_rem(a);
                }
        }
}



extern int got_signal;

extern int run_loop;
extern FILE *LOG;



int bigloop() {
        int a = 0, b = 0;
        int max = 0;
        fd_set rx_fd;
        struct timeval timeout;

        for(;;) {

        while(run_loop == 1) {

                set_time();
                max = get_max();
                set_rx_fd(&rx_fd);
                timeout.tv_sec = 0;
                timeout.tv_usec = 50000; 
                a = select(max,&rx_fd,NULL,NULL,&timeout);

                
                if(a > 0) {
                        process_results(a,&rx_fd);

                } else {
                        fflush(LOG);

                }
                
                
                for(b = 0; b < max_tcp_procs; b++) {
                        tcp_handle_all(b);
                }
                kill_expired();
                kill_tcp_expired();

                
                if(got_signal != 0) {
                        dw_log_number("Got signal ", got_signal," to process...",1);
                        process_signal(got_signal);
                }

        }

        process_signal(1);

        return 0; 
}

