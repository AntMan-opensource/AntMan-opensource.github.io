








































































dw_str *key_s[KEY_S_COUNT + 1]; 
dwd_dict *key_d[KEY_D_COUNT + 1]; 
int32_t key_n[KEY_N_COUNT + 1]; 

char *key_s_names[KEY_S_COUNT + 1] = {
        "bind_address",  "ipv4_bind_addresses", "chroot_dir", "recursive_acl", "random_seed_file", "cache_file", "ip_blacklist", "ip_blocklist", "source_ip4", 0 };









char *key_d_names[KEY_D_COUNT + 1] = {
        "upstream_servers",  "root_servers", "ip4", "ip6", 0 };




char *key_n_names[KEY_N_COUNT + 1] = {
        "maxprocs",  "timeout_seconds", "dns_port", "upstream_port", "handle_overload", "handle_noreply", "recurse_min_bind_port", "recurse_number_ports", "hash_magic_number", "maximum_cache_elements", "maradns_uid", "maradns_gid", "resurrections", "num_retries", "verbose_level", "max_tcp_procs", "timeout_seconds_tcp", "tcp_listen", "max_ar_chain", "ttl_age", "max_inflights", "deliver_all", "filter_rfc1918", "ns_glueless_type", "reject_aaaa", "reject_mx", "truncation_hack", "reject_ptr", "min_ttl_incomplete_cname", "max_ttl", "min_ttl", 0 };




































































































typedef struct {
        char pattern[DWM_MAX_PATTERNS + 1];
        char action[DWM_MAX_PATTERNS + 1];
        char newstate[DWM_MAX_PATTERNS + 1];
        } dwm_fs;


int dwm_parse_mararc(char *name);


dw_str *dwm_dict_fetch(int num, dw_str *key);


int32_t dwm_dict_size(int num);


dw_str *dwm_dict_nextkey(int num, dw_str *key);


int dwm_parse_file(char *name);


