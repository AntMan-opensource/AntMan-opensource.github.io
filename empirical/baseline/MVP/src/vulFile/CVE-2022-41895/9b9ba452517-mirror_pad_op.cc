





















namespace tensorflow {

template <typename Device, typename T, typename Tpaddings> class MirrorPadOp : public OpKernel {
 public:
  explicit MirrorPadOp(OpKernelConstruction* context) : OpKernel(context) {
    MirrorPadMode mode;
    OP_REQUIRES_OK(context, context->GetAttr("mode", &mode));

    switch (mode) {
      case MirrorPadMode::SYMMETRIC: {
        offset_ = 0;
        break;
      }
      case MirrorPadMode::REFLECT: {
        offset_ = 1;
        break;
      }
      default:
        OP_REQUIRES(context, false, errors::InvalidArgument( "mode must be either REFLECT or SYMMETRIC."));

    }
  }

  ~MirrorPadOp() override = default;

  void Compute(OpKernelContext* context) override {
    const Tensor& in0 = context->input(0);
    const Tensor& in1 = context->input(1);
    const int dims = in0.dims();
    constexpr int kMinDims = 0;
    constexpr int kMaxDims = 5;
    OP_REQUIRES(context, kMinDims <= dims && dims <= kMaxDims, errors::Unimplemented("inputs rank not in [", kMinDims, ",", kMaxDims, "]: ", dims));

    OP_REQUIRES( context, TensorShapeUtils::IsMatrix(in1.shape()) && in1.dim_size(1) == 2, errors::InvalidArgument("paddings must be a matrix with 2 columns: ", in1.shape().DebugString()));



    OP_REQUIRES( context, dims == in1.dim_size(0), errors::InvalidArgument( "The first dimension of paddings must be the rank of inputs", in1.shape().DebugString(), ", ", in0.shape().DebugString()));




    
    TensorShape output_shape;
    typename TTypes<Tpaddings>::ConstMatrix paddings = in1.matrix<Tpaddings>();
    for (int d = 0; d < dims; ++d) {
      const Tpaddings before = paddings(d, 0);  
      const Tpaddings after = paddings(d, 1);   
      OP_REQUIRES(context, before >= 0 && after >= 0, errors::InvalidArgument( "paddings must be non-negative: ", before, " ", after));

      if (offset_ == 0) {  
        OP_REQUIRES(context, before <= in0.dim_size(d) && after <= in0.dim_size(d), errors::InvalidArgument("paddings must be no greater " "than the dimension size: ", before, ", ", after, " greater than ", in0.dim_size(d)));




      } else if (offset_ == 1) {  
        OP_REQUIRES( context, before < in0.dim_size(d) && after < in0.dim_size(d), errors::InvalidArgument("paddings must be less than" " the dimension size: ", before, ", ", after, " not less than ", in0.dim_size(d)));




      }

      output_shape.AddDim(before + in0.dim_size(d) + after);
    }

    if (output_shape.num_elements() == in0.NumElements()) {
      
      Tensor out;
      CHECK(out.CopyFrom(in0, output_shape));
      context->set_output(0, out);
      return;
    }

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));








    
    switch (dims) {
      MIRROR_PAD_CASE(1)
      MIRROR_PAD_CASE(2)
      MIRROR_PAD_CASE(3)
      MIRROR_PAD_CASE(4)
      MIRROR_PAD_CASE(5)
      default:
        OP_REQUIRES(context, false, errors::InvalidArgument("Unsupported rank: ", in0.shape().DebugString()));

    }

  }

 private:
  int offset_;
};

using CpuDevice = Eigen::ThreadPoolDevice;
using GpuDevice = Eigen::GpuDevice;

namespace functor {




















TF_CALL_POD_TYPES(DECLARE_CPU_SPECS);
TF_CALL_QUANTIZED_TYPES(DECLARE_CPU_SPECS);
TF_CALL_tstring(DECLARE_CPU_SPECS);



}  















TF_CALL_POD_TYPES(REGISTER_KERNEL);
TF_CALL_QUANTIZED_TYPES(REGISTER_KERNEL);
TF_CALL_tstring(REGISTER_KERNEL);



namespace functor {



















TF_CALL_GPU_NUMBER_TYPES(DECLARE_GPU_SPECS);


}  















TF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_KERNEL);




template <typename Device, typename T, typename Tpaddings> class MirrorPadGradOp : public OpKernel {
 public:
  explicit MirrorPadGradOp(OpKernelConstruction* context) : OpKernel(context) {
    MirrorPadMode mode;
    OP_REQUIRES_OK(context, context->GetAttr("mode", &mode));

    switch (mode) {
      case MirrorPadMode::SYMMETRIC: {
        offset_ = 0;
        break;
      }
      case MirrorPadMode::REFLECT: {
        offset_ = 1;
        break;
      }
      default:
        OP_REQUIRES(context, false, errors::InvalidArgument( "mode must be either REFLECT or SYMMETRIC."));

    }
  }

  ~MirrorPadGradOp() override = default;

  void Compute(OpKernelContext* context) override {
    const Tensor& in0 = context->input(0);
    const Tensor& in1 = context->input(1);
    const int dims = in0.dims();
    constexpr int kMinDims = 0;
    constexpr int kMaxDims = 5;
    OP_REQUIRES(context, kMinDims <= dims && dims <= kMaxDims, errors::Unimplemented("inputs rank not in [", kMinDims, ",", kMaxDims, "]: ", dims));

    OP_REQUIRES( context, TensorShapeUtils::IsMatrix(in1.shape()) && in1.dim_size(1) == 2, errors::InvalidArgument("paddings must be a matrix with 2 columns: ", in1.shape().DebugString()));



    OP_REQUIRES( context, dims == in1.dim_size(0), errors::InvalidArgument( "The first dimension of paddings must be the rank of inputs", in1.shape().DebugString(), " ", in0.shape().DebugString()));




    
    TensorShape output_shape;
    typename TTypes<Tpaddings>::ConstMatrix paddings = in1.matrix<Tpaddings>();
    for (int d = 0; d < dims; ++d) {
      const Tpaddings before = paddings(d, 0);  
      const Tpaddings after = paddings(d, 1);   
      OP_REQUIRES(context, before >= 0 && after >= 0, errors::InvalidArgument( "Paddings must be non-negative: ", before, ", ", after));


      const int64_t out_size = in0.dim_size(d) - (before + after);
      if (offset_ == 0) {  
        OP_REQUIRES(context, before <= out_size && after <= out_size, errors::InvalidArgument("paddings must be no greater " "than the output dimension size: ", before, ", ", after, " greater than ", out_size));



      } else if (offset_ == 1) {  
        OP_REQUIRES(context, before < out_size && after < out_size, errors::InvalidArgument("paddings must be less than" " the output dimension size: ", before, ", ", after, " not less than ", out_size));



      }
      output_shape.AddDim(out_size);
    }

    if (output_shape == in0.shape()) {
      context->set_output(0, in0);
      return;
    }

    Tensor scratch;
    OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<T>::value, in0.shape(), &scratch));

    Tensor* output = nullptr;
    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));









    
    switch (dims) {
      MIRROR_PAD_GRAD_CASE(1);
      MIRROR_PAD_GRAD_CASE(2);
      MIRROR_PAD_GRAD_CASE(3);
      MIRROR_PAD_GRAD_CASE(4);
      MIRROR_PAD_GRAD_CASE(5);
      default:
        OP_REQUIRES(context, false, errors::InvalidArgument("Unsupported rank: ", in0.shape().DebugString()));

    }

  }

 private:
  int offset_;
};

namespace functor {





















TF_CALL_NUMBER_TYPES(DECLARE_CPU_SPECS);


}  














TF_CALL_NUMBER_TYPES(REGISTER_KERNEL);



namespace functor {




















TF_CALL_GPU_NUMBER_TYPES(DECLARE_GPU_SPECS);


}  















TF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU_KERNEL);



}  
