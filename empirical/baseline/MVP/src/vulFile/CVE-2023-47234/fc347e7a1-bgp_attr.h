



































































struct bgp_attr_encap_subtlv {
	struct bgp_attr_encap_subtlv *next; 
	
	unsigned long refcnt;
	uint16_t type;
	uint16_t length;
	uint8_t value[0]; 
};



struct bgp_tea_options {
	struct bgp_tea_options *next;
	uint8_t options_count;
	uint16_t options_length; 
	uint8_t type;
	uint8_t length;
	void *value; 
};



enum pta_type {
	PMSI_TNLTYPE_NO_INFO = 0, PMSI_TNLTYPE_RSVP_TE_P2MP, PMSI_TNLTYPE_MLDP_P2MP, PMSI_TNLTYPE_PIM_SSM, PMSI_TNLTYPE_PIM_SM, PMSI_TNLTYPE_PIM_BIDIR, PMSI_TNLTYPE_INGR_REPL, PMSI_TNLTYPE_MLDP_MP2MP, PMSI_TNLTYPE_MAX = PMSI_TNLTYPE_MLDP_MP2MP };










struct bgp_attr_srv6_vpn {
	unsigned long refcnt;
	uint8_t sid_flags;
	struct in6_addr sid;
};


struct bgp_attr_srv6_l3vpn {
	unsigned long refcnt;
	uint8_t sid_flags;
	uint16_t endpoint_behavior;
	struct in6_addr sid;
	uint8_t loc_block_len;
	uint8_t loc_node_len;
	uint8_t func_len;
	uint8_t arg_len;
	uint8_t transposition_len;
	uint8_t transposition_offset;
};


struct attr {
	
	struct aspath *aspath;

	
	struct community *community;

	
	unsigned long refcnt;

	
	uint64_t flag;

	
	struct in_addr nexthop;
	uint32_t med;
	uint32_t local_pref;
	ifindex_t nh_ifindex;

	
	uint8_t origin;

	
	enum pta_type pmsi_tnl_type;

	
	uint32_t rmap_change_flags;

	
	struct in6_addr mp_nexthop_global;
	struct in6_addr mp_nexthop_local;

	
	ifindex_t nh_lla_ifindex;

	
	struct ecommunity *ecommunity;

	
	struct ecommunity *ipv6_ecommunity;

	
	struct lcommunity *lcommunity;

	
	struct cluster_list *cluster1;

	
	struct transit *transit;

	struct in_addr mp_nexthop_global_in;

	
	struct in_addr aggregator_addr;

	
	struct in_addr originator_id;

	
	uint32_t weight;

	
	as_t aggregator_as;

	
	uint8_t mp_nexthop_len;

	
	uint8_t mp_nexthop_prefer_global;

	
	uint8_t sticky;

	
	uint8_t default_gw;

	
	uint8_t router_flag;

	
	uint8_t es_flags;
	

	

	

	

	


	




	
	route_tag_t tag;

	
	uint32_t label_index;

	
	mpls_label_t label;

	
	struct bgp_attr_srv6_vpn *srv6_vpn;

	
	struct bgp_attr_srv6_l3vpn *srv6_l3vpn;

	uint16_t encap_tunneltype;		     
	struct bgp_attr_encap_subtlv *encap_subtlvs; 


	struct bgp_attr_encap_subtlv *vnc_subtlvs; 

	
	struct bgp_route_evpn evpn_overlay;

	
	uint32_t mm_seqnum;
	
	uint32_t mm_sync_seqnum;

	
	struct ethaddr rmac;

	
	uint8_t distance;

	
	uint32_t rmap_table_id;

	
	uint32_t link_bw;

	
	esi_t esi;

	
	uint32_t srte_color;

	
	uint16_t df_pref;
	uint8_t df_alg;

	
	enum nexthop_types_t nh_type;

	
	enum blackhole_type bh_type;

	
	uint32_t otc;

	
	uint64_t aigp_metric;
};















struct cluster_list {
	unsigned long refcnt;
	int length;
	struct in_addr *list;
};


struct transit {
	unsigned long refcnt;
	int length;
	uint8_t *val;
};








enum bgp_attr_parse_ret {
	BGP_ATTR_PARSE_PROCEED = 0, BGP_ATTR_PARSE_ERROR = -1, BGP_ATTR_PARSE_WITHDRAW = -2,   BGP_ATTR_PARSE_ERROR_NOTIFYPLS = -3, };






struct bpacket_attr_vec_arr;


extern void bgp_attr_init(void);
extern void bgp_attr_finish(void);
extern enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr, bgp_size_t size, struct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw);

extern struct attr *bgp_attr_intern(struct attr *attr);
extern void bgp_attr_unintern_sub(struct attr *attr);
extern void bgp_attr_unintern(struct attr **pattr);
extern void bgp_attr_flush(struct attr *attr);
extern struct attr *bgp_attr_default_set(struct attr *attr, struct bgp *bgp, uint8_t origin);
extern struct attr *bgp_attr_aggregate_intern( struct bgp *bgp, uint8_t origin, struct aspath *aspath, struct community *community, struct ecommunity *ecommunity, struct lcommunity *lcommunity, struct bgp_aggregate *aggregate, uint8_t atomic_aggregate, const struct prefix *p);



extern bgp_size_t bgp_packet_attribute( struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr, struct bpacket_attr_vec_arr *vecarr, struct prefix *p, afi_t afi, safi_t safi, struct peer *from, struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct bgp_path_info *bpi);




extern void bgp_dump_routes_attr(struct stream *s, struct bgp_path_info *bpi, const struct prefix *p);
extern bool attrhash_cmp(const void *arg1, const void *arg2);
extern unsigned int attrhash_key_make(const void *p);
extern void attr_show_all(struct vty *vty);
extern unsigned long int attr_count(void);
extern unsigned long int attr_unknown_count(void);
extern void bgp_path_attribute_discard_vty(struct vty *vty, struct peer *peer, const char *discard_attrs, bool set);
extern void bgp_path_attribute_withdraw_vty(struct vty *vty, struct peer *peer, const char *withdraw_attrs, bool set);

extern enum bgp_attr_parse_ret bgp_attr_ignore(struct peer *peer, uint8_t type);


extern bool cluster_loop_check(struct cluster_list *cluster, struct in_addr originator);


struct bgp_attr_parser_args {
	struct peer *peer;
	bgp_size_t length; 
	bgp_size_t total;  
	struct attr *attr;
	uint8_t type;
	uint8_t flags;
	uint8_t *startp;
};
extern int bgp_mp_reach_parse(struct bgp_attr_parser_args *args, struct bgp_nlri *mp_update);
extern int bgp_mp_unreach_parse(struct bgp_attr_parser_args *args, struct bgp_nlri *mp_withdraw);
extern enum bgp_attr_parse_ret bgp_attr_prefix_sid(struct bgp_attr_parser_args *args);

extern struct bgp_attr_encap_subtlv * encap_tlv_dup(struct bgp_attr_encap_subtlv *orig);

extern void bgp_attr_flush_encap(struct attr *attr);

extern void bgp_attr_extcom_tunnel_type(struct attr *attr, bgp_encap_types *tunnel_type);


extern size_t bgp_packet_mpattr_start(struct stream *s, struct peer *peer, afi_t afi, safi_t safi, struct bpacket_attr_vec_arr *vecarr, struct attr *attr);


extern void bgp_packet_mpattr_prefix(struct stream *s, afi_t afi, safi_t safi, const struct prefix *p, const struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct attr *);




extern size_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi, const struct prefix *p);
extern void bgp_packet_mpattr_end(struct stream *s, size_t sizep);

extern size_t bgp_packet_mpunreach_start(struct stream *s, afi_t afi, safi_t safi);
extern void bgp_packet_mpunreach_prefix( struct stream *s, const struct prefix *p, afi_t afi, safi_t safi, const struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct attr *attr);


extern void bgp_packet_mpunreach_end(struct stream *s, size_t attrlen_pnt);

extern enum bgp_attr_parse_ret bgp_attr_nexthop_valid(struct peer *peer, struct attr *attr);

extern uint32_t bgp_attr_get_color(struct attr *attr);

static inline bool bgp_rmap_nhop_changed(uint32_t out_rmap_flags, uint32_t in_rmap_flags)
{
	return ((CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_PEER_ADDRESS) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV4_NHOP_CHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_VPNV4_NHOP_CHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_VPNV6_GLOBAL_NHOP_CHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV6_GLOBAL_NHOP_CHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV6_PREFER_GLOBAL_CHANGED) || CHECK_FLAG(out_rmap_flags, BATTR_RMAP_IPV6_LL_NHOP_CHANGED) || CHECK_FLAG(in_rmap_flags, BATTR_RMAP_NEXTHOP_UNCHANGED))










			? true : false);
}

static inline uint32_t mac_mobility_seqnum(struct attr *attr)
{
	return (attr) ? attr->mm_seqnum : 0;
}

static inline enum pta_type bgp_attr_get_pmsi_tnl_type(struct attr *attr)
{
	return attr->pmsi_tnl_type;
}

static inline void bgp_attr_set_pmsi_tnl_type(struct attr *attr, enum pta_type pmsi_tnl_type)
{
	attr->pmsi_tnl_type = pmsi_tnl_type;
}

static inline struct ecommunity * bgp_attr_get_ecommunity(const struct attr *attr)
{
	return attr->ecommunity;
}

static inline void bgp_attr_set_ecommunity(struct attr *attr, struct ecommunity *ecomm)
{
	attr->ecommunity = ecomm;

	if (ecomm)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES));
	else UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES));
}

static inline struct lcommunity * bgp_attr_get_lcommunity(const struct attr *attr)
{
	return attr->lcommunity;
}

static inline void bgp_attr_set_lcommunity(struct attr *attr, struct lcommunity *lcomm)
{
	attr->lcommunity = lcomm;

	if (lcomm)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES));
	else UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES));

}

static inline struct community *bgp_attr_get_community(const struct attr *attr)
{
	return attr->community;
}

static inline void bgp_attr_set_community(struct attr *attr, struct community *comm)
{
	attr->community = comm;

	if (comm)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES));
	else UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES));
}

static inline struct ecommunity * bgp_attr_get_ipv6_ecommunity(const struct attr *attr)
{
	return attr->ipv6_ecommunity;
}

static inline void bgp_attr_set_ipv6_ecommunity(struct attr *attr, struct ecommunity *ipv6_ecomm)
{
	attr->ipv6_ecommunity = ipv6_ecomm;

	if (ipv6_ecomm)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_IPV6_EXT_COMMUNITIES));
	else UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_IPV6_EXT_COMMUNITIES));

}

static inline struct transit *bgp_attr_get_transit(const struct attr *attr)
{
	return attr->transit;
}

static inline void bgp_attr_set_transit(struct attr *attr, struct transit *transit)
{
	attr->transit = transit;
}

static inline uint64_t bgp_attr_get_aigp_metric(const struct attr *attr)
{
	return attr->aigp_metric;
}

static inline void bgp_attr_set_aigp_metric(struct attr *attr, uint64_t aigp)
{
	attr->aigp_metric = aigp;

	if (aigp)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AIGP));
}

static inline struct cluster_list *bgp_attr_get_cluster(const struct attr *attr)
{
	return attr->cluster1;
}

static inline void bgp_attr_set_cluster(struct attr *attr, struct cluster_list *cl)
{
	attr->cluster1 = cl;

	if (cl)
		SET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST));
	else UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST));
}

static inline const struct bgp_route_evpn * bgp_attr_get_evpn_overlay(const struct attr *attr)
{
	return &attr->evpn_overlay;
}

static inline void bgp_attr_set_evpn_overlay(struct attr *attr, struct bgp_route_evpn *eo)
{
	memcpy(&attr->evpn_overlay, eo, sizeof(struct bgp_route_evpn));
}

static inline struct bgp_attr_encap_subtlv * bgp_attr_get_vnc_subtlvs(const struct attr *attr)
{

	return attr->vnc_subtlvs;

	return NULL;

}

static inline void bgp_attr_set_vnc_subtlvs(struct attr *attr, struct bgp_attr_encap_subtlv *vnc_subtlvs)

{

	attr->vnc_subtlvs = vnc_subtlvs;

}

extern bool route_matches_soo(struct bgp_path_info *pi, struct ecommunity *soo);


