



























int dalloc_add_talloc_chunk(DALLOC_CTX *dd, void *talloc_chunk, void *obj, size_t size)
{
    if (talloc_chunk) {
        
        dd->dd_talloc_array = talloc_realloc(dd, dd->dd_talloc_array, void *, talloc_array_length(dd->dd_talloc_array) + 1);


        memcpy(talloc_chunk, obj, size);
        dd->dd_talloc_array[talloc_array_length(dd->dd_talloc_array) - 1] = talloc_chunk;
    } else {
        
        dd->dd_talloc_array = talloc_realloc(dd, dd->dd_talloc_array, void *, talloc_array_length(dd->dd_talloc_array) + 1);


        dd->dd_talloc_array[talloc_array_length(dd->dd_talloc_array) - 1] = obj;

    }
    return 0;
}


int dalloc_size(DALLOC_CTX *d)
{
    if (!d || !d->dd_talloc_array)
        return 0;
    return talloc_array_length(d->dd_talloc_array);
}


void *dalloc_get(const DALLOC_CTX *d, ...)
{
    EC_INIT;
    void *p = NULL;
    va_list args;
    const char *type;
    int elem;
    const char *elemtype;

    va_start(args, d);
    type = va_arg(args, const char *);

    while (STRCMP(type, ==, "DALLOC_CTX")) {
        elem = va_arg(args, int);
        if (elem >= talloc_array_length(d->dd_talloc_array)) {
            LOG(log_error, logtype_sl, "dalloc_get(%s): bound check error: %d >= %d", type, elem >= talloc_array_length(d->dd_talloc_array));
            EC_FAIL;
        }
        d = d->dd_talloc_array[elem];
        type = va_arg(args, const char *);
    }

    elem = va_arg(args, int);
    if (elem >= talloc_array_length(d->dd_talloc_array)) {
        LOG(log_error, logtype_sl, "dalloc_get(%s): bound check error: %d >= %d", type, elem,  talloc_array_length(d->dd_talloc_array));
        EC_FAIL;
    }

    if (!(p = talloc_check_name(d->dd_talloc_array[elem], type))) {
        LOG(log_error, logtype_sl, "dalloc_get(%d/%s): type mismatch: %s", type, elem, talloc_get_name(d->dd_talloc_array[elem]));
    }

    va_end(args);

EC_CLEANUP:
    if (ret != 0)
        p = NULL;
    return p;
}

void *dalloc_value_for_key(const DALLOC_CTX *d, ...)
{
    EC_INIT;
    void *p = NULL;
    va_list args;
    const char *type;
    int elem;
    const char *elemtype;
    char *s;

    va_start(args, d);
    type = va_arg(args, const char *);

    while (STRCMP(type, ==, "DALLOC_CTX")) {
        elem = va_arg(args, int);
        AFP_ASSERT(elem < talloc_array_length(d->dd_talloc_array));
        d = d->dd_talloc_array[elem];
        type = va_arg(args, const char *);
    }

    for (elem = 0; elem + 1 < talloc_array_length(d->dd_talloc_array); elem += 2) {
        if (STRCMP(talloc_get_name(d->dd_talloc_array[elem]), !=, "char *")) {
            LOG(log_error, logtype_default, "dalloc_value_for_key: key not a string: %s", talloc_get_name(d->dd_talloc_array[elem]));
            EC_FAIL;
        }
        if (STRCMP((char *)d->dd_talloc_array[elem], ==, type)) {
            p = d->dd_talloc_array[elem + 1];
            break;
        }            
    }
    va_end(args);

EC_CLEANUP:
    if (ret != 0)
        p = NULL;
    return p;
}

char *dalloc_strdup(const void *ctx, const char *string)
{
    EC_INIT;
    char *p;

    EC_NULL( p = talloc_strdup(ctx, string) );
    talloc_set_name(p, "char *");

EC_CLEANUP:
    if (ret != 0) {
        if (p)
            talloc_free(p);
        p = NULL;
    }
    return p;
}

char *dalloc_strndup(const void *ctx, const char *string, size_t n)
{
    EC_INIT;
    char *p;

    EC_NULL( p = talloc_strndup(ctx, string, n) );
    talloc_set_name(p, "char *");

EC_CLEANUP:
    if (ret != 0) {
        if (p)
            talloc_free(p);
        p = NULL;
    }
    return p;
}
