




































CAPNP_BEGIN_HEADER                     namespace capnp {





















class ClientHook;

namespace _ {  

class PointerBuilder;
class PointerReader;
class StructBuilder;
class StructReader;
class ListBuilder;
class ListReader;
class OrphanBuilder;
struct WirePointer;
struct WireHelpers;
class SegmentReader;
class SegmentBuilder;
class Arena;
class BuilderArena;




typedef kj::UnitRatio<kj::Bounded<64, uint>, BitLabel, ElementLabel> BitsPerElementTableType;

typedef uint BitsPerElementTableType;


static constexpr BitsPerElementTableType BITS_PER_ELEMENT_TABLE[8] = {
  bounded< 0>() * BITS / ELEMENTS, bounded< 1>() * BITS / ELEMENTS, bounded< 8>() * BITS / ELEMENTS, bounded<16>() * BITS / ELEMENTS, bounded<32>() * BITS / ELEMENTS, bounded<64>() * BITS / ELEMENTS, bounded< 0>() * BITS / ELEMENTS, bounded< 0>() * BITS / ELEMENTS };








inline KJ_CONSTEXPR() BitsPerElementTableType dataBitsPerElement(ElementSize size) {
  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];
}

inline constexpr PointersPerElementN<1> pointersPerElement(ElementSize size) {
  return size == ElementSize::POINTER ? PointersPerElementN<1>(ONE * POINTERS / ELEMENTS)
      : PointersPerElementN<1>(ZERO * POINTERS / ELEMENTS);
}

static constexpr BitsPerElementTableType BITS_PER_ELEMENT_INCLUDING_PONITERS_TABLE[8] = {
  bounded< 0>() * BITS / ELEMENTS, bounded< 1>() * BITS / ELEMENTS, bounded< 8>() * BITS / ELEMENTS, bounded<16>() * BITS / ELEMENTS, bounded<32>() * BITS / ELEMENTS, bounded<64>() * BITS / ELEMENTS, bounded<64>() * BITS / ELEMENTS, bounded< 0>() * BITS / ELEMENTS };








inline KJ_CONSTEXPR() BitsPerElementTableType bitsPerElementIncludingPointers(ElementSize size) {
  return _::BITS_PER_ELEMENT_INCLUDING_PONITERS_TABLE[static_cast<int>(size)];
}

template <size_t size> struct ElementSizeForByteSize;
template <> struct ElementSizeForByteSize<1> { static constexpr ElementSize value = ElementSize::BYTE; };
template <> struct ElementSizeForByteSize<2> { static constexpr ElementSize value = ElementSize::TWO_BYTES; };
template <> struct ElementSizeForByteSize<4> { static constexpr ElementSize value = ElementSize::FOUR_BYTES; };
template <> struct ElementSizeForByteSize<8> { static constexpr ElementSize value = ElementSize::EIGHT_BYTES; };

template <typename T> struct ElementSizeForType {
  static constexpr ElementSize value =  CAPNP_KIND(T) == Kind::PRIMITIVE ? ElementSizeForByteSize<sizeof(T)>::value :

      CAPNP_KIND(T) == Kind::ENUM ? ElementSize::TWO_BYTES :
      CAPNP_KIND(T) == Kind::STRUCT ? ElementSize::INLINE_COMPOSITE :

      
      ElementSize::POINTER;
};


template <> struct ElementSizeForType<Void> { static constexpr ElementSize value = ElementSize::VOID; };
template <> struct ElementSizeForType<bool> { static constexpr ElementSize value = ElementSize::BIT; };


template <typename T, Kind K> struct ElementSizeForType<List<T, K>> {
  static constexpr ElementSize value = ElementSize::POINTER;
};
template <> struct ElementSizeForType<Text> {
  static constexpr ElementSize value = ElementSize::POINTER;
};
template <> struct ElementSizeForType<Data> {
  static constexpr ElementSize value = ElementSize::POINTER;
};

template <typename T> inline constexpr ElementSize elementSizeForType() {
  return ElementSizeForType<T>::value;
}

struct MessageSizeCounts {
  WordCountN<61, uint64_t> wordCount;  
  uint capCount;

  MessageSizeCounts& operator+=(const MessageSizeCounts& other) {
    
    
    wordCount = assumeBits<61>(wordCount + other.wordCount);
    capCount += other.capCount;
    return *this;
  }

  void addWords(WordCountN<61, uint64_t> other) {
    wordCount = assumeBits<61>(wordCount + other);
  }

  MessageSize asPublic() {
    return MessageSize { unbound(wordCount / WORDS), capCount };
  }
};



template <int wordCount> union AlignedData {
  
  

  uint8_t bytes[wordCount * sizeof(word)];
  word words[wordCount];
};

struct StructSize {
  StructDataWordCount data;
  StructPointerCount pointers;

  inline constexpr WordCountN<17> total() const { return data + pointers * WORDS_PER_POINTER; }

  StructSize() = default;
  inline constexpr StructSize(StructDataWordCount data, StructPointerCount pointers)
      : data(data), pointers(pointers) {}
};

template <typename T, typename CapnpPrivate = typename T::_capnpPrivate> inline constexpr StructSize structSize() {
  return StructSize(bounded(CapnpPrivate::dataWordSize) * WORDS, bounded(CapnpPrivate::pointerCount) * POINTERS);
}

template <typename T, typename CapnpPrivate = typename T::_capnpPrivate, typename = kj::EnableIf<CAPNP_KIND(T) == Kind::STRUCT>> inline constexpr StructSize minStructSizeForElement() {

  
  

  return StructSize(bounded(CapnpPrivate::dataWordSize) * WORDS, bounded(CapnpPrivate::pointerCount) * POINTERS);
}

template <typename T, typename = kj::EnableIf<CAPNP_KIND(T) != Kind::STRUCT>> inline constexpr StructSize minStructSizeForElement() {
  
  

  return StructSize( dataBitsPerElement(elementSizeForType<T>()) * ELEMENTS > ZERO * BITS ? StructDataWordCount(ONE * WORDS) : StructDataWordCount(ZERO * WORDS), pointersPerElement(elementSizeForType<T>()) * ELEMENTS);


}




template <typename T, Kind kind = CAPNP_KIND(T)> struct Mask_;
template <typename T> struct Mask_<T, Kind::PRIMITIVE> { typedef T Type; };
template <typename T> struct Mask_<T, Kind::ENUM> { typedef uint16_t Type; };
template <> struct Mask_<float, Kind::PRIMITIVE> { typedef uint32_t Type; };
template <> struct Mask_<double, Kind::PRIMITIVE> { typedef uint64_t Type; };

template <typename T> struct Mask_<T, Kind::OTHER> {
  
  static_assert(sizeof(T) == 2, "Don't know how to mask this type.");
  typedef uint16_t Type;
};

template <typename T> using Mask = typename Mask_<T>::Type;

template <typename T> KJ_ALWAYS_INLINE(Mask<T> mask(T value, Mask<T> mask));
template <typename T> KJ_ALWAYS_INLINE(T unmask(Mask<T> value, Mask<T> mask));

template <typename T> inline Mask<T> mask(T value, Mask<T> mask) {
  return static_cast<Mask<T> >(value) ^ mask;
}

template <> inline uint32_t mask<float>(float value, uint32_t mask) {

  if (value != value) {
    return 0x7fc00000u ^ mask;
  }


  uint32_t i;
  static_assert(sizeof(i) == sizeof(value), "float is not 32 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <> inline uint64_t mask<double>(double value, uint64_t mask) {

  if (value != value) {
    return 0x7ff8000000000000ull ^ mask;
  }


  uint64_t i;
  static_assert(sizeof(i) == sizeof(value), "double is not 64 bits?");
  memcpy(&i, &value, sizeof(value));
  return i ^ mask;
}

template <typename T> inline T unmask(Mask<T> value, Mask<T> mask) {
  return static_cast<T>(value ^ mask);
}

template <> inline float unmask<float>(uint32_t value, uint32_t mask) {
  value ^= mask;
  float result;
  static_assert(sizeof(result) == sizeof(value), "float is not 32 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}

template <> inline double unmask<double>(uint64_t value, uint64_t mask) {
  value ^= mask;
  double result;
  static_assert(sizeof(result) == sizeof(value), "double is not 64 bits?");
  memcpy(&result, &value, sizeof(value));
  return result;
}



class CapTableReader {
public:
  virtual kj::Maybe<kj::Own<ClientHook>> extractCap(uint index) = 0;
  
};

class CapTableBuilder: public CapTableReader {
public:
  virtual uint injectCap(kj::Own<ClientHook>&& cap) = 0;
  
  
  

  virtual void dropCap(uint index) = 0;
  
};



class PointerBuilder: public kj::DisallowConstCopy {
  

public:
  inline PointerBuilder(): segment(nullptr), capTable(nullptr), pointer(nullptr) {}

  static inline PointerBuilder getRoot( SegmentBuilder* segment, CapTableBuilder* capTable, word* location);
  
  

  inline bool isNull() { return getPointerType() == PointerType::NULL_; }
  PointerType getPointerType() const;

  StructBuilder getStruct(StructSize size, const word* defaultValue);
  ListBuilder getList(ElementSize elementSize, const word* defaultValue);
  ListBuilder getStructList(StructSize elementSize, const word* defaultValue);
  ListBuilder getListAnySize(const word* defaultValue);
  template <typename T> typename T::Builder getBlob( const void* defaultValue, ByteCount defaultSize);

  kj::Own<ClientHook> getCapability();

  
  
  

  StructBuilder initStruct(StructSize size);
  ListBuilder initList(ElementSize elementSize, ElementCount elementCount);
  ListBuilder initStructList(ElementCount elementCount, StructSize size);
  template <typename T> typename T::Builder initBlob(ByteCount size);
  
  

  void setStruct(const StructReader& value, bool canonical = false);
  void setList(const ListReader& value, bool canonical = false);
  template <typename T> void setBlob(typename T::Reader value);

  void setCapability(kj::Own<ClientHook>&& cap);

  
  

  void adopt(OrphanBuilder&& orphan);
  

  OrphanBuilder disown();
  

  void clear();
  

  void transferFrom(PointerBuilder other);
  

  void copyFrom(PointerReader other, bool canonical = false);
  
  
  

  PointerReader asReader() const;

  BuilderArena* getArena() const;
  

  CapTableBuilder* getCapTable();
  

  PointerBuilder imbue(CapTableBuilder* capTable);
  

private:
  SegmentBuilder* segment;     
  CapTableBuilder* capTable;   
  WirePointer* pointer;        

  inline PointerBuilder(SegmentBuilder* segment, CapTableBuilder* capTable, WirePointer* pointer)
      : segment(segment), capTable(capTable), pointer(pointer) {}

  friend class StructBuilder;
  friend class ListBuilder;
  friend class OrphanBuilder;
};

class PointerReader {
public:
  inline PointerReader()
      : segment(nullptr), capTable(nullptr), pointer(nullptr), nestingLimit(0x7fffffff) {}

  static PointerReader getRoot(SegmentReader* segment, CapTableReader* capTable, const word* location, int nestingLimit);
  
  

  static inline PointerReader getRootUnchecked(const word* location);
  

  MessageSizeCounts targetSize() const;
  
  
  
  
  

  inline bool isNull() const { return getPointerType() == PointerType::NULL_; }
  PointerType getPointerType() const;

  StructReader getStruct(const word* defaultValue) const;
  ListReader getList(ElementSize expectedElementSize, const word* defaultValue) const;
  ListReader getListAnySize(const word* defaultValue) const;
  template <typename T> typename T::Reader getBlob(const void* defaultValue, ByteCount defaultSize) const;

  kj::Own<ClientHook> getCapability() const;

  
  
  

  const word* getUnchecked() const;
  
  
  

  kj::Maybe<Arena&> getArena() const;
  

  CapTableReader* getCapTable();
  

  PointerReader imbue(CapTableReader* capTable) const;
  

  bool isCanonical(const word **readHead);
  
  
  
  
  

private:
  SegmentReader* segment;      
  CapTableReader* capTable;    
  const WirePointer* pointer;  

  int nestingLimit;
  
  

  inline PointerReader(SegmentReader* segment, CapTableReader* capTable, const WirePointer* pointer, int nestingLimit)
      : segment(segment), capTable(capTable), pointer(pointer), nestingLimit(nestingLimit) {}

  friend class StructReader;
  friend class ListReader;
  friend class PointerBuilder;
  friend class OrphanBuilder;
};



class StructBuilder: public kj::DisallowConstCopy {
public:
  inline StructBuilder(): segment(nullptr), capTable(nullptr), data(nullptr), pointers(nullptr) {}

  inline word* getLocation() { return reinterpret_cast<word*>(data); }
  
  

  inline StructDataBitCount getDataSectionSize() const { return dataSize; }
  inline StructPointerCount getPointerSectionSize() const { return pointerCount; }
  inline kj::ArrayPtr<byte> getDataSectionAsBlob();
  inline _::ListBuilder getPointerSectionAsList();

  template <typename T> KJ_ALWAYS_INLINE(bool hasDataField(StructDataOffset offset));
  

  template <typename T> KJ_ALWAYS_INLINE(T getDataField(StructDataOffset offset));
  
  

  template <typename T> KJ_ALWAYS_INLINE(T getDataField(StructDataOffset offset, Mask<T> mask));
  
  

  template <typename T> KJ_ALWAYS_INLINE(void setDataField(StructDataOffset offset, kj::NoInfer<T> value));
  

  template <typename T> KJ_ALWAYS_INLINE(void setDataField(StructDataOffset offset, kj::NoInfer<T> value, Mask<T> mask));

  
  

  KJ_ALWAYS_INLINE(PointerBuilder getPointerField(StructPointerOffset ptrIndex));
  

  void clearAll();
  

  void transferContentFrom(StructBuilder other);
  
  
  

  void copyContentFrom(StructReader other);
  
  
  

  StructReader asReader() const;
  

  BuilderArena* getArena();
  

  CapTableBuilder* getCapTable();
  

  StructBuilder imbue(CapTableBuilder* capTable);
  

private:
  SegmentBuilder* segment;     
  CapTableBuilder* capTable;   
  void* data;                  
  WirePointer* pointers;   

  StructDataBitCount dataSize;
  
  

  StructPointerCount pointerCount;  

  inline StructBuilder(SegmentBuilder* segment, CapTableBuilder* capTable, void* data, WirePointer* pointers, StructDataBitCount dataSize, StructPointerCount pointerCount)

      : segment(segment), capTable(capTable), data(data), pointers(pointers), dataSize(dataSize), pointerCount(pointerCount) {}

  friend class ListBuilder;
  friend struct WireHelpers;
  friend class OrphanBuilder;
};

class StructReader {
public:
  inline StructReader()
      : segment(nullptr), capTable(nullptr), data(nullptr), pointers(nullptr), dataSize(ZERO * BITS), pointerCount(ZERO * POINTERS), nestingLimit(0x7fffffff) {}
  inline StructReader(kj::ArrayPtr<const word> data)
      : segment(nullptr), capTable(nullptr), data(data.begin()), pointers(nullptr), dataSize(assumeBits<STRUCT_DATA_WORD_COUNT_BITS>(data.size()) * WORDS * BITS_PER_WORD), pointerCount(ZERO * POINTERS), nestingLimit(0x7fffffff) {}


  const void* getLocation() const { return data; }

  inline StructDataBitCount getDataSectionSize() const { return dataSize; }
  inline StructPointerCount getPointerSectionSize() const { return pointerCount; }
  inline kj::ArrayPtr<const byte> getDataSectionAsBlob() const;
  inline _::ListReader getPointerSectionAsList() const;

  kj::Array<word> canonicalize();

  template <typename T> KJ_ALWAYS_INLINE(bool hasDataField(StructDataOffset offset) const);
  

  template <typename T> KJ_ALWAYS_INLINE(T getDataField(StructDataOffset offset) const);
  
  
  

  template <typename T> KJ_ALWAYS_INLINE(T getDataField(StructDataOffset offset, Mask<T> mask) const);
  
  

  KJ_ALWAYS_INLINE(PointerReader getPointerField(StructPointerOffset ptrIndex) const);
  
  

  MessageSizeCounts totalSize() const;
  
  
  

  CapTableReader* getCapTable();
  

  StructReader imbue(CapTableReader* capTable) const;
  

  bool isCanonical(const word **readHead, const word **ptrHead, bool *dataTrunc, bool *ptrTrunc);
  
  
  
  
  
  
  
  
  
  
  
  

private:
  SegmentReader* segment;    
  CapTableReader* capTable;  

  const void* data;
  const WirePointer* pointers;

  StructDataBitCount dataSize;
  
  

  StructPointerCount pointerCount;  

  int nestingLimit;
  
  
  

  inline StructReader(SegmentReader* segment, CapTableReader* capTable, const void* data, const WirePointer* pointers, StructDataBitCount dataSize, StructPointerCount pointerCount, int nestingLimit)


      : segment(segment), capTable(capTable), data(data), pointers(pointers), dataSize(dataSize), pointerCount(pointerCount), nestingLimit(nestingLimit) {}


  friend class ListReader;
  friend class StructBuilder;
  friend struct WireHelpers;
};



class ListBuilder: public kj::DisallowConstCopy {
public:
  inline explicit ListBuilder(ElementSize elementSize)
      : segment(nullptr), capTable(nullptr), ptr(nullptr), elementCount(ZERO * ELEMENTS), step(ZERO * BITS / ELEMENTS), structDataSize(ZERO * BITS), structPointerCount(ZERO * POINTERS), elementSize(elementSize) {}


  inline word* getLocation() {
    

    if (elementSize == ElementSize::INLINE_COMPOSITE && ptr != nullptr) {
      return reinterpret_cast<word*>(ptr) - POINTER_SIZE_IN_WORDS;
    } else {
      return reinterpret_cast<word*>(ptr);
    }
  }

  inline ElementSize getElementSize() const { return elementSize; }

  inline ListElementCount size() const;
  

  Text::Builder asText();
  Data::Builder asData();
  

  template <typename T> KJ_ALWAYS_INLINE(T getDataElement(ElementCount index));
  

  template <typename T> KJ_ALWAYS_INLINE(void setDataElement(ElementCount index, kj::NoInfer<T> value));
  

  KJ_ALWAYS_INLINE(PointerBuilder getPointerElement(ElementCount index));

  StructBuilder getStructElement(ElementCount index);

  ListReader asReader() const;
  

  BuilderArena* getArena();
  

  CapTableBuilder* getCapTable();
  

  ListBuilder imbue(CapTableBuilder* capTable);
  

private:
  SegmentBuilder* segment;    
  CapTableBuilder* capTable;  

  byte* ptr;  

  ListElementCount elementCount;  

  BitsPerElementN<23> step;
  
  

  StructDataBitCount structDataSize;
  StructPointerCount structPointerCount;
  
  

  ElementSize elementSize;
  
  

  inline ListBuilder(SegmentBuilder* segment, CapTableBuilder* capTable, void* ptr, BitsPerElementN<23> step, ListElementCount size, StructDataBitCount structDataSize, StructPointerCount structPointerCount, ElementSize elementSize)


      : segment(segment), capTable(capTable), ptr(reinterpret_cast<byte*>(ptr)), elementCount(size), step(step), structDataSize(structDataSize), structPointerCount(structPointerCount), elementSize(elementSize) {}


  friend class StructBuilder;
  friend struct WireHelpers;
  friend class OrphanBuilder;
};

class ListReader {
public:
  inline explicit ListReader(ElementSize elementSize)
      : segment(nullptr), capTable(nullptr), ptr(nullptr), elementCount(ZERO * ELEMENTS), step(ZERO * BITS / ELEMENTS), structDataSize(ZERO * BITS), structPointerCount(ZERO * POINTERS), elementSize(elementSize), nestingLimit(0x7fffffff) {}


  inline ListElementCount size() const;
  

  inline ElementSize getElementSize() const { return elementSize; }

  Text::Reader asText();
  Data::Reader asData();
  

  kj::ArrayPtr<const byte> asRawBytes() const;

  template <typename T> KJ_ALWAYS_INLINE(T getDataElement(ElementCount index) const);
  

  KJ_ALWAYS_INLINE(PointerReader getPointerElement(ElementCount index) const);

  StructReader getStructElement(ElementCount index) const;

  MessageSizeCounts totalSize() const;
  

  CapTableReader* getCapTable();
  

  ListReader imbue(CapTableReader* capTable) const;
  

  bool isCanonical(const word **readHead, const WirePointer* ref);
  
  
  
  
  

private:
  SegmentReader* segment;    
  CapTableReader* capTable;  

  const byte* ptr;  

  ListElementCount elementCount;  

  BitsPerElementN<23> step;
  
  

  StructDataBitCount structDataSize;
  StructPointerCount structPointerCount;
  
  

  ElementSize elementSize;
  
  

  int nestingLimit;
  
  

  inline ListReader(SegmentReader* segment, CapTableReader* capTable, const void* ptr, ListElementCount elementCount, BitsPerElementN<23> step, StructDataBitCount structDataSize, StructPointerCount structPointerCount, ElementSize elementSize, int nestingLimit)


      : segment(segment), capTable(capTable), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount), step(step), structDataSize(structDataSize), structPointerCount(structPointerCount), elementSize(elementSize), nestingLimit(nestingLimit) {}



  friend class StructReader;
  friend class ListBuilder;
  friend struct WireHelpers;
  friend class OrphanBuilder;
};



class OrphanBuilder {
public:
  inline OrphanBuilder(): segment(nullptr), capTable(nullptr), location(nullptr) {
    memset(&tag, 0, sizeof(tag));
  }
  OrphanBuilder(const OrphanBuilder& other) = delete;
  inline OrphanBuilder(OrphanBuilder&& other) noexcept;
  inline ~OrphanBuilder() noexcept(false);

  static OrphanBuilder initStruct(BuilderArena* arena, CapTableBuilder* capTable, StructSize size);
  static OrphanBuilder initList(BuilderArena* arena, CapTableBuilder* capTable, ElementCount elementCount, ElementSize elementSize);
  static OrphanBuilder initStructList(BuilderArena* arena, CapTableBuilder* capTable, ElementCount elementCount, StructSize elementSize);
  static OrphanBuilder initText(BuilderArena* arena, CapTableBuilder* capTable, ByteCount size);
  static OrphanBuilder initData(BuilderArena* arena, CapTableBuilder* capTable, ByteCount size);

  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, StructReader copyFrom);
  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, ListReader copyFrom);
  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, PointerReader copyFrom);
  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, Text::Reader copyFrom);
  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, Data::Reader copyFrom);

  static OrphanBuilder copy(BuilderArena* arena, CapTableBuilder* capTable, kj::Own<ClientHook> copyFrom);


  static OrphanBuilder concat(BuilderArena* arena, CapTableBuilder* capTable, ElementSize expectedElementSize, StructSize expectedStructSize, kj::ArrayPtr<const ListReader> lists);


  static OrphanBuilder referenceExternalData(BuilderArena* arena, Data::Reader data);

  OrphanBuilder& operator=(const OrphanBuilder& other) = delete;
  inline OrphanBuilder& operator=(OrphanBuilder&& other);

  inline bool operator==(decltype(nullptr)) const { return location == nullptr; }
  inline bool operator!=(decltype(nullptr)) const { return location != nullptr; }

  StructBuilder asStruct(StructSize size);
  

  ListBuilder asList(ElementSize elementSize);
  
  

  ListBuilder asStructList(StructSize elementSize);
  

  ListBuilder asListAnySize();
  

  Text::Builder asText();
  Data::Builder asData();
  

  StructReader asStructReader(StructSize size) const;
  ListReader asListReader(ElementSize elementSize) const;
  ListReader asListReaderAnySize() const;

  kj::Own<ClientHook> asCapability() const;

  Text::Reader asTextReader() const;
  Data::Reader asDataReader() const;

  bool truncate(ElementCount size, bool isText) KJ_WARN_UNUSED_RESULT;
  
  

  void truncate(ElementCount size, ElementSize elementSize);
  void truncate(ElementCount size, StructSize elementSize);
  void truncateText(ElementCount size);
  

private:
  static_assert(ONE * POINTERS * WORDS_PER_POINTER == ONE * WORDS, "This struct assumes a pointer is one word.");
  word tag;
  
  
  
  
  
  
  
  
  
  

  SegmentBuilder* segment;
  

  CapTableBuilder* capTable;
  

  word* location;
  
  

  inline OrphanBuilder(const void* tagPtr, SegmentBuilder* segment, CapTableBuilder* capTable, word* location)
      : segment(segment), capTable(capTable), location(location) {
    memcpy(&tag, tagPtr, sizeof(tag));
  }

  inline WirePointer* tagAsPtr() { return reinterpret_cast<WirePointer*>(&tag); }
  inline const WirePointer* tagAsPtr() const { return reinterpret_cast<const WirePointer*>(&tag); }

  void euthanize();
  
  

  friend struct WireHelpers;
};





template <> typename Text::Builder PointerBuilder::initBlob<Text>(ByteCount size);
template <> void PointerBuilder::setBlob<Text>(typename Text::Reader value);
template <> typename Text::Builder PointerBuilder::getBlob<Text>( const void* defaultValue, ByteCount defaultSize);
template <> typename Text::Reader PointerReader::getBlob<Text>( const void* defaultValue, ByteCount defaultSize) const;

template <> typename Data::Builder PointerBuilder::initBlob<Data>(ByteCount size);
template <> void PointerBuilder::setBlob<Data>(typename Data::Reader value);
template <> typename Data::Builder PointerBuilder::getBlob<Data>( const void* defaultValue, ByteCount defaultSize);
template <> typename Data::Reader PointerReader::getBlob<Data>( const void* defaultValue, ByteCount defaultSize) const;

inline PointerBuilder PointerBuilder::getRoot( SegmentBuilder* segment, CapTableBuilder* capTable, word* location) {
  return PointerBuilder(segment, capTable, reinterpret_cast<WirePointer*>(location));
}

inline PointerReader PointerReader::getRootUnchecked(const word* location) {
  return PointerReader(nullptr, nullptr, reinterpret_cast<const WirePointer*>(location), 0x7fffffff);
}



inline kj::ArrayPtr<byte> StructBuilder::getDataSectionAsBlob() {
  return kj::ArrayPtr<byte>(reinterpret_cast<byte*>(data), unbound(dataSize / BITS_PER_BYTE / BYTES));
}

inline _::ListBuilder StructBuilder::getPointerSectionAsList() {
  return _::ListBuilder(segment, capTable, pointers, ONE * POINTERS * BITS_PER_POINTER / ELEMENTS, pointerCount * (ONE * ELEMENTS / POINTERS), ZERO * BITS, ONE * POINTERS, ElementSize::POINTER);

}

template <typename T> inline bool StructBuilder::hasDataField(StructDataOffset offset) {
  return getDataField<Mask<T>>(offset) != 0;
}

template <> inline bool StructBuilder::hasDataField<Void>(StructDataOffset offset) {
  return false;
}

template <typename T> inline T StructBuilder::getDataField(StructDataOffset offset) {
  return reinterpret_cast<WireValue<T>*>(data)[unbound(offset / ELEMENTS)].get();
}

template <> inline bool StructBuilder::getDataField<bool>(StructDataOffset offset) {
  BitCount32 boffset = offset * (ONE * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & unbound(ONE << (boffset % BITS_PER_BYTE / BITS))) != 0;
}

template <> inline Void StructBuilder::getDataField<Void>(StructDataOffset offset) {
  return VOID;
}

template <typename T> inline T StructBuilder::getDataField(StructDataOffset offset, Mask<T> mask) {
  return unmask<T>(getDataField<Mask<T> >(offset), mask);
}

template <typename T> inline void StructBuilder::setDataField(StructDataOffset offset, kj::NoInfer<T> value) {
  reinterpret_cast<WireValue<T>*>(data)[unbound(offset / ELEMENTS)].set(value);
}



template <> inline void StructBuilder::setDataField<float>(StructDataOffset offset, float value) {
  setDataField<uint32_t>(offset, mask<float>(value, 0));
}
template <> inline void StructBuilder::setDataField<double>(StructDataOffset offset, double value) {
  setDataField<uint64_t>(offset, mask<double>(value, 0));
}


template <> inline void StructBuilder::setDataField<bool>(StructDataOffset offset, bool value) {
  auto boffset = offset * (ONE * BITS / ELEMENTS);
  byte* b = reinterpret_cast<byte*>(data) + boffset / BITS_PER_BYTE;
  uint bitnum = unboundMaxBits<3>(boffset % BITS_PER_BYTE / BITS);
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << bitnum))
                                 | (static_cast<uint8_t>(value) << bitnum);
}

template <> inline void StructBuilder::setDataField<Void>(StructDataOffset offset, Void value) {}

template <typename T> inline void StructBuilder::setDataField(StructDataOffset offset, kj::NoInfer<T> value, Mask<T> m) {

  setDataField<Mask<T> >(offset, mask<T>(value, m));
}

inline PointerBuilder StructBuilder::getPointerField(StructPointerOffset ptrIndex) {
  
  return PointerBuilder(segment, capTable, reinterpret_cast<WirePointer*>( reinterpret_cast<word*>(pointers) + ptrIndex * WORDS_PER_POINTER));
}



inline kj::ArrayPtr<const byte> StructReader::getDataSectionAsBlob() const {
  return kj::ArrayPtr<const byte>(reinterpret_cast<const byte*>(data), unbound(dataSize / BITS_PER_BYTE / BYTES));
}

inline _::ListReader StructReader::getPointerSectionAsList() const {
  return _::ListReader(segment, capTable, pointers, pointerCount * (ONE * ELEMENTS / POINTERS), ONE * POINTERS * BITS_PER_POINTER / ELEMENTS, ZERO * BITS, ONE * POINTERS, ElementSize::POINTER, nestingLimit);

}

template <typename T> inline bool StructReader::hasDataField(StructDataOffset offset) const {
  return getDataField<Mask<T>>(offset) != 0;
}

template <> inline bool StructReader::hasDataField<Void>(StructDataOffset offset) const {
  return false;
}

template <typename T> inline T StructReader::getDataField(StructDataOffset offset) const {
  if ((offset + ONE * ELEMENTS) * capnp::bitsPerElement<T>() <= dataSize) {
    return reinterpret_cast<const WireValue<T>*>(data)[unbound(offset / ELEMENTS)].get();
  } else {
    return static_cast<T>(0);
  }
}

template <> inline bool StructReader::getDataField<bool>(StructDataOffset offset) const {
  auto boffset = offset * (ONE * BITS / ELEMENTS);
  if (boffset < dataSize) {
    const byte* b = reinterpret_cast<const byte*>(data) + boffset / BITS_PER_BYTE;
    return (*reinterpret_cast<const uint8_t*>(b) & unbound(ONE << (boffset % BITS_PER_BYTE / BITS))) != 0;
  } else {
    return false;
  }
}

template <> inline Void StructReader::getDataField<Void>(StructDataOffset offset) const {
  return VOID;
}

template <typename T> T StructReader::getDataField(StructDataOffset offset, Mask<T> mask) const {
  return unmask<T>(getDataField<Mask<T> >(offset), mask);
}

inline PointerReader StructReader::getPointerField(StructPointerOffset ptrIndex) const {
  if (ptrIndex < pointerCount) {
    
    return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>( reinterpret_cast<const word*>(pointers) + ptrIndex * WORDS_PER_POINTER), nestingLimit);
  } else{
    return PointerReader();
  }
}



inline ListElementCount ListBuilder::size() const { return elementCount; }

template <typename T> inline T ListBuilder::getDataElement(ElementCount index) {
  return reinterpret_cast<WireValue<T>*>( ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE)->get();

  
  
  
  


}

template <> inline bool ListBuilder::getDataElement<bool>(ElementCount index) {
  
  auto bindex = index * (ONE * BITS / ELEMENTS);
  byte* b = ptr + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<uint8_t*>(b) & unbound(ONE << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <> inline Void ListBuilder::getDataElement<Void>(ElementCount index) {
  return VOID;
}

template <typename T> inline void ListBuilder::setDataElement(ElementCount index, kj::NoInfer<T> value) {
  reinterpret_cast<WireValue<T>*>( ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE)->set(value);
}



template <> inline void ListBuilder::setDataElement<float>(ElementCount index, float value) {
  setDataElement<uint32_t>(index, mask<float>(value, 0));
}
template <> inline void ListBuilder::setDataElement<double>(ElementCount index, double value) {
  setDataElement<uint64_t>(index, mask<double>(value, 0));
}


template <> inline void ListBuilder::setDataElement<bool>(ElementCount index, bool value) {
  
  auto bindex = index * (ONE * BITS / ELEMENTS);
  byte* b = ptr + bindex / BITS_PER_BYTE;
  auto bitnum = bindex % BITS_PER_BYTE / BITS;
  *reinterpret_cast<uint8_t*>(b) = (*reinterpret_cast<uint8_t*>(b) & ~(1 << unbound(bitnum)))
                                 | (static_cast<uint8_t>(value) << unbound(bitnum));
}

template <> inline void ListBuilder::setDataElement<Void>(ElementCount index, Void value) {}

inline PointerBuilder ListBuilder::getPointerElement(ElementCount index) {
  return PointerBuilder(segment, capTable, reinterpret_cast<WirePointer*>(ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE));
}



inline ListElementCount ListReader::size() const { return elementCount; }

template <typename T> inline T ListReader::getDataElement(ElementCount index) const {
  return reinterpret_cast<const WireValue<T>*>( ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE)->get();
}

template <> inline bool ListReader::getDataElement<bool>(ElementCount index) const {
  
  auto bindex = index * (ONE * BITS / ELEMENTS);
  const byte* b = ptr + bindex / BITS_PER_BYTE;
  return (*reinterpret_cast<const uint8_t*>(b) & unbound(ONE << (bindex % BITS_PER_BYTE / BITS))) != 0;
}

template <> inline Void ListReader::getDataElement<Void>(ElementCount index) const {
  return VOID;
}

inline PointerReader ListReader::getPointerElement(ElementCount index) const {
  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>( ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);
}



inline OrphanBuilder::OrphanBuilder(OrphanBuilder&& other) noexcept : segment(other.segment), capTable(other.capTable), location(other.location) {
  memcpy(&tag, &other.tag, sizeof(tag));  
  other.segment = nullptr;
  other.location = nullptr;
}

inline OrphanBuilder::~OrphanBuilder() noexcept(false) {
  if (segment != nullptr) euthanize();
}

inline OrphanBuilder& OrphanBuilder::operator=(OrphanBuilder&& other) {
  
  
  
  
  

  if (segment != nullptr) euthanize();
  segment = other.segment;
  capTable = other.capTable;
  location = other.location;
  memcpy(&tag, &other.tag, sizeof(tag));  
  other.segment = nullptr;
  other.location = nullptr;
  return *this;
}

}  
}  

CAPNP_END_HEADER