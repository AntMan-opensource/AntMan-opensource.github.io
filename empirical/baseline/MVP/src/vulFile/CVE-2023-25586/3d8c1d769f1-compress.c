















static bool decompress_contents (bool is_zstd, bfd_byte *compressed_buffer, bfd_size_type compressed_size, bfd_byte *uncompressed_buffer, bfd_size_type uncompressed_size)



{
  if (is_zstd)
    {

      size_t ret = ZSTD_decompress (uncompressed_buffer, uncompressed_size, compressed_buffer, compressed_size);
      return !ZSTD_isError (ret);

    }

  z_stream strm;
  int rc;

  
  
  memset (& strm, 0, sizeof strm);
  strm.avail_in = compressed_size;
  strm.next_in = (Bytef*) compressed_buffer;
  strm.avail_out = uncompressed_size;
  
  if (strm.avail_in != compressed_size || strm.avail_out != uncompressed_size)
    return false;

  BFD_ASSERT (Z_OK == 0);
  rc = inflateInit (&strm);
  while (strm.avail_in > 0 && strm.avail_out > 0)
    {
      if (rc != Z_OK)
	break;
      strm.next_out = ((Bytef*) uncompressed_buffer + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
	break;
      rc = inflateReset (&strm);
    }
  return inflateEnd (&strm) == Z_OK && rc == Z_OK && strm.avail_out == 0;
}



static bfd_size_type bfd_compress_section_contents (bfd *abfd, sec_ptr sec)
{
  bfd_byte *input_buffer;
  uLong compressed_size;
  bfd_byte *buffer;
  bfd_size_type buffer_size;
  int zlib_size = 0;
  int orig_header_size;
  bfd_size_type uncompressed_size;
  unsigned int uncompressed_alignment_pow;
  unsigned int ch_type = 0;
  int new_header_size = bfd_get_compression_header_size (abfd, NULL);
  bool compressed = bfd_is_section_compressed_info (abfd, sec, &orig_header_size, &uncompressed_size, &uncompressed_alignment_pow, &ch_type);




  bool update = false;

  
  if (compressed && orig_header_size < 0)
    abort ();

  
  if (!new_header_size)
    new_header_size = 12;
  if (ch_type == 0)
    orig_header_size = 12;

  input_buffer = sec->contents;
  if (compressed)
    {
      zlib_size = sec->size - orig_header_size;
      compressed_size = zlib_size + new_header_size;

      
      update = (ch_type < ELFCOMPRESS_ZSTD && (abfd->flags & BFD_COMPRESS_ZSTD) == 0);

      
      if (!update || compressed_size >= uncompressed_size)
	{
	  buffer_size = uncompressed_size;
	  buffer = bfd_malloc (buffer_size);
	  if (buffer == NULL)
	    return 0;

	  if (!decompress_contents (ch_type == ELFCOMPRESS_ZSTD, input_buffer + orig_header_size, zlib_size, buffer, buffer_size))

	    {
	      bfd_set_error (bfd_error_bad_value);
	      free (buffer);
	      return 0;
	    }
	  free (input_buffer);
	  bfd_set_section_alignment (sec, uncompressed_alignment_pow);
	  sec->contents = buffer;
	  sec->flags |= SEC_IN_MEMORY;
	  sec->compress_status = COMPRESS_SECTION_NONE;
	  sec->size = uncompressed_size;
	  input_buffer = buffer;
	}
    }

  if (!update)
    compressed_size = compressBound (uncompressed_size) + new_header_size;

  buffer_size = compressed_size;
  buffer = bfd_alloc (abfd, buffer_size);
  if (buffer == NULL)
    return 0;

  if (update)
    {
      if (compressed_size < uncompressed_size)
	memcpy (buffer + new_header_size, input_buffer + orig_header_size, zlib_size);

    }
  else {
      if (abfd->flags & BFD_COMPRESS_ZSTD)
	{

	  compressed_size = ZSTD_compress (buffer + new_header_size, compressed_size, input_buffer, uncompressed_size, ZSTD_CLEVEL_DEFAULT);



	  if (ZSTD_isError (compressed_size))
	    {
	      bfd_release (abfd, buffer);
	      bfd_set_error (bfd_error_bad_value);
	      return 0;
	    }

	}
      else if (compress ((Bytef *) buffer + new_header_size, &compressed_size, (const Bytef *) input_buffer, uncompressed_size)
	       != Z_OK)
	{
	  bfd_release (abfd, buffer);
	  bfd_set_error (bfd_error_bad_value);
	  return 0;
	}

      compressed_size += new_header_size;
    }

  
  if (compressed_size >= uncompressed_size)
    {
      memcpy (buffer, input_buffer, uncompressed_size);
      elf_section_flags (sec) &= ~SHF_COMPRESSED;
      sec->compress_status = COMPRESS_SECTION_NONE;
    }
  else {
      sec->size = uncompressed_size;
      bfd_update_compression_header (abfd, buffer, sec);
      sec->size = compressed_size;
      sec->compress_status = COMPRESS_SECTION_DONE;
    }
  sec->contents = buffer;
  sec->flags |= SEC_IN_MEMORY;
  free (input_buffer);
  return uncompressed_size;
}



bool bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
{
  bfd_size_type sz = bfd_get_section_limit_octets (abfd, sec);
  bfd_byte *p = *ptr;
  bool ret;
  bfd_size_type save_size;
  bfd_size_type save_rawsize;
  bfd_byte *compressed_buffer;
  unsigned int compression_header_size;
  const unsigned int compress_status = sec->compress_status;

  if (sz == 0)
    {
      *ptr = NULL;
      return true;
    }

  if (p == NULL && compress_status != COMPRESS_SECTION_DONE && _bfd_section_size_insane (abfd, sec))

    {
      
      _bfd_error_handler  (_("error: %pB(%pA) is too large (%#" PRIx64 " bytes)"), abfd, sec, (uint64_t) sz);


      return false;
    }

  switch (compress_status)
    {
    case COMPRESS_SECTION_NONE:
      if (p == NULL)
	{
	  p = (bfd_byte *) bfd_malloc (sz);
	  if (p == NULL)
	    {
	      
	      if (bfd_get_error () == bfd_error_no_memory)
		_bfd_error_handler  (_("error: %pB(%pA) is too large (%#" PRIx64 " bytes)"), abfd, sec, (uint64_t) sz);


	      return false;
	    }
	}

      if (!bfd_get_section_contents (abfd, sec, p, 0, sz))
	{
	  if (*ptr != p)
	    free (p);
	  return false;
	}
      *ptr = p;
      return true;

    case DECOMPRESS_SECTION_ZLIB:
    case DECOMPRESS_SECTION_ZSTD:
      
      compressed_buffer = (bfd_byte *) bfd_malloc (sec->compressed_size);
      if (compressed_buffer == NULL)
	return false;
      save_rawsize = sec->rawsize;
      save_size = sec->size;
      
      sec->rawsize = 0;
      sec->size = sec->compressed_size;
      sec->compress_status = COMPRESS_SECTION_NONE;
      ret = bfd_get_section_contents (abfd, sec, compressed_buffer, 0, sec->compressed_size);
      
      sec->rawsize = save_rawsize;
      sec->size = save_size;
      sec->compress_status = compress_status;
      if (!ret)
	goto fail_compressed;

      if (p == NULL)
	p = (bfd_byte *) bfd_malloc (sz);
      if (p == NULL)
	goto fail_compressed;

      compression_header_size = bfd_get_compression_header_size (abfd, sec);
      if (compression_header_size == 0)
	
	compression_header_size = 12;
      bool is_zstd = compress_status == DECOMPRESS_SECTION_ZSTD;
      if (!decompress_contents ( is_zstd, compressed_buffer + compression_header_size, sec->compressed_size - compression_header_size, p, sz))

	{
	  bfd_set_error (bfd_error_bad_value);
	  if (p != *ptr)
	    free (p);
	fail_compressed:
	  free (compressed_buffer);
	  return false;
	}

      free (compressed_buffer);
      *ptr = p;
      return true;

    case COMPRESS_SECTION_DONE:
      if (sec->contents == NULL)
	return false;
      if (p == NULL)
	{
	  p = (bfd_byte *) bfd_malloc (sz);
	  if (p == NULL)
	    return false;
	  *ptr = p;
	}
      
      if (p != sec->contents)
	memcpy (p, sec->contents, sz);
      return true;

    default:
      abort ();
    }
}



bool bfd_is_section_compressed_info (bfd *abfd, sec_ptr sec, int *compression_header_size_p, bfd_size_type *uncompressed_size_p, unsigned int *uncompressed_align_pow_p, unsigned int *ch_type)




{
  bfd_byte header[MAX_COMPRESSION_HEADER_SIZE];
  int compression_header_size;
  int header_size;
  unsigned int saved = sec->compress_status;
  bool compressed;

  *uncompressed_align_pow_p = 0;

  compression_header_size = bfd_get_compression_header_size (abfd, sec);
  if (compression_header_size > MAX_COMPRESSION_HEADER_SIZE)
    abort ();
  header_size = compression_header_size ? compression_header_size : 12;

  
  sec->compress_status = COMPRESS_SECTION_NONE;

  
  if (bfd_get_section_contents (abfd, sec, header, 0, header_size))
    {
      if (compression_header_size == 0)
	
	compressed = startswith ((char*) header , "ZLIB");
      else compressed = true;
    }
  else compressed = false;

  *uncompressed_size_p = sec->size;
  if (compressed)
    {
      if (compression_header_size != 0)
	{
	  if (!bfd_check_compression_header (abfd, header, sec, ch_type, uncompressed_size_p, uncompressed_align_pow_p))

	    compression_header_size = -1;
	}
      
      else if (strcmp (sec->name, ".debug_str") == 0 && ISPRINT (header[4]))
	compressed = false;
      else *uncompressed_size_p = bfd_getb64 (header + 4);
    }

  
  sec->compress_status = saved;
  *compression_header_size_p = compression_header_size;
  return compressed;
}



bool bfd_is_section_compressed (bfd *abfd, sec_ptr sec)
{
  int compression_header_size;
  bfd_size_type uncompressed_size;
  unsigned int uncompressed_align_power;
  unsigned int ch_type;
  return (bfd_is_section_compressed_info (abfd, sec, &compression_header_size, &uncompressed_size, &uncompressed_align_power, &ch_type)



	  && compression_header_size >= 0 && uncompressed_size > 0);
}



bool bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)
{
  bfd_byte header[MAX_COMPRESSION_HEADER_SIZE];
  int compression_header_size;
  int header_size;
  bfd_size_type uncompressed_size;
  unsigned int uncompressed_alignment_power = 0;
  unsigned int ch_type;
  z_stream strm;

  compression_header_size = bfd_get_compression_header_size (abfd, sec);
  if (compression_header_size > MAX_COMPRESSION_HEADER_SIZE)
    abort ();
  header_size = compression_header_size ? compression_header_size : 12;

  
  if (sec->rawsize != 0 || sec->contents != NULL || sec->compress_status != COMPRESS_SECTION_NONE || !bfd_get_section_contents (abfd, sec, header, 0, header_size))


    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  if (compression_header_size == 0)
    {
      
      if (! startswith ((char*) header, "ZLIB"))
	{
	  bfd_set_error (bfd_error_wrong_format);
	  return false;
	}
      uncompressed_size = bfd_getb64 (header + 4);
    }
  else if (!bfd_check_compression_header (abfd, header, sec, &ch_type, &uncompressed_size, &uncompressed_alignment_power))


    {
      bfd_set_error (bfd_error_wrong_format);
      return false;
    }

  
  strm.avail_in = sec->size;
  strm.avail_out = uncompressed_size;
  if (strm.avail_in != sec->size || strm.avail_out != uncompressed_size)
    {
      bfd_set_error (bfd_error_nonrepresentable_section);
      return false;
    }

  sec->compressed_size = sec->size;
  sec->size = uncompressed_size;
  bfd_set_section_alignment (sec, uncompressed_alignment_power);
  sec->compress_status = (ch_type == ELFCOMPRESS_ZSTD ? DECOMPRESS_SECTION_ZSTD : DECOMPRESS_SECTION_ZLIB);

  return true;
}



bool bfd_init_section_compress_status (bfd *abfd, sec_ptr sec)
{
  bfd_size_type uncompressed_size;
  bfd_byte *uncompressed_buffer;

  
  if (abfd->direction != read_direction || sec->size == 0 || sec->rawsize != 0 || sec->contents != NULL || sec->compress_status != COMPRESS_SECTION_NONE)



    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  
  uncompressed_size = sec->size;
  uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
  
  if (uncompressed_buffer == NULL)
    return false;

  if (!bfd_get_section_contents (abfd, sec, uncompressed_buffer, 0, uncompressed_size))
    return false;

  sec->contents = uncompressed_buffer;
  if (bfd_compress_section_contents (abfd, sec) == 0)
    {
      free (sec->contents);
      sec->contents = NULL;
      return false;
    }
  return true;
}



bool bfd_compress_section (bfd *abfd, sec_ptr sec, bfd_byte *uncompressed_buffer)
{
  bfd_size_type uncompressed_size = sec->size;

  
  if (abfd->direction != write_direction || uncompressed_size == 0 || uncompressed_buffer == NULL || sec->contents != NULL || sec->compressed_size != 0 || sec->compress_status != COMPRESS_SECTION_NONE)




    {
      bfd_set_error (bfd_error_invalid_operation);
      return false;
    }

  sec->contents = uncompressed_buffer;
  if (bfd_compress_section_contents (abfd, sec) == 0)
    {
      free (sec->contents);
      sec->contents = NULL;
      return false;
    }
  return true;
}
