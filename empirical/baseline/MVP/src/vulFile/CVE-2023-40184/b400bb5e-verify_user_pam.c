

















struct conv_func_data {
    const char *pass;
};

struct auth_info {
    int session_opened;
    int did_setcred;
    pam_handle_t *ph;
};


static const char * msg_style_to_str(int msg_style, char *buff, unsigned int bufflen)
{
    const char *result;
    switch (msg_style)
    {
        case PAM_PROMPT_ECHO_OFF:
            result = "PAM_PROMPT_ECHO_OFF";
            break;

        case PAM_PROMPT_ECHO_ON:
            result = "PAM_PROMPT_ECHO_ON";
            break;

        case PAM_ERROR_MSG:
            result = "PAM_ERROR_MSG";
            break;

        case PAM_TEXT_INFO:
            result = "PAM_TEXT_INFO";
            break;

        default:
            g_snprintf(buff, bufflen, "UNKNOWN_0x%x", msg_style);
            result = buff;
    }

    return result;
}



static int verify_pam_conv(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr)

{
    int i;
    struct pam_response *reply = NULL;
    struct conv_func_data *conv_func_data;
    char sb[64];
    int rv = PAM_SUCCESS;

    if (num_msg <= 0 || num_msg > PAM_MAX_NUM_MSG)
    {
        rv = PAM_CONV_ERR;
    }
    else if ((reply = g_new0(struct pam_response, num_msg)) == NULL)
    {
        rv = PAM_BUF_ERR;
    }
    else {
        for (i = 0; i < num_msg && rv == PAM_SUCCESS; i++)
        {
            LOG_DEVEL(LOG_LEVEL_INFO, "Handling struct pam_message" " { style = %s, msg = \"%s\" }", msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)), msg[i]->msg == NULL ? "<null>" : msg[i]->msg);



            switch (msg[i]->msg_style)
            {
                case PAM_PROMPT_ECHO_OFF: 
                    conv_func_data = (struct conv_func_data *) appdata_ptr;
                    
                    if (conv_func_data == NULL || conv_func_data->pass == NULL)
                    {
                        LOG(LOG_LEVEL_ERROR, "verify_pam_conv: Password unavailable");
                        reply[i].resp = g_strdup("????");
                    }
                    else {
                        reply[i].resp = g_strdup(conv_func_data->pass);
                    }
                    break;

                case PAM_ERROR_MSG:
                    LOG(LOG_LEVEL_ERROR, "PAM: %s", msg[i]->msg);
                    break;

                case PAM_TEXT_INFO:
                    LOG(LOG_LEVEL_INFO, "PAM: %s", msg[i]->msg);
                    break;

                default:
                {
                    LOG(LOG_LEVEL_ERROR, "Unhandled message in verify_pam_conv" " { style = %s, msg = \"%s\" }", msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)), msg[i]->msg == NULL ? "<null>" : msg[i]->msg);


                    rv = PAM_CONV_ERR;
                }
            }
        }
    }

    if (rv == PAM_SUCCESS)
    {
        *resp = reply;
    }
    else if (reply != NULL)
    {
        for (i = 0; i < num_msg; i++)
        {
            if (reply[i].resp != NULL)
            {
                g_free(reply[i].resp);
            }
        }
        g_free(reply);
    }

    return rv;
}


static void get_service_name(char *service_name)
{
    service_name[0] = 0;

    if (g_file_exist("/etc/pam.d/xrdp-sesman") ||   g_file_exist("/usr/lib/pam.d/xrdp-sesman") ||    g_file_exist("/usr/local/etc/pam.d/xrdp-sesman") ||  g_file_exist(XRDP_PAMCONF_PATH "/xrdp-sesman"))








    {
        g_strncpy(service_name, "xrdp-sesman", 255);
    }
    else {
        g_strncpy(service_name, "gdm", 255);
    }
}




static enum scp_login_status common_pam_login(struct auth_info *auth_info, const char *user, const char *pass, const char *client_ip, int authentication_required)




{
    int perror;
    char service_name[256];
    struct conv_func_data conv_func_data;
    struct pam_conv pamc;

    
    conv_func_data.pass = (authentication_required) ? pass : NULL;
    pamc.conv = verify_pam_conv;
    pamc.appdata_ptr = (void *) &conv_func_data;

    get_service_name(service_name);
    perror = pam_start(service_name, user, &pamc, &(auth_info->ph));

    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_start failed: %s", pam_strerror(auth_info->ph, perror));
        pam_end(auth_info->ph, perror);
        return E_SCP_LOGIN_GENERAL_ERROR;
    }

    if (client_ip != NULL && client_ip[0] != '\0')
    {
        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);
        if (perror != PAM_SUCCESS)
        {
            LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_RHOST) failed: %s", pam_strerror(auth_info->ph, perror));
        }
    }

    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);
    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_TTY) failed: %s", pam_strerror(auth_info->ph, perror));
    }

    if (authentication_required)
    {
        perror = pam_authenticate(auth_info->ph, 0);

        if (perror != PAM_SUCCESS)
        {
            LOG(LOG_LEVEL_ERROR, "pam_authenticate failed: %s", pam_strerror(auth_info->ph, perror));
            pam_end(auth_info->ph, perror);
            return E_SCP_LOGIN_NOT_AUTHENTICATED;
        }
    }
    
    perror = pam_acct_mgmt(auth_info->ph, 0);

    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_acct_mgmt failed: %s", pam_strerror(auth_info->ph, perror));
        pam_end(auth_info->ph, perror);
        return E_SCP_LOGIN_NOT_AUTHORIZED;
    }

    
    pamc.appdata_ptr = NULL;
    perror = pam_set_item(auth_info->ph, PAM_CONV, &pamc);
    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_CONV) failed: %s", pam_strerror(auth_info->ph, perror));
    }

    return E_SCP_LOGIN_OK;
}





struct auth_info * auth_userpass(const char *user, const char *pass, const char *client_ip, enum scp_login_status *errorcode)

{
    struct auth_info *auth_info;
    enum scp_login_status status;

    auth_info = g_new0(struct auth_info, 1);
    if (auth_info == NULL)
    {
        status = E_SCP_LOGIN_NO_MEMORY;
    }
    else {
        status = common_pam_login(auth_info, user, pass, client_ip, 1);

        if (status != E_SCP_LOGIN_OK)
        {
            g_free(auth_info);
            auth_info = NULL;
        }
    }

    if (errorcode != NULL)
    {
        *errorcode = status;
    }

    return auth_info;
}



struct auth_info * auth_uds(const char *user, enum scp_login_status *errorcode)
{
    struct auth_info *auth_info;
    enum scp_login_status status;

    auth_info = g_new0(struct auth_info, 1);
    if (auth_info == NULL)
    {
        status = E_SCP_LOGIN_NO_MEMORY;
    }
    else {
        status = common_pam_login(auth_info, user, NULL, NULL, 0);

        if (status != E_SCP_LOGIN_OK)
        {
            g_free(auth_info);
            auth_info = NULL;
        }
    }

    if (errorcode != NULL)
    {
        *errorcode = status;
    }

    return auth_info;
}




int auth_start_session(struct auth_info *auth_info, int display_num)
{
    int error;
    char display[256];

    g_sprintf(display, ":%d", display_num);
    error = pam_set_item(auth_info->ph, PAM_TTY, display);

    if (error != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_set_item failed: %s", pam_strerror(auth_info->ph, error));
        return 1;
    }

    error = pam_setcred(auth_info->ph, PAM_ESTABLISH_CRED);

    if (error != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_setcred failed: %s", pam_strerror(auth_info->ph, error));
        return 1;
    }

    auth_info->did_setcred = 1;
    error = pam_open_session(auth_info->ph, 0);

    if (error != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_open_session failed: %s", pam_strerror(auth_info->ph, error));
        return 1;
    }

    auth_info->session_opened = 1;
    return 0;
}



static int auth_stop_session(struct auth_info *auth_info)
{
    int rv = 0;
    int error;

    if (auth_info->session_opened)
    {
        error = pam_close_session(auth_info->ph, 0);
        if (error != PAM_SUCCESS)
        {
            LOG(LOG_LEVEL_ERROR, "pam_close_session failed: %s", pam_strerror(auth_info->ph, error));
            rv = 1;
        }
        else {
            auth_info->session_opened = 0;
        }
    }

    if (auth_info->did_setcred)
    {
        pam_setcred(auth_info->ph, PAM_DELETE_CRED);
        auth_info->did_setcred = 0;
    }

    return rv;
}




int auth_end(struct auth_info *auth_info)
{
    if (auth_info != NULL)
    {
        if (auth_info->ph != 0)
        {
            auth_stop_session(auth_info);

            pam_end(auth_info->ph, PAM_SUCCESS);
            auth_info->ph = 0;
        }
    }

    g_free(auth_info);
    return 0;
}




int auth_set_env(struct auth_info *auth_info)
{
    char **pam_envlist;
    char **pam_env;

    if (auth_info != NULL)
    {
        
        pam_envlist = pam_getenvlist(auth_info->ph);

        if (pam_envlist != NULL)
        {
            for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env)
            {
                char *str = *pam_env;
                int eq_pos = g_pos(str, "=");

                if (eq_pos > 0)
                {
                    str[eq_pos] = '\0';
                    g_setenv(str, str + eq_pos + 1, 1);
                }

                g_free(str);
            }

            g_free(pam_envlist);
        }
    }

    return 0;
}
