















enum ColourSpaces { NONE, GREYSCALE, sRGB, CIELAB, BINARY };


enum CompressionType { UNCOMPRESSED, JPEG, DEFLATE, PNG };


enum SampleType { FIXEDPOINT, FLOATINGPOINT };




class RawTile{

 public:

  
  int tileNum;

  
  int resolution;

  
  int hSequence;

  
  int vSequence;

  
  CompressionType compressionType;

  
  int quality;

  
  std::string filename;

  
  time_t timestamp;

  
  void *data;

  
  
  
  int memoryManaged;

  
  unsigned int dataLength;

  
  unsigned int width;

  
  unsigned int height;

  
  int channels;

  
  int bpc;

  
  SampleType sampleType;

  
  bool padded;


  
  
  RawTile( int tn = 0, int res = 0, int hs = 0, int vs = 0, int w = 0, int h = 0, int c = 0, int b = 0 ) {
    width = w; height = h; bpc = b; dataLength = 0; data = NULL;
    tileNum = tn; resolution = res; hSequence = hs ; vSequence = vs;
    memoryManaged = 1; channels = c; compressionType = UNCOMPRESSED; quality = 0;
    timestamp = 0; sampleType = FIXEDPOINT; padded = false;
  };


  
  ~RawTile() {
    if( data && memoryManaged ){
      switch( bpc ){
      case 32:
        if( sampleType == FLOATINGPOINT ) delete[] (float*) data;
        else delete[] (unsigned int*) data;
        break;
      case 16:
	delete[] (unsigned short*) data;
        break;
      default:
	delete[] (unsigned char*) data;
        break;
      }
    }
  }


  
  RawTile( const RawTile& tile ) {

    tileNum = tile.tileNum;
    resolution = tile.resolution;
    hSequence = tile.hSequence;
    vSequence = tile.vSequence;
    compressionType = tile.compressionType;
    quality = tile.quality;
    filename = tile.filename;
    timestamp = tile.timestamp;
    memoryManaged = tile.memoryManaged;
    dataLength = tile.dataLength;
    width = tile.width;
    height = tile.height;
    channels = tile.channels;
    bpc = tile.bpc;
    sampleType = tile.sampleType;
    padded = tile.padded;

    switch( bpc ){
      case 32:
	if( sampleType == FLOATINGPOINT ) data = new float[dataLength/4];
	else data = new unsigned int[dataLength/4];
	break;
      case 16:
	data = new unsigned short[dataLength/2];
	break;
      default:
	data = new unsigned char[dataLength];
	break;
    }

    if( data && (dataLength > 0) && tile.data ){
      memcpy( data, tile.data, dataLength );
      memoryManaged = 1;
    }
  }


  
  RawTile& operator= ( const RawTile& tile ) {

    tileNum = tile.tileNum;
    resolution = tile.resolution;
    hSequence = tile.hSequence;
    vSequence = tile.vSequence;
    compressionType = tile.compressionType;
    quality = tile.quality;
    filename = tile.filename;
    timestamp = tile.timestamp;
    memoryManaged = tile.memoryManaged;
    dataLength = tile.dataLength;
    width = tile.width;
    height = tile.height;
    channels = tile.channels;
    bpc = tile.bpc;
    sampleType = tile.sampleType;
    padded = tile.padded;

    switch( bpc ){
      case 32:
	if( sampleType == FLOATINGPOINT ) data = new float[dataLength/4];
	else data = new int[dataLength/4];
	break;
      case 16:
	data = new unsigned short[dataLength/2];
	break;
      default:
	data = new unsigned char[dataLength];
	break;
    }

    if( data && (dataLength > 0) && tile.data ){
      memcpy( data, tile.data, dataLength );
      memoryManaged = 1;
    }

    return *this;
  }


  
  unsigned int size() { return dataLength; }


  
  friend int operator == ( const RawTile& A, const RawTile& B ) {
    if( (A.tileNum == B.tileNum) && (A.resolution == B.resolution) && (A.hSequence == B.hSequence) && (A.vSequence == B.vSequence) && (A.compressionType == B.compressionType) && (A.quality == B.quality) && (A.filename == B.filename) ){





      return( 1 );
    }
    else return( 0 );
  }


  
  friend int operator != ( const RawTile& A, const RawTile& B ) {
    if( (A.tileNum == B.tileNum) && (A.resolution == B.resolution) && (A.hSequence == B.hSequence) && (A.vSequence == B.vSequence) && (A.compressionType == B.compressionType) && (A.quality == B.quality) && (A.filename == B.filename) ){





      return( 0 );
    }
    else return( 1 );
  }


};



