




















































extern "C" {

struct x509_st;




}

namespace brpc {
class Span;
class Server;
class SharedLoadBalancer;
class ExcludedServers;
class RPCSender;
class StreamSettings;
class SampledRequest;
class MongoContext;
class RetryPolicy;
class InputMessageBase;
class ThriftStub;
namespace policy {
class OnServerStreamCreated;
void ProcessMongoRequest(InputMessageBase*);
void ProcessThriftRequest(InputMessageBase*);
}
namespace schan {
class Sender;
class SubDone;
}


struct IdlNames {
    const char* request_name;  
    const char* response_name; 
};

extern const IdlNames idl_single_req_single_res;
extern const IdlNames idl_single_req_multi_res;
extern const IdlNames idl_multi_req_single_res;
extern const IdlNames idl_multi_req_multi_res;


typedef bthread_id_t CallId;


enum StopStyle {
    FORCE_STOP, WAIT_FOR_STOP, };


const int32_t UNSET_MAGIC_NUM = -123456789;




class Controller : public google::protobuf::RpcController {
friend class Channel;
friend class ParallelChannel;
friend class ParallelChannelDone;
friend class ControllerPrivateAccessor;
friend class ServerPrivateAccessor;
friend class SelectiveChannel;
friend class ThriftStub;
friend class schan::Sender;
friend class schan::SubDone;
friend class policy::OnServerStreamCreated;
friend int StreamCreate(StreamId*, Controller&, const StreamOptions*);
friend int StreamAccept(StreamId*, Controller&, const StreamOptions*);
friend void policy::ProcessMongoRequest(InputMessageBase*);
friend void policy::ProcessThriftRequest(InputMessageBase*);
    
    static const uint32_t FLAGS_IGNORE_EOVERCROWDED = 1;
    static const uint32_t FLAGS_SECURITY_MODE = (1 << 1);
    static const uint32_t FLAGS_ADDED_CONCURRENCY = (1 << 2);
    static const uint32_t FLAGS_READ_PROGRESSIVELY = (1 << 3);
    static const uint32_t FLAGS_PROGRESSIVE_READER = (1 << 4);
    static const uint32_t FLAGS_BACKUP_REQUEST = (1 << 5);
    
    
    static const uint32_t FLAGS_DESTROY_CID_IN_DONE = (1 << 7);
    static const uint32_t FLAGS_CLOSE_CONNECTION = (1 << 8);
    static const uint32_t FLAGS_LOG_ID = (1 << 9); 
    static const uint32_t FLAGS_REQUEST_CODE = (1 << 10);
    static const uint32_t FLAGS_PB_BYTES_TO_BASE64 = (1 << 11);
    static const uint32_t FLAGS_ALLOW_DONE_TO_RUN_IN_PLACE = (1 << 12);
    static const uint32_t FLAGS_USED_BY_RPC = (1 << 13);
    static const uint32_t FLAGS_PB_JSONIFY_EMPTY_ARRAY = (1 << 16);
    static const uint32_t FLAGS_ENABLED_CIRCUIT_BREAKER = (1 << 17);
    static const uint32_t FLAGS_ALWAYS_PRINT_PRIMITIVE_FIELDS = (1 << 18);
    static const uint32_t FLAGS_HEALTH_CHECK_CALL = (1 << 19);
    static const uint32_t FLAGS_PB_SINGLE_REPEATED_TO_ARRAY = (1 << 20);
    static const uint32_t FLAGS_MANAGE_HTTP_BODY_ON_ERROR = (1 << 21);
    static const uint32_t FLAGS_WRITE_TO_SOCKET_IN_BACKGROUND = (1 << 22);

public:
    struct Inheritable {
        Inheritable() : log_id(0) {}
        void Reset() {
            log_id = 0;
            request_id.clear();
        }

        uint64_t log_id;
        std::string request_id;
    };

public:
    Controller();
    Controller(const Inheritable& parent_ctx);
    ~Controller();
    
    
    
    
    
    

    
    
    void set_timeout_ms(int64_t timeout_ms);
    int64_t timeout_ms() const { return _timeout_ms; }

    
    
    void set_backup_request_ms(int64_t timeout_ms);
    int64_t backup_request_ms() const { return _backup_request_ms; }

    
    
    
    
    
    
    
    
    
    
    void set_max_retry(int max_retry);
    int max_retry() const { return _max_retry; }

    
    int retried_count() const { return _current_call.nretry; }

    
    bool has_backup_request() const { return has_flag(FLAGS_BACKUP_REQUEST); }

    
    
    
    int64_t latency_us() const {
        if (_end_time_us == UNSET_MAGIC_NUM) {
            return butil::cpuwide_time_us() - _begin_time_us;
        }
        return _end_time_us - _begin_time_us;
    }

    
    google::protobuf::Message* response() const { return _response; }

    
    
    
    void set_log_id(uint64_t log_id);

    void set_request_id(std::string request_id) { _inheritable.request_id = request_id; }

    
    
    
    
    
    void set_type_of_service(short tos) { _tos = tos; }

    
    
    void set_connection_type(ConnectionType type) { _connection_type = type; }

    
    void set_request_compress_type(CompressType t) { _request_compress_type = t; }

    
    void set_request_code(uint64_t request_code) {
        add_flag(FLAGS_REQUEST_CODE);
        _request_code = request_code;
    }
    bool has_request_code() const { return has_flag(FLAGS_REQUEST_CODE); }
    uint64_t request_code() const { return _request_code; }
    
    
    HttpHeader& http_request() {
        if (_http_request == NULL) {
            _http_request = new HttpHeader;
        }
        return *_http_request;
    }
    bool has_http_request() const { return _http_request; }
    HttpHeader* release_http_request() {
        HttpHeader* const tmp = _http_request;
        _http_request = NULL;
        return tmp;
    }

    
    
    butil::IOBuf& request_attachment() { return _request_attachment; }

    ConnectionType connection_type() const { return _connection_type; }
    
    const google::protobuf::MethodDescriptor* method() const { return _method; }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    int sub_count() const;
    const Controller* sub(int index) const;

    
    
    void reset_sampled_request(SampledRequest* req);
    const SampledRequest* sampled_request() { return _sampled_request; }

    
    
    
    void set_stream_creator(StreamCreator* sc);

    
    
    void response_will_be_read_progressively() { add_flag(FLAGS_READ_PROGRESSIVELY); }
    
    
    void request_will_be_read_progressively() { add_flag(FLAGS_READ_PROGRESSIVELY); }
    
    bool is_response_read_progressively() const { return has_flag(FLAGS_READ_PROGRESSIVELY); }

    
    
    
    
    
    
    
    
    
    void ReadProgressiveAttachmentBy(ProgressiveReader* r);
    
    
    bool has_progressive_reader() const { return has_flag(FLAGS_PROGRESSIVE_READER); }
    
    
    
    
    
    void ignore_eovercrowded() { add_flag(FLAGS_IGNORE_EOVERCROWDED); }
    
    
    
    void set_pb_bytes_to_base64(bool f) { set_flag(FLAGS_PB_BYTES_TO_BASE64, f); }
    bool has_pb_bytes_to_base64() const { return has_flag(FLAGS_PB_BYTES_TO_BASE64); }

    
    
    void set_pb_single_repeated_to_array(bool f) { set_flag(FLAGS_PB_SINGLE_REPEATED_TO_ARRAY, f); }
    bool has_pb_single_repeated_to_array() const { return has_flag(FLAGS_PB_SINGLE_REPEATED_TO_ARRAY); }

    
    
    void set_pb_jsonify_empty_array(bool f) { set_flag(FLAGS_PB_JSONIFY_EMPTY_ARRAY, f); }
    bool has_pb_jsonify_empty_array() const { return has_flag(FLAGS_PB_JSONIFY_EMPTY_ARRAY); }
    
    
    
    
    
    void set_always_print_primitive_fields(bool f) { set_flag(FLAGS_ALWAYS_PRINT_PRIMITIVE_FIELDS, f); }
    bool has_always_print_primitive_fields() const { return has_flag(FLAGS_ALWAYS_PRINT_PRIMITIVE_FIELDS); }
    

    
    
    
    
    
    
    
    void allow_done_to_run_in_place()
    { add_flag(FLAGS_ALLOW_DONE_TO_RUN_IN_PLACE); }
    
    bool is_done_allowed_to_run_in_place() const { return has_flag(FLAGS_ALLOW_DONE_TO_RUN_IN_PLACE); }

    
    
    
    
    
    
    
    
    void set_write_to_socket_in_background(bool f) { set_flag(FLAGS_WRITE_TO_SOCKET_IN_BACKGROUND, f); }
    bool write_to_socket_in_background() const { return has_flag(FLAGS_WRITE_TO_SOCKET_IN_BACKGROUND); }

    
    
    
    
    

    
    
    
    
    
    bool IsCanceled() const override;

    
    
    
    
    
    
    
    void NotifyOnCancel(google::protobuf::Closure* callback) override;

    
    const AuthContext* auth_context() const { return _auth_context; }

    
    bool is_ssl() const;

    
    x509_st* get_peer_certificate() const;

    
    HttpHeader& http_response() {
        if (_http_response == NULL) {
            _http_response = new HttpHeader;
        }
        return *_http_response;
    }
    bool has_http_response() const { return _http_response; }
    HttpHeader* release_http_response() {
        HttpHeader* const tmp = _http_response;
        _http_response = NULL;
        return tmp;
    }
    
    
    
    butil::IOBuf& response_attachment() { return _response_attachment; }

    
    
    
    
    void manage_http_body_on_error(bool manage_or_not)
    { set_flag(FLAGS_MANAGE_HTTP_BODY_ON_ERROR, manage_or_not); }
    
    bool does_manage_http_body_on_error() const { return has_flag(FLAGS_MANAGE_HTTP_BODY_ON_ERROR); }

    
    
    
    
    butil::intrusive_ptr<ProgressiveAttachment> CreateProgressiveAttachment(StopStyle stop_style = WAIT_FOR_STOP);

    bool has_progressive_writer() const { return _wpa != NULL; }

    
    void set_response_compress_type(CompressType t) { _response_compress_type = t; }
    
    
    
    uint64_t trace_id() const;
    uint64_t span_id() const;

    
    
    
    
    void CloseConnection(const char* reason_fmt, ...);

    
    bool IsCloseConnection() const { return has_flag(FLAGS_CLOSE_CONNECTION); }

    
    
    bool is_security_mode() const { return has_flag(FLAGS_SECURITY_MODE); }

    
    
    const Server* server() const { return _server; }

    
    
    
    void* session_local_data();

    
    MongoContext* mongo_session_data() { return _mongo_session_data.get(); }
    
    
    
    
    
    

    
    
    
    butil::EndPoint remote_side() const { return _remote_side; }
    
    
    
    
    
    butil::EndPoint local_side() const { return _local_side; }

    
    ProtocolType request_protocol() const { return _request_protocol; }

    
    
    void Reset() override {
        ResetNonPods();
        ResetPods();
    }
    
    
    
    
    
    
    
    void SetFailed(const std::string& reason) override;
    void SetFailed(int error_code, const char* reason_fmt, ...)
        __attribute__ ((__format__ (__printf__, 3, 4)));
    
    
    
    
    bool Failed() const override;

    
    
    std::string ErrorText() const override;

    
    
    int ErrorCode() const { return _error_code; }

    
    const Inheritable& inheritable() { return _inheritable; }
    bool has_log_id() const { return has_flag(FLAGS_LOG_ID); }
    uint64_t log_id() const { return _inheritable.log_id; }
    const std::string& request_id() const { return _inheritable.request_id; }
    CompressType request_compress_type() const { return _request_compress_type; }
    CompressType response_compress_type() const { return _response_compress_type; }
    const HttpHeader& http_request() const  { return _http_request != NULL ? *_http_request : DefaultHttpHeader(); }
    
    const HttpHeader& http_response() const { return _http_response != NULL ? *_http_response : DefaultHttpHeader(); }

    const butil::IOBuf& request_attachment() const { return _request_attachment; }
    const butil::IOBuf& response_attachment() const { return _response_attachment; }

    
    
    KVMap& SessionKV();
    
    
    void FlushSessionKV(std::ostream& os);

    
    class LogPrefixDummy {
    public:
        LogPrefixDummy(const Controller* cntl) : _cntl(cntl) {}
        void DoPrintLogPrefix(std::ostream& os) const { _cntl->DoPrintLogPrefix(os); }
    private:
        const Controller* _cntl;
    };
    friend class LogPrefixDummy;
    LogPrefixDummy LogPrefix() const { return LogPrefixDummy(this); }

    
    bool has_remote_stream() { return _remote_stream_settings != NULL; }

    
    CallId call_id();

    
    
    
    
    void set_idl_names(const IdlNames& names) { _idl_names = names; }
    IdlNames idl_names() const { return _idl_names; }

    
    
    
    
    void set_idl_result(int64_t result) { _idl_result = result; }
    int64_t idl_result() const { return _idl_result; }

    const std::string& thrift_method_name() { return _thrift_method_name; }

    
    int GetSockOption(int level, int optname, void* optval, socklen_t* optlen);

    
    
    int64_t deadline_us() const { return _deadline_us; }

private:
    struct CompletionInfo {
        CallId id;           
        bool responded;      
    };

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    void OnVersionedRPCReturned(const CompletionInfo&, bool new_bthread, int saved_error);

    static void* RunEndRPC(void* arg);
    void EndRPC(const CompletionInfo&);

    static int HandleSocketFailed(bthread_id_t, void* data, int error_code, const std::string& error_text);
    void HandleSendFailed();

    static int RunOnCancel(bthread_id_t, void* data, int error_code);
    
    void set_auth_context(const AuthContext* ctx);

    
    
    
    
    
    
    
    void set_mongo_session_data(MongoContext* data);

    
    void ResetPods();
    void ResetNonPods();

    void StartCancel() override;

    
    
    void IssueRPC(int64_t start_realtime_us);

    struct ClientSettings {
        int32_t timeout_ms;
        int32_t backup_request_ms;
        int max_retry;                      
        int32_t tos;
        ConnectionType connection_type;         
        CompressType request_compress_type;
        uint64_t log_id;
        bool has_request_code;
        int64_t request_code;
    };

    void SaveClientSettings(ClientSettings*) const;
    void ApplyClientSettings(const ClientSettings&);
 
    bool FailedInline() const { return _error_code; }

    CallId get_id(int nretry) const {
        CallId id = { _correlation_id.value + nretry + 1 };
        return id;
    }

    
    bool is_health_check_call() const { return has_flag(FLAGS_HEALTH_CHECK_CALL); }

public:
    CallId current_id() const {
        CallId id = { _correlation_id.value + _current_call.nretry + 1 };
        return id;
    }
private:
    
    
    void AppendServerIdentiy();

    
    
    struct Call {
        Call() { Reset(); }
        Call(Call*); 
        ~Call();
        void Reset();
        void OnComplete(Controller* c, int error_code, bool responded, bool end_of_rpc);

        int nretry;                     
        bool need_feedback;             
        bool enable_circuit_breaker;    
        bool touched_by_stream_creator; 
        SocketId peer_id;               
        int64_t begin_time_us;          
        
        
        
        
        SocketUniquePtr sending_sock;
        StreamUserData* stream_user_data;
    };

    void HandleStreamConnection(Socket *host_socket);

    bool SingleServer() const { return _single_server_id != INVALID_SOCKET_ID; }

    void SubmitSpan();

    void OnRPCBegin(int64_t begin_time_us) {
        _begin_time_us = begin_time_us;
        
        _end_time_us = begin_time_us;
    }

    void OnRPCEnd(int64_t end_time_us) {
        _end_time_us = end_time_us;
    }

    static void RunDoneInBackupThread(void*);
    void DoneInBackupThread();

    
    inline void add_flag(uint32_t f) { _flags |= f; }
    inline void clear_flag(uint32_t f) { _flags &= ~f; }
    inline void set_flag(uint32_t f, bool t)
    { return t ? add_flag(f) : clear_flag(f); }
    inline bool has_flag(uint32_t f) const { return _flags & f; }

    void set_used_by_rpc() { add_flag(FLAGS_USED_BY_RPC); }
    bool is_used_by_rpc() const { return has_flag(FLAGS_USED_BY_RPC); }

    bool has_enabled_circuit_breaker() const { 
        return has_flag(FLAGS_ENABLED_CIRCUIT_BREAKER); 
    }

    std::string& protocol_param() { return _thrift_method_name; }
    const std::string& protocol_param() const { return _thrift_method_name; }

    void DoPrintLogPrefix(std::ostream& os) const;

private:
    

    Span* _span;
    uint32_t _flags; 
    int32_t _error_code;
    std::string _error_text;
    butil::EndPoint _remote_side;
    butil::EndPoint _local_side;
    
    void* _session_local_data;
    const Server* _server;
    bthread_id_t _oncancel_id;
    const AuthContext* _auth_context;        
    butil::intrusive_ptr<MongoContext> _mongo_session_data;
    SampledRequest* _sampled_request;

    ProtocolType _request_protocol;
    
    
    int _max_retry;
    const RetryPolicy* _retry_policy;
    
    
    CallId _correlation_id;

    ConnectionType _connection_type;

    
    int _fail_limit;
    
    uint32_t _pipelined_count;

    
    int32_t _timeout_ms;
    int32_t _connect_timeout_ms;
    int32_t _backup_request_ms;
    
    int64_t _real_timeout_ms;
    
    int64_t _deadline_us;
    
    bthread_timer_t _timeout_id;

    
    int64_t _begin_time_us;
    int64_t _end_time_us;
    short _tos;    
    
    int _preferred_index;
    CompressType _request_compress_type;
    CompressType _response_compress_type;
    Inheritable _inheritable;
    int _pchan_sub_count;
    google::protobuf::Message* _response;
    google::protobuf::Closure* _done;
    RPCSender* _sender;
    uint64_t _request_code;
    SocketId _single_server_id;
    butil::intrusive_ptr<SharedLoadBalancer> _lb;

    
    CompletionInfo _tmp_completion_info;
    
    Call _current_call;
    Call* _unfinished_call;
    ExcludedServers* _accessed;
    
    StreamCreator* _stream_creator;

    
    Protocol::PackRequest _pack_request;
    const google::protobuf::MethodDescriptor* _method;
    const Authenticator* _auth;
    butil::IOBuf _request_buf;
    IdlNames _idl_names;
    int64_t _idl_result;

    HttpHeader* _http_request;
    HttpHeader* _http_response;

    std::unique_ptr<KVMap> _session_kv;

    
    butil::IOBuf _request_attachment;
    butil::IOBuf _response_attachment;

    
    butil::intrusive_ptr<ProgressiveAttachment> _wpa;
    
    butil::intrusive_ptr<ReadableProgressiveAttachment> _rpa;

    
    
    StreamId _request_stream;
    
    StreamId _response_stream;
    
    StreamSettings *_remote_stream_settings;

    
    std::string _thrift_method_name;

    uint32_t _auth_flags;
};





void StartCancel(CallId id);


void Join(CallId id);








google::protobuf::Closure* DoNothing();


void WebEscape(const std::string& source, std::string* output);


bool IsAskedToQuit();


void AskToQuit();

std::ostream& operator<<(std::ostream& os, const Controller::LogPrefixDummy& p);

} 






















