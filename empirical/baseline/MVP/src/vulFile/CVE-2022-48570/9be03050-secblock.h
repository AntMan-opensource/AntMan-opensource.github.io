




















NAMESPACE_BEGIN(CryptoPP)





template<class T> class AllocatorBase {

public:
	typedef T value_type;
	typedef size_t size_type;
	typedef std::ptrdiff_t difference_type;
	typedef T * pointer;
	typedef const T * const_pointer;
	typedef T & reference;
	typedef const T & const_reference;

	pointer address(reference r) const {return (&r);}
	const_pointer address(const_reference r) const {return (&r); }
	void construct(pointer p, const T& val) {new (p) T(val);}
	void destroy(pointer p) {CRYPTOPP_UNUSED(p); p->~T();}

	
	
	
	
	
	
	
	
	
	
	
	

	static const size_type ELEMS_MAX = ...;

	static const size_type ELEMS_MAX = (~(size_type)0)/sizeof(T);

	enum : size_type {ELEMS_MAX = SIZE_MAX/sizeof(T)};

	static const size_type ELEMS_MAX = SIZE_MAX/sizeof(T);


	
	
	
	
	
	
	CRYPTOPP_CONSTEXPR size_type max_size() const {return ELEMS_MAX;}


	
	
	CRYPTOPP_CONSTEXPR size_type max_size(size_type n) const {return SIZE_MAX/n;}




	
	
	
	
	
	
	
    template<typename V, typename... Args> void construct(V* ptr, Args&&... args) {::new ((void*)ptr) V(std::forward<Args>(args)...);}

	
	
	
	
    template<typename V> void destroy(V* ptr) {if (ptr) ptr->~V();}



protected:

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	static void CheckSize(size_t size)
	{
		
		CRYPTOPP_UNUSED(size);
		
		if (sizeof(T) != 1 && size > ELEMS_MAX)
			throw InvalidArgument("AllocatorBase: requested size would cause integer overflow");
	}
};



















template <class T, class A> typename A::pointer StandardReallocate(A& alloc, T *oldPtr, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)
{
	
	
	if (oldSize == newSize)
		return oldPtr;

	if (preserve)
	{
		typename A::pointer newPointer = alloc.allocate(newSize, NULLPTR);
		const typename A::size_type copySize = STDMIN(oldSize, newSize) * sizeof(T);

		if (oldPtr && newPointer)
			memcpy_s(newPointer, copySize, oldPtr, copySize);

		if (oldPtr)
			alloc.deallocate(oldPtr, oldSize);

		return newPointer;
	}
	else {
		if (oldPtr)
			alloc.deallocate(oldPtr, oldSize);

		return alloc.allocate(newSize, NULLPTR);
	}
}









template <class T, bool T_Align16 = false> class AllocatorWithCleanup : public AllocatorBase<T> {

public:
	CRYPTOPP_INHERIT_ALLOCATOR_TYPES                pointer allocate(size_type size, const void *ptr = NULLPTR)















	{
		CRYPTOPP_UNUSED(ptr); CRYPTOPP_ASSERT(ptr == NULLPTR);
		this->CheckSize(size);
		if (size == 0)
			return NULLPTR;


		if (T_Align16)
			return reinterpret_cast<pointer>(AlignedAllocate(size*sizeof(T)));


		return reinterpret_cast<pointer>(UnalignedAllocate(size*sizeof(T)));
	}

	
	
	
	
	
	
	
	
	void deallocate(void *ptr, size_type size)
	{
		
		
		if (ptr)
		{
			SecureWipeArray(reinterpret_cast<pointer>(ptr), size);


			if (T_Align16)
				return AlignedDeallocate(ptr);


			UnalignedDeallocate(ptr);
		}
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	pointer reallocate(T *oldPtr, size_type oldSize, size_type newSize, bool preserve)
	{
		CRYPTOPP_ASSERT((oldPtr && oldSize) || !(oldPtr || oldSize));
		return StandardReallocate(*this, oldPtr, oldSize, newSize, preserve);
	}

	
	
	
	
	
	
	
    template <class V> struct rebind { typedef AllocatorWithCleanup<V, T_Align16> other; };

	AllocatorWithCleanup() {}
	template <class V, bool A> AllocatorWithCleanup(const AllocatorWithCleanup<V, A> &) {}

};

CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<byte>;
CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word16>;
CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word32>;
CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word64>;

CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word128, true>; 


CRYPTOPP_DLL_TEMPLATE_CLASS AllocatorWithCleanup<word, true>;	 









template <class T> class NullAllocator : public AllocatorBase<T> {

public:
	
	CRYPTOPP_INHERIT_ALLOCATOR_TYPES     pointer allocate(size_type n, const void* unused = NULLPTR)




	{
		CRYPTOPP_UNUSED(n); CRYPTOPP_UNUSED(unused);
		CRYPTOPP_ASSERT(false); return NULLPTR;
	}

	void deallocate(void *p, size_type n)
	{
		CRYPTOPP_UNUSED(p); CRYPTOPP_UNUSED(n);
		CRYPTOPP_ASSERT(false);
	}

	CRYPTOPP_CONSTEXPR size_type max_size() const {return 0;}
	
};













template <class T, size_t S, class A = NullAllocator<T>, bool T_Align16 = false> class FixedSizeAllocatorWithCleanup : public AllocatorBase<T> {

	
	
	
	
	
};











template <class T, size_t S, class A> class FixedSizeAllocatorWithCleanup<T, S, A, true> : public AllocatorBase<T> {

public:
	CRYPTOPP_INHERIT_ALLOCATOR_TYPES   FixedSizeAllocatorWithCleanup() : m_allocated(false) {}



	
	
	
	
	
	
	
	
	
	
	
	
	pointer allocate(size_type size)
	{
		CRYPTOPP_ASSERT(IsAlignedOn(m_array, 8));

		if (size <= S && !m_allocated)
		{
			m_allocated = true;
			return GetAlignedArray();
		}
		else return m_fallbackAllocator.allocate(size);
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	pointer allocate(size_type size, const void *hint)
	{
		if (size <= S && !m_allocated)
		{
			m_allocated = true;
			return GetAlignedArray();
		}
		else return m_fallbackAllocator.allocate(size, hint);
	}

	
	
	
	
	
	
	
	
	void deallocate(void *ptr, size_type size)
	{
		
		
		if (ptr == GetAlignedArray())
		{
			
			
			
			
			CRYPTOPP_ASSERT(size <= S);
			CRYPTOPP_ASSERT(m_allocated);
			m_allocated = false;
			SecureWipeArray(reinterpret_cast<pointer>(ptr), size);
		}
		else {
			if (ptr)
				m_fallbackAllocator.deallocate(ptr, size);
		}
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	pointer reallocate(pointer oldPtr, size_type oldSize, size_type newSize, bool preserve)
	{
		if (oldPtr == GetAlignedArray() && newSize <= S)
		{
			CRYPTOPP_ASSERT(oldSize <= S);
			if (oldSize > newSize)
				SecureWipeArray(oldPtr+newSize, oldSize-newSize);
			return oldPtr;
		}

		pointer newPointer = allocate(newSize, NULLPTR);
		if (preserve && newSize)
		{
			const size_type copySize = STDMIN(oldSize, newSize);
			if (newPointer && oldPtr)  
				memcpy_s(newPointer, sizeof(T)*newSize, oldPtr, sizeof(T)*copySize);
		}
		deallocate(oldPtr, oldSize);
		return newPointer;
	}

	CRYPTOPP_CONSTEXPR size_type max_size() const {
		return STDMAX(m_fallbackAllocator.max_size(), S);
	}

private:



	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	T* GetAlignedArray() {

		
		
		
		
		
		
		
		
		
		CRYPTOPP_ASSERT(IsAlignedOn(m_array, 8));
		int off = reinterpret_cast<uintptr_t>(m_array) % 16;
		byte* ptr = reinterpret_cast<byte*>(m_array) + off;

		
		
		CRYPTOPP_ASSERT(IsAlignedOn(ptr, 16));
		
		CRYPTOPP_ASSERT( reinterpret_cast<uintptr_t>(ptr) >= reinterpret_cast<uintptr_t>(m_array)

		);
		
		
		CRYPTOPP_ASSERT( reinterpret_cast<uintptr_t>(ptr+S*sizeof(T)) <= reinterpret_cast<uintptr_t>(m_array+(S+PAD))

		);

		
		return reinterpret_cast<T*>( static_cast<void*>(ptr)
		);
	}

	
	enum { Q = sizeof(T), PAD = (Q >= 8) ? 1 : (Q >= 4) ? 2 : (Q >= 2) ? 4 : 8 };
	
	CRYPTOPP_ALIGN_DATA(8) T m_array[S+PAD];



	
	T* GetAlignedArray() {return m_array;}
	T m_array[S];



	A m_fallbackAllocator;
	bool m_allocated;
};











template <class T, size_t S, class A> class FixedSizeAllocatorWithCleanup<T, S, A, false> : public AllocatorBase<T> {

public:
	CRYPTOPP_INHERIT_ALLOCATOR_TYPES   FixedSizeAllocatorWithCleanup() : m_allocated(false) {}



	
	
	
	
	
	
	
	
	
	
	
	
	pointer allocate(size_type size)
	{
		CRYPTOPP_ASSERT(IsAlignedOn(m_array, 8));

		if (size <= S && !m_allocated)
		{
			m_allocated = true;
			return GetAlignedArray();
		}
		else return m_fallbackAllocator.allocate(size);
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	pointer allocate(size_type size, const void *hint)
	{
		if (size <= S && !m_allocated)
		{
			m_allocated = true;
			return GetAlignedArray();
		}
		else return m_fallbackAllocator.allocate(size, hint);
	}

	
	
	
	
	
	
	
	
	void deallocate(void *ptr, size_type size)
	{
		
		
		if (ptr == GetAlignedArray())
		{
			
			
			CRYPTOPP_ASSERT(size <= S);
			CRYPTOPP_ASSERT(m_allocated);
			m_allocated = false;
			SecureWipeArray((pointer)ptr, size);
		}
		else {
			if (ptr)
				m_fallbackAllocator.deallocate(ptr, size);
			m_allocated = false;
		}
	}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	pointer reallocate(pointer oldPtr, size_type oldSize, size_type newSize, bool preserve)
	{
		if (oldPtr == GetAlignedArray() && newSize <= S)
		{
			CRYPTOPP_ASSERT(oldSize <= S);
			if (oldSize > newSize)
				SecureWipeArray(oldPtr+newSize, oldSize-newSize);
			return oldPtr;
		}

		pointer newPointer = allocate(newSize, NULLPTR);
		if (preserve && newSize)
		{
			const size_type copySize = STDMIN(oldSize, newSize);
			if (newPointer && oldPtr)  
				memcpy_s(newPointer, sizeof(T)*newSize, oldPtr, sizeof(T)*copySize);
		}
		deallocate(oldPtr, oldSize);
		return newPointer;
	}

	CRYPTOPP_CONSTEXPR size_type max_size() const {
		return STDMAX(m_fallbackAllocator.max_size(), S);
	}

private:

	
	T* GetAlignedArray() {return m_array;}
	T m_array[S];

	A m_fallbackAllocator;
	bool m_allocated;
};




template <class T, class A = AllocatorWithCleanup<T> > class SecBlock {

public:
	typedef typename A::value_type value_type;
	typedef typename A::pointer iterator;
	typedef typename A::const_pointer const_iterator;
	typedef typename A::size_type size_type;

	
	
	
	
	
	
	
	
	
	
	
	

	static const size_type ELEMS_MAX = ...;

	static const size_type ELEMS_MAX = (~(size_type)0)/sizeof(T);

	enum : size_type {ELEMS_MAX = A::ELEMS_MAX};

	static const size_type ELEMS_MAX = SIZE_MAX/sizeof(T);


	
	
	
	
	
	explicit SecBlock(size_type size=0)
		: m_mark(ELEMS_MAX), m_size(size), m_ptr(m_alloc.allocate(size, NULLPTR)) { }

	
	
	
	SecBlock(const SecBlock<T, A> &t)
		: m_mark(t.m_mark), m_size(t.m_size), m_ptr(m_alloc.allocate(t.m_size, NULLPTR)) {
			CRYPTOPP_ASSERT((!t.m_ptr && !m_size) || (t.m_ptr && m_size));
			if (m_ptr && t.m_ptr)
				memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
		}

	
	
	
	
	
	
	
	
	SecBlock(const T *ptr, size_type len)
		: m_mark(ELEMS_MAX), m_size(len), m_ptr(m_alloc.allocate(len, NULLPTR)) {
			CRYPTOPP_ASSERT((!m_ptr && !m_size) || (m_ptr && m_size));
			if (m_ptr && ptr)
				memcpy_s(m_ptr, m_size*sizeof(T), ptr, len*sizeof(T));
			else if (m_ptr && m_size)
				memset(m_ptr, 0, m_size*sizeof(T));
		}

	~SecBlock()
		{m_alloc.deallocate(m_ptr, STDMIN(m_size, m_mark));}


	
        
	operator T *() const {return (T*)m_ptr;}

	
        
	operator const void *() const {return m_ptr;}

	
        
	operator void *()
		{return m_ptr;}

	
        
	operator const T *() const {return m_ptr;}

	
        
	operator T *()
		{return m_ptr;}


	
	
	iterator begin()
		{return m_ptr;}
	
	
	const_iterator begin() const {return m_ptr;}
	
	
	iterator end()
		{return m_ptr+m_size;}
	
	
	const_iterator end() const {return m_ptr+m_size;}

	
	
	typename A::pointer data() {return m_ptr;}
	
	
	typename A::const_pointer data() const {return m_ptr;}

	
	
	
	size_type size() const {return m_size;}
	
	
	bool empty() const {return m_size == 0;}

	
	
	byte * BytePtr() {return (byte *)m_ptr;}
	
	
	const byte * BytePtr() const {return (const byte *)m_ptr;}
	
	
	
	size_type SizeInBytes() const {return m_size*sizeof(T);}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	void SetMark(size_t count) {m_mark = count;}

	
	
	
	
	
	void Assign(const T *ptr, size_type len)
	{
		New(len);
		if (m_ptr && ptr)  
			memcpy_s(m_ptr, m_size*sizeof(T), ptr, len*sizeof(T));
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	void Assign(size_type count, T value)
	{
		New(count);
		for (size_t i=0; i<count; ++i)
			m_ptr[i] = value;

		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	void Assign(const SecBlock<T, A> &t)
	{
		if (this != &t)
		{
			New(t.m_size);
			if (m_ptr && t.m_ptr)  
				memcpy_s(m_ptr, m_size*sizeof(T), t, t.m_size*sizeof(T));
		}
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	SecBlock<T, A>& operator=(const SecBlock<T, A> &t)
	{
		
		Assign(t);
		return *this;
	}

	
	
	
	SecBlock<T, A>& operator+=(const SecBlock<T, A> &t)
	{
		CRYPTOPP_ASSERT((!t.m_ptr && !t.m_size) || (t.m_ptr && t.m_size));
		if (t.m_size)
		{
			const size_type oldSize = m_size;
			if (this != &t)  
			{
				Grow(m_size+t.m_size);
				if (m_ptr && t.m_ptr)  
					memcpy_s(m_ptr+oldSize, (m_size-oldSize)*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
			}
			else             {
				Grow(m_size*2);
				if (m_ptr && t.m_ptr)  
					memcpy_s(m_ptr+oldSize, (m_size-oldSize)*sizeof(T), m_ptr, oldSize*sizeof(T));
			}
		}
		m_mark = ELEMS_MAX;
		return *this;
	}

	
	
	
	
	SecBlock<T, A> operator+(const SecBlock<T, A> &t)
	{
		CRYPTOPP_ASSERT((!m_ptr && !m_size) || (m_ptr && m_size));
		CRYPTOPP_ASSERT((!t.m_ptr && !t.m_size) || (t.m_ptr && t.m_size));
		if(!t.m_size) return SecBlock(*this);

		SecBlock<T, A> result(m_size+t.m_size);
		if (m_size)
			memcpy_s(result.m_ptr, result.m_size*sizeof(T), m_ptr, m_size*sizeof(T));
		if (result.m_ptr && t.m_ptr)  
			memcpy_s(result.m_ptr+m_size, (result.m_size-m_size)*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
		return result;
	}

	
	
	
	
	
	
	bool operator==(const SecBlock<T, A> &t) const {
		return m_size == t.m_size && VerifyBufsEqual( reinterpret_cast<const byte*>(m_ptr), reinterpret_cast<const byte*>(t.m_ptr), m_size*sizeof(T));

	}

	
	
	
	
	
	
	
	bool operator!=(const SecBlock<T, A> &t) const {
		return !operator==(t);
	}

	
	
	
	
	
	
	
	
	void New(size_type newSize)
	{
		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);
		m_size = newSize;
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	
	
	void CleanNew(size_type newSize)
	{
		New(newSize);
		if (m_ptr) {memset_z(m_ptr, 0, m_size*sizeof(T));}
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	
	
	void Grow(size_type newSize)
	{
		if (newSize > m_size)
		{
			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
			m_size = newSize;
		}
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	
	
	void CleanGrow(size_type newSize)
	{
		if (newSize > m_size)
		{
			m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
			memset_z(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));
			m_size = newSize;
		}
		m_mark = ELEMS_MAX;
	}

	
	
	
	
	
	
	
	void resize(size_type newSize)
	{
		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);
		m_size = newSize;
		m_mark = ELEMS_MAX;
	}

	
	
	
	void swap(SecBlock<T, A> &b)
	{
		
		std::swap(m_alloc, b.m_alloc);
		std::swap(m_mark, b.m_mark);
		std::swap(m_size, b.m_size);
		std::swap(m_ptr, b.m_ptr);
	}

protected:
	A m_alloc;
	size_type m_mark, m_size;
	T *m_ptr;
};



class SecByteBlock : public SecBlock<byte> {};

class SecWordBlock : public SecBlock<word> {};

class AlignedSecByteBlock : public SecBlock<byte, AllocatorWithCleanup<byte, true> > {};

typedef SecBlock<byte> SecByteBlock;
typedef SecBlock<word> SecWordBlock;
typedef SecBlock<byte, AllocatorWithCleanup<byte, true> > AlignedSecByteBlock;









template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S> > class FixedSizeSecBlock : public SecBlock<T, A> {

public:
	
	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}
};





template <class T, unsigned int S, bool T_Align16 = true> class FixedSizeAlignedSecBlock : public FixedSizeSecBlock<T, S, FixedSizeAllocatorWithCleanup<T, S, NullAllocator<T>, T_Align16> > {

};





template <class T, unsigned int S, class A = FixedSizeAllocatorWithCleanup<T, S, AllocatorWithCleanup<T> > > class SecBlockWithHint : public SecBlock<T, A> {

public:
	
	explicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}
};

template<class T, bool A, class V, bool B> inline bool operator==(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<V, B>&) {return (true);}
template<class T, bool A, class V, bool B> inline bool operator!=(const CryptoPP::AllocatorWithCleanup<T, A>&, const CryptoPP::AllocatorWithCleanup<V, B>&) {return (false);}

NAMESPACE_END  NAMESPACE_BEGIN(std)







template <class T, class A> inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)
{
	a.swap(b);
}



template <class _Tp1, class _Tp2> inline CryptoPP::AllocatorWithCleanup<_Tp2>& __stl_alloc_rebind(CryptoPP::AllocatorWithCleanup<_Tp1>& __a, const _Tp2*)

{
	return (CryptoPP::AllocatorWithCleanup<_Tp2>&)(__a);
}


NAMESPACE_END      





