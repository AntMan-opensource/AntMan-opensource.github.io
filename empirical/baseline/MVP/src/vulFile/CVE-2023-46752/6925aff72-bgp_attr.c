










































static const struct message attr_str[] = {
	{BGP_ATTR_ORIGIN, "ORIGIN", {BGP_ATTR_AS_PATH, "AS_PATH", {BGP_ATTR_NEXT_HOP, "NEXT_HOP", {BGP_ATTR_MULTI_EXIT_DISC, "MULTI_EXIT_DISC", {BGP_ATTR_LOCAL_PREF, "LOCAL_PREF", {BGP_ATTR_ATOMIC_AGGREGATE, "ATOMIC_AGGREGATE", {BGP_ATTR_AGGREGATOR, "AGGREGATOR", {BGP_ATTR_COMMUNITIES, "COMMUNITY", {BGP_ATTR_ORIGINATOR_ID, "ORIGINATOR_ID", {BGP_ATTR_CLUSTER_LIST, "CLUSTER_LIST", {BGP_ATTR_MP_REACH_NLRI, "MP_REACH_NLRI", {BGP_ATTR_MP_UNREACH_NLRI, "MP_UNREACH_NLRI", {BGP_ATTR_EXT_COMMUNITIES, "EXT_COMMUNITIES", {BGP_ATTR_AS4_PATH, "AS4_PATH", {BGP_ATTR_AS4_AGGREGATOR, "AS4_AGGREGATOR", {BGP_ATTR_PMSI_TUNNEL, "PMSI_TUNNEL_ATTRIBUTE", {BGP_ATTR_ENCAP, "ENCAP", {BGP_ATTR_OTC, "OTC",  {BGP_ATTR_VNC, "VNC",  {BGP_ATTR_LARGE_COMMUNITIES, "LARGE_COMMUNITY", {BGP_ATTR_PREFIX_SID, "PREFIX_SID", {BGP_ATTR_IPV6_EXT_COMMUNITIES, "IPV6_EXT_COMMUNITIES", {BGP_ATTR_AIGP, "AIGP", {0}};

























static const struct message attr_flag_str[] = {
	{BGP_ATTR_FLAG_OPTIONAL, "Optional", {BGP_ATTR_FLAG_TRANS, "Transitive", {BGP_ATTR_FLAG_PARTIAL, "Partial",  {BGP_ATTR_FLAG_EXTLEN, "Extended Length", {0}};





static struct hash *cluster_hash;

static void *cluster_hash_alloc(void *p)
{
	const struct cluster_list *val = (const struct cluster_list *)p;
	struct cluster_list *cluster;

	cluster = XMALLOC(MTYPE_CLUSTER, sizeof(struct cluster_list));
	cluster->length = val->length;

	if (cluster->length) {
		cluster->list = XMALLOC(MTYPE_CLUSTER_VAL, val->length);
		memcpy(cluster->list, val->list, val->length);
	} else cluster->list = NULL;

	cluster->refcnt = 0;

	return cluster;
}


static struct cluster_list *cluster_parse(struct in_addr *pnt, int length)
{
	struct cluster_list tmp = {};
	struct cluster_list *cluster;

	tmp.length = length;
	tmp.list = length == 0 ? NULL : pnt;

	cluster = hash_get(cluster_hash, &tmp, cluster_hash_alloc);
	cluster->refcnt++;
	return cluster;
}

bool cluster_loop_check(struct cluster_list *cluster, struct in_addr originator)
{
	int i;

	for (i = 0; i < cluster->length / 4; i++)
		if (cluster->list[i].s_addr == originator.s_addr)
			return true;
	return false;
}

static unsigned int cluster_hash_key_make(const void *p)
{
	const struct cluster_list *cluster = p;

	return jhash(cluster->list, cluster->length, 0);
}

static bool cluster_hash_cmp(const void *p1, const void *p2)
{
	const struct cluster_list *cluster1 = p1;
	const struct cluster_list *cluster2 = p2;

	if (cluster1->list == cluster2->list)
		return true;

	if (!cluster1->list || !cluster2->list)
		return false;

	if (cluster1->length != cluster2->length)
		return false;

	return (memcmp(cluster1->list, cluster2->list, cluster1->length) == 0);
}

static void cluster_free(struct cluster_list *cluster)
{
	XFREE(MTYPE_CLUSTER_VAL, cluster->list);
	XFREE(MTYPE_CLUSTER, cluster);
}

static struct cluster_list *cluster_intern(struct cluster_list *cluster)
{
	struct cluster_list *find;

	find = hash_get(cluster_hash, cluster, cluster_hash_alloc);
	find->refcnt++;

	return find;
}

static void cluster_unintern(struct cluster_list **cluster)
{
	if (!*cluster)
		return;

	if ((*cluster)->refcnt)
		(*cluster)->refcnt--;

	if ((*cluster)->refcnt == 0) {
		void *p = hash_release(cluster_hash, *cluster);
		assert(p == *cluster);
		cluster_free(*cluster);
		*cluster = NULL;
	}
}

static void cluster_init(void)
{
	cluster_hash = hash_create(cluster_hash_key_make, cluster_hash_cmp, "BGP Cluster");
}

static void cluster_finish(void)
{
	hash_clean_and_free(&cluster_hash, (void (*)(void *))cluster_free);
}

static struct hash *encap_hash = NULL;

static struct hash *vnc_hash = NULL;

static struct hash *srv6_l3vpn_hash;
static struct hash *srv6_vpn_hash;

struct bgp_attr_encap_subtlv *encap_tlv_dup(struct bgp_attr_encap_subtlv *orig)
{
	struct bgp_attr_encap_subtlv *new;
	struct bgp_attr_encap_subtlv *tail;
	struct bgp_attr_encap_subtlv *p;

	for (p = orig, tail = new = NULL; p; p = p->next) {
		int size = sizeof(struct bgp_attr_encap_subtlv) + p->length;
		if (tail) {
			tail->next = XCALLOC(MTYPE_ENCAP_TLV, size);
			tail = tail->next;
		} else {
			tail = new = XCALLOC(MTYPE_ENCAP_TLV, size);
		}
		assert(tail);
		memcpy(tail, p, size);
		tail->next = NULL;
	}

	return new;
}

static void encap_free(struct bgp_attr_encap_subtlv *p)
{
	struct bgp_attr_encap_subtlv *next;
	while (p) {
		next = p->next;
		p->next = NULL;
		XFREE(MTYPE_ENCAP_TLV, p);
		p = next;
	}
}

void bgp_attr_flush_encap(struct attr *attr)
{
	if (!attr)
		return;

	if (attr->encap_subtlvs) {
		encap_free(attr->encap_subtlvs);
		attr->encap_subtlvs = NULL;
	}

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs) {
		encap_free(vnc_subtlvs);
		bgp_attr_set_vnc_subtlvs(attr, NULL);
	}

}


static bool encap_same(const struct bgp_attr_encap_subtlv *h1, const struct bgp_attr_encap_subtlv *h2)
{
	const struct bgp_attr_encap_subtlv *p;
	const struct bgp_attr_encap_subtlv *q;

	if (h1 == h2)
		return true;
	if (h1 == NULL || h2 == NULL)
		return false;

	for (p = h1; p; p = p->next) {
		for (q = h2; q; q = q->next) {
			if ((p->type == q->type) && (p->length == q->length)
			    && !memcmp(p->value, q->value, p->length)) {

				break;
			}
		}
		if (!q)
			return false;
	}

	for (p = h2; p; p = p->next) {
		for (q = h1; q; q = q->next) {
			if ((p->type == q->type) && (p->length == q->length)
			    && !memcmp(p->value, q->value, p->length)) {

				break;
			}
		}
		if (!q)
			return false;
	}

	return true;
}

static void *encap_hash_alloc(void *p)
{
	
	return p;
}

typedef enum {
	ENCAP_SUBTLV_TYPE,  VNC_SUBTLV_TYPE  } encap_subtlv_type;




static struct bgp_attr_encap_subtlv * encap_intern(struct bgp_attr_encap_subtlv *encap, encap_subtlv_type type)
{
	struct bgp_attr_encap_subtlv *find;
	struct hash *hash = encap_hash;

	if (type == VNC_SUBTLV_TYPE)
		hash = vnc_hash;


	find = hash_get(hash, encap, encap_hash_alloc);
	if (find != encap)
		encap_free(encap);
	find->refcnt++;

	return find;
}

static void encap_unintern(struct bgp_attr_encap_subtlv **encapp, encap_subtlv_type type)
{
	struct bgp_attr_encap_subtlv *encap = *encapp;

	if (!*encapp)
		return;

	if (encap->refcnt)
		encap->refcnt--;

	if (encap->refcnt == 0) {
		struct hash *hash = encap_hash;

		if (type == VNC_SUBTLV_TYPE)
			hash = vnc_hash;

		hash_release(hash, encap);
		encap_free(encap);
		*encapp = NULL;
	}
}

static unsigned int encap_hash_key_make(const void *p)
{
	const struct bgp_attr_encap_subtlv *encap = p;

	return jhash(encap->value, encap->length, 0);
}

static bool encap_hash_cmp(const void *p1, const void *p2)
{
	return encap_same((const struct bgp_attr_encap_subtlv *)p1, (const struct bgp_attr_encap_subtlv *)p2);
}

static void encap_init(void)
{
	encap_hash = hash_create(encap_hash_key_make, encap_hash_cmp, "BGP Encap Hash");

	vnc_hash = hash_create(encap_hash_key_make, encap_hash_cmp, "BGP VNC Hash");

}

static void encap_finish(void)
{
	hash_clean_and_free(&encap_hash, (void (*)(void *))encap_free);

	hash_clean_and_free(&vnc_hash, (void (*)(void *))encap_free);

}

static bool overlay_index_same(const struct attr *a1, const struct attr *a2)
{
	if (!a1 && a2)
		return false;
	if (!a2 && a1)
		return false;
	if (!a1 && !a2)
		return true;

	return bgp_route_evpn_same(bgp_attr_get_evpn_overlay(a1), bgp_attr_get_evpn_overlay(a2));
}


static struct hash *transit_hash;

static void transit_free(struct transit *transit)
{
	XFREE(MTYPE_TRANSIT_VAL, transit->val);
	XFREE(MTYPE_TRANSIT, transit);
}

static void *transit_hash_alloc(void *p)
{
	
	return p;
}

static struct transit *transit_intern(struct transit *transit)
{
	struct transit *find;

	find = hash_get(transit_hash, transit, transit_hash_alloc);
	if (find != transit)
		transit_free(transit);
	find->refcnt++;

	return find;
}

static void transit_unintern(struct transit **transit)
{
	if (!*transit)
		return;

	if ((*transit)->refcnt)
		(*transit)->refcnt--;

	if ((*transit)->refcnt == 0) {
		hash_release(transit_hash, *transit);
		transit_free(*transit);
		*transit = NULL;
	}
}

static bool bgp_attr_aigp_get_tlv_metric(uint8_t *pnt, int length, uint64_t *aigp)
{
	uint8_t *data = pnt;
	uint8_t tlv_type;
	uint16_t tlv_length;

	while (length) {
		tlv_type = *data;
		ptr_get_be16(data + 1, &tlv_length);
		(void)data;

		
		if (tlv_type == BGP_AIGP_TLV_METRIC) {
			(void)ptr_get_be64(data + 3, aigp);

			
			if (*aigp == BGP_AIGP_TLV_METRIC_MAX) {
				zlog_err("Bad AIGP TLV (%s) length: %llu", BGP_AIGP_TLV_METRIC_DESC, BGP_AIGP_TLV_METRIC_MAX);

				return false;
			}

			return true;
		}

		data += tlv_length;
		length -= tlv_length;
	}

	return false;
}

static uint64_t bgp_aigp_metric_total(struct bgp_path_info *bpi)
{
	uint64_t aigp = bgp_attr_get_aigp_metric(bpi->attr);

	if (bpi->nexthop)
		return aigp + bpi->nexthop->metric;
	else return aigp;
}

static void stream_put_bgp_aigp_tlv_metric(struct stream *s, struct bgp_path_info *bpi)
{
	stream_putc(s, BGP_AIGP_TLV_METRIC);
	stream_putw(s, BGP_AIGP_TLV_METRIC_LEN);
	stream_putq(s, bgp_aigp_metric_total(bpi));
}

static bool bgp_attr_aigp_valid(uint8_t *pnt, int length)
{
	uint8_t *data = pnt;
	uint8_t tlv_type;
	uint16_t tlv_length;
	uint8_t *end = data + length;

	if (length < 3) {
		zlog_err("Bad AIGP attribute length (MUST be minimum 3): %u", length);
		return false;
	}

	while (length) {
		size_t data_len = end - data;

		tlv_type = *data;

		if (data_len - 1 < 2)
			return false;

		ptr_get_be16(data + 1, &tlv_length);
		(void)data;

		if (length < tlv_length) {
			zlog_err( "Bad AIGP attribute length: %u, but TLV length: %u", length, tlv_length);

			return false;
		}

		if (tlv_length < 3) {
			zlog_err("Bad AIGP TLV length (MUST be minimum 3): %u", tlv_length);
			return false;
		}

		
		if (tlv_type == BGP_AIGP_TLV_METRIC && tlv_length != BGP_AIGP_TLV_METRIC_LEN) {
			zlog_err("Bad AIGP TLV (%s) length: %u", BGP_AIGP_TLV_METRIC_DESC, tlv_length);
			return false;
		}

		data += tlv_length;
		length -= tlv_length;
	}

	return true;
}

static void *srv6_l3vpn_hash_alloc(void *p)
{
	return p;
}

static void srv6_l3vpn_free(struct bgp_attr_srv6_l3vpn *l3vpn)
{
	XFREE(MTYPE_BGP_SRV6_L3VPN, l3vpn);
}

static struct bgp_attr_srv6_l3vpn * srv6_l3vpn_intern(struct bgp_attr_srv6_l3vpn *l3vpn)
{
	struct bgp_attr_srv6_l3vpn *find;

	find = hash_get(srv6_l3vpn_hash, l3vpn, srv6_l3vpn_hash_alloc);
	if (find != l3vpn)
		srv6_l3vpn_free(l3vpn);
	find->refcnt++;
	return find;
}

static void srv6_l3vpn_unintern(struct bgp_attr_srv6_l3vpn **l3vpnp)
{
	struct bgp_attr_srv6_l3vpn *l3vpn = *l3vpnp;

	if (!*l3vpnp)
		return;

	if (l3vpn->refcnt)
		l3vpn->refcnt--;

	if (l3vpn->refcnt == 0) {
		hash_release(srv6_l3vpn_hash, l3vpn);
		srv6_l3vpn_free(l3vpn);
		*l3vpnp = NULL;
	}
}

static void *srv6_vpn_hash_alloc(void *p)
{
	return p;
}

static void srv6_vpn_free(struct bgp_attr_srv6_vpn *vpn)
{
	XFREE(MTYPE_BGP_SRV6_VPN, vpn);
}

static struct bgp_attr_srv6_vpn *srv6_vpn_intern(struct bgp_attr_srv6_vpn *vpn)
{
	struct bgp_attr_srv6_vpn *find;

	find = hash_get(srv6_vpn_hash, vpn, srv6_vpn_hash_alloc);
	if (find != vpn)
		srv6_vpn_free(vpn);
	find->refcnt++;
	return find;
}

static void srv6_vpn_unintern(struct bgp_attr_srv6_vpn **vpnp)
{
	struct bgp_attr_srv6_vpn *vpn = *vpnp;

	if (!*vpnp)
		return;

	if (vpn->refcnt)
		vpn->refcnt--;

	if (vpn->refcnt == 0) {
		hash_release(srv6_vpn_hash, vpn);
		srv6_vpn_free(vpn);
		*vpnp = NULL;
	}
}

static uint32_t srv6_l3vpn_hash_key_make(const void *p)
{
	const struct bgp_attr_srv6_l3vpn *l3vpn = p;
	uint32_t key = 0;

	key = jhash(&l3vpn->sid, 16, key);
	key = jhash_1word(l3vpn->sid_flags, key);
	key = jhash_1word(l3vpn->endpoint_behavior, key);
	key = jhash_1word(l3vpn->loc_block_len, key);
	key = jhash_1word(l3vpn->loc_node_len, key);
	key = jhash_1word(l3vpn->func_len, key);
	key = jhash_1word(l3vpn->arg_len, key);
	key = jhash_1word(l3vpn->transposition_len, key);
	key = jhash_1word(l3vpn->transposition_offset, key);
	return key;
}

static bool srv6_l3vpn_hash_cmp(const void *p1, const void *p2)
{
	const struct bgp_attr_srv6_l3vpn *l3vpn1 = p1;
	const struct bgp_attr_srv6_l3vpn *l3vpn2 = p2;

	return sid_same(&l3vpn1->sid, &l3vpn2->sid)
	       && l3vpn1->sid_flags == l3vpn2->sid_flags && l3vpn1->endpoint_behavior == l3vpn2->endpoint_behavior && l3vpn1->loc_block_len == l3vpn2->loc_block_len && l3vpn1->loc_node_len == l3vpn2->loc_node_len && l3vpn1->func_len == l3vpn2->func_len && l3vpn1->arg_len == l3vpn2->arg_len && l3vpn1->transposition_len == l3vpn2->transposition_len && l3vpn1->transposition_offset == l3vpn2->transposition_offset;






}

static bool srv6_l3vpn_same(const struct bgp_attr_srv6_l3vpn *h1, const struct bgp_attr_srv6_l3vpn *h2)
{
	if (h1 == h2)
		return true;
	else if (h1 == NULL || h2 == NULL)
		return false;
	else return srv6_l3vpn_hash_cmp((const void *)h1, (const void *)h2);
}

static unsigned int srv6_vpn_hash_key_make(const void *p)
{
	const struct bgp_attr_srv6_vpn *vpn = p;
	uint32_t key = 0;

	key = jhash(&vpn->sid, 16, key);
	key = jhash_1word(vpn->sid_flags, key);
	return key;
}

static bool srv6_vpn_hash_cmp(const void *p1, const void *p2)
{
	const struct bgp_attr_srv6_vpn *vpn1 = p1;
	const struct bgp_attr_srv6_vpn *vpn2 = p2;

	return sid_same(&vpn1->sid, &vpn2->sid)
	       && vpn1->sid_flags == vpn2->sid_flags;
}

static bool srv6_vpn_same(const struct bgp_attr_srv6_vpn *h1, const struct bgp_attr_srv6_vpn *h2)
{
	if (h1 == h2)
		return true;
	else if (h1 == NULL || h2 == NULL)
		return false;
	else return srv6_vpn_hash_cmp((const void *)h1, (const void *)h2);
}

static void srv6_init(void)
{
	srv6_l3vpn_hash = hash_create(srv6_l3vpn_hash_key_make, srv6_l3vpn_hash_cmp, "BGP Prefix-SID SRv6-L3VPN-Service-TLV");

	srv6_vpn_hash = hash_create(srv6_vpn_hash_key_make, srv6_vpn_hash_cmp, "BGP Prefix-SID SRv6-VPN-Service-TLV");
}

static void srv6_finish(void)
{
	hash_clean_and_free(&srv6_l3vpn_hash, (void (*)(void *))srv6_l3vpn_free);
	hash_clean_and_free(&srv6_vpn_hash, (void (*)(void *))srv6_vpn_free);
}

static unsigned int transit_hash_key_make(const void *p)
{
	const struct transit *transit = p;

	return jhash(transit->val, transit->length, 0);
}

static bool transit_hash_cmp(const void *p1, const void *p2)
{
	const struct transit *transit1 = p1;
	const struct transit *transit2 = p2;

	return (transit1->length == transit2->length && memcmp(transit1->val, transit2->val, transit1->length) == 0);
}

static void transit_init(void)
{
	transit_hash = hash_create(transit_hash_key_make, transit_hash_cmp, "BGP Transit Hash");
}

static void transit_finish(void)
{
	hash_clean_and_free(&transit_hash, (void (*)(void *))transit_free);
}


static struct hash *attrhash;

unsigned long int attr_count(void)
{
	return attrhash->count;
}

unsigned long int attr_unknown_count(void)
{
	return transit_hash->count;
}

unsigned int attrhash_key_make(const void *p)
{
	const struct attr *attr = (struct attr *)p;
	uint32_t key = 0;



	MIX3(attr->origin, attr->nexthop.s_addr, attr->med);
	MIX3(attr->local_pref, attr->aggregator_as, attr->aggregator_addr.s_addr);
	MIX3(attr->weight, attr->mp_nexthop_global_in.s_addr, attr->originator_id.s_addr);
	MIX3(attr->tag, attr->label, attr->label_index);

	if (attr->aspath)
		MIX(aspath_key_make(attr->aspath));
	if (bgp_attr_get_community(attr))
		MIX(community_hash_make(bgp_attr_get_community(attr)));
	if (bgp_attr_get_lcommunity(attr))
		MIX(lcommunity_hash_make(bgp_attr_get_lcommunity(attr)));
	if (bgp_attr_get_ecommunity(attr))
		MIX(ecommunity_hash_make(bgp_attr_get_ecommunity(attr)));
	if (bgp_attr_get_ipv6_ecommunity(attr))
		MIX(ecommunity_hash_make(bgp_attr_get_ipv6_ecommunity(attr)));
	if (bgp_attr_get_cluster(attr))
		MIX(cluster_hash_key_make(bgp_attr_get_cluster(attr)));
	if (bgp_attr_get_transit(attr))
		MIX(transit_hash_key_make(bgp_attr_get_transit(attr)));
	if (attr->encap_subtlvs)
		MIX(encap_hash_key_make(attr->encap_subtlvs));
	if (attr->srv6_l3vpn)
		MIX(srv6_l3vpn_hash_key_make(attr->srv6_l3vpn));
	if (attr->srv6_vpn)
		MIX(srv6_vpn_hash_key_make(attr->srv6_vpn));

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);
	if (vnc_subtlvs)
		MIX(encap_hash_key_make(vnc_subtlvs));

	MIX(attr->mp_nexthop_len);
	key = jhash(attr->mp_nexthop_global.s6_addr, IPV6_MAX_BYTELEN, key);
	key = jhash(attr->mp_nexthop_local.s6_addr, IPV6_MAX_BYTELEN, key);
	MIX3(attr->nh_ifindex, attr->nh_lla_ifindex, attr->distance);
	MIX(attr->rmap_table_id);
	MIX(attr->nh_type);
	MIX(attr->bh_type);
	MIX(attr->otc);
	MIX(bgp_attr_get_aigp_metric(attr));

	return key;
}

bool attrhash_cmp(const void *p1, const void *p2)
{
	const struct attr *attr1 = p1;
	const struct attr *attr2 = p2;

	if (attr1->flag == attr2->flag && attr1->origin == attr2->origin && attr1->nexthop.s_addr == attr2->nexthop.s_addr && attr1->aspath == attr2->aspath && bgp_attr_get_community(attr1)


				== bgp_attr_get_community(attr2)
		&& attr1->med == attr2->med && attr1->local_pref == attr2->local_pref && attr1->rmap_change_flags == attr2->rmap_change_flags) {

		if (attr1->aggregator_as == attr2->aggregator_as && attr1->aggregator_addr.s_addr == attr2->aggregator_addr.s_addr && attr1->weight == attr2->weight && attr1->tag == attr2->tag && attr1->label_index == attr2->label_index && attr1->mp_nexthop_len == attr2->mp_nexthop_len && bgp_attr_get_ecommunity(attr1) == bgp_attr_get_ecommunity(attr2) && bgp_attr_get_ipv6_ecommunity(attr1) == bgp_attr_get_ipv6_ecommunity(attr2) && bgp_attr_get_lcommunity(attr1) == bgp_attr_get_lcommunity(attr2) && bgp_attr_get_cluster(attr1) == bgp_attr_get_cluster(attr2) && bgp_attr_get_transit(attr1) == bgp_attr_get_transit(attr2) && bgp_attr_get_aigp_metric(attr1) == bgp_attr_get_aigp_metric(attr2) && attr1->rmap_table_id == attr2->rmap_table_id && (attr1->encap_tunneltype == attr2->encap_tunneltype) && encap_same(attr1->encap_subtlvs, attr2->encap_subtlvs)





















		    && encap_same(bgp_attr_get_vnc_subtlvs(attr1), bgp_attr_get_vnc_subtlvs(attr2))

		    && IPV6_ADDR_SAME(&attr1->mp_nexthop_global, &attr2->mp_nexthop_global) && IPV6_ADDR_SAME(&attr1->mp_nexthop_local, &attr2->mp_nexthop_local) && IPV4_ADDR_SAME(&attr1->mp_nexthop_global_in, &attr2->mp_nexthop_global_in) && IPV4_ADDR_SAME(&attr1->originator_id, &attr2->originator_id) && overlay_index_same(attr1, attr2) && !memcmp(&attr1->esi, &attr2->esi, sizeof(esi_t)) && attr1->es_flags == attr2->es_flags && attr1->mm_sync_seqnum == attr2->mm_sync_seqnum && attr1->df_pref == attr2->df_pref && attr1->df_alg == attr2->df_alg && attr1->nh_ifindex == attr2->nh_ifindex && attr1->nh_lla_ifindex == attr2->nh_lla_ifindex && attr1->distance == attr2->distance && srv6_l3vpn_same(attr1->srv6_l3vpn, attr2->srv6_l3vpn) && srv6_vpn_same(attr1->srv6_vpn, attr2->srv6_vpn) && attr1->srte_color == attr2->srte_color && attr1->nh_type == attr2->nh_type && attr1->bh_type == attr2->bh_type && attr1->otc == attr2->otc)





















			return true;
	}

	return false;
}

static void attrhash_init(void)
{
	attrhash = hash_create(attrhash_key_make, attrhash_cmp, "BGP Attributes");
}


static void attr_vfree(void *attr)
{
	XFREE(MTYPE_ATTR, attr);
}

static void attrhash_finish(void)
{
	hash_clean_and_free(&attrhash, attr_vfree);
}

static void attr_show_all_iterator(struct hash_bucket *bucket, struct vty *vty)
{
	struct attr *attr = bucket->data;
	struct in6_addr *sid = NULL;

	if (attr->srv6_l3vpn)
		sid = &attr->srv6_l3vpn->sid;
	else if (attr->srv6_vpn)
		sid = &attr->srv6_vpn->sid;

	vty_out(vty, "attr[%ld] nexthop %pI4\n", attr->refcnt, &attr->nexthop);

	vty_out(vty, "\tflags: %" PRIu64 " distance: %u med: %u local_pref: %u origin: %u weight: %u label: %u sid: %pI6\n", attr->flag, attr->distance, attr->med, attr->local_pref, attr->origin, attr->weight, attr->label, sid);



}

void attr_show_all(struct vty *vty)
{
	hash_iterate(attrhash, (void (*)(struct hash_bucket *, void *))attr_show_all_iterator, vty);

}

static void *bgp_attr_hash_alloc(void *p)
{
	struct attr *val = (struct attr *)p;
	struct attr *attr;

	attr = XMALLOC(MTYPE_ATTR, sizeof(struct attr));
	*attr = *val;
	if (val->encap_subtlvs) {
		val->encap_subtlvs = NULL;
	}

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(val);

	if (vnc_subtlvs)
		bgp_attr_set_vnc_subtlvs(val, NULL);


	attr->refcnt = 0;
	return attr;
}


struct attr *bgp_attr_intern(struct attr *attr)
{
	struct attr *find;
	struct ecommunity *ecomm = NULL;
	struct ecommunity *ipv6_ecomm = NULL;
	struct lcommunity *lcomm = NULL;
	struct community *comm = NULL;

	
	if (attr->aspath) {
		if (!attr->aspath->refcnt)
			attr->aspath = aspath_intern(attr->aspath);
		else attr->aspath->refcnt++;
	}

	comm = bgp_attr_get_community(attr);
	if (comm) {
		if (!comm->refcnt)
			bgp_attr_set_community(attr, community_intern(comm));
		else comm->refcnt++;
	}

	ecomm = bgp_attr_get_ecommunity(attr);
	if (ecomm) {
		if (!ecomm->refcnt)
			bgp_attr_set_ecommunity(attr, ecommunity_intern(ecomm));
		else ecomm->refcnt++;
	}

	ipv6_ecomm = bgp_attr_get_ipv6_ecommunity(attr);
	if (ipv6_ecomm) {
		if (!ipv6_ecomm->refcnt)
			bgp_attr_set_ipv6_ecommunity( attr, ecommunity_intern(ipv6_ecomm));
		else ipv6_ecomm->refcnt++;
	}

	lcomm = bgp_attr_get_lcommunity(attr);
	if (lcomm) {
		if (!lcomm->refcnt)
			bgp_attr_set_lcommunity(attr, lcommunity_intern(lcomm));
		else lcomm->refcnt++;
	}

	struct cluster_list *cluster = bgp_attr_get_cluster(attr);

	if (cluster) {
		if (!cluster->refcnt)
			bgp_attr_set_cluster(attr, cluster_intern(cluster));
		else cluster->refcnt++;
	}

	struct transit *transit = bgp_attr_get_transit(attr);

	if (transit) {
		if (!transit->refcnt)
			bgp_attr_set_transit(attr, transit_intern(transit));
		else transit->refcnt++;
	}
	if (attr->encap_subtlvs) {
		if (!attr->encap_subtlvs->refcnt)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);
		else attr->encap_subtlvs->refcnt++;
	}
	if (attr->srv6_l3vpn) {
		if (!attr->srv6_l3vpn->refcnt)
			attr->srv6_l3vpn = srv6_l3vpn_intern(attr->srv6_l3vpn);
		else attr->srv6_l3vpn->refcnt++;
	}
	if (attr->srv6_vpn) {
		if (!attr->srv6_vpn->refcnt)
			attr->srv6_vpn = srv6_vpn_intern(attr->srv6_vpn);
		else attr->srv6_vpn->refcnt++;
	}

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs) {
		if (!vnc_subtlvs->refcnt)
			bgp_attr_set_vnc_subtlvs( attr, encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));

		else vnc_subtlvs->refcnt++;
	}


	
	find = (struct attr *)hash_get(attrhash, attr, bgp_attr_hash_alloc);
	find->refcnt++;

	return find;
}


struct attr *bgp_attr_default_set(struct attr *attr, struct bgp *bgp, uint8_t origin)
{
	memset(attr, 0, sizeof(struct attr));

	attr->origin = origin;
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);
	attr->aspath = aspath_empty(bgp->asnotation);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);
	attr->weight = BGP_ATTR_DEFAULT_WEIGHT;
	attr->tag = 0;
	attr->label_index = BGP_INVALID_LABEL_INDEX;
	attr->label = MPLS_INVALID_LABEL;
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);
	attr->mp_nexthop_len = IPV6_MAX_BYTELEN;
	attr->local_pref = bgp->default_local_pref;

	return attr;
}


struct attr *bgp_attr_aggregate_intern( struct bgp *bgp, uint8_t origin, struct aspath *aspath, struct community *community, struct ecommunity *ecommunity, struct lcommunity *lcommunity, struct bgp_aggregate *aggregate, uint8_t atomic_aggregate, const struct prefix *p)



{
	struct attr attr;
	struct attr *new;
	route_map_result_t ret;

	memset(&attr, 0, sizeof(attr));

	
	attr.origin = origin;
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);

	
	attr.med = 0;
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);

	
	if (aspath)
		attr.aspath = aspath_intern(aspath);
	else attr.aspath = aspath_empty(bgp->asnotation);
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);

	if (community) {
		uint32_t gshut = COMMUNITY_GSHUT;

		
		if (!bgp_in_graceful_shutdown(bgp)
		    && community_include(community, gshut)) {
			community_del_val(community, &gshut);
		}

		bgp_attr_set_community(&attr, community);
	}

	if (ecommunity)
		bgp_attr_set_ecommunity(&attr, ecommunity);

	if (lcommunity)
		bgp_attr_set_lcommunity(&attr, lcommunity);

	if (bgp_in_graceful_shutdown(bgp))
		bgp_attr_add_gshut_community(&attr);

	attr.label_index = BGP_INVALID_LABEL_INDEX;
	attr.label = MPLS_INVALID_LABEL;
	attr.weight = BGP_ATTR_DEFAULT_WEIGHT;
	attr.mp_nexthop_len = IPV6_MAX_BYTELEN;
	if (!aggregate->as_set || atomic_aggregate)
		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);
	attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);
	if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))
		attr.aggregator_as = bgp->confed_id;
	else attr.aggregator_as = bgp->as;
	attr.aggregator_addr = bgp->router_id;

	
	if (p->family == AF_INET) {
		
		attr.flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);
		attr.mp_nexthop_len = IPV4_MAX_BYTELEN;
	}

	
	if (aggregate->rmap.name) {
		struct attr attr_tmp = attr;
		struct bgp_path_info rmap_path;

		memset(&rmap_path, 0, sizeof(rmap_path));
		rmap_path.peer = bgp->peer_self;
		rmap_path.attr = &attr_tmp;

		SET_FLAG(bgp->peer_self->rmap_type, PEER_RMAP_TYPE_AGGREGATE);

		ret = route_map_apply(aggregate->rmap.map, p, &rmap_path);

		bgp->peer_self->rmap_type = 0;

		if (ret == RMAP_DENYMATCH) {
			
			bgp_attr_flush(&attr_tmp);

			
			aspath_unintern(&attr.aspath);
			return NULL;
		}

		if (bgp_in_graceful_shutdown(bgp))
			bgp_attr_add_gshut_community(&attr_tmp);

		new = bgp_attr_intern(&attr_tmp);
	} else {

		if (bgp_in_graceful_shutdown(bgp))
			bgp_attr_add_gshut_community(&attr);

		new = bgp_attr_intern(&attr);
	}

	
	aspath_unintern(&attr.aspath);

	return new;
}


void bgp_attr_unintern_sub(struct attr *attr)
{
	struct ecommunity *ecomm = NULL;
	struct ecommunity *ipv6_ecomm = NULL;
	struct cluster_list *cluster;
	struct lcommunity *lcomm = NULL;
	struct community *comm = NULL;
	struct transit *transit;

	
	aspath_unintern(&attr->aspath);
	UNSET_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH));

	comm = bgp_attr_get_community(attr);
	community_unintern(&comm);
	bgp_attr_set_community(attr, NULL);

	ecomm = bgp_attr_get_ecommunity(attr);
	ecommunity_unintern(&ecomm);
	bgp_attr_set_ecommunity(attr, NULL);

	ipv6_ecomm = bgp_attr_get_ipv6_ecommunity(attr);
	ecommunity_unintern(&ipv6_ecomm);
	bgp_attr_set_ipv6_ecommunity(attr, NULL);

	lcomm = bgp_attr_get_lcommunity(attr);
	lcommunity_unintern(&lcomm);
	bgp_attr_set_lcommunity(attr, NULL);

	cluster = bgp_attr_get_cluster(attr);
	cluster_unintern(&cluster);
	bgp_attr_set_cluster(attr, NULL);

	transit = bgp_attr_get_transit(attr);
	transit_unintern(&transit);
	bgp_attr_set_transit(attr, NULL);

	encap_unintern(&attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);


	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

	encap_unintern(&vnc_subtlvs, VNC_SUBTLV_TYPE);
	bgp_attr_set_vnc_subtlvs(attr, NULL);


	srv6_l3vpn_unintern(&attr->srv6_l3vpn);
	srv6_vpn_unintern(&attr->srv6_vpn);
}


void bgp_attr_unintern(struct attr **pattr)
{
	struct attr *attr = *pattr;
	struct attr *ret;
	struct attr tmp;

	
	attr->refcnt--;

	tmp = *attr;

	
	if (attr->refcnt == 0) {
		ret = hash_release(attrhash, attr);
		assert(ret != NULL);
		XFREE(MTYPE_ATTR, attr);
		*pattr = NULL;
	}

	bgp_attr_unintern_sub(&tmp);
}

void bgp_attr_flush(struct attr *attr)
{
	struct ecommunity *ecomm;
	struct ecommunity *ipv6_ecomm;
	struct cluster_list *cluster;
	struct lcommunity *lcomm;
	struct community *comm;

	if (attr->aspath && !attr->aspath->refcnt) {
		aspath_free(attr->aspath);
		attr->aspath = NULL;
	}
	comm = bgp_attr_get_community(attr);
	if (comm && !comm->refcnt)
		community_free(&comm);
	bgp_attr_set_community(attr, NULL);

	ecomm = bgp_attr_get_ecommunity(attr);
	if (ecomm && !ecomm->refcnt)
		ecommunity_free(&ecomm);
	bgp_attr_set_ecommunity(attr, NULL);

	ipv6_ecomm = bgp_attr_get_ipv6_ecommunity(attr);
	if (ipv6_ecomm && !ipv6_ecomm->refcnt)
		ecommunity_free(&ipv6_ecomm);
	bgp_attr_set_ipv6_ecommunity(attr, NULL);

	lcomm = bgp_attr_get_lcommunity(attr);
	if (lcomm && !lcomm->refcnt)
		lcommunity_free(&lcomm);
	bgp_attr_set_lcommunity(attr, NULL);

	cluster = bgp_attr_get_cluster(attr);
	if (cluster && !cluster->refcnt) {
		cluster_free(cluster);
		bgp_attr_set_cluster(attr, NULL);
	}

	struct transit *transit = bgp_attr_get_transit(attr);

	if (transit && !transit->refcnt) {
		transit_free(transit);
		bgp_attr_set_transit(attr, NULL);
	}
	if (attr->encap_subtlvs && !attr->encap_subtlvs->refcnt) {
		encap_free(attr->encap_subtlvs);
		attr->encap_subtlvs = NULL;
	}
	if (attr->srv6_l3vpn && !attr->srv6_l3vpn->refcnt) {
		srv6_l3vpn_free(attr->srv6_l3vpn);
		attr->srv6_l3vpn = NULL;
	}
	if (attr->srv6_vpn && !attr->srv6_vpn->refcnt) {
		srv6_vpn_free(attr->srv6_vpn);
		attr->srv6_vpn = NULL;
	}

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs && !vnc_subtlvs->refcnt) {
		encap_free(vnc_subtlvs);
		bgp_attr_set_vnc_subtlvs(attr, NULL);
	}

}


static enum bgp_attr_parse_ret bgp_attr_malformed(struct bgp_attr_parser_args *args, uint8_t subcode, bgp_size_t length)

{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const uint8_t flags = args->flags;
	
	uint8_t *notify_datap = (length > 0 ? args->startp : NULL);

	if (bgp_debug_update(peer, NULL, NULL, 1)) {
		char attr_str[BUFSIZ] = {0};

		bgp_dump_attr(attr, attr_str, sizeof(attr_str));

		zlog_debug("%s: attributes: %s", __func__, attr_str);
	}

	
	if (peer->sort != BGP_PEER_EBGP) {
		bgp_notify_send_with_data(peer->connection, BGP_NOTIFY_UPDATE_ERR, subcode, notify_datap, length);

		return BGP_ATTR_PARSE_ERROR;
	}

	
	stream_set_getp(BGP_INPUT(peer), (args->startp - STREAM_DATA(BGP_INPUT(peer)))
				+ args->total);

	switch (args->type) {
	
	case BGP_ATTR_AS4_AGGREGATOR:
	case BGP_ATTR_AGGREGATOR:
	case BGP_ATTR_ATOMIC_AGGREGATE:
		return BGP_ATTR_PARSE_PROCEED;

	
	case BGP_ATTR_ORIGIN:
	case BGP_ATTR_AS_PATH:
	case BGP_ATTR_AS4_PATH:
	case BGP_ATTR_NEXT_HOP:
	case BGP_ATTR_MULTI_EXIT_DISC:
	case BGP_ATTR_LOCAL_PREF:
	case BGP_ATTR_COMMUNITIES:
	case BGP_ATTR_EXT_COMMUNITIES:
	case BGP_ATTR_IPV6_EXT_COMMUNITIES:
	case BGP_ATTR_LARGE_COMMUNITIES:
	case BGP_ATTR_ORIGINATOR_ID:
	case BGP_ATTR_CLUSTER_LIST:
	case BGP_ATTR_PMSI_TUNNEL:
	case BGP_ATTR_ENCAP:
	case BGP_ATTR_OTC:
		return BGP_ATTR_PARSE_WITHDRAW;
	case BGP_ATTR_MP_REACH_NLRI:
	case BGP_ATTR_MP_UNREACH_NLRI:
		bgp_notify_send_with_data(peer->connection, BGP_NOTIFY_UPDATE_ERR, subcode, notify_datap, length);

		return BGP_ATTR_PARSE_ERROR;
	}

	
	if (CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)
	    && CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)
	    && CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL))
		return BGP_ATTR_PARSE_WITHDRAW;

	
	return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
}


static void bgp_attr_flags_diagnose(struct bgp_attr_parser_args *args, uint8_t desired_flags )


{
	uint8_t seen = 0, i;
	uint8_t real_flags = args->flags;
	const uint8_t attr_code = args->type;

	desired_flags &= ~BGP_ATTR_FLAG_EXTLEN;
	real_flags &= ~BGP_ATTR_FLAG_EXTLEN;
	for (i = 0; i <= 2; i++) 
		if (CHECK_FLAG(desired_flags, attr_flag_str[i].key)
		    != CHECK_FLAG(real_flags, attr_flag_str[i].key)) {
			flog_err(EC_BGP_ATTR_FLAG, "%s attribute must%s be flagged as \"%s\"", lookup_msg(attr_str, attr_code, NULL), CHECK_FLAG(desired_flags, attr_flag_str[i].key)


					 ? "" : " not", attr_flag_str[i].str);

			seen = 1;
		}
	if (!seen) {
		zlog_debug( "Strange, %s called for attr %s, but no problem found with flags (real flags 0x%x, desired 0x%x)", __func__, lookup_msg(attr_str, attr_code, NULL), real_flags, desired_flags);


	}
}


const uint8_t attr_flags_values[] = {
	[BGP_ATTR_ORIGIN] = BGP_ATTR_FLAG_TRANS, [BGP_ATTR_AS_PATH] = BGP_ATTR_FLAG_TRANS, [BGP_ATTR_NEXT_HOP] = BGP_ATTR_FLAG_TRANS, [BGP_ATTR_MULTI_EXIT_DISC] = BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_LOCAL_PREF] = BGP_ATTR_FLAG_TRANS, [BGP_ATTR_ATOMIC_AGGREGATE] = BGP_ATTR_FLAG_TRANS, [BGP_ATTR_AGGREGATOR] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_COMMUNITIES] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_ORIGINATOR_ID] = BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_CLUSTER_LIST] = BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_MP_REACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_MP_UNREACH_NLRI] = BGP_ATTR_FLAG_OPTIONAL, [BGP_ATTR_EXT_COMMUNITIES] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_AS4_PATH] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_AS4_AGGREGATOR] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_PMSI_TUNNEL] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_LARGE_COMMUNITIES] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_OTC] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_PREFIX_SID] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_IPV6_EXT_COMMUNITIES] = BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS, [BGP_ATTR_AIGP] = BGP_ATTR_FLAG_OPTIONAL, };
























static const size_t attr_flags_values_max = array_size(attr_flags_values) - 1;

static bool bgp_attr_flag_invalid(struct bgp_attr_parser_args *args)
{
	uint8_t mask = BGP_ATTR_FLAG_EXTLEN;
	const uint8_t flags = args->flags;
	const uint8_t attr_code = args->type;

	
	if (attr_code > attr_flags_values_max)
		return false;
	if (attr_flags_values[attr_code] == 0)
		return false;

	
	if (!CHECK_FLAG(BGP_ATTR_FLAG_OPTIONAL, flags)
	    && !CHECK_FLAG(BGP_ATTR_FLAG_TRANS, flags)) {
		flog_err( EC_BGP_ATTR_FLAG, "%s well-known attributes must have transitive flag set (%x)", lookup_msg(attr_str, attr_code, NULL), flags);


		return true;
	}

	
	if (CHECK_FLAG(flags, BGP_ATTR_FLAG_PARTIAL)) {
		if (!CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)) {
			flog_err(EC_BGP_ATTR_FLAG, "%s well-known attribute must NOT have the partial flag set (%x)", lookup_msg(attr_str, attr_code, NULL), flags);

			return true;
		}
		if (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)
		    && !CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS)) {
			flog_err(EC_BGP_ATTR_FLAG, "%s optional + transitive attribute must NOT have the partial flag set (%x)", lookup_msg(attr_str, attr_code, NULL), flags);

			return true;
		}
	}

	
	if (CHECK_FLAG(flags, BGP_ATTR_FLAG_OPTIONAL)
	    && CHECK_FLAG(flags, BGP_ATTR_FLAG_TRANS))
		SET_FLAG(mask, BGP_ATTR_FLAG_PARTIAL);

	if ((flags & ~mask) == attr_flags_values[attr_code])
		return false;

	bgp_attr_flags_diagnose(args, attr_flags_values[attr_code]);
	return true;
}


static enum bgp_attr_parse_ret bgp_attr_origin(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length != 1) {
		flog_err(EC_BGP_ATTR_LEN, "Origin attribute length is not one %d", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	
	attr->origin = stream_getc(BGP_INPUT(peer));

	
	if ((attr->origin != BGP_ORIGIN_IGP) && (attr->origin != BGP_ORIGIN_EGP)
	    && (attr->origin != BGP_ORIGIN_INCOMPLETE)) {
		flog_err(EC_BGP_ATTR_ORIGIN, "Origin attribute value is invalid %d", attr->origin);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_INVAL_ORIGIN, args->total);
	}

	
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGIN);

	return 0;
}


static int bgp_attr_aspath(struct bgp_attr_parser_args *args)
{
	struct attr *const attr = args->attr;
	struct peer *const peer = args->peer;
	const bgp_size_t length = args->length;
	enum asnotation_mode asnotation;

	asnotation = bgp_get_asnotation( args->peer && args->peer->bgp ? args->peer->bgp : NULL);
	
	attr->aspath = aspath_parse(peer->curr, length, CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV) && CHECK_FLAG(peer->cap, PEER_CAP_AS4_ADV), asnotation);




	
	if (!attr->aspath) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "Malformed AS path from %s, length is %d", peer->host, length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);
	}

	
	if (peer->bgp && peer->bgp->reject_as_sets && aspath_check_as_sets(attr->aspath)) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "AS_SET and AS_CONFED_SET are deprecated from %pBP", peer);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);
	}

	
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS_PATH);

	return BGP_ATTR_PARSE_PROCEED;
}

static enum bgp_attr_parse_ret bgp_attr_aspath_check(struct peer *const peer, struct attr *const attr)
{
	
	struct aspath *aspath;

	
	(void)peer_sort(peer);

	
	if ((peer->sort == BGP_PEER_CONFED && !aspath_left_confed_check(attr->aspath))
	    || (peer->sort == BGP_PEER_EBGP && aspath_confed_check(attr->aspath))) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "Malformed AS path from %s", peer->host);
		return BGP_ATTR_PARSE_WITHDRAW;
	}

	
	if (CHECK_FLAG(peer->flags, PEER_FLAG_ENFORCE_FIRST_AS)) {
		if (peer->sort == BGP_PEER_EBGP && !aspath_firstas_check(attr->aspath, peer->as)) {
			flog_err(EC_BGP_ATTR_FIRST_AS, "%s incorrect first AS (must be %u)", peer->host, peer->as);

			return BGP_ATTR_PARSE_WITHDRAW;
		}
	}

	
	if (peer->sort == BGP_PEER_EBGP && aspath_check_as_zero(attr->aspath)) {
		flog_err( EC_BGP_ATTR_MAL_AS_PATH, "Malformed AS path, AS number is 0 in the path from %s", peer->host);


		return BGP_ATTR_PARSE_WITHDRAW;
	}

	
	if (peer->change_local_as && !CHECK_FLAG(peer->flags, PEER_FLAG_LOCAL_AS_NO_PREPEND)) {
		aspath = aspath_dup(attr->aspath);
		aspath = aspath_add_seq(aspath, peer->change_local_as);
		aspath_unintern(&attr->aspath);
		attr->aspath = aspath_intern(aspath);
	}

	return BGP_ATTR_PARSE_PROCEED;
}


static int bgp_attr_as4_path(struct bgp_attr_parser_args *args, struct aspath **as4_path)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	enum asnotation_mode asnotation;

	asnotation = bgp_get_asnotation(peer->bgp);

	*as4_path = aspath_parse(peer->curr, length, 1, asnotation);

	
	if (!*as4_path) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "Malformed AS4 path from %s, length is %d", peer->host, length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);
	}

	
	if (peer->bgp->reject_as_sets && aspath_check_as_sets(attr->aspath)) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "AS_SET and AS_CONFED_SET are deprecated from %pBP", peer);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);
	}

	
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH);

	return BGP_ATTR_PARSE_PROCEED;
}


enum bgp_attr_parse_ret bgp_attr_nexthop_valid(struct peer *peer, struct attr *attr)
{
	struct bgp *bgp = peer->bgp;

	if (ipv4_martian(&attr->nexthop) && !bgp->allow_martian) {
		uint8_t data[7]; 

		flog_err(EC_BGP_ATTR_MARTIAN_NH, "Martian nexthop %pI4", &attr->nexthop);
		data[0] = BGP_ATTR_FLAG_TRANS;
		data[1] = BGP_ATTR_NEXT_HOP;
		data[2] = BGP_ATTR_NHLEN_IPV4;
		memcpy(&data[3], &attr->nexthop.s_addr, BGP_ATTR_NHLEN_IPV4);
		bgp_notify_send_with_data(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, data, 7);


		return BGP_ATTR_PARSE_ERROR;
	}

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_nexthop(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN, "Nexthop attribute length isn't four [%d]", length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	attr->nexthop.s_addr = stream_get_ipv4(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP);

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_med(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN, "MED attribute length isn't four [%d]", length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	attr->med = stream_getl(peer->curr);

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC);

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if ((peer->sort == BGP_PEER_IBGP || peer->sub_sort == BGP_PEER_EBGP_OAD) && length != 4) {

		flog_err(EC_BGP_ATTR_LEN, "LOCAL_PREF attribute length isn't 4 [%u]", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	
	if (peer->sort == BGP_PEER_EBGP && peer->sub_sort != BGP_PEER_EBGP_OAD) {
		STREAM_FORWARD_GETP(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	STREAM_GETL(peer->curr, attr->local_pref);

	
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;

stream_failure:
	return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
}


static int bgp_attr_atomic(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length != 0) {
		flog_err(EC_BGP_ATTR_LEN, "ATOMIC_AGGREGATE attribute length isn't 0 [%u]", length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto atomic_ignore;

	
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE);

	return BGP_ATTR_PARSE_PROCEED;

atomic_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static int bgp_attr_aggregator(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	as_t aggregator_as;

	int wantedlen = 6;

	
	if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)
	    && CHECK_FLAG(peer->cap, PEER_CAP_AS4_ADV))
		wantedlen = 8;

	if (length != wantedlen) {
		flog_err(EC_BGP_ATTR_LEN, "AGGREGATOR attribute length isn't %u [%u]", wantedlen, length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto aggregator_ignore;

	if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV))
		aggregator_as = stream_getl(peer->curr);
	else aggregator_as = stream_getw(peer->curr);

	attr->aggregator_as = aggregator_as;
	attr->aggregator_addr.s_addr = stream_get_ipv4(peer->curr);

	
	if (aggregator_as == BGP_AS_ZERO) {
		flog_err(EC_BGP_ATTR_LEN, "%s: AGGREGATOR AS number is 0 for aspath: %s", peer->host, aspath_print(attr->aspath));


		if (bgp_debug_update(peer, NULL, NULL, 1)) {
			char attr_str[BUFSIZ] = {0};

			bgp_dump_attr(attr, attr_str, sizeof(attr_str));

			zlog_debug("%s: attributes: %s", __func__, attr_str);
		}
	} else {
		attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR);
	}

	return BGP_ATTR_PARSE_PROCEED;

aggregator_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_as4_aggregator(struct bgp_attr_parser_args *args, as_t *as4_aggregator_as, struct in_addr *as4_aggregator_addr)


{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	as_t aggregator_as;

	if (length != 8) {
		flog_err(EC_BGP_ATTR_LEN, "New Aggregator length is not 8 [%d]", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, 0);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto as4_aggregator_ignore;

	aggregator_as = stream_getl(peer->curr);

	*as4_aggregator_as = aggregator_as;
	as4_aggregator_addr->s_addr = stream_get_ipv4(peer->curr);

	
	if (aggregator_as == BGP_AS_ZERO) {
		flog_err(EC_BGP_ATTR_LEN, "%s: AS4_AGGREGATOR AS number is 0 for aspath: %s", peer->host, aspath_print(attr->aspath));


		if (bgp_debug_update(peer, NULL, NULL, 1)) {
			char attr_str[BUFSIZ] = {0};

			bgp_dump_attr(attr, attr_str, sizeof(attr_str));

			zlog_debug("%s: attributes: %s", __func__, attr_str);
		}
	} else {
		attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR);
	}

	return BGP_ATTR_PARSE_PROCEED;

as4_aggregator_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_munge_as4_attrs(struct peer *const peer, struct attr *const attr, struct aspath *as4_path, as_t as4_aggregator, struct in_addr *as4_aggregator_addr)


{
	int ignore_as4_path = 0;
	struct aspath *newpath;

	if (!attr->aspath) {
		
		return BGP_ATTR_PARSE_ERROR;
	}

	if (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) {
		
		if (BGP_DEBUG(as4, AS4)) {
			if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))
				zlog_debug("[AS4] %s %s AS4_PATH", peer->host, "AS4 capable peer, yet it sent");

			if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR)))
				zlog_debug("[AS4] %s %s AS4_AGGREGATOR", peer->host, "AS4 capable peer, yet it sent");

		}

		return BGP_ATTR_PARSE_PROCEED;
	}

	
	if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR))) {
		if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR))) {
			
			if (attr->aggregator_as != BGP_AS_TRANS) {
				
				if (BGP_DEBUG(as4, AS4))
					zlog_debug( "[AS4] %s BGP not AS4 capable peer send AGGREGATOR != AS_TRANS and AS4_AGGREGATOR, so ignore AS4_AGGREGATOR and AS4_PATH", peer->host);

				ignore_as4_path = 1;
			} else {
				
				attr->aggregator_as = as4_aggregator;
				attr->aggregator_addr.s_addr = as4_aggregator_addr->s_addr;
			}
		} else {
			
			if (BGP_DEBUG(as4, AS4))
				zlog_debug( "[AS4] %s BGP not AS4 capable peer send AS4_AGGREGATOR but no AGGREGATOR, will take it as if AGGREGATOR with AS_TRANS had been there", peer->host);

			attr->aggregator_as = as4_aggregator;
			
			attr->flag |= (ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR));
		}
	}

	
	if (!ignore_as4_path && (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))) {
		newpath = aspath_reconcile_as4(attr->aspath, as4_path);
		if (!newpath)
			return BGP_ATTR_PARSE_ERROR;

		aspath_unintern(&attr->aspath);
		attr->aspath = aspath_intern(newpath);
	}
	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_community(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	if (length == 0) {
		bgp_attr_set_community(attr, NULL);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto community_ignore;

	bgp_attr_set_community( attr, community_parse((uint32_t *)stream_pnt(peer->curr), length));


	
	stream_forward_getp(peer->curr, length);

	
	if (!bgp_attr_get_community(attr))
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

	return BGP_ATTR_PARSE_PROCEED;

community_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_originator_id(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN, "Bad originator ID length %d", length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto originator_id_ignore;

	attr->originator_id.s_addr = stream_get_ipv4(peer->curr);

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID);

	return BGP_ATTR_PARSE_PROCEED;

originator_id_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_cluster_list(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	
	if (length == 0 || length % 4) {
		flog_err(EC_BGP_ATTR_LEN, "Bad cluster list length %d", length);

		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto cluster_list_ignore;

	bgp_attr_set_cluster( attr, cluster_parse((struct in_addr *)stream_pnt(peer->curr), length));


	
	stream_forward_getp(peer->curr, length);

	return BGP_ATTR_PARSE_PROCEED;

cluster_list_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


uint32_t bgp_attr_get_color(struct attr *attr)
{
	if (attr->srte_color)
		return attr->srte_color;
	if (attr->ecommunity)
		return ecommunity_select_color(attr->ecommunity);
	return 0;
}


int bgp_mp_reach_parse(struct bgp_attr_parser_args *args, struct bgp_nlri *mp_update)
{
	iana_afi_t pkt_afi;
	afi_t afi;
	iana_safi_t pkt_safi;
	safi_t safi;
	bgp_size_t nlri_len;
	size_t start;
	struct stream *s;
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	s = BGP_INPUT(peer);
	start = stream_get_getp(s);




	if ((length > STREAM_READABLE(s)) || (length < BGP_MP_REACH_MIN_SIZE)) {
		zlog_info("%s: %s sent invalid length, %lu, of MP_REACH_NLRI", __func__, peer->host, (unsigned long)length);
		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
	}

	
	pkt_afi = stream_getw(s);
	pkt_safi = stream_getc(s);

	
	if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {
		
		if (bgp_debug_update(peer, NULL, NULL, 0))
			zlog_debug( "%s sent unrecognizable AFI, %s or, SAFI, %s, of MP_REACH_NLRI", peer->host, iana_afi2str(pkt_afi), iana_safi2str(pkt_safi));


		return BGP_ATTR_PARSE_ERROR;
	}

	
	attr->mp_nexthop_len = stream_getc(s);

	if (LEN_LEFT < attr->mp_nexthop_len) {
		zlog_info( "%s: %s sent next-hop length, %u, in MP_REACH_NLRI which goes past the end of attribute", __func__, peer->host, attr->mp_nexthop_len);

		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
	}

	
	switch (attr->mp_nexthop_len) {
	case 0:
		if (safi != SAFI_FLOWSPEC) {
			zlog_info("%s: %s sent wrong next-hop length, %d, in MP_REACH_NLRI", __func__, peer->host, attr->mp_nexthop_len);
			return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
		}
		break;
	case BGP_ATTR_NHLEN_VPNV4:
		stream_getl(s); 
		stream_getl(s); 
				
		fallthrough;
	case BGP_ATTR_NHLEN_IPV4:
		stream_get(&attr->mp_nexthop_global_in, s, IPV4_MAX_BYTELEN);
		
		if (attr->nexthop.s_addr == INADDR_ANY)
			memcpy(&attr->nexthop.s_addr, &attr->mp_nexthop_global_in, IPV4_MAX_BYTELEN);
		break;
	case BGP_ATTR_NHLEN_IPV6_GLOBAL:
	case BGP_ATTR_NHLEN_VPNV6_GLOBAL:
		if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL) {
			stream_getl(s); 
			stream_getl(s); 
		}
		stream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);
		if (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {
			if (!peer->nexthop.ifp) {
				zlog_warn("%s sent a v6 global attribute but address is a V6 LL and there's no peer interface information. Hence, withdrawing", peer->host);
				return BGP_ATTR_PARSE_WITHDRAW;
			}
			attr->nh_ifindex = peer->nexthop.ifp->ifindex;
		}
		break;
	case BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL:
	case BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL:
		if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {
			stream_getl(s); 
			stream_getl(s); 
		}
		stream_get(&attr->mp_nexthop_global, s, IPV6_MAX_BYTELEN);
		if (IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_global)) {
			if (!peer->nexthop.ifp) {
				zlog_warn("%s sent a v6 global and LL attribute but global address is a V6 LL and there's no peer interface information. Hence, withdrawing", peer->host);
				return BGP_ATTR_PARSE_WITHDRAW;
			}
			attr->nh_ifindex = peer->nexthop.ifp->ifindex;
		}
		if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {
			stream_getl(s); 
			stream_getl(s); 
		}
		stream_get(&attr->mp_nexthop_local, s, IPV6_MAX_BYTELEN);
		if (!IN6_IS_ADDR_LINKLOCAL(&attr->mp_nexthop_local)) {
			if (bgp_debug_update(peer, NULL, NULL, 1))
				zlog_debug( "%s sent next-hops %pI6 and %pI6. Ignoring non-LL value", peer->host, &attr->mp_nexthop_global, &attr->mp_nexthop_local);



			attr->mp_nexthop_len = IPV6_MAX_BYTELEN;
		}
		if (!peer->nexthop.ifp) {
			zlog_warn("%s sent a v6 LL next-hop and there's no peer interface information. Hence, withdrawing", peer->host);
			return BGP_ATTR_PARSE_WITHDRAW;
		}
		attr->nh_lla_ifindex = peer->nexthop.ifp->ifindex;
		break;
	default:
		zlog_info("%s: %s sent wrong next-hop length, %d, in MP_REACH_NLRI", __func__, peer->host, attr->mp_nexthop_len);
		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
	}

	if (!LEN_LEFT) {
		zlog_info("%s: %s sent SNPA which couldn't be read", __func__, peer->host);
		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
	}

	{
		uint8_t val;
		if ((val = stream_getc(s)))
			flog_warn( EC_BGP_DEFUNCT_SNPA_LEN, "%s sent non-zero value, %u, for defunct SNPA-length field", peer->host, val);


	}

	
	nlri_len = LEN_LEFT;
	if (nlri_len > STREAM_READABLE(s)) {
		zlog_info("%s: %s sent MP_REACH_NLRI which couldn't be read", __func__, peer->host);
		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;
	}

	if (!nlri_len) {
		zlog_info("%s: %s sent a zero-length NLRI. Hence, treating as a EOR marker", __func__, peer->host);

		mp_update->afi = afi;
		mp_update->safi = safi;
		return BGP_ATTR_PARSE_EOR;
	}

	mp_update->afi = afi;
	mp_update->safi = safi;
	mp_update->nlri = stream_pnt(s);
	mp_update->length = nlri_len;

	stream_forward_getp(s, nlri_len);

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI);

	return BGP_ATTR_PARSE_PROCEED;

}


int bgp_mp_unreach_parse(struct bgp_attr_parser_args *args, struct bgp_nlri *mp_withdraw)
{
	struct stream *s;
	iana_afi_t pkt_afi;
	afi_t afi;
	iana_safi_t pkt_safi;
	safi_t safi;
	uint16_t withdraw_len;
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	s = peer->curr;


	if ((length > STREAM_READABLE(s)) || (length < BGP_MP_UNREACH_MIN_SIZE))
		return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;

	pkt_afi = stream_getw(s);
	pkt_safi = stream_getc(s);

	
	if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) {
		
		if (bgp_debug_update(peer, NULL, NULL, 0))
			zlog_debug( "%s: MP_UNREACH received AFI %s or SAFI %s is unrecognized", peer->host, iana_afi2str(pkt_afi), iana_safi2str(pkt_safi));


		return BGP_ATTR_PARSE_ERROR;
	}

	withdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;

	mp_withdraw->afi = afi;
	mp_withdraw->safi = safi;
	mp_withdraw->nlri = stream_pnt(s);
	mp_withdraw->length = withdraw_len;

	stream_forward_getp(s, withdraw_len);

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI);

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_large_community(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length == 0) {
		bgp_attr_set_lcommunity(attr, NULL);
		
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto large_community_ignore;

	bgp_attr_set_lcommunity( attr, lcommunity_parse(stream_pnt(peer->curr), length));
	
	stream_forward_getp(peer->curr, length);

	if (!bgp_attr_get_lcommunity(attr))
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

	return BGP_ATTR_PARSE_PROCEED;

large_community_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_ext_communities(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	uint8_t sticky = 0;
	bool proxy = false;
	struct ecommunity *ecomm;

	if (length == 0) {
		bgp_attr_set_ecommunity(attr, NULL);
		
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	ecomm = ecommunity_parse( stream_pnt(peer->curr), length, CHECK_FLAG(peer->flags, PEER_FLAG_DISABLE_LINK_BW_ENCODING_IEEE));


	bgp_attr_set_ecommunity(attr, ecomm);
	
	stream_forward_getp(peer->curr, length);

	
	if (!bgp_attr_get_ecommunity(attr))
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

	
	attr->df_pref = bgp_attr_df_pref_from_ec(attr, &attr->df_alg);

	
	attr->mm_seqnum = bgp_attr_mac_mobility_seqnum(attr, &sticky);
	attr->sticky = sticky;

	
	attr->default_gw = bgp_attr_default_gw(attr);

	
	if (attr->default_gw)
		attr->router_flag = 1;

	
	bgp_attr_evpn_na_flag(attr, &attr->router_flag, &proxy);
	if (proxy)
		attr->es_flags |= ATTR_ES_PROXY_ADVERT;

	
	if (bgp_attr_rmac(attr, &attr->rmac)) {
		if (bgp_debug_update(peer, NULL, NULL, 1)
		    && bgp_mac_exist(&attr->rmac))
			zlog_debug("%s: router mac %pEA is self mac", __func__, &attr->rmac);
	}

	
	bgp_attr_extcom_tunnel_type(attr, (bgp_encap_types *)&attr->encap_tunneltype);

	
	(void)ecommunity_linkbw_present(bgp_attr_get_ecommunity(attr), &attr->link_bw);

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_ipv6_ext_communities(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	struct ecommunity *ipv6_ecomm = NULL;

	if (length == 0) {
		bgp_attr_set_ipv6_ecommunity(attr, ipv6_ecomm);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto ipv6_ext_community_ignore;

	ipv6_ecomm = ecommunity_parse_ipv6( stream_pnt(peer->curr), length, CHECK_FLAG(peer->flags, PEER_FLAG_DISABLE_LINK_BW_ENCODING_IEEE));


	bgp_attr_set_ipv6_ecommunity(attr, ipv6_ecomm);

	
	stream_forward_getp(peer->curr, length);

	if (!ipv6_ecomm)
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

	return BGP_ATTR_PARSE_PROCEED;

ipv6_ext_community_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static int bgp_attr_encap(struct bgp_attr_parser_args *args)
{
	uint16_t tunneltype = 0;
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	bgp_size_t length = args->length;
	uint8_t type = args->type;
	uint8_t flag = args->flags;

	if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)
	    || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {
		zlog_err("Tunnel Encap attribute flag isn't optional and transitive %d", flag);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	if (BGP_ATTR_ENCAP == type) {
		
		uint16_t tlv_length;

		if (length < 4) {
			zlog_err( "Tunnel Encap attribute not long enough to contain outer T,L");
			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

		}
		tunneltype = stream_getw(BGP_INPUT(peer));
		tlv_length = stream_getw(BGP_INPUT(peer));
		length -= 4;

		if (tlv_length != length) {
			zlog_info("%s: tlv_length(%d) != length(%d)", __func__, tlv_length, length);
		}
	}

	while (length >= 4) {
		uint16_t subtype = 0;
		uint16_t sublength = 0;
		struct bgp_attr_encap_subtlv *tlv;

		if (BGP_ATTR_ENCAP == type) {
			subtype = stream_getc(BGP_INPUT(peer));
			sublength = (subtype < 128)
					    ? stream_getc(BGP_INPUT(peer))
					    : stream_getw(BGP_INPUT(peer));
			length -= 2;

		} else {
			subtype = stream_getw(BGP_INPUT(peer));
			sublength = stream_getw(BGP_INPUT(peer));
			length -= 4;

		}

		if (sublength > length) {
			zlog_err("Tunnel Encap attribute sub-tlv length %d exceeds remaining length %d", sublength, length);
			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

		}

		
		
		tlv = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) + sublength);
		tlv->type = subtype;
		tlv->length = sublength;
		stream_get(tlv->value, peer->curr, sublength);
		length -= sublength;

		
		if (BGP_ATTR_ENCAP == type) {
			struct bgp_attr_encap_subtlv *stlv_last;
			for (stlv_last = attr->encap_subtlvs;
			     stlv_last && stlv_last->next;
			     stlv_last = stlv_last->next)
				;
			if (stlv_last) {
				stlv_last->next = tlv;
			} else {
				attr->encap_subtlvs = tlv;
			}

		} else {
			struct bgp_attr_encap_subtlv *stlv_last;
			struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

			for (stlv_last = vnc_subtlvs;
			     stlv_last && stlv_last->next;
			     stlv_last = stlv_last->next)
				;
			if (stlv_last)
				stlv_last->next = tlv;
			else bgp_attr_set_vnc_subtlvs(attr, tlv);

		}
	}

	if (BGP_ATTR_ENCAP == type) {
		attr->encap_tunneltype = tunneltype;
	}

	if (length) {
		
		zlog_err("Tunnel Encap attribute length is bad: %d leftover octets", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}

	return 0;
}



static enum bgp_attr_parse_ret bgp_attr_srv6_service_data(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	uint8_t type, loc_block_len, loc_node_len, func_len, arg_len, transposition_len, transposition_offset;
	uint16_t length;
	size_t headersz = sizeof(type) + sizeof(length);

	if (STREAM_READABLE(peer->curr) < headersz) {
		flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)", headersz, STREAM_READABLE(peer->curr));


		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	type = stream_getc(peer->curr);
	length = stream_getw(peer->curr);

	if (STREAM_READABLE(peer->curr) < length) {
		flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficent data (need %hu for attribute data, have %zu remaining in UPDATE)", length, STREAM_READABLE(peer->curr));


		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (length < BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH) {
		flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficient data (need %u, have %hu remaining in UPDATE)", BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH, length);



		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE) {
		if (STREAM_READABLE(peer->curr) < BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH) {
			flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Data Sub-Sub-TLV attribute - insufficient data (need %u, have %zu remaining in UPDATE)", BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH, STREAM_READABLE(peer->curr));



			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		loc_block_len = stream_getc(peer->curr);
		loc_node_len = stream_getc(peer->curr);
		func_len = stream_getc(peer->curr);
		arg_len = stream_getc(peer->curr);
		transposition_len = stream_getc(peer->curr);
		transposition_offset = stream_getc(peer->curr);

		
		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL)) {
			zlog_debug( "%s: srv6-l3-srv-data loc-block-len=%u, loc-node-len=%u func-len=%u, arg-len=%u, transposition-len=%u, transposition-offset=%u", __func__, loc_block_len, loc_node_len, func_len, arg_len, transposition_len, transposition_offset);



		}

		attr->srv6_l3vpn->loc_block_len = loc_block_len;
		attr->srv6_l3vpn->loc_node_len = loc_node_len;
		attr->srv6_l3vpn->func_len = func_len;
		attr->srv6_l3vpn->arg_len = arg_len;
		attr->srv6_l3vpn->transposition_len = transposition_len;
		attr->srv6_l3vpn->transposition_offset = transposition_offset;
	}

	else {
		if (bgp_debug_update(peer, NULL, NULL, 1))
			zlog_debug( "%s attr SRv6 Service Data Sub-Sub-TLV sub-sub-type=%u is not supported, skipped", peer->host, type);


		stream_forward_getp(peer->curr, length);
	}

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_srv6_service(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	struct in6_addr ipv6_sid;
	uint8_t type, sid_flags;
	uint16_t length, endpoint_behavior;
	size_t headersz = sizeof(type) + sizeof(length);
	enum bgp_attr_parse_ret err;

	if (STREAM_READABLE(peer->curr) < headersz) {
		flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)", headersz, STREAM_READABLE(peer->curr));


		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	type = stream_getc(peer->curr);
	length = stream_getw(peer->curr);

	if (STREAM_READABLE(peer->curr) < length) {
		flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %hu for attribute data, have %zu remaining in UPDATE)", length, STREAM_READABLE(peer->curr));


		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO) {
		if (STREAM_READABLE(peer->curr) < BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH) {
			flog_err( EC_BGP_ATTR_LEN, "Malformed SRv6 Service Sub-TLV attribute - insufficent data (need %d for attribute data, have %zu remaining in UPDATE)", BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH, STREAM_READABLE(peer->curr));



			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}
		stream_getc(peer->curr);
		stream_get(&ipv6_sid, peer->curr, sizeof(ipv6_sid));
		sid_flags = stream_getc(peer->curr);
		endpoint_behavior = stream_getw(peer->curr);
		stream_getc(peer->curr);

		
		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL))
			zlog_debug( "%s: srv6-l3-srv sid %pI6, sid-flags 0x%02x, end-behaviour 0x%04x", __func__, &ipv6_sid, sid_flags, endpoint_behavior);



		
		if (attr->srv6_l3vpn) {
			flog_err(EC_BGP_ATTRIBUTE_REPEATED, "Prefix SID SRv6 L3VPN field repeated");
			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_MAL_ATTR, args->total);
		}
		attr->srv6_l3vpn = XCALLOC(MTYPE_BGP_SRV6_L3VPN, sizeof(struct bgp_attr_srv6_l3vpn));
		sid_copy(&attr->srv6_l3vpn->sid, &ipv6_sid);
		attr->srv6_l3vpn->sid_flags = sid_flags;
		attr->srv6_l3vpn->endpoint_behavior = endpoint_behavior;
		attr->srv6_l3vpn->loc_block_len = 0;
		attr->srv6_l3vpn->loc_node_len = 0;
		attr->srv6_l3vpn->func_len = 0;
		attr->srv6_l3vpn->arg_len = 0;
		attr->srv6_l3vpn->transposition_len = 0;
		attr->srv6_l3vpn->transposition_offset = 0;

		
		if (length > BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH) {
			err = bgp_attr_srv6_service_data(args);

			if (err != BGP_ATTR_PARSE_PROCEED)
				return err;
		}

		attr->srv6_l3vpn = srv6_l3vpn_intern(attr->srv6_l3vpn);
	}

	
	else {
		if (bgp_debug_update(peer, NULL, NULL, 1))
			zlog_debug( "%s attr SRv6 Service Sub-TLV sub-type=%u is not supported, skipped", peer->host, type);


		stream_forward_getp(peer->curr, length);
	}

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_psid_sub(uint8_t type, uint16_t length, struct bgp_attr_parser_args *args)

{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	uint32_t label_index;
	struct in6_addr ipv6_sid;
	uint32_t srgb_base;
	uint32_t srgb_range;
	int srgb_count;
	uint8_t sid_type, sid_flags;

	
	if (STREAM_READABLE(peer->curr) < length) {
		flog_err( EC_BGP_ATTR_LEN, "Prefix SID specifies length %hu, but only %zu bytes remain", length, STREAM_READABLE(peer->curr));


		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (type == BGP_PREFIX_SID_LABEL_INDEX) {
		if (length != BGP_PREFIX_SID_LABEL_INDEX_LENGTH) {
			flog_err(EC_BGP_ATTR_LEN, "Prefix SID label index length is %hu instead of %u", length, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);

			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		
		stream_getc(peer->curr);
		stream_getw(peer->curr);

		
		label_index = stream_getl(peer->curr);
		if (label_index == BGP_INVALID_LABEL_INDEX)
			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);

		
		attr->label_index = label_index;
	} else if (type == BGP_PREFIX_SID_IPV6) {
		if (length != BGP_PREFIX_SID_IPV6_LENGTH) {
			flog_err(EC_BGP_ATTR_LEN, "Prefix SID IPv6 length is %hu instead of %u", length, BGP_PREFIX_SID_IPV6_LENGTH);

			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		
		stream_getc(peer->curr);
		stream_getw(peer->curr);

		stream_get(&ipv6_sid, peer->curr, 16);
	} else if (type == BGP_PREFIX_SID_ORIGINATOR_SRGB) {
		

		
		if (length < (2 + BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH)) {
			flog_err( EC_BGP_ATTR_LEN, "Prefix SID Originator SRGB length field claims length of %hu bytes, but the minimum for this TLV type is %u", length, 2 + BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH);



			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		
		stream_getw(peer->curr);
		length -= 2;
		if (length % BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH) {
			flog_err( EC_BGP_ATTR_LEN, "Prefix SID Originator SRGB length field claims attribute SRGB sequence section is %hubytes, but it must be a multiple of %u", length, BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH);


			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		srgb_count = length / BGP_PREFIX_SID_ORIGINATOR_SRGB_LENGTH;

		for (int i = 0; i < srgb_count; i++) {
			stream_get(&srgb_base, peer->curr, 3);
			stream_get(&srgb_range, peer->curr, 3);
		}
	} else if (type == BGP_PREFIX_SID_VPN_SID) {
		if (length != BGP_PREFIX_SID_VPN_SID_LENGTH) {
			flog_err(EC_BGP_ATTR_LEN, "Prefix SID VPN SID length is %hu instead of %u", length, BGP_PREFIX_SID_VPN_SID_LENGTH);

			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		
		stream_getc(peer->curr);               
		sid_type = stream_getc(peer->curr);    
		sid_flags = stream_getc(peer->curr);   
		stream_get(&ipv6_sid, peer->curr, sizeof(ipv6_sid));

		
		if (BGP_DEBUG(vpn, VPN_LEAK_LABEL))
			zlog_debug( "%s: vpn-sid: sid %pI6, sid-type 0x%02x sid-flags 0x%02x", __func__, &ipv6_sid, sid_type, sid_flags);


		
		if (attr->srv6_vpn) {
			flog_err(EC_BGP_ATTRIBUTE_REPEATED, "Prefix SID SRv6 VPN field repeated");
			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_MAL_ATTR, args->total);
		}
		attr->srv6_vpn = XCALLOC(MTYPE_BGP_SRV6_VPN, sizeof(struct bgp_attr_srv6_vpn));
		attr->srv6_vpn->sid_flags = sid_flags;
		sid_copy(&attr->srv6_vpn->sid, &ipv6_sid);
		attr->srv6_vpn = srv6_vpn_intern(attr->srv6_vpn);
	} else if (type == BGP_PREFIX_SID_SRV6_L3_SERVICE) {
		if (STREAM_READABLE(peer->curr) < 1) {
			flog_err( EC_BGP_ATTR_LEN, "Prefix SID SRV6 L3 Service not enough data left, it must be at least 1 byte");

			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}
		
		stream_getc(peer->curr);

		return bgp_attr_srv6_service(args);
	}
	
	else {
		if (bgp_debug_update(peer, NULL, NULL, 1))
			zlog_debug( "%s attr Prefix-SID sub-type=%u is not supported, skipped", peer->host, type);


		stream_forward_getp(peer->curr, length);
	}

	return BGP_ATTR_PARSE_PROCEED;
}


enum bgp_attr_parse_ret bgp_attr_prefix_sid(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	enum bgp_attr_parse_ret ret;

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID);

	uint8_t type;
	uint16_t length;
	size_t headersz = sizeof(type) + sizeof(length);
	size_t psid_parsed_length = 0;

	while (STREAM_READABLE(peer->curr) > 0 && psid_parsed_length < args->length) {

		if (STREAM_READABLE(peer->curr) < headersz) {
			flog_err( EC_BGP_ATTR_LEN, "Malformed Prefix SID attribute - insufficent data (need %zu for attribute header, have %zu remaining in UPDATE)", headersz, STREAM_READABLE(peer->curr));


			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		type = stream_getc(peer->curr);
		length = stream_getw(peer->curr);

		if (STREAM_READABLE(peer->curr) < length) {
			flog_err( EC_BGP_ATTR_LEN, "Malformed Prefix SID attribute - insufficient data (need %hu for attribute body, have %zu remaining in UPDATE)", length, STREAM_READABLE(peer->curr));


			return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}

		ret = bgp_attr_psid_sub(type, length, args);

		if (ret != BGP_ATTR_PARSE_PROCEED)
			return ret;

		psid_parsed_length += length + headersz;

		if (psid_parsed_length > args->length) {
			flog_err( EC_BGP_ATTR_LEN, "Malformed Prefix SID attribute - TLV overflow by attribute (need %zu for TLV length, have %zu overflowed in UPDATE)", length + headersz, psid_parsed_length - (length + headersz));


			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}
	}

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_pmsi_tunnel(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	uint8_t tnl_type;
	int attr_parse_len = 2 + BGP_LABEL_BYTES;

	
	if (length < attr_parse_len) {
		flog_err(EC_BGP_ATTR_LEN, "Bad PMSI tunnel attribute length %d", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}
	stream_getc(peer->curr); 
	tnl_type = stream_getc(peer->curr);
	if (tnl_type > PMSI_TNLTYPE_MAX) {
		flog_err(EC_BGP_ATTR_PMSI_TYPE, "Invalid PMSI tunnel attribute type %d", tnl_type);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, args->total);
	}
	if (tnl_type == PMSI_TNLTYPE_INGR_REPL) {
		if (length != 9) {
			flog_err(EC_BGP_ATTR_PMSI_LEN, "Bad PMSI tunnel attribute length %d for IR", length);

			return bgp_attr_malformed( args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);

		}
	}

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL);
	bgp_attr_set_pmsi_tnl_type(attr, tnl_type);
	stream_get(&attr->label, peer->curr, BGP_LABEL_BYTES);

	
	stream_forward_getp(peer->curr, length - attr_parse_len);

	return BGP_ATTR_PARSE_PROCEED;
}


static enum bgp_attr_parse_ret bgp_attr_aigp(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	uint8_t *s = stream_pnt(peer->curr);
	uint64_t aigp = 0;

	
	if (peer->sort == BGP_PEER_EBGP && (!CHECK_FLAG(peer->flags, PEER_FLAG_AIGP) || peer->sub_sort != BGP_PEER_EBGP_OAD)) {

		zlog_warn( "%pBP received AIGP attribute, but eBGP peer do not support it", peer);

		goto aigp_ignore;
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto aigp_ignore;

	if (!bgp_attr_aigp_valid(s, length))
		goto aigp_ignore;

	
	if (bgp_attr_aigp_get_tlv_metric(s, length, &aigp))
		bgp_attr_set_aigp_metric(attr, aigp);

aigp_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_otc(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN, "OTC attribute length isn't 4 [%u]", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, args->total);
	}

	if (peer->discard_attrs[args->type] || peer->withdraw_attrs[args->type])
		goto otc_ignore;

	attr->otc = stream_getl(peer->curr);
	if (!attr->otc) {
		flog_err(EC_BGP_ATTR_MAL_AS_PATH, "OTC attribute value is 0");
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, args->total);
	}

	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_OTC);

	return BGP_ATTR_PARSE_PROCEED;

otc_ignore:
	stream_forward_getp(peer->curr, length);

	return bgp_attr_ignore(peer, args->type);
}


static enum bgp_attr_parse_ret bgp_attr_unknown(struct bgp_attr_parser_args *args)
{
	bgp_size_t total = args->total;
	struct transit *transit;
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	uint8_t *const startp = args->startp;
	const uint8_t type = args->type;
	const uint8_t flag = args->flags;
	const bgp_size_t length = args->length;

	if (bgp_debug_update(peer, NULL, NULL, 1))
		zlog_debug( "%s Unknown attribute is received (type %d, length %d)", peer->host, type, length);


	
	stream_forward_getp(peer->curr, length);

	if (peer->discard_attrs[type] || peer->withdraw_attrs[type])
		return bgp_attr_ignore(peer, type);

	
	if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL)) {
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_UNREC_ATTR, args->total);
	}

	
	if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS))
		return BGP_ATTR_PARSE_PROCEED;

	
	SET_FLAG(*startp, BGP_ATTR_FLAG_PARTIAL);

	
	transit = bgp_attr_get_transit(attr);
	if (!transit)
		transit = XCALLOC(MTYPE_TRANSIT, sizeof(struct transit));

	transit->val = XREALLOC(MTYPE_TRANSIT_VAL, transit->val, transit->length + total);

	memcpy(transit->val + transit->length, startp, total);
	transit->length += total;
	bgp_attr_set_transit(attr, transit);

	return BGP_ATTR_PARSE_PROCEED;
}


static int bgp_attr_check(struct peer *peer, struct attr *attr)
{
	uint8_t type = 0;

	
	if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag)
		return BGP_ATTR_PARSE_PROCEED;

	
	if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) && CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI))))
		return BGP_ATTR_PARSE_PROCEED;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN)))
		type = BGP_ATTR_ORIGIN;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))
		type = BGP_ATTR_AS_PATH;

	
	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)))
		type = BGP_ATTR_NEXT_HOP;

	if (peer->sort == BGP_PEER_IBGP && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)))
		type = BGP_ATTR_LOCAL_PREF;

	
	if (type) {
		flog_warn(EC_BGP_MISSING_ATTRIBUTE, "%s Missing well-known attribute %s.", peer->host, lookup_msg(attr_str, type, NULL));

		return BGP_ATTR_PARSE_WITHDRAW;
	}
	return BGP_ATTR_PARSE_PROCEED;
}


enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr, bgp_size_t size, struct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw)


{
	enum bgp_attr_parse_ret ret;
	uint8_t flag = 0;
	uint8_t type = 0;
	bgp_size_t length;
	uint8_t *startp, *endp;
	uint8_t *attr_endp;
	uint8_t seen[BGP_ATTR_BITMAP_SIZE];
	
	
	struct aspath *as4_path = NULL;
	as_t as4_aggregator = 0;
	struct in_addr as4_aggregator_addr = {.s_addr = 0};
	struct transit *transit;

	
	memset(seen, 0, BGP_ATTR_BITMAP_SIZE);

	
	endp = BGP_INPUT_PNT(peer) + size;

	
	while (BGP_INPUT_PNT(peer) < endp) {
		startp = BGP_INPUT_PNT(peer);

		

		
		if ((endp - startp) < BGP_ATTR_MIN_LEN) {
			
			flog_warn( EC_BGP_ATTRIBUTE_TOO_SMALL, "%s: error BGP attribute length %lu is smaller than min len", peer->host, (unsigned long)(endp - stream_pnt(BGP_INPUT(peer))));





			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);

				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		
		flag = 0xF0 & stream_getc(BGP_INPUT(peer));
		type = stream_getc(BGP_INPUT(peer));

		
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)
		    && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) {
			flog_warn( EC_BGP_EXT_ATTRIBUTE_TOO_SMALL, "%s: Extended length set, but just %lu bytes of attr header", peer->host, (unsigned long)(endp - stream_pnt(BGP_INPUT(peer))));





			if (peer->sort != BGP_PEER_EBGP) {
				bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);

				ret = BGP_ATTR_PARSE_ERROR;
			} else {
				ret = BGP_ATTR_PARSE_WITHDRAW;
			}

			goto done;
		}

		
		if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN))
			length = stream_getw(BGP_INPUT(peer));
		else length = stream_getc(BGP_INPUT(peer));

		
		attr_endp = BGP_INPUT_PNT(peer) + length;

		if (attr_endp > endp) {
			flog_warn( EC_BGP_ATTRIBUTE_TOO_LARGE, "%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p", peer->host, type, length, size, attr_endp, endp);




			
			if (peer->sort != BGP_PEER_EBGP) {
				
				unsigned char ndata[peer->max_packet_size];

				memset(ndata, 0x00, sizeof(ndata));
				size_t lfl = CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1;
				
				stream_rewind_getp(BGP_INPUT(peer), (1 + lfl));
				
				stream_get(&ndata[0], BGP_INPUT(peer), 1);
				
				stream_get(&ndata[1], BGP_INPUT(peer), lfl);
				
				size_t atl = attr_endp - startp;
				size_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer)));

				stream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl);

				bgp_notify_send_with_data(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, ndata, ndl + lfl + 1);



				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				
				flog_warn( EC_BGP_ATTRIBUTE_PARSE_WITHDRAW, "%s: Attribute %s, parse error - treating as withdrawal", peer->host, lookup_msg(attr_str, type, NULL));


				ret = BGP_ATTR_PARSE_WITHDRAW;
				stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
				goto done;
			}
		}

		

		if (CHECK_BITMAP(seen, type)) {
			
			if (peer->sort != BGP_PEER_EBGP || type == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) {
				flog_warn( EC_BGP_ATTRIBUTE_REPEATED, "%s: error BGP attribute type %d appears twice in a message", peer->host, type);



				bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR);

				ret = BGP_ATTR_PARSE_ERROR;
				goto done;
			} else {
				flog_warn( EC_BGP_ATTRIBUTE_REPEATED, "%s: error BGP attribute type %d appears twice in a message - discard attribute", peer->host, type);


				
				stream_set_getp(BGP_INPUT(peer), (startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp));
				continue;
			}
		}

		

		SET_BITMAP(seen, type);

		struct bgp_attr_parser_args attr_args = {
			.peer = peer, .length = length, .attr = attr, .type = type, .flags = flag, .startp = startp, .total = attr_endp - startp, };








		
		if (bgp_attr_flag_invalid(&attr_args)) {
			ret = bgp_attr_malformed( &attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR, attr_args.total);

			if (ret == BGP_ATTR_PARSE_PROCEED)
				continue;
			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		
		switch (type) {
		case BGP_ATTR_ORIGIN:
			ret = bgp_attr_origin(&attr_args);
			break;
		case BGP_ATTR_AS_PATH:
			ret = bgp_attr_aspath(&attr_args);
			break;
		case BGP_ATTR_AS4_PATH:
			ret = bgp_attr_as4_path(&attr_args, &as4_path);
			break;
		case BGP_ATTR_NEXT_HOP:
			ret = bgp_attr_nexthop(&attr_args);
			break;
		case BGP_ATTR_MULTI_EXIT_DISC:
			ret = bgp_attr_med(&attr_args);
			break;
		case BGP_ATTR_LOCAL_PREF:
			ret = bgp_attr_local_pref(&attr_args);
			break;
		case BGP_ATTR_ATOMIC_AGGREGATE:
			ret = bgp_attr_atomic(&attr_args);
			break;
		case BGP_ATTR_AGGREGATOR:
			ret = bgp_attr_aggregator(&attr_args);
			break;
		case BGP_ATTR_AS4_AGGREGATOR:
			ret = bgp_attr_as4_aggregator(&attr_args, &as4_aggregator, &as4_aggregator_addr);

			break;
		case BGP_ATTR_COMMUNITIES:
			ret = bgp_attr_community(&attr_args);
			break;
		case BGP_ATTR_LARGE_COMMUNITIES:
			ret = bgp_attr_large_community(&attr_args);
			break;
		case BGP_ATTR_ORIGINATOR_ID:
			ret = bgp_attr_originator_id(&attr_args);
			break;
		case BGP_ATTR_CLUSTER_LIST:
			ret = bgp_attr_cluster_list(&attr_args);
			break;
		case BGP_ATTR_MP_REACH_NLRI:
			ret = bgp_mp_reach_parse(&attr_args, mp_update);
			break;
		case BGP_ATTR_MP_UNREACH_NLRI:
			ret = bgp_mp_unreach_parse(&attr_args, mp_withdraw);
			break;
		case BGP_ATTR_EXT_COMMUNITIES:
			ret = bgp_attr_ext_communities(&attr_args);
			break;

		case BGP_ATTR_VNC:

		case BGP_ATTR_ENCAP:
			ret = bgp_attr_encap(&attr_args);
			break;
		case BGP_ATTR_PREFIX_SID:
			ret = bgp_attr_prefix_sid(&attr_args);
			break;
		case BGP_ATTR_PMSI_TUNNEL:
			ret = bgp_attr_pmsi_tunnel(&attr_args);
			break;
		case BGP_ATTR_IPV6_EXT_COMMUNITIES:
			ret = bgp_attr_ipv6_ext_communities(&attr_args);
			break;
		case BGP_ATTR_OTC:
			ret = bgp_attr_otc(&attr_args);
			break;
		case BGP_ATTR_AIGP:
			ret = bgp_attr_aigp(&attr_args);
			break;
		default:
			ret = bgp_attr_unknown(&attr_args);
			break;
		}

		if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) {
			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}

		if (ret == BGP_ATTR_PARSE_EOR) {
			goto done;
		}

		if (ret == BGP_ATTR_PARSE_ERROR) {
			flog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR, "%s: Attribute %s, parse error", peer->host, lookup_msg(attr_str, type, NULL));

			goto done;
		}
		if (ret == BGP_ATTR_PARSE_WITHDRAW) {
			flog_warn( EC_BGP_ATTRIBUTE_PARSE_WITHDRAW, "%s: Attribute %s, parse error - treating as withdrawal", peer->host, lookup_msg(attr_str, type, NULL));


			stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer));
			goto done;
		}

		
		if (BGP_INPUT_PNT(peer) != attr_endp) {
			flog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR, "%s: BGP attribute %s, fetch error", peer->host, lookup_msg(attr_str, type, NULL));

			bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	
	if (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST)
		attr->label_index = BGP_INVALID_LABEL_INDEX;

	
	if (BGP_INPUT_PNT(peer) != endp) {
		flog_warn(EC_BGP_ATTRIBUTES_MISMATCH, "%s: BGP attribute %s, length mismatch", peer->host, lookup_msg(attr_str, type, NULL));

		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);

		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP))
	    && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) {
		if (bgp_attr_nexthop_valid(peer, attr) < 0) {
			ret = BGP_ATTR_PARSE_ERROR;
			goto done;
		}
	}

	
	ret = bgp_attr_check(peer, attr);
	if (ret < 0)
		goto done;

	
	
	if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))
	    && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator, &as4_aggregator_addr)) {
		bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR);
		ret = BGP_ATTR_PARSE_ERROR;
		goto done;
	}

	
	if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) {
		ret = bgp_attr_aspath_check(peer, attr);
		if (ret != BGP_ATTR_PARSE_PROCEED)
			goto done;
	}

	ret = BGP_ATTR_PARSE_PROCEED;
done:

	
	
	aspath_unintern(&as4_path);

	transit = bgp_attr_get_transit(attr);
	if (ret != BGP_ATTR_PARSE_ERROR) {
		
		if (transit)
			bgp_attr_set_transit(attr, transit_intern(transit));
		if (attr->encap_subtlvs)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE);

		struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

		if (vnc_subtlvs)
			bgp_attr_set_vnc_subtlvs( attr, encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));


	} else {
		if (transit) {
			transit_free(transit);
			bgp_attr_set_transit(attr, NULL);
		}

		bgp_attr_flush_encap(attr);
	};

	
	transit = bgp_attr_get_transit(attr);
	if (transit)
		assert(transit->refcnt > 0);
	if (attr->encap_subtlvs)
		assert(attr->encap_subtlvs->refcnt > 0);

	struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs)
		assert(vnc_subtlvs->refcnt > 0);


	return ret;
}


void bgp_attr_extcom_tunnel_type(struct attr *attr, bgp_encap_types *tunnel_type)
{
	struct ecommunity *ecom;
	uint32_t i;

	if (!attr)
		return;

	ecom = bgp_attr_get_ecommunity(attr);
	if (!ecom || !ecom->size)
		return;

	for (i = 0; i < ecom->size; i++) {
		uint8_t *pnt;
		uint8_t type, sub_type;

		pnt = (ecom->val + (i * ECOMMUNITY_SIZE));
		type = pnt[0];
		sub_type = pnt[1];
		if (!(type == ECOMMUNITY_ENCODE_OPAQUE && sub_type == ECOMMUNITY_OPAQUE_SUBTYPE_ENCAP))
			continue;
		*tunnel_type = ((pnt[6] << 8) | pnt[7]);
		return;
	}

	return;
}

size_t bgp_packet_mpattr_start(struct stream *s, struct peer *peer, afi_t afi, safi_t safi, struct bpacket_attr_vec_arr *vecarr, struct attr *attr)

{
	size_t sizep;
	iana_afi_t pkt_afi = IANA_AFI_IPV4;
	iana_safi_t pkt_safi = IANA_SAFI_UNICAST;
	afi_t nh_afi;

	
	stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);
	stream_putc(s, BGP_ATTR_MP_REACH_NLRI);
	sizep = stream_get_endp(s);
	stream_putw(s, 0); 


	
	bgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);

	stream_putw(s, pkt_afi);  
	stream_putc(s, pkt_safi); 

	
	if (afi == AFI_IP && (safi == SAFI_UNICAST || safi == SAFI_LABELED_UNICAST || safi == SAFI_MPLS_VPN || safi == SAFI_MULTICAST))

		nh_afi = peer_cap_enhe(peer, afi, safi) ? AFI_IP6 : AFI_IP;
	else if (safi == SAFI_FLOWSPEC)
		nh_afi = afi;
	else nh_afi = BGP_NEXTHOP_AFI_FROM_NHLEN(attr->mp_nexthop_len);

	
	bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr);
	switch (nh_afi) {
	case AFI_IP:
		switch (safi) {
		case SAFI_UNICAST:
		case SAFI_MULTICAST:
		case SAFI_LABELED_UNICAST:
			stream_putc(s, 4);
			stream_put_ipv4(s, attr->nexthop.s_addr);
			break;
		case SAFI_MPLS_VPN:
			stream_putc(s, 12);
			stream_putl(s, 0); 
			stream_putl(s, 0);
			stream_put(s, &attr->mp_nexthop_global_in, 4);
			break;
		case SAFI_ENCAP:
		case SAFI_EVPN:
			stream_putc(s, 4);
			stream_put(s, &attr->mp_nexthop_global_in, 4);
			break;
		case SAFI_FLOWSPEC:
			if (attr->mp_nexthop_len == 0)
				stream_putc(s, 0); 
			else {
				stream_putc(s, attr->mp_nexthop_len);
				stream_put_ipv4(s, attr->nexthop.s_addr);
			}
			break;
		case SAFI_UNSPEC:
		case SAFI_MAX:
			assert(!"SAFI's UNSPEC or MAX being specified are a DEV ESCAPE");
			break;
		}
		break;
	case AFI_IP6:
		switch (safi) {
		case SAFI_UNICAST:
		case SAFI_MULTICAST:
		case SAFI_LABELED_UNICAST:
		case SAFI_EVPN: {
			if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL) {
				stream_putc(s, BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL);
				stream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);
				stream_put(s, &attr->mp_nexthop_local, IPV6_MAX_BYTELEN);
			} else {
				stream_putc(s, IPV6_MAX_BYTELEN);
				stream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);
			}
		} break;
		case SAFI_MPLS_VPN: {
			if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL)
				stream_putc(s, attr->mp_nexthop_len);
			else stream_putc(s, BGP_ATTR_NHLEN_VPNV6_GLOBAL);
			stream_putl(s, 0); 
			stream_putl(s, 0);
			stream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);
			if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_VPNV6_GLOBAL_AND_LL) {
				stream_putl(s, 0); 
				stream_putl(s, 0);
				stream_put(s, &attr->mp_nexthop_local, IPV6_MAX_BYTELEN);
			}
		} break;
		case SAFI_ENCAP:
			stream_putc(s, IPV6_MAX_BYTELEN);
			stream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);
			break;
		case SAFI_FLOWSPEC:
			stream_putc(s, 0); 
			break;
		case SAFI_UNSPEC:
		case SAFI_MAX:
			assert(!"SAFI's UNSPEC or MAX being specified are a DEV ESCAPE");
			break;
		}
		break;
	case AFI_L2VPN:
		if (safi != SAFI_FLOWSPEC)
			flog_err( EC_BGP_ATTR_NH_SEND_LEN, "Bad nexthop when sending to %s, AFI %u SAFI %u nhlen %d", peer->host, afi, safi, attr->mp_nexthop_len);


		break;
	case AFI_UNSPEC:
	case AFI_MAX:
		assert(!"DEV ESCAPE: AFI_UNSPEC or AFI_MAX should not be used here");
		break;
	}

	
	stream_putc(s, 0);
	return sizep;
}

void bgp_packet_mpattr_prefix(struct stream *s, afi_t afi, safi_t safi, const struct prefix *p, const struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct attr *attr)



{
	switch (safi) {
	case SAFI_UNSPEC:
	case SAFI_MAX:
		assert(!"Dev escape usage of SAFI_UNSPEC or MAX");
		break;
	case SAFI_MPLS_VPN:
		if (addpath_capable)
			stream_putl(s, addpath_tx_id);
		
		stream_putc(s, p->prefixlen + 88);
		stream_put(s, label, BGP_LABEL_BYTES);
		stream_put(s, prd->val, 8);
		stream_put(s, &p->u.prefix, PSIZE(p->prefixlen));
		break;
	case SAFI_EVPN:
		if (afi == AFI_L2VPN)
			
			bgp_evpn_encode_prefix(s, p, prd, label, num_labels, attr, addpath_capable, addpath_tx_id);

		else assert(!"Add encoding bits here for other AFI's");
		break;
	case SAFI_LABELED_UNICAST:
		
		stream_put_labeled_prefix(s, p, label, addpath_capable, addpath_tx_id);
		break;
	case SAFI_FLOWSPEC:
		stream_putc(s, p->u.prefix_flowspec.prefixlen);
		stream_put(s, (const void *)p->u.prefix_flowspec.ptr, p->u.prefix_flowspec.prefixlen);
		break;

	case SAFI_UNICAST:
	case SAFI_MULTICAST:
		stream_put_prefix_addpath(s, p, addpath_capable, addpath_tx_id);
		break;
	case SAFI_ENCAP:
		assert(!"Please add proper encoding of SAFI_ENCAP");
		break;
	}
}

size_t bgp_packet_mpattr_prefix_size(afi_t afi, safi_t safi, const struct prefix *p)
{
	int size = PSIZE(p->prefixlen);

	switch (safi) {
	case SAFI_UNSPEC:
	case SAFI_MAX:
		assert(!"Attempting to figure size for a SAFI_UNSPEC/SAFI_MAX this is a DEV ESCAPE");
		break;
	case SAFI_UNICAST:
	case SAFI_MULTICAST:
		break;
	case SAFI_MPLS_VPN:
		size += 88;
		break;
	case SAFI_ENCAP:
		
		assert(!"Do we try to use this?");
		break;
	case SAFI_LABELED_UNICAST:
		size += BGP_LABEL_BYTES;
		break;
	case SAFI_EVPN:
		
		if (afi == AFI_L2VPN)
			size += 232;
		else assert(!"Attempting to figure size for SAFI_EVPN and !AFI_L2VPN and FRR will not have the proper values");
		break;
	case SAFI_FLOWSPEC:
		size = ((struct prefix_fs *)p)->prefix.prefixlen;
		break;
	}

	return size;
}


static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr, uint8_t attrtype)

{
	unsigned int attrlenfield = 0;
	unsigned int attrhdrlen = 0;
	struct bgp_attr_encap_subtlv *subtlvs;
	struct bgp_attr_encap_subtlv *st;
	const char *attrname;

	if (!attr || (attrtype == BGP_ATTR_ENCAP && (!attr->encap_tunneltype || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))

		return;

	switch (attrtype) {
	case BGP_ATTR_ENCAP:
		attrname = "Tunnel Encap";
		subtlvs = attr->encap_subtlvs;
		if (subtlvs == NULL) 
			return;
		
		attrlenfield = 2 + 2; 
		attrhdrlen = 1 + 1;   
		break;


	case BGP_ATTR_VNC:
		attrname = "VNC";
		subtlvs = bgp_attr_get_vnc_subtlvs(attr);
		if (subtlvs == NULL) 
			return;
		attrlenfield = 0;   
		attrhdrlen = 2 + 2; 
		break;


	default:
		assert(0);
	}

	
	for (st = subtlvs; st; st = st->next) {
		attrlenfield += (attrhdrlen + st->length);
	}

	if (attrlenfield > 0xffff) {
		zlog_info("%s attribute is too long (length=%d), can't send it", attrname, attrlenfield);
		return;
	}

	if (attrlenfield > 0xff) {
		
		stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);

		stream_putc(s, attrtype);
		stream_putw(s, attrlenfield & 0xffff);
	} else {
		
		stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, attrtype);
		stream_putc(s, attrlenfield & 0xff);
	}

	if (attrtype == BGP_ATTR_ENCAP) {
		
		stream_putw(s, attr->encap_tunneltype);
		stream_putw(s, attrlenfield - 4);
	}

	
	for (st = subtlvs; st; st = st->next) {
		if (attrtype == BGP_ATTR_ENCAP) {
			stream_putc(s, st->type);
			stream_putc(s, st->length);

		} else {
			stream_putw(s, st->type);
			stream_putw(s, st->length);

		}
		stream_put(s, st->value, st->length);
	}
}

void bgp_packet_mpattr_end(struct stream *s, size_t sizep)
{
	
	stream_putw_at(s, sizep, (stream_get_endp(s) - sizep) - 2);
}

static bool bgp_append_local_as(struct peer *peer, afi_t afi, safi_t safi)
{
	if (!BGP_AS_IS_PRIVATE(peer->local_as)
	    || (BGP_AS_IS_PRIVATE(peer->local_as)
		&& !CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS)
		&& !CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS_ALL)
		&& !CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS_REPLACE)
		&& !CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_REMOVE_PRIVATE_AS_ALL_REPLACE)))
		return true;
	return false;
}


bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr, struct bpacket_attr_vec_arr *vecarr, struct prefix *p, afi_t afi, safi_t safi, struct peer *from, struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct bgp_path_info *bpi)






{
	size_t cp;
	size_t aspath_sizep;
	struct aspath *aspath;
	int send_as4_path = 0;
	int send_as4_aggregator = 0;
	bool use32bit = CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)
			&& CHECK_FLAG(peer->cap, PEER_CAP_AS4_ADV);

	if (!bgp)
		bgp = peer->bgp;

	
	cp = stream_get_endp(s);

	if (p && !((afi == AFI_IP && safi == SAFI_UNICAST)
		 && !peer_cap_enhe(peer, afi, safi))) {
		size_t mpattrlen_pos = 0;

		mpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi, vecarr, attr);
		bgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels, addpath_capable, addpath_tx_id, attr);

		bgp_packet_mpattr_end(s, mpattrlen_pos);
	}

	
	stream_putc(s, BGP_ATTR_FLAG_TRANS);
	stream_putc(s, BGP_ATTR_ORIGIN);
	stream_putc(s, 1);
	stream_putc(s, attr->origin);

	

	
	if (peer->sort == BGP_PEER_EBGP && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)

		|| attr->aspath->segments == NULL)
	    && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))) {
		aspath = aspath_dup(attr->aspath);

		
		aspath = aspath_delete_confed_seq(aspath);

		if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {
			
			if (bgp_confederation_peers_check(bgp, peer->as)) {
				aspath = aspath_add_confed_seq(aspath, peer->local_as);
			} else {
				
				aspath = aspath_add_seq(aspath, bgp->confed_id);
			}
		} else {
			if (peer->change_local_as) {
				
				if (!CHECK_FLAG(peer->flags, PEER_FLAG_LOCAL_AS_REPLACE_AS))
					if (bgp_append_local_as(peer, afi, safi))
						aspath = aspath_add_seq( aspath, peer->local_as);
				aspath = aspath_add_seq(aspath, peer->change_local_as);
			} else {
				aspath = aspath_add_seq(aspath, peer->local_as);
			}
		}
	} else if (peer->sort == BGP_PEER_CONFED) {
		
		aspath = aspath_dup(attr->aspath);
		aspath = aspath_add_confed_seq(aspath, peer->local_as);
	} else aspath = attr->aspath;

	

	stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);
	stream_putc(s, BGP_ATTR_AS_PATH);
	aspath_sizep = stream_get_endp(s);
	stream_putw(s, 0);
	stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit));

	
	if (!use32bit && aspath_has_as4(aspath))
		send_as4_path = 1;

	
	if (afi == AFI_IP && safi == SAFI_UNICAST && !peer_cap_enhe(peer, afi, safi)) {
		afi_t nh_afi = BGP_NEXTHOP_AFI_FROM_NHLEN(attr->mp_nexthop_len);

		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) {
			stream_putc(s, BGP_ATTR_FLAG_TRANS);
			stream_putc(s, BGP_ATTR_NEXT_HOP);
			bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr);
			stream_putc(s, 4);
			stream_put_ipv4(s, attr->nexthop.s_addr);
		} else if (peer_cap_enhe(from, afi, safi)
			   || (nh_afi == AFI_IP6)) {
			
			stream_putc(s, BGP_ATTR_FLAG_TRANS);
			stream_putc(s, BGP_ATTR_NEXT_HOP);
			bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, NULL);
			stream_putc(s, 4);
			stream_put_ipv4(s, 0);
		}
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)
	    || bgp->maxmed_active) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);
		stream_putc(s, 4);
		stream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value : attr->med));
	}

	
	if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED || peer->sub_sort == BGP_PEER_EBGP_OAD) {
		stream_putc(s, BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_LOCAL_PREF);
		stream_putc(s, 4);
		stream_putl(s, attr->local_pref);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {
		stream_putc(s, BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);
		stream_putc(s, 0);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {
		
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_AGGREGATOR);

		if (use32bit) {
			
			stream_putc(s, 8);
			stream_putl(s, attr->aggregator_as);
		} else {
			
			stream_putc(s, 6);

			
			if (attr->aggregator_as > UINT16_MAX) {
				stream_putw(s, BGP_AS_TRANS);

				
				send_as4_aggregator = 1;
			} else stream_putw(s, (uint16_t)attr->aggregator_as);
		}
		stream_put_ipv4(s, attr->aggregator_addr.s_addr);
	}

	
	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) {
		struct community *comm = NULL;

		comm = bgp_attr_get_community(attr);
		if (comm->size * 4 > 255) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);

			stream_putc(s, BGP_ATTR_COMMUNITIES);
			stream_putw(s, comm->size * 4);
		} else {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

			stream_putc(s, BGP_ATTR_COMMUNITIES);
			stream_putc(s, comm->size * 4);
		}
		stream_put(s, comm->val, comm->size * 4);
	}

	
	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY)
	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) {
		if (lcom_length(bgp_attr_get_lcommunity(attr)) > 255) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);

			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
			stream_putw(s, lcom_length(bgp_attr_get_lcommunity(attr)));
		} else {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
			stream_putc(s, lcom_length(bgp_attr_get_lcommunity(attr)));
		}
		stream_put(s, bgp_attr_get_lcommunity(attr)->val, lcom_length(bgp_attr_get_lcommunity(attr)));
	}

	
	if (peer->sort == BGP_PEER_IBGP && from && from->sort == BGP_PEER_IBGP) {
		struct cluster_list *cluster = bgp_attr_get_cluster(attr);

		
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_ORIGINATOR_ID);
		stream_putc(s, 4);

		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
			stream_put_in_addr(s, &attr->originator_id);
		else stream_put_in_addr(s, &from->remote_id);

		
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_CLUSTER_LIST);

		if (cluster) {
			stream_putc(s, cluster->length + 4);
			
			if (bgp->config & BGP_CONFIG_CLUSTER_ID)
				stream_put_in_addr(s, &bgp->cluster_id);
			else stream_put_in_addr(s, &bgp->router_id);
			stream_put(s, cluster->list, cluster->length);
		} else {
			stream_putc(s, 4);
			
			if (bgp->config & BGP_CONFIG_CLUSTER_ID)
				stream_put_in_addr(s, &bgp->cluster_id);
			else stream_put_in_addr(s, &bgp->router_id);
		}
	}

	
	if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)
	    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) {
		struct ecommunity *ecomm = bgp_attr_get_ecommunity(attr);
		bool transparent = CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT) && from && CHECK_FLAG(from->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT);




		if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED || transparent) {
			if (ecomm->size * 8 > 255) {
				stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);


				stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
				stream_putw(s, ecomm->size * 8);
			} else {
				stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

				stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
				stream_putc(s, ecomm->size * 8);
			}
			stream_put(s, ecomm->val, ecomm->size * 8);
		} else {
			uint8_t *pnt;
			int tbit;
			int ecom_tr_size = 0;
			uint32_t i;

			for (i = 0; i < ecomm->size; i++) {
				pnt = ecomm->val + (i * 8);
				tbit = *pnt;

				if (CHECK_FLAG(tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))
					continue;

				ecom_tr_size++;
			}

			if (ecom_tr_size) {
				if (ecom_tr_size * 8 > 255) {
					stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);



					stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
					stream_putw(s, ecom_tr_size * 8);
				} else {
					stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);


					stream_putc(s, BGP_ATTR_EXT_COMMUNITIES);
					stream_putc(s, ecom_tr_size * 8);
				}

				for (i = 0; i < ecomm->size; i++) {
					pnt = ecomm->val + (i * 8);
					tbit = *pnt;

					if (CHECK_FLAG( tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))

						continue;

					stream_put(s, pnt, 8);
				}
			}
		}
	}

	
	if (safi == SAFI_LABELED_UNICAST) {
		if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {
			uint32_t label_index;

			label_index = attr->label_index;

			if (label_index != BGP_INVALID_LABEL_INDEX) {
				stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

				stream_putc(s, BGP_ATTR_PREFIX_SID);
				stream_putc(s, 10);
				stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);
				stream_putw(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);
				stream_putc(s, 0); 
				stream_putw(s, 0); 
				stream_putl(s, label_index);
			}
		}
	}

	
	if ((afi == AFI_IP || afi == AFI_IP6) && safi == SAFI_MPLS_VPN) {
		if (attr->srv6_l3vpn) {
			uint8_t subtlv_len = BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH + BGP_ATTR_MIN_LEN + BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO_LENGTH;


			uint8_t tlv_len = subtlv_len + BGP_ATTR_MIN_LEN + 1;
			uint8_t attr_len = tlv_len + BGP_ATTR_MIN_LEN;
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
			stream_putc(s, BGP_ATTR_PREFIX_SID);
			stream_putc(s, attr_len);
			stream_putc(s, BGP_PREFIX_SID_SRV6_L3_SERVICE);
			stream_putw(s, tlv_len);
			stream_putc(s, 0); 
			stream_putc(s, BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_INFO);
			stream_putw(s, subtlv_len);
			stream_putc(s, 0);      
			stream_put(s, &attr->srv6_l3vpn->sid, sizeof(attr->srv6_l3vpn->sid));
			stream_putc(s, 0);      
			stream_putw(s, attr->srv6_l3vpn ->endpoint_behavior);

			stream_putc(s, 0);      
			stream_putc( s, BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE);

			stream_putw( s, BGP_PREFIX_SID_SRV6_L3_SERVICE_SID_STRUCTURE_LENGTH);

			stream_putc(s, attr->srv6_l3vpn->loc_block_len);
			stream_putc(s, attr->srv6_l3vpn->loc_node_len);
			stream_putc(s, attr->srv6_l3vpn->func_len);
			stream_putc(s, attr->srv6_l3vpn->arg_len);
			stream_putc(s, attr->srv6_l3vpn->transposition_len);
			stream_putc(s, attr->srv6_l3vpn->transposition_offset);
		} else if (attr->srv6_vpn) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
			stream_putc(s, BGP_ATTR_PREFIX_SID);
			stream_putc(s, 22);     
			stream_putc(s, BGP_PREFIX_SID_VPN_SID);
			stream_putw(s, 0x13);   
			stream_putc(s, 0x00);   
			stream_putc(s, 0x01);   
			stream_putc(s, 0x00);   
			stream_put(s, &attr->srv6_vpn->sid, sizeof(attr->srv6_vpn->sid));
		}
	}

	if (send_as4_path) {
		
		

		

		
		if (aspath == attr->aspath)
			aspath = aspath_dup(attr->aspath);
		aspath = aspath_delete_confed_seq(aspath);

		stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);

		stream_putc(s, BGP_ATTR_AS4_PATH);
		aspath_sizep = stream_get_endp(s);
		stream_putw(s, 0);
		stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1));
	}

	if (aspath != attr->aspath)
		aspath_free(aspath);

	if (send_as4_aggregator) {
		
		
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_AS4_AGGREGATOR);
		stream_putc(s, 8);
		stream_putl(s, attr->aggregator_as);
		stream_put_ipv4(s, attr->aggregator_addr.s_addr);
	}

	if (((afi == AFI_IP || afi == AFI_IP6)
	     && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))
	    || (afi == AFI_L2VPN && safi == SAFI_EVPN)) {
		
		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);


		
		bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);

	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_PMSI_TUNNEL);
		stream_putc(s, 9); 
		stream_putc(s, 0); 
		stream_putc(s, bgp_attr_get_pmsi_tnl_type(attr));
		stream_put(s, &(attr->label), BGP_LABEL_BYTES);
		stream_put_ipv4(s, attr->nexthop.s_addr);
		
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_OTC)) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_OTC);
		stream_putc(s, 4);
		stream_putl(s, attr->otc);
	}

	
	if (bpi && attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AIGP) && (CHECK_FLAG(peer->flags, PEER_FLAG_AIGP) || peer->sub_sort == BGP_PEER_EBGP_OAD || peer->sort != BGP_PEER_EBGP)) {


		
		uint8_t attr_len = BGP_AIGP_TLV_METRIC_LEN;

		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_AIGP);
		stream_putc(s, attr_len);
		stream_put_bgp_aigp_tlv_metric(s, bpi);
	}

	
	struct transit *transit = bgp_attr_get_transit(attr);

	if (transit)
		stream_put(s, transit->val, transit->length);

	
	return stream_get_endp(s) - cp;
}

size_t bgp_packet_mpunreach_start(struct stream *s, afi_t afi, safi_t safi)
{
	unsigned long attrlen_pnt;
	iana_afi_t pkt_afi = IANA_AFI_IPV4;
	iana_safi_t pkt_safi = IANA_SAFI_UNICAST;

	
	stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN);
	stream_putc(s, BGP_ATTR_MP_UNREACH_NLRI);

	attrlen_pnt = stream_get_endp(s);
	stream_putw(s, 0); 

	
	bgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);

	stream_putw(s, pkt_afi);
	stream_putc(s, pkt_safi);

	return attrlen_pnt;
}

void bgp_packet_mpunreach_prefix(struct stream *s, const struct prefix *p, afi_t afi, safi_t safi, const struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, bool addpath_capable, uint32_t addpath_tx_id, struct attr *attr)




{
	uint8_t wlabel[4] = {0x80, 0x00, 0x00};

	if (safi == SAFI_LABELED_UNICAST) {
		label = (mpls_label_t *)wlabel;
		num_labels = 1;
	}

	bgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels, addpath_capable, addpath_tx_id, attr);
}

void bgp_packet_mpunreach_end(struct stream *s, size_t attrlen_pnt)
{
	bgp_packet_mpattr_end(s, attrlen_pnt);
}


void bgp_attr_init(void)
{
	aspath_init();
	attrhash_init();
	community_init();
	ecommunity_init();
	lcommunity_init();
	cluster_init();
	transit_init();
	encap_init();
	srv6_init();
}

void bgp_attr_finish(void)
{
	aspath_finish();
	attrhash_finish();
	community_finish();
	ecommunity_finish();
	lcommunity_finish();
	cluster_finish();
	transit_finish();
	encap_finish();
	srv6_finish();
}


void bgp_dump_routes_attr(struct stream *s, struct bgp_path_info *bpi, const struct prefix *prefix)
{
	unsigned long cp;
	unsigned long len;
	size_t aspath_lenp;
	struct aspath *aspath;
	bool addpath_capable = false;
	uint32_t addpath_tx_id = 0;
	struct attr *attr = bpi->attr;

	
	cp = stream_get_endp(s);

	
	stream_putw(s, 0);

	
	stream_putc(s, BGP_ATTR_FLAG_TRANS);
	stream_putc(s, BGP_ATTR_ORIGIN);
	stream_putc(s, 1);
	stream_putc(s, attr->origin);

	aspath = attr->aspath;

	stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);
	stream_putc(s, BGP_ATTR_AS_PATH);
	aspath_lenp = stream_get_endp(s);
	stream_putw(s, 0);

	stream_putw_at(s, aspath_lenp, aspath_put(s, aspath, 1));

	
	
	if (prefix != NULL && prefix->family != AF_INET6) {
		stream_putc(s, BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_NEXT_HOP);
		stream_putc(s, 4);
		stream_put_ipv4(s, attr->nexthop.s_addr);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);
		stream_putc(s, 4);
		stream_putl(s, attr->med);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF)) {
		stream_putc(s, BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_LOCAL_PREF);
		stream_putc(s, 4);
		stream_putl(s, attr->local_pref);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {
		stream_putc(s, BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);
		stream_putc(s, 0);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_AGGREGATOR);
		stream_putc(s, 8);
		stream_putl(s, attr->aggregator_as);
		stream_put_ipv4(s, attr->aggregator_addr.s_addr);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES)) {
		struct community *comm = NULL;

		comm = bgp_attr_get_community(attr);
		if (comm->size * 4 > 255) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);

			stream_putc(s, BGP_ATTR_COMMUNITIES);
			stream_putw(s, comm->size * 4);
		} else {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

			stream_putc(s, BGP_ATTR_COMMUNITIES);
			stream_putc(s, comm->size * 4);
		}
		stream_put(s, comm->val, comm->size * 4);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES)) {
		if (lcom_length(bgp_attr_get_lcommunity(attr)) > 255) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);

			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
			stream_putw(s, lcom_length(bgp_attr_get_lcommunity(attr)));
		} else {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

			stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);
			stream_putc(s, lcom_length(bgp_attr_get_lcommunity(attr)));
		}

		stream_put(s, bgp_attr_get_lcommunity(attr)->val, lcom_length(bgp_attr_get_lcommunity(attr)));
	}

	
	if (prefix != NULL && prefix->family == AF_INET6 && (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL || attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)) {

		int sizep;

		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);
		stream_putc(s, BGP_ATTR_MP_REACH_NLRI);
		sizep = stream_get_endp(s);

		
		stream_putc(s, 0);	    
		stream_putw(s, AFI_IP6);      
		stream_putc(s, SAFI_UNICAST); 

		
		stream_putc(s, attr->mp_nexthop_len);
		stream_put(s, &attr->mp_nexthop_global, IPV6_MAX_BYTELEN);
		if (attr->mp_nexthop_len == BGP_ATTR_NHLEN_IPV6_GLOBAL_AND_LL)
			stream_put(s, &attr->mp_nexthop_local, IPV6_MAX_BYTELEN);

		
		stream_putc(s, 0);

		
		stream_put_prefix_addpath(s, prefix, addpath_capable, addpath_tx_id);

		
		stream_putc_at(s, sizep, (stream_get_endp(s) - sizep) - 1);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {
		if (attr->label_index != BGP_INVALID_LABEL_INDEX) {
			stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);

			stream_putc(s, BGP_ATTR_PREFIX_SID);
			stream_putc(s, 10);
			stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);
			stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH);
			stream_putc(s, 0); 
			stream_putw(s, 0); 
			stream_putl(s, attr->label_index);
		}
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_OTC)) {
		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_OTC);
		stream_putc(s, 4);
		stream_putl(s, attr->otc);
	}

	
	if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AIGP)) {
		
		uint8_t attr_len = BGP_AIGP_TLV_METRIC_LEN;

		stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);
		stream_putc(s, BGP_ATTR_AIGP);
		stream_putc(s, attr_len);
		stream_put_bgp_aigp_tlv_metric(s, bpi);
	}

	
	len = stream_get_endp(s) - cp - 2;
	stream_putw_at(s, cp, len);
}

void bgp_path_attribute_discard_vty(struct vty *vty, struct peer *peer, const char *discard_attrs, bool set)
{
	int i, num_attributes;
	char **attributes;
	afi_t afi;
	safi_t safi;


	
	if (!discard_attrs) {
		for (i = 1; i <= BGP_ATTR_MAX; i++)
			peer->discard_attrs[i] = false;
		goto discard_soft_clear;
	}

	if (discard_attrs) {
		frrstr_split(discard_attrs, " ", &attributes, &num_attributes);

		if (set)
			for (i = 1; i <= BGP_ATTR_MAX; i++)
				peer->discard_attrs[i] = false;

		for (i = 0; i < num_attributes; i++) {
			uint8_t attr_num = strtoul(attributes[i], NULL, 10);

			XFREE(MTYPE_TMP, attributes[i]);

			
			if (attr_num == BGP_ATTR_ORIGIN || attr_num == BGP_ATTR_AS_PATH || attr_num == BGP_ATTR_NEXT_HOP || attr_num == BGP_ATTR_MULTI_EXIT_DISC || attr_num == BGP_ATTR_MP_REACH_NLRI || attr_num == BGP_ATTR_MP_UNREACH_NLRI || attr_num == BGP_ATTR_EXT_COMMUNITIES) {





				vty_out(vty, "%% Can't discard path-attribute %s, ignoring.\n", lookup_msg(attr_str, attr_num, NULL));

				continue;
			}

			
			if (peer->sort != BGP_PEER_EBGP && (attr_num == BGP_ATTR_LOCAL_PREF || attr_num == BGP_ATTR_ORIGINATOR_ID || attr_num == BGP_ATTR_CLUSTER_LIST)) {


				vty_out(vty, "%% Can discard path-attribute %s only for eBGP, ignoring.\n", lookup_msg(attr_str, attr_num, NULL));

				continue;
			}

			peer->discard_attrs[attr_num] = set;
		}
		XFREE(MTYPE_TMP, attributes);
	discard_soft_clear:
		
		FOREACH_AFI_SAFI (afi, safi)
			peer_clear_soft(peer, afi, safi, BGP_CLEAR_SOFT_IN);
	}
}

void bgp_path_attribute_withdraw_vty(struct vty *vty, struct peer *peer, const char *withdraw_attrs, bool set)
{
	int i, num_attributes;
	char **attributes;
	afi_t afi;
	safi_t safi;

	
	if (!withdraw_attrs) {
		for (i = 1; i <= BGP_ATTR_MAX; i++)
			peer->withdraw_attrs[i] = false;
		goto withdraw_soft_clear;
	}

	if (withdraw_attrs) {
		frrstr_split(withdraw_attrs, " ", &attributes, &num_attributes);

		if (set)
			for (i = 1; i <= BGP_ATTR_MAX; i++)
				peer->withdraw_attrs[i] = false;

		for (i = 0; i < num_attributes; i++) {
			uint8_t attr_num = strtoul(attributes[i], NULL, 10);

			XFREE(MTYPE_TMP, attributes[i]);

			
			if (attr_num == BGP_ATTR_ORIGIN || attr_num == BGP_ATTR_AS_PATH || attr_num == BGP_ATTR_NEXT_HOP || attr_num == BGP_ATTR_MULTI_EXIT_DISC || attr_num == BGP_ATTR_MP_REACH_NLRI || attr_num == BGP_ATTR_MP_UNREACH_NLRI || attr_num == BGP_ATTR_EXT_COMMUNITIES) {





				vty_out(vty, "%% Can't treat-as-withdraw path-attribute %s, ignoring.\n", lookup_msg(attr_str, attr_num, NULL));

				continue;
			}

			
			if (peer->sort != BGP_PEER_EBGP && (attr_num == BGP_ATTR_LOCAL_PREF || attr_num == BGP_ATTR_ORIGINATOR_ID || attr_num == BGP_ATTR_CLUSTER_LIST)) {


				vty_out(vty, "%% Can treat-as-withdraw path-attribute %s only for eBGP, ignoring.\n", lookup_msg(attr_str, attr_num, NULL));

				continue;
			}

			peer->withdraw_attrs[attr_num] = set;
		}
		XFREE(MTYPE_TMP, attributes);
	withdraw_soft_clear:
		
		FOREACH_AFI_SAFI (afi, safi)
			peer_clear_soft(peer, afi, safi, BGP_CLEAR_SOFT_IN);
	}
}

enum bgp_attr_parse_ret bgp_attr_ignore(struct peer *peer, uint8_t type)
{
	bool discard = peer->discard_attrs[type];
	bool withdraw = peer->withdraw_attrs[type];

	if (bgp_debug_update(peer, NULL, NULL, 1) && (discard || withdraw))
		zlog_debug("%pBP: Ignoring attribute %s (%s)", peer, lookup_msg(attr_str, type, NULL), withdraw ? "treat-as-withdraw" : "discard");


	return withdraw ? BGP_ATTR_PARSE_WITHDRAW : BGP_ATTR_PARSE_PROCEED;
}

bool route_matches_soo(struct bgp_path_info *pi, struct ecommunity *soo)
{
	struct attr *attr = pi->attr;
	struct ecommunity *ecom;

	if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES)))
		return false;

	ecom = attr->ecommunity;
	if (!ecom || !ecom->size)
		return false;

	return soo_in_ecom(ecom, soo);
}
