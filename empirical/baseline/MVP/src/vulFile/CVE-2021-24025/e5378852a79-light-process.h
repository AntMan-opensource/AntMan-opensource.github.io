



















namespace HPHP {



struct LightProcess {
  LightProcess();
  ~LightProcess();

  Mutex& mutex() { return m_procMutex; }

  static void Close();
  static bool Available();
  static void Initialize(const std::string &prefix, int count, bool trackProcessTimes, const std::vector<int> &inherited_fds);

  static void ChangeUser(const std::string &username);
  static void ChangeUser(int afdt, const std::string &username);

  typedef std::function<void(pid_t)> LostChildHandler;
  static void SetLostChildHandler(const LostChildHandler& handler);

  static FILE *popen(const char *cmd, const char *type, const char *cwd = nullptr);
  static int pclose(FILE *f);

  
  static pid_t ForkAndExecve( const std::string& path, const std::vector<std::string>& argv, const std::vector<std::string>& envp, const std::string& cwd, const std::map<int, int>& fds, int flags = Process::FORK_AND_EXECVE_FLAG_NONE, pid_t pgid = 0 );








  
  static pid_t proc_open(const char *cmd, const std::vector<int> &created, const std::vector<int> &desired, const char *cwd, const std::vector<std::string> &env);


  
  static pid_t waitpid(pid_t pid, int *stat_loc, int options, int timeout = 0);

  static pid_t pcntl_waitpid(pid_t pid, int *stat_loc, int options);

  
  static int createDelegate();

  static std::unique_ptr<LightProcess> setThreadLocalAfdtOverride(int fd);
  static std::unique_ptr<LightProcess> setThreadLocalAfdtOverride( std::unique_ptr<LightProcess> p );


private:
  static void SigChldHandler(int sig, siginfo_t* info, void* ctx);

  bool initShadow(int afdt_listen, const std::string& afdt_filename, int id, const std::vector<int> &inherited_fds);

  static void runShadow(int afdt_fd);
  void closeShadow();

  
  void closeFiles();

  static FILE *LightPopenImpl(const char *cmd, const char *type, const char *cwd);
  static FILE *HeavyPopenImpl(const char *cmd, const char *type, const char *cwd);

  pid_t m_shadowProcess;
  Mutex m_procMutex;
  int m_afdt_fd;
  std::map<FILE*, pid_t> m_popenMap;

 public:
  
  static bool g_strictUser;
};


}

