
















namespace HPHP {



struct APCString;
struct Array;
struct String;
struct APCHandle;
struct NamedEntity;




enum AttachStringMode { AttachString };




enum CopyStringMode { CopyString };


struct StringData final : MaybeCountable, type_scan::MarkCollectable<StringData> {
  friend struct APCString;
  friend StringData* allocFlat(size_t len);

  

  static constexpr uint32_t MaxSize = 0x80000000U - 16 - 1;

  static constexpr uint32_t MaxSize = 0x80000000U - 24 - 1;


  
  static StringData* Make();

  
  static StringData* Make(folly::StringPiece);

  static StringData* Make(const char* data, CopyStringMode);
  static StringData* Make(const char* data, size_t len, CopyStringMode);
  static StringData* Make(const StringData* s, CopyStringMode);
  static StringData* Make(folly::StringPiece r1, CopyStringMode);

  
  static StringData* Make(char* data, AttachStringMode);
  static StringData* Make(char* data, size_t len, AttachStringMode);

  
  static StringData* Make(const StringData* s1, const StringData* s2);
  static StringData* Make(const StringData* s1, folly::StringPiece s2);
  static StringData* Make(const StringData* s1, const char* lit2);
  static StringData* Make(folly::StringPiece s1, const char* lit2);
  static StringData* Make(folly::StringPiece s1, folly::StringPiece s2);
  static StringData* Make(folly::StringPiece s1, folly::StringPiece s2, folly::StringPiece s3);
  static StringData* Make(folly::StringPiece s1, folly::StringPiece s2, folly::StringPiece s3, folly::StringPiece s4);

  
  static StringData* Make(size_t reserve);

  
  static StringData* MakeProxy(const APCString* apcstr);

  
  static StringData* MakeStaticAt(folly::StringPiece, MemBlock);

  
  static StringData* MakeStatic(folly::StringPiece);

  
  static StringData* MakeUncounted(folly::StringPiece);

  
  static StringData* MakeEmpty();

  
  static size_t estimateCap(size_t size);

  

  static constexpr ptrdiff_t dataOff() { return offsetof(StringData, m_data); }

  static constexpr ptrdiff_t sizeOff() { return offsetof(StringData, m_len); }
  static constexpr ptrdiff_t hashOff() { return offsetof(StringData, m_hash); }

  
  static unsigned sweepAll();

  
  void release() noexcept;
  size_t heapSize() const;

  
  void destructStatic();

  
  static void ReleaseUncounted(const StringData*);

  
  ALWAYS_INLINE void decRefAndRelease() {
    assertx(kindIsValid());
    if (decReleaseCheck()) release();
  }

  bool kindIsValid() const { return m_kind == HeaderKind::String; }

  
  StringData* append(folly::StringPiece r);
  StringData* append(folly::StringPiece r1, folly::StringPiece r2);
  StringData* append(folly::StringPiece r1, folly::StringPiece r2, folly::StringPiece r3);


  
  StringData* reserve(size_t maxLen);

  
  StringData* shrink(size_t len);
  StringData* shrinkImpl(size_t len);

  
  folly::StringPiece slice() const;

  
  folly::MutableStringPiece bufferSlice();

  
  void invalidateHash();
  void setSize(int len);

  
  void checkStack() const;

  
  const char* data() const;

  
  char* mutableData() const;

  
  int size() const;

  
  bool empty() const;

  
  uint32_t capacity() const;

  
  DataType isNumericWithVal(int64_t&, double&, int allowErrors, int* overflow = nullptr) const;

  
  bool isNumeric() const;

  
  bool isInteger() const;

  
  bool isStrictlyInteger(int64_t& res) const;

  
  bool isZero() const;

  
  StringData* modifyChar(int offset, char c);

  
  StringData* getChar(int offset) const;

  
  StringData* increment();

  
  bool isSymbol() const;
  static void markSymbolsLoaded();

  
  Class* getCachedClass() const;
  NamedEntity* getNamedEntity() const;
  void setCachedClass(Class* cls);
  void setNamedEntity(NamedEntity* ne);

  
  static ptrdiff_t isSymbolOffset();
  static ptrdiff_t cachedClassOffset();

  
  bool toBoolean() const;
  char toByte(int base = 10) const { return toInt64(base); }
  short toInt16(int base = 10) const { return toInt64(base); }
  int toInt32(int base = 10) const { return toInt64(base); }
  int64_t toInt64(int base = 10) const;
  double toDouble() const;
  DataType toNumeric(int64_t& lval, double& dval) const;
  std::string toCppString() const;

  
  strhash_t hash() const;
  strhash_t hashStatic() const;
  NEVER_INLINE strhash_t hashHelper() const;
  static strhash_t hash(const char* s, size_t len);
  static strhash_t hash_unsafe(const char* s, size_t len);

  
  bool equal(const StringData* s) const;

  
  bool same(const StringData* s) const;

  
  bool isame(const StringData* s) const;

  
  int compare(const StringData* v2) const;

  
  StringData* substr(int start, int length = StringData::MaxSize);

  
  void dump() const;

  static StringData* node2str(StringDataNode* node) {
    return reinterpret_cast<StringData*>( uintptr_t(node) - offsetof(Proxy, node)
                   - sizeof(StringData)
    );
  }

  static constexpr bool isProxy() { return false; }

  bool isProxy() const;


  bool isImmutable() const;

  bool checkSane() const;

  void unProxy();

private:
  struct Proxy {
    StringDataNode node;
    const APCString* apcstr;
  };

private:
  template<bool trueStatic> static MemBlock AllocateShared(folly::StringPiece sl);
  template<bool trueStatic> static StringData* MakeSharedAt(folly::StringPiece sl, MemBlock range);

  StringData(const StringData&) = delete;
  StringData& operator=(const StringData&) = delete;
  ~StringData() = delete;

private:
  const void* payload() const;
  void* payload();
  const Proxy* proxy() const;
  Proxy* proxy();


  static constexpr bool isFlat() { return true; }

  bool isFlat() const;


  void releaseProxy();
  int numericCompare(const StringData *v2) const;
  StringData* escalate(size_t cap);
  void enlist();
  void delist();
  void incrementHelper();
  void preCompute();

  
  
  
private:

  
  char* m_data;

  union {
    struct {
      uint32_t m_len;
      mutable int32_t m_hash;           
    };
    uint64_t m_lenAndHash;
  };
};


struct SymbolPrefix {
  AtomicLowPtr<NamedEntity> ne;
  AtomicLowPtr<Class> cls;
};

static_assert(sizeof(SymbolPrefix) % alignof(StringData) == 0, "");




auto constexpr kStringOverhead = sizeof(StringData) + 1;
static_assert(StringData::MaxSize + kStringOverhead == kSizeIndex2Size[103], "max allocation size is a valid size class");


constexpr uint32_t SmallStringReserve = 64 - kStringOverhead;


inline constexpr uint32_t sizeClassParams2StringCapacity( size_t lg_grp, size_t lg_delta, size_t ndelta ) {



  return ((size_t{1} << lg_grp) + (ndelta << lg_delta)) > kStringOverhead && ((size_t{1} << lg_grp) + (ndelta << lg_delta))
        <= StringData::MaxSize + kStringOverhead ? ((size_t{1} << lg_grp) + (ndelta << lg_delta)) - kStringOverhead : 0;

}

alignas(64) constexpr uint32_t kSizeIndex2StringCapacity[] = {

  SIZE_CLASSES  };



void raiseStringLengthExceededError(size_t len);


void decRefStr(StringData* s);




struct string_data_hash;
struct string_data_same;
struct string_data_isame;
struct string_data_lt;
struct string_data_lti;



extern std::aligned_storage< kStringOverhead, alignof(StringData)

>::type s_theEmptyString;


ALWAYS_INLINE StringData* staticEmptyString() {
  void* vp = &s_theEmptyString;
  return static_cast<StringData*>(vp);
}



}

namespace folly {
template<> class FormatValue<const HPHP::StringData*> {
 public:
  explicit FormatValue(const HPHP::StringData* str) : m_val(str) {}

  template<typename Callback> void format(FormatArg& arg, Callback& cb) const {
    auto piece = folly::StringPiece(m_val->data(), m_val->size());
    format_value::formatString(piece, arg, cb);
  }

 private:
  const HPHP::StringData* m_val;
};

template<> class FormatValue<HPHP::StringData*> {
 public:
  explicit FormatValue(const HPHP::StringData* str) : m_val(str) {}

  template<typename Callback> void format(FormatArg& arg, Callback& cb) const {
    FormatValue<const HPHP::StringData*>(m_val).format(arg, cb);
  }

 private:
  const HPHP::StringData* m_val;
};
}



