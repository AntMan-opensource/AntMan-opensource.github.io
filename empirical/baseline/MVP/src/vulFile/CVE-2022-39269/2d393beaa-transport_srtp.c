




































































































static const pj_str_t ID_RTP_AVP  = { "RTP/AVP", 7 };
static const pj_str_t ID_RTP_SAVP = { "RTP/SAVP", 8 };

static const pj_str_t ID_CRYPTO   = { "crypto", 6 };

typedef void (*crypto_method_t)(srtp_crypto_policy_t *policy);

typedef struct crypto_suite {
    char		*name;
    srtp_cipher_type_id_t cipher_type;
    unsigned		 cipher_key_len;    
    unsigned		 cipher_salt_len;   
    srtp_auth_type_id_t	 auth_type;
    unsigned		 auth_key_len;
    unsigned		 srtp_auth_tag_len;
    unsigned		 srtcp_auth_tag_len;
    srtp_sec_serv_t	 service;
    
    srtp_cipher_type_t  *ext_cipher_type;
    crypto_method_t      ext_crypto_method;
} crypto_suite;

extern srtp_cipher_type_t srtp_aes_gcm_256_openssl;
extern srtp_cipher_type_t srtp_aes_gcm_128_openssl;
extern srtp_cipher_type_t srtp_aes_icm_192;


static crypto_suite crypto_suites[] = {
    
    {"NULL", SRTP_NULL_CIPHER, 0, SRTP_NULL_AUTH, 0, 0, 0, sec_serv_none},     {"AEAD_AES_256_GCM", SRTP_AES_GCM_256, 44, 12, SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth, &srtp_aes_gcm_256_openssl},   {"AEAD_AES_256_GCM_8", SRTP_AES_GCM_256, 44, 12, SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth, &srtp_aes_gcm_256_openssl},     {"AES_256_CM_HMAC_SHA1_80", SRTP_AES_ICM_256, 46, 14, SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth, NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80},   {"AES_256_CM_HMAC_SHA1_32", SRTP_AES_ICM_256, 46, 14, SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth, NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32},     {"AES_192_CM_HMAC_SHA1_80", SRTP_AES_ICM_192, 38, 14, SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth, &srtp_aes_icm_192},   {"AES_192_CM_HMAC_SHA1_32", SRTP_AES_ICM_192, 38, 14, SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth, &srtp_aes_icm_192},     {"AEAD_AES_128_GCM", SRTP_AES_GCM_128, 28, 12, SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth, &srtp_aes_gcm_128_openssl},   {"AEAD_AES_128_GCM_8", SRTP_AES_GCM_128, 28, 12, SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth, &srtp_aes_gcm_128_openssl},     {"AES_CM_128_HMAC_SHA1_80", SRTP_AES_ICM_128, 30, 14, SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth},   {"AES_CM_128_HMAC_SHA1_32", SRTP_AES_ICM_128, 30, 14, SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth},    };
































































typedef struct transport_srtp {
    pjmedia_transport	 base;		    
    pj_pool_t		*pool;		    
    pj_lock_t		*mutex;		    
    char		 rtp_tx_buffer[MAX_RTP_BUFFER_LEN];
    char		 rtcp_tx_buffer[MAX_RTCP_BUFFER_LEN];
    pjmedia_srtp_setting setting;
    unsigned		 media_option;
    pj_bool_t		 use_rtcp_mux;	    

    
    pj_bool_t		 session_inited;
    pj_bool_t		 offerer_side;
    pj_bool_t		 bypass_srtp;
    char		 tx_key[MAX_KEY_LEN];
    char		 rx_key[MAX_KEY_LEN];
    pjmedia_srtp_crypto  tx_policy;
    pjmedia_srtp_crypto  rx_policy;

    
    pjmedia_srtp_crypto  tx_policy_neg;
    pjmedia_srtp_crypto  rx_policy_neg;

    
    srtp_t		 srtp_tx_ctx;
    srtp_t		 srtp_rx_ctx;

    
    void		*user_data;
    void		(*rtp_cb)( void *user_data, void *pkt, pj_ssize_t size);

    void  		(*rtp_cb2)(pjmedia_tp_cb_param*);
    void		(*rtcp_cb)(void *user_data, void *pkt, pj_ssize_t size);


    
    pjmedia_transport	*member_tp; 
    pj_bool_t		 member_tp_attached;
    pj_bool_t		 started;

    
    pjmedia_srtp_use	 peer_use;

    
    unsigned		 probation_cnt;

    
    unsigned		 all_keying_cnt;
    pjmedia_transport	*all_keying[MAX_KEYING];

    
    unsigned		 keying_cnt;
    pjmedia_transport	*keying[MAX_KEYING];

    
    unsigned		 keying_pending_cnt;

    
    pj_uint32_t		 rx_ssrc;

    pj_uint32_t		 tx_ssrc;

} transport_srtp;



static void srtp_rtp_cb(pjmedia_tp_cb_param *param);


static void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size);



static pj_status_t transport_get_info (pjmedia_transport *tp, pjmedia_transport_info *info);











static void	   transport_detach   (pjmedia_transport *tp, void *strm);
static pj_status_t transport_send_rtp( pjmedia_transport *tp, const void *pkt, pj_size_t size);

static pj_status_t transport_send_rtcp(pjmedia_transport *tp, const void *pkt, pj_size_t size);

static pj_status_t transport_send_rtcp2(pjmedia_transport *tp, const pj_sockaddr_t *addr, unsigned addr_len, const void *pkt, pj_size_t size);



static pj_status_t transport_media_create(pjmedia_transport *tp, pj_pool_t *sdp_pool, unsigned options, const pjmedia_sdp_session *sdp_remote, unsigned media_index);



static pj_status_t transport_encode_sdp(pjmedia_transport *tp, pj_pool_t *sdp_pool, pjmedia_sdp_session *sdp_local, const pjmedia_sdp_session *sdp_remote, unsigned media_index);



static pj_status_t transport_media_start (pjmedia_transport *tp, pj_pool_t *pool, const pjmedia_sdp_session *sdp_local, const pjmedia_sdp_session *sdp_remote, unsigned media_index);



static pj_status_t transport_media_stop(pjmedia_transport *tp);
static pj_status_t transport_simulate_lost(pjmedia_transport *tp, pjmedia_dir dir, unsigned pct_lost);

static pj_status_t transport_destroy  (pjmedia_transport *tp);
static pj_status_t transport_attach2  (pjmedia_transport *tp, pjmedia_transport_attach_param *param);



static pjmedia_transport_op transport_srtp_op = {
    &transport_get_info, NULL, &transport_detach, &transport_send_rtp, &transport_send_rtcp, &transport_send_rtcp2, &transport_media_create, &transport_encode_sdp, &transport_media_start, &transport_media_stop, &transport_simulate_lost, &transport_destroy, &transport_attach2 };














static int get_crypto_idx(const pj_str_t* crypto_name);


static pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c);


static int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1, const pjmedia_srtp_crypto* c2);


static pj_status_t start_srtp(transport_srtp *srtp);



PJ_BEGIN_DECL const char* get_libsrtp_errstr(int err);
PJ_END_DECL  const char* get_libsrtp_errstr(int err)

{

    static char *liberr[] = {
	"ok",				     "unspecified failure", "unsupported parameter", "couldn't allocate memory", "couldn't deallocate properly", "couldn't initialize", "can't process as much data as requested",  "authentication failure", "cipher failure", "replay check failed (bad index)", "replay check failed (index too old)",  "algorithm failed test routine", "unsupported operation", "no appropriate context found", "unable to perform desired validation",  "can't use key any more", "error in use of socket", "error in use POSIX signals", "nonce check failed", "couldn't read data", "couldn't write data", "error pasring data", "error encoding data", "error while using semaphores", "error while using pfkey" };



























    if (err >= 0 && err < (int)PJ_ARRAY_SIZE(liberr)) {
	return liberr[err];
    } else {
	static char msg[32];
	pj_ansi_snprintf(msg, sizeof(msg), "Unknown libsrtp error %d", err);
	return msg;
    }

    static char msg[32];
    pj_ansi_snprintf(msg, sizeof(msg), "libsrtp error %d", err);
    return msg;

}










PJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego( pjmedia_transport *srtp, const pjmedia_srtp_dtls_nego_param *param)

{
    PJ_UNUSED_ARG(srtp);
    PJ_UNUSED_ARG(param);
    return PJ_ENOTSUP;
}
PJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint( pjmedia_transport *srtp, const char *hash, char *buf, pj_size_t *len)


{
    PJ_UNUSED_ARG(srtp);
    PJ_UNUSED_ARG(hash);
    PJ_UNUSED_ARG(buf);
    PJ_UNUSED_ARG(len);
    return PJ_ENOTSUP;
}



static pj_bool_t libsrtp_initialized;
static void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt);

PJ_DEF(pj_status_t) pjmedia_srtp_init_lib(pjmedia_endpt *endpt)
{
    pj_status_t status = PJ_SUCCESS;

    if (libsrtp_initialized)
	return PJ_SUCCESS;


    
    {
	srtp_err_status_t err;

	err = srtp_init();
	if (err != srtp_err_status_ok) {
	    PJ_LOG(4, (THIS_FILE, "Failed to initialize libsrtp: %s", get_libsrtp_errstr(err)));
	    return PJMEDIA_ERRNO_FROM_LIBSRTP(err);
	}
    }



    dtls_init();


    status = pjmedia_endpt_atexit(endpt, pjmedia_srtp_deinit_lib);
    if (status != PJ_SUCCESS) {
	
	PJ_PERROR(4, (THIS_FILE, status, "Failed to register libsrtp deinit."));

	
	status = PJ_SUCCESS;
    }

    libsrtp_initialized = PJ_TRUE;

    return status;
}

static void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt)
{
    srtp_err_status_t err;

    

    PJ_UNUSED_ARG(endpt);








    err = srtp_deinit();

    err = srtp_shutdown();

    err = srtp_err_status_ok;

    if (err != srtp_err_status_ok) {
	PJ_LOG(4, (THIS_FILE, "Failed to deinitialize libsrtp: %s", get_libsrtp_errstr(err)));
    }



    dtls_deinit();


    libsrtp_initialized = PJ_FALSE;
}


static int get_crypto_idx(const pj_str_t* crypto_name)
{
    int i;
    int cs_cnt = sizeof(crypto_suites)/sizeof(crypto_suites[0]);

    
    if (crypto_name->slen == 0)
	return 0;

    for (i=0; i<cs_cnt; ++i) {
	if (!pj_stricmp2(crypto_name, crypto_suites[i].name))
	    return i;
    }

    return -1;
}


static int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1, const pjmedia_srtp_crypto* c2)
{
    int r;

    r = pj_strcmp(&c1->key, &c2->key);
    if (r != 0)
	return r;

    r = pj_stricmp(&c1->name, &c2->name);
    if (r != 0)
	return r;

    return (c1->flags != c2->flags);
}


static pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c)
{
    return (c->name.slen==0 || c->key.slen==0);
}


PJ_DEF(void) pjmedia_srtp_setting_default(pjmedia_srtp_setting *opt)
{
    pj_assert(opt);

    pj_bzero(opt, sizeof(pjmedia_srtp_setting));
    opt->close_member_tp = PJ_TRUE;
    opt->use = PJMEDIA_SRTP_OPTIONAL;
}


PJ_DEF(pj_status_t) pjmedia_srtp_enum_crypto(unsigned *count, pjmedia_srtp_crypto crypto[])
{
    unsigned i, max;

    PJ_ASSERT_RETURN(count && crypto, PJ_EINVAL);

    max = sizeof(crypto_suites) / sizeof(crypto_suites[0]) - 1;
    if (*count > max)
	*count = max;

    for (i=0; i<*count; ++i) {
	pj_bzero(&crypto[i], sizeof(crypto[0]));
	crypto[i].name = pj_str(crypto_suites[i+1].name);
    }
    
    return PJ_SUCCESS;
}



PJ_DEF(pj_status_t) pjmedia_srtp_enum_keying(unsigned *count, pjmedia_srtp_keying_method keying[])
{
    unsigned max;

    PJ_ASSERT_RETURN(count && keying, PJ_EINVAL);

    max = *count;
    *count = 0;


    if (*count < max)
	keying[(*count)++] = PJMEDIA_SRTP_KEYING_SDES;


    if (*count < max)
	keying[(*count)++] = PJMEDIA_SRTP_KEYING_DTLS_SRTP;

    
    return PJ_SUCCESS;
}



PJ_DEF(pj_status_t) pjmedia_transport_srtp_create( pjmedia_endpt *endpt, pjmedia_transport *tp, const pjmedia_srtp_setting *opt, pjmedia_transport **p_tp)



{
    pj_pool_t *pool;
    transport_srtp *srtp;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(endpt && tp && p_tp, PJ_EINVAL);

    
    if (opt && opt->use != PJMEDIA_SRTP_DISABLED) {
	for (i=0; i < opt->crypto_count; ++i) {
	    int cs_idx = get_crypto_idx(&opt->crypto[i].name);

	    
	    if (cs_idx == -1)
		return PJMEDIA_SRTP_ENOTSUPCRYPTO;

	    
	    if (opt->crypto[i].key.slen && opt->crypto[i].key.slen < (pj_ssize_t)crypto_suites[cs_idx].cipher_key_len)

		return PJMEDIA_SRTP_EINKEYLEN;
	}
    }

    
    status = pjmedia_srtp_init_lib(endpt);
    if (status != PJ_SUCCESS)
	return status;

    pool = pjmedia_endpt_create_pool(endpt, "srtp%p", 1000, 1000);
    srtp = PJ_POOL_ZALLOC_T(pool, transport_srtp);

    srtp->pool = pool;
    srtp->session_inited = PJ_FALSE;
    srtp->bypass_srtp = PJ_FALSE;
    srtp->probation_cnt = PROBATION_CNT_INIT;

    if (opt) {
	srtp->setting = *opt;
	if (opt->use == PJMEDIA_SRTP_DISABLED)
	    srtp->setting.crypto_count = 0;

	for (i=0; i < srtp->setting.crypto_count; ++i) {
	    int cs_idx = get_crypto_idx(&opt->crypto[i].name);
	    pj_str_t tmp_key = opt->crypto[i].key;

	    
	    srtp->setting.crypto[i].name = pj_str(crypto_suites[cs_idx].name);
	    
	    if (tmp_key.slen)
		tmp_key.slen = crypto_suites[cs_idx].cipher_key_len;
	    pj_strdup(pool, &srtp->setting.crypto[i].key, &tmp_key);
	}
    } else {
	pjmedia_srtp_setting_default(&srtp->setting);
    }

    
    if (srtp->setting.crypto_count == 0 &&  srtp->setting.use != PJMEDIA_SRTP_DISABLED)
    {
	srtp->setting.crypto_count = PJMEDIA_SRTP_MAX_CRYPTOS;
	pjmedia_srtp_enum_crypto(&srtp->setting.crypto_count, srtp->setting.crypto);
    }

    status = pj_lock_create_recursive_mutex(pool, pool->obj_name, &srtp->mutex);
    if (status != PJ_SUCCESS) {
	pj_pool_release(pool);
	return status;
    }

    
    pj_memcpy(srtp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);
    if (tp)
	srtp->base.type = tp->type;
    else srtp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;
    srtp->base.op = &transport_srtp_op;
    srtp->base.user_data = srtp->setting.user_data;

    
    srtp->member_tp = tp;

    
    srtp->peer_use = srtp->setting.use;

    
    if (srtp->setting.keying_count == 0) {
	srtp->setting.keying_count = PJMEDIA_SRTP_KEYINGS_COUNT;
	pjmedia_srtp_enum_keying(&srtp->setting.keying_count, srtp->setting.keying);
    }

    
    for (i = 0; i < srtp->setting.keying_count && i < MAX_KEYING; ++i) {
	switch(srtp->setting.keying[i]) {

	case PJMEDIA_SRTP_KEYING_SDES:

	    sdes_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);

	    break;

	case PJMEDIA_SRTP_KEYING_DTLS_SRTP:

	    dtls_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);

	    break;

	default:
	    break;
	}
    }

    
    *p_tp = &srtp->base;

    return PJ_SUCCESS;
}



PJ_DEF(pj_status_t) pjmedia_transport_srtp_get_setting( pjmedia_transport *tp, pjmedia_srtp_setting *opt)

{
    transport_srtp  *srtp = (transport_srtp*) tp;
    *opt = srtp->setting;
    return PJ_SUCCESS;
}


PJ_DEF(pj_status_t) pjmedia_transport_srtp_modify_setting( pjmedia_transport *tp, const pjmedia_srtp_setting *opt)

{
    transport_srtp  *srtp = (transport_srtp*) tp;
    srtp->setting = *opt;
    return PJ_SUCCESS;
}



PJ_DEF(pj_status_t) pjmedia_transport_srtp_start( pjmedia_transport *tp, const pjmedia_srtp_crypto *tx, const pjmedia_srtp_crypto *rx)


{
    transport_srtp  *srtp = (transport_srtp*) tp;
    srtp_policy_t    tx_;
    srtp_policy_t    rx_;
    srtp_err_status_t err;
    int		     cr_tx_idx = 0;
    int		     au_tx_idx = 0;
    int		     cr_rx_idx = 0;
    int		     au_rx_idx = 0;
    pj_status_t	     status = PJ_SUCCESS;

    PJ_ASSERT_RETURN(tp && tx && rx, PJ_EINVAL);

    pj_lock_acquire(srtp->mutex);

    if (srtp->session_inited) {
	pjmedia_transport_srtp_stop(tp);
    }

    
    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);
    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)
	cr_tx_idx = 0;
    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)
	au_tx_idx = 0;

    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);
    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)
	cr_rx_idx = 0;
    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)
	au_rx_idx = 0;

    
    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 || au_rx_idx == -1)
    {
	status = PJMEDIA_SRTP_ENOTSUPCRYPTO;
	goto on_return;
    }

    
    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {
	srtp->bypass_srtp = PJ_TRUE;
	goto on_return;
    }

    
    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len || rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)
    {
	status = PJMEDIA_SRTP_EINKEYLEN;
	goto on_return;
    }

    
    pj_bzero(&tx_, sizeof(srtp_policy_t));
    pj_memmove(srtp->tx_key, tx->key.ptr, tx->key.slen);
    if (cr_tx_idx && au_tx_idx)
	tx_.rtp.sec_serv    = sec_serv_conf_and_auth;
    else if (cr_tx_idx)
	tx_.rtp.sec_serv    = sec_serv_conf;
    else if (au_tx_idx)
	tx_.rtp.sec_serv    = sec_serv_auth;
    else tx_.rtp.sec_serv    = sec_serv_none;
    tx_.key		    = (uint8_t*)srtp->tx_key;
    if (srtp->setting.tx_roc.roc != 0 && srtp->setting.tx_roc.ssrc != 0)
    {
	tx_.ssrc.type	    = ssrc_specific;
	tx_.ssrc.value	    = srtp->setting.tx_roc.ssrc;
    } else {
	tx_.ssrc.type	    = ssrc_any_outbound;
	tx_.ssrc.value	    = 0;
    }
    tx_.rtp.cipher_type	    = crypto_suites[cr_tx_idx].cipher_type;
    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;
    tx_.rtp.auth_type	    = crypto_suites[au_tx_idx].auth_type;
    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;
    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;
    tx_.rtcp		    = tx_.rtp;
    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;
    tx_.next		    = NULL;
    err = srtp_create(&srtp->srtp_tx_ctx, &tx_);
    if (err != srtp_err_status_ok) {
	status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
	goto on_return;
    }
    if (srtp->setting.tx_roc.roc != 0 && srtp->setting.tx_roc.ssrc != 0)
    {
	err = srtp_set_stream_roc(srtp->srtp_tx_ctx, srtp->setting.tx_roc.ssrc, srtp->setting.tx_roc.roc);

    	PJ_LOG(4, (THIS_FILE, "Initializing SRTP TX ROC to SSRC %d with " "ROC %d %s\n", srtp->setting.tx_roc.ssrc, srtp->setting.tx_roc.roc, (err == srtp_err_status_ok)? "succeeded": "failed"));


    }
    srtp->tx_policy = *tx;
    pj_strset(&srtp->tx_policy.key,  srtp->tx_key, tx->key.slen);
    srtp->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);


    
    pj_bzero(&rx_, sizeof(srtp_policy_t));
    pj_memmove(srtp->rx_key, rx->key.ptr, rx->key.slen);
    if (cr_rx_idx && au_rx_idx)
	rx_.rtp.sec_serv    = sec_serv_conf_and_auth;
    else if (cr_rx_idx)
	rx_.rtp.sec_serv    = sec_serv_conf;
    else if (au_rx_idx)
	rx_.rtp.sec_serv    = sec_serv_auth;
    else rx_.rtp.sec_serv    = sec_serv_none;
    rx_.key		    = (uint8_t*)srtp->rx_key;
    if (srtp->setting.rx_roc.roc != 0 && srtp->setting.rx_roc.ssrc != 0)
    {
	rx_.ssrc.type	    = ssrc_specific;
	rx_.ssrc.value	    = srtp->setting.rx_roc.ssrc;
    } else {
	rx_.ssrc.type	    = ssrc_any_inbound;
	rx_.ssrc.value	    = 0;
    }
    rx_.rtp.sec_serv	    = crypto_suites[cr_rx_idx].service;
    rx_.rtp.cipher_type	    = crypto_suites[cr_rx_idx].cipher_type;
    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;
    rx_.rtp.auth_type	    = crypto_suites[au_rx_idx].auth_type;
    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;
    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;
    rx_.rtcp		    = rx_.rtp;
    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;
    rx_.next		    = NULL;
    err = srtp_create(&srtp->srtp_rx_ctx, &rx_);
    if (err != srtp_err_status_ok) {
	srtp_dealloc(srtp->srtp_tx_ctx);
	status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
	goto on_return;
    }
    if (srtp->setting.rx_roc.roc != 0 && srtp->setting.rx_roc.ssrc != 0)
    {
	err = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc, srtp->setting.rx_roc.roc);

    	PJ_LOG(4, (THIS_FILE, "Initializing SRTP RX ROC from SSRC %d with " "ROC %d %s\n", srtp->setting.rx_roc.ssrc, srtp->setting.rx_roc.roc, (err == srtp_err_status_ok)? "succeeded": "failed"));


    }
    srtp->rx_policy = *rx;
    pj_strset(&srtp->rx_policy.key,  srtp->rx_key, rx->key.slen);
    srtp->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);

    
    srtp->session_inited = PJ_TRUE;

    

    {
	char b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];
	int b64_len;

	
	b64_len = sizeof(b64);
	status = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen, b64, &b64_len);
	if (status != PJ_SUCCESS)
	    b64_len = pj_ansi_sprintf(b64, "--key too long--");
	else b64[b64_len] = '\0';

	PJ_LOG(5, (srtp->pool->obj_name, "TX: %s key=%s", srtp->tx_policy.name.ptr, b64));
	if (srtp->tx_policy.flags) {
	    PJ_LOG(5,(srtp->pool->obj_name, "TX: disable%s%s", (cr_tx_idx?"":" enc"), (au_tx_idx?"":" auth")));

	}

	
	b64_len = sizeof(b64);
	status = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen, b64, &b64_len);
	if (status != PJ_SUCCESS)
	    b64_len = pj_ansi_sprintf(b64, "--key too long--");
	else b64[b64_len] = '\0';

	PJ_LOG(5, (srtp->pool->obj_name, "RX: %s key=%s", srtp->rx_policy.name.ptr, b64));
	if (srtp->rx_policy.flags) {
	    PJ_LOG(5,(srtp->pool->obj_name,"RX: disable%s%s", (cr_rx_idx?"":" enc"), (au_rx_idx?"":" auth")));

	}
    }


on_return:
    pj_lock_release(srtp->mutex);
    return status;
}


PJ_DEF(pj_status_t) pjmedia_transport_srtp_stop(pjmedia_transport *srtp)
{
    transport_srtp *p_srtp = (transport_srtp*) srtp;
    srtp_err_status_t err;

    PJ_ASSERT_RETURN(srtp, PJ_EINVAL);

    pj_lock_acquire(p_srtp->mutex);

    if (!p_srtp->session_inited) {
	pj_lock_release(p_srtp->mutex);
	return PJ_SUCCESS;
    }

    err = srtp_dealloc(p_srtp->srtp_rx_ctx);
    if (err != srtp_err_status_ok) {
	PJ_LOG(4, (p_srtp->pool->obj_name, "Failed to dealloc RX SRTP context: %s", get_libsrtp_errstr(err)));

    }
    err = srtp_dealloc(p_srtp->srtp_tx_ctx);
    if (err != srtp_err_status_ok) {
	PJ_LOG(4, (p_srtp->pool->obj_name, "Failed to dealloc TX SRTP context: %s", get_libsrtp_errstr(err)));

    }
    p_srtp->srtp_rx_ctx = NULL;
    p_srtp->srtp_tx_ctx = NULL;

    p_srtp->session_inited = PJ_FALSE;
    pj_bzero(&p_srtp->rx_policy, sizeof(p_srtp->rx_policy));
    pj_bzero(&p_srtp->tx_policy, sizeof(p_srtp->tx_policy));

    pj_lock_release(p_srtp->mutex);

    return PJ_SUCCESS;
}


static pj_status_t start_srtp(transport_srtp *srtp)
{
    
    if (srtp_crypto_empty(&srtp->tx_policy_neg) || srtp_crypto_empty(&srtp->rx_policy_neg))
    {
	srtp->bypass_srtp = PJ_TRUE;
	srtp->peer_use = PJMEDIA_SRTP_DISABLED;
	if (srtp->session_inited) {
	    pjmedia_transport_srtp_stop(&srtp->base);
	}

	PJ_LOG(4, (srtp->pool->obj_name, "SRTP not active"));
	return PJ_SUCCESS;
    }

    

    
    if (srtp_crypto_cmp(&srtp->tx_policy_neg, &srtp->tx_policy) || srtp_crypto_cmp(&srtp->rx_policy_neg, &srtp->rx_policy))
    {
	pj_status_t status;
	status = pjmedia_transport_srtp_start(&srtp->base, &srtp->tx_policy_neg, &srtp->rx_policy_neg);

	if (status != PJ_SUCCESS)
	    return status;

	
	srtp->probation_cnt = PROBATION_CNT_INIT;

	PJ_LOG(4, (srtp->pool->obj_name, "SRTP started, keying=%s, crypto=%s", ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES? "SDES":"DTLS-SRTP"), srtp->tx_policy.name.ptr));



    }

    srtp->bypass_srtp = PJ_FALSE;

    return PJ_SUCCESS;
}


PJ_DEF(pjmedia_transport *) pjmedia_transport_srtp_get_member( pjmedia_transport *tp)
{
    transport_srtp *srtp = (transport_srtp*) tp;

    PJ_ASSERT_RETURN(tp, NULL);

    return srtp->member_tp;
}


static pj_status_t transport_get_info(pjmedia_transport *tp, pjmedia_transport_info *info)
{
    transport_srtp *srtp = (transport_srtp*) tp;
    pjmedia_srtp_info srtp_info;
    int spc_info_idx;
    unsigned i;

    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);
    PJ_ASSERT_RETURN(info->specific_info_cnt < PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT, PJ_ETOOMANY);
    PJ_ASSERT_RETURN(sizeof(pjmedia_srtp_info) <= PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE, PJ_ENOMEM);

    srtp_info.active = srtp->session_inited;
    srtp_info.rx_policy = srtp->rx_policy;
    srtp_info.tx_policy = srtp->tx_policy;
    srtp_info.use = srtp->setting.use;
    srtp_info.peer_use = srtp->peer_use;

    pj_bzero(&srtp_info.tx_roc, sizeof(srtp_info.tx_roc));
    pj_bzero(&srtp_info.rx_roc, sizeof(srtp_info.rx_roc));

    if (srtp->srtp_rx_ctx && srtp->rx_ssrc != 0) {
    	srtp_info.rx_roc.ssrc = srtp->rx_ssrc;
    	srtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc, &srtp_info.rx_roc.roc);
    } else if (srtp->setting.rx_roc.ssrc != 0) {
    	srtp_info.rx_roc.ssrc = srtp->setting.rx_roc.ssrc;
    	srtp_info.rx_roc.roc = srtp->setting.rx_roc.roc;
    }
    if (srtp->srtp_tx_ctx && srtp->tx_ssrc != 0) {
    	srtp_info.tx_roc.ssrc = srtp->tx_ssrc;
    	srtp_get_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc, &srtp_info.tx_roc.roc);
    } else if (srtp->setting.tx_roc.ssrc != 0) {
    	srtp_info.tx_roc.ssrc = srtp->setting.tx_roc.ssrc;
    	srtp_info.tx_roc.roc = srtp->setting.tx_roc.roc;
    }

    spc_info_idx = info->specific_info_cnt++;
    info->spc_info[spc_info_idx].type = PJMEDIA_TRANSPORT_TYPE_SRTP;
    info->spc_info[spc_info_idx].tp = tp;
    info->spc_info[spc_info_idx].cbsize = sizeof(srtp_info);
    pj_memcpy(&info->spc_info[spc_info_idx].buffer, &srtp_info, sizeof(srtp_info));

    
    for (i=0; i < srtp->keying_cnt; i++)
	pjmedia_transport_get_info(srtp->keying[i], info);

    return pjmedia_transport_get_info(srtp->member_tp, info);
}

static pj_status_t transport_attach2(pjmedia_transport *tp, pjmedia_transport_attach_param *param)
{
    transport_srtp *srtp = (transport_srtp*) tp;
    pjmedia_transport_attach_param member_param;
    pj_status_t status;

    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);

    
    pj_lock_acquire(srtp->mutex);
    if (param->rtp_cb || param->rtp_cb2) {
	
	srtp->rtp_cb = param->rtp_cb;
	srtp->rtp_cb2 = param->rtp_cb2;
	srtp->rtcp_cb = param->rtcp_cb;
	srtp->user_data = param->user_data;
    }
    pj_lock_release(srtp->mutex);

    
    member_param = *param;
    member_param.user_data = srtp;
    member_param.rtp_cb = NULL;
    member_param.rtp_cb2 = &srtp_rtp_cb;
    member_param.rtcp_cb = &srtp_rtcp_cb;
    status = pjmedia_transport_attach2(srtp->member_tp, &member_param);
    if (status != PJ_SUCCESS) {
	pj_lock_acquire(srtp->mutex);
	srtp->rtp_cb = NULL;
	srtp->rtcp_cb = NULL;
	srtp->user_data = NULL;
	pj_lock_release(srtp->mutex);
	return status;
    }

    
    srtp->use_rtcp_mux = (pj_sockaddr_has_addr(&param->rem_addr) && pj_sockaddr_cmp(&param->rem_addr, &param->rem_rtcp) == 0);

    srtp->member_tp_attached = PJ_TRUE;
    return PJ_SUCCESS;
}

static void transport_detach(pjmedia_transport *tp, void *strm)
{
    transport_srtp *srtp = (transport_srtp*) tp;

    PJ_UNUSED_ARG(strm);
    PJ_ASSERT_ON_FAIL(tp, return);

    if (srtp->member_tp) {
	pjmedia_transport_detach(srtp->member_tp, srtp);
    }

    
    pj_lock_acquire(srtp->mutex);
    srtp->rtp_cb = NULL;
    srtp->rtp_cb2 = NULL;
    srtp->rtcp_cb = NULL;
    srtp->user_data = NULL;
    pj_lock_release(srtp->mutex);
    srtp->member_tp_attached = PJ_FALSE;
}

static pj_status_t transport_send_rtp( pjmedia_transport *tp, const void *pkt, pj_size_t size)

{
    pj_status_t status;
    transport_srtp *srtp = (transport_srtp*) tp;
    int len = (int)size;
    srtp_err_status_t err;

    if (srtp->bypass_srtp)
	return pjmedia_transport_send_rtp(srtp->member_tp, pkt, size);

    if (size > sizeof(srtp->rtp_tx_buffer) - MAX_TRAILER_LEN)
	return PJ_ETOOBIG;

    pj_memcpy(srtp->rtp_tx_buffer, pkt, size);

    pj_lock_acquire(srtp->mutex);
    if (!srtp->session_inited) {
	pj_lock_release(srtp->mutex);
	return PJMEDIA_SRTP_EKEYNOTREADY;
    }

    
    srtp->tx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);


    if (srtp->setting.tx_roc.ssrc == 0) {
	srtp_err_status_t status;
    	status = srtp_set_stream_roc(srtp->srtp_tx_ctx, srtp->tx_ssrc, (srtp->offerer_side? 1: 2));
    	if (status == srtp_err_status_ok) {
    	    srtp->setting.tx_roc.ssrc = srtp->tx_ssrc;
    	    srtp->setting.tx_roc.roc = (srtp->offerer_side? 1: 2);
	    PJ_LOG(4, (THIS_FILE, "Setting TX ROC to SSRC %d to %d", srtp->tx_ssrc, srtp->setting.tx_roc.roc));
	}
    }


    err = srtp_protect(srtp->srtp_tx_ctx, srtp->rtp_tx_buffer, &len);
    pj_lock_release(srtp->mutex);

    if (err == srtp_err_status_ok) {
	status = pjmedia_transport_send_rtp(srtp->member_tp, srtp->rtp_tx_buffer, len);
    } else {
	status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
    }

    return status;
}

static pj_status_t transport_send_rtcp(pjmedia_transport *tp, const void *pkt, pj_size_t size)

{
    return transport_send_rtcp2(tp, NULL, 0, pkt, size);
}

static pj_status_t transport_send_rtcp2(pjmedia_transport *tp, const pj_sockaddr_t *addr, unsigned addr_len, const void *pkt, pj_size_t size)



{
    pj_status_t status;
    transport_srtp *srtp = (transport_srtp*) tp;
    int len = (int)size;
    srtp_err_status_t err;

    if (srtp->bypass_srtp) {
	return pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len, pkt, size);
    }

    if (size > sizeof(srtp->rtcp_tx_buffer) - (MAX_TRAILER_LEN+4))
	return PJ_ETOOBIG;

    pj_memcpy(srtp->rtcp_tx_buffer, pkt, size);

    pj_lock_acquire(srtp->mutex);
    if (!srtp->session_inited) {
	pj_lock_release(srtp->mutex);
	return PJMEDIA_SRTP_EKEYNOTREADY;
    }
    err = srtp_protect_rtcp(srtp->srtp_tx_ctx, srtp->rtcp_tx_buffer, &len);
    pj_lock_release(srtp->mutex);

    if (err == srtp_err_status_ok) {
	status = pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len, srtp->rtcp_tx_buffer, len);
    } else {
	status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
    }

    return status;
}


static pj_status_t transport_simulate_lost(pjmedia_transport *tp, pjmedia_dir dir, unsigned pct_lost)

{
    transport_srtp *srtp = (transport_srtp *) tp;

    PJ_ASSERT_RETURN(tp, PJ_EINVAL);

    return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);
}

static pj_status_t transport_destroy  (pjmedia_transport *tp)
{
    transport_srtp *srtp = (transport_srtp *) tp;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(tp, PJ_EINVAL);

    
    for (i=0; i < srtp->all_keying_cnt; i++)
	pjmedia_transport_close(srtp->all_keying[i]);

    
    if (srtp->setting.close_member_tp && srtp->member_tp) {
	pjmedia_transport_close(srtp->member_tp);
    }

    status = pjmedia_transport_srtp_stop(tp);

    
    pj_lock_acquire(srtp->mutex);
    pj_lock_release(srtp->mutex);

    pj_lock_destroy(srtp->mutex);
    pj_pool_release(srtp->pool);

    return status;
}


static void srtp_rtp_cb(pjmedia_tp_cb_param *param)
{
    transport_srtp *srtp = (transport_srtp *) param->user_data;
    void *pkt = param->pkt;
    pj_ssize_t size = param->size;
    int len = (int)size;
    srtp_err_status_t err;
    void (*cb)(void*, void*, pj_ssize_t) = NULL;
    void (*cb2)(pjmedia_tp_cb_param*) = NULL;
    void *cb_data = NULL;

    if (srtp->bypass_srtp) {
        if (srtp->rtp_cb2) {
            pjmedia_tp_cb_param param2 = *param;
            param2.user_data = srtp->user_data;
            srtp->rtp_cb2(&param2);
            param->rem_switch = param2.rem_switch;
        } else if (srtp->rtp_cb) {
	    srtp->rtp_cb(srtp->user_data, pkt, size);
	}
	return;
    }

    if (size < 0) {
	return;
    }

    
    {
	unsigned i;
	pj_status_t status;
	for (i=0; i < srtp->keying_cnt; i++) {
	    if (!srtp->keying[i]->op->send_rtp)
		continue;
	    status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);
	    if (status != PJ_EIGNORED) {
		
		return;
	    }
	}
    }

    
    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );

    if (srtp->probation_cnt > 0)
	--srtp->probation_cnt;

    pj_lock_acquire(srtp->mutex);

    if (!srtp->session_inited) {
	pj_lock_release(srtp->mutex);
	return;
    }

    
    if (srtp->use_rtcp_mux) {
    	pjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;
  
	if (hdr->pt >= 64 && hdr->pt <= 95) {   
	    pj_lock_release(srtp->mutex);
	    srtp_rtcp_cb(srtp, pkt, size);
    	    return;
    	}
    }


    if (srtp->setting.rx_roc.ssrc == 0) {
	srtp_err_status_t status;
	
	srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);
    	status = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc,  (srtp->offerer_side? 2: 1));
	if (status == srtp_err_status_ok) {    	
    	    srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;
	    srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);

	    PJ_LOG(4, (THIS_FILE, "Setting RX ROC from SSRC %d to %d", srtp->rx_ssrc, srtp->setting.rx_roc.roc));
	} else {
	    PJ_LOG(4, (THIS_FILE, "Setting RX ROC %s", get_libsrtp_errstr(status)));
	}
    }

    
    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);


    if (srtp->probation_cnt > 0 && (err == srtp_err_status_replay_old || err == srtp_err_status_replay_fail))

    {
	
	pjmedia_srtp_crypto tx, rx;
	pj_status_t status;

	
	pjmedia_transport_srtp_stop((pjmedia_transport*)srtp);

	tx = srtp->tx_policy;
	rx = srtp->rx_policy;
	status = pjmedia_transport_srtp_start((pjmedia_transport*)srtp, &tx, &rx);
	if (status != PJ_SUCCESS) {
	    PJ_LOG(5,(srtp->pool->obj_name, "Failed to restart SRTP, err=%s", get_libsrtp_errstr(err)));
	} else if (!srtp->bypass_srtp) {
	    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);
	}
    }

    else     if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail && srtp->setting.prev_rx_roc.ssrc != 0 && srtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc && srtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)







    {
        unsigned roc, new_roc;
	srtp_err_status_t status;

    	srtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc, &roc);
    	new_roc = (roc == srtp->setting.rx_roc.roc? srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);
    	status = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc, new_roc);
	if (status == srtp_err_status_ok) {
	    PJ_LOG(4, (srtp->pool->obj_name, "Retrying to unprotect SRTP from ROC %d to new ROC %d", roc, new_roc));

    	    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);
    	}
    }


    if (err != srtp_err_status_ok) {
	PJ_LOG(5,(srtp->pool->obj_name, "Failed to unprotect SRTP, pkt size=%d, err=%s", size, get_libsrtp_errstr(err)));

    } else {
	cb = srtp->rtp_cb;
	cb2 = srtp->rtp_cb2;
	cb_data = srtp->user_data;

	
	srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);
    }

    pj_lock_release(srtp->mutex);

    if (cb2) {
        pjmedia_tp_cb_param param2 = *param;
        param2.user_data = cb_data;
        param2.pkt = pkt;
        param2.size = len;
        (*cb2)(&param2);
        param->rem_switch = param2.rem_switch;
    } else if (cb) {
	(*cb)(cb_data, pkt, len);
    }
}


static void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)
{
    transport_srtp *srtp = (transport_srtp *) user_data;
    int len = (int)size;
    srtp_err_status_t err;
    void (*cb)(void*, void*, pj_ssize_t) = NULL;
    void *cb_data = NULL;

    if (srtp->bypass_srtp) {
	srtp->rtcp_cb(srtp->user_data, pkt, size);
	return;
    }

    if (size < 0) {
	return;
    }

    
    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );

    pj_lock_acquire(srtp->mutex);

    if (!srtp->session_inited) {
	pj_lock_release(srtp->mutex);
	return;
    }
    err = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);
    if (err != srtp_err_status_ok) {
	PJ_LOG(5,(srtp->pool->obj_name, "Failed to unprotect SRTCP, pkt size=%d, err=%s", size, get_libsrtp_errstr(err)));

    } else {
	cb = srtp->rtcp_cb;
	cb_data = srtp->user_data;
    }

    pj_lock_release(srtp->mutex);

    if (cb) {
	(*cb)(cb_data, pkt, len);
    }
}


static pj_status_t transport_media_create(pjmedia_transport *tp, pj_pool_t *sdp_pool, unsigned options, const pjmedia_sdp_session *sdp_remote, unsigned media_index)



{
    struct transport_srtp *srtp = (struct transport_srtp*) tp;
    unsigned member_tp_option;
    pj_status_t keying_status = PJ_SUCCESS;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(tp, PJ_EINVAL);

    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));
    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));

    srtp->tx_ssrc = srtp->rx_ssrc = 0;
    srtp->media_option = member_tp_option = options;
    srtp->offerer_side = (sdp_remote == NULL);

    if (srtp->offerer_side && srtp->setting.use == PJMEDIA_SRTP_DISABLED) {
	
	srtp->bypass_srtp = PJ_TRUE;
	srtp->keying_cnt = 0;
    } else {
	
	srtp->bypass_srtp = PJ_FALSE;
	srtp->keying_cnt = srtp->all_keying_cnt;
	for (i = 0; i < srtp->all_keying_cnt; ++i)
	    srtp->keying[i] = srtp->all_keying[i];

	member_tp_option |= PJMEDIA_TPMED_NO_TRANSPORT_CHECKING;
    }

    status = pjmedia_transport_media_create(srtp->member_tp, sdp_pool, member_tp_option, sdp_remote, media_index);

    if (status != PJ_SUCCESS)
	return status;

    
    for (i=0; i < srtp->keying_cnt; ) {
	pj_status_t st;
	st = pjmedia_transport_media_create(srtp->keying[i], sdp_pool, options, sdp_remote, media_index);

	if (st != PJ_SUCCESS) {
	    
	    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]), srtp->keying_cnt, i);
	    srtp->keying_cnt--;
	    keying_status = st;
	    continue;
	} else if (srtp->offerer_side) {
	    
	    srtp->keying[0] = srtp->keying[i];
	    srtp->keying_cnt = 1;
	    break;
	}

	++i;
    }

    
    if (srtp->keying_cnt == 0)
	return keying_status;

    
    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {
	srtp->bypass_srtp = PJ_TRUE;
	srtp->keying_cnt = 0;
    }

    return PJ_SUCCESS;
}

static pj_status_t transport_encode_sdp(pjmedia_transport *tp, pj_pool_t *sdp_pool, pjmedia_sdp_session *sdp_local, const pjmedia_sdp_session *sdp_remote, unsigned media_index)



{
    struct transport_srtp *srtp = (struct transport_srtp*) tp;
    pj_status_t keying_status = PJ_SUCCESS;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(tp && sdp_pool && sdp_local, PJ_EINVAL);

    pj_bzero(&srtp->rx_policy_neg, sizeof(srtp->rx_policy_neg));
    pj_bzero(&srtp->tx_policy_neg, sizeof(srtp->tx_policy_neg));

    srtp->offerer_side = (sdp_remote == NULL);

    if (!srtp->offerer_side && srtp->started) {
	
	srtp->keying_cnt = srtp->all_keying_cnt;
	for (i = 0; i < srtp->all_keying_cnt; ++i)
	    srtp->keying[i] = srtp->all_keying[i];
    }

    status = pjmedia_transport_encode_sdp(srtp->member_tp, sdp_pool, sdp_local, sdp_remote, media_index);
    if (status != PJ_SUCCESS)
	return status;

    
    for (i=0; i < srtp->keying_cnt; ) {
	pj_status_t st;
	st = pjmedia_transport_encode_sdp(srtp->keying[i], sdp_pool, sdp_local, sdp_remote, media_index);

	if (st != PJ_SUCCESS) {
	    
	    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]), srtp->keying_cnt, i);
	    srtp->keying_cnt--;
	    keying_status = st;
	    continue;
	} else if (!srtp->offerer_side) {
	    
	    srtp->keying[0] = srtp->keying[i];
	    srtp->keying_cnt = 1;
	    break;
	}

	i++;
    }

    
    if (srtp->keying_cnt == 0) {
	if (keying_status != PJ_SUCCESS) {
	    DEACTIVATE_MEDIA(sdp_pool, sdp_local->media[media_index]);
	}
	return keying_status;
    }

    
    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {
	srtp->bypass_srtp = PJ_TRUE;
	srtp->keying_cnt = 0;
    }

    if (srtp->keying_cnt != 0) {
	
	pj_assert(srtp->keying_cnt == 1);
	PJ_LOG(4, (srtp->pool->obj_name, "SRTP uses keying method %s", ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES? "SDES":"DTLS-SRTP")));

    }

    return PJ_SUCCESS;
}


static pj_status_t transport_media_start(pjmedia_transport *tp, pj_pool_t *pool, const pjmedia_sdp_session *sdp_local, const pjmedia_sdp_session *sdp_remote, unsigned media_index)



{
    struct transport_srtp *srtp = (struct transport_srtp*) tp;
    pj_status_t keying_status = PJ_SUCCESS;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(tp, PJ_EINVAL);

    
    pj_assert(srtp->keying_cnt <= 1);

    srtp->started = PJ_TRUE;

    status = pjmedia_transport_media_start(srtp->member_tp, pool, sdp_local, sdp_remote, media_index);

    if (status != PJ_SUCCESS)
	return status;

    
    for (i=0; i < srtp->keying_cnt; ) {
	status = pjmedia_transport_media_start(srtp->keying[i], pool, sdp_local, sdp_remote, media_index);

	if (status != PJ_SUCCESS) {
	    
	    pj_array_erase(srtp->keying, sizeof(srtp->keying[0]), srtp->keying_cnt, i);
	    srtp->keying_cnt--;
	    keying_status = status;
	    continue;
	}

	if (!srtp_crypto_empty(&srtp->tx_policy_neg) && !srtp_crypto_empty(&srtp->rx_policy_neg))
	{
	    
	    srtp->keying_cnt = 1;
	    srtp->keying[0] = srtp->keying[i];
	    srtp->keying_pending_cnt = 0;
	    break;
	}

	i++;
    }

    
    if (srtp->keying_cnt == 0)
	return keying_status;

    
    if (srtp->keying_pending_cnt)
	return PJ_SUCCESS;

    
    status = start_srtp(srtp);

    return status;
}


static pj_status_t transport_media_stop(pjmedia_transport *tp)
{
    struct transport_srtp *srtp = (struct transport_srtp*) tp;
    pj_status_t status;
    unsigned i;

    PJ_ASSERT_RETURN(tp, PJ_EINVAL);

    srtp->started = PJ_FALSE;

    
    for (i=0; i < srtp->keying_cnt; ++i) {
	pjmedia_transport_media_stop(srtp->keying[i]);
    }

    
    status = pjmedia_transport_media_stop(srtp->member_tp);
    if (status != PJ_SUCCESS)
	PJ_PERROR(4, (srtp->pool->obj_name, status, "SRTP failed stop underlying media transport."));

    
    return pjmedia_transport_srtp_stop(tp);
}



PJ_DEF(pj_status_t) pjmedia_transport_srtp_decrypt_pkt(pjmedia_transport *tp, pj_bool_t is_rtp, void *pkt, int *pkt_len)


{
    transport_srtp *srtp = (transport_srtp *)tp;
    srtp_err_status_t err;

    if (srtp->bypass_srtp)
	return PJ_SUCCESS;

    PJ_ASSERT_RETURN(tp && pkt && (*pkt_len>0), PJ_EINVAL);
    PJ_ASSERT_RETURN(srtp->session_inited, PJ_EINVALIDOP);

    
    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return PJ_EINVAL);

    pj_lock_acquire(srtp->mutex);

    if (!srtp->session_inited) {
	pj_lock_release(srtp->mutex);
	return PJ_EINVALIDOP;
    }

    if (is_rtp)
	err = srtp_unprotect(srtp->srtp_rx_ctx, pkt, pkt_len);
    else err = srtp_unprotect_rtcp(srtp->srtp_rx_ctx, pkt, pkt_len);

    if (err != srtp_err_status_ok) {
	PJ_LOG(5,(srtp->pool->obj_name, "Failed to unprotect SRTP, pkt size=%d, err=%s", *pkt_len, get_libsrtp_errstr(err)));

    }

    pj_lock_release(srtp->mutex);

    return (err==srtp_err_status_ok) ? PJ_SUCCESS :
				       PJMEDIA_ERRNO_FROM_LIBSRTP(err);
}


