









    #include <wolfssl/crl.h>



    #include <wolfssl/wolfcrypt/des3.h>


    #include <wolfssl/wolfcrypt/chacha.h>


    #include <wolfssl/wolfcrypt/asn.h>
    #include <wolfssl/wolfcrypt/pkcs12.h>


    #include <wolfssl/wolfcrypt/md5.h>


    #include <wolfssl/wolfcrypt/sha.h>


    #include <wolfssl/wolfcrypt/aes.h>


    #include <wolfssl/wolfcrypt/poly1305.h>


    #include <wolfssl/wolfcrypt/chacha20_poly1305.h>


    #include <wolfssl/wolfcrypt/port/aria/aria-crypt.h>


    #include <wolfssl/wolfcrypt/camellia.h>


    #include <wolfssl/wolfcrypt/sm4.h>



    #include <wolfssl/wolfcrypt/hmac.h>


    #include <wolfssl/wolfcrypt/arc4.h>


    #include <wolfssl/wolfcrypt/sha256.h>


    #include <wolfssl/wolfcrypt/sha512.h>


    #include <wolfssl/ocsp.h>


    #include <wolfssl/quic.h>


    #include <wolfssl/wolfcrypt/sha512.h>


    #include <wolfssl/wolfcrypt/sha512.h>


    #include <wolfssl/wolfcrypt/sm3.h>


    #include <wolfssl/wolfcrypt/sha512.h>


    #include <wolfssl/wolfcrypt/ripemd.h>


    #include <wolfssl/wolfcrypt/rsa.h>


    #include <wolfssl/wolfcrypt/ecc.h>


    #include <wolfssl/wolfcrypt/sm2.h>


    #include <wolfssl/wolfcrypt/dh.h>


    #include <wolfssl/wolfcrypt/ed25519.h>


    #include <wolfssl/wolfcrypt/curve25519.h>


    #include <wolfssl/wolfcrypt/ed448.h>


    #include <wolfssl/wolfcrypt/curve448.h>


    #include <wolfssl/wolfcrypt/falcon.h>
    #include <wolfssl/wolfcrypt/dilithium.h>


    #include <wolfssl/wolfcrypt/kdf.h>


    #if defined(HAVE_CHACHA) && defined(HAVE_POLY1305) &&  !defined(WOLFSSL_TICKET_ENC_AES128_GCM) && !defined(WOLFSSL_TICKET_ENC_AES256_GCM

        #include <wolfssl/wolfcrypt/chacha20_poly1305.h>
    #else
        #include <wolfssl/wolfcrypt/aes.h>
    #endif






    #include <wolfssl/callbacks.h>


    #include <signal.h>



    #ifdef WOLFSSL_GAME_BUILD
        #include "system/xtl.h"
    #else
        #if defined(_WIN32_WCE) || defined(WIN32_LEAN_AND_MEAN)
            
            #include <winsock2.h>
        #endif
        #include <windows.h>
    #endif

    #ifndef SINGLE_THREADED
        #include "tx_api.h"
    #endif


    

    

    

    

    

    

    #include "fsl_os_abstraction.h"

        

        

    #include "cmsis_os.h"

    #include "cmsis_os2.h"

    #if defined(WOLFSSL_MDK5)
        #include "cmsis_os.h"
    #else
        #include <rtl.h>
    #endif


    

    #include <rt.h>

    

    #if !defined(WOLFSSL_LWIP)
        void mynewt_ctx_clear(void *ctx);
        void* mynewt_ctx_new();
    #endif

    #ifndef SINGLE_THREADED
        #include <zephyr/kernel.h>
    #endif

    

    

    #ifndef SINGLE_THREADED
        #if defined(WOLFSSL_LINUXKM)
            
        #elif defined(WOLFSSL_USER_MUTEX)
            
        #else
            #define WOLFSSL_PTHREADS
            #include <pthread.h>
        #endif
    #endif
    #if defined(OPENSSL_EXTRA) && !defined(NO_FILESYSTEM)
        #ifdef FUSION_RTOS
           #include <fclunistd.h>
        #else
            #include <unistd.h>      
        #endif
    #endif



    
    #include <limits.h>




    #include "zlib.h"



    #include <wolfssl/wolfcrypt/async.h>



    #ifdef WOLFCRYPT_HAVE_SRP
        #include <wolfssl/wolfcrypt/srp.h>
    #endif



    
    #pragma warning(disable: 4996)



    #define WC_SHA_DIGEST_SIZE 20



    #define WC_SHA256_DIGEST_SIZE 32



    #define WC_MD5_DIGEST_SIZE 16



    #include <wolfssl/wolfcrypt/port/iotsafe/iotsafe.h>



    #include <wolfssl/wolfcrypt/port/Renesas/renesas-tsip-crypt.h>









    extern "C" {











    #error "You are trying to build max strength with requirements disabled."







    
    #undef HAVE_AES_CBC










    #if !defined(NO_RSA) && !defined(NO_RC4) && !defined(WSSL_HARDEN_TLS)
        
        #if defined(WOLFSSL_STATIC_RSA)
            #if !defined(NO_SHA)
                #define BUILD_SSL_RSA_WITH_RC4_128_SHA
            #endif
            #if !defined(NO_MD5)
                #define BUILD_SSL_RSA_WITH_RC4_128_MD5
            #endif
        #endif
    #endif

    #if !defined(NO_RSA) && !defined(NO_DES3)
        #if !defined(NO_SHA)
            #if defined(WOLFSSL_STATIC_RSA)
                #define BUILD_SSL_RSA_WITH_3DES_EDE_CBC_SHA
            #endif
        #endif
    #endif


    #if !defined(NO_RSA) && !defined(NO_AES) && !defined(NO_TLS)
        #if !defined(NO_SHA) && defined(HAVE_AES_CBC)
            #if defined(WOLFSSL_STATIC_RSA)
                #ifdef WOLFSSL_AES_128
                    #define BUILD_TLS_RSA_WITH_AES_128_CBC_SHA
                #endif
                #ifdef WOLFSSL_AES_256
                    #define BUILD_TLS_RSA_WITH_AES_256_CBC_SHA
                #endif
            #endif
        #endif
        #if defined(WOLFSSL_STATIC_RSA)
            #if !defined (NO_SHA256) && defined(HAVE_AES_CBC)
                #ifdef WOLFSSL_AES_128
                    #define BUILD_TLS_RSA_WITH_AES_128_CBC_SHA256
                #endif
                #ifdef WOLFSSL_AES_256
                    #define BUILD_TLS_RSA_WITH_AES_256_CBC_SHA256
                #endif
            #endif
            #if defined (HAVE_AESGCM)
                #ifdef WOLFSSL_AES_128
                    #define BUILD_TLS_RSA_WITH_AES_128_GCM_SHA256
                #endif
                #if defined (WOLFSSL_SHA384) && defined(WOLFSSL_AES_256)
                    #define BUILD_TLS_RSA_WITH_AES_256_GCM_SHA384
                #endif
            #endif
            #if defined (HAVE_AESCCM)
                #ifdef WOLFSSL_AES_128
                    #define BUILD_TLS_RSA_WITH_AES_128_CCM_8
                #endif
                #ifdef WOLFSSL_AES_256
                    #define BUILD_TLS_RSA_WITH_AES_256_CCM_8
                #endif
            #endif
        #endif
    #endif

    #if defined(HAVE_CAMELLIA) && !defined(NO_TLS) && !defined(NO_CAMELLIA_CBC)
        #ifndef NO_RSA
          #if defined(WOLFSSL_STATIC_RSA)
            #if !defined(NO_SHA)
                #define BUILD_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
                #define BUILD_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
            #endif
            #ifndef NO_SHA256
                #define BUILD_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
                #define BUILD_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
            #endif
          #endif
            #if !defined(NO_DH) && !defined(NO_TLS_DH)
              
              #if !defined(NO_SHA)
                #define BUILD_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
                #define BUILD_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
              #endif
                #ifndef NO_SHA256
                    #define BUILD_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
                    #define BUILD_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
                #endif
            #endif
        #endif
    #endif


    #if !defined(NO_PSK) && !defined(NO_AES) && !defined(NO_TLS)
        #if !defined(NO_SHA)
            #ifdef WOLFSSL_AES_128
                #define BUILD_TLS_PSK_WITH_AES_128_CBC_SHA
            #endif
            #ifdef WOLFSSL_AES_256
                #define BUILD_TLS_PSK_WITH_AES_256_CBC_SHA
            #endif
        #endif
        #ifndef NO_SHA256
            #ifdef WOLFSSL_AES_128
                #ifdef HAVE_AES_CBC
                    #define BUILD_TLS_PSK_WITH_AES_128_CBC_SHA256
                #endif
                #ifdef HAVE_AESGCM
                    #define BUILD_TLS_PSK_WITH_AES_128_GCM_SHA256
                #endif
            #endif 
            #ifdef HAVE_AESCCM
                #ifdef WOLFSSL_AES_128
                    #define BUILD_TLS_PSK_WITH_AES_128_CCM_8
                    #define BUILD_TLS_PSK_WITH_AES_128_CCM
                #endif
                #ifdef WOLFSSL_AES_256
                    #define BUILD_TLS_PSK_WITH_AES_256_CCM_8
                    #define BUILD_TLS_PSK_WITH_AES_256_CCM
                #endif
            #endif
        #endif
        #if defined(WOLFSSL_SHA384) && defined(WOLFSSL_AES_256)
            #ifdef HAVE_AES_CBC
                #define BUILD_TLS_PSK_WITH_AES_256_CBC_SHA384
            #endif
            #ifdef HAVE_AESGCM
                #define BUILD_TLS_PSK_WITH_AES_256_GCM_SHA384
            #endif
        #endif
    #endif


    #if !defined(NO_TLS) && defined(HAVE_NULL_CIPHER)
        #if !defined(NO_RSA)
            #if defined(WOLFSSL_STATIC_RSA)
                #ifndef NO_MD5
                    #define BUILD_TLS_RSA_WITH_NULL_MD5
                #endif
                #if !defined(NO_SHA)
                    #define BUILD_TLS_RSA_WITH_NULL_SHA
                #endif
                #ifndef NO_SHA256
                    #define BUILD_TLS_RSA_WITH_NULL_SHA256
                #endif
            #endif
        #endif
        #if !defined(NO_PSK) && defined(WOLFSSL_STATIC_PSK)
            #if !defined(NO_SHA)
                #define BUILD_TLS_PSK_WITH_NULL_SHA
            #endif
            #ifndef NO_SHA256
                #define BUILD_TLS_PSK_WITH_NULL_SHA256
            #endif
            #ifdef WOLFSSL_SHA384
                #define BUILD_TLS_PSK_WITH_NULL_SHA384
            #endif
        #endif
    #endif

    #if !defined(NO_DH) && !defined(NO_AES) && !defined(NO_TLS) &&  !defined(NO_RSA) && !defined(NO_TLS_DH
        

        #if !defined(NO_SHA)
            #if defined(WOLFSSL_AES_128) && defined(HAVE_AES_CBC)
                #define BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
            #endif
            #if defined(WOLFSSL_AES_256) && defined(HAVE_AES_CBC)
                #define BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
            #endif
            #if !defined(NO_DES3)
                #define BUILD_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
            #endif
        #endif
        #if !defined(NO_SHA256) && defined(HAVE_AES_CBC)
            #ifdef WOLFSSL_AES_128
                #define BUILD_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
            #endif
            #ifdef WOLFSSL_AES_256
                #define BUILD_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
            #endif
        #endif
    #endif

    #if defined(HAVE_ANON) && !defined(NO_TLS) && !defined(NO_DH) &&  !defined(NO_AES) && !defined(NO_SHA) && defined(WOLFSSL_AES_128
        #ifdef HAVE_AES_CBC
            #define BUILD_TLS_DH_anon_WITH_AES_128_CBC_SHA
        #endif

        #if defined(WOLFSSL_SHA384) && defined(HAVE_AESGCM)
            #define BUILD_TLS_DH_anon_WITH_AES_256_GCM_SHA384
        #endif
    #endif

    #if !defined(NO_DH) && !defined(NO_PSK) && !defined(NO_TLS) &&  !defined(NO_TLS_DH
        
        #ifndef NO_SHA256
            #if !defined(NO_AES) && defined(WOLFSSL_AES_128) &&  defined(HAVE_AES_CBC
                #define BUILD_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
            #endif
            #ifdef HAVE_NULL_CIPHER
                #define BUILD_TLS_DHE_PSK_WITH_NULL_SHA256
            #endif
        #endif
        #ifdef WOLFSSL_SHA384
            #if !defined(NO_AES) && defined(WOLFSSL_AES_256) &&  defined(HAVE_AES_CBC
                #define BUILD_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
            #endif
            #ifdef HAVE_NULL_CIPHER
                #define BUILD_TLS_DHE_PSK_WITH_NULL_SHA384
            #endif
        #endif
    #endif

    #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||  defined(HAVE_CURVE448)) && !defined(NO_TLS
        #if !defined(NO_AES)
            #if !defined(NO_SHA) && defined(HAVE_AES_CBC)
                #if !defined(NO_RSA)
                    #ifdef WOLFSSL_AES_128
                        #define BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
                    #endif
                    #ifdef WOLFSSL_AES_256
                        #define BUILD_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
                    #endif
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #ifdef WOLFSSL_AES_128
                            #define BUILD_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
                        #endif
                        #ifdef WOLFSSL_AES_256
                            #define BUILD_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
                        #endif
                    #endif
                #endif

                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #ifdef WOLFSSL_AES_128
                        #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
                    #endif
                    #ifdef WOLFSSL_AES_256
                        #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
                    #endif
                #endif

                #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                    #ifdef WOLFSSL_AES_128
                        #define BUILD_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
                    #endif
                    #ifdef WOLFSSL_AES_256
                        #define BUILD_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
                    #endif
                #endif
            #endif 
            #if !defined(NO_SHA256) && defined(WOLFSSL_AES_128) &&  defined(HAVE_AES_CBC
                #if !defined(NO_RSA)
                    #define BUILD_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #define BUILD_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
                    #endif
                #endif
                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
                #endif
                #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                    #define BUILD_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
                #endif
            #endif

            #if defined(WOLFSSL_SHA384) && defined(WOLFSSL_AES_256) &&  defined(HAVE_AES_CBC
                #if !defined(NO_RSA)
                    #define BUILD_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #define BUILD_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
                    #endif
                #endif
                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
                #endif
                #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                    #define BUILD_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
                #endif
            #endif

            #if defined (HAVE_AESGCM)
                #if !defined(NO_RSA)
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #ifdef WOLFSSL_AES_128
                            #define BUILD_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
                        #endif
                    #endif
                    #if defined(WOLFSSL_SHA384)
                        #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                            #ifdef WOLFSSL_AES_256
                                #define BUILD_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
                            #endif
                        #endif
                    #endif
                #endif

                #if defined(WOLFSSL_STATIC_DH) && defined(WOLFSSL_AES_128) &&  defined(HAVE_ECC
                    #define BUILD_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
                #endif

                #if defined(WOLFSSL_SHA384)
                    #if defined(WOLFSSL_STATIC_DH) &&  defined(WOLFSSL_AES_256) && defined(HAVE_ECC
                        #define BUILD_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
                    #endif
                #endif
            #endif
        #endif 
        #ifdef HAVE_ARIA
            #define BUILD_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256
            #define BUILD_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384
        #endif 
        #if !defined(NO_RC4) && !defined(WSSL_HARDEN_TLS)
            
            #if !defined(NO_SHA)
                #if !defined(NO_RSA)
                    #ifndef WOLFSSL_AEAD_ONLY
                        #define BUILD_TLS_ECDHE_RSA_WITH_RC4_128_SHA
                    #endif
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #define BUILD_TLS_ECDH_RSA_WITH_RC4_128_SHA
                    #endif
                #endif

                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #ifndef WOLFSSL_AEAD_ONLY
                        #define BUILD_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
                    #endif
                #endif
                #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                    #define BUILD_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
                #endif
            #endif
        #endif
        #if !defined(NO_DES3) && !(defined(WSSL_HARDEN_TLS) &&  WSSL_HARDEN_TLS > 112
            
            #ifndef NO_SHA
                #if !defined(NO_RSA)
                    #define BUILD_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
                    #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                        #define BUILD_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
                    #endif
                #endif

                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #define BUILD_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
                #endif
                #if defined(WOLFSSL_STATIC_DH) && defined(HAVE_ECC)
                    #define BUILD_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
                #endif
            #endif 
        #endif
        #if defined(HAVE_NULL_CIPHER)
            #if !defined(NO_SHA)
                #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                    #define BUILD_TLS_ECDHE_ECDSA_WITH_NULL_SHA
                #endif
            #endif
            #if !defined(NO_PSK) && !defined(NO_SHA256)
                #define BUILD_TLS_ECDHE_PSK_WITH_NULL_SHA256
            #endif
        #endif
        #if !defined(NO_PSK) && !defined(NO_SHA256) && !defined(NO_AES) &&  defined(WOLFSSL_AES_128) && defined(HAVE_AES_CBC
            #define BUILD_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
        #endif
        #if !defined(NO_PSK) && !defined(NO_SHA256) && !defined(NO_AES) &&  defined(WOLFSSL_AES_128) && defined(HAVE_AESGCM
            #define BUILD_TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256
        #endif
    #endif
    #if defined(HAVE_CHACHA) && defined(HAVE_POLY1305) && !defined(NO_SHA256)
        #if !defined(NO_OLD_POLY1305)
        #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

            #define BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256
        #endif
        #if !defined(NO_RSA) && defined(HAVE_ECC)
            #define BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
        #endif
        #if !defined(NO_DH) && !defined(NO_RSA) && !defined(NO_TLS_DH)
            
            #define BUILD_TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256
        #endif
        #endif 
        #if !defined(NO_PSK)
            #define BUILD_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256
            #if defined(HAVE_ECC) || defined(HAVE_ED25519) ||  defined(HAVE_ED448
                #define BUILD_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256
            #endif
            #if !defined(NO_DH) && !defined(NO_TLS_DH)
                
                #define BUILD_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256
            #endif
        #endif 
    #endif




    

    #if !defined(NO_SHA256) && defined(WOLFSSL_AES_128)
        #define BUILD_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    #endif

    #if defined(WOLFSSL_SHA384) && defined(WOLFSSL_AES_256)
        #define BUILD_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
    #endif



    
    #ifndef NO_SHA256
        #if defined(HAVE_AESGCM) && defined(WOLFSSL_AES_128)
            #define BUILD_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
        #endif
        #ifdef HAVE_AESCCM
            #ifdef WOLFSSL_AES_128
                #define BUILD_TLS_DHE_PSK_WITH_AES_128_CCM
            #endif
            #ifdef WOLFSSL_AES_256
                #define BUILD_TLS_DHE_PSK_WITH_AES_256_CCM
            #endif
        #endif
    #endif
    #if defined(WOLFSSL_SHA384) && defined(HAVE_AESGCM) &&  defined(WOLFSSL_AES_256
        #define BUILD_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
    #endif



    #ifdef HAVE_AESGCM
        #if !defined(NO_SHA256) && defined(WOLFSSL_AES_128)
            #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
            #endif
            #ifndef NO_RSA
                #define BUILD_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
            #endif
        #endif
        #if defined(WOLFSSL_SHA384) && defined(WOLFSSL_AES_256)
            #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

                #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
            #endif
            #ifndef NO_RSA
                #define BUILD_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
            #endif
        #endif
    #endif
    #if defined(HAVE_AESCCM) && !defined(NO_SHA256)
        #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

            #ifdef WOLFSSL_AES_128
                #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CCM
                #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8
            #endif
            #ifdef WOLFSSL_AES_256
                #define BUILD_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8
            #endif
        #endif
    #endif



    #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
        #if defined(HAVE_ECC) ||  (defined(HAVE_CURVE25519) && defined(HAVE_ED25519)) || (defined(HAVE_CURVE448) && defined(HAVE_ED448)

            #define BUILD_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
        #endif
        #ifndef NO_RSA
            #define BUILD_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
        #endif
    #endif
    #if !defined(NO_DH) && !defined(NO_RSA) && !defined(NO_TLS_DH)
        
        #define BUILD_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    #endif


    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        #ifdef WOLFSSL_SM4_CBC
            #define BUILD_TLS_ECDHE_ECDSA_WITH_SM4_CBC_SM3
        #endif
        #ifdef WOLFSSL_SM4_GCM
            #define BUILD_TLS_ECDHE_ECDSA_WITH_SM4_GCM_SM3
        #endif
        #ifdef WOLFSSL_SM4_CCM
            #define BUILD_TLS_ECDHE_ECDSA_WITH_SM4_CCM_SM3
        #endif
    #endif



    #ifdef HAVE_AESGCM
        #if !defined(NO_SHA256) && defined(WOLFSSL_AES_128)
            #define BUILD_TLS_AES_128_GCM_SHA256
        #endif
        #if defined(WOLFSSL_SHA384) && defined(WOLFSSL_AES_256)
            #define BUILD_TLS_AES_256_GCM_SHA384
        #endif
    #endif

    #if defined(HAVE_CHACHA) && defined(HAVE_POLY1305)
        #ifndef NO_SHA256
            #define BUILD_TLS_CHACHA20_POLY1305_SHA256
        #endif
    #endif

    #ifdef HAVE_AESCCM
        #if !defined(NO_SHA256) && defined(WOLFSSL_AES_128)
            #define BUILD_TLS_AES_128_CCM_SHA256
            #define BUILD_TLS_AES_128_CCM_8_SHA256
        #endif
    #endif
    #ifdef HAVE_NULL_CIPHER
        #ifndef NO_SHA256
            #define BUILD_TLS_SHA256_SHA256
        #endif
        #ifdef WOLFSSL_SHA384
            #define BUILD_TLS_SHA384_SHA384
        #endif
    #endif

    #ifdef WOLFSSL_SM3
        #ifdef WOLFSSL_SM4_GCM
            #define BUILD_TLS_SM4_GCM_SM3
        #endif

        #ifdef WOLFSSL_SM4_CCM
            #define BUILD_TLS_SM4_CCM_SM3
        #endif
    #endif





   #error "No cipher suites available with this build"



    #if defined(HAVE_NULL_CIPHER) && !defined(NO_SHA256)
        #define BUILD_WDM_WITH_NULL_SHA256
    #endif



    #define BUILD_ARC4



    #define BUILD_DES3





    #undef  BUILD_AES
    #define BUILD_AES















    #define BUILD_AESGCM

    
    #define NO_AESGCM_AEAD



    #define BUILD_ARIA











    

    
    #define NO_CHAPOL_AEAD



    #define DES_BLOCK_SIZE 8

    #undef  BUILD_DES3
    #define BUILD_DES3



    #define AES_BLOCK_SIZE 16
    #undef  BUILD_AES

    #undef  BUILD_AES
    #define BUILD_AES



    
    #undef  BUILD_ARC4
    #define BUILD_ARC4



    #define CHACHA20_BLOCK_SIZE 16










    #define HAVE_AEAD




    #define HAVE_PFS



    #ifdef HAVE_NULL_CIPHER
        #error "NULL ciphers not allowed https://www.rfc-editor.org/rfc/rfc9325#section-4.1"
    #endif
    #ifdef WOLFSSL_STATIC_RSA
        #error "Static RSA ciphers not allowed https://www.rfc-editor.org/rfc/rfc9325#section-4.1"
    #endif
    #ifdef WOLFSSL_STATIC_DH
        #error "Static DH ciphers not allowed https://www.rfc-editor.org/rfc/rfc9325#section-4.1"
    #endif
    #ifdef HAVE_ANON
        #error "At least the server side has to be authenticated"
    #endif











enum {
    TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x16, TLS_DHE_RSA_WITH_AES_256_CBC_SHA  = 0x39, TLS_DHE_RSA_WITH_AES_128_CBC_SHA  = 0x33, TLS_DH_anon_WITH_AES_128_CBC_SHA  = 0x34, TLS_RSA_WITH_AES_256_CBC_SHA      = 0x35, TLS_RSA_WITH_AES_128_CBC_SHA      = 0x2F, TLS_RSA_WITH_NULL_MD5             = 0x01, TLS_RSA_WITH_NULL_SHA             = 0x02, TLS_PSK_WITH_AES_256_CBC_SHA      = 0x8d, TLS_PSK_WITH_AES_128_CBC_SHA256   = 0xae, TLS_PSK_WITH_AES_256_CBC_SHA384   = 0xaf, TLS_PSK_WITH_AES_128_CBC_SHA      = 0x8c, TLS_PSK_WITH_NULL_SHA256          = 0xb0, TLS_PSK_WITH_NULL_SHA384          = 0xb1, TLS_PSK_WITH_NULL_SHA             = 0x2c, SSL_RSA_WITH_RC4_128_SHA          = 0x05, SSL_RSA_WITH_RC4_128_MD5          = 0x04, SSL_RSA_WITH_3DES_EDE_CBC_SHA     = 0x0A,   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA    = 0x14, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA    = 0x13, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA  = 0x0A, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA  = 0x09, TLS_ECDHE_RSA_WITH_RC4_128_SHA        = 0x11, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA      = 0x07, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA   = 0x12, TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0x08, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   = 0x27, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0x23, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   = 0x28, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0x24, TLS_ECDHE_ECDSA_WITH_NULL_SHA           = 0x06, TLS_ECDHE_PSK_WITH_NULL_SHA256          = 0x3a, TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256   = 0x37,   TLS_ECDH_RSA_WITH_AES_256_CBC_SHA    = 0x0F, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA    = 0x0E, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA  = 0x05, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA  = 0x04, TLS_ECDH_RSA_WITH_RC4_128_SHA        = 0x0C, TLS_ECDH_ECDSA_WITH_RC4_128_SHA      = 0x02, TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA   = 0x0D, TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0x03, TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256   = 0x29, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0x25, TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384   = 0x2A, TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0x26,  WDM_WITH_NULL_SHA256          = 0xFE,   TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x6b, TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x67, TLS_RSA_WITH_AES_256_CBC_SHA256     = 0x3d, TLS_RSA_WITH_AES_128_CBC_SHA256     = 0x3c, TLS_RSA_WITH_NULL_SHA256            = 0x3b, TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 0xb2, TLS_DHE_PSK_WITH_NULL_SHA256        = 0xb4,   TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 0xb3, TLS_DHE_PSK_WITH_NULL_SHA384        = 0xb5,   TLS_RSA_WITH_AES_128_GCM_SHA256          = 0x9c, TLS_RSA_WITH_AES_256_GCM_SHA384          = 0x9d, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      = 0x9e, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384      = 0x9f, TLS_DH_anon_WITH_AES_256_GCM_SHA384      = 0xa7, TLS_PSK_WITH_AES_128_GCM_SHA256          = 0xa8, TLS_PSK_WITH_AES_256_GCM_SHA384          = 0xa9, TLS_DHE_PSK_WITH_AES_128_GCM_SHA256      = 0xaa, TLS_DHE_PSK_WITH_AES_256_GCM_SHA384      = 0xab,   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256  = 0x2b, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384  = 0x2c, TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256   = 0x2d, TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384   = 0x2e, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    = 0x2f, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384    = 0x30, TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256     = 0x31, TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384     = 0x32,   TLS_RSA_WITH_AES_128_CCM_8         = 0xa0, TLS_RSA_WITH_AES_256_CCM_8         = 0xa1, TLS_ECDHE_ECDSA_WITH_AES_128_CCM   = 0xac, TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xae, TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xaf, TLS_PSK_WITH_AES_128_CCM           = 0xa4, TLS_PSK_WITH_AES_256_CCM           = 0xa5, TLS_PSK_WITH_AES_128_CCM_8         = 0xa8, TLS_PSK_WITH_AES_256_CCM_8         = 0xa9, TLS_DHE_PSK_WITH_AES_128_CCM       = 0xa6, TLS_DHE_PSK_WITH_AES_256_CCM       = 0xa7,   TLS_RSA_WITH_CAMELLIA_128_CBC_SHA        = 0x41, TLS_RSA_WITH_CAMELLIA_256_CBC_SHA        = 0x84, TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256     = 0xba, TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256     = 0xc0, TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA    = 0x45, TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA    = 0x88, TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xbe, TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0xc4,   TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   = 0xa8, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xa9, TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256     = 0xaa, TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256   = 0xac, TLS_PSK_WITH_CHACHA20_POLY1305_SHA256         = 0xab, TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256     = 0xad,   TLS_ECDHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256   = 0x13, TLS_ECDHE_ECDSA_WITH_CHACHA20_OLD_POLY1305_SHA256 = 0x14, TLS_DHE_RSA_WITH_CHACHA20_OLD_POLY1305_SHA256     = 0x15,   TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256    = 0x01,   TLS_AES_128_GCM_SHA256       = 0x01, TLS_AES_256_GCM_SHA384       = 0x02, TLS_CHACHA20_POLY1305_SHA256 = 0x03, TLS_AES_128_CCM_SHA256       = 0x04, TLS_AES_128_CCM_8_SHA256     = 0x05,   TLS_SHA256_SHA256            = 0xB4, TLS_SHA384_SHA384            = 0xB5,   TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256   = 0x5c, TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384   = 0x5d,   TLS_SM4_GCM_SM3              = 0xC6, TLS_SM4_CCM_SM3              = 0xC7,   TLS_ECDHE_ECDSA_WITH_SM4_CBC_SM3 = 0x11, TLS_ECDHE_ECDSA_WITH_SM4_GCM_SM3 = 0x51, TLS_ECDHE_ECDSA_WITH_SM4_CCM_SM3 = 0x52,   TLS_FALLBACK_SCSV                        = 0x56,  TLS_EMPTY_RENEGOTIATION_INFO_SCSV        = 0xff };



























































































































































    #define WOLFSSL_SESSION_TIMEOUT 500
    




    #define WOLFSSL_DTLS_WINDOW_WORDS 2






    #define WOLFSSL_DTLS_PEERSEQ_SZ 1

    #ifndef WOLFSSL_MULTICAST_PEERS
        
        #define WOLFSSL_MULTICAST_PEERS 100
    #endif
    #define WOLFSSL_DTLS_PEERSEQ_SZ WOLFSSL_MULTICAST_PEERS



    
    #define WOLFSSL_MAX_MTU 1400



    #define WOLFSSL_DTLS_MTU_ADDITIONAL_READ_BUFFER 500



    #define WOLFSSL_DTLS_FRAG_POOL_SZ 10




    #if defined(WOLFSSL_HARDEN_TLS) && !defined(WOLFSSL_HARDEN_TLS_NO_PKEY_CHECK)
        
        #if WOLFSSL_HARDEN_TLS >= 128
            #define WOLFSSL_MIN_DHKEY_BITS 3072
        #elif WOLFSSL_HARDEN_TLS >= 112
            #define WOLFSSL_MIN_DHKEY_BITS 2048
        #endif
    #elif defined(WOLFSSL_MAX_STRENGTH)
        #define WOLFSSL_MIN_DHKEY_BITS 2048
    #else
        #define WOLFSSL_MIN_DHKEY_BITS 1024
    #endif


    
    #error "For 112 bits of security DH needs at least 2048 bit keys"


    #error DH minimum bit size must be multiple of 8


    #error DH minimum bit size must not be greater than 16000




    #if (defined(USE_FAST_MATH) && defined(FP_MAX_BITS) && FP_MAX_BITS >= 16384)
        #define WOLFSSL_MAX_DHKEY_BITS  (FP_MAX_BITS / 2)
    #elif (defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_SP_MATH)) &&  defined(SP_INT_BITS
        
        #define WOLFSSL_MAX_DHKEY_BITS  (((SP_INT_BITS + 7) / 8) * 8)
    #else
        #define WOLFSSL_MAX_DHKEY_BITS  4096
    #endif


    #error DH maximum bit size must be multiple of 8


    #error DH maximum bit size must not be greater than 16384










    
    #if defined(WOLFSSL_TLS13)
        
        #define MAX_PSK_ID_LEN 1536
    #else
        #define MAX_PSK_ID_LEN 128
    #endif



    
    #define MAX_EARLY_DATA_SZ  4096



    #ifndef WOLFSSL_MAX_RSA_BITS
        #ifdef USE_FAST_MATH
            
            #define WOLFSSL_MAX_RSA_BITS    (FP_MAX_BITS / 2)
        #elif defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_SP_MATH)
            
            #define WOLFSSL_MAX_RSA_BITS    (((SP_INT_BITS + 7) / 8) * 8)
        #else
            
            #define WOLFSSL_MAX_RSA_BITS 4096
        #endif
    #endif
    #if (WOLFSSL_MAX_RSA_BITS % 8)
        #error RSA maximum bit size must be multiple of 8
    #endif




    
    #if defined(USE_FAST_MATH) && defined(FP_MAX_BITS)
        
        #if FP_MAX_BITS >= 16384
            #define ENCRYPT_BASE_BITS  8192
        #elif defined(HAVE_ECC)
            #if FP_MAX_BITS > 2224
                #define ENCRYPT_BASE_BITS  (FP_MAX_BITS / 2)
            #else
                
                #define ENCRYPT_BASE_BITS  1112
            #endif
        #else
            #if FP_MAX_BITS > 2048
                #define ENCRYPT_BASE_BITS  (FP_MAX_BITS / 2)
            #else
                #define ENCRYPT_BASE_BITS  1024
            #endif
        #endif

        
        #if defined(WOLFSSL_MYSQL_COMPATIBLE) && ENCRYPT_BASE_BITS < 8192
            #error "MySQL needs FP_MAX_BITS at least at 16384"
        #endif

        #if !defined(NO_RSA) && defined(WOLFSSL_MAX_RSA_BITS) &&  WOLFSSL_MAX_RSA_BITS > ENCRYPT_BASE_BIT
            #error "FP_MAX_BITS too small for WOLFSSL_MAX_RSA_BITS"
        #endif
    #elif defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_SP_MATH)
        
        #if SP_INT_BITS >= 8192
            #define ENCRYPT_BASE_BITS  8192
        #elif defined(HAVE_ECC)
            #if SP_INT_BITS > 1112
                #define ENCRYPT_BASE_BITS  SP_INT_BITS
            #else
                
                #define ENCRYPT_BASE_BITS  1112
            #endif
        #else
            #if SP_INT_BITS > 1024
                #define ENCRYPT_BASE_BITS  SP_INT_BITS
            #else
                #define ENCRYPT_BASE_BITS  1024
            #endif
        #endif

        
        #if defined(WOLFSSL_MYSQL_COMPATIBLE) && ENCRYPT_BASE_BITS < 8192
            #error "MySQL needs SP_INT_BITS at least at 8192"
        #endif

        #if !defined(NO_RSA) && defined(WOLFSSL_MAX_RSA_BITS) &&  WOLFSSL_MAX_RSA_BITS > SP_INT_BIT
            #error "SP_INT_BITS too small for WOLFSSL_MAX_RSA_BITS"
        #endif
    #else
        
        #define ENCRYPT_BASE_BITS  4096
    #endif

    #define ENCRYPT_BASE_BITS    (456 * 2)

    #define ENCRYPT_BASE_BITS    (256 * 2)

    
    #define ENCRYPT_BASE_BITS  ((MAX_PSK_ID_LEN + 2) * 8)











































































enum Misc {
    CIPHER_BYTE    = 0x00,          ECC_BYTE       = 0xC0, CHACHA_BYTE    = 0xCC, TLS13_BYTE     = 0x13, ECDHE_PSK_BYTE = 0xD0, SM_BYTE        = 0xE0,  SEND_CERT       = 1, SEND_BLANK_CERT = 2,  DTLS_MAJOR      = 0xfe, DTLS_MINOR      = 0xff, DTLS_BOGUS_MINOR = 0xfe, DTLSv1_2_MINOR  = 0xfd, DTLSv1_3_MINOR  = 0xfc, SSLv3_MAJOR     = 3, SSLv3_MINOR     = 0, TLSv1_MINOR     = 1, TLSv1_1_MINOR   = 2, TLSv1_2_MINOR   = 3, TLSv1_3_MINOR   = 4, TLS_DRAFT_MAJOR = 0x7f, OLD_HELLO_ID    = 0x01, INVALID_BYTE    = 0xff, NO_COMPRESSION  =  0, ZLIB_COMPRESSION = 221, HELLO_EXT_SIG_ALGO = 13, HELLO_EXT_EXTMS = 0x0017, SECRET_LEN      = WOLFSSL_MAX_MASTER_KEY_LENGTH,   TIMESTAMP_LEN   = 4,  TIMESTAMP_LEN   = 8,   AGEADD_LEN      = 4, NAMEDGROUP_LEN  = 2,  MAXEARLYDATASZ_LEN = 4,    ENCRYPT_LEN     = 4600,   ENCRYPT_LEN     = (ENCRYPT_BASE_BITS / 8) + MAX_PSK_ID_LEN + 2,  ENCRYPT_LEN     = (ENCRYPT_BASE_BITS / 8),   SIZEOF_SENDER   =  4, FINISHED_SZ     = 36, MAX_RECORD_SIZE = 16384, MAX_PLAINTEXT_SZ   = (1 << 14), MAX_TLS_CIPHER_SZ  = (1 << 14) + 2048,  MAX_TLS13_PLAIN_SZ = (1 << 14) + 1, MAX_TLS13_ENC_SZ   = (1 << 14) + 256,  MAX_MSG_EXTRA   = 38 + WC_MAX_DIGEST_SIZE,   MAX_COMP_EXTRA  = 1024, MAX_MTU         = WOLFSSL_MAX_MTU, MAX_UDP_SIZE    = 8192 - 100, MAX_DH_SZ       = (MAX_DHKEY_SZ * 3) + 12,  MAX_STR_VERSION = 8,  PAD_MD5        = 48, PAD_SHA        = 40, MAX_PAD_SIZE   = 256,  LENGTH_SZ      =  2, VERSION_SZ     =  2, SEQ_SZ         =  8, ALERT_SIZE     =  2, VERIFY_HEADER  =  2, EXTS_SZ        =  2, EXT_ID_SZ      =  2, MAX_DH_SIZE    = MAX_DHKEY_SZ+1,  MIN_FFHDE_GROUP = 0x100, MAX_FFHDE_GROUP = 0x1FF, SESSION_HINT_SZ = 4, SESSION_ADD_SZ = 4, TICKET_NONCE_LEN_SZ = 1, DEF_TICKET_NONCE_SZ = 1,  MAX_TICKET_NONCE_STATIC_SZ = TLS13_TICKET_NONCE_STATIC_SZ,   MAX_LIFETIME   = 604800,  RAN_LEN      = 32, SEED_LEN     = RAN_LEN * 2, ID_LEN       = 32, COOKIE_SECRET_SZ = 14, MAX_COOKIE_LEN = 32, COOKIE_SZ    = 20, SUITE_LEN    =  2, ENUM_LEN     =  1, OPAQUE8_LEN  =  1, OPAQUE16_LEN =  2, OPAQUE24_LEN =  3, OPAQUE32_LEN =  4, OPAQUE64_LEN =  8, COMP_LEN     =  1, CURVE_LEN    =  2, KE_GROUP_LEN =  2,  SERVER_ID_LEN = WC_SHA256_DIGEST_SIZE,  SERVER_ID_LEN = WC_SHA_DIGEST_SIZE,   HANDSHAKE_HEADER_SZ   = 4, RECORD_HEADER_SZ      = 5, CERT_HEADER_SZ        = 3, REQ_HEADER_SZ         = 2, HINT_LEN_SZ           = 2, TRUNCATED_HMAC_SZ     = 10, HELLO_EXT_SZ          = 4, HELLO_EXT_TYPE_SZ     = 2, HELLO_EXT_SZ_SZ       = 2, HELLO_EXT_SIGALGO_SZ  = 2,  DTLS_HANDSHAKE_HEADER_SZ = 12, DTLS_RECORD_HEADER_SZ    = 13, DTLS_UNIFIED_HEADER_MIN_SZ = 2,  DTLS_RECVD_RL_HEADER_MAX_SZ = 5 + DTLS_CID_MAX_SIZE, DTLS_RECORD_HEADER_MAX_SZ = 13, DTLS_HANDSHAKE_EXTRA     = 8, DTLS_RECORD_EXTRA        = 8, DTLS_HANDSHAKE_SEQ_SZ    = 2, DTLS_HANDSHAKE_FRAG_SZ   = 3, DTLS_POOL_SZ             = 20, DTLS_FRAG_POOL_SZ        = WOLFSSL_DTLS_FRAG_POOL_SZ,  DTLS_EXPORT_PRO          = 165, DTLS_EXPORT_STATE_PRO    = 166, TLS_EXPORT_PRO           = 167, DTLS_EXPORT_OPT_SZ       = 62, DTLS_EXPORT_OPT_SZ_4     = 61, TLS_EXPORT_OPT_SZ        = 65, DTLS_EXPORT_OPT_SZ_3     = 60, DTLS_EXPORT_KEY_SZ       = 325 + (DTLS_SEQ_SZ * 2),  DTLS_EXPORT_MIN_KEY_SZ   = 85 + (DTLS_SEQ_SZ * 2),  WOLFSSL_EXPORT_TLS       = 1, WOLFSSL_EXPORT_DTLS      = 0,  WOLFSSL_EXPORT_SPC_SZ    = 16,  WOLFSSL_EXPORT_LEN       = 2, WOLFSSL_EXPORT_VERSION   = 5,  WOLFSSL_EXPORT_VERSION_4 = 4,  WOLFSSL_EXPORT_VERSION_3 = 3,  MAX_EXPORT_IP            = 46, DTLS_MTU_ADDITIONAL_READ_BUFFER = WOLFSSL_DTLS_MTU_ADDITIONAL_READ_BUFFER,  MAX_EXPORT_BUFFER        = 514, MAX_EXPORT_STATE_BUFFER  = (DTLS_EXPORT_MIN_KEY_SZ) + (3 * WOLFSSL_EXPORT_LEN),  FINISHED_LABEL_SZ   = 15, TLS_FINISHED_SZ     = 12, TLS_FINISHED_SZ_MAX = WC_MAX_DIGEST_SIZE,  EXT_MASTER_LABEL_SZ = 22, MASTER_LABEL_SZ     = 13, KEY_LABEL_SZ        = 13, PROTOCOL_LABEL_SZ   = 9, MAX_LABEL_SZ        = 34, MAX_REQUEST_SZ      = 256, SESSION_FLUSH_COUNT = 256, TLS_MAX_PAD_SZ      = 255,   #if defined(WOLFSSL_SHA384) && WC_MAX_SYM_KEY_SIZE < 48























































































































































































        MAX_SYM_KEY_SIZE    = WC_SHA384_DIGEST_SIZE, #elif !defined(NO_SHA256) && WC_MAX_SYM_KEY_SIZE < 32
        MAX_SYM_KEY_SIZE    = WC_SHA256_DIGEST_SIZE, #else
        MAX_SYM_KEY_SIZE    = WC_MAX_SYM_KEY_SIZE, #endif

    MAX_SYM_KEY_SIZE    = WC_MAX_SYM_KEY_SIZE,    #ifndef WOLFSSL_AES_KEY_SIZE_ENUM



    #define WOLFSSL_AES_KEY_SIZE_ENUM
    AES_IV_SIZE         = 16, AES_128_KEY_SIZE    = 16, AES_192_KEY_SIZE    = 24, AES_256_KEY_SIZE    = 32, #endif





    MAX_IV_SZ           = AES_BLOCK_SIZE,  AEAD_SEQ_OFFSET     = 4, AEAD_TYPE_OFFSET    = 8, AEAD_VMAJ_OFFSET    = 9, AEAD_VMIN_OFFSET    = 10, AEAD_LEN_OFFSET     = 11, AEAD_AUTH_DATA_SZ   = 13, AEAD_NONCE_SZ       = 12, AESGCM_IMP_IV_SZ    = 4, AESGCM_EXP_IV_SZ    = 8, AESGCM_NONCE_SZ     = AESGCM_EXP_IV_SZ + AESGCM_IMP_IV_SZ, GCM_IMP_IV_SZ       = 4, GCM_EXP_IV_SZ       = 8, GCM_NONCE_SZ        = GCM_EXP_IV_SZ + GCM_IMP_IV_SZ,  CHACHA20_IMP_IV_SZ  = 12, CHACHA20_NONCE_SZ   = 12, CHACHA20_OLD_OFFSET = 4,    AES_GCM_AUTH_SZ     = 16, AES_CCM_16_AUTH_SZ  = 16, AES_CCM_8_AUTH_SZ   = 8, AESCCM_NONCE_SZ     = 12,  SM4_GCM_AUTH_SZ     = 16, SM4_GCM_NONCE_SZ    = 12, SM4_CCM_AUTH_SZ     = 16, SM4_CCM_NONCE_SZ    = 12,  CAMELLIA_128_KEY_SIZE = 16, CAMELLIA_192_KEY_SIZE = 24, CAMELLIA_256_KEY_SIZE = 32, CAMELLIA_IV_SIZE      = 16,  CHACHA20_256_KEY_SIZE = 32, CHACHA20_128_KEY_SIZE = 16, CHACHA20_IV_SIZE      = 12,  POLY1305_AUTH_SZ    = 16,  HMAC_NONCE_SZ       = 12,  EVP_SALT_SIZE       =  8,   ECDHE_SIZE          = 32,  MAX_EXPORT_ECC_SZ   = 256, MAX_CURVE_NAME_SZ   = 16,  NEW_SA_MAJOR        = 8, ED25519_SA_MAJOR    = 8, ED25519_SA_MINOR    = 7, ED448_SA_MAJOR      = 8, ED448_SA_MINOR      = 8, SM2_SA_MAJOR        = 7, SM2_SA_MINOR        = 8,  PQC_SA_MAJOR        = 0xFE,   FALCON_LEVEL1_SA_MAJOR = 0xFE, FALCON_LEVEL1_SA_MINOR = 0x0B, FALCON_LEVEL5_SA_MAJOR = 0xFE, FALCON_LEVEL5_SA_MINOR = 0x0E,  DILITHIUM_LEVEL2_SA_MAJOR = 0xFE, DILITHIUM_LEVEL2_SA_MINOR = 0xA0, DILITHIUM_LEVEL3_SA_MAJOR = 0xFE, DILITHIUM_LEVEL3_SA_MINOR = 0xA3, DILITHIUM_LEVEL5_SA_MAJOR = 0xFE, DILITHIUM_LEVEL5_SA_MINOR = 0xA5,  MIN_RSA_SHA512_PSS_BITS = 512 * 2 + 8 * 8, MIN_RSA_SHA384_PSS_BITS = 384 * 2 + 8 * 8,   MAX_CERT_VERIFY_SZ = 6000,  MAX_CERT_VERIFY_SZ = WOLFSSL_MAX_RSA_BITS / 8,  MAX_CERT_VERIFY_SZ = ECC_MAX_SIG_SIZE,  MAX_CERT_VERIFY_SZ = ED448_SIG_SIZE,  MAX_CERT_VERIFY_SZ = ED25519_SIG_SIZE,  MAX_CERT_VERIFY_SZ = 1024,  CLIENT_HELLO_FIRST =  35, MAX_SUITE_NAME     =  48,  DTLS_TIMEOUT_INIT       =  1, DTLS_TIMEOUT_MAX        = 64, DTLS_TIMEOUT_MULTIPLIER =  2,  NULL_TERM_LEN        =   1, MAX_PSK_KEY_LEN      =  64, MIN_PSK_ID_LEN       =   6, MIN_PSK_BINDERS_LEN  =  33,   MAX_WOLFSSL_FILE_SIZE = 1024UL * 1024UL * 4,   CERT_MIN_SIZE      =  256,  NO_SNIFF           =   0, SNIFF              =   1,  HASH_SIG_SIZE      =   2,  NO_COPY            =   0, COPY               =   1,  INVALID_PEER_ID    = 0xFFFF,  PREV_ORDER         = -1, PEER_ORDER         = 1, CUR_ORDER          = 0, WRITE_PROTO        = 1, READ_PROTO         = 0 };






































































































































    #ifndef NO_OLD_TLS
        #define WOLFSSL_MIN_DOWNGRADE TLSv1_MINOR
    #else
        #define WOLFSSL_MIN_DOWNGRADE TLSv1_2_MINOR
    #endif















    #define WOLFSSL_MAX_SUITE_SZ 300
    





    
    #define WOLFSSL_MAX_SIGALGO 128

    #define WOLFSSL_MAX_SIGALGO 38






    #ifdef WOLFSSL_MAX_STRENGTH
        #define WOLFSSL_MIN_ECC_BITS  256
    #else
        #define WOLFSSL_MIN_ECC_BITS 224
    #endif


    
    #error ECC minimum bit size must be a multiple of 8





    #define MIN_FALCONKEY_SZ    897


    #define MIN_DILITHIUMKEY_SZ    1312





    #if defined(WOLFSSL_HARDEN_TLS) && !defined(WOLFSSL_HARDEN_TLS_NO_PKEY_CHECK)
        
        #if WOLFSSL_HARDEN_TLS >= 128
            #define WOLFSSL_MIN_RSA_BITS 3072
        #elif WOLFSSL_HARDEN_TLS >= 112
            #define WOLFSSL_MIN_RSA_BITS 2048
        #endif
    #elif defined(WOLFSSL_MAX_STRENGTH)
        #define WOLFSSL_MIN_RSA_BITS 2048
    #else
        #define WOLFSSL_MIN_RSA_BITS 1024
    #endif


    
    #error "For 112 bits of security RSA needs at least 2048 bit keys"


    
    #error RSA minimum bit size must be a multiple of 8










    #if defined(HAVE_PQC)
        #define MAX_X509_SIZE   (8*1024) 
    #elif defined(WOLFSSL_HAPROXY)
        #define MAX_X509_SIZE   3072 
    #else
        #define MAX_X509_SIZE   2048 
    #endif




    #define MAX_CHAIN_DEPTH 9





    #define MAX_CERTIFICATE_SZ  (CERT_HEADER_SZ + (MAX_X509_SIZE + CERT_HEADER_SZ) * MAX_CHAIN_DEPTH





    #define MAX_HANDSHAKE_SZ MAX_CERTIFICATE_SZ



    #define PREALLOC_SESSION_TICKET_LEN 512



    #define PREALLOC_SESSION_TICKET_NONCE_LEN 32



    #define SESSION_TICKET_HINT_DEFAULT 300



    
    #if !(defined(HAVE_CHACHA) && defined(HAVE_POLY1305)) &&  defined(WOLFSSL_TICKET_ENC_CHACHA20_POLY1305
        #error "ChaCha20-Poly1305 not available for default ticket encryption"
    #endif
    #if !defined(HAVE_AESGCM) && (defined(WOLFSSL_TICKET_ENC_AES128_GCM) ||  defined(WOLFSSL_TICKET_ENC_AES256_GCM)
        #error "AES-GCM not available for default ticket encryption"
    #endif

    #ifndef WOLFSSL_TICKET_KEY_LIFETIME
        
        #define WOLFSSL_TICKET_KEY_LIFETIME       (60 * 60)
    #endif
    #if WOLFSSL_TICKET_KEY_LIFETIME <= SESSION_TICKET_HINT_DEFAULT
        #error "Ticket Key lifetime must be longer than ticket life hint."
    #endif
















enum states {
    NULL_STATE = 0,  SERVER_HELLOVERIFYREQUEST_COMPLETE, SERVER_HELLO_RETRY_REQUEST_COMPLETE, SERVER_HELLO_COMPLETE, SERVER_ENCRYPTED_EXTENSIONS_COMPLETE, SERVER_CERT_COMPLETE, SERVER_CERT_VERIFY_COMPLETE, SERVER_KEYEXCHANGE_COMPLETE, SERVER_HELLODONE_COMPLETE, SERVER_CHANGECIPHERSPEC_COMPLETE, SERVER_FINISHED_COMPLETE,  CLIENT_HELLO_RETRY, CLIENT_HELLO_COMPLETE, CLIENT_KEYEXCHANGE_COMPLETE, CLIENT_CHANGECIPHERSPEC_COMPLETE, CLIENT_FINISHED_COMPLETE,  HANDSHAKE_DONE,   SERVER_FINISHED_ACKED,   };


























typedef struct ProtocolVersion {
    byte major;
    byte minor;
} WOLFSSL_PACK ProtocolVersion;


WOLFSSL_LOCAL ProtocolVersion MakeSSLv3(void);
WOLFSSL_LOCAL ProtocolVersion MakeTLSv1(void);
WOLFSSL_LOCAL ProtocolVersion MakeTLSv1_1(void);
WOLFSSL_LOCAL ProtocolVersion MakeTLSv1_2(void);
WOLFSSL_LOCAL ProtocolVersion MakeTLSv1_3(void);


    WOLFSSL_LOCAL ProtocolVersion MakeDTLSv1(void);
    WOLFSSL_LOCAL ProtocolVersion MakeDTLSv1_2(void);


    WOLFSSL_LOCAL ProtocolVersion MakeDTLSv1_3(void);




WOLFSSL_LOCAL int wolfSSL_session_export_internal(WOLFSSL* ssl, byte* buf, word32* sz, int type);
WOLFSSL_LOCAL int wolfSSL_session_import_internal(WOLFSSL* ssl, const byte* buf, word32 sz, int type);

    WOLFSSL_LOCAL int wolfSSL_dtls_export_state_internal(WOLFSSL* ssl, byte* buf, word32 sz);
    WOLFSSL_LOCAL int wolfSSL_dtls_import_state_internal(WOLFSSL* ssl, const byte* buf, word32 sz);
    WOLFSSL_LOCAL int wolfSSL_send_session(WOLFSSL* ssl);



struct WOLFSSL_BY_DIR_HASH {
    unsigned long hash_value;
    int last_suffix;
};

struct WOLFSSL_BY_DIR_entry {
    char*   dir_name;
    int     dir_type;
    WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH) *hashes;
};

struct WOLFSSL_BY_DIR {
    WOLF_STACK_OF(WOLFSSL_BY_DIR_entry) *dir_entry;
    wolfSSL_Mutex    lock; 
};


struct WOLFSSL_METHOD {
    ProtocolVersion version;
    byte            side;         
    byte            downgrade;    
};


typedef WOLFSSL_BUFFER_INFO buffer;

typedef struct Suites Suites;



    typedef struct ClientSession ClientSession;
    #define WOLFSSL_CLIENT_SESSION_DEFINED



WOLFSSL_LOCAL void InitSSL_Method(WOLFSSL_METHOD* method, ProtocolVersion pv);

WOLFSSL_LOCAL void InitSSL_CTX_Suites(WOLFSSL_CTX* ctx);
WOLFSSL_LOCAL int InitSSL_Suites(WOLFSSL* ssl);
WOLFSSL_LOCAL int InitSSL_Side(WOLFSSL* ssl, word16 side);


WOLFSSL_LOCAL int DoHandShakeMsgType(WOLFSSL* ssl, byte* input, word32* inOutIdx, byte type, word32 size, word32 totalSz);

WOLFSSL_LOCAL int DoFinished(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 size, word32 totalSz, int sniff);

WOLFSSL_LOCAL int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 size, word32 totalSz, int sniff);

WOLFSSL_LOCAL int DoApplicationData(WOLFSSL* ssl, byte* input, word32* inOutIdx, int sniff);

WOLFSSL_LOCAL int  HandleTlsResumption(WOLFSSL* ssl, Suites* clSuites);

WOLFSSL_LOCAL byte SuiteMac(const byte* suite);

WOLFSSL_LOCAL int  DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 helloSz);

WOLFSSL_LOCAL int DoTls13ClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 helloSz);

WOLFSSL_LOCAL int  DoServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 helloSz);
WOLFSSL_LOCAL int  CompleteServerHello(WOLFSSL *ssl);
WOLFSSL_LOCAL int  CheckVersion(WOLFSSL *ssl, ProtocolVersion pv);
WOLFSSL_LOCAL int  PickHashSigAlgo(WOLFSSL* ssl, const byte* hashSigAlgo, word32 hashSigAlgoSz);

WOLFSSL_LOCAL int  CreateDevPrivateKey(void** pkey, byte* data, word32 length, int hsType, int label, int id, void* heap, int devId);


WOLFSSL_LOCAL int  DecodePrivateKey(WOLFSSL *ssl, word16* length);

WOLFSSL_LOCAL int GetPrivateKeySigSize(WOLFSSL* ssl);

    WOLFSSL_LOCAL int  InitSigPkCb(WOLFSSL* ssl, SignatureCtx* sigCtx);


WOLFSSL_LOCAL int CreateSigData(WOLFSSL* ssl, byte* sigData, word16* sigDataSz, int check);
WOLFSSL_LOCAL int CreateRSAEncodedSig(byte* sig, byte* sigData, int sigDataSz, int sigAlgo, int hashAlgo);

WOLFSSL_LOCAL void FreeAsyncCtx(WOLFSSL* ssl, byte freeAsync);

WOLFSSL_LOCAL void FreeKeyExchange(WOLFSSL* ssl);
WOLFSSL_LOCAL void FreeSuites(WOLFSSL* ssl);
WOLFSSL_LOCAL int  ProcessPeerCerts(WOLFSSL* ssl, byte* input, word32* inOutIdx, word32 totalSz);
WOLFSSL_LOCAL int  MatchDomainName(const char* pattern, int len, const char* str);

WOLFSSL_LOCAL int  CheckForAltNames(DecodedCert* dCert, const char* domain, int* checkCN);
WOLFSSL_LOCAL int  CheckIPAddr(DecodedCert* dCert, const char* ipasc);
WOLFSSL_LOCAL void CopyDecodedName(WOLFSSL_X509_NAME* name, DecodedCert* dCert, int nameType);

WOLFSSL_LOCAL int  SetupTicket(WOLFSSL* ssl);
WOLFSSL_LOCAL int  CreateTicket(WOLFSSL* ssl);
WOLFSSL_LOCAL int  HashRaw(WOLFSSL* ssl, const byte* output, int sz);
WOLFSSL_LOCAL int  HashOutput(WOLFSSL* ssl, const byte* output, int sz, int ivSz);
WOLFSSL_LOCAL int  HashInput(WOLFSSL* ssl, const byte* input, int sz);



WOLFSSL_LOCAL int SNI_Callback(WOLFSSL* ssl);




WOLFSSL_LOCAL int ALPN_Select(WOLFSSL* ssl);


WOLFSSL_LOCAL int ChachaAEADEncrypt(WOLFSSL* ssl, byte* out, const byte* input, word16 sz);
WOLFSSL_LOCAL int ChachaAEADDecrypt(WOLFSSL* ssl, byte* plain, const byte* input, word16 sz);


WOLFSSL_LOCAL int  DecryptTls13(WOLFSSL* ssl, byte* output, const byte* input, word16 sz, const byte* aad, word16 aadSz);
WOLFSSL_LOCAL int  DoTls13HandShakeMsgType(WOLFSSL* ssl, byte* input, word32* inOutIdx, byte type, word32 size, word32 totalSz);

WOLFSSL_LOCAL int  DoTls13HandShakeMsg(WOLFSSL* ssl, byte* input, word32* inOutIdx, word32 totalSz);
WOLFSSL_LOCAL int DoTls13ServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 helloSz, byte* extMsgType);

WOLFSSL_LOCAL int RestartHandshakeHash(WOLFSSL* ssl);

WOLFSSL_LOCAL int Tls13DeriveKey(WOLFSSL *ssl, byte *output, int outputLen, const byte *secret, const byte *label, word32 labelLen, int hashAlgo, int includeMsgs, int side);


int TimingPadVerify(WOLFSSL* ssl, const byte* input, int padLen, int macSz, int pLen, int content);


enum {
    FORCED_FREE = 1, NO_FORCED_FREE = 0 };





    #define COMP_EXTRA MAX_COMP_EXTRA

    #define COMP_EXTRA 0




    #define MTU_EXTRA MAX_MTU * 3

    #define MTU_EXTRA 0





    #undef  LARGE_STATIC_BUFFERS
    #define LARGE_STATIC_BUFFERS





    
    #if RECORD_SIZE < 128 || RECORD_SIZE > MAX_RECORD_SIZE
        #error Invalid record size
    #endif

    
    #if defined(LARGE_STATIC_BUFFERS)
        #define RECORD_SIZE     MAX_RECORD_SIZE
    #else
        #ifdef WOLFSSL_DTLS
            #define RECORD_SIZE MAX_MTU
        #else
            #define RECORD_SIZE 128
        #endif
    #endif






    #define OUTPUT_RECORD_SIZE MAX_RECORD_SIZE

    #define OUTPUT_RECORD_SIZE RECORD_SIZE




    
    #if STATIC_BUFFER_LEN < 5 || STATIC_BUFFER_LEN > (RECORD_HEADER_SZ +  RECORD_SIZE + COMP_EXTRA + MTU_EXTRA + MAX_MSG_EXTRA)
        #error Invalid static buffer length
    #endif

    #define STATIC_BUFFER_LEN (RECORD_HEADER_SZ + RECORD_SIZE + COMP_EXTRA +  MTU_EXTRA + MAX_MSG_EXTRA

    
    #define STATIC_BUFFER_LEN RECORD_HEADER_SZ


typedef struct {
    ALIGN16 byte staticBuffer[STATIC_BUFFER_LEN];
    byte*  buffer;       
    word32 length;       
    word32 idx;          
    word32 bufferSize;   
    byte   dynamicFlag;  
    byte   offset;       
} bufferStatic;


struct Suites {
    word16 suiteSz;                 
    word16 hashSigAlgoSz;           
    byte   suites[WOLFSSL_MAX_SUITE_SZ];
    byte   hashSigAlgo[WOLFSSL_MAX_SIGALGO]; 
    byte   setSuites;               
};

typedef struct CipherSuite {
    byte   cipherSuite0;
    byte   cipherSuite;
    word32 ecdhCurveOID;
    struct KeyShareEntry* clientKSE;

    int    doHelloRetry;

} CipherSuite;

WOLFSSL_LOCAL void InitSuitesHashSigAlgo(Suites* suites, int haveECDSAsig, int haveRSAsig, int haveFalconSig, int haveDilithiumSig, int haveAnon, int tls1_2, int keySz);


WOLFSSL_LOCAL void InitSuitesHashSigAlgo_ex(byte* hashSigAlgo, int haveECDSAsig, int haveRSAsig, int haveFalconSig, int haveDilithiumSig, int haveAnon, int tls1_2, int keySz, word16* len);



WOLFSSL_API void InitSuitesHashSigAlgo_ex2(byte* hashSigAlgo, int have, int tls1_2, int keySz, word16* len);

WOLFSSL_LOCAL int AllocateCtxSuites(WOLFSSL_CTX* ctx);
WOLFSSL_LOCAL int AllocateSuites(WOLFSSL* ssl);
WOLFSSL_LOCAL void InitSuites(Suites* suites, ProtocolVersion pv, int keySz, word16 haveRSA, word16 havePSK, word16 haveDH, word16 haveECDSAsig, word16 haveECC, word16 haveStaticRSA, word16 haveStaticECC, word16 haveFalconSig, word16 haveDilithiumSig, word16 haveAnon, word16 haveNull, int side);





typedef struct TLSX TLSX;
WOLFSSL_LOCAL int MatchSuite_ex(const WOLFSSL* ssl, Suites* peerSuites, CipherSuite* cs, TLSX* extensions);
WOLFSSL_LOCAL int  MatchSuite(WOLFSSL* ssl, Suites* peerSuites);
WOLFSSL_LOCAL int  SetCipherList(WOLFSSL_CTX* ctx, Suites* suites, const char* list);
WOLFSSL_LOCAL int  SetCipherListFromBytes(WOLFSSL_CTX* ctx, Suites* suites, const byte* list, const int listSz);
WOLFSSL_LOCAL int  SetSuitesHashSigAlgo(Suites* suites, const char* list);


    typedef unsigned int (*wc_psk_client_callback)(WOLFSSL*, const char*, char*, unsigned int, unsigned char*, unsigned int);
    typedef unsigned int (*wc_psk_server_callback)(WOLFSSL*, const char*, unsigned char*, unsigned int);

    typedef unsigned int (*wc_psk_client_cs_callback)(WOLFSSL*, const char*, char*, unsigned int, unsigned char*, unsigned int, const char* cipherName);

    typedef unsigned int (*wc_psk_client_tls13_callback)(WOLFSSL*, const char*, char*, unsigned int, unsigned char*, unsigned int, const char** cipherName);

    typedef unsigned int (*wc_psk_server_tls13_callback)(WOLFSSL*, const char*, unsigned char*, unsigned int, const char** cipherName);




    typedef int (*wc_dtls_export)(WOLFSSL* ssl,         struct WOLFSSL_CIPHER {








    byte cipherSuite0;
    byte cipherSuite;
    const WOLFSSL* ssl;

    char description[MAX_DESCRIPTION_SZ];
    unsigned long offset;
    unsigned int in_stack; 
    int bits;

};



    
    typedef struct CertStatus CertStatus;



    typedef struct WOLFSSL_OCSP WOLFSSL_OCSP;




struct WOLFSSL_OCSP {
    WOLFSSL_CERT_MANAGER* cm;            
    OcspEntry*            ocspList;      
    wolfSSL_Mutex         ocspLock;      
    int                   error;

    int(*statusCb)(WOLFSSL*, void*);

};






typedef struct CRL_Entry CRL_Entry;


    #define CRL_DIGEST_SIZE WC_SM3_DIGEST_SIZE

    #define CRL_DIGEST_SIZE WC_SHA256_DIGEST_SIZE

    #define CRL_DIGEST_SIZE WC_SHA_DIGEST_SIZE



    typedef struct RevokedCert RevokedCert;


    #ifndef CRL_MAX_REVOKED_CERTS
        #define CRL_MAX_REVOKED_CERTS 4
    #elif CRL_MAX_REVOKED_CERTS > 22000
        #error CRL_MAX_REVOKED_CERTS too big, max is 22000
    #endif


struct CRL_Entry {
    byte*   toBeSigned;
    byte*   signature;

    WOLFSSL_X509_NAME*    issuer;     

    CRL_Entry* next;                      
    wolfSSL_Mutex verifyMutex;
    
    byte    issuerHash[CRL_DIGEST_SIZE];  
    
    
    byte    lastDate[MAX_DATE_SIZE]; 
    byte    nextDate[MAX_DATE_SIZE]; 
    byte    lastDateFormat;          
    byte    nextDateFormat;          

    WOLFSSL_ASN1_TIME lastDateAsn1;  
    WOLFSSL_ASN1_TIME nextDateAsn1;  


    RevokedCert certs[CRL_MAX_REVOKED_CERTS];

    RevokedCert* certs;             

    int     totalCerts;             
    int     version;                
    int     verified;
    word32  tbsSz;
    word32  signatureSz;
    word32  signatureOID;

    byte    extAuthKeyIdSet;
    byte    extAuthKeyId[KEYID_SIZE];

    int                   crlNumber;  
};


typedef struct CRL_Monitor CRL_Monitor;


struct CRL_Monitor {
    char* path;      
    int   type;      
};



    #undef HAVE_CRL_MONITOR






typedef int    wolfSSL_CRL_mfd_t; 



typedef HANDLE wolfSSL_CRL_mfd_t; 




struct WOLFSSL_CRL {
    WOLFSSL_CERT_MANAGER* cm;            
    CRL_Entry*            currentEntry;  
    CRL_Entry*            crlList;       

    CbCrlIO               crlIOCb;

    wolfSSL_RwLock        crlLock;       
    CRL_Monitor           monitors[WOLFSSL_CRL_MONITORS_LEN];

    COND_TYPE             cond;          
    THREAD_TYPE           tid;           
    wolfSSL_CRL_mfd_t     mfd;
    int                   setup;         

    void*                 heap;          
};



    typedef struct Signer Signer;

    typedef struct TrustedPeerCert TrustedPeerCert;





    #define CA_TABLE_SIZE 11


    #define TP_TABLE_SIZE 11



struct WOLFSSL_CERT_MANAGER {
    Signer*         caTable[CA_TABLE_SIZE]; 
    void*           heap;                

    TrustedPeerCert* tpTable[TP_TABLE_SIZE]; 
    wolfSSL_Mutex   tpLock;                  

    WOLFSSL_CRL*    crl;                 
    WOLFSSL_OCSP*   ocsp;                

    WOLFSSL_OCSP*   ocsp_stapling;       

    char*           ocspOverrideURL;     
    void*           ocspIOCtx;           

    VerifyCallback  verifyCallback;      

    CallbackCACache caCacheCallback;       
    CbMissingCRL    cbMissingCRL;          
    CbOCSPIO        ocspIOCb;              
    CbOCSPRespFree  ocspRespFreeCb;        
    wolfSSL_Mutex   caLock;                
    byte            crlEnabled:1;          
    byte            crlCheckAll:1;         
    byte            ocspEnabled:1;         
    byte            ocspCheckAll:1;        
    byte            ocspSendNonce:1;       
    byte            ocspUseOverrideURL:1;  
    byte            ocspStaplingEnabled:1; 

    byte            ocspMustStaple:1;      



    short           minRsaKeySz;         


    short           minEccKeySz;         


    WOLFSSL_X509_STORE  *x509_store_p;  
                                        
                                        

    wolfSSL_Ref     ref;

    short           minFalconKeySz;      
    short           minDilithiumKeySz;   


};

WOLFSSL_LOCAL int CM_SaveCertCache(WOLFSSL_CERT_MANAGER* cm, const char* fname);
WOLFSSL_LOCAL int CM_RestoreCertCache(WOLFSSL_CERT_MANAGER* cm, const char* fname);
WOLFSSL_LOCAL int CM_MemSaveCertCache(WOLFSSL_CERT_MANAGER* cm, void* mem, int sz, int* used);
WOLFSSL_LOCAL int CM_MemRestoreCertCache(WOLFSSL_CERT_MANAGER* cm, const void* mem, int sz);
WOLFSSL_LOCAL int CM_GetCertCacheMemSize(WOLFSSL_CERT_MANAGER* cm);
WOLFSSL_LOCAL int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const byte* buff, long sz, int format, int prev_err);




typedef struct ProcPeerCertArgs {
    buffer*      certs;

    buffer*      exts; 

    DecodedCert* dCert;
    word32 idx;
    word32 begin;
    int    totalCerts; 
    int    count;
    int    certIdx;
    int    lastErr;

    byte   ctxSz;


    char   untrustedDepth;

    word16 fatal:1;
    word16 verifyErr:1;
    word16 dCertInit:1;

    word16 haveTrustPeer:1; 

} ProcPeerCertArgs;
WOLFSSL_LOCAL int DoVerifyCallback(WOLFSSL_CERT_MANAGER* cm, WOLFSSL* ssl, int ret, ProcPeerCertArgs* args);




struct WOLFSSL_SOCKADDR {
    unsigned int sz; 
    unsigned int bufSz; 
    void*        sa; 
};

typedef struct WOLFSSL_DTLS_CTX {
    WOLFSSL_SOCKADDR peer;
    int rfd;
    int wfd;
    byte userSet:1;
    byte connected:1; 
} WOLFSSL_DTLS_CTX;


typedef struct WOLFSSL_DTLS_PEERSEQ {
    word32 window[WOLFSSL_DTLS_WINDOW_WORDS];
                        
    word16 nextEpoch;   
    word16 nextSeq_hi;  
    word32 nextSeq_lo;

    word32 prevWindow[WOLFSSL_DTLS_WINDOW_WORDS];
                        
    word32 prevSeq_lo;
    word16 prevSeq_hi;  


    word16 peerId;
    word32 highwaterMark;

} WOLFSSL_DTLS_PEERSEQ;





typedef struct Keys {

    byte client_write_MAC_secret[WC_MAX_DIGEST_SIZE];   
    byte server_write_MAC_secret[WC_MAX_DIGEST_SIZE];

    byte client_write_key[MAX_SYM_KEY_SIZE];         
    byte server_write_key[MAX_SYM_KEY_SIZE];
    byte client_write_IV[MAX_WRITE_IV_SZ];               
    byte server_write_IV[MAX_WRITE_IV_SZ];

    byte aead_exp_IV[AEAD_MAX_EXP_SZ];
    byte aead_enc_imp_IV[AEAD_MAX_IMP_SZ];
    byte aead_dec_imp_IV[AEAD_MAX_IMP_SZ];



    byte client_sn_key[MAX_SYM_KEY_SIZE];
    byte server_sn_key[MAX_SYM_KEY_SIZE];


    word32 peer_sequence_number_hi;
    word32 peer_sequence_number_lo;
    word32 sequence_number_hi;
    word32 sequence_number_lo;


    word16 curEpoch;    
    word16 curSeq_hi;   
    word32 curSeq_lo;


    w64wrapper curEpoch64;    
    w64wrapper curSeq;



    byte   curPeerId;   

    WOLFSSL_DTLS_PEERSEQ peerSeq[WOLFSSL_DTLS_PEERSEQ_SZ];

    word16 dtls_peer_handshake_number;
    word16 dtls_expected_peer_handshake_number;

    word16 dtls_epoch;                          
    word16 dtls_sequence_number_hi;             
    word32 dtls_sequence_number_lo;
    word16 dtls_prev_sequence_number_hi;        
    word32 dtls_prev_sequence_number_lo;
    word16 dtls_handshake_number;               


    word32 encryptSz;             
    word32 padSz;                 
    byte   encryptionOn;          
    byte   decryptedCur;          

    byte   updateResponseReq:1;   
    byte   keyUpdateRespond:1;    



    tsip_hmac_sha_key_index_t tsip_client_write_MAC_secret;
    tsip_hmac_sha_key_index_t tsip_server_write_MAC_secret;



    FSPSM_HMAC_WKEY fspsm_client_write_MAC_secret;
    FSPSM_HMAC_WKEY fspsm_server_write_MAC_secret;

} Keys;


typedef struct Options Options;





typedef enum {

    TLSX_SERVER_NAME                = 0x0000,   TLSX_MAX_FRAGMENT_LENGTH        = 0x0001, TLSX_TRUSTED_CA_KEYS            = 0x0003, TLSX_TRUNCATED_HMAC             = 0x0004, TLSX_STATUS_REQUEST             = 0x0005, TLSX_SUPPORTED_GROUPS           = 0x000a, TLSX_EC_POINT_FORMATS           = 0x000b,  TLSX_SIGNATURE_ALGORITHMS       = 0x000d,   TLSX_USE_SRTP                   = 0x000e,  TLSX_APPLICATION_LAYER_PROTOCOL = 0x0010, TLSX_STATUS_REQUEST_V2          = 0x0011,  TLSX_CLIENT_CERTIFICATE_TYPE    = 0x0013, TLSX_SERVER_CERTIFICATE_TYPE    = 0x0014,   TLSX_ENCRYPT_THEN_MAC           = 0x0016,  TLSX_EXTENDED_MASTER_SECRET     = 0x0017, TLSX_SESSION_TICKET             = 0x0023,  #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)

























    TLSX_PRE_SHARED_KEY             = 0x0029, #endif
    #ifdef WOLFSSL_EARLY_DATA
    TLSX_EARLY_DATA                 = 0x002a, #endif
    TLSX_SUPPORTED_VERSIONS         = 0x002b, #ifdef WOLFSSL_SEND_HRR_COOKIE
    TLSX_COOKIE                     = 0x002c, #endif
    #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
    TLSX_PSK_KEY_EXCHANGE_MODES     = 0x002d, #endif
    #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CA_NAMES)
    TLSX_CERTIFICATE_AUTHORITIES    = 0x002f, #endif
    #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
    TLSX_POST_HANDSHAKE_AUTH        = 0x0031, #endif
    #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
    TLSX_SIGNATURE_ALGORITHMS_CERT  = 0x0032, #endif
    TLSX_KEY_SHARE                  = 0x0033, #if defined(WOLFSSL_DTLS_CID)
    TLSX_CONNECTION_ID              = 0x0036, #endif
    #ifdef WOLFSSL_QUIC
    TLSX_KEY_QUIC_TP_PARAMS         = 0x0039,  #endif

    TLSX_RENEGOTIATION_INFO         = 0xff01,  TLSX_KEY_QUIC_TP_PARAMS_DRAFT   = 0xffa5,   TLSX_ECH                        = 0xfe0d,  } TLSX_Type;









typedef struct RpkConfig {
    
    byte preferred_ClientCertTypeCnt;
    byte preferred_ClientCertTypes[MAX_CLIENT_CERT_TYPE_CNT];
    byte preferred_ServerCertTypeCnt;
    byte preferred_ServerCertTypes[MAX_CLIENT_CERT_TYPE_CNT];
    
} RpkConfig;

typedef struct RpkState {
    byte sending_ClientCertTypeCnt;
    byte sending_ClientCertTypes[MAX_CLIENT_CERT_TYPE_CNT];
    
    byte sending_ServerCertTypeCnt;
    byte sending_ServerCertTypes[MAX_SERVER_CERT_TYPE_CNT];
    
    byte received_ClientCertTypeCnt;
    byte received_ClientCertTypes[MAX_CLIENT_CERT_TYPE_CNT];
    
    byte received_ServerCertTypeCnt;
    byte received_ServerCertTypes[MAX_SERVER_CERT_TYPE_CNT];
    
    int  isRPKLoaded;
} RpkState;




typedef enum {
    ECH_TYPE_OUTER = 0, ECH_TYPE_INNER = 1 } EchType;


typedef enum {
    ECH_WRITE_GREASE, ECH_WRITE_REAL, ECH_WRITE_RETRY_CONFIGS, ECH_WRITE_NONE, ECH_PARSED_INTERNAL, } EchState;





typedef struct EchCipherSuite {
    word16 kdfId;
    word16 aeadId;
} EchCipherSuite;

typedef struct WOLFSSL_EchConfig {
    byte* raw;
    char* publicName;
    void* receiverPrivkey;
    struct WOLFSSL_EchConfig* next;
    EchCipherSuite* cipherSuites;
    word32 rawLen;
    word16 kemId;
    byte configId;
    byte numCipherSuites;
    byte receiverPubkey[HPKE_Npk_MAX];
} WOLFSSL_EchConfig;

typedef struct WOLFSSL_ECH {
    Hpke* hpke;
    const byte* aad;
    void* ephemeralKey;
    WOLFSSL_EchConfig* echConfig;
    byte* innerClientHello;
    byte* outerClientPayload;
    EchCipherSuite cipherSuite;
    word16 aadLen;
    word16 paddingLen;
    word16 innerClientHelloLen;
    word16 kemId;
    word16 encLen;
    EchState state;
    byte type;
    byte configId;
    byte enc[HPKE_Npk_MAX];
} WOLFSSL_ECH;

WOLFSSL_LOCAL int EchConfigGetSupportedCipherSuite(WOLFSSL_EchConfig* config);

WOLFSSL_LOCAL int TLSX_FinalizeEch(WOLFSSL_ECH* ech, byte* aad, word32 aadLen);

WOLFSSL_LOCAL int GetEchConfig(WOLFSSL_EchConfig* config, byte* output, word32* outputLen);

WOLFSSL_LOCAL int GetEchConfigsEx(WOLFSSL_EchConfig* configs, byte* output, word32* outputLen);


struct TLSX {
    TLSX_Type    type; 
    void*        data; 
    word32       val;  
    byte         resp; 
    struct TLSX* next; 
};

WOLFSSL_LOCAL TLSX* TLSX_Find(TLSX* list, TLSX_Type type);
WOLFSSL_LOCAL void  TLSX_Remove(TLSX** list, TLSX_Type type, void* heap);
WOLFSSL_LOCAL void  TLSX_FreeAll(TLSX* list, void* heap);
WOLFSSL_LOCAL int   TLSX_SupportExtensions(WOLFSSL* ssl);
WOLFSSL_LOCAL int   TLSX_PopulateExtensions(WOLFSSL* ssl, byte isRequest);


WOLFSSL_LOCAL int   TLSX_GetRequestSize(WOLFSSL* ssl, byte msgType, word16* pLength);
WOLFSSL_LOCAL int   TLSX_WriteRequest(WOLFSSL* ssl, byte* output, byte msgType, word16* pOffset);




WOLFSSL_LOCAL int   TLSX_GetResponseSize(WOLFSSL* ssl, byte msgType, word16* pLength);
WOLFSSL_LOCAL int   TLSX_WriteResponse(WOLFSSL *ssl, byte* output, byte msgType, word16* pOffset);


WOLFSSL_LOCAL int   TLSX_ParseVersion(WOLFSSL* ssl, const byte* input, word16 length, byte msgType, int* found);
WOLFSSL_LOCAL int TLSX_SupportedVersions_Parse(const WOLFSSL* ssl, const byte* input, word16 length, byte msgType, ProtocolVersion* pv, Options* opts, TLSX** exts);

WOLFSSL_LOCAL int   TLSX_Parse(WOLFSSL* ssl, const byte* input, word16 length, byte msgType, Suites *suites);
WOLFSSL_LOCAL int TLSX_Push(TLSX** list, TLSX_Type type, const void* data, void* heap);
WOLFSSL_LOCAL int TLSX_Append(TLSX** list, TLSX_Type type, const void* data, void* heap);



















typedef struct SNI {
    byte                       type;    
    union { char* host_name; } data;    
    struct SNI*                next;    
    byte                       status;  

    byte                       options; 

} SNI;

WOLFSSL_LOCAL int TLSX_UseSNI(TLSX** extensions, byte type, const void* data, word16 size, void* heap);
WOLFSSL_LOCAL byte TLSX_SNI_Status(TLSX* extensions, byte type);
WOLFSSL_LOCAL word16 TLSX_SNI_GetRequest(TLSX* extensions, byte type, void** data);


WOLFSSL_LOCAL void   TLSX_SNI_SetOptions(TLSX* extensions, byte type, byte options);
WOLFSSL_LOCAL int    TLSX_SNI_GetFromBuffer(const byte* clientHello, word32 helloSz, byte type, byte* sni, word32* inOutSz);







typedef struct TCA {
    byte                       type;    
    byte*                      id;      
    word16                     idSz;    
    struct TCA*                next;    
} TCA;

WOLFSSL_LOCAL int TLSX_UseTrustedCA(TLSX** extensions, byte type, const byte* id, word16 idSz, void* heap);





typedef struct ALPN {
    char*        protocol_name; 
    struct ALPN* next;          
    byte         options;       
    byte         negotiated;    
} ALPN;

WOLFSSL_LOCAL int TLSX_ALPN_GetRequest(TLSX* extensions, void** data, word16 *dataSz);

WOLFSSL_LOCAL int TLSX_UseALPN(TLSX** extensions, const void* data, word16 size, byte options, void* heap);

WOLFSSL_LOCAL int TLSX_ALPN_SetOptions(TLSX** extensions, byte option);






WOLFSSL_LOCAL int TLSX_UseMaxFragment(TLSX** extensions, byte mfl, void* heap);






WOLFSSL_LOCAL int TLSX_UseTruncatedHMAC(TLSX** extensions, void* heap);






typedef struct {
    byte status_type;
    byte options;
    WOLFSSL* ssl;
    union {
        OcspRequest ocsp;
    } request;

    buffer response;

} CertificateStatusRequest;

WOLFSSL_LOCAL int   TLSX_UseCertificateStatusRequest(TLSX** extensions, byte status_type, byte options, WOLFSSL* ssl, void* heap, int devId);

WOLFSSL_LOCAL int   TLSX_CSR_InitRequest(TLSX* extensions, DecodedCert* cert, void* heap);

WOLFSSL_LOCAL void* TLSX_CSR_GetRequest(TLSX* extensions);
WOLFSSL_LOCAL int   TLSX_CSR_ForceRequest(WOLFSSL* ssl);






typedef struct CSRIv2 {
    byte status_type;
    byte options;
    word16 requests;
    union {
        OcspRequest ocsp[1 + MAX_CHAIN_DEPTH];
    } request;
    struct CSRIv2* next;
} CertificateStatusRequestItemV2;

WOLFSSL_LOCAL int   TLSX_UseCertificateStatusRequestV2(TLSX** extensions, byte status_type, byte options, void* heap, int devId);

WOLFSSL_LOCAL int   TLSX_CSR2_InitRequests(TLSX* extensions, DecodedCert* cert, byte isPeer, void* heap);

WOLFSSL_LOCAL void* TLSX_CSR2_GetRequest(TLSX* extensions, byte status_type, byte idx);
WOLFSSL_LOCAL int   TLSX_CSR2_ForceRequest(WOLFSSL* ssl);





typedef int (*CallbackProcessPeerCert)(WOLFSSL* ssl, DecodedCert* p_cert);
WOLFSSL_API void wolfSSL_CTX_SetProcessPeerCertCb(WOLFSSL_CTX* ctx, CallbackProcessPeerCert cb);



typedef struct SignatureAlgorithms {
    
    WOLFSSL*    ssl;
    word16      hashSigAlgoSz; 
    
    #ifdef _MSC_VER
    #pragma warning(disable: 4200)
    #endif
    byte        hashSigAlgo[]; 
} SignatureAlgorithms;

WOLFSSL_LOCAL SignatureAlgorithms* TLSX_SignatureAlgorithms_New( WOLFSSL* ssl, word16 hashSigAlgoSz, void* heap);
WOLFSSL_LOCAL void TLSX_SignatureAlgorithms_FreeAll(SignatureAlgorithms* sa, void* heap);





typedef struct SupportedCurve {
    word16 name;                 
    struct SupportedCurve* next; 
} SupportedCurve;

typedef struct PointFormat {
    byte format;                
    struct PointFormat* next;   
} PointFormat;

WOLFSSL_LOCAL int TLSX_SupportedCurve_Copy(TLSX* src, TLSX** dst, void* heap);
WOLFSSL_LOCAL int TLSX_UseSupportedCurve(TLSX** extensions, word16 name, void* heap);

WOLFSSL_LOCAL int TLSX_UsePointFormat(TLSX** extensions, byte point, void* heap);


WOLFSSL_LOCAL int TLSX_ValidateSupportedCurves(const WOLFSSL* ssl, byte first, byte second, word32* ecdhCurveOID);
WOLFSSL_LOCAL int TLSX_SupportedCurve_CheckPriority(WOLFSSL* ssl);
WOLFSSL_LOCAL int TLSX_SupportedFFDHE_Set(WOLFSSL* ssl);

WOLFSSL_LOCAL int TLSX_SupportedCurve_Preferred(WOLFSSL* ssl, int checkSupported);
WOLFSSL_LOCAL int TLSX_SupportedCurve_Parse(const WOLFSSL* ssl, const byte* input, word16 length, byte isRequest, TLSX** extensions);






enum key_cache_state {
    SCR_CACHE_NULL   = 0,        SCR_CACHE_NEEDED, SCR_CACHE_COPY, SCR_CACHE_PARTIAL, SCR_CACHE_COMPLETE };






typedef struct SecureRenegotiation {
   byte                 enabled;  
   byte                 verifySet;
   byte                 startScr; 
   enum key_cache_state cache_status;  
   byte                 client_verify_data[TLS_FINISHED_SZ];  
   byte                 server_verify_data[TLS_FINISHED_SZ];  
   byte                 subject_hash_set; 
   byte                 subject_hash[KEYID_SIZE];  
   Keys                 tmp_keys;  
} SecureRenegotiation;

WOLFSSL_LOCAL int TLSX_UseSecureRenegotiation(TLSX** extensions, void* heap);


WOLFSSL_LOCAL int TLSX_AddEmptyRenegotiationInfo(TLSX** extensions, void* heap);






typedef struct InternalTicket {
    ProtocolVersion pv;                    
    byte            suite[SUITE_LEN];      
    byte            msecret[SECRET_LEN];   
    byte            timestamp[TIMESTAMP_LEN];          
    byte            haveEMS;               

    byte            ageAdd[AGEADD_LEN];    
    byte            namedGroup[NAMEDGROUP_LEN]; 
    byte            ticketNonceLen;
    byte            ticketNonce[MAX_TICKET_NONCE_STATIC_SZ];

    byte            maxEarlyDataSz[MAXEARLYDATASZ_LEN]; 



    byte            id[ID_LEN];


    byte            sessionCtxSz;          
    byte            sessionCtx[ID_LEN];    

} InternalTicket;








typedef struct ExternalTicket {
    byte key_name[WOLFSSL_TICKET_NAME_SZ];  
    byte iv[WOLFSSL_TICKET_IV_SZ];          
    byte enc_len[OPAQUE16_LEN];             
    byte enc_ticket[WOLFSSL_TICKET_ENC_SZ];
                                            
    byte mac[WOLFSSL_TICKET_MAC_SZ];        
} ExternalTicket;





typedef struct SessionTicket {
    word32 lifetime;

    word64 seen;
    word32 ageAdd;

    byte*  data;
    word16 size;
} SessionTicket;




typedef struct TicketEncCbCtx {
    
    byte name[WOLFSSL_TICKET_NAME_SZ];
    
    byte key[2][WOLFSSL_TICKET_KEY_SZ];
    
    word32 expirary[2];
    
    WC_RNG rng;

    
    wolfSSL_Mutex mutex;

    
    WOLFSSL_CTX* ctx;
} TicketEncCbCtx;



WOLFSSL_LOCAL int  TLSX_UseSessionTicket(TLSX** extensions, SessionTicket* ticket, void* heap);
WOLFSSL_LOCAL SessionTicket* TLSX_SessionTicket_Create(word32 lifetime, byte* data, word16 size, void* heap);
WOLFSSL_LOCAL void TLSX_SessionTicket_Free(SessionTicket* ticket, void* heap);




int TLSX_EncryptThenMac_Respond(WOLFSSL* ssl);




typedef struct Cookie {
    word16 len;
    
    #ifdef _MSC_VER
    #pragma warning(disable: 4200)
    #endif
    byte   data[];
} Cookie;

WOLFSSL_LOCAL int TLSX_Cookie_Use(const WOLFSSL* ssl, const byte* data, word16 len, byte* mac, byte macSz, int resp, TLSX** exts);
WOLFSSL_LOCAL int TlsCheckCookie(const WOLFSSL* ssl, const byte* cookie, word16 cookieSz);





typedef struct KeyShareEntry {
    word16                group;     
    byte*                 ke;        
    word32                keLen;     
    void*                 key;       
    word32                keyLen;    
    byte*                 pubKey;    
    word32                pubKeyLen; 

    byte*                 privKey;   


    int                   lastRet;

    struct KeyShareEntry* next;      
} KeyShareEntry;

WOLFSSL_LOCAL int TLSX_KeyShare_Use(const WOLFSSL* ssl, word16 group, word16 len, byte* data, KeyShareEntry **kse, TLSX** extensions);
WOLFSSL_LOCAL int TLSX_KeyShare_Empty(WOLFSSL* ssl);
WOLFSSL_LOCAL int TLSX_KeyShare_SetSupported(const WOLFSSL* ssl, TLSX** extensions);
WOLFSSL_LOCAL int TLSX_KeyShare_GenKey(WOLFSSL *ssl, KeyShareEntry *kse);
WOLFSSL_LOCAL int TLSX_KeyShare_Choose(const WOLFSSL *ssl, TLSX* extensions, byte cipherSuite0, byte cipherSuite, KeyShareEntry** kse, byte* searched);

WOLFSSL_LOCAL int TLSX_KeyShare_Setup(WOLFSSL *ssl, KeyShareEntry* clientKSE);
WOLFSSL_LOCAL int TLSX_KeyShare_Establish(WOLFSSL* ssl, int* doHelloRetry);
WOLFSSL_LOCAL int TLSX_KeyShare_DeriveSecret(WOLFSSL* sclientKSEclientKSEsl);
WOLFSSL_LOCAL int TLSX_KeyShare_Parse(WOLFSSL* ssl, const byte* input, word16 length, byte msgType);
WOLFSSL_LOCAL int TLSX_KeyShare_Parse_ClientHello(const WOLFSSL* ssl, const byte* input, word16 length, TLSX** extensions);




enum PskDecryptReturn {
    PSK_DECRYPT_NONE = 0, PSK_DECRYPT_OK, PSK_DECRYPT_CREATE, PSK_DECRYPT_FAIL, };





typedef struct psk_sess_free_cb_ctx {
    word32 row;

    int extCache;
    int freeSess;

} psk_sess_free_cb_ctx;
typedef void (psk_sess_free_cb)(const WOLFSSL* ssl, const WOLFSSL_SESSION* sess, psk_sess_free_cb_ctx* freeCtx);



typedef struct PreSharedKey {
    word16               identityLen;             
    byte*                identity;                
    word32               ticketAge;               
    byte                 cipherSuite0;            
    byte                 cipherSuite;             
    word32               binderLen;               
    byte                 binder[WC_MAX_DIGEST_SIZE]; 
    byte                 hmac;                    

    InternalTicket*      it;                      
    const WOLFSSL_SESSION* sess; 
    psk_sess_free_cb* sess_free_cb;               
    psk_sess_free_cb_ctx sess_free_cb_ctx;        

    byte                 resumption:1;            
    byte                 chosen:1;                
    byte                 decryptRet:3;            
    struct PreSharedKey* next;                    
} PreSharedKey;

WOLFSSL_LOCAL int TLSX_PreSharedKey_WriteBinders(PreSharedKey* list, byte* output, byte msgType, word16* pSz);

WOLFSSL_LOCAL int TLSX_PreSharedKey_GetSizeBinders(PreSharedKey* list, byte msgType, word16* pSz);
WOLFSSL_LOCAL int TLSX_PreSharedKey_Use(TLSX** extensions, const byte* identity, word16 len, word32 age, byte hmac, byte cipherSuite0, byte cipherSuite, byte resumption, PreSharedKey **preSharedKey, void* heap);




WOLFSSL_LOCAL int TLSX_PreSharedKey_Parse_ClientHello(TLSX** extensions, const byte* input, word16 length, void* heap);


enum PskKeyExchangeMode {
    PSK_KE, PSK_DHE_KE };







WOLFSSL_LOCAL int TLSX_PskKeyModes_Use(WOLFSSL* ssl, byte modes);
WOLFSSL_LOCAL int TLSX_PskKeyModes_Parse_Modes(const byte* input, word16 length, byte msgType, byte* modes);


WOLFSSL_LOCAL int TLSX_EarlyData_Use(WOLFSSL* ssl, word32 max, int is_response);





enum DeriveKeyType {
    no_key, early_data_key, handshake_key, traffic_key, update_traffic_key };





WOLFSSL_LOCAL int DeriveEarlySecret(WOLFSSL* ssl);
WOLFSSL_LOCAL int DeriveHandshakeSecret(WOLFSSL* ssl);
WOLFSSL_LOCAL int DeriveTls13Keys(WOLFSSL* ssl, int secret, int side, int store);
WOLFSSL_LOCAL int DeriveMasterSecret(WOLFSSL* ssl);
WOLFSSL_LOCAL int DeriveResumptionPSK(WOLFSSL* ssl, byte* nonce, byte nonceLen, byte* secret);
WOLFSSL_LOCAL int DeriveResumptionSecret(WOLFSSL* ssl, byte* key);

WOLFSSL_LOCAL int Tls13_Exporter(WOLFSSL* ssl, unsigned char *out, size_t outLen, const char *label, size_t labelLen, const unsigned char *context, size_t contextLen);



enum KeyUpdateRequest {
    update_not_requested, update_requested };




WOLFSSL_LOCAL void TLSX_ConnectionID_Free(byte* ext, void* heap);
WOLFSSL_LOCAL word16 TLSX_ConnectionID_Write(byte* ext, byte* output);
WOLFSSL_LOCAL word16 TLSX_ConnectionID_GetSize(byte* ext);
WOLFSSL_LOCAL int TLSX_ConnectionID_Use(WOLFSSL* ssl);
WOLFSSL_LOCAL int TLSX_ConnectionID_Parse(WOLFSSL* ssl, const byte* input, word16 length, byte isRequest);
WOLFSSL_LOCAL void DtlsCIDOnExtensionsParsed(WOLFSSL* ssl);
WOLFSSL_LOCAL byte DtlsCIDCheck(WOLFSSL* ssl, const byte* input, word16 inputSize);



enum SetCBIO {
    WOLFSSL_CBIO_NONE = 0, WOLFSSL_CBIO_RECV = 0x1, WOLFSSL_CBIO_SEND = 0x2, };






typedef struct {

    DerBuffer* dhKey;


    DerBuffer* ecKey;


    DerBuffer* x25519Key;


    DerBuffer* x448Key;

} StaticKeyExchangeInfo_t;




struct WOLFSSL_CTX {
    WOLFSSL_METHOD* method;

    WC_RNG*         rng;          

    wolfSSL_Ref     ref;
    int         err;              

    buffer      serverDH_P;
    buffer      serverDH_G;


    DerBuffer*  certificate;
    DerBuffer*  certChain;
                 
    #ifndef WOLFSSL_NO_CA_NAMES
    WOLF_STACK_OF(WOLFSSL_X509_NAME)* client_ca_names;
    #endif
    #ifdef OPENSSL_EXTRA
    WOLF_STACK_OF(WOLFSSL_X509)* x509Chain;
    client_cert_cb CBClientCert;  
    CertSetupCallback  certSetupCb;
    void*              certSetupCbArg;
    #endif

    int         certChainCnt;

    DerBuffer*  privateKey;
    byte        privateKeyType:6;
    byte        privateKeyId:1;
    byte        privateKeyLabel:1;
    int         privateKeySz;
    int         privateKeyDevId;

    WOLFSSL_EVP_PKEY* privateKeyPKey;

    WOLFSSL_CERT_MANAGER* cm;      


    WOLFSSL_X509*    ourCert;     
    int              ownOurCert;  

    Suites*     suites;           
    void*       heap;             
    byte        verifyDepth;
    byte        verifyPeer:1;
    byte        verifyNone:1;
    byte        failNoCert:1;
    byte        failNoCertxPSK:1; 
    byte        sessionCacheOff:1;
    byte        sessionCacheFlushOff:1;

    byte        internalCacheOff:1;
    byte        internalCacheLookupOff:1;

    byte        sendVerify:2;     
    byte        haveRSA:1;        
    byte        haveECC:1;        
    byte        haveDH:1;         
    byte        haveECDSAsig:1;   
    byte        haveFalconSig:1;  
    byte        haveDilithiumSig:1;
    byte        haveStaticECC:1;  
    byte        partialWrite:1;   
    byte        autoRetry:1;      
    byte        quietShutdown:1;  
    byte        groupMessages:1;  
    byte        minDowngrade;     
    byte        haveEMS:1;        
    byte        useClientOrder:1; 

    byte        noTicketTls12:1;  


    #if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER)
    unsigned int maxTicketTls13;  
    #endif
    byte        noTicketTls13:1;  

    byte        noPskDheKe:1;     

    byte        onlyPskDheKe:1;   



    byte        mutualAuth:1;     

    byte        postHandshakeAuth:1;  
    byte        verifyPostHandshake:1; 


    #if !defined(WOLFSSL_OLD_PRIME_CHECK) && !defined(HAVE_FIPS) &&  !defined(HAVE_SELFTEST
    byte        dhKeyTested:1;   
    #endif


    byte        useSecureReneg:1; 


    byte        disallowEncThenMac:1;  


    byte        onHeapHint:1; 


    byte        staticKELockInit:1;


    byte        dtlsSctp:1;         

    word16      minProto:1; 
    word16      maxProto:1; 

    RpkConfig   rpkConfig;
    RpkState    rpkState;


    word16      dtlsSrtpProfiles;  


    byte        haveMcast;        
    byte        mcastID;          


    word16      dtlsMtuSz;        


    word16      minDhKeySz;       
    word16      maxDhKeySz;       


    short       minRsaKeySz;      


    short       minEccKeySz;      


    short       minFalconKeySz;   
    short       minDilithiumKeySz;

    unsigned long     mask;             

    word32            disabledCurves;   


    byte              sessionCtx[ID_LEN]; 
    byte              sessionCtxSz;


    const unsigned char *alpn_cli_protos;
    unsigned int         alpn_cli_protos_len;
    byte              cbioFlag;  
    CallbackInfoState* CBIS;      
    WOLFSSL_X509_VERIFY_PARAM* param;    


    NetworkFilterCallback_t AcceptFilter;
    void *AcceptFilter_arg;
    NetworkFilterCallback_t ConnectFilter;
    void *ConnectFilter_arg;

    CallbackIORecv CBIORecv;
    CallbackIOSend CBIOSend;

    CallbackGenCookie CBIOCookie;       



    wc_dtls_export  dtls_export;        

    CallbackGetPeer CBGetPeer;
    CallbackSetPeer CBSetPeer;

    VerifyCallback  verifyCallback;     
    void*           verifyCbCtx;        

    CertVerifyCallback verifyCertCb;
    void*              verifyCertCbArg;


    SSL_Msg_Cb      protoMsgCb;         
    void*           protoMsgCtx;        

    word32          timeout;            

    word32          ecdhCurveOID;       


    word16          eccTempKeySz;       


    word32          pkCurveOID;         


    byte        havePSK;                
    wc_psk_client_callback client_psk_cb;  
    wc_psk_server_callback server_psk_cb;  

    wc_psk_client_cs_callback    client_psk_cs_cb;     
    wc_psk_client_tls13_callback client_psk_tls13_cb;  
    wc_psk_server_tls13_callback server_psk_tls13_cb;  

    void*       psk_ctx;
    char        server_hint[MAX_PSK_ID_LEN + NULL_TERM_LEN];


    word16          group[WOLFSSL_MAX_GROUP_COUNT];
    byte            numGroups;


    word32          maxEarlyDataSz;


    byte        haveAnon;               


    wc_pem_password_cb* passwd_cb;
    void*               passwd_userdata;


    WOLFSSL_X509_STORE x509_store; 
    WOLFSSL_X509_STORE* x509_store_pt; 


    byte            readAhead;
    void*           userPRFArg; 


    WOLFSSL_CRYPTO_EX_DATA ex_data;


    CallbackALPNSelect alpnSelect;
    void*              alpnSelectArg;


    CallbackSniRecv sniRecvCb;
    void*           sniRecvCbArg;


    CallbackMcastHighwater mcastHwCb; 
    word32      mcastFirstSeq;    
    word32      mcastSecondSeq;   
    word32      mcastMaxSeq;      


    WOLFSSL_OCSP      ocsp;

    int             devId;              

    TLSX* extensions;                  
    #ifndef NO_WOLFSSL_SERVER
        #if defined(HAVE_CERTIFICATE_STATUS_REQUEST)  || defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2
            OcspRequest* certOcspRequest;
        #endif
        #if defined(HAVE_CERTIFICATE_STATUS_REQUEST_V2)
            OcspRequest* chainOcspRequest[MAX_CHAIN_DEPTH];
        #endif
    #endif
    #if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER)
        SessionTicketEncCb ticketEncCb;   
        void*              ticketEncCtx;  
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)  || defined(OPENSSL_EXTRA) || defined(HAVE_LIGHTY
        ticketCompatCb     ticketEncWrapCb; 
        #endif
        int                ticketHint;    
        #ifndef WOLFSSL_NO_DEF_TICKET_ENC_CB
            TicketEncCbCtx ticketKeyCtx;
        #endif
    #endif
    #endif
    #ifdef HAVE_SUPPORTED_CURVES
        byte userCurves;                  
    #endif

    CallbackMacEncrypt    MacEncryptCb;    
    CallbackDecryptVerify DecryptVerifyCb; 
    #ifdef HAVE_ENCRYPT_THEN_MAC
        CallbackEncryptMac    EncryptMacCb;    
        CallbackVerifyDecrypt VerifyDecryptCb; 
    #endif


    #ifdef HAVE_ECC
        CallbackEccKeyGen EccKeyGenCb;  
        CallbackEccSign   EccSignCb;    
        void*             EccSignCtx;   
        CallbackEccVerify EccVerifyCb;  
        CallbackEccSharedSecret EccSharedSecretCb; 
    #endif 
    #ifdef HAVE_HKDF
        CallbackHKDFExtract HkdfExtractCb; 
    #endif
    #ifdef HAVE_ED25519
        
        CallbackEd25519Sign   Ed25519SignCb;
        
        CallbackEd25519Verify Ed25519VerifyCb;
    #endif
    #ifdef HAVE_CURVE25519
        
        CallbackX25519KeyGen X25519KeyGenCb;
        
        CallbackX25519SharedSecret X25519SharedSecretCb;
    #endif
    #ifdef HAVE_ED448
        
        CallbackEd448Sign   Ed448SignCb;
        
        CallbackEd448Verify Ed448VerifyCb;
    #endif
    #ifdef HAVE_CURVE448
        
        CallbackX448KeyGen X448KeyGenCb;
        
        CallbackX448SharedSecret X448SharedSecretCb;
    #endif
    #ifndef NO_DH
        
        CallbackDhGenerateKeyPair DhGenerateKeyPairCb;
        
        CallbackDhAgree DhAgreeCb;
    #endif
    #ifndef NO_RSA
        
        CallbackRsaSign   RsaSignCb;
        
        CallbackRsaVerify RsaVerifyCb;
        
        CallbackRsaVerify RsaSignCheckCb;
        #ifdef WC_RSA_PSS
            
            CallbackRsaPssSign   RsaPssSignCb;
            
            CallbackRsaPssVerify RsaPssVerifyCb;
            
            CallbackRsaPssVerify RsaPssSignCheckCb;
        #endif
        CallbackRsaEnc    RsaEncCb;     
        CallbackRsaDec    RsaDecCb;     
    #endif 

    
    CallbackGenPreMaster        GenPreMasterCb;
    
    CallbackGenMasterSecret     GenMasterCb;
    
    CallbackGenSessionKey       GenSessionKeyCb;
    
    CallbackEncryptKeys         EncryptKeysCb;
    
    CallbackTlsFinished         TlsFinishedCb;

    
    CallbackVerifyMac           VerifyMacCb;


    
    CallbackProcessPeerCert ProcessPeerCertCb;

    
    CallbackProcessServerSigKex ProcessServerSigKexCb;
    
    CallbackPerformTlsRecordProcessing PerformTlsRecordProcessingCb;
    
    CallbackHKDFExpandLabel HKDFExpandLabelCb;



    WOLF_EVENT_QUEUE event_queue;


    WOLFSSL_SESSION*(*get_sess_cb)(WOLFSSL*, const unsigned char*, int, int*);
    int (*new_sess_cb)(WOLFSSL*, WOLFSSL_SESSION*);


    Rem_Sess_Cb rem_sess_cb;


    Srp*  srp;  
    byte* srp_password;


    wolfSSL_CTX_keylog_cb_func keyLogCb;


    StaticKeyExchangeInfo_t staticKE;
    #ifndef SINGLE_THREADED
    wolfSSL_Mutex staticKELock;
    #endif


    struct {
        const WOLFSSL_QUIC_METHOD *method;
    } quic;


    WOLFSSL_EchConfig* echConfigs;


    byte doAppleNativeCertValidationFlag:1;

};

WOLFSSL_LOCAL int InitSSL_Ctx(WOLFSSL_CTX* ctx, WOLFSSL_METHOD* method, void* heap);
WOLFSSL_LOCAL void FreeSSL_Ctx(WOLFSSL_CTX* ctx);
WOLFSSL_LOCAL void SSL_CtxResourceFree(WOLFSSL_CTX* ctx);


    #ifndef HAVE_EX_DATA
        #error "HAVE_EX_DATA_CLEANUP_HOOKS requires HAVE_EX_DATA to be defined"
    #endif
void wolfSSL_CRYPTO_cleanup_ex_data(WOLFSSL_CRYPTO_EX_DATA* ex_data);


WOLFSSL_LOCAL int DeriveTlsKeys(WOLFSSL* ssl);
WOLFSSL_LOCAL int ProcessOldClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 inSz, word16 sz);



    WOLFSSL_LOCAL int AddCA(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int type, int verify);
    WOLFSSL_LOCAL int AlreadySigner(WOLFSSL_CERT_MANAGER* cm, byte* hash);

    WOLFSSL_LOCAL int AddTrustedPeer(WOLFSSL_CERT_MANAGER* cm, DerBuffer** pDer, int verify);
    WOLFSSL_LOCAL int AlreadyTrustedPeer(WOLFSSL_CERT_MANAGER* cm, DecodedCert* cert);




typedef struct CipherSpecs {
    word16 key_size;
    word16 iv_size;
    word16 block_size;
    word16 aead_mac_size;
    byte bulk_cipher_algorithm;
    byte cipher_type;               
    byte mac_algorithm;
    byte kea;                       
    byte sig_algo;
    byte hash_size;
    byte pad_size;
    byte static_ecdh;
} CipherSpecs;


void InitCipherSpecs(CipherSpecs* cs);



enum KeyExchangeAlgorithm {
    no_kea, rsa_kea, diffie_hellman_kea, fortezza_kea, psk_kea, dhe_psk_kea, ecdhe_psk_kea, ecc_diffie_hellman_kea, ecc_static_diffie_hellman_kea };


















enum SignatureAlgorithm {
    anonymous_sa_algo            = 0, rsa_sa_algo                  = 1, dsa_sa_algo                  = 2, ecc_dsa_sa_algo              = 3, rsa_pss_sa_algo              = 8, ed25519_sa_algo              = 9, rsa_pss_pss_algo             = 10, ed448_sa_algo                = 11, falcon_level1_sa_algo        = 12, falcon_level5_sa_algo        = 13, dilithium_level2_sa_algo     = 14, dilithium_level3_sa_algo     = 15, dilithium_level5_sa_algo     = 16, sm2_sa_algo                  = 17, invalid_sa_algo              = 255 };



















enum SigAlgRsaPss {
    pss_sha256  = 0x09, pss_sha384  = 0x0a, pss_sha512  = 0x0b, };




    
    #define TLS12_SM2_SIG_ID        ((byte*)"1234567812345678")
    
    #define TLS12_SM2_SIG_ID_SZ     16

    
    
    #define TLS13_SM2_SIG_ID        ((byte*)"TLSv1.3+GM+Cipher+Suite")
    
    #define TLS13_SM2_SIG_ID_SZ     23



enum EccCurves {
    named_curve = 3 };



enum ClientCertificateType {
    rsa_sign            = 1, dss_sign            = 2, rsa_fixed_dh        = 3, dss_fixed_dh        = 4, rsa_ephemeral_dh    = 5, dss_ephemeral_dh    = 6, fortezza_kea_cert   = 20, ecdsa_sign          = 64, rsa_fixed_ecdh      = 65, ecdsa_fixed_ecdh    = 66, falcon_sign         = 67, dilithium_sign      = 68, };














enum CipherType { stream, block, aead };

enum CipherType { aead };




    #define CIPHER_NONCE



enum CipherSrc {
    KEYS_NOT_SET = 0, KEYS, SCR };





    #ifndef WOLFSSL_CIPHER_CHECK_SZ
        
        #define WOLFSSL_CIPHER_CHECK_SZ 8
    #endif



typedef struct Ciphers {

    Arc4*   arc4;


    Des3*   des3;


    Aes*    aes;


    byte* additional;


    wc_Aria* aria;


    byte* nonce;


    Camellia* cam;


    ChaCha*   chacha;


    wc_Sm4*   sm4;


    Hmac* hmac;


    word32 sanityCheck[WOLFSSL_CIPHER_CHECK_SZ/sizeof(word32)];

    byte    state;
    byte    setup;       

    enum CipherSrc src;  

} Ciphers;


typedef struct RecordNumberCiphers {

        Aes *aes;


        ChaCha *chacha;

} RecordNumberCiphers;




typedef struct OneTimeAuth {

    Poly1305* poly1305;

    byte    setup;      

} OneTimeAuth;



WOLFSSL_LOCAL void InitCiphers(WOLFSSL* ssl);
WOLFSSL_LOCAL void FreeCiphers(WOLFSSL* ssl);



typedef struct Hashes {
    #if !defined(NO_MD5) && !defined(NO_OLD_TLS)
        byte md5[WC_MD5_DIGEST_SIZE];
    #endif
    #if !defined(NO_SHA)
        byte sha[WC_SHA_DIGEST_SIZE];
    #endif
    #ifndef NO_SHA256
        byte sha256[WC_SHA256_DIGEST_SIZE];
    #endif
    #ifdef WOLFSSL_SHA384
        byte sha384[WC_SHA384_DIGEST_SIZE];
    #endif
    #ifdef WOLFSSL_SHA512
        byte sha512[WC_SHA512_DIGEST_SIZE];
    #endif
    #ifdef WOLFSSL_SM3
        byte sm3[WC_SM3_DIGEST_SIZE];
    #endif
} Hashes;

WOLFSSL_LOCAL int BuildCertHashes(const WOLFSSL* ssl, Hashes* hashes);


typedef union Digest {

    wc_Sha256 sha256;


    wc_Sha384 sha384;


    wc_Sha512 sha512;


    wc_Sm3    sm3;

} Digest;



typedef struct x509_buffer {
    int  length;                  
    byte buffer[MAX_X509_SIZE];   
} x509_buffer;



struct WOLFSSL_X509_CHAIN {
    int         count;                    
    x509_buffer certs[MAX_CHAIN_DEPTH];   
};

typedef enum WOLFSSL_SESSION_TYPE {
    WOLFSSL_SESSION_TYPE_UNKNOWN, WOLFSSL_SESSION_TYPE_SSL, WOLFSSL_SESSION_TYPE_CACHE, WOLFSSL_SESSION_TYPE_HEAP } WOLFSSL_SESSION_TYPE;





typedef struct QuicRecord QuicRecord;
typedef struct QuicRecord {
    struct QuicRecord *next;
    uint8_t *data;
    word32 capacity;
    word32 len;
    word32 start;
    word32 end;
    WOLFSSL_ENCRYPTION_LEVEL level;
    word32 rec_hdr_remain;
} QuicEncData;

typedef struct QuicTransportParam QuicTransportParam;
struct QuicTransportParam {
    const uint8_t *data;
    word16 len;
};

WOLFSSL_LOCAL const QuicTransportParam *QuicTransportParam_new(const uint8_t *data, size_t len, void *heap);
WOLFSSL_LOCAL const QuicTransportParam *QuicTransportParam_dup(const QuicTransportParam *tp, void *heap);
WOLFSSL_LOCAL void QuicTransportParam_free(const QuicTransportParam *tp, void *heap);
WOLFSSL_LOCAL int TLSX_QuicTP_Use(WOLFSSL* ssl, TLSX_Type ext_type, int is_response);
WOLFSSL_LOCAL int wolfSSL_quic_add_transport_extensions(WOLFSSL *ssl, int msg_type);








typedef struct TicketNonce {
    byte len;

    byte *data;
    byte dataStatic[MAX_TICKET_NONCE_STATIC_SZ];

    byte data[MAX_TICKET_NONCE_STATIC_SZ];

} TicketNonce;




struct WOLFSSL_SESSION {
    
    WOLFSSL_SESSION_TYPE type;

    int                cacheRow;          

    wolfSSL_Ref        ref;
    byte               altSessionID[ID_LEN];
    byte               haveAltSessionID:1;

    byte               ownExData:1;


    Rem_Sess_Cb        rem_sess_cb;

    void*              heap;
    

    byte               side;              

    word32             bornOn;            
    word32             timeout;           

    byte               sessionID[ID_LEN]; 
    byte               sessionIDSz;

    byte               masterSecret[SECRET_LEN]; 
    word16             haveEMS;           

    WOLFSSL_X509*      peer;              


    ProtocolVersion    version;           


    byte               cipherSuite0;      
    byte               cipherSuite;       


    word16             idLen;             
    byte               serverID[SERVER_ID_LEN]; 


    byte               sessionCtxSz;      
    byte               sessionCtx[ID_LEN]; 


    byte               peerVerifyRet;     


    word16             namedGroup;




    word32             ticketSeen;        

    sword64            ticketSeen;        

    word32             ticketAdd;         
    TicketNonce        ticketNonce;       


    word32             maxEarlyDataSz;



    byte               staticTicket[SESSION_TICKET_LEN];
    byte*              ticket;
    word16             ticketLen;
    word16             ticketLenAlloc;    



    WOLFSSL_X509_CHAIN chain;             
    #ifdef WOLFSSL_ALT_CERT_CHAINS
    WOLFSSL_X509_CHAIN altChain;          
    #endif


    WOLFSSL_CRYPTO_EX_DATA ex_data;

    byte               isSetup:1;
};



WOLFSSL_LOCAL int SessionTicketNoncePopulate(WOLFSSL_SESSION *session, const byte* nonce, byte len);


WOLFSSL_LOCAL int wolfSSL_RAND_Init(void);

WOLFSSL_LOCAL WOLFSSL_SESSION* wolfSSL_NewSession(void* heap);
WOLFSSL_LOCAL WOLFSSL_SESSION* wolfSSL_GetSession( WOLFSSL* ssl, byte* masterSecret, byte restoreSessionCerts);
WOLFSSL_LOCAL void SetupSession(WOLFSSL* ssl);
WOLFSSL_LOCAL void AddSession(WOLFSSL* ssl);

WOLFSSL_API int AddSessionToCache(WOLFSSL_CTX* ctx, WOLFSSL_SESSION* addSession, const byte* id, byte idSz, int* sessionIndex, int side, word16 useTicket, ClientSession** clientCacheEntry);


WOLFSSL_LOCAL ClientSession* AddSessionToClientCache(int side, int row, int idx, byte* serverID, word16 idLen, const byte* sessionID, word16 useTicket);


WOLFSSL_LOCAL WOLFSSL_SESSION* ClientSessionToSession(const WOLFSSL_SESSION* session);
WOLFSSL_LOCAL void TlsSessionCacheUnlockRow(word32 row);
WOLFSSL_LOCAL int TlsSessionCacheGetAndRdLock(const byte *id, const WOLFSSL_SESSION **sess, word32 *lockedRow, byte side);
WOLFSSL_LOCAL int TlsSessionCacheGetAndWrLock(const byte *id, WOLFSSL_SESSION **sess, word32 *lockedRow, byte side);
WOLFSSL_LOCAL void EvictSessionFromCache(WOLFSSL_SESSION* session);

WOLFSSL_API int wolfSSL_GetSessionFromCache(WOLFSSL* ssl, WOLFSSL_SESSION* output);
WOLFSSL_LOCAL int wolfSSL_SetSession(WOLFSSL* ssl, WOLFSSL_SESSION* session);
WOLFSSL_LOCAL void wolfSSL_FreeSession(WOLFSSL_CTX* ctx, WOLFSSL_SESSION* session);
WOLFSSL_LOCAL int wolfSSL_DupSession(const WOLFSSL_SESSION* input, WOLFSSL_SESSION* output, int avoidSysCalls);


typedef int (*hmacfp) (WOLFSSL*, byte*, const byte*, word32, int, int, int, int);


    WOLFSSL_LOCAL WOLFSSL_SESSION* wolfSSL_GetSessionClient( WOLFSSL* ssl, const byte* id, int len);



enum ConnectState {
    CONNECT_BEGIN = 0, CLIENT_HELLO_SENT, HELLO_AGAIN, HELLO_AGAIN_REPLY, FIRST_REPLY_DONE, FIRST_REPLY_FIRST, FIRST_REPLY_SECOND, FIRST_REPLY_THIRD, FIRST_REPLY_FOURTH, FINISHED_DONE, SECOND_REPLY_DONE,   WAIT_FINISHED_ACK   };


















enum AcceptState {
    ACCEPT_BEGIN = 0, ACCEPT_BEGIN_RENEG, ACCEPT_CLIENT_HELLO_DONE, ACCEPT_HELLO_RETRY_REQUEST_DONE, ACCEPT_FIRST_REPLY_DONE, SERVER_HELLO_SENT, CERT_SENT, CERT_VERIFY_SENT, CERT_STATUS_SENT, KEY_EXCHANGE_SENT, CERT_REQ_SENT, SERVER_HELLO_DONE, ACCEPT_SECOND_REPLY_DONE, TICKET_SENT, CHANGE_CIPHER_SENT, ACCEPT_FINISHED_DONE, ACCEPT_THIRD_REPLY_DONE };


















enum AcceptStateTls13 {
    TLS13_ACCEPT_BEGIN = 0, TLS13_ACCEPT_BEGIN_RENEG, TLS13_ACCEPT_CLIENT_HELLO_DONE, TLS13_ACCEPT_HELLO_RETRY_REQUEST_DONE, TLS13_ACCEPT_FIRST_REPLY_DONE, TLS13_ACCEPT_SECOND_REPLY_DONE, TLS13_SERVER_HELLO_SENT, TLS13_ACCEPT_THIRD_REPLY_DONE, TLS13_SERVER_EXTENSIONS_SENT, TLS13_CERT_REQ_SENT, TLS13_CERT_SENT, TLS13_CERT_VERIFY_SENT, TLS13_ACCEPT_FINISHED_SENT, TLS13_PRE_TICKET_SENT, TLS13_ACCEPT_FINISHED_DONE, TLS13_TICKET_SENT };

















typedef struct Buffers {
    bufferStatic    inputBuffer;
    bufferStatic    outputBuffer;
    buffer          domainName;            
    buffer          clearOutputBuffer;
    buffer          sig;                   
    buffer          digest;                
    int             prevSent;              
    int             plainSz;               
    byte            weOwnCert;             
    byte            weOwnCertChain;        
    byte            weOwnKey;              
    byte            weOwnDH;               

    buffer          serverDH_P;            
    buffer          serverDH_G;            
    buffer          serverDH_Pub;
    buffer          serverDH_Priv;
    DhKey*          serverDH_Key;


    DerBuffer*      certificate;           
    DerBuffer*      key;                   
    byte            keyType:6;             
    byte            keyId:1;               
    byte            keyLabel:1;            
    int             keySz;                 
    int             keyDevId;              
    DerBuffer*      certChain;             
                 

    int             certChainCnt;
    DerBuffer*      certExts;



    buffer          tls13CookieSecret;     


    WOLFSSL_DTLS_CTX dtlsCtx;              
    #ifndef NO_WOLFSSL_SERVER
        buffer       dtlsCookieSecret;     
    #endif 


    #ifdef HAVE_ECC
        buffer peerEccDsaKey;              
    #endif 
    #ifdef HAVE_ED25519
        buffer peerEd25519Key;             
    #endif 
    #ifdef HAVE_ED448
        buffer peerEd448Key;             
    #endif 
    #ifndef NO_RSA
        buffer peerRsaKey;                 
    #endif 

} Buffers;


enum asyncState {
    TLS_ASYNC_BEGIN = 0, TLS_ASYNC_BUILD, TLS_ASYNC_DO, TLS_ASYNC_VERIFY, TLS_ASYNC_FINALIZE, TLS_ASYNC_END };







enum buildMsgState {
    BUILD_MSG_BEGIN = 0, BUILD_MSG_SIZE, BUILD_MSG_HASH, BUILD_MSG_VERIFY_MAC, BUILD_MSG_ENCRYPT, BUILD_MSG_ENCRYPTED_VERIFY_MAC, };







enum cipherState {
    CIPHER_STATE_BEGIN = 0, CIPHER_STATE_DO, CIPHER_STATE_END, };



struct Options {

    wc_psk_client_callback client_psk_cb;
    wc_psk_server_callback server_psk_cb;

    wc_psk_use_session_cb_func session_psk_cb;


    wc_psk_client_cs_callback    client_psk_cs_cb;     
    wc_psk_client_tls13_callback client_psk_tls13_cb;  
    wc_psk_server_tls13_callback server_psk_tls13_cb;  

    void*             psk_ctx;

    unsigned long     mask; 

    word16            minProto:1; 
    word16            maxProto:1; 


    unsigned int      maxTicketTls13;  
    unsigned int      ticketsSent;     


    

    word16            havePSK:1;            

    word16            sendVerify:2;     
    word16            sessionCacheOff:1;
    word16            sessionCacheFlushOff:1;

    word16            internalCacheOff:1;
    word16            internalCacheLookupOff:1;

    word16            side:2;             
    word16            verifyPeer:1;
    word16            verifyNone:1;
    word16            failNoCert:1;
    word16            failNoCertxPSK:1;   
    word16            downgrade:1;        
    word16            resuming:1;

    word16            resumed:1;          

    word16            isPSK:1;
    word16            haveSessionId:1;    
    word16            tls:1;              
    word16            tls1_1:1;           
    word16            tls1_3:1;           
    word16            seenUnifiedHdr:1;   
    word16            dtls:1;             

    word16            dtlsStateful:1;     

    word16            connReset:1;        
    word16            isClosed:1;         
    word16            closeNotify:1;      
    word16            sentNotify:1;       
    word16            shutdownDone:1;     
    word16            usingCompression:1; 
    word16            haveRSA:1;          
    word16            haveECC:1;          
    word16            haveDH:1;           
    word16            haveECDSAsig:1;     
    word16            haveStaticECC:1;    
    word16            haveFalconSig:1;    
    word16            haveDilithiumSig:1; 
    word16            havePeerCert:1;     
    word16            havePeerVerify:1;   
    word16            usingPSK_cipher:1;  
    word16            usingAnon_cipher:1; 

    word16            noPskDheKe:1;       

    word16            onlyPskDheKe:1;     


    word16            partialWrite:1;     
    word16            quietShutdown:1;    
    word16            certOnly:1;         
    word16            groupMessages:1;    
    word16            saveArrays:1;       
    word16            weOwnRng:1;         
    word16            dontFreeDigest:1;   
    word16            haveEMS:1;          

    word16            oldPoly:1;        

    word16            haveAnon:1;       

    word16            createTicket:1;     
    word16            useTicket:1;        
    word16            rejectTicket:1;     
    word16            noTicketTls12:1;    

    word16            noTicketTls13:1;    




    word16            dtlsDoSCR:1;        

    word16            dtlsUseNonblock:1;  
    word16            dtlsHsRetain:1;     
    word16            haveMcast:1;        

    word16            dtlsSctp:1;         



    word16            userCurves:1;       

    word16            keepResources:1;    
    word16            useClientOrder:1;   
    word16            mutualAuth:1;       
    word16            peerAuthGood:1;     

    word16            pskNegotiated:1;    


    word16            postHandshakeAuth:1;
    word16            verifyPostHandshake:1; 


    word16            sendCookie:1;       


    word16            usingAltCertChain:1;


    word16            sentChangeCipher:1; 




    word16            cacheMessages:1;    


    #if !defined(WOLFSSL_OLD_PRIME_CHECK) &&  !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST
        word16        dhDoKeyTest:1;      
        word16        dhKeyTested:1;      
    #endif


    word16            disallowEncThenMac:1;   
    word16            encThenMac:1;           
    word16            startedETMRead:1;       
    word16            startedETMWrite:1;      


    word16            buildArgsSet:1;         

    word16            buildingMsg:1;      

    word16            dtls13SendMoreAcks:1;  

    word16            dtls13NoHrrOnResume:1;


    word16            dtls13ChFrag:1;



    word16            tls13MiddleBoxCompat:1; 


    word16            useDtlsCID:1;


    word16            useEch:1;


    word16            cookieGood:1;


    word16            useDANE:1;


    RpkConfig         rpkConfig;
    RpkState          rpkState;


    
    byte            processReply;           
    byte            cipherSuite0;           
    byte            cipherSuite;            
    byte            hashAlgo;               
    byte            sigAlgo;                
    byte            serverState;
    byte            clientState;
    byte            handShakeState;
    byte            handShakeDone;      
    byte            minDowngrade;       
    byte            connectState;       
    byte            acceptState;        
    byte            asyncState;         
    byte            buildMsgState;      
    byte            alertCount;         

    word16          mcastID;            


    word16          minDhKeySz;         
    word16          maxDhKeySz;         
    word16          dhKeySz;            


    short           minRsaKeySz;      


    short           minEccKeySz;      


    short           minFalconKeySz;   
    short           minDilithiumKeySz;


    byte            verifyDepth;      


    word16          pskIdIndex;
    word32          maxEarlyDataSz;


    byte            oldMinor;          

};

typedef struct Arrays {
    byte*           pendingMsg;         
    byte*           preMasterSecret;
    word32          preMasterSz;        
    word32          pendingMsgSz;       
    word32          pendingMsgOffset;   

    word32          psk_keySz;          
    char            client_identity[MAX_PSK_ID_LEN + NULL_TERM_LEN];
    char            server_hint[MAX_PSK_ID_LEN + NULL_TERM_LEN];
    byte            psk_key[MAX_PSK_KEY_LEN];

    byte            clientRandom[RAN_LEN];

    byte            clientRandomInner[RAN_LEN];

    byte            serverRandom[RAN_LEN];
    byte            sessionID[ID_LEN];
    byte            sessionIDSz;

    byte            secret[SECRET_LEN];


    byte            exporterSecret[WC_MAX_DIGEST_SIZE];

    byte            masterSecret[SECRET_LEN];

    byte            tsip_masterSecret[TSIP_TLS_MASTERSECRET_SIZE];


    byte            fspsm_masterSecret[FSPSM_TLS_MASTERSECRET_SIZE];


    byte            cookie[MAX_COOKIE_LEN];
    byte            cookieSz;

    byte            pendingMsgType;    
} Arrays;


    #ifndef NO_ASN
        
        #define ASN_NAME_MAX WC_ASN_NAME_MAX
    #else
        
        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) ||  defined(WOLFSSL_CERT_EXT
            #define ASN_NAME_MAX 330
        #else
            #define ASN_NAME_MAX 256
        #endif
    #endif






typedef enum {
    STACK_TYPE_X509               = 0, STACK_TYPE_GEN_NAME           = 1, STACK_TYPE_BIO                = 2, STACK_TYPE_OBJ                = 3, STACK_TYPE_STRING             = 4, STACK_TYPE_CIPHER             = 5, STACK_TYPE_ACCESS_DESCRIPTION = 6, STACK_TYPE_X509_EXT           = 7, STACK_TYPE_NULL               = 8, STACK_TYPE_X509_NAME          = 9, STACK_TYPE_CONF_VALUE         = 10, STACK_TYPE_X509_INFO          = 11, STACK_TYPE_BY_DIR_entry       = 12, STACK_TYPE_BY_DIR_hash        = 13, STACK_TYPE_X509_OBJ           = 14, STACK_TYPE_DIST_POINT         = 15, STACK_TYPE_X509_CRL           = 16, STACK_TYPE_X509_NAME_ENTRY    = 17, STACK_TYPE_X509_REQ_ATTR      = 18, } WOLF_STACK_TYPE;



















struct WOLFSSL_STACK {
    unsigned long num; 
    #if defined(OPENSSL_ALL)
    wolf_sk_hash_cb hash_fn;
    unsigned long hash;
    #endif

    union {
        WOLFSSL_X509*          x509;
        WOLFSSL_X509_NAME*     name;
        WOLFSSL_X509_NAME_ENTRY* name_entry;
        WOLFSSL_X509_INFO*     info;
        WOLFSSL_BIO*           bio;
        WOLFSSL_ASN1_OBJECT*   obj;
        WOLFSSL_CIPHER         cipher;
        WOLFSSL_ACCESS_DESCRIPTION* access;
        WOLFSSL_X509_EXTENSION* ext;

        WOLFSSL_CONF_VALUE*    conf;

        void*                  generic;
        char*                  string;
        WOLFSSL_GENERAL_NAME*  gn;
        WOLFSSL_BY_DIR_entry*  dir_entry;
        WOLFSSL_BY_DIR_HASH*   dir_hash;
        WOLFSSL_X509_OBJECT*   x509_obj;
        WOLFSSL_DIST_POINT*    dp;
        WOLFSSL_X509_CRL*      crl;
    } data;
    void* heap; 
    WOLFSSL_STACK* next;
    WOLF_STACK_TYPE type;     
};

struct WOLFSSL_X509_NAME {
    char  *name;
    int   dynamicName;
    int   sz;
    char  staticName[ASN_NAME_MAX];

    DecodedName fullName;
    int   entrySz; 
    WOLFSSL_X509_NAME_ENTRY entry[MAX_NAME_ENTRIES]; 
    WOLFSSL_X509*           x509;   


    byte  raw[ASN_NAME_MAX];
    int   rawLen;

    WOLF_STACK_OF(WOLFSSL_X509_NAME_ENTRY)* entries;

    void* heap;
};


    #define EXTERNAL_SERIAL_SIZE 32



    typedef struct DNS_entry DNS_entry;


struct WOLFSSL_X509 {
    int              version;
    int              serialSz;

    int              deviceTypeSz;
    int              hwTypeSz;
    byte             deviceType[EXTERNAL_SERIAL_SIZE];
    byte             hwType[EXTERNAL_SERIAL_SIZE];
    int              hwSerialNumSz;
    byte             hwSerialNum[EXTERNAL_SERIAL_SIZE];



    byte             certPolicySet;
    byte             certPolicyCrit;


    WOLFSSL_STACK* ext_sk; 
    WOLFSSL_STACK* ext_sk_full; 
    WOLFSSL_STACK* ext_d2i;


    WOLFSSL_ASN1_INTEGER* serialNumber; 

    WOLFSSL_ASN1_TIME notBefore;
    WOLFSSL_ASN1_TIME notAfter;
    buffer           sig;
    int              sigOID;
    DNS_entry*       altNames;                       
    buffer           pubKey;
    int              pubKeyOID;
    DNS_entry*       altNamesNext;                   

    word32       pkCurveOID;


    DerBuffer*   derCert;                            

    void*            heap;                           
    byte             dynamicMemory;                  
    byte             isCa:1;

    char             certPolicies[MAX_CERTPOL_NB][MAX_CERTPOL_SZ];
    int              certPoliciesNb;


    wolfSSL_Ref      ref;



    WOLFSSL_CRYPTO_EX_DATA ex_data;

    byte*            authKeyId; 
    byte*            authKeyIdSrc;
    byte*            subjKeyId;
    byte*            extKeyUsageSrc;

    byte*            subjAltNameSrc;

    byte*            rawCRLInfo;
    byte*            CRLInfo;
    byte*            authInfo;

    byte*            authInfoCaIssuer;
    int              authInfoCaIssuerSz;

    word32           pathLength;
    word16           keyUsage;
    int              rawCRLInfoSz;
    int              CRLInfoSz;
    int              authInfoSz;
    word32           authKeyIdSz;
    word32           authKeyIdSrcSz;
    word32           subjKeyIdSz;
    byte             extKeyUsage;
    word32           extKeyUsageSz;
    word32           extKeyUsageCount;

    byte             nsCertType;


    word32           subjAltNameSz;


    byte             CRLdistSet:1;
    byte             CRLdistCrit:1;
    byte             authInfoSet:1;
    byte             authInfoCrit:1;
    byte             keyUsageSet:1;
    byte             keyUsageCrit:1;
    byte             extKeyUsageCrit:1;
    byte             subjKeyIdSet:1;

    byte             subjKeyIdCrit:1;
    byte             basicConstSet:1;
    byte             basicConstCrit:1;
    byte             basicConstPlSet:1;
    byte             subjAltNameSet:1;
    byte             subjAltNameCrit:1;
    byte             authKeyIdSet:1;
    byte             authKeyIdCrit:1;
    byte             issuerSet:1;

    CertExtension    custom_exts[NUM_CUSTOM_EXT];
    int              customExtCount;



    byte             isCSR:1;

    byte             serial[EXTERNAL_SERIAL_SIZE];
    char             subjectCN[ASN_NAME_MAX];        


    
    WOLF_STACK_OF(WOLFSSL_X509_ATRIBUTE)* reqAttributes;

    #if defined(WOLFSSL_CERT_REQ)
    char             challengePw[CTC_NAME_SIZE]; 
    char             contentType[CTC_NAME_SIZE];
    #endif

    WOLFSSL_X509_NAME issuer;
    WOLFSSL_X509_NAME subject;

    WOLFSSL_X509_ALGOR algor;
    WOLFSSL_X509_PUBKEY key;



    byte            notBeforeData[CTC_DATE_SIZE];
    byte            notAfterData[CTC_DATE_SIZE];

};



typedef struct RecordLayerHeader {
    byte            type;
    byte            pvMajor;
    byte            pvMinor;
    byte            length[2];
} RecordLayerHeader;



typedef struct DtlsRecordLayerHeader {
    byte            type;
    byte            pvMajor;
    byte            pvMinor;
    byte            sequence_number[8];   
    byte            length[2];
} DtlsRecordLayerHeader;

typedef struct DtlsFragBucket {
    
    union {
        struct {
            struct DtlsFragBucket* next;
            word32 offset;
            word32 sz;
        } m;
        
        byte padding[DTLS_HANDSHAKE_HEADER_SZ];
    } m;




    byte buf[];
} DtlsFragBucket;

typedef struct DtlsMsg {
    struct DtlsMsg* next;
    byte*           raw;
    byte*           fullMsg;   
    DtlsFragBucket* fragBucketList;
    word32          bytesReceived;
    word16          epoch;     
    word32          seq;       
    word32          sz;        
    byte            type;
    byte            fragBucketListCount;
    byte            ready:1;
} DtlsMsg;




    
    typedef struct NetX_Ctx {
        NX_TCP_SOCKET* nxSocket;    
        NX_PACKET*     nxPacket;    
        ULONG          nxOffset;    
        ULONG          nxWait;      
    } NetX_Ctx;




typedef struct MsgsReceived {
    word16 got_hello_request:1;
    word16 got_client_hello:2;
    word16 got_server_hello:1;
    word16 got_hello_verify_request:1;
    word16 got_session_ticket:1;
    word16 got_end_of_early_data:1;
    word16 got_hello_retry_request:1;
    word16 got_encrypted_extensions:1;
    word16 got_certificate:1;
    word16 got_certificate_status:1;
    word16 got_server_key_exchange:1;
    word16 got_certificate_request:1;
    word16 got_server_hello_done:1;
    word16 got_certificate_verify:1;
    word16 got_client_key_exchange:1;
    word16 got_finished:1;
    word16 got_key_update:1;
    word16 got_change_cipher:1;
} MsgsReceived;



typedef struct HS_Hashes {
    Hashes          verifyHashes;
    Hashes          certHashes;         

    wc_Sha          hashSha;            


    wc_Md5          hashMd5;            


    wc_Sha256       hashSha256;         


    wc_Sha384       hashSha384;         


    wc_Sha512       hashSha512;         


    wc_Sm3          hashSm3;            



    byte*           messages;           
    int             length;             
    int             prevLen;            

} HS_Hashes;




typedef struct BuildMsgArgs {
    word32 digestSz;
    word32 sz;
    word32 pad;
    word32 idx;
    word32 headerSz;
    word16 size;
    word32 ivSz;      
    byte*  iv;
    ALIGN16 byte staticIvBuffer[MAX_IV_SZ];
} BuildMsgArgs;



    #define MAX_ASYNC_ARGS 18
    typedef void (*FreeArgsCb)(struct WOLFSSL* ssl, void* pArgs);

    struct WOLFSSL_ASYNC {

        BuildMsgArgs  buildArgs; 

        FreeArgsCb    freeArgs; 
        word32        args[MAX_ASYNC_ARGS]; 
    };




    #define WRITE_DUP_SIDE 1
    #define READ_DUP_SIDE 2

    typedef struct WriteDup {
        wolfSSL_Mutex   dupMutex;       
        int             dupCount;       
        int             dupErr;         
    } WriteDup;

    WOLFSSL_LOCAL void FreeWriteDup(WOLFSSL* ssl);
    WOLFSSL_LOCAL int  NotifyWriteSide(WOLFSSL* ssl, int err);



typedef struct CertReqCtx CertReqCtx;

struct CertReqCtx {
    CertReqCtx* next;
    byte        len;
    byte        ctx;
};



typedef enum EarlyDataState {
    no_early_data, early_data_ext, expecting_early_data, process_early_data, done_early_data } EarlyDataState;











typedef struct Dtls13UnifiedHdrInfo {
    word16 recordLength;
    byte seqLo;
    byte seqHi;
    byte seqHiPresent:1;
    byte epochBits;
} Dtls13UnifiedHdrInfo;

enum  {
    DTLS13_EPOCH_EARLYDATA = 1, DTLS13_EPOCH_HANDSHAKE = 2, DTLS13_EPOCH_TRAFFIC0 = 3 };



typedef struct Dtls13Epoch {
    w64wrapper epochNumber;

    w64wrapper nextSeqNumber;
    w64wrapper nextPeerSeqNumber;


    w64wrapper dropCount; 


    word32 window[WOLFSSL_DTLS_WINDOW_WORDS];

    
    byte client_write_key[MAX_SYM_KEY_SIZE];
    byte server_write_key[MAX_SYM_KEY_SIZE];
    byte client_write_IV[MAX_WRITE_IV_SZ];
    byte server_write_IV[MAX_WRITE_IV_SZ];

    byte aead_exp_IV[AEAD_MAX_EXP_SZ];
    byte aead_enc_imp_IV[AEAD_MAX_IMP_SZ];
    byte aead_dec_imp_IV[AEAD_MAX_IMP_SZ];

    byte client_sn_key[MAX_SYM_KEY_SIZE];
    byte server_sn_key[MAX_SYM_KEY_SIZE];

    byte isValid;
    byte side;
} Dtls13Epoch;









enum Dtls13RtxFsmState {
    DTLS13_RTX_FSM_PREPARING = 0, DTLS13_RTX_FSM_SENDING, DTLS13_RTX_FSM_WAITING, DTLS13_RTX_FSM_FINISHED };




typedef struct Dtls13RtxRecord {
    struct Dtls13RtxRecord *next;
    word16 length;
    byte *data;
    w64wrapper epoch;
    w64wrapper seq[DTLS13_RETRANS_RN_SIZE];
    byte rnIdx;
    byte handshakeType;
} Dtls13RtxRecord;

typedef struct Dtls13RecordNumber {
    struct Dtls13RecordNumber *next;
    w64wrapper epoch;
    w64wrapper seq;
} Dtls13RecordNumber;

typedef struct Dtls13Rtx {
    enum Dtls13RtxFsmState state;
    Dtls13RtxRecord *rtxRecords;
    Dtls13RtxRecord **rtxRecordTailPtr;
    Dtls13RecordNumber *seenRecords;
    word32 lastRtx;
    byte triggeredRtxs;
    byte sendAcks:1;
    byte retransmit:1;
} Dtls13Rtx;




typedef struct CIDInfo CIDInfo;








struct WOLFSSL {
    WOLFSSL_CTX*    ctx;

    WOLFSSL_CTX*    initial_ctx; 

    Suites*         suites; 

    const Suites*   clSuites;


    WOLF_STACK_OF(WOLFSSL_CIPHER)* suitesStack; 

    Arrays*         arrays;

    byte            clientSecret[SECRET_LEN];
    byte            serverSecret[SECRET_LEN];

    HS_Hashes*      hsHashes;

    HS_Hashes*      hsHashesEch;

    void*           IOCB_ReadCtx;
    void*           IOCB_WriteCtx;
    WC_RNG*         rng;
    void*           verifyCbCtx;        
    VerifyCallback  verifyCallback;     
    void*           heap;               

    WriteDup*       dupWrite;           
             
    byte            dupSide;            


    byte              cbioFlag;         


    NetworkFilterCallback_t AcceptFilter;
    void *AcceptFilter_arg;
    NetworkFilterCallback_t ConnectFilter;
    void *ConnectFilter_arg;

    CallbackIORecv  CBIORecv;
    CallbackIOSend  CBIOSend;

    WOLFSSL_HEAP_HINT heap_hint;


    ClientHelloGoodCb chGoodCb;        
    void*             chGoodCtx;       


    HandShakeDoneCb hsDoneCb;          
    void*           hsDoneCtx;         



    WC_ASYNC_DEV* asyncDev;

    
    struct WOLFSSL_ASYNC* async;

    void*           hsKey;              
    word32          hsType;             
    WOLFSSL_CIPHER  cipher;

    hmacfp          hmac;

    Ciphers         encrypt;
    Ciphers         decrypt;
    Buffers         buffers;
    WOLFSSL_SESSION* session;

    ClientSession*  clientSession;

    WOLFSSL_ALERT_HISTORY alert_history;
    WOLFSSL_ALERT   pendingAlert;
    int             error;
    int             rfd;                
    int             wfd;                
    int             rflags;             
    int             wflags;             
    word32          timeout;            
    word32          fragOffset;         
    word16          curSize;
    byte            verifyDepth;
    RecordLayerHeader curRL;
    MsgsReceived    msgsReceived;       
    ProtocolVersion version;            
    ProtocolVersion chVersion;          
    CipherSpecs     specs;
    Keys            keys;
    Options         options;

    byte             sessionCtx[ID_LEN]; 
    byte             sessionCtxSz;       


    CallbackInfoState* CBIS;             
    int              cbmode;             
    int              cbtype;             
    WOLFSSL_BIO*     biord;              
    WOLFSSL_BIO*     biowr;              
    WOLFSSL_X509_VERIFY_PARAM* param;    


    word32            disabledCurves;   


    unsigned long    peerVerifyRet;


    byte             readAhead;

    void*            loggingCtx;         



    RsaKey*         peerRsaKey;

    void*           RenesasUserCtx;
    byte*           peerSceTsipEncRsaKeyIndex;

    byte            peerRsaKeyPresent;


    word16          namedGroup;


    word16          group[WOLFSSL_MAX_GROUP_COUNT];
    byte            numGroups;

    word16          pssAlgo;

    word16          certHashSigAlgoSz;  
    byte            certHashSigAlgo[WOLFSSL_MAX_SIGALGO]; 


    int             eccVerifyRes;


    word32          ecdhCurveOID;            
    ecc_key*        eccTempKey;              
    byte            eccTempKeyPresent;       
    byte            peerEccKeyPresent;


    ecc_key*        peerEccKey;              
    ecc_key*        peerEccDsaKey;           
    word16          eccTempKeySz;            
    byte            peerEccDsaKeyPresent;


    word32          pkCurveOID;              


    ed25519_key*    peerEd25519Key;
    byte            peerEd25519KeyPresent;


    curve25519_key* peerX25519Key;
    byte            peerX25519KeyPresent;


    ed448_key*      peerEd448Key;
    byte            peerEd448KeyPresent;


    curve448_key*   peerX448Key;
    byte            peerX448KeyPresent;


    falcon_key*     peerFalconKey;
    byte            peerFalconKeyPresent;
    dilithium_key*  peerDilithiumKey;
    byte            peerDilithiumKeyPresent;


    z_stream        c_stream;           
    z_stream        d_stream;           
    byte            didStreamInit;      


    int             dtls_timeout_init;  
    int             dtls_timeout_max;   
    int             dtls_timeout;       

    word32          dtls_start_timeout;

    word32          dtls_tx_msg_list_sz;
    word32          dtls_rx_msg_list_sz;
    DtlsMsg*        dtls_tx_msg_list;
    DtlsMsg*        dtls_tx_msg;
    DtlsMsg*        dtls_rx_msg_list;
    void*           IOCB_CookieCtx;     

    wc_dtls_export  dtls_export;        


    word16          dtlsMtuSz;


    void*           mcastHwCbCtx;       


    word32 macDropCount;
    word32 replayDropCount;


    word16         dtlsSrtpProfiles;   
    word16         dtlsSrtpId;         


    RecordNumberCiphers dtlsRecordNumberEncrypt;
    RecordNumberCiphers dtlsRecordNumberDecrypt;
    Dtls13Epoch dtls13Epochs[DTLS13_EPOCH_SIZE];
    Dtls13Epoch *dtls13EncryptEpoch;
    Dtls13Epoch *dtls13DecryptEpoch;
    w64wrapper dtls13Epoch;
    w64wrapper dtls13PeerEpoch;
    w64wrapper dtls13InvalidateBefore;
    byte dtls13CurRL[DTLS_RECVD_RL_HEADER_MAX_SZ];
    word16 dtls13CurRlLength;

    
    buffer dtls13FragmentsBuffer;
    byte dtls13SendingFragments:1;
    byte dtls13SendingAckOrRtx:1;
    byte dtls13FastTimeout:1;
    byte dtls13WaitKeyUpdateAck:1;
    byte dtls13DoKeyUpdate:1;
    word32 dtls13MessageLength;
    word32 dtls13FragOffset;
    byte dtls13FragHandshakeType;
    Dtls13Rtx dtls13Rtx;
    byte *dtls13ClientHello;
    word16 dtls13ClientHelloSz;



    CIDInfo *dtlsCidInfo;




    TimeoutInfo     timeoutInfo;        
    HandShakeInfo   handShakeInfo;      


    SSL_Msg_Cb      protoMsgCb;         
    void*           protoMsgCtx;        


    byte            hsInfoOn;           
    byte            toInfoOn;           


    CallbackFuzzer  fuzzerCb;           
    void*           fuzzerCtx;          


    CertReqCtx*     certReqCtx;


    WOLFSSL_X509_STORE* x509_store_pt; 


    
    WOLFSSL_X509     peerCert;           


    WOLFSSL_X509*    ourCert;            

    byte             keepCert;           

    WOLFSSL_CRYPTO_EX_DATA ex_data; 

    int              devId;             

    OneTimeAuth     auth;


    TLSX* extensions;                  
    #ifdef HAVE_MAX_FRAGMENT
        word16 max_fragment;
    #endif
    #ifdef HAVE_TRUNCATED_HMAC
        byte truncated_hmac;
    #endif
    #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
        byte status_request;
    #endif
    #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
        byte status_request_v2;
    #endif
    #if defined(HAVE_SECURE_RENEGOTIATION)  || defined(HAVE_SERVER_RENEGOTIATION_INFO
        int                  secure_rene_count;    
        SecureRenegotiation* secure_renegotiation; 
    #endif                                         
    #ifdef HAVE_ALPN
        byte *alpn_peer_requested; 
        word16 alpn_peer_requested_length; 
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX)  ||  defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_QUIC
            CallbackALPNSelect alpnSelect;
            void*              alpnSelectArg;
        #endif
    #endif                         
    #if !defined(NO_WOLFSSL_CLIENT) && defined(HAVE_SESSION_TICKET)
        CallbackSessionTicket session_ticket_cb;
        void*                 session_ticket_ctx;
        byte                  expect_session_ticket;
    #endif


        void*       ocspIOCtx;
        byte ocspProducedDate[MAX_DATE_SZ];
        int ocspProducedDateFormat;
    #ifdef OPENSSL_EXTRA
        byte*       ocspResp;
        int         ocspRespSz;
        #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
            char*   url;
        #endif
    #endif


    NetX_Ctx        nxCtx;             


    void*           mnCtx;             


    struct gnrc_wolfssl_ctx *gnrcCtx;  


    int sessionIndex;                  


    void*    MacEncryptCtx;    
    void*    DecryptVerifyCtx; 
    #ifdef HAVE_ENCRYPT_THEN_MAC
        void*    EncryptMacCtx;    
        void*    VerifyDecryptCtx; 
    #endif


    #ifdef HAVE_ECC
        void* EccKeyGenCtx;          
        void* EccSignCtx;            
        void* EccVerifyCtx;          
        void* EccSharedSecretCtx;    
    #endif 
    #ifdef HAVE_HKDF
        void* HkdfExtractCtx;       
    #endif
    #ifdef HAVE_ED25519
        void* Ed25519SignCtx;        
        void* Ed25519VerifyCtx;      
    #endif
    #ifdef HAVE_CURVE25519
        void* X25519KeyGenCtx;       
        void* X25519SharedSecretCtx; 
    #endif
    #ifdef HAVE_ED448
        void* Ed448SignCtx;          
        void* Ed448VerifyCtx;        
    #endif
    #ifdef HAVE_CURVE448
        void* X448KeyGenCtx;         
        void* X448SharedSecretCtx;   
    #endif
    #ifndef NO_DH
        void* DhAgreeCtx; 
    #endif 
    #ifndef NO_RSA
        void* RsaSignCtx;     
        void* RsaVerifyCtx;   
        #ifdef WC_RSA_PSS
            void* RsaPssSignCtx;     
            void* RsaPssVerifyCtx;   
        #endif
        void* RsaEncCtx;      
        void* RsaDecCtx;      
    #endif 
    void* GenPreMasterCtx;   
    void* GenMasterCtx;      
    void* GenSessionKeyCtx;  
    void* EncryptKeysCtx;    
    void* TlsFinishedCtx;    
    void* VerifyMacCtx;      


        SessionSecretCb sessionSecretCb;
        void*           sessionSecretCtx;
    #ifdef WOLFSSL_TLS13
        Tls13SecretCb   tls13SecretCb;
        void*           tls13SecretCtx;
    #endif
    #ifdef OPENSSL_EXTRA
        SessionSecretCb keyLogCb;
    #ifdef WOLFSSL_TLS13
        Tls13SecretCb   tls13KeyLogCb;
    #endif
    #endif


        void* jObjectRef;     


    EarlyDataState earlyData;
    word32 earlyDataSz;
    byte earlyDataStatus;


    WOLFSSL_STACK* supportedCiphers; 
    WOLFSSL_STACK* peerCertChain;    

    WOLFSSL_STACK* ourCertChain;    



    StaticKeyExchangeInfo_t staticKE;


    maxq_ssl_t maxq_ctx;


    
    byte clientFinished[TLS_FINISHED_SZ_MAX];
    byte serverFinished[TLS_FINISHED_SZ_MAX];
    byte clientFinished_len;
    byte serverFinished_len;


    WOLF_STACK_OF(WOLFSSL_X509_NAME)* client_ca_names;


    IOTSAFE iotsafe;


    WOLFSSL_LWIP_NATIVE_STATE      lwipCtx; 


    struct {
        const WOLFSSL_QUIC_METHOD* method;
        WOLFSSL_ENCRYPTION_LEVEL enc_level_read;
        WOLFSSL_ENCRYPTION_LEVEL enc_level_read_next;
        WOLFSSL_ENCRYPTION_LEVEL enc_level_latest_recvd;
        WOLFSSL_ENCRYPTION_LEVEL enc_level_write;
        WOLFSSL_ENCRYPTION_LEVEL enc_level_write_next;
        int transport_version;
        const QuicTransportParam* transport_local;
        const QuicTransportParam* transport_peer;
        const QuicTransportParam* transport_peer_draft;
        QuicRecord* input_head;          
        QuicRecord* input_tail;          
        QuicRecord* scratch;             
        enum wolfssl_encryption_level_t output_rec_level;
                                         
        word32 output_rec_remain;        
    } quic;


    WOLFSSL_EchConfig* echConfigs;



    SSLSnifferSecretCb snifferSecretCb;


};





























WOLFSSL_LOCAL int  SetSSL_CTX(WOLFSSL* ssl, WOLFSSL_CTX* ctx, int writeDup);
WOLFSSL_LOCAL int  InitSSL(WOLFSSL* ssl, WOLFSSL_CTX* ctx, int writeDup);
WOLFSSL_LOCAL int  ReinitSSL(WOLFSSL* ssl, WOLFSSL_CTX* ctx, int writeDup);
WOLFSSL_LOCAL void FreeSSL(WOLFSSL* ssl, void* heap);
WOLFSSL_API   void SSL_ResourceFree(WOLFSSL* ssl);   




    WOLFSSL_LOCAL int ProcessBuffer(WOLFSSL_CTX* ctx, const unsigned char* buff, long sz, int format, int type, WOLFSSL* ssl, long* used, int userChain, int verify);

    WOLFSSL_LOCAL int ProcessFile(WOLFSSL_CTX* ctx, const char* fname, int format, int type, WOLFSSL* ssl, int userChain, WOLFSSL_CRL* crl, int verify);


    WOLFSSL_LOCAL int CheckHostName(DecodedCert* dCert, const char *domainName, size_t domainNameLen);




    WOLFSSL_LOCAL void InitHandShakeInfo(HandShakeInfo* info, WOLFSSL* ssl);
    WOLFSSL_LOCAL void FinishHandShakeInfo(HandShakeInfo* info);
    WOLFSSL_LOCAL void AddPacketName(WOLFSSL* ssl, const char* name);

    WOLFSSL_LOCAL void InitTimeoutInfo(TimeoutInfo* info);
    WOLFSSL_LOCAL void FreeTimeoutInfo(TimeoutInfo* info, void* heap);
    WOLFSSL_LOCAL int AddPacketInfo(WOLFSSL* ssl, const char* name, int type, const byte* data, int sz, int written, int lateRL, void* heap);

    WOLFSSL_LOCAL void AddLateName(const char* name, TimeoutInfo* info);
    WOLFSSL_LOCAL void AddLateRecordHeader(const RecordLayerHeader* rl, TimeoutInfo* info);




enum ContentType {
    no_type            = 0, change_cipher_spec = 20, alert              = 21, handshake          = 22, application_data   = 23,  ack                = 26,  };










typedef struct HandShakeHeader {
    byte            type;
    word24          length;
} HandShakeHeader;



typedef struct DtlsHandShakeHeader {
    byte            type;
    word24          length;
    byte            message_seq[2];    
    word24          fragment_offset;   
    word24          fragment_length;   
} DtlsHandShakeHeader;


enum HandShakeType {
    hello_request        =   0, client_hello         =   1, server_hello         =   2, hello_verify_request =   3, session_ticket       =   4, end_of_early_data    =   5, hello_retry_request  =   6, encrypted_extensions =   8, certificate          =  11, server_key_exchange  =  12, certificate_request  =  13, server_hello_done    =  14, certificate_verify   =  15, client_key_exchange  =  16, finished             =  20, certificate_status   =  22, key_update           =  24, change_cipher_hs     =  55, message_hash         = 254, no_shake             = 255 };




















enum ProvisionSide {
    PROVISION_CLIENT = 1, PROVISION_SERVER = 2, PROVISION_CLIENT_SERVER = 3 };




enum {
    REQUIRES_RSA, REQUIRES_DHE, REQUIRES_ECC, REQUIRES_ECC_STATIC, REQUIRES_PSK, REQUIRES_RSA_SIG, REQUIRES_AEAD };







static const byte kTlsClientStr[SIZEOF_SENDER+1] = { 0x43, 0x4C, 0x4E, 0x54, 0x00 }; 
static const byte kTlsServerStr[SIZEOF_SENDER+1] = { 0x53, 0x52, 0x56, 0x52, 0x00 }; 

static const byte kTlsClientFinStr[FINISHED_LABEL_SZ + 1] = "client finished";
static const byte kTlsServerFinStr[FINISHED_LABEL_SZ + 1] = "server finished";


typedef struct {
    int name_len;
    const char *name;
    int nid;
} WOLF_EC_NIST_NAME;
extern const WOLF_EC_NIST_NAME kNistCurves[];










WOLFSSL_LOCAL int SendChangeCipher(WOLFSSL* ssl);
WOLFSSL_LOCAL int SendTicket(WOLFSSL* ssl);

WOLFSSL_LOCAL int DoDecryptTicket(const WOLFSSL* ssl, const byte* input, word32 len, InternalTicket **it);

WOLFSSL_LOCAL void DoClientTicketFinalize(WOLFSSL* ssl, InternalTicket* it, const WOLFSSL_SESSION* sess);


WOLFSSL_LOCAL int DoClientTicketCheck(const WOLFSSL* ssl, const PreSharedKey* psk, sword64 timeout, const byte* suite);
WOLFSSL_LOCAL void CleanupClientTickets(PreSharedKey* psk);
WOLFSSL_LOCAL int DoClientTicket_ex(const WOLFSSL* ssl, PreSharedKey* psk, int retainSess);


WOLFSSL_LOCAL int DoClientTicket(WOLFSSL* ssl, const byte* input, word32 len);

WOLFSSL_LOCAL int SendData(WOLFSSL* ssl, const void* data, int sz);

WOLFSSL_LOCAL int SendTls13ServerHello(WOLFSSL* ssl, byte extMsgType);

WOLFSSL_LOCAL int SendCertificate(WOLFSSL* ssl);
WOLFSSL_LOCAL int SendCertificateRequest(WOLFSSL* ssl);

WOLFSSL_LOCAL int CreateOcspResponse(WOLFSSL* ssl, OcspRequest** ocspRequest, buffer* response);


WOLFSSL_LOCAL int SendHelloRequest(WOLFSSL* ssl);

WOLFSSL_LOCAL int SendCertificateStatus(WOLFSSL* ssl);
WOLFSSL_LOCAL int SendServerKeyExchange(WOLFSSL* ssl);
WOLFSSL_LOCAL int SendBuffered(WOLFSSL* ssl);
WOLFSSL_LOCAL int ReceiveData(WOLFSSL* ssl, byte* output, int sz, int peek);
WOLFSSL_LOCAL int SendFinished(WOLFSSL* ssl);
WOLFSSL_LOCAL int RetrySendAlert(WOLFSSL* ssl);
WOLFSSL_LOCAL int SendAlert(WOLFSSL* ssl, int severity, int type);
WOLFSSL_LOCAL int SendFatalAlertOnly(WOLFSSL *ssl, int error);
WOLFSSL_LOCAL int ProcessReply(WOLFSSL* ssl);
WOLFSSL_LOCAL int ProcessReplyEx(WOLFSSL* ssl, int allowSocketErr);

WOLFSSL_LOCAL const char* AlertTypeToString(int type);

WOLFSSL_LOCAL int SetCipherSpecs(WOLFSSL* ssl);
WOLFSSL_LOCAL int GetCipherSpec(word16 side, byte cipherSuite0, byte cipherSuite, CipherSpecs* specs, Options* opts);
WOLFSSL_LOCAL int MakeMasterSecret(WOLFSSL* ssl);

WOLFSSL_LOCAL int DeriveKeys(WOLFSSL* ssl);
WOLFSSL_LOCAL int StoreKeys(WOLFSSL* ssl, const byte* keyData, int side);

WOLFSSL_LOCAL int IsTLS(const WOLFSSL* ssl);
WOLFSSL_LOCAL int IsAtLeastTLSv1_2(const WOLFSSL* ssl);
WOLFSSL_LOCAL int IsAtLeastTLSv1_3(ProtocolVersion pv);
WOLFSSL_LOCAL int IsEncryptionOn(WOLFSSL* ssl, int isSend);
WOLFSSL_LOCAL int TLSv1_3_Capable(WOLFSSL* ssl);

WOLFSSL_LOCAL void FreeHandshakeResources(WOLFSSL* ssl);
WOLFSSL_LOCAL void ShrinkInputBuffer(WOLFSSL* ssl, int forcedFree);
WOLFSSL_LOCAL void ShrinkOutputBuffer(WOLFSSL* ssl);
WOLFSSL_LOCAL byte* GetOutputBuffer(WOLFSSL* ssl);

WOLFSSL_LOCAL int CipherRequires(byte first, byte second, int requirement);
WOLFSSL_LOCAL int VerifyClientSuite(word16 havePSK, byte cipherSuite0, byte cipherSuite);

WOLFSSL_LOCAL int SetTicket(WOLFSSL* ssl, const byte* ticket, word32 length);
WOLFSSL_LOCAL int wolfSSL_GetMaxFragSize(WOLFSSL* ssl, int maxFragment);


WOLFSSL_LOCAL IOTSAFE *wolfSSL_get_iotsafe_ctx(WOLFSSL *ssl);
WOLFSSL_LOCAL int wolfSSL_set_iotsafe_ctx(WOLFSSL *ssl, IOTSAFE *iotsafe);



WOLFSSL_LOCAL int SetECKeyInternal(WOLFSSL_EC_KEY* eckey);
WOLFSSL_LOCAL int SetECKeyExternal(WOLFSSL_EC_KEY* eckey);



WOLFSSL_LOCAL int wolfSSL_curve_is_disabled(const WOLFSSL* ssl, word16 named_curve);




WOLFSSL_LOCAL WC_RNG* WOLFSSL_RSA_GetRNG(WOLFSSL_RSA *rsa, WC_RNG **tmpRNG, int *initTmpRng);


    #ifndef NO_RSA
        #ifdef WC_RSA_PSS
            WOLFSSL_LOCAL int CheckRsaPssPadding(const byte* plain, word32 plainSz, byte* out, word32 sigSz, enum wc_HashType hashType);
            WOLFSSL_LOCAL int ConvertHashPss(int hashAlgo, enum wc_HashType* hashType, int* mgf);
        #endif
        WOLFSSL_LOCAL int VerifyRsaSign(WOLFSSL* ssl, byte* verifySig, word32 sigSz, const byte* plain, word32 plainSz, int sigAlgo, int hashAlgo, RsaKey* key, DerBuffer* keyBufInfo);

        WOLFSSL_LOCAL int RsaSign(WOLFSSL* ssl, const byte* in, word32 inSz, byte* out, word32* outSz, int sigAlgo, int hashAlgo, RsaKey* key, DerBuffer* keyBufInfo);

        WOLFSSL_LOCAL int RsaVerify(WOLFSSL* ssl, byte* in, word32 inSz, byte** out, int sigAlgo, int hashAlgo, RsaKey* key, buffer* keyBufInfo);

        WOLFSSL_LOCAL int RsaDec(WOLFSSL* ssl, byte* in, word32 inSz, byte** out, word32* outSz, RsaKey* key, DerBuffer* keyBufInfo);
        WOLFSSL_LOCAL int RsaEnc(WOLFSSL* ssl, const byte* in, word32 inSz, byte* out, word32* outSz, RsaKey* key, buffer* keyBufInfo);
    #endif 

    #ifdef HAVE_ECC
        WOLFSSL_LOCAL int EccSign(WOLFSSL* ssl, const byte* in, word32 inSz, byte* out, word32* outSz, ecc_key* key, DerBuffer* keyBufInfo);
        WOLFSSL_LOCAL int EccVerify(WOLFSSL* ssl, const byte* in, word32 inSz, const byte* out, word32 outSz, ecc_key* key, buffer* keyBufInfo);
        WOLFSSL_LOCAL int EccSharedSecret(WOLFSSL* ssl, ecc_key* priv_key, ecc_key* pub_key, byte* pubKeyDer, word32* pubKeySz, byte* out, word32* outlen, int side);

    #endif 
    #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
        WOLFSSL_LOCAL int Sm2wSm3Sign(WOLFSSL* ssl, const byte* id, word32 idSz, const byte* in, word32 inSz, byte* out, word32* outSz, ecc_key* key, DerBuffer* keyBufInfo);

        WOLFSSL_LOCAL int Sm2wSm3Verify(WOLFSSL* ssl, const byte* id, word32 idSz, const byte* in, word32 inSz, const byte* out, word32 outSz, ecc_key* key, buffer* keyBufInfo);

    #endif 
    #ifdef HAVE_ED25519
        WOLFSSL_LOCAL int Ed25519CheckPubKey(WOLFSSL* ssl);
        WOLFSSL_LOCAL int Ed25519Sign(WOLFSSL* ssl, const byte* in, word32 inSz, byte* out, word32* outSz, ed25519_key* key, DerBuffer* keyBufInfo);
        WOLFSSL_LOCAL int Ed25519Verify(WOLFSSL* ssl, const byte* in, word32 inSz, const byte* msg, word32 msgSz, ed25519_key* key, buffer* keyBufInfo);

    #endif 
    #ifdef HAVE_ED448
        WOLFSSL_LOCAL int Ed448CheckPubKey(WOLFSSL* ssl);
        WOLFSSL_LOCAL int Ed448Sign(WOLFSSL* ssl, const byte* in, word32 inSz, byte* out, word32* outSz, ed448_key* key, DerBuffer* keyBufInfo);
        WOLFSSL_LOCAL int Ed448Verify(WOLFSSL* ssl, const byte* in, word32 inSz, const byte* msg, word32 msgSz, ed448_key* key, buffer* keyBufInfo);

    #endif 


    #ifdef WOLFSSL_TRUST_PEER_CERT

        
        #define WC_MATCH_SKID 0
        #define WC_MATCH_NAME 1

        WOLFSSL_LOCAL TrustedPeerCert* GetTrustedPeer(void* vp, DecodedCert* cert);
        WOLFSSL_LOCAL int MatchTrustedPeer(TrustedPeerCert* tp, DecodedCert* cert);
    #endif

    #ifndef GetCA
        WOLFSSL_LOCAL Signer* GetCA(void* vp, byte* hash);
    #endif
    #ifdef WOLFSSL_AKID_NAME
        WOLFSSL_LOCAL Signer* GetCAByAKID(void* vp, const byte* issuer, word32 issuerSz, const byte* serial, word32 serialSz);
    #endif
    #if !defined(NO_SKID) && !defined(GetCAByName)
        WOLFSSL_LOCAL Signer* GetCAByName(void* cm, byte* hash);
    #endif

WOLFSSL_LOCAL int  BuildTlsHandshakeHash(WOLFSSL* ssl, byte* hash, word32* hashLen);
WOLFSSL_LOCAL int  BuildTlsFinished(WOLFSSL* ssl, Hashes* hashes, const byte* sender);
WOLFSSL_LOCAL void FreeArrays(WOLFSSL* ssl, int keep);
WOLFSSL_LOCAL  int CheckAvailableSize(WOLFSSL *ssl, int size);
WOLFSSL_LOCAL  int GrowInputBuffer(WOLFSSL* ssl, int size, int usedLength);

WOLFSSL_LOCAL void DoCertFatalAlert(WOLFSSL* ssl, int ret);


    WOLFSSL_LOCAL int  MakeTlsMasterSecret(WOLFSSL* ssl);

    WOLFSSL_LOCAL int  TLS_hmac(WOLFSSL* ssl, byte* digest, const byte* in, word32 sz, int padSz, int content, int verify, int epochOrder);



WOLFSSL_LOCAL int cipherExtraData(WOLFSSL* ssl);


    WOLFSSL_LOCAL int HaveUniqueSessionObj(WOLFSSL* ssl);
    WOLFSSL_LOCAL int SendClientHello(WOLFSSL* ssl);
    WOLFSSL_LOCAL int DoHelloVerifyRequest(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 size);
    #ifdef WOLFSSL_TLS13
    WOLFSSL_LOCAL int SendTls13ClientHello(WOLFSSL* ssl);
    #endif
    WOLFSSL_LOCAL int SendClientKeyExchange(WOLFSSL* ssl);
    WOLFSSL_LOCAL int SendCertificateVerify(WOLFSSL* ssl);



    WOLFSSL_LOCAL int SendServerHello(WOLFSSL* ssl);
    WOLFSSL_LOCAL int SendServerHelloDone(WOLFSSL* ssl);



    WOLFSSL_LOCAL DtlsMsg* DtlsMsgNew(word32 sz, byte tx, void* heap);
    WOLFSSL_LOCAL void DtlsMsgDelete(DtlsMsg* item, void* heap);
    
    WOLFSSL_API void DtlsMsgListDelete(DtlsMsg* head, void* heap);
    WOLFSSL_LOCAL void DtlsTxMsgListClean(WOLFSSL* ssl);
    WOLFSSL_LOCAL int  DtlsMsgSet(DtlsMsg* msg, word32 seq, word16 epoch, const byte* data, byte type, word32 fragOffset, word32 fragSz, void* heap, word32 totalLen);


    
    WOLFSSL_API DtlsMsg* DtlsMsgFind(DtlsMsg* head, word16 epoch, word32 seq);

    
    WOLFSSL_API void DtlsMsgStore(WOLFSSL* ssl, word16 epoch, word32 seq, const byte* data, word32 dataSz, byte type, word32 fragOffset, word32 fragSz, void* heap);


    WOLFSSL_LOCAL DtlsMsg* DtlsMsgInsert(DtlsMsg* head, DtlsMsg* item);

    WOLFSSL_LOCAL int  DtlsMsgPoolSave(WOLFSSL* ssl, const byte* data, word32 dataSz, enum HandShakeType type);
    WOLFSSL_LOCAL int  DtlsMsgPoolTimeout(WOLFSSL* ssl);
    WOLFSSL_LOCAL int  VerifyForDtlsMsgPoolSend(WOLFSSL* ssl, byte type, word32 fragOffset);
    WOLFSSL_LOCAL int  VerifyForTxDtlsMsgDelete(WOLFSSL* ssl, DtlsMsg* item);
    WOLFSSL_LOCAL void DtlsMsgPoolReset(WOLFSSL* ssl);
    WOLFSSL_LOCAL int  DtlsMsgPoolSend(WOLFSSL* ssl, int sendOnlyFirstPacket);
    WOLFSSL_LOCAL void DtlsMsgDestroyFragBucket(DtlsFragBucket* fragBucket, void* heap);
    WOLFSSL_LOCAL int GetDtlsHandShakeHeader(WOLFSSL *ssl, const byte *input, word32 *inOutIdx, byte *type, word32 *size, word32 *fragOffset, word32 *fragSz, word32 totalSz);

    WOLFSSL_LOCAL int DtlsMsgDrain(WOLFSSL *ssl);
    WOLFSSL_LOCAL int SendHelloVerifyRequest(WOLFSSL* ssl, const byte* cookie, byte cookieSz);


    WOLFSSL_LOCAL int DoClientHelloStateless(WOLFSSL* ssl, const byte* input, word32 helloSz, byte isFirstCHFrag, byte* tls13);




    WOLFSSL_LOCAL int DtlsSCRKeysSet(WOLFSSL* ssl);
    WOLFSSL_LOCAL int IsDtlsMsgSCRKeys(WOLFSSL* ssl);
    WOLFSSL_LOCAL int DtlsUseSCRKeys(WOLFSSL* ssl);
    WOLFSSL_LOCAL int DtlsCheckOrder(WOLFSSL* ssl, int order);

    WOLFSSL_LOCAL int IsSCR(WOLFSSL* ssl);
    WOLFSSL_LOCAL int IsDtlsNotSctpMode(WOLFSSL* ssl);
    WOLFSSL_LOCAL int IsDtlsNotSrtpMode(WOLFSSL* ssl);

    WOLFSSL_LOCAL void WriteSEQ(WOLFSSL* ssl, int verifyOrder, byte* out);



    WOLFSSL_LOCAL word32 TimeNowInMilliseconds(void);

    WOLFSSL_LOCAL sword64 TimeNowInMilliseconds(void);



WOLFSSL_LOCAL word32  LowResTimer(void);

WOLFSSL_LOCAL int FindSuiteSSL(const WOLFSSL* ssl, byte* suite);

WOLFSSL_LOCAL void DecodeSigAlg(const byte* input, byte* hashAlgo, byte* hsType);
WOLFSSL_LOCAL enum wc_HashType HashAlgoToType(int hashAlgo);


    WOLFSSL_LOCAL void InitX509Name(WOLFSSL_X509_NAME* name, int dynamicFlag, void* heap);
    WOLFSSL_LOCAL void FreeX509Name(WOLFSSL_X509_NAME* name);
    WOLFSSL_LOCAL void InitX509(WOLFSSL_X509* x509, int dynamicFlag, void* heap);
    WOLFSSL_LOCAL void FreeX509(WOLFSSL_X509* x509);
    WOLFSSL_LOCAL int  CopyDecodedToX509(WOLFSSL_X509* x509, DecodedCert* dCert);







typedef char cipher_name[MAX_CIPHER_NAME];

typedef const char* cipher_name;


typedef struct CipherSuiteInfo {
    cipher_name name;

    cipher_name name_iana;

    byte cipherSuite0;
    byte cipherSuite;

    byte minor;
    byte major;

    byte flags;
} CipherSuiteInfo;

WOLFSSL_LOCAL const CipherSuiteInfo* GetCipherNames(void);
WOLFSSL_LOCAL int GetCipherNamesSize(void);
WOLFSSL_LOCAL const char* GetCipherNameInternal(byte cipherSuite0, byte cipherSuite);




WOLFSSL_LOCAL int wolfSSL_sk_CIPHER_description(WOLFSSL_CIPHER* cipher);
WOLFSSL_LOCAL const char* GetCipherSegment(const WOLFSSL_CIPHER* cipher, char n[][MAX_SEGMENT_SZ]);
WOLFSSL_LOCAL const char* GetCipherProtocol(byte minor);
WOLFSSL_LOCAL const char* GetCipherKeaStr(char n[][MAX_SEGMENT_SZ]);
WOLFSSL_LOCAL const char* GetCipherAuthStr(char n[][MAX_SEGMENT_SZ]);
WOLFSSL_LOCAL const char* GetCipherEncStr(char n[][MAX_SEGMENT_SZ]);
WOLFSSL_LOCAL const char* GetCipherMacStr(char n[][MAX_SEGMENT_SZ]);
WOLFSSL_LOCAL int SetCipherBits(const char* enc);
WOLFSSL_LOCAL int IsCipherAEAD(char n[][MAX_SEGMENT_SZ]);

WOLFSSL_LOCAL const char* GetCipherNameIana(byte cipherSuite0, byte cipherSuite);
WOLFSSL_LOCAL const char* wolfSSL_get_cipher_name_internal(WOLFSSL* ssl);
WOLFSSL_LOCAL const char* wolfSSL_get_cipher_name_iana(WOLFSSL* ssl);
WOLFSSL_LOCAL int GetCipherSuiteFromName(const char* name, byte* cipherSuite0, byte* cipherSuite, int* flags);


enum encrypt_side {
    ENCRYPT_SIDE_ONLY = 1, DECRYPT_SIDE_ONLY, ENCRYPT_AND_DECRYPT_SIDE };



WOLFSSL_LOCAL int SetKeysSide(WOLFSSL* ssl, enum encrypt_side side);


WOLFSSL_LOCAL int SetDsaInternal(WOLFSSL_DSA* dsa);
WOLFSSL_LOCAL int SetDsaExternal(WOLFSSL_DSA* dsa);

WOLFSSL_LOCAL int SetRsaExternal(WOLFSSL_RSA* rsa);
WOLFSSL_LOCAL int SetRsaInternal(WOLFSSL_RSA* rsa);


typedef enum elem_set {
    ELEMENT_P   = 0x01, ELEMENT_Q   = 0x02, ELEMENT_G   = 0x04, ELEMENT_PUB = 0x08, ELEMENT_PRV = 0x10, } Element_Set;




WOLFSSL_LOCAL int SetDhExternal_ex(WOLFSSL_DH *dh, int elm );
WOLFSSL_LOCAL int SetDhInternal(WOLFSSL_DH* dh);
WOLFSSL_LOCAL int SetDhExternal(WOLFSSL_DH *dh);


    WOLFSSL_LOCAL int DhGenKeyPair(WOLFSSL* ssl, DhKey* dhKey, byte* priv, word32* privSz, byte* pub, word32* pubSz);

    WOLFSSL_LOCAL int DhAgree(WOLFSSL* ssl, DhKey* dhKey, const byte* priv, word32 privSz, const byte* otherPub, word32 otherPubSz, byte* agree, word32* agreeSz, const byte* prime, word32 primeSz);






    WOLFSSL_LOCAL int EccMakeKey(WOLFSSL* ssl, ecc_key* key, ecc_key* peer);
    WOLFSSL_LOCAL word16 GetCurveByOID(int oidSum);


WOLFSSL_LOCAL int InitHandshakeHashes(WOLFSSL* ssl);
WOLFSSL_LOCAL void FreeHandshakeHashes(WOLFSSL* ssl);
WOLFSSL_LOCAL int InitHandshakeHashesAndCopy(WOLFSSL* ssl, HS_Hashes* source, HS_Hashes** destination);



WOLFSSL_LOCAL void FreeBuildMsgArgs(WOLFSSL* ssl, BuildMsgArgs* args);

WOLFSSL_LOCAL int BuildMessage(WOLFSSL* ssl, byte* output, int outSz, const byte* input, int inSz, int type, int hashOutput, int sizeOnly, int asyncOkay, int epochOrder);




WOLFSSL_API int BuildTls13Message(WOLFSSL* ssl, byte* output, int outSz, const byte* input, int inSz, int type, int hashOutput, int sizeOnly, int asyncOkay);
WOLFSSL_LOCAL int Tls13UpdateKeys(WOLFSSL* ssl);


WOLFSSL_LOCAL int AllocKey(WOLFSSL* ssl, int type, void** pKey);
WOLFSSL_LOCAL void FreeKey(WOLFSSL* ssl, int type, void** pKey);


    WOLFSSL_LOCAL int wolfSSL_AsyncInit(WOLFSSL* ssl, WC_ASYNC_DEV* asyncDev, word32 flags);
    WOLFSSL_LOCAL int wolfSSL_AsyncPop(WOLFSSL* ssl, byte* state);
    WOLFSSL_LOCAL int wolfSSL_AsyncPush(WOLFSSL* ssl, WC_ASYNC_DEV* asyncDev);




WOLFSSL_LOCAL int LoadCertByIssuer(WOLFSSL_X509_STORE* store, X509_NAME* issuer, int Type);


WOLFSSL_LOCAL WOLFSSL_BY_DIR_HASH* wolfSSL_BY_DIR_HASH_new(void);
WOLFSSL_LOCAL void wolfSSL_BY_DIR_HASH_free(WOLFSSL_BY_DIR_HASH* dir_hash);
WOLFSSL_LOCAL WOLFSSL_STACK* wolfSSL_sk_BY_DIR_HASH_new_null(void);
WOLFSSL_LOCAL int wolfSSL_sk_BY_DIR_HASH_find( WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH)* sk, const WOLFSSL_BY_DIR_HASH* toFind);
WOLFSSL_LOCAL int wolfSSL_sk_BY_DIR_HASH_num(const WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH) *sk);
WOLFSSL_LOCAL WOLFSSL_BY_DIR_HASH* wolfSSL_sk_BY_DIR_HASH_value( const WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH) *sk, int i);
WOLFSSL_LOCAL WOLFSSL_BY_DIR_HASH* wolfSSL_sk_BY_DIR_HASH_pop( WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH)* sk);
WOLFSSL_LOCAL void wolfSSL_sk_BY_DIR_HASH_pop_free(WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH)* sk, void (*f) (WOLFSSL_BY_DIR_HASH*));
WOLFSSL_LOCAL void wolfSSL_sk_BY_DIR_HASH_free(WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH) *sk);
WOLFSSL_LOCAL int wolfSSL_sk_BY_DIR_HASH_push(WOLF_STACK_OF(WOLFSSL_BY_DIR_HASH)* sk, WOLFSSL_BY_DIR_HASH* in);

WOLFSSL_LOCAL WOLFSSL_BY_DIR_entry* wolfSSL_BY_DIR_entry_new(void);
WOLFSSL_LOCAL void wolfSSL_BY_DIR_entry_free(WOLFSSL_BY_DIR_entry* entry);
WOLFSSL_LOCAL WOLFSSL_STACK* wolfSSL_sk_BY_DIR_entry_new_null(void);
WOLFSSL_LOCAL int wolfSSL_sk_BY_DIR_entry_num(const WOLF_STACK_OF(WOLFSSL_BY_DIR_entry) *sk);
WOLFSSL_LOCAL WOLFSSL_BY_DIR_entry* wolfSSL_sk_BY_DIR_entry_value( const WOLF_STACK_OF(WOLFSSL_BY_DIR_entry) *sk, int i);
WOLFSSL_LOCAL WOLFSSL_BY_DIR_entry* wolfSSL_sk_BY_DIR_entry_pop( WOLF_STACK_OF(WOLFSSL_BY_DIR_entry)* sk);
WOLFSSL_LOCAL void wolfSSL_sk_BY_DIR_entry_pop_free(WOLF_STACK_OF(wolfSSL_BY_DIR_entry)* sk, void (*f) (WOLFSSL_BY_DIR_entry*));
WOLFSSL_LOCAL void wolfSSL_sk_BY_DIR_entry_free(WOLF_STACK_OF(wolfSSL_BY_DIR_entry) *sk);
WOLFSSL_LOCAL int wolfSSL_sk_BY_DIR_entry_push(WOLF_STACK_OF(wolfSSL_BY_DIR_entry)* sk, WOLFSSL_BY_DIR_entry* in);


WOLFSSL_LOCAL int oid2nid(word32 oid, int grp);
WOLFSSL_LOCAL word32 nid2oid(int nid, int grp);



WOLFSSL_API int wolfSSL_DtlsUpdateWindow(word16 cur_hi, word32 cur_lo, word16* next_hi, word32* next_lo, word32 *window);
WOLFSSL_LOCAL int DtlsUpdateWindow(WOLFSSL* ssl);
WOLFSSL_LOCAL void DtlsResetState(WOLFSSL *ssl);
WOLFSSL_LOCAL int DtlsIgnoreError(int err);
WOLFSSL_LOCAL void DtlsSetSeqNumForReply(WOLFSSL* ssl);





WOLFSSL_API struct Dtls13Epoch* Dtls13GetEpoch(WOLFSSL* ssl, w64wrapper epochNumber);
WOLFSSL_LOCAL void Dtls13SetOlderEpochSide(WOLFSSL* ssl, w64wrapper epochNumber, int side);
WOLFSSL_LOCAL int Dtls13NewEpoch(WOLFSSL* ssl, w64wrapper epochNumber, int side);
WOLFSSL_LOCAL int Dtls13SetEpochKeys(WOLFSSL* ssl, w64wrapper epochNumber, enum encrypt_side side);
WOLFSSL_LOCAL int Dtls13GetSeq(WOLFSSL* ssl, int order, word32* seq, byte increment);
WOLFSSL_LOCAL int Dtls13DoScheduledWork(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13DeriveSnKeys(WOLFSSL* ssl, int provision);
WOLFSSL_LOCAL int Dtls13SetRecordNumberKeys(WOLFSSL* ssl, enum encrypt_side side);

WOLFSSL_LOCAL int Dtls13AddHeaders(byte* output, word32 length, enum HandShakeType hs_type, WOLFSSL* ssl);
WOLFSSL_LOCAL word16 Dtls13GetHeadersLength(WOLFSSL *ssl, enum HandShakeType type);
WOLFSSL_LOCAL word16 Dtls13GetRlHeaderLength(WOLFSSL *ssl, byte is_encrypted);
WOLFSSL_LOCAL int Dtls13RlAddCiphertextHeader(WOLFSSL* ssl, byte* out, word16 length);
WOLFSSL_LOCAL int Dtls13RlAddPlaintextHeader(WOLFSSL* ssl, byte* out, enum ContentType content_type, word16 length);
WOLFSSL_LOCAL int Dtls13EncryptRecordNumber(WOLFSSL* ssl, byte* hdr, word16 recordLength);
WOLFSSL_LOCAL int Dtls13IsUnifiedHeader(byte header_flags);
WOLFSSL_LOCAL int Dtls13GetUnifiedHeaderSize(WOLFSSL* ssl, const byte input, word16* size);
WOLFSSL_LOCAL int Dtls13ParseUnifiedRecordLayer(WOLFSSL* ssl, const byte* input, word16 input_size, Dtls13UnifiedHdrInfo* hdrInfo);
WOLFSSL_LOCAL int Dtls13HandshakeSend(WOLFSSL* ssl, byte* output, word16 output_size, word16 length, enum HandShakeType handshake_type, int hash_output);

WOLFSSL_LOCAL int Dtls13RecordRecvd(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13HandshakeRecv(WOLFSSL* ssl, byte* input, word32* inOutIdx, word32 totalSz);
WOLFSSL_LOCAL int Dtls13HandshakeAddHeader(WOLFSSL* ssl, byte* output, enum HandShakeType msg_type, word32 length);

WOLFSSL_LOCAL int Dtls13FragmentsContinue(WOLFSSL* ssl);
WOLFSSL_LOCAL int DoDtls13Ack(WOLFSSL* ssl, const byte* input, word32 inputSize, word32* processedSize);
WOLFSSL_LOCAL int Dtls13ReconstructEpochNumber(WOLFSSL* ssl, byte epochBits, w64wrapper* epoch);
WOLFSSL_LOCAL int Dtls13ReconstructSeqNumber(WOLFSSL* ssl, Dtls13UnifiedHdrInfo* hdrInfo, w64wrapper* out);
WOLFSSL_LOCAL int SendDtls13Ack(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13RtxProcessingCertificate(WOLFSSL* ssl, byte* input, word32 inputSize);
WOLFSSL_LOCAL int Dtls13HashHandshake(WOLFSSL* ssl, const byte* input, word16 length);
WOLFSSL_LOCAL int Dtls13HashClientHello(const WOLFSSL* ssl, byte* hash, int* hashSz, const byte* body, word32 length, CipherSpecs* specs);
WOLFSSL_LOCAL void Dtls13FreeFsmResources(WOLFSSL* ssl);
WOLFSSL_LOCAL void Dtls13RtxFlushBuffered(WOLFSSL* ssl, byte keepNewSessionTicket);
WOLFSSL_LOCAL int Dtls13RtxTimeout(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13ProcessBufferedMessages(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13CheckAEADFailLimit(WOLFSSL* ssl);
WOLFSSL_LOCAL int Dtls13UpdateWindowRecordRecvd(WOLFSSL* ssl);



WOLFSSL_LOCAL int wolfSSL_StaticEphemeralKeyLoad(WOLFSSL* ssl, int keyAlgo, void* keyPtr);




WOLFSSL_LOCAL int wolfSSL_ASN1_STRING_canon(WOLFSSL_ASN1_STRING* asn_out, const WOLFSSL_ASN1_STRING* asn_in);


WOLFSSL_LOCAL int GetX509Error(int e);







typedef struct CRYPTO_EX_cb_ctx {
    long ctx_l;
    void *ctx_ptr;
    WOLFSSL_CRYPTO_EX_new* new_func;
    WOLFSSL_CRYPTO_EX_free* free_func;
    WOLFSSL_CRYPTO_EX_dup* dup_func;
    struct CRYPTO_EX_cb_ctx* next;
} CRYPTO_EX_cb_ctx;

WOLFSSL_API extern CRYPTO_EX_cb_ctx* crypto_ex_cb_ctx_session;
WOLFSSL_API void crypto_ex_cb_free(CRYPTO_EX_cb_ctx* cb_ctx);
WOLFSSL_LOCAL void crypto_ex_cb_setup_new_data(void *new_obj, CRYPTO_EX_cb_ctx* cb_ctx, WOLFSSL_CRYPTO_EX_DATA* ex_data);
WOLFSSL_LOCAL void crypto_ex_cb_free_data(void *obj, CRYPTO_EX_cb_ctx* cb_ctx, WOLFSSL_CRYPTO_EX_DATA* ex_data);
WOLFSSL_LOCAL int crypto_ex_cb_dup_data(const WOLFSSL_CRYPTO_EX_DATA *in, WOLFSSL_CRYPTO_EX_DATA *out, CRYPTO_EX_cb_ctx* cb_ctx);
WOLFSSL_LOCAL int wolfssl_get_ex_new_index(int class_index, long ctx_l, void* ctx_ptr, WOLFSSL_CRYPTO_EX_new* new_func, WOLFSSL_CRYPTO_EX_dup* dup_func, WOLFSSL_CRYPTO_EX_free* free_func);



WOLFSSL_LOCAL WC_RNG* wolfssl_get_global_rng(void);
WOLFSSL_LOCAL WC_RNG* wolfssl_make_global_rng(void);



WOLFSSL_LOCAL int EncryptDerKey(byte *der, int *derSz, const EVP_CIPHER* cipher, unsigned char* passwd, int passwdSz, byte **cipherInfo, int maxDerSz);




WOLFSSL_LOCAL int wolfSSL_RSA_To_Der(WOLFSSL_RSA* rsa, byte** outBuf, int publicKey, void* heap);



WOLFSSL_LOCAL int wolfSSL_SSL_do_handshake_internal(WOLFSSL *s);




WOLFSSL_LOCAL int wolfSSL_quic_receive(WOLFSSL* ssl, byte* buf, word32 sz);
WOLFSSL_LOCAL int wolfSSL_quic_send(WOLFSSL* ssl);
WOLFSSL_LOCAL void wolfSSL_quic_clear(WOLFSSL* ssl);
WOLFSSL_LOCAL void wolfSSL_quic_free(WOLFSSL* ssl);
WOLFSSL_LOCAL int wolfSSL_quic_forward_secrets(WOLFSSL *ssl, int ktype, int side);
WOLFSSL_LOCAL int wolfSSL_quic_keys_active(WOLFSSL* ssl, enum encrypt_side side);






WOLFSSL_LOCAL int tls13ShowSecrets(WOLFSSL* ssl, int id, const unsigned char* secret, int secretSz, void* ctx);





    #define WOLFSSL_SSLKEYLOGFILE_OUTPUT "sslkeylog.log"




WOLFSSL_LOCAL int FindPskSuite(const WOLFSSL* ssl, PreSharedKey* psk, byte* psk_key, word32* psk_keySz, const byte* suite, int* found, byte* foundSuite);



WOLFSSL_LOCAL int wolfSSL_GetHmacType_ex(CipherSpecs* specs);


WOLFSSL_LOCAL int CreateCookieExt(const WOLFSSL* ssl, byte* hash, word16 hashSz, TLSX** exts, byte cipherSuite0, byte cipherSuite);



WOLFSSL_LOCAL int TranslateErrorToAlert(int err);


void* wolfssl_sk_pop_type(WOLFSSL_STACK* sk, WOLF_STACK_TYPE type);
WOLFSSL_STACK* wolfssl_sk_new_type(WOLF_STACK_TYPE type);



    }  



