

























static uint32_t get_var_int(const uint8_t **raw_in, uint32_t *len_in, int b)
{
	uint32_t ret = 0;
	int len = *len_in;
	const uint8_t *raw = *raw_in;
	uint8_t shift = 0;

	len--;
	ret = *(raw++) & ((1 << b) - 1);
	if (ret != (uint32_t)((1 << b) - 1))
		goto end;

	while (len && (*raw & 128)) {
		ret += ((uint32_t)(*raw++) & 127) << shift;
		shift += 7;
		len--;
	}

	
	if (!len)
		goto too_short;
	len--;
	ret += ((uint32_t)(*raw++) & 127) << shift;

 end:
	*raw_in = raw;
	*len_in = len;
	return ret;

 too_short:
	*len_in = (uint32_t)-1;
	return 0;
}


static inline int hpack_idx_to_phdr(uint32_t idx)
{
	if (idx > 14)
		return 0;

	idx >>= 1;
	idx <<= 2;
	return (0x55554321U >> idx) & 0xF;
}


static inline struct ist hpack_alloc_string(struct buffer *store, uint32_t idx, struct ist in)
{
	struct ist out;

	if (idx < HPACK_SHT_SIZE)
		return in;

	out.len = in.len;
	out.ptr = chunk_newstr(store);
	if (unlikely(!isttest(out)))
		return out;

	if (unlikely(store->data + out.len > store->size)) {
		out.ptr = NULL;
		return out;
	}

	store->data += out.len;
	memcpy(out.ptr, in.ptr, out.len);
	return out;
}


int hpack_decode_frame(struct hpack_dht *dht, const uint8_t *raw, uint32_t len, struct http_hdr *list, int list_size, struct buffer *tmp)

{
	uint32_t idx;
	uint32_t nlen;
	uint32_t vlen;
	uint8_t huff;
	struct ist name;
	struct ist value;
	int must_index;
	int ret;

	hpack_debug_hexdump(stderr, "[HPACK-DEC] ", (const char *)raw, 0, len);

	chunk_reset(tmp);
	ret = 0;
	while (len) {
		int __maybe_unused code = *raw; 

		must_index = 0;
		if (*raw >= 0x80) {
			
			if (*raw == 0x80) {
				hpack_debug_printf("unhandled code 0x%02x (raw=%p, len=%u)\n", *raw, raw, len);
				ret = -HPACK_ERR_UNKNOWN_OPCODE;
				goto leave;
			}

			hpack_debug_printf("%02x: p14: indexed header field : ", code);

			idx = get_var_int(&raw, &len, 7);
			if (len == (uint32_t)-1) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			hpack_debug_printf(" idx=%u ", idx);

			if (!hpack_valid_idx(dht, idx)) {
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TOO_LARGE;
				goto leave;
			}

			value = hpack_alloc_string(tmp, idx, hpack_idx_to_value(dht, idx));
			if (!isttest(value)) {
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TOO_LARGE;
				goto leave;
			}

			
			name = ist2(NULL, hpack_idx_to_phdr(idx));

			if (!name.len) {
				name = hpack_alloc_string(tmp, idx, hpack_idx_to_name(dht, idx));
				if (!isttest(name)) {
					hpack_debug_printf("##ERR@%d##\n", __LINE__);
					ret = -HPACK_ERR_TOO_LARGE;
					goto leave;
				}
			}
			
		}
		else if (*raw >= 0x20 && *raw <= 0x3f) {
			
			hpack_debug_printf("%02x: p18: dynamic table size update : ", code);

			if (ret) {
				
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TOO_LARGE;
				goto leave;
			}

			idx = get_var_int(&raw, &len, 5);
			if (len == (uint32_t)-1) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}
			hpack_debug_printf(" new len=%u\n", idx);

			if (idx > dht->size) {
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_INVALID_ARGUMENT;
				goto leave;
			}
			continue;
		}
		else if (!(*raw & (*raw - 0x10))) {
			

			
			if (*raw == 0x00)
				hpack_debug_printf("%02x: p17: literal without indexing : ", code);
			else if (*raw == 0x10)
				hpack_debug_printf("%02x: p18: literal never indexed : ", code);
			else if (*raw == 0x40)
				hpack_debug_printf("%02x: p16: literal with indexing : ", code);

			if (*raw == 0x40)
				must_index = 1;

			raw++; len--;

			
			if (!len) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			huff = *raw & 0x80;
			nlen = get_var_int(&raw, &len, 7);
			if (len == (uint32_t)-1 || len < nlen) { 
				hpack_debug_printf("##ERR@%d## (truncated): nlen=%d len=%d\n", __LINE__, (int)nlen, (int)len);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			name = ist2(raw, nlen);

			raw += nlen;
			len -= nlen;

			if (huff) {
				char *ntrash = chunk_newstr(tmp);
				if (!ntrash) {
					hpack_debug_printf("##ERR@%d##\n", __LINE__);
					ret = -HPACK_ERR_TOO_LARGE;
					goto leave;
				}

				nlen = huff_dec((const uint8_t *)name.ptr, name.len, ntrash, tmp->size - tmp->data);
				if (nlen == (uint32_t)-1) {
					hpack_debug_printf("2: can't decode huffman.\n");
					ret = -HPACK_ERR_HUFFMAN;
					goto leave;
				}
				hpack_debug_printf(" [name huff %d->%d] ", (int)name.len, (int)nlen);

				tmp->data += nlen; 
				name = ist2(ntrash, nlen);
			}

			
			if (!len) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			huff = *raw & 0x80;
			vlen = get_var_int(&raw, &len, 7);
			if (len == (uint32_t)-1 || len < vlen) { 
				hpack_debug_printf("##ERR@%d## : vlen=%d len=%d\n", __LINE__, (int)vlen, (int)len);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			value = ist2(raw, vlen);
			raw += vlen;
			len -= vlen;

			if (huff) {
				char *vtrash = chunk_newstr(tmp);
				if (!vtrash) {
					hpack_debug_printf("##ERR@%d##\n", __LINE__);
					ret = -HPACK_ERR_TOO_LARGE;
					goto leave;
				}

				vlen = huff_dec((const uint8_t *)value.ptr, value.len, vtrash, tmp->size - tmp->data);
				if (vlen == (uint32_t)-1) {
					hpack_debug_printf("3: can't decode huffman.\n");
					ret = -HPACK_ERR_HUFFMAN;
					goto leave;
				}
				hpack_debug_printf(" [value huff %d->%d] ", (int)value.len, (int)vlen);

				tmp->data += vlen; 
				value = ist2(vtrash, vlen);
			}

			
		}
		else {
			
			
			

			if (*raw <= 0x0f)
				hpack_debug_printf("%02x: p16: literal without indexing -- indexed name : ", code);
			else if (*raw >= 0x41)
				hpack_debug_printf("%02x: p15: literal with indexing -- indexed name : ", code);
			else hpack_debug_printf("%02x: p16: literal never indexed -- indexed name : ", code);

			
			if (*raw >= 0x41) {
				must_index = 1;
				idx = get_var_int(&raw, &len, 6);
			}
			else idx = get_var_int(&raw, &len, 4);

			hpack_debug_printf(" idx=%u ", idx);

			if (len == (uint32_t)-1 || !len) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			if (!hpack_valid_idx(dht, idx)) {
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TOO_LARGE;
				goto leave;
			}

			
			huff = *raw & 0x80;
			vlen = get_var_int(&raw, &len, 7);
			if (len == (uint32_t)-1 || len < vlen) { 
				hpack_debug_printf("##ERR@%d##\n", __LINE__);
				ret = -HPACK_ERR_TRUNCATED;
				goto leave;
			}

			value = ist2(raw, vlen);
			raw += vlen;
			len -= vlen;

			if (huff) {
				char *vtrash = chunk_newstr(tmp);
				if (!vtrash) {
					hpack_debug_printf("##ERR@%d##\n", __LINE__);
					ret = -HPACK_ERR_TOO_LARGE;
					goto leave;
				}

				vlen = huff_dec((const uint8_t *)value.ptr, value.len, vtrash, tmp->size - tmp->data);
				if (vlen == (uint32_t)-1) {
					hpack_debug_printf("##ERR@%d## can't decode huffman : ilen=%d osize=%d\n", __LINE__, (int)value.len, (int)(tmp->size - tmp->data));

					hpack_debug_hexdump(stderr, "[HUFFMAN] ", value.ptr, 0, value.len);
					ret = -HPACK_ERR_HUFFMAN;
					goto leave;
				}
				tmp->data += vlen; 
				value = ist2(vtrash, vlen);
			}

			name = IST_NULL;
			if (!must_index)
				name.len = hpack_idx_to_phdr(idx);

			if (!name.len) {
				name = hpack_alloc_string(tmp, idx, hpack_idx_to_name(dht, idx));
				if (!isttest(name)) {
					hpack_debug_printf("##ERR@%d##\n", __LINE__);
					ret = -HPACK_ERR_TOO_LARGE;
					goto leave;
				}
			}
			
		}

		
		if (ret >= list_size) {
			hpack_debug_printf("##ERR@%d##\n", __LINE__);
			ret = -HPACK_ERR_TOO_LARGE;
			goto leave;
		}

		list[ret].n = name;
		list[ret].v = value;
		ret++;

		if (must_index && hpack_dht_insert(dht, name, value) < 0) {
			hpack_debug_printf("failed to find some room in the dynamic table\n");
			ret = -HPACK_ERR_DHT_INSERT_FAIL;
			goto leave;
		}

		hpack_debug_printf("\e[1;34m%s\e[0m: ", isttest(name) ? istpad(trash.area, name).ptr : h2_phdr_to_str(name.len));

		hpack_debug_printf("\e[1;35m%s\e[0m [mustidx=%d, used=%d] [n=(%p,%d) v=(%p,%d)]\n", istpad(trash.area, value).ptr, must_index, dht->used, name.ptr, (int)name.len, value.ptr, (int)value.len);


	}

	if (ret >= list_size) {
		ret = -HPACK_ERR_TOO_LARGE;
		goto leave;
	}

	
	list[ret].n = list[ret].v = IST_NULL;
	ret++;

 leave:
	hpack_debug_printf("-- done: ret=%d list_size=%d --\n", (int)ret, (int)list_size);
	return ret;
}
