




























namespace arangodb {

class AuthenticationFeature final : public application_features::ApplicationFeature {
 private:
  const size_t _maxSecretLength = 64;

 public:
  explicit AuthenticationFeature(application_features::ApplicationServer& server);

  static inline AuthenticationFeature* instance() { return INSTANCE; }

  void collectOptions(std::shared_ptr<options::ProgramOptions>) override final;
  void validateOptions(std::shared_ptr<options::ProgramOptions>) override final;
  void prepare() override final;
  void start() override final;
  void unprepare() override final;

  bool isActive() const { return _active && isEnabled(); }

  bool authenticationUnixSockets() const { return _authenticationUnixSockets; }
  bool authenticationSystemOnly() const { return _authenticationSystemOnly; }


  
  bool localAuthentication() const noexcept { return _localAuthentication; }

  
  inline auth::TokenCache& tokenCache() const noexcept {
    TRI_ASSERT(_authCache);
    return *_authCache.get();
  }

  
  
  inline auth::UserManager* userManager() const noexcept {
    return _userManager.get();
  }

  bool hasUserdefinedJwt() const;
  
  std::string jwtActiveSecret() const;

  
  std::pair<std::string, std::vector<std::string>> jwtSecrets() const;

  
  
  [[nodiscard]] Result loadJwtSecretsFromFile();

 private:
  
  [[nodiscard]] Result loadJwtSecretKeyfile();

  
  [[nodiscard]] Result loadJwtSecretFolder();

 private:
  std::unique_ptr<auth::UserManager> _userManager;
  std::unique_ptr<auth::TokenCache> _authCache;
  bool _authenticationUnixSockets;
  bool _authenticationSystemOnly;
  bool _localAuthentication;
  bool _active;
  double _authenticationTimeout;
  
  mutable std::mutex _jwtSecretsLock;

  std::string _jwtSecretProgramOption;
  std::string _jwtSecretKeyfileProgramOption;
  std::string _jwtSecretFolderProgramOption;


  
  std::vector<std::string> _jwtPassiveSecrets;


  static AuthenticationFeature* INSTANCE;
};

}  

