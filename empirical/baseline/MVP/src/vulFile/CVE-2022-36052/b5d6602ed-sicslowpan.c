


























































































static uint8_t *packetbuf_ptr;


static uint8_t packetbuf_hdr_len;


static int packetbuf_payload_len;


static uint8_t uncomp_hdr_len;


static int mac_max_payload;


static uint8_t curr_page;


static int last_tx_status;


static int last_rssi;






static uint16_t my_tag;



































struct sicslowpan_frag_info {
  
  linkaddr_t sender;
  
  linkaddr_t receiver;
  
  uint16_t tag;
  
  uint16_t len;
  
  uint16_t reassembled_len;
  
  struct timer reass_timer;

  
  uint16_t first_frag_len;
  
  uint8_t first_frag[SICSLOWPAN_FIRST_FRAGMENT_SIZE];
};

static struct sicslowpan_frag_info frag_info[SICSLOWPAN_REASS_CONTEXTS];

struct sicslowpan_frag_buf {
  
  uint8_t index;
  
  uint8_t offset;
  
  uint8_t len;
  uint8_t data[SICSLOWPAN_FRAGMENT_SIZE];
};

static struct sicslowpan_frag_buf frag_buf[SICSLOWPAN_FRAGMENT_BUFFERS];


static int clear_fragments(uint8_t frag_info_index)
{
  int i, clear_count;
  clear_count = 0;
  frag_info[frag_info_index].len = 0;
  for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS; i++) {
    if(frag_buf[i].len > 0 && frag_buf[i].index == frag_info_index) {
      
      frag_buf[i].len = 0;
      clear_count++;
    }
  }
  return clear_count;
}

static int timeout_fragments(int not_context)
{
  int i;
  int count = 0;
  for(i = 0; i < SICSLOWPAN_REASS_CONTEXTS; i++) {
    if(frag_info[i].len > 0 && i != not_context && timer_expired(&frag_info[i].reass_timer)) {
      
      count += clear_fragments(i);
    }
  }
  return count;
}

static int store_fragment(uint8_t index, uint8_t offset)
{
  int i;
  int len;

  len = packetbuf_datalen() - packetbuf_hdr_len;

  if(len <= 0 || len > SICSLOWPAN_FRAGMENT_SIZE) {
    
    return -1;
  }

  for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS; i++) {
    if(frag_buf[i].len == 0) {
      
      frag_buf[i].offset = offset; 
      frag_buf[i].len = len;
      frag_buf[i].index = index;
      memcpy(frag_buf[i].data, packetbuf_ptr + packetbuf_hdr_len, len);
      
      return len;
    }
  }
  
  return -1;
}


static int8_t add_fragment(uint16_t tag, uint16_t frag_size, uint8_t offset)
{
  int i;
  int len;
  int8_t found = -1;

  if(offset == 0) {
    
    for(i = 0; i < SICSLOWPAN_REASS_CONTEXTS; i++) {
      
      if(frag_info[i].len > 0 && timer_expired(&frag_info[i].reass_timer)) {
        clear_fragments(i);
      }

      
      if(found < 0 && frag_info[i].len == 0) {
        
        found = i;
      }
    }

    if(found < 0) {
      LOG_WARN("reassembly: failed to store new fragment session - tag: %d\n", tag);
      return -1;
    }

    
    frag_info[found].len = frag_size;
    frag_info[found].tag = tag;
    linkaddr_copy(&frag_info[found].sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
    timer_set(&frag_info[found].reass_timer, SICSLOWPAN_REASS_MAXAGE * CLOCK_SECOND / 16);
    
    return found;
  }

  
  for(i = 0; i < SICSLOWPAN_REASS_CONTEXTS; i++) {
    if(frag_info[i].tag == tag && frag_info[i].len > 0 && linkaddr_cmp(&frag_info[i].sender, packetbuf_addr(PACKETBUF_ADDR_SENDER))) {
      
      found = i;
      break;
    }
  }

  if(found < 0) {
    
    LOG_WARN("reassembly: failed to store N-fragment - could not find session - tag: %d offset: %d\n", tag, offset);
    return -1;
  }

  
  len = store_fragment(i, offset);
  if(len < 0 && timeout_fragments(i) > 0) {
    len = store_fragment(i, offset);
  }
  if(len > 0) {
    frag_info[i].reassembled_len += len;
    return i;
  } else {
    
    LOG_WARN("reassembly: failed to store fragment - packet reassembly will fail tag:%d l\n", frag_info[i].tag);
    return -1;
  }
}


static bool copy_frags2uip(int context)
{
  int i;

  
  if(frag_info[context].len < frag_info[context].first_frag_len || frag_info[context].len > sizeof(uip_buf)) {
    LOG_WARN("input: invalid total size of fragments\n");
    clear_fragments(context);
    return false;
  }

  
  memcpy((uint8_t *)UIP_IP_BUF, (uint8_t *)frag_info[context].first_frag, frag_info[context].first_frag_len);

  
  memset((uint8_t *)UIP_IP_BUF + frag_info[context].first_frag_len, 0, frag_info[context].len - frag_info[context].first_frag_len);

  for(i = 0; i < SICSLOWPAN_FRAGMENT_BUFFERS; i++) {
    
    if(frag_buf[i].len > 0 && frag_buf[i].index == context) {
      if((frag_buf[i].offset << 3) + frag_buf[i].len > sizeof(uip_buf)) {
        LOG_WARN("input: invalid fragment offset\n");
        clear_fragments(context);
        return false;
      }
      memcpy((uint8_t *)UIP_IP_BUF + (uint16_t)(frag_buf[i].offset << 3), (uint8_t *)frag_buf[i].data, frag_buf[i].len);
    }
  }
  
  clear_fragments(context);

  return true;
}







static struct netstack_sniffer *callback = NULL;

void netstack_sniffer_add(struct netstack_sniffer *s)
{
  callback = s;
}

void netstack_sniffer_remove(struct netstack_sniffer *s)
{
  callback = NULL;
}

static void set_packet_attrs(void)
{
  int c = 0;
  
  packetbuf_set_attr(PACKETBUF_ATTR_NETWORK_ID, UIP_IP_BUF->proto);

  
  if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
    c = UIP_UDP_BUF_POS(0)->srcport;
    if(UIP_UDP_BUF_POS(0)->destport < c) {
      c = UIP_UDP_BUF_POS(0)->destport;
    }
  } else if(UIP_IP_BUF->proto == UIP_PROTO_TCP) {
    c = UIP_TCP_BUF->srcport;
    if(UIP_TCP_BUF->destport < c) {
      c = UIP_TCP_BUF->destport;
    }
  } else if(UIP_IP_BUF->proto == UIP_PROTO_ICMP6) {
    c = UIP_ICMP_BUF->type << 8 | UIP_ICMP_BUF->icode;
  }

  packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c);





}








static struct sicslowpan_addr_context addr_contexts[SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS];



static struct sicslowpan_addr_context *context;


static uint8_t *hc06_ptr;








const uint8_t unc_llconf[] = {0x0f,0x28,0x22,0x20};






const uint8_t unc_ctxconf[] = {0x00,0x88,0x82,0x80};






const uint8_t unc_mxconf[] = {0x0f, 0x25, 0x23, 0x21};


const uint8_t llprefix[] = {0xfe, 0x80};


static const uint8_t ttl_values[] = {0, 1, 64, 255};





static struct sicslowpan_addr_context* addr_context_lookup_by_prefix(uip_ipaddr_t *ipaddr)
{


  int i;
  for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
    if((addr_contexts[i].used == 1) && uip_ipaddr_prefixcmp(&addr_contexts[i].prefix, ipaddr, 64)) {
      return &addr_contexts[i];
    }
  }

  return NULL;
}


static struct sicslowpan_addr_context* addr_context_lookup_by_number(uint8_t number)
{


  int i;
  for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
    if((addr_contexts[i].used == 1) && addr_contexts[i].number == number) {
      return &addr_contexts[i];
    }
  }

  return NULL;
}

static uint8_t compress_addr_64(uint8_t bitpos, uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr)
{
  if(uip_is_addr_mac_addr_based(ipaddr, lladdr)) {
    return 3 << bitpos; 
  } else if(sicslowpan_is_iid_16_bit_compressable(ipaddr)) {
    
    memcpy(hc06_ptr, &ipaddr->u16[7], 2);
    hc06_ptr += 2;
    return 2 << bitpos; 
  } else {
    
    memcpy(hc06_ptr, &ipaddr->u16[4], 8);
    hc06_ptr += 8;
    return 1 << bitpos; 
  }
}



static void uncompress_addr(uip_ipaddr_t *ipaddr, uint8_t const prefix[], uint8_t pref_post_count, uip_lladdr_t *lladdr)

{
  uint8_t prefcount = pref_post_count >> 4;
  uint8_t postcount = pref_post_count & 0x0f;
  
  prefcount = prefcount == 15 ? 16 : prefcount;
  postcount = postcount == 15 ? 16 : postcount;

  LOG_DBG("uncompression: address %d %d ", prefcount, postcount);

  if(prefcount > 0) {
    memcpy(ipaddr, prefix, prefcount);
  }
  if(prefcount + postcount < 16) {
    memset(&ipaddr->u8[prefcount], 0, 16 - (prefcount + postcount));
  }
  if(postcount > 0) {
    memcpy(&ipaddr->u8[16 - postcount], hc06_ptr, postcount);
    if(postcount == 2 && prefcount < 11) {
      
      ipaddr->u8[11] = 0xff;
      ipaddr->u8[12] = 0xfe;
    }
    hc06_ptr += postcount;
  } else if (prefcount > 0) {
    
    uip_ds6_set_addr_iid(ipaddr, lladdr);
  }

  LOG_DBG_6ADDR(ipaddr);
  LOG_DBG_("\n");
}



static int compress_hdr_iphc(linkaddr_t *link_destaddr)
{
  uint8_t tmp, iphc0, iphc1, *next_hdr, *next_nhc;
  int ext_hdr_len;
  struct uip_udp_hdr *udp_buf;

  if(LOG_DBG_ENABLED) {
    uint16_t ndx;
    LOG_DBG("compression: before (%d): ", UIP_IP_BUF->len[1]);
    for(ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {
      uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];
      LOG_DBG_("%02x", data);
    }
    LOG_DBG_("\n");
  }









  hc06_ptr = PACKETBUF_IPHC_BUF + 2;

  
  CHECK_BUFFER_SPACE(38);

  

  iphc0 = SICSLOWPAN_DISPATCH_IPHC;
  iphc1 = 0;
  PACKETBUF_IPHC_BUF[2] = 0; 

  


  
  
  if(addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr) != NULL || addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr) != NULL) {
    
    LOG_DBG("compression: dest or src ipaddr - setting CID\n");
    iphc1 |= SICSLOWPAN_IPHC_CID;
    hc06_ptr++;
  }

  

  

  tmp = (UIP_IP_BUF->vtc << 4) | (UIP_IP_BUF->tcflow >> 4);
  tmp = ((tmp & 0x03) << 6) | (tmp >> 2);

  if(((UIP_IP_BUF->tcflow & 0x0F) == 0) && (UIP_IP_BUF->flow == 0)) {
    
    iphc0 |= SICSLOWPAN_IPHC_FL_C;
    if(((UIP_IP_BUF->vtc & 0x0F) == 0) && ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
      
      iphc0 |= SICSLOWPAN_IPHC_TC_C;
    } else {
      
     *hc06_ptr = tmp;
      hc06_ptr += 1;
    }
  } else {
    
    if(((UIP_IP_BUF->vtc & 0x0F) == 0) && ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
      
      iphc0 |= SICSLOWPAN_IPHC_TC_C;
      *hc06_ptr = (tmp & 0xc0) | (UIP_IP_BUF->tcflow & 0x0F);
      memcpy(hc06_ptr + 1, &UIP_IP_BUF->flow, 2);
      hc06_ptr += 3;
    } else {
      
      memcpy(hc06_ptr, &UIP_IP_BUF->vtc, 4);
      
      *hc06_ptr = tmp;
      hc06_ptr += 4;
   }
  }

  

  
  if(IS_COMPRESSABLE_PROTO(UIP_IP_BUF->proto)) {
    iphc0 |= SICSLOWPAN_IPHC_NH_C;
  }

  
  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
    *hc06_ptr = UIP_IP_BUF->proto;
    hc06_ptr += 1;
  }

  
  switch(UIP_IP_BUF->ttl) {
    case 1:
      iphc0 |= SICSLOWPAN_IPHC_TTL_1;
      break;
    case 64:
      iphc0 |= SICSLOWPAN_IPHC_TTL_64;
      break;
    case 255:
      iphc0 |= SICSLOWPAN_IPHC_TTL_255;
      break;
    default:
      *hc06_ptr = UIP_IP_BUF->ttl;
      hc06_ptr += 1;
      break;
  }

  
  if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
    LOG_DBG("compression: addr unspecified - setting SAC\n");
    iphc1 |= SICSLOWPAN_IPHC_SAC;
    iphc1 |= SICSLOWPAN_IPHC_SAM_00;
  } else if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr))
     != NULL) {
    
    LOG_DBG("compression: src with context - setting CID & SAC ctx: %d\n", context->number);
    iphc1 |= SICSLOWPAN_IPHC_CID | SICSLOWPAN_IPHC_SAC;
    PACKETBUF_IPHC_BUF[2] |= context->number << 4;
    

    iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT, &UIP_IP_BUF->srcipaddr, &uip_lladdr);
    
  } else if(uip_is_addr_linklocal(&UIP_IP_BUF->srcipaddr) && UIP_IP_BUF->destipaddr.u16[1] == 0 && UIP_IP_BUF->destipaddr.u16[2] == 0 && UIP_IP_BUF->destipaddr.u16[3] == 0) {


    iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT, &UIP_IP_BUF->srcipaddr, &uip_lladdr);
  } else {
    
    iphc1 |= SICSLOWPAN_IPHC_SAM_00; 
    memcpy(hc06_ptr, &UIP_IP_BUF->srcipaddr.u16[0], 16);
    hc06_ptr += 16;
  }

  
  if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    
    iphc1 |= SICSLOWPAN_IPHC_M;
    if(sicslowpan_is_mcast_addr_compressable8(&UIP_IP_BUF->destipaddr)) {
      iphc1 |= SICSLOWPAN_IPHC_DAM_11;
      
      *hc06_ptr = UIP_IP_BUF->destipaddr.u8[15];
      hc06_ptr += 1;
    } else if(sicslowpan_is_mcast_addr_compressable32(&UIP_IP_BUF->destipaddr)) {
      iphc1 |= SICSLOWPAN_IPHC_DAM_10;
      
      *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
      memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[13], 3);
      hc06_ptr += 4;
    } else if(sicslowpan_is_mcast_addr_compressable48(&UIP_IP_BUF->destipaddr)) {
      iphc1 |= SICSLOWPAN_IPHC_DAM_01;
      
      *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
      memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[11], 5);
      hc06_ptr += 6;
    } else {
      iphc1 |= SICSLOWPAN_IPHC_DAM_00;
      
      memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u8[0], 16);
      hc06_ptr += 16;
    }
  } else {
    
    if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr)) != NULL) {
      
      iphc1 |= SICSLOWPAN_IPHC_DAC;
      PACKETBUF_IPHC_BUF[2] |= context->number;
      

      iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT, &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)link_destaddr);

      
    } else if(uip_is_addr_linklocal(&UIP_IP_BUF->destipaddr) && UIP_IP_BUF->destipaddr.u16[1] == 0 && UIP_IP_BUF->destipaddr.u16[2] == 0 && UIP_IP_BUF->destipaddr.u16[3] == 0) {


      iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT, &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)link_destaddr);
    } else {
      
      iphc1 |= SICSLOWPAN_IPHC_DAM_00; 
      memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u16[0], 16);
      hc06_ptr += 16;
    }
  }

  uncomp_hdr_len = UIP_IPH_LEN;

  
  
  next_hdr = &UIP_IP_BUF->proto;
  next_nhc = hc06_ptr; 
  ext_hdr_len = 0;
  
  LOG_DBG("compression: first header: %d\n", *next_hdr);
  while(next_hdr != NULL && IS_COMPRESSABLE_PROTO(*next_hdr)) {
    LOG_DBG("compression: next header: %d\n", *next_hdr);
    int proto = -1; 
    
    switch(*next_hdr) {
    case UIP_PROTO_HBHO:
      proto = SICSLOWPAN_NHC_ETX_HDR_HBHO;
    case UIP_PROTO_ROUTING:
      proto = proto == -1 ? SICSLOWPAN_NHC_ETX_HDR_ROUTING : proto;
    case UIP_PROTO_FRAG:
      proto = proto == -1 ? SICSLOWPAN_NHC_ETX_HDR_FRAG : proto;
    case UIP_PROTO_DESTO:
      
      {
        struct uip_ext_hdr *ext_hdr = (struct uip_ext_hdr *) UIP_IPPAYLOAD_BUF_POS(ext_hdr_len);
        int len;
        proto = proto == -1 ? SICSLOWPAN_NHC_ETX_HDR_DESTO : proto;
        
        len = (ext_hdr->len << 3) + 8;
        LOG_DBG("compression: next header %d (len:%d)\n", *next_hdr, len);
        
        next_hdr = &ext_hdr->next;
        
        if(!IS_COMPRESSABLE_PROTO(*next_hdr)) {
          CHECK_BUFFER_SPACE(1);
          hc06_ptr++;
          LOG_DBG("compression: keeping the next header in this ext hdr: %d\n", ext_hdr->next);
        }
        
        CHECK_BUFFER_SPACE(len);
        memcpy(hc06_ptr, ext_hdr, len);
        
        ext_hdr = (struct uip_ext_hdr *) hc06_ptr;
        ext_hdr->len = len - 2; 
        ext_hdr_len += len;
        hc06_ptr += len;
        uncomp_hdr_len += len;

        
        *next_nhc = SICSLOWPAN_NHC_EXT_HDR | (IS_COMPRESSABLE_PROTO(*next_hdr) ? SICSLOWPAN_NHC_BIT : 0) | (proto << 1);

        
        next_nhc = hc06_ptr;
      }
      break;
    case UIP_PROTO_UDP:
      
      hc06_ptr++;
      udp_buf = UIP_UDP_BUF_POS(ext_hdr_len);
      LOG_DBG("compression: inlined UDP ports on send side: %x, %x\n", UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));
      
      if(((UIP_HTONS(udp_buf->srcport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN) && ((UIP_HTONS(udp_buf->destport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN)) {
        
        *next_nhc = SICSLOWPAN_NHC_UDP_CS_P_11;
        LOG_DBG("IPHC: remove 12 b of both source & dest with prefix 0xFOB\n");
        CHECK_BUFFER_SPACE(1);
        *hc06_ptr = (uint8_t)((UIP_HTONS(udp_buf->srcport) - SICSLOWPAN_UDP_4_BIT_PORT_MIN) << 4) + (uint8_t)((UIP_HTONS(udp_buf->destport) - SICSLOWPAN_UDP_4_BIT_PORT_MIN));



        hc06_ptr += 1;
      } else if((UIP_HTONS(udp_buf->destport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
        
        *next_nhc = SICSLOWPAN_NHC_UDP_CS_P_01;
        LOG_DBG("IPHC: leave source, remove 8 bits of dest with prefix 0xF0\n");
        CHECK_BUFFER_SPACE(3);
        memcpy(hc06_ptr, &udp_buf->srcport, 2);
        *(hc06_ptr + 2) = (uint8_t)((UIP_HTONS(udp_buf->destport) - SICSLOWPAN_UDP_8_BIT_PORT_MIN));

        hc06_ptr += 3;
      } else if((UIP_HTONS(udp_buf->srcport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
        
        *next_nhc = SICSLOWPAN_NHC_UDP_CS_P_10;
        LOG_DBG("IPHC: remove 8 bits of source with prefix 0xF0, leave dest. hch: %i\n", *next_nhc);
        CHECK_BUFFER_SPACE(3);
        *hc06_ptr = (uint8_t)((UIP_HTONS(udp_buf->srcport) - SICSLOWPAN_UDP_8_BIT_PORT_MIN));

        memcpy(hc06_ptr + 1, &udp_buf->destport, 2);
        hc06_ptr += 3;
      } else {
        
        *next_nhc = SICSLOWPAN_NHC_UDP_CS_P_00;
        LOG_DBG("IPHC: cannot compress UDP headers\n");
        CHECK_BUFFER_SPACE(4);
        memcpy(hc06_ptr, &udp_buf->srcport, 4);
        hc06_ptr += 4;
      }
      
      CHECK_BUFFER_SPACE(2);
      memcpy(hc06_ptr, &udp_buf->udpchksum, 2);
      hc06_ptr += 2;
      uncomp_hdr_len += UIP_UDPH_LEN;
      
      next_hdr = NULL;
      break;
    default:
      LOG_ERR("compression: could not handle compression of header");
    }
  }
  if(next_hdr != NULL) {
    
    
    LOG_DBG("compression: last header could is not compressed: %d\n", *next_hdr);
  }
  
  PACKETBUF_IPHC_BUF[0] = iphc0;
  PACKETBUF_IPHC_BUF[1] = iphc1;

  if(LOG_DBG_ENABLED) {
    uint16_t ndx;
    LOG_DBG("compression: after (%d): ", (int)(hc06_ptr - packetbuf_ptr));
    for(ndx = 0; ndx < hc06_ptr - packetbuf_ptr; ndx++) {
      uint8_t data = ((uint8_t *) packetbuf_ptr)[ndx];
      LOG_DBG_("%02x", data);
    }
    LOG_DBG_("\n");
  }

  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;

  return 1;
}



static bool uncompress_hdr_iphc(uint8_t *buf, uint16_t buf_size, uint16_t ip_len)
{
  uint8_t tmp, iphc0, iphc1, nhc;
  struct uip_ext_hdr *exthdr;
  uint8_t* last_nextheader;
  uint8_t* ip_payload;
  uint8_t ext_hdr_len = 0;
  uint16_t cmpr_len;








  
  cmpr_len = packetbuf_datalen();
  if(cmpr_len < packetbuf_hdr_len + 2) {
    return false;
  }
  hc06_ptr = packetbuf_ptr + packetbuf_hdr_len + 2;

  iphc0 = PACKETBUF_IPHC_BUF[0];
  iphc1 = PACKETBUF_IPHC_BUF[1];

  
  if(iphc1 & SICSLOWPAN_IPHC_CID) {
    LOG_DBG("uncompression: CID flag set - increase header with one\n");
    hc06_ptr++;
  }

  
    if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {
      
      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
        
        CHECK_READ_SPACE(4);
        memcpy(&SICSLOWPAN_IP_BUF(buf)->tcflow, hc06_ptr + 1, 3);
        tmp = *hc06_ptr;
        hc06_ptr += 4;
        
        
        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((tmp >> 2) & 0x0f);
        
        SICSLOWPAN_IP_BUF(buf)->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) | (SICSLOWPAN_IP_BUF(buf)->tcflow & 0x0f);
      } else {
        
        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;
        
        CHECK_READ_SPACE(3);
        SICSLOWPAN_IP_BUF(buf)->tcflow = (*hc06_ptr & 0x0F) |  ((*hc06_ptr >> 2) & 0x30);
        memcpy(&SICSLOWPAN_IP_BUF(buf)->flow, hc06_ptr + 1, 2);
        hc06_ptr += 3;
      }
    } else {
      
      
      if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
        
        CHECK_READ_SPACE(1);
        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);
        SICSLOWPAN_IP_BUF(buf)->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);
        SICSLOWPAN_IP_BUF(buf)->flow = 0;
        hc06_ptr += 1;
      } else {
        
        SICSLOWPAN_IP_BUF(buf)->vtc = 0x60;
        SICSLOWPAN_IP_BUF(buf)->tcflow = 0;
        SICSLOWPAN_IP_BUF(buf)->flow = 0;
      }
    }

  
  if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
    
    CHECK_READ_SPACE(1);
    SICSLOWPAN_IP_BUF(buf)->proto = *hc06_ptr;
    LOG_DBG("uncompression: next header inline: %d\n", SICSLOWPAN_IP_BUF(buf)->proto);
    hc06_ptr += 1;
  }

  
  if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {
    SICSLOWPAN_IP_BUF(buf)->ttl = ttl_values[iphc0 & 0x03];
  } else {
    CHECK_READ_SPACE(1);
    SICSLOWPAN_IP_BUF(buf)->ttl = *hc06_ptr;
    hc06_ptr += 1;
  }

  
  tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;

  
  if(iphc1 & SICSLOWPAN_IPHC_SAC) {
    uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] >> 4 : 0;

    
    if (tmp != 0) {
      context = addr_context_lookup_by_number(sci);
      if(context == NULL) {
        LOG_ERR("uncompression: error context not found\n");
        return false;
      }
    }
    
    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp], (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));

  } else {
    
    uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->srcipaddr, llprefix, unc_llconf[tmp], (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
  }

  
  
  tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;

  
  if(iphc1 & SICSLOWPAN_IPHC_M) {
    
    if(iphc1 & SICSLOWPAN_IPHC_DAC) {
      
    } else {
      
      
      
      
      
      uint8_t prefix[] = {0xff, 0x02};
      if(tmp > 0 && tmp < 3) {
        CHECK_READ_SPACE(1);
        prefix[1] = *hc06_ptr;
        hc06_ptr++;
      }

      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, prefix, unc_mxconf[tmp], NULL);
    }
  } else {
    
    
    if(iphc1 & SICSLOWPAN_IPHC_DAC) {
      uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ? PACKETBUF_IPHC_BUF[2] & 0x0f : 0;
      context = addr_context_lookup_by_number(dci);

      
      if(context == NULL) {
        LOG_ERR("uncompression: error context not found\n");
        return false;
      }
      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, context->prefix, unc_ctxconf[tmp], (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));

    } else {
      
      uncompress_addr(&SICSLOWPAN_IP_BUF(buf)->destipaddr, llprefix, unc_llconf[tmp], (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));

    }
  }
  uncomp_hdr_len += UIP_IPH_LEN;

  
  nhc = iphc0 & SICSLOWPAN_IPHC_NH_C;
  
  last_nextheader =  &SICSLOWPAN_IP_BUF(buf)->proto;
  ip_payload = SICSLOWPAN_IPPAYLOAD_BUF(buf);

  CHECK_READ_SPACE(1);
  while(nhc && (*hc06_ptr & SICSLOWPAN_NHC_MASK) == SICSLOWPAN_NHC_EXT_HDR) {
    uint8_t eid = (*hc06_ptr & 0x0e) >> 1;
    
    uint8_t nh = (*hc06_ptr & 0x01);
    uint8_t next = 0;
    uint8_t len;
    uint8_t proto;

    nhc = nh;

    hc06_ptr++;
    CHECK_READ_SPACE(1);
    if(!nh) {
      next = *hc06_ptr;
      hc06_ptr++;
      LOG_DBG("uncompression: next header is inlined. Next: %d\n", next);
    }
    CHECK_READ_SPACE(1);
    len = *hc06_ptr;
    hc06_ptr++;

    LOG_DBG("uncompression: found ext header id: %d next: %d len: %d\n", eid, next, len);
    switch(eid) {
    case SICSLOWPAN_NHC_ETX_HDR_HBHO:
      proto = UIP_PROTO_HBHO;
      break;
    case SICSLOWPAN_NHC_ETX_HDR_ROUTING:
      proto = UIP_PROTO_ROUTING;
      break;
    case SICSLOWPAN_NHC_ETX_HDR_FRAG:
      proto = UIP_PROTO_FRAG;
      break;
    case SICSLOWPAN_NHC_ETX_HDR_DESTO:
      proto = UIP_PROTO_DESTO;
      break;
    default:
      LOG_DBG("uncompression: error unsupported ext header\n");
      return false;
    }
    *last_nextheader = proto;

    
    if((ip_payload - buf) + UIP_EXT_HDR_LEN + len > buf_size) {
      LOG_WARN("uncompression: cannot write ext header beyond target buffer\n");
      return false;
    }

    
    exthdr = (struct uip_ext_hdr *)ip_payload;
    exthdr->len = (UIP_EXT_HDR_LEN + len) / 8;
    if(exthdr->len == 0) {
      LOG_WARN("Extension header length is below 8\n");
      return false;
    }
    exthdr->len--;
    exthdr->next = next;
    last_nextheader = &exthdr->next;

    
    CHECK_READ_SPACE(len + 1);
    memcpy((uint8_t *)exthdr + UIP_EXT_HDR_LEN, hc06_ptr, len);
    hc06_ptr += len;

    uncomp_hdr_len += (exthdr->len + 1) * 8;
    ip_payload += (exthdr->len + 1) * 8;
    ext_hdr_len += (exthdr->len + 1) * 8;

    LOG_DBG("uncompression: %d len: %d exthdr len: %d (calc: %d)\n", proto, len, exthdr->len, (exthdr->len + 1) * 8);
  }

  
  CHECK_READ_SPACE(1);
  if(nhc && (*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {
    struct uip_udp_hdr *udp_buf = (struct uip_udp_hdr *)ip_payload;
    uint16_t udp_len;
    uint8_t checksum_compressed;
    *last_nextheader = UIP_PROTO_UDP;
    checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;
    LOG_DBG("uncompression: incoming header value: %i\n", *hc06_ptr);
    switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {
    case SICSLOWPAN_NHC_UDP_CS_P_00:
      
      CHECK_READ_SPACE(5);
      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);
      memcpy(&udp_buf->destport, hc06_ptr + 3, 2);
      LOG_DBG("uncompression: UDP ports (ptr+5): %x, %x\n", UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));

      hc06_ptr += 5;
      break;

    case SICSLOWPAN_NHC_UDP_CS_P_01:
      
      LOG_DBG("uncompression: destination address\n");
      CHECK_READ_SPACE(4);
      memcpy(&udp_buf->srcport, hc06_ptr + 1, 2);
      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));
      LOG_DBG("uncompression: UDP ports (ptr+4): %x, %x\n", UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));
      hc06_ptr += 4;
      break;

    case SICSLOWPAN_NHC_UDP_CS_P_10:
      
      LOG_DBG("uncompression: source address\n");
      CHECK_READ_SPACE(4);
      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 1)));
      memcpy(&udp_buf->destport, hc06_ptr + 2, 2);
      LOG_DBG("uncompression: UDP ports (ptr+4): %x, %x\n", UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));
      hc06_ptr += 4;
      break;

    case SICSLOWPAN_NHC_UDP_CS_P_11:
      
      CHECK_READ_SPACE(2);
      udp_buf->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN + (*(hc06_ptr + 1) >> 4));
      udp_buf->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN + ((*(hc06_ptr + 1)) & 0x0F));
      LOG_DBG("uncompression: UDP ports (ptr+2): %x, %x\n", UIP_HTONS(udp_buf->srcport), UIP_HTONS(udp_buf->destport));

      hc06_ptr += 2;
      break;
    default:
      LOG_DBG("uncompression: error unsupported UDP compression\n");
      return false;
    }
    if(!checksum_compressed) { 
      CHECK_READ_SPACE(2);
      memcpy(&udp_buf->udpchksum, hc06_ptr, 2);
      hc06_ptr += 2;
      LOG_DBG("uncompression: checksum included\n");
    } else {
      LOG_DBG("uncompression: checksum *NOT* included\n");
    }

    
    udp_len = 8 + packetbuf_datalen() - (hc06_ptr - packetbuf_ptr);
    udp_buf->udplen = UIP_HTONS(ip_len == 0 ? udp_len :
                                ip_len - UIP_IPH_LEN - ext_hdr_len);
    LOG_DBG("uncompression: UDP length: %u (ext: %u) ip_len: %d udp_len: %d\n", UIP_HTONS(udp_buf->udplen), ext_hdr_len, ip_len, udp_len);

    uncomp_hdr_len += UIP_UDPH_LEN;
  }

  packetbuf_hdr_len = hc06_ptr - packetbuf_ptr;

  
  if(ip_len == 0) {
    int len = packetbuf_datalen() - packetbuf_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;
    LOG_DBG("uncompression: IP payload length: %d. %u - %u + %u - %u\n", len, packetbuf_datalen(), packetbuf_hdr_len, uncomp_hdr_len, UIP_IPH_LEN);

    
    SICSLOWPAN_IP_BUF(buf)->len[0] = len >> 8;
    SICSLOWPAN_IP_BUF(buf)->len[1] = len & 0x00FF;
  } else {
    
    SICSLOWPAN_IP_BUF(buf)->len[0] = (ip_len - UIP_IPH_LEN) >> 8;
    SICSLOWPAN_IP_BUF(buf)->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;
  }

  return true;
}






static void add_paging_dispatch(uint8_t page)
{
  
  PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] = SICSLOWPAN_DISPATCH_PAGING | (page & 0x0f);
  packetbuf_hdr_len++;
}


static void add_6lorh_hdr(void)
{
  
}




static void digest_paging_dispatch(void)
{
  
  if((PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_PAGING_MASK) == SICSLOWPAN_DISPATCH_PAGING) {
    
    curr_page = PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & 0x0f;
    packetbuf_hdr_len++;
  }
}


static void digest_6lorh_hdr(void)
{
  
}





static void compress_hdr_ipv6(linkaddr_t *link_destaddr)
{
  *packetbuf_ptr = SICSLOWPAN_DISPATCH_IPV6;
  packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
  memcpy(packetbuf_ptr + packetbuf_hdr_len, UIP_IP_BUF, UIP_IPH_LEN);
  packetbuf_hdr_len += UIP_IPH_LEN;
  uncomp_hdr_len += UIP_IPH_LEN;
  return;
}







static void packet_sent(void *ptr, int status, int transmissions)
{
  const linkaddr_t *dest;

  if(callback != NULL) {
    callback->output_callback(status);
  }
  last_tx_status = status;

  
  dest = packetbuf_addr(PACKETBUF_ADDR_RECEIVER);
  if(linkaddr_cmp(dest, &linkaddr_null)) {
    return;
  }

  
  link_stats_packet_sent(dest, status, transmissions);

  
  NETSTACK_ROUTING.link_callback(dest, status, transmissions);

  
  uip_ds6_link_callback(status, transmissions);
}


static void send_packet(linkaddr_t *dest)
{
  
  packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, dest);


  
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER,(void*)&uip_lladdr);


  
  NETSTACK_MAC.send(&packet_sent, NULL);

  
  watchdog_periodic();
}



static int fragment_copy_payload_and_send(uint16_t uip_offset, linkaddr_t *dest) {
  struct queuebuf *q;

  
  memcpy(packetbuf_ptr + packetbuf_hdr_len, (uint8_t *)UIP_IP_BUF + uip_offset, packetbuf_payload_len);
  packetbuf_set_datalen(packetbuf_payload_len + packetbuf_hdr_len);

  
  q = queuebuf_new_from_packetbuf();
  if(q == NULL) {
    LOG_WARN("output: could not allocate queuebuf, dropping fragment\n");
    return 0;
  }

  
  send_packet(dest);

  
  queuebuf_to_packetbuf(q);
  queuebuf_free(q);

  
  if((last_tx_status == MAC_TX_COLLISION) || (last_tx_status >= MAC_TX_ERR)) {
    LOG_ERR("output: error in fragment tx, dropping subsequent fragments.\n");
    return 0;
  }
  return 1;
}



static uint8_t output(const linkaddr_t *localdest)
{
  int frag_needed;

  
  linkaddr_t dest;

  
  uncomp_hdr_len = 0;
  packetbuf_hdr_len = 0;

  
  packetbuf_clear();
  packetbuf_ptr = packetbuf_dataptr();

  if(callback) {
    
    set_packet_attrs();
  }

  
  if(localdest == NULL) {
    linkaddr_copy(&dest, &linkaddr_null);
  } else {
    linkaddr_copy(&dest, localdest);
  }

  LOG_INFO("output: sending IPv6 packet with len %d\n", uip_len);

  
  packetbuf_set_attr(PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS, uipbuf_get_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS));


  packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &dest);

  
  packetbuf_set_attr(PACKETBUF_ATTR_SECURITY_LEVEL, uipbuf_get_attr(UIPBUF_ATTR_LLSEC_LEVEL));

  packetbuf_set_attr(PACKETBUF_ATTR_KEY_INDEX, uipbuf_get_attr(UIPBUF_ATTR_LLSEC_KEY_ID));



  mac_max_payload = NETSTACK_MAC.max_payload();

  if(mac_max_payload <= 0) {
  
    LOG_WARN("output: failed to calculate payload size - dropping packet\n");
    return 0;
  }

  

  compress_hdr_ipv6(&dest);


  
  if(!uip_is_addr_linklocal(&UIP_IP_BUF->destipaddr)) {
    add_paging_dispatch(1);
    add_6lorh_hdr();
  }


  if(compress_hdr_iphc(&dest) == 0) {
    
    return 0;
  }


  

  packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &dest);

  frag_needed = (int)uip_len - (int)uncomp_hdr_len + (int)packetbuf_hdr_len > mac_max_payload;
  LOG_INFO("output: header len %d -> %d, total len %d -> %d, MAC max payload %d, frag_needed %d\n", uncomp_hdr_len, packetbuf_hdr_len, uip_len, uip_len - uncomp_hdr_len + packetbuf_hdr_len, mac_max_payload, frag_needed);



  if(frag_needed) {

    
    uint16_t processed_ip_out_len;
    uint16_t frag_tag;
    int curr_frag = 0;

    
     
    int total_payload = (uip_len - uncomp_hdr_len);
    
    int frag1_payload = (mac_max_payload - packetbuf_hdr_len - SICSLOWPAN_FRAG1_HDR_LEN) & 0xfffffff8;
    
    int fragn_max_payload = (mac_max_payload - SICSLOWPAN_FRAGN_HDR_LEN) & 0xfffffff8;
    
    int last_fragn_max_payload = mac_max_payload - SICSLOWPAN_FRAGN_HDR_LEN;
    
    int middle_fragn_total_payload = MAX(total_payload - frag1_payload - last_fragn_max_payload, 0);
    
    int fragment_count = 2;
    if(middle_fragn_total_payload > 0) {
      fragment_count += 1 + (middle_fragn_total_payload - 1) / fragn_max_payload;
    }

    int freebuf = queuebuf_numfree() - 1;
    LOG_INFO("output: fragmentation needed, fragments: %u, free queuebufs: %u\n", fragment_count, freebuf);

    if(freebuf < fragment_count) {
      LOG_WARN("output: dropping packet, not enough free bufs (needed: %u, free: %u)\n", fragment_count, freebuf);
      return 0;
    }

    if(frag1_payload < 0) {
      
      LOG_WARN("output: compressed header does not fit first fragment\n");
      return 0;
    }

    
    last_tx_status = MAC_TX_OK;
    
    frag_tag = my_tag++;

    
    memmove(packetbuf_ptr + SICSLOWPAN_FRAG1_HDR_LEN, packetbuf_ptr, packetbuf_hdr_len);
    packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;

    
    SET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE, ((SICSLOWPAN_DISPATCH_FRAG1 << 8) | uip_len));
    SET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG, frag_tag);

    
    packetbuf_payload_len = frag1_payload;

    
    
    LOG_INFO("output: fragment %d/%d (tag %d, payload %d)\n", curr_frag + 1, fragment_count, frag_tag, packetbuf_payload_len);

    if(fragment_copy_payload_and_send(uncomp_hdr_len, &dest) == 0) {
      return 0;
    }

    

    
    packetbuf_hdr_len = SICSLOWPAN_FRAGN_HDR_LEN;
    SET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE, ((SICSLOWPAN_DISPATCH_FRAGN << 8) | uip_len));

    
    processed_ip_out_len = uncomp_hdr_len + packetbuf_payload_len;

    
    while(processed_ip_out_len < uip_len) {
      curr_frag++;
      
      PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET] = processed_ip_out_len >> 3;

      
      if(uip_len - processed_ip_out_len > last_fragn_max_payload) {
        
        packetbuf_payload_len = fragn_max_payload;
      } else {
        
        packetbuf_payload_len = uip_len - processed_ip_out_len;
      }

      
      
      LOG_INFO("output: fragment %d/%d (tag %d, payload %d, offset %d)\n", curr_frag + 1, fragment_count, frag_tag, packetbuf_payload_len, processed_ip_out_len);

      if(fragment_copy_payload_and_send(processed_ip_out_len, &dest) == 0) {
        return 0;
      }

      processed_ip_out_len += packetbuf_payload_len;
    }

    LOG_ERR("output: Packet too large to be sent without fragmentation support; dropping packet\n");
    return 0;

  } else {
    

   if(uip_len < uncomp_hdr_len) {
     LOG_ERR("output: uip_len is smaller than uncomp_hdr_len (%d < %d)", (int)uip_len, (int)uncomp_hdr_len);
     return 0;
    }

    memcpy(packetbuf_ptr + packetbuf_hdr_len, (uint8_t *)UIP_IP_BUF + uncomp_hdr_len, uip_len - uncomp_hdr_len);
    packetbuf_set_datalen(uip_len - uncomp_hdr_len + packetbuf_hdr_len);
    send_packet(&dest);
  }
  return 1;
}



static void input(void)
{
  
  uint16_t frag_size = 0;
  
  uint8_t frag_offset = 0;
  uint8_t *buffer;
  uint16_t buffer_size;


  uint8_t is_fragment = 0;
  int8_t frag_context = 0;

  
  uint16_t frag_tag = 0;
  uint8_t first_fragment = 0, last_fragment = 0;


  
  link_stats_input_callback(packetbuf_addr(PACKETBUF_ADDR_SENDER));

  
  uncomp_hdr_len = 0;
  packetbuf_hdr_len = 0;

  
  packetbuf_ptr = packetbuf_dataptr();

  if(packetbuf_datalen() == 0) {
    LOG_WARN("input: empty packet\n");
    return;
  }

  
  uipbuf_clear();

  
  buffer = (uint8_t *)UIP_IP_BUF;
  buffer_size = UIP_BUFSIZE;

  
  last_rssi = (signed short)packetbuf_attr(PACKETBUF_ATTR_RSSI);
  uipbuf_set_attr(UIPBUF_ATTR_RSSI, packetbuf_attr(PACKETBUF_ATTR_RSSI));
  uipbuf_set_attr(UIPBUF_ATTR_LINK_QUALITY, packetbuf_attr(PACKETBUF_ATTR_LINK_QUALITY));




  
  switch((GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) >> 8) & SICSLOWPAN_DISPATCH_FRAG_MASK) {
    case SICSLOWPAN_DISPATCH_FRAG1:
      frag_offset = 0;
      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;
      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);
      packetbuf_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;
      first_fragment = 1;
      is_fragment = 1;

      LOG_INFO("input: received first element of a fragmented packet (tag %d, len %d)\n", frag_tag, frag_size);

      
      frag_context = add_fragment(frag_tag, frag_size, frag_offset);

      if(frag_context == -1) {
        LOG_ERR("input: failed to allocate new reassembly context\n");
        return;
      }

      buffer = frag_info[frag_context].first_frag;
      buffer_size = SICSLOWPAN_FIRST_FRAGMENT_SIZE;
      break;
    case SICSLOWPAN_DISPATCH_FRAGN:
      
      frag_offset = PACKETBUF_FRAG_PTR[PACKETBUF_FRAG_OFFSET];
      frag_tag = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_TAG);
      frag_size = GET16(PACKETBUF_FRAG_PTR, PACKETBUF_FRAG_DISPATCH_SIZE) & 0x07ff;
      packetbuf_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;

      
      frag_context = add_fragment(frag_tag, frag_size, frag_offset);

      if(frag_context == -1) {
        LOG_ERR("input: reassembly context not found (tag %d)\n", frag_tag);
        return;
      }

      
      buffer = NULL;

      if(frag_info[frag_context].reassembled_len >= frag_size) {
        last_fragment = 1;
      }
      is_fragment = 1;
      break;
    default:
      break;
  }

  if(is_fragment && !first_fragment) {
    
    goto copypayload;
  }


  
  curr_page = 0;
  digest_paging_dispatch();
  if(curr_page == 1) {
    LOG_INFO("input: page 1, 6LoRH\n");
    digest_6lorh_hdr();
  } else if (curr_page > 1) {
    LOG_ERR("input: page %u not supported\n", curr_page);
    return;
  }

  
  if(SICSLOWPAN_COMPRESSION > SICSLOWPAN_COMPRESSION_IPV6 && (PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK) == SICSLOWPAN_DISPATCH_IPHC) {
    LOG_DBG("uncompression: IPHC dispatch\n");
    if(uncompress_hdr_iphc(buffer, buffer_size, frag_size) == false) {
      LOG_ERR("input: failed to decompress IPHC packet\n");
      return;
    }
  } else if(PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] == SICSLOWPAN_DISPATCH_IPV6) {
    LOG_DBG("uncompression: IPV6 dispatch\n");
    packetbuf_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;

    
    memcpy(buffer, packetbuf_ptr + packetbuf_hdr_len, UIP_IPH_LEN);

    
    packetbuf_hdr_len += UIP_IPH_LEN;
    uncomp_hdr_len += UIP_IPH_LEN;
  } else {
    LOG_ERR("uncompression: unknown dispatch: 0x%02x, or IPHC disabled\n", PACKETBUF_6LO_PTR[PACKETBUF_6LO_DISPATCH] & SICSLOWPAN_DISPATCH_IPHC_MASK);
    return;
  }


 copypayload:

  
  if(packetbuf_datalen() < packetbuf_hdr_len) {
    LOG_ERR("input: packet dropped due to header > total packet\n");
    return;
  }
  packetbuf_payload_len = packetbuf_datalen() - packetbuf_hdr_len;


  if(is_fragment) {
    LOG_INFO("input: fragment (tag %d, payload %d, offset %d) -- %u %u\n", frag_tag, packetbuf_payload_len, frag_offset << 3, packetbuf_datalen(), packetbuf_hdr_len);
  }


  
  {
    int req_size = uncomp_hdr_len + (uint16_t)(frag_offset << 3)
        + packetbuf_payload_len;
    if(req_size > sizeof(uip_buf)) {

      LOG_ERR( "input: packet and fragment context %u dropped, minimum required IP_BUF size: %d+%d+%d=%d (current size: %u)\n", frag_context, uncomp_hdr_len, (uint16_t)(frag_offset << 3), packetbuf_payload_len, req_size, (unsigned)sizeof(uip_buf));



      
      clear_fragments(frag_context);

      return;
    }
  }

  
  if(buffer != NULL) {
    memcpy((uint8_t *)buffer + uncomp_hdr_len, packetbuf_ptr + packetbuf_hdr_len, packetbuf_payload_len);
  }

  


  if(frag_size > 0) {
    
    if(first_fragment != 0) {
      frag_info[frag_context].reassembled_len = uncomp_hdr_len + packetbuf_payload_len;
      frag_info[frag_context].first_frag_len = uncomp_hdr_len + packetbuf_payload_len;
    }
    
    if(last_fragment != 0) {
      frag_info[frag_context].reassembled_len = frag_size;
      
      if(!copy_frags2uip(frag_context)) {
        return;
      }
    }
  }

  
  if(!is_fragment || last_fragment) {
    
    if(is_fragment != 0 && last_fragment != 0) {
      uip_len = frag_size;
    } else {
      uip_len = packetbuf_payload_len + uncomp_hdr_len;
    }

    uip_len = packetbuf_payload_len + uncomp_hdr_len;

    LOG_INFO("input: received IPv6 packet with len %d\n", uip_len);

    if(LOG_DBG_ENABLED) {
      uint16_t ndx;
      LOG_DBG("uncompression: after (%u):", UIP_IP_BUF->len[1]);
      for (ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {
        uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];
        LOG_DBG_("%02x", data);
      }
      LOG_DBG_("\n");
    }

    
    if(callback) {
      set_packet_attrs();
      callback->input_callback();
    }


    
    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_LEVEL, packetbuf_attr(PACKETBUF_ATTR_SECURITY_LEVEL));

    uipbuf_set_attr(UIPBUF_ATTR_LLSEC_KEY_ID, packetbuf_attr(PACKETBUF_ATTR_KEY_INDEX));



    tcpip_input();

  }

}





void sicslowpan_init(void)
{




  addr_contexts[0].used   = 1;
  addr_contexts[0].number = 0;

  SICSLOWPAN_CONF_ADDR_CONTEXT_0;

  addr_contexts[0].prefix[0] = UIP_DS6_DEFAULT_PREFIX_0;
  addr_contexts[0].prefix[1] = UIP_DS6_DEFAULT_PREFIX_1;




  {
    int i;
    for(i = 1; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {

      if (i==1) {
        addr_contexts[1].used   = 1;
        addr_contexts[1].number = 1;
        SICSLOWPAN_CONF_ADDR_CONTEXT_1;

      } else if (i==2) {
        addr_contexts[2].used   = 1;
        addr_contexts[2].number = 2;
        SICSLOWPAN_CONF_ADDR_CONTEXT_2;

      } else {
        addr_contexts[i].used = 0;
      }

      addr_contexts[i].used = 0;

    }
  }



}

int sicslowpan_get_last_rssi(void)
{
  return last_rssi;
}

const struct network_driver sicslowpan_driver = {
  "sicslowpan", sicslowpan_init, input, output };





