



























int disable_503_translation = 0;








extern char version[];
extern int version_len;



int received_test( struct sip_msg *msg )
{
	int rcvd;

	if(msg->via1->received !=NULL)
		return 1;

	if(msg->via1->maddr){
		rcvd = check_ip_address(&msg->rcv.src_ip, &msg->via1->maddr->value, msg->via1->port, msg->via1->proto, received_dns);
	} else {
		rcvd = check_ip_address(&msg->rcv.src_ip, &msg->via1->host, msg->via1->port, msg->via1->proto, received_dns);
	}

	return rcvd;
}


static char * warning_builder( struct sip_msg *msg, unsigned int *returned_len)
{
	static char buf[MAX_WARNING_LEN];
	str *foo;
	int print_len, l, clen;
	char* t;



























	clen=0;
	str_lenpair_print(WARNING, WARNING_LEN, msg->rcv.bind_address->name.s, msg->rcv.bind_address->name.len);

	str_lenpair_print(":", 1, msg->rcv.bind_address->port_no_str.s, msg->rcv.bind_address->port_no_str.len);
	str_print(WARNING_PHRASE, WARNING_PHRASE_LEN);

	
	if (msg->new_uri.s)
		foo=&(msg->new_uri);
	else foo=&(msg->first_line.u.request.uri);
	
	str_int_print(" pid=", my_pid());
	
	str_ipaddr_print(" req_src_ip=", &msg->rcv.src_ip);
	str_int_print(" req_src_port=", msg->rcv.src_port);
	str_pair_print(" in_uri=", msg->first_line.u.request.uri.s, msg->first_line.u.request.uri.len);
	str_pair_print(" out_uri=", foo->s, foo->len);
	str_pair_print(" via_cnt", (msg->parsed_flag & HDR_EOH_F)==HDR_EOH_F ? "=" : ">", 1);
	str_int_print("=", via_cnt);
	if (clen<MAX_WARNING_LEN){ buf[clen]='"'; clen++; }
	else goto error_overflow;


	*returned_len=clen;
	return buf;
error_overflow:
	LM_ERR("buffer size exceeded\n");
	*returned_len=0;
	return 0;
}




char* received_builder(struct sip_msg *msg, unsigned int *received_len)
{
	char *buf, *tmp;
	int  len, tmp_len;
	struct ip_addr *source_ip;

	source_ip=&msg->rcv.src_ip;

	buf=pkg_malloc(sizeof(char)*MAX_RECEIVED_SIZE);
	if (buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		return 0;
	}
	memcpy(buf, RECEIVED, RECEIVED_LEN);
	if ( (tmp=ip_addr2a(source_ip))==0)
		return 0; 
	tmp_len=strlen(tmp);
	len=RECEIVED_LEN+tmp_len;

	memcpy(buf+RECEIVED_LEN, tmp, tmp_len);
	buf[len]=0; 

	*received_len = len;
	return buf;
}



char* rport_builder(struct sip_msg *msg, unsigned int *rport_len)
{
	char* buf, * tmp;
	int len, tmp_len;

	tmp_len=0;
	tmp=int2str(msg->rcv.src_port, &tmp_len);
	len=RPORT_LEN+tmp_len;
	buf=pkg_malloc(sizeof(char)*(len+1));
	if (buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		return 0;
	}
	memcpy(buf, RPORT, RPORT_LEN);
	memcpy(buf+RPORT_LEN, tmp, tmp_len);
	buf[len]=0; 

	*rport_len=len;
	return buf;
}



char* id_builder(struct sip_msg* msg, unsigned int *id_len)
{
	char* buf, *p;
	int len, value_len, size;
	char revhex[sizeof(int)*2];

	size=sizeof(int)*2;
	p=&revhex[0];
	if (int2reverse_hex(&p, &size, msg->rcv.proto_reserved1)==-1){
		LM_CRIT("not enough space for id\n");
		return 0;
	}
	value_len=p-&revhex[0];
	len=ID_PARAM_LEN+value_len;
	buf=pkg_malloc(sizeof(char)*(len+1));
	if (buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		return 0;
	}
	memcpy(buf, ID_PARAM, ID_PARAM_LEN);
	memcpy(buf+ID_PARAM_LEN, revhex, value_len);
	buf[len]=0; 
	*id_len=len;
	return buf;
}



char* clen_builder(struct sip_msg* msg, int *clen_len, int diff)
{
	char *buf, * value_s;
	int len, value, value_len;
	str body;

	if ( (get_body(msg,&body)!=0) ) {
		ser_error=E_BAD_REQ;
		LM_ERR("no message body found (missing crlf?)");
		return 0;
	}
	value = body.len + diff;
	value_s=int2str(value, &value_len);
	LM_DBG("content-length: %d (%s)\n", value, value_s);

	len=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;
	buf=pkg_malloc(sizeof(char)*(len+1));
	if (buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		return 0;
	}
	memcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);
	memcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);
	memcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);
	buf[len]=0; 
	*clen_len=len;
	return buf;
}




static inline int lump_check_opt(	struct lump *l, struct sip_msg* msg, struct socket_info* snd_s )


{
	struct ip_addr* ip;
	unsigned short port;
	int proto;















	switch(l->u.cond){
		case COND_FALSE:
			return 0;
		case COND_TRUE:
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_DIFF_REALMS:
			get_ip_port_proto;
			
			if ((port==snd_s->port_no)&&(proto==snd_s->proto)&& (ip_addr_cmp(ip, &snd_s->address))) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_SAME_REALMS:
			get_ip_port_proto;
			
			if ((port!=snd_s->port_no)||(proto!=snd_s->proto)|| (!ip_addr_cmp(ip, &snd_s->address))) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_DIFF_AF:
			get_ip_port_proto;
			if (ip->af==snd_s->address.af) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_DIFF_PROTO:
			get_ip_port_proto;
			if (proto==snd_s->proto) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_DIFF_PORT:
			get_ip_port_proto;
			if (port==snd_s->port_no) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		case COND_IF_DIFF_IP:
			get_ip_port_proto;
			if (ip_addr_cmp(ip, &snd_s->address)) {
				l->flags &= ~LUMPFLAG_COND_TRUE;
				return 0;
			}
			l->flags |= LUMPFLAG_COND_TRUE;
			return 1;
		default:
			LM_CRIT("unknown lump condition %d\n", l->u.cond);
	}
	return 0; 
}




int lumps_len(struct sip_msg* msg, struct lump* lumps, struct socket_info* send_sock, int max_offset)
{
	unsigned int s_offset, new_len;
	unsigned int last_del;
	struct lump *t, *r;
	str *send_address_str, *send_port_str;
	str *rcv_address_str=NULL;
	str *rcv_port_str=NULL;














































































































































	s_offset=0;
	new_len=0;
	last_del=0;

	
	if(send_sock && send_sock->adv_name_str.len)
		send_address_str=&(send_sock->adv_name_str);
	else if (msg->set_global_address.s)
		send_address_str=&(msg->set_global_address);
	else if (default_global_address->s)
		send_address_str=default_global_address;
	else send_address_str=&(send_sock->address_str);

	if(send_sock && send_sock->adv_port_str.len)
		send_port_str=&(send_sock->adv_port_str);
	else if (msg->set_global_port.s)
		send_port_str=&(msg->set_global_port);
	else if (default_global_port->s)
		send_port_str=default_global_port;
	else send_port_str=&(send_sock->port_no_str);

	
	if(msg->rcv.bind_address) {
		if(msg->rcv.bind_address->adv_name_str.len)
			rcv_address_str=&(msg->rcv.bind_address->adv_name_str);
		else if (default_global_address->s)
			rcv_address_str=default_global_address;
		else rcv_address_str=&(msg->rcv.bind_address->address_str);
		if(msg->rcv.bind_address->adv_port_str.len)
			rcv_port_str=&(msg->rcv.bind_address->adv_port_str);
		else if (default_global_port->s)
			rcv_port_str=default_global_port;
		else rcv_port_str=&(msg->rcv.bind_address->port_no_str);
	}

	for (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {
		
		if (t->u.offset < s_offset && t->u.offset != last_del) {
			LM_DBG("skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\n", t->op,s_offset, t->u.offset,last_del);
			continue;
		}

		for (r = t->before; r; r = r->before) {
			switch (r->op) {
				case LUMP_ADD:
					new_len += r->len;
					break;
				case LUMP_ADD_SUBST:
					SUBST_LUMP_LEN(r);
					break;
				case LUMP_ADD_OPT:
					
					if (!lump_check_opt(r, msg, send_sock))
						goto skip_before;
					break;
				case LUMP_SKIP:
					
					if (!r->before || !r->before->before)
						continue;
					for (; r->before->before; r = r->before)
						;
					break;
				default:
					
						LM_CRIT("invalid op for data lump (%x)\n", r->op);
			}
		}
skip_before:
		switch (t->op) {
			case LUMP_DEL:
				last_del=t->u.offset;

				if (t->u.offset < s_offset) {
					if (t->u.offset + t->len > s_offset) {
						new_len -= t->len - (s_offset - t->u.offset);
						s_offset = t->u.offset + t->len;
					}
				} else {
					new_len -= t->len;
					s_offset = t->u.offset + t->len;
				}

				break;
			case LUMP_NOP:
				
				break;
			case LUMP_ADD:
				
				new_len += t->len;
				break;
			case LUMP_ADD_OPT:
				LM_BUG("LUMP_ADD_OPT");
				
				break;
			case LUMP_SKIP:
				LM_BUG("LUMP_SKIP");
				
				break;
			case LUMP_ADD_SUBST:
				LM_BUG("LUMP_ADD_SUBST");
				SUBST_LUMP_LEN(t);
				break;
			default:
				LM_BUG("op for data lump (%x)", r->op);
		}

		for (r = t->after; r; r = r->after) {
			switch (r->op) {
				case LUMP_ADD:
					new_len+=r->len;
					break;
				case LUMP_ADD_SUBST:
					SUBST_LUMP_LEN(r);
					break;
				case LUMP_ADD_OPT:
					
					if (!lump_check_opt(r, msg, send_sock))
						goto skip_after;
					break;
				case LUMP_SKIP:
					
					if (!r->after || !r->after->after)
						continue;
					for (; r->after->after; r = r->after)
						;
					break;
				default:
					
					LM_CRIT("invalid op for data lump (%x)\n", r->op);
			}
		}
skip_after:
		; 
	}
	return new_len;
}





void process_lumps(	struct sip_msg* msg, struct lump* lumps, char* new_buf, unsigned int* new_buf_offs, unsigned int* orig_offs, struct socket_info* send_sock, int max_offset)





{
	struct lump *t, *r;
	char* orig;
	unsigned int size, offset, s_offset;
	unsigned int last_del;
	str *send_address_str, *send_port_str;
	str *rcv_address_str=NULL;
	str *rcv_port_str=NULL;























































































































































































































































	
	if(send_sock && send_sock->adv_name_str.len)
		send_address_str=&(send_sock->adv_name_str);
	else if (msg->set_global_address.len)
		send_address_str=&(msg->set_global_address);
	else if (default_global_address->s)
		send_address_str=default_global_address;
	else send_address_str=&(send_sock->address_str);
	if(send_sock && send_sock->adv_port_str.len)
		send_port_str=&(send_sock->adv_port_str);
	else if (msg->set_global_port.len)
		send_port_str=&(msg->set_global_port);
	else if (default_global_port->s)
		send_port_str=default_global_port;
	else send_port_str=&(send_sock->port_no_str);

	
	if(msg->rcv.bind_address) {
		if(msg->rcv.bind_address->adv_name_str.len)
			rcv_address_str=&(msg->rcv.bind_address->adv_name_str);
		else if (default_global_address->s)
			rcv_address_str=default_global_address;
		else rcv_address_str=&(msg->rcv.bind_address->address_str);
		if(msg->rcv.bind_address->adv_port_str.len)
			rcv_port_str=&(msg->rcv.bind_address->adv_port_str);
		else if (default_global_port->s)
			rcv_port_str=default_global_port;
		else rcv_port_str=&(msg->rcv.bind_address->port_no_str);
	}

	orig=msg->buf;
	offset=*new_buf_offs;
	s_offset=*orig_offs;
	last_del=0;

	for (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {
		
		if (t->u.offset < s_offset && t->u.offset != last_del) {
			LM_DBG("skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\n", t->op,s_offset, t->u.offset,last_del);
			continue;
		}

		switch (t->op) {
			case LUMP_NOP:
			case LUMP_DEL:
				
				if (s_offset < t->u.offset) {
					size = t->u.offset-s_offset;
					memcpy(new_buf+offset, orig+s_offset, size);
					offset += size;
					s_offset += size;
				}

				if (t->op == LUMP_DEL)
					last_del = t->u.offset;

				
				for (r = t->before; r; r = r->before) {
					switch (r->op) {
						case LUMP_ADD:
							
							memcpy(new_buf+offset, r->u.value, r->len);
							offset += r->len;
							break;
						case LUMP_ADD_SUBST:
							SUBST_LUMP(r);
							break;
						case LUMP_ADD_OPT:
							
							if (!lump_check_opt(r, msg, send_sock))
								goto skip_nop_before;
							break;
						case LUMP_SKIP:
							
							if (!r->before || !r->before->before)
								continue;
							for (; r->before->before; r = r->before)
								;
							break;
						default:
							
							LM_BUG("invalid op 1 (%x)",r->op);
					}
				}
skip_nop_before:
				if (t->op == LUMP_DEL) {
					
					if (t->u.offset + t->len > s_offset)
						s_offset += t->len - (s_offset - t->u.offset);
				}

				
				for (r = t->after; r; r = r->after) {
					switch (r->op) {
						case LUMP_ADD:
							
							memcpy(new_buf+offset, r->u.value, r->len);
							offset += r->len;
							break;
						case LUMP_ADD_SUBST:
							SUBST_LUMP(r);
							break;
						case LUMP_ADD_OPT:
							
							if (!lump_check_opt(r, msg, send_sock))
								goto skip_nop_after;
							break;
						case LUMP_SKIP:
							
							if (!r->after || !r->after->after)
								continue;
							for (; r->after->after; r = r->after)
								;
							break;
						default:
							
							LM_BUG("invalid op 2 (%x)", r->op);
					}
				}
skip_nop_after:
				break;
			case LUMP_ADD:
			case LUMP_ADD_SUBST:
			case LUMP_ADD_OPT:
				LM_BUG("ADD|SUBST|OPT");
				
				if ((t->op==LUMP_ADD_OPT) && (!lump_check_opt(t, msg, send_sock)))
					continue;
				
				
				for(r=t->before;r;r=r->before){
					switch (r->op){
						case LUMP_ADD:
							
							memcpy(new_buf+offset, r->u.value, r->len);
							offset+=r->len;
							break;
						case LUMP_ADD_SUBST:
							SUBST_LUMP(r);
							break;
						case LUMP_ADD_OPT:
							
							if (!lump_check_opt(r, msg, send_sock))
								goto skip_before;
							break;
						case LUMP_SKIP:
							
							if (!r->before || !r->before->before) continue;
							for(;r->before->before;r=r->before);
							break;
						default:
							
							LM_BUG("invalid op 3 (%x)", r->op);
					}
				}
skip_before:
				
				switch(t->op){
					case LUMP_ADD:
						memcpy(new_buf+offset, t->u.value, t->len);
						offset+=t->len;
						break;
					case LUMP_ADD_SUBST:
						SUBST_LUMP(t);
						break;
					case LUMP_ADD_OPT:
						
						break;
					default:
						
						LM_BUG("invalid op 4 %d", t->op);
				}
				
				for(r=t->after;r;r=r->after){
					switch (r->op){
						case LUMP_ADD:
							
							memcpy(new_buf+offset, r->u.value, r->len);
							offset+=r->len;
							break;
						case LUMP_ADD_SUBST:
							SUBST_LUMP(r);
							break;
						case LUMP_ADD_OPT:
							
							if (!lump_check_opt(r, msg, send_sock))
								goto skip_after;
							break;
						case LUMP_SKIP:
							
							if (!r->after || !r->after->after) continue;
							for(;r->after->after;r=r->after);
							break;
						default:
							
							LM_BUG("invalid op 5 (%x)", r->op);
					}
				}
skip_after:
				break;
			case LUMP_SKIP:
				LM_BUG("LUMP_SKIP");
				
				if (!t->next || !t->next->next)
					continue;
				for (; t->next->next; t = t->next)
					;
				break;
			default:
				LM_BUG("invalid op 6 (%x)", t->op);
		}
	}

	*new_buf_offs = offset;
	*orig_offs = s_offset;
}



unsigned int prep_reassemble_body_parts( struct sip_msg* msg, struct socket_info* send_sock)
{
	struct body_part *part;
	struct lump* lump;
	struct lump* ct;
	unsigned int size;
	unsigned int len = 0;
	unsigned int orig_offs;
	struct hdr_field hf;
	char *hdr, *it;

	
	orig_offs = msg->body->part_count ? msg->body->body.s-msg->buf : msg->len ;

	if (msg->body->updated_part_count==0) {

		
		LM_DBG("no part to be added\n");

		
		if (msg->content_type && msg->content_type->name.s && msg->content_type->name.len && del_lump(msg, msg->content_type->name.s- msg->buf, msg->content_type->len, HDR_CONTENTTYPE_T)==0) {


			LM_ERR("failed to add lump to delete content type header\n");
		}

	} else if (msg->body->updated_part_count==1) {

		
		LM_DBG("only one part to be added\n");

		for( part=&msg->body->first ; part ; part=part->next)
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;

		if (part==NULL) {
			LM_BUG("updated count is 1, but no non-deleted part found :-/\n");
			return len ;
		}

		LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

		if (part->dump_f) {
			
			if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
				LM_ERR("failed to build part, inserting empty\n");
				part->dump.s = "";
				part->dump.len = 0;
			} else len += part->dump.len;
		} else {
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				
				len += part->body.len;
			} else {
				
				orig_offs = part->body.s - msg->buf;
				lump = msg->body_lumps;
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					len += lumps_len( msg, lump, send_sock,  part->body.s+part->body.len-msg->buf);
				}
				
				len += (part->body.s+part->body.len-msg->buf)-orig_offs;
			}
		}

		
		if ( (part->flags & SIP_BODY_PART_FLAG_NEW)
		|| msg->body->part_count>1 ) {
			
			if (msg->content_type)
				ct = del_lump(msg, msg->content_type->name.s-msg->buf, msg->content_type->len, HDR_CONTENTTYPE_T);
			else ct = anchor_lump(msg, msg->unparsed - msg->buf, HDR_CONTENTTYPE_T);

			if (ct==NULL) {
				LM_ERR("failed to remove old CT / create anchor\n");
			} else {
				
				if (part->flags & SIP_BODY_PART_FLAG_NEW) {
					hdr = (char*)pkg_malloc( 14 + part->mime_s.len +CRLF_LEN + part->headers.len);
					if (hdr==NULL) {
						LM_ERR("failed to allocate new ct hdr\n");
					} else {
						memcpy( hdr, "Content-Type: ", 14);
						memcpy( hdr+14, part->mime_s.s, part->mime_s.len);
						memcpy( hdr+14+part->mime_s.len, CRLF, CRLF_LEN);
						if (part->headers.len)
							memcpy( hdr+14+part->mime_s.len+CRLF_LEN, part->headers.s, part->headers.len);
						if (insert_new_lump_before(ct, hdr, 14+part->mime_s.len+CRLF_LEN+part->headers.len, HDR_CONTENTTYPE_T) == NULL) {

							LM_ERR("failed to create insert lump\n");
							pkg_free(hdr);
						}
					}
				} else {
					
					it = part->headers.s;
					while ( it<part->headers.s+part->headers.len ) {
						memset( &hf, 0, sizeof(struct hdr_field));
						it = get_hdr_field( it, part->headers.s+part->headers.len, &hf);
						if (hf.type==HDR_ERROR_T || hf.type==HDR_EOH_T)
							break;
						if (hf.type==HDR_CONTENTLENGTH_T)
							continue;
						
						hdr = (char*)pkg_malloc( hf.len);
						if (hdr==NULL) {
							LM_ERR("failed to allocate new ct hdr\n");
						} else {
							memcpy( hdr, hf.name.s, hf.len);
							if (insert_new_lump_before(ct, hdr, hf.len, HDR_CONTENTTYPE_T) == NULL) {
								LM_ERR("failed to create insert lump\n");
								pkg_free(hdr);
							}
						}
					}
				}
			}
		} else  if ( (part->flags & SIP_BODY_PART_FLAG_NEW)==0 && msg->body->part_count==1 && msg->body->flags & SIP_BODY_RCV_MULTIPART) {



				
				len += msg->body->body.len - part->body.len;
			}

	} else if (msg->body->part_count<2) {

		

		LM_DBG("transition from 0/1 parts to multi part body\n");
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
					
					orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			
			len += 2  + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14 + part->mime_s.len + CRLF_LEN + part->headers.len + CRLF_LEN ;


			
			if (part->dump_f) {
				if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
					LM_ERR("failed to build part, inserting empty\n");
					part->dump.s = "";
					part->dump.len = 0;
				} else len += part->dump.len;
				len += CRLF_LEN;
			} else  if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {

				
				len += part->body.len;
				len += CRLF_LEN;
			} else  {

				
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					
					len += lumps_len( msg, lump, send_sock, part->body.s+part->body.len-msg->buf);
				}
				
				size = (part->body.s+part->body.len-msg->buf)-orig_offs;
				len += size + CRLF_LEN;
			}

			
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;

		} 

		
		len += 2  + sizeof(OSS_BOUNDARY)-1 + 2  + CRLF_LEN;

		
		if (msg->content_type)
			ct = del_lump(msg, msg->content_type->name.s-msg->buf, msg->content_type->len, HDR_CONTENTTYPE_T);
		else ct = anchor_lump(msg, msg->unparsed - msg->buf, HDR_CONTENTTYPE_T);

		if (ct==NULL) {
			LM_ERR("failed to remove old CT / create anchor\n");
		} else {
			
			hdr = (char*)pkg_malloc( 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN );
			if (hdr==NULL) {
				LM_ERR("failed to allocate new ct hdr\n");
			} else {
				memcpy( hdr, "Content-Type: multipart/mixed;boundary=" OSS_BOUNDARY CRLF, 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN);

				if (insert_new_lump_before(ct, hdr, 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN, HDR_CONTENTTYPE_T) == NULL) {

					LM_ERR("failed to create insert lump\n");
					pkg_free(hdr);
				}
			}
		}

	} else {

		

		LM_DBG("multi to multi part body reconstruction\n");
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {
			
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )
					
					orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				
				len += 2  + msg->body->boundary.len + CRLF_LEN + 14  + part->mime_s.len + CRLF_LEN + part->headers.len + CRLF_LEN ;

				
				if (part->dump_f) {
					if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
						LM_ERR("failed to build part, inserting empty\n");
						part->dump.s = "";
						part->dump.len = 0;
					} else len += part->dump.len;
				} else len += part->body.len;
				len += CRLF_LEN;
			} else  if (part->dump_f) {

				
				len += (part->body.s - msg->buf) - orig_offs;
				
				if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
					LM_ERR("failed to build part, inserting empty\n");
					part->dump.s = "";
					part->dump.len = 0;
				} else len += part->dump.len;
				len += CRLF_LEN;
				
			} else  {

				
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					
					len += lumps_len( msg, lump, send_sock, part->body.s+part->body.len-msg->buf);
				}
				
				size = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-orig_offs;
				len += size;
			}

			
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
		} 

		
		size = msg->len - orig_offs;
		len += size;

		
	}

	LM_DBG("resulting body len is %d\n",len);
	return len;
}


void reassemble_body_parts( struct sip_msg* msg, char* new_buf, unsigned int* new_offs, unsigned int* orig_offs, struct socket_info* send_sock)

{
	struct body_part *part;
	struct lump* lump;
	unsigned int size;
	unsigned int offset;
	int padding=0;

	if (msg->body->updated_part_count==0) {

		
		LM_DBG("no part to be added\n");

	} else if (msg->body->updated_part_count==1) {

		
		LM_DBG("only one part to be added\n");

		for( part=&msg->body->first ; part ; part=part->next)
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;

		if (part==NULL) {
			LM_BUG("updated count is 1, but no non-deleted part found :-/\n");
			return;
		}

		LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

		
		if ( msg->body->flags & SIP_BODY_RCV_MULTIPART && msg->body->part_count==1 && (part->flags & SIP_BODY_PART_FLAG_NEW)==0 ) {

			
			memcpy(new_buf+*new_offs, msg->body->body.s, part->body.s-msg->body->body.s );
			*new_offs += part->body.s-msg->body->body.s;
			padding = 1;
		}

		if (part->dump_f) {
			
			
			memcpy(new_buf+*new_offs, part->dump.s, part->dump.len );
			*new_offs += part->dump.len;
			pkg_free(part->dump.s);
			part->dump.s = NULL;
			part->dump.len = 0;
		} else {
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				
				memcpy(new_buf+*new_offs, part->body.s, part->body.len );
				*new_offs += part->body.len;
			} else {
				
				*orig_offs = part->body.s - msg->buf;
				lump = msg->body_lumps;
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					
					process_lumps( msg, lump, new_buf, new_offs, orig_offs, send_sock, part->body.s+part->body.len-msg->buf);
				}
				
				size = (part->body.s+part->body.len-msg->buf)-*orig_offs;
				memcpy(new_buf+*new_offs, msg->buf+*orig_offs, size);
				*new_offs += size;
			}
		}

		if (padding) {
			
			memcpy(new_buf+*new_offs, part->body.s+part->body.len, (msg->body->body.s+msg->body->body.len)- (part->body.s+part->body.len) );

			*new_offs += (msg->body->body.s+msg->body->body.len)- (part->body.s+part->body.len);
		}

	} else if (msg->body->part_count<2) {

		

		LM_DBG("transition from 0/1 parts to multi part body\n");
		offset = *new_offs;
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
					
					*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			
			memcpy(new_buf+offset, "--" OSS_BOUNDARY CRLF "Content-Type: ", 2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14);
			offset += 2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14;
			memcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);
			offset += part->mime_s.len;
			if (part->headers.len==0) {
				memcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);
				offset += CRLF_LEN + CRLF_LEN ;
			} else {
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
				memcpy(new_buf+offset, part->headers.s , part->headers.len);
				offset += part->headers.len ;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			}

			
			if (part->dump_f) {
				memcpy(new_buf+offset, part->dump.s, part->dump.len );
				offset += part->dump.len;
				pkg_free(part->dump.s);
				part->dump.s = NULL;
				part->dump.len = 0;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else  if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {

				
				memcpy(new_buf+offset, part->body.s, part->body.len );
				offset += part->body.len;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else  {

				
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					
					process_lumps( msg, lump, new_buf, &offset, orig_offs, send_sock, part->body.s+part->body.len-msg->buf);
				}
				
				size = (part->body.s+part->body.len-msg->buf)-*orig_offs;
				memcpy(new_buf+offset, msg->buf+*orig_offs, size);
				offset += size;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			}

			
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN ;

		} 

		
		memcpy(new_buf+offset, "--" OSS_BOUNDARY "--" CRLF, 2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN);
		offset += 2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN;

		
		*new_offs = offset;

	} else {

		
		LM_DBG("multi to multi part body reconstruction\n");

		offset = *new_offs;
		lump = msg->body_lumps;
		for( part=&msg->body->first ; part ; part=part->next) {
			
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )
					
					*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n", part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				
				memcpy(new_buf+offset, "--" , 2);
				offset += 2;
				memcpy(new_buf+offset, msg->body->boundary.s , msg->body->boundary.len);
				offset += msg->body->boundary.len;
				memcpy(new_buf+offset, CRLF "Content-Type: " , CRLF_LEN+14);
				offset += CRLF_LEN + 14 ;
				memcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);
				offset += part->mime_s.len;
				if (part->headers.len==0) {
					memcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);
					offset += CRLF_LEN + CRLF_LEN ;
				} else {
					memcpy(new_buf+offset, CRLF , CRLF_LEN);
					offset += CRLF_LEN;
					memcpy(new_buf+offset, part->headers.s , part->headers.len);
					offset += part->headers.len ;
					memcpy(new_buf+offset, CRLF , CRLF_LEN);
					offset += CRLF_LEN;
				}
				
				if (part->dump_f) {
					memcpy(new_buf+offset, part->dump.s, part->dump.len );
					offset += part->dump.len;
					part->dump.s = NULL;
					part->dump.len = 0;
				} else {
					memcpy(new_buf+offset, part->body.s, part->body.len );
					offset += part->body.len;
				}
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else  if (part->dump_f) {

				
				size = (part->body.s - msg->buf) - *orig_offs;
				memcpy( new_buf+offset,  msg->buf+*orig_offs, size);
				offset += size;
				
				memcpy(new_buf+offset, part->dump.s, part->dump.len );
				offset += part->dump.len;
				pkg_free(part->dump.s);
				part->dump.s = NULL;
				part->dump.len = 0;
				memcpy(new_buf+offset, CRLF , CRLF_LEN);
				offset += CRLF_LEN;
			} else  {

				
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					
					process_lumps( msg, lump, new_buf, &offset, orig_offs, send_sock, part->body.s+part->body.len-msg->buf);
				}
				
				size = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-*orig_offs;
				memcpy(new_buf+offset, msg->buf+*orig_offs, size);
				offset += size;
			}

			
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;

		} 

		
		size = msg->len - *orig_offs;
		memcpy(new_buf+offset, msg->buf+*orig_offs , size);
		*new_offs = offset + size;
		*orig_offs += size;

	}
	return;
}



static inline int calculate_body_diff(struct sip_msg *msg, struct socket_info *sock )
{
	if (msg->body==NULL) {
		
		return lumps_len(msg, msg->body_lumps, sock, -1);
	} else {
		return ((int)prep_reassemble_body_parts( msg, sock) - msg->body->body.len);
	}
}



static inline void apply_msg_changes(struct sip_msg *msg, char *new_buf, unsigned int *new_offs, unsigned int *orig_offs, struct socket_info *sock, unsigned int max_offset)


{
	unsigned int size;

	
	process_lumps(msg, msg->add_rm, new_buf, new_offs, orig_offs, sock, -1);
	if (msg->body==NULL) {
		
		process_lumps(msg, msg->body_lumps, new_buf, new_offs, orig_offs, sock, max_offset);
		
		memcpy(new_buf+*new_offs, msg->buf+*orig_offs, max_offset-*orig_offs);
		*new_offs += max_offset-*orig_offs;
	} else {
		
		size = (msg->body->part_count) ? ((msg->body->body.s - msg->buf) - *orig_offs)
			: (msg->len - *orig_offs);                      
		memcpy(new_buf+*new_offs, msg->buf+*orig_offs, size );
		*new_offs += size;
		*orig_offs += size;
		
		reassemble_body_parts(msg, new_buf, new_offs, orig_offs, sock);
	}
}



static inline int adjust_clen(struct sip_msg* msg, int body_delta, int proto)
{
	struct lump* anchor;
	char* clen_buf;
	int clen_len;

	

	clen_buf = 0;
	anchor=0;

	
	if (is_tcp_based_proto(proto)) {
		if (parse_headers(msg, HDR_CONTENTLENGTH_F, 0)==-1){
			LM_ERR("parsing content-length\n");
			goto error;
		}
		if (msg->content_length==0){
			
			
			anchor=anchor_lump(msg, msg->unparsed-msg->buf, HDR_CONTENTLENGTH_T);
			if (anchor==0){
				LM_ERR("cannot set clen anchor\n");
				goto error;
			}
		}
	}

	if ((anchor==0) && body_delta){
		if (parse_headers(msg, HDR_CONTENTLENGTH_F, 0) == -1) {
			LM_ERR("parsing Content-Length\n");
			goto error;
		}

		
		
		if (msg->content_length==0){
		    
			
			if (proto!=PROTO_UDP){
				anchor=anchor_lump(msg, msg->unparsed-msg->buf, HDR_CONTENTLENGTH_T);
				if (anchor==0){
					LM_ERR("cannot set clen anchor\n");
					goto error;
				}
			}else{
				LM_DBG("the UDP packet has no clen => not adding one \n");
			}
		}else{
			
			anchor = del_lump(	msg, msg->content_length->name.s - msg->buf, msg->content_length->len, HDR_CONTENTLENGTH_T);
			if (anchor==0) {
				LM_ERR("can't remove original Content-Length\n");
				goto error;
			}
		}
	}

	if (anchor){
		clen_buf = clen_builder(msg, &clen_len, body_delta);
		if (!clen_buf) goto error;
		if (insert_new_lump_after(anchor, clen_buf, clen_len, HDR_CONTENTLENGTH_T) == 0)
			goto error;
	}

	return 0;
error:
	if (clen_buf) pkg_free(clen_buf);
	return -1;
}





static inline int insert_path_as_route(struct sip_msg* msg, str* path)
{
	struct lump *anchor;
	char *route;
	struct hdr_field *hf, *last_via=0;

	for (hf = msg->headers; hf; hf = hf->next) {
		if (hf->type == HDR_ROUTE_T) {
			break;
		} else if (hf->type == HDR_VIA_T) {
			last_via = hf;
		}
	}
	if (hf) {
		
		anchor = anchor_lump(msg, hf->name.s - msg->buf, 0);
	} else if(last_via) {
		if (last_via->next) {
			
			anchor = anchor_lump(msg, last_via->next->name.s - msg->buf, 0);
		} else {
			
			anchor = anchor_lump(msg, msg->unparsed - msg->buf, 0);
		}
	} else {
		
		anchor = anchor_lump(msg, msg->headers->name.s - msg->buf, 0);
	}

	if (anchor == 0) {
		LM_ERR("failed to get anchor\n");
		return -1;
	}

	route = pkg_malloc(ROUTE_LEN + path->len + CRLF_LEN);
	if (!route) {
		LM_ERR("out of pkg memory\n");
		return -1;
	}
	memcpy(route, ROUTE_STR, ROUTE_LEN);
	memcpy(route + ROUTE_LEN, path->s, path->len);
	memcpy(route + ROUTE_LEN + path->len, CRLF, CRLF_LEN);

	if (insert_new_lump_before(anchor, route, ROUTE_LEN + path->len + CRLF_LEN, 0) == 0) {
		LM_ERR("failed to insert lump\n");
		return -1;
	}

	return 0;
}

int is_del_via1_lump(struct sip_msg* msg)
{
	struct lump* lump;
	int via1_off, via1_len;


	if(!msg->h_via1)
		return 0;

	via1_off = msg->h_via1->name.s - msg->buf;
	via1_len = msg->h_via1->len;

	for(lump= msg->add_rm; lump; lump= lump->next)
	{
		if(lump->type == 0 && lump->op== LUMP_DEL && lump->u.offset == via1_off && lump->len == via1_len)
			return 1;
	}
	return 0;
}

char * build_req_buf_from_sip_req( struct sip_msg* msg, unsigned int *returned_len, struct socket_info* send_sock, int proto, str *via_params, unsigned int flags)


{
	unsigned int len, new_len, received_len, rport_len, uri_len, via_len, body_delta;
	char *line_buf, *received_buf, *rport_buf, *new_buf, *buf, *id_buf;
	unsigned int offset, s_offset, size, id_len;
	struct lump *anchor, *via_insert_param;
	str branch, extra_params, body;
	struct hostport hp;

	id_buf=0;
	id_len=0;
	via_insert_param=0;
	extra_params.len=0;
	extra_params.s=0;
	uri_len=0;
	buf=msg->buf;
	len=msg->len;
	received_len=0;
	rport_len=0;
	new_buf=0;
	received_buf=0;
	rport_buf=0;
	line_buf=0;
	int via1_deleted = 0;

	if (msg->path_vec.len) {
		if (insert_path_as_route(msg, &msg->path_vec) < 0) {
			LM_ERR("adding path lumps failed\n");
			goto error;
		}
	}

	
	body_delta = calculate_body_diff( msg, send_sock);
	if (adjust_clen(msg, body_delta, proto) < 0) {
		LM_ERR("failed to adjust Content-Length\n");
		goto error;
	}

	if (flags&MSG_TRANS_NOVIA_FLAG)
		goto build_msg;

	
	if (is_tcp_based_proto(msg->rcv.proto)) {
		if  ((id_buf=id_builder(msg, &id_len))==0){
			LM_ERR("id_builder failed\n");
			goto error; 
		}
		LM_DBG("id added: <%.*s>, rcv proto=%d\n", (int)id_len, id_buf, msg->rcv.proto);
		
		if (via_params && via_params->len != 0) {
			extra_params.len = id_len + via_params->len;
			extra_params.s=pkg_malloc(extra_params.len);
			if(extra_params.s==0) {
				LM_ERR("extra params building failed\n");
				pkg_free(id_buf);
				goto error;
			}
			memcpy(extra_params.s, via_params->s, via_params->len);
			memcpy(extra_params.s + via_params->len, id_buf, id_len);
		} else {
			extra_params.s=id_buf;
			extra_params.len=id_len;
		}
	}

	
	if(msg->msg_flags&FL_FORCE_LOCAL_RPORT) {
		id_buf=extra_params.s;
		id_len=extra_params.len;
		if (via_params && !extra_params.len) {
			
			extra_params.len = via_params->len;
			
		}
		extra_params.len += RPORT_LEN-1; 
		extra_params.s = (char*)pkg_malloc(extra_params.len+1);
		if(extra_params.s==0) {
			LM_ERR("extra params building failed\n");
			if (id_buf) pkg_free(id_buf);
			goto error;
		}

		if(id_buf!=0) {
			memcpy(extra_params.s, id_buf, id_len);
			pkg_free(id_buf);
		} else if (via_params)
			memcpy(extra_params.s, via_params->s, via_params->len);
		memcpy(extra_params.s+id_len, RPORT, RPORT_LEN-1);
		extra_params.s[extra_params.len]='\0';
		LM_DBG("extra param added: <%.*s>\n",extra_params.len, extra_params.s);
	}

	branch.s=msg->add_to_branch_s;
	branch.len=msg->add_to_branch_len;
	set_hostport(&hp, msg);
	line_buf = via_builder( &via_len, send_sock, &branch, extra_params.len?&extra_params:via_params, proto, &hp);
	if (!line_buf){
		LM_ERR("no via received!\n");
		goto error00;
	}

	via1_deleted = is_del_via1_lump(msg);
	
	if ( (msg->via1->rport || (msg->msg_flags&FL_FORCE_RPORT) || received_test(msg) ) && !via1_deleted) {
		if ((received_buf=received_builder(msg,&received_len))==0){
			LM_ERR("received_builder failed\n");
			goto error01;  
		}
	}

	
	if (((msg->msg_flags&FL_FORCE_RPORT)|| (msg->via1->rport )) && !via1_deleted){
		if ((rport_buf=rport_builder(msg, &rport_len))==0){
			LM_ERR("rport_builder failed\n");
			goto error01; 
		}
	}

	
	
	
	anchor=anchor_lump(msg, msg->via1->hdr.s-buf, HDR_VIA_T);
	if (anchor==0) goto error01;
	if (insert_new_lump_before(anchor, line_buf, via_len, HDR_VIA_T)==0)
		goto error01;
	
	if (msg->via1->params.s){
			size= msg->via1->params.s-msg->via1->hdr.s-1; 
	}else{
			size= msg->via1->host.s-msg->via1->hdr.s+msg->via1->host.len;
			if (msg->via1->port!=0){
				
				size += msg->via1->port_str.len + 1; 
			}
	}
	
	if (received_len){
		if (msg->via1->received){ 
			via_insert_param=del_lump(msg, msg->via1->received->start-buf-1, msg->via1->received->size+1,  HDR_VIA_T);

		}else if (via_insert_param==0){ 
			via_insert_param=anchor_lump(msg, msg->via1->hdr.s-buf+size, HDR_VIA_T);
		}
		if (via_insert_param==0) goto error02; 
		if (insert_new_lump_after(via_insert_param, received_buf, received_len, HDR_VIA_T) ==0 ) goto error02;
	}
	
	if (rport_len){
		if (msg->via1->rport){ 
			via_insert_param=del_lump(msg, msg->via1->rport->start-buf-1, msg->via1->rport->size+1 , HDR_VIA_T);

		}else if (via_insert_param==0){ 
			
			via_insert_param=anchor_lump(msg, msg->via1->hdr.s-buf+size, HDR_VIA_T);
		}
		if (via_insert_param==0) goto error03; 
		if (insert_new_lump_after(via_insert_param, rport_buf, rport_len, HDR_VIA_T) ==0 )
			goto error03; 
	}

build_msg:
	
	if (get_body(msg, &body) == 0 && body.len)
		len -= (msg->buf + msg->len - body.s - body.len);

	
	new_len=len+body_delta+lumps_len(msg, msg->add_rm, send_sock,-1);

	LM_DBG("new_len(%d)=len(%d)+lumps_len\n", new_len, len);


	if (msg->new_uri.s){
		uri_len=msg->new_uri.len;
		new_len=new_len-msg->first_line.u.request.uri.len+uri_len;
	}
	if (flags&MSG_TRANS_SHM_FLAG)
		new_buf=(char*)shm_malloc(new_len+1);
	else new_buf=(char*)pkg_malloc(new_len+1);
	if (new_buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		goto error00;
	}

	offset=s_offset=0;
	if (msg->new_uri.s){
		
		size=msg->first_line.u.request.uri.s-buf;
		memcpy(new_buf, buf, size);
		offset+=size;
		s_offset+=size;
		
		memcpy(new_buf+offset, msg->new_uri.s, uri_len);
		offset+=uri_len;
		s_offset+=msg->first_line.u.request.uri.len; 
	}

	
	apply_msg_changes( msg, new_buf, &offset, &s_offset, send_sock, len);
	if (offset!=new_len) {
		LM_BUG("len mismatch : calculated %d, written %d\n", new_len, offset);
		abort();
	}

	new_buf[new_len]=0;

	*returned_len=new_len;
	
	if (extra_params.s) pkg_free(extra_params.s);
	return new_buf;

error01:
	if (line_buf) pkg_free(line_buf);
error02:
	if (received_buf) pkg_free(received_buf);
error03:
	if (rport_buf) pkg_free(rport_buf);
error00:
	if (extra_params.s) pkg_free(extra_params.s);
error:
	*returned_len=0;
	return 0;
}



char * build_res_buf_from_sip_res( struct sip_msg* msg, unsigned int *returned_len, struct socket_info *sock,int flags)
{
	unsigned int new_len, body_delta, len;
	char *new_buf, *buf;
	unsigned int offset, s_offset;
	str body;

	buf=msg->buf;
	len=msg->len;
	new_buf=0;

	
	body_delta = calculate_body_diff( msg, sock);
	if (adjust_clen(msg, body_delta, (msg->via2? msg->via2->proto:PROTO_UDP))
			< 0) {
		LM_ERR("failed to adjust Content-Length\n");
		goto error;
	}

	
	if (!(flags & MSG_TRANS_NOVIA_FLAG)) {
		unsigned int via_len, via_offset;

		if (msg->via1->next) {
			via_len = msg->via1->bsize;
			via_offset = msg->h_via1->body.s-buf;
		} else {
			via_len = msg->h_via1->len;
			via_offset = msg->h_via1->name.s-buf;
		}

		if (del_lump(msg, via_offset, via_len, HDR_VIA_T) == 0) {
			LM_ERR("failed to remove first via\n");
			goto error;
		}
	}

	
	if (get_body(msg, &body) == 0 && body.len)
		len -= (msg->buf + msg->len - body.s - body.len);
	new_len=len+body_delta+lumps_len(msg, msg->add_rm, sock, -1);

	LM_DBG(" old size: %d, new size: %d\n", len, new_len);
	new_buf=(char*)pkg_malloc(new_len+1); 
	if (new_buf==0){
		LM_ERR("out of pkg mem\n");
		goto error;
	}
	offset=s_offset=0;

	
	apply_msg_changes( msg, new_buf, &offset, &s_offset, sock, len);
	if (offset!=new_len) {
		LM_BUG("len mismatch : calculated %d, written %d\n", new_len, offset);
		abort();
	}

	new_buf[new_len]=0; 

	
	if ( !disable_503_translation && msg->first_line.u.reply.statuscode==503 )
		new_buf[(int)(msg->first_line.u.reply.status.s-msg->buf)+2] = '0';
	
	LM_DBG("copied size: orig:%d, new: %d, rest: %d" " msg=\n%s\n", s_offset, offset, len-s_offset, new_buf);

	*returned_len=new_len;
	return new_buf;
error:
	*returned_len=0;
	return 0;
}


char * build_res_buf_from_sip_req( unsigned int code, const str *text ,str *new_tag, struct sip_msg* msg, unsigned int *returned_len, struct bookmark *bmark)
{
	char *buf, *p, *received_buf, *rport_buf, *warning_buf;
	char *content_len_buf, *after_body, *totags;
	unsigned int len, foo, received_len, rport_len;
	unsigned int warning_len, content_len_len;
	struct hdr_field *hdr;
	struct lump_rpl *lump, *body;
	int i;
	str to_tag;

	body = 0;
	buf=0;
	to_tag.s = 0;
	to_tag.len = 0;
	received_buf=rport_buf=warning_buf=content_len_buf=0;
	received_len=rport_len=warning_len=content_len_len=0;

	
	if (parse_headers( msg, HDR_EOH_F, 0 )==-1) {
		LM_ERR("parse_headers failed\n");
		goto error00;
	}

	
	len = 0;

	
	if ( (msg->msg_flags&FL_FORCE_RPORT)|| (msg->via1->rport )){
		if ((rport_buf=rport_builder(msg, &rport_len))==0){
			LM_ERR("rport_builder failed\n");
			goto error00;
		}
		if (msg->via1->rport)
			len -= msg->via1->rport->size+1; 
	}

	
	if (rport_buf || received_test(msg)) {
		if ((received_buf=received_builder(msg,&received_len))==0) {
			LM_ERR("received_builder failed\n");
			goto error01;
		}
	}

	
	len += SIP_VERSION_LEN + 1 + 3 + 1 + text->len + CRLF_LEN;
	
	for ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {
		switch (hdr->type) {
			case HDR_TO_T:
				if (new_tag && new_tag->len) {
					to_tag=get_to(msg)->tag_value;
					if (to_tag.len )
						len+=new_tag->len-to_tag.len;
					else len+=new_tag->len+TOTAG_TOKEN_LEN;
				}
				len += hdr->len;
				break;
			case HDR_VIA_T:
				
				len+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;
				if (hdr==msg->h_via1) len += received_len+rport_len;
				break;
			case HDR_RECORDROUTE_T:
				
				if (code<180 || code>=300)
					break;
			case HDR_FROM_T:
			case HDR_CALLID_T:
			case HDR_CSEQ_T:
				
				len += hdr->len;
				break;
			default:
				
				;
		}
	}
	
	for(lump=msg->reply_lump;lump;lump=lump->next) {
		len += lump->text.len;
		if (lump->flags&LUMP_RPL_BODY)
			body = lump;
	}
	
	if (server_signature)
		len += server_header->len + CRLF_LEN;
	
	if (sip_warning) {
		warning_buf = warning_builder(msg,&warning_len);
		if (warning_buf) len += warning_len + CRLF_LEN;
		else LM_WARN("warning skipped -- too big\n");
	}
	
	if (body) {
		content_len_buf = int2str(body->text.len, (int*)&content_len_len);
		len += CONTENT_LENGTH_LEN + content_len_len + CRLF_LEN;
	} else {
		len += CONTENT_LENGTH_LEN + 1 + CRLF_LEN;
	}
	
	len += CRLF_LEN; 

	
	buf = (char*) pkg_malloc( len+1 );
	if (!buf)
	{
		LM_ERR("out of pkg memory; needs %d\n",len);
		goto error01;
	}

	
	p=buf;
	
	memcpy( p , SIP_VERSION , SIP_VERSION_LEN );
	p += SIP_VERSION_LEN;
	*(p++) = ' ' ;
	
	for ( i=2 , foo = code  ;  i>=0  ;  i-- , foo=foo/10 )
		*(p+i) = '0' + foo - ( foo/10 )*10;
	p += 3;
	*(p++) = ' ' ;
	memcpy( p , text->s , text->len );
	p += text->len;
	memcpy( p, CRLF, CRLF_LEN );
	p+=CRLF_LEN;
	
	for ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {
		switch (hdr->type)
		{
			case HDR_VIA_T:
				if (hdr==msg->h_via1){
					i = 0;
					if (received_buf) {
						i = msg->via1->host.s - msg->via1->hdr.s + msg->via1->host.len + (msg->via1->port? msg->via1->port_str.len + 1 : 0);

						
						append_str( p, hdr->name.s, i);
						
						append_str( p, received_buf, received_len);
					}
					if (rport_buf){
						if (msg->via1->rport){ 
							
							append_str_trans( p, hdr->name.s+i , msg->via1->rport->start-hdr->name.s-1-i,msg);
							
							append_str(p, rport_buf, rport_len);
							
							append_str_trans(p, msg->via1->rport->start+ msg->via1->rport->size, hdr->body.s+hdr->body.len- msg->via1->rport->start- msg->via1->rport->size, msg);



						}else{ 
							append_str(p, rport_buf, rport_len);
							append_str_trans( p, hdr->name.s+i , (hdr->body.s+hdr->body.len)-hdr->name.s-i,msg);
						}
					}else{
						
						append_str_trans( p, hdr->name.s+i , (hdr->body.s+hdr->body.len)-hdr->name.s-i, msg);
					}
				}else{
					
					append_str_trans( p, hdr->name.s, (hdr->body.s+hdr->body.len)-hdr->name.s, msg);
				}
				append_str( p, CRLF,CRLF_LEN);
				break;
			case HDR_RECORDROUTE_T:
				
				if (code<180 || code>=300) break;
				append_str(p, hdr->name.s, hdr->len);
				break;
			case HDR_TO_T:
				if (new_tag && new_tag->len){
					if (to_tag.len ) { 
						
						append_str( p, hdr->name.s, to_tag.s-hdr->name.s);
						
						bmark->to_tag_val.s=p;
						bmark->to_tag_val.len=new_tag->len;
						append_str( p, new_tag->s,new_tag->len);
						
						append_str( p, to_tag.s+to_tag.len, hdr->name.s+hdr->len-(to_tag.s+to_tag.len));
					}else{ 
						after_body=hdr->body.s+hdr->body.len;
						append_str( p, hdr->name.s, after_body-hdr->name.s);
						append_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);
						bmark->to_tag_val.s=p;
						bmark->to_tag_val.len=new_tag->len;
						append_str( p, new_tag->s,new_tag->len);
						append_str( p, after_body, hdr->name.s+hdr->len-after_body);
					}
					break;
				} 
				totags=((struct to_body*)(hdr->parsed))->tag_value.s;
				if (totags) {
					bmark->to_tag_val.s=p+(totags-hdr->name.s);
					bmark->to_tag_val.len= ((struct to_body*)(hdr->parsed))->tag_value.len;
				} else {
					bmark->to_tag_val.s = NULL;
					bmark->to_tag_val.len = 0;
				}
			case HDR_FROM_T:
			case HDR_CALLID_T:
			case HDR_CSEQ_T:
					append_str(p, hdr->name.s, hdr->len);
					break;
			default:
				
				;
		} 
	} 
	
	for(lump=msg->reply_lump;lump;lump=lump->next)
		if (lump->flags&LUMP_RPL_HDR){
			memcpy(p,lump->text.s,lump->text.len);
			p += lump->text.len;
		}
	
	if (server_signature) {
		append_str( p, server_header->s, server_header->len);
		append_str( p, CRLF, CRLF_LEN );
	}
	
	if (content_len_len) {
		append_str( p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);
		append_str( p, content_len_buf, content_len_len );
		append_str( p, CRLF, CRLF_LEN );
	} else {
		append_str( p, CONTENT_LENGTH"0"CRLF,CONTENT_LENGTH_LEN+1+CRLF_LEN);
	}
	
	if (warning_buf) {
		append_str( p, warning_buf, warning_len );
		append_str( p, CRLF, CRLF_LEN );
	}
	
	memcpy( p, CRLF, CRLF_LEN );
	p+=CRLF_LEN;
	
	if (body) {
		append_str( p, body->text.s, body->text.len );
	}

	if (len!=(unsigned long)(p-buf))
		LM_CRIT("diff len=%d p-buf=%d\n", len, (int)(p-buf));

	*(p) = 0;
	*returned_len = len;
	
	if (received_buf) pkg_free(received_buf);
	if (rport_buf) pkg_free(rport_buf);
	return buf;

error01:
	if (received_buf) pkg_free(received_buf);
	if (rport_buf) pkg_free(rport_buf);
error00:
	*returned_len=0;
	return 0;
}




int branch_builder( unsigned int hash_index,  unsigned int label, char * char_v, int branch, char *branch_str, int *len )



{

	char *begin;
	int size;

	
	size=MAX_BRANCH_PARAM_LEN;
	begin=branch_str;
	*len=0;

	memcpy(begin, MCOOKIE, MCOOKIE_LEN );
	size-=MCOOKIE_LEN;begin+=MCOOKIE_LEN;

	if (int2reverse_hex( &begin, &size, hash_index)==-1)
		return 0;

	if (size) {
		*begin=BRANCH_SEPARATOR;
		begin++; size--;
	} else return 0;

	
	if (char_v) {
		if (memcpy(begin,char_v,MD5_LEN)) {
			begin+=MD5_LEN; size-=MD5_LEN;
		} else return 0;
	} else { 
		if (int2reverse_hex( &begin, &size, label )==-1)
			return 0;
	}

	if (size) {
		*begin=BRANCH_SEPARATOR;
		begin++; size--;
	} else return 0;

	if (int2reverse_hex( &begin, &size, branch)==-1)
		return 0;

	*len=MAX_BRANCH_PARAM_LEN-size;
	return size;

}


char* via_builder( unsigned int *len, struct socket_info* send_sock, str* branch, str* extra_params, int proto, struct hostport* hp)

{
	unsigned int via_len, extra_len;
	char *line_buf;
	int max_len, local_via_len=MY_VIA_LEN;
	str* address_str; 
	str* port_str; 

	
	if (hp && hp->host && hp->host->len)
		address_str=hp->host;
	else address_str=get_adv_host(send_sock);

	if (hp && hp->port && hp->port->len)
		port_str=hp->port;
	else port_str=get_adv_port(send_sock);

	max_len=local_via_len+address_str->len  +2 +1 +port_str->len +(branch?(MY_BRANCH_LEN+branch->len):0)


		+(extra_params?extra_params->len:0)
		+CRLF_LEN+1;
	line_buf=pkg_malloc( max_len );
	if (line_buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		return 0;
	}

	extra_len=0;

	memcpy(line_buf, MY_VIA, local_via_len);
	if (proto==PROTO_UDP){
		
	}else if (proto==PROTO_TCP){
		memcpy(line_buf+local_via_len-4, "TCP ", 4);
	}else if (proto==PROTO_TLS){
		memcpy(line_buf+local_via_len-4, "TLS ", 4);
	}else if(proto==PROTO_SCTP){
		memcpy(line_buf+local_via_len-4, "SCTP ", 5);
		local_via_len++;
	}else if(proto==PROTO_WS){
		memcpy(line_buf+local_via_len-4, "WS ", 3);
		local_via_len--;
	}else if(proto==PROTO_WSS){
		memcpy(line_buf+local_via_len-4, "WSS ", 4);
	}else{
		LM_CRIT("unknown proto %d\n", proto);
		return 0;
	}

	via_len=local_via_len+address_str->len; 

	memcpy(line_buf+local_via_len+extra_len, address_str->s, address_str->len);
	line_buf[via_len]=':'; via_len++;
	memcpy(line_buf+via_len, port_str->s, port_str->len);
	via_len+=port_str->len;

	
	if (branch){
		memcpy(line_buf+via_len, MY_BRANCH, MY_BRANCH_LEN );
		via_len+=MY_BRANCH_LEN;
		memcpy(line_buf+via_len, branch->s, branch->len );
		via_len+=branch->len;
	}
	
	if (extra_params){
		memcpy(line_buf+via_len, extra_params->s, extra_params->len);
		via_len+=extra_params->len;
	}

	memcpy(line_buf+via_len, CRLF, CRLF_LEN);
	via_len+=CRLF_LEN;
	line_buf[via_len]=0; 

	*len = via_len;
	return line_buf;
}


static char uri_buff[MAX_URI_LEN];
char *construct_uri(str *protocol,str *username,str *domain,str *port, str *params,int *len)
{
	int pos = 0;

	if (!len)
	{
		LM_ERR("null pointer provided for construct_uri \n");
		return 0;
	}

	if (!protocol->s || protocol->len == 0)
	{
		LM_ERR("no protocol specified\n");
		return 0;
	}

	if (!domain->s || domain->len == 0)
	{
		LM_ERR("no domain specified\n");
		return 0;
	}

	memcpy(uri_buff,protocol->s,protocol->len);
	pos += protocol->len;
	uri_buff[pos++] = ':';

	if (username && username->s && username->len != 0)
	{
		memcpy(uri_buff+pos,username->s,username->len);
		pos += username->len;
		uri_buff[pos++] = '@';
	}

	memcpy(uri_buff+pos,domain->s,domain->len);
	pos += domain->len;

	if (port && port->s && port->len !=0)
	{
		uri_buff[pos++] = ':';
		memcpy(uri_buff+pos,port->s,port->len);
		pos += port->len;
	}

	if (params && params->s && params->len !=0 )
	{
		uri_buff[pos++] = ';';
		memcpy(uri_buff+pos,params->s,params->len);
		pos += params->len;
	}

	uri_buff[pos] = 0;
	*len = pos;
	return uri_buff;
}


char *contact_builder(struct socket_info* send_sock, int *ct_len)
{
	char *p;
	int proto_len = 0;
	str* address_str = get_adv_host(send_sock);
	str* port_str = get_adv_port(send_sock);

	
	p = uri_buff;
	memcpy(p, "sip:", 4);
	p += 4;

	
	memcpy(p, address_str->s, address_str->len);
	p += address_str->len;

	
	*p++ = ':';
	memcpy(p, port_str->s, port_str->len);
	p += port_str->len;

	
	if (send_sock->proto != PROTO_UDP) {
		memcpy(p, ";transport=", 11);
		p += 11;
		proto_len = strlen(protos[send_sock->proto].name);
		memcpy(p, protos[send_sock->proto].name, proto_len);
		p += proto_len;
	}

	*p = '\0';

	if (ct_len)
		*ct_len = p - uri_buff;

	return uri_buff;
}
