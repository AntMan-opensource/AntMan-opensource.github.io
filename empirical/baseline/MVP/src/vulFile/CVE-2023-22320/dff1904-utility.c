












const char *am_strerror(int err) {
    switch (err) {
            AM_ERRNO_MAP(AM_STRERROR_GEN)
        default:
            return "unknown system error";
    }
}


const char *request_method_str[] = {
    "UNKNOWN", "GET", "POST", "HEAD", "PUT", "DELETE", "TRACE", "OPTIONS", "CONNECT", "COPY", "INVALID", "LOCK", "UNLOCK", "MKCOL", "MOVE", "PATCH", "PROPFIND", "PROPPATCH", "VERSION_CONTROL", "CHECKOUT", "UNCHECKOUT", "CHECKIN", "UPDATE", "LABEL", "REPORT", "MKWORKSPACE", "MKACTIVITY", "BASELINE_CONTROL", "MERGE", "CONFIG", "ENABLE-APP", "DISABLE-APP", "STOP-APP", "STOP-APP-RSP", "REMOVE-APP", "STATUS", "STATUS-RSP", "INFO", "INFO-RSP", "DUMP", "DUMP-RSP", "PING", "PING-RSP" };























































struct query_attribute {
    char *key;
    char *key_value;
};

enum {
    AM_TIMER_INACTIVE = 0, AM_TIMER_ACTIVE = 1 << 0, AM_TIMER_PAUSED = 1 << 1 };







struct dirent {
    long d_ino;
    off_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[AM_URI_SIZE + 1];
};

typedef struct {
    intptr_t handle;
    short offset;
    short finished;
    struct _finddata_t fileinfo;
    char *dir;
    struct dirent dent;
} DIR;



static am_timer_t am_timer_s = {0, 0, 0, 0};

static const char *hex_chars = "0123456789ABCDEF";

static const unsigned char base64_table[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static struct http_status http_status_list[] = {

    {HTTP_STATUS_CODE(100), "Continue", {HTTP_STATUS_CODE(101), "Switching Protocols", {HTTP_STATUS_CODE(102), "Processing", {HTTP_STATUS_CODE(200), "OK", {HTTP_STATUS_CODE(201), "Created", {HTTP_STATUS_CODE(202), "Accepted", {HTTP_STATUS_CODE(203), "Non-Authoritative Information", {HTTP_STATUS_CODE(204), "No Content", {HTTP_STATUS_CODE(205), "Reset Content", {HTTP_STATUS_CODE(206), "Partial Content", {HTTP_STATUS_CODE(207), "Multi-Status", {HTTP_STATUS_CODE(300), "Multiple Choices", {HTTP_STATUS_CODE(301), "Moved Permanently", {HTTP_STATUS_CODE(302), "Found", {HTTP_STATUS_CODE(303), "See Other", {HTTP_STATUS_CODE(304), "Not Modified", {HTTP_STATUS_CODE(305), "Use Proxy", {HTTP_STATUS_CODE(307), "Temporary Redirect", {HTTP_STATUS_CODE(400), "Bad Request", {HTTP_STATUS_CODE(401), "Unauthorized", {HTTP_STATUS_CODE(402), "Payment Required", {HTTP_STATUS_CODE(403), "Forbidden", {HTTP_STATUS_CODE(404), "Not Found", {HTTP_STATUS_CODE(405), "Method Not Allowed", {HTTP_STATUS_CODE(406), "Not Acceptable", {HTTP_STATUS_CODE(407), "Proxy Authentication Required", {HTTP_STATUS_CODE(408), "Request Time-out", {HTTP_STATUS_CODE(409), "Conflict", {HTTP_STATUS_CODE(410), "Gone", {HTTP_STATUS_CODE(411), "Length Required", {HTTP_STATUS_CODE(412), "Precondition Failed", {HTTP_STATUS_CODE(413), "Request Entity Too Large", {HTTP_STATUS_CODE(414), "Request-URI Too Large", {HTTP_STATUS_CODE(415), "Unsupported Media Type", {HTTP_STATUS_CODE(416), "Requested range not satisfiable", {HTTP_STATUS_CODE(417), "Expectation Failed", {HTTP_STATUS_CODE(422), "Unprocessable Entity", {HTTP_STATUS_CODE(423), "Locked", {HTTP_STATUS_CODE(424), "Failed Dependency", {HTTP_STATUS_CODE(426), "Upgrade Required", {HTTP_STATUS_CODE(500), "Internal Server Error", {HTTP_STATUS_CODE(501), "Not Implemented", {HTTP_STATUS_CODE(502), "Bad Gateway", {HTTP_STATUS_CODE(503), "Service Unavailable", {HTTP_STATUS_CODE(504), "Gateway Time-out", {HTTP_STATUS_CODE(505), "HTTP Version not supported", {HTTP_STATUS_CODE(506), "Variant Also Negotiates", {HTTP_STATUS_CODE(507), "Insufficient Storage", {HTTP_STATUS_CODE(510), "HTTP Version not supported"  };


















































am_bool_t is_http_status(int status) {
    int i;
    for (i = 0; i < ARRAY_SIZE(http_status_list); i++) {
        struct http_status *s = &http_status_list[i];
        if (s->code == status)
            return AM_TRUE;
    }
    return AM_FALSE;
}

struct http_status *get_http_status(int status) {
    int i;
    for (i = 0; i < ARRAY_SIZE(http_status_list); i++) {
        struct http_status *s = &http_status_list[i];
        if (s->code == status)
            return s;
    }
    return &http_status_list[40]; 
}

void am_free(void *ptr) {
    if (ptr != NULL) {
        free(ptr);
    }
}

void am_secure_zero_memory(void *v, size_t sz) {

    SecureZeroMemory(v, sz);

    size_t n = sz;
    volatile unsigned char *p = v;
    while (n--) *p++ = 0;

}

char is_big_endian() {

    union {
        uint32_t i;
        char c[4];
    } b = {0x01020304};

    return b.c[0] == 1;
}


am_return_t match(unsigned long instance_id, const char *subject, const char *pattern) {
    pcre* x = NULL;
    const char* error;
    int erroroffset, rc = -1;
    int offsets[3];
    am_return_t result = AM_OK;

    if (subject == NULL || pattern == NULL) {
        return result;
    }
    x = pcre_compile(pattern, 0, &error, &erroroffset, NULL);
    if (x == NULL) {
        AM_LOG_DEBUG(instance_id, "match: pcre_compile failed on \"%s\" with error %s", pattern, (error == NULL) ? "unknown" : error);
        return AM_FAIL;
    }

    rc = pcre_exec(x, NULL, subject, (int) strlen(subject), 0, 0, offsets, 3);
    if (rc < 0) {
        AM_LOG_DEBUG(instance_id, "match(): '%s' does not match '%s'", subject, pattern);
        result = AM_FAIL;
    } else {
        AM_LOG_DEBUG(instance_id, "match(): '%s' matches '%s'", subject, pattern);
    }
    pcre_free(x);

    return result;
}


char *match_group(pcre *x, int capture_groups, const char *subject, size_t *len) {

    
    int max_capture_groups = (capture_groups + 1) * 3;
    size_t k = 0, slen = *len;
    int i, substring_len, rc, ret_len = 0;
    unsigned int offset = 0;
    char* result = NULL;
    int* ovector;

    if (x == NULL || subject == NULL) {
        return NULL;
    }
    if ((ovector = calloc(max_capture_groups, sizeof (int))) == NULL) {
        return NULL;
    }
    while (offset < slen && (rc = pcre_exec(x, 0, subject, (int) slen, offset, 0, ovector, max_capture_groups)) >= 0) {
        for (i = 1 ;
                i < rc; ++i) {
            char *rslt, *ret_tmp;
            if ((substring_len = pcre_get_substring(subject, ovector, rc, i, (const char **) &rslt)) > 0) {
                ret_tmp = realloc(result, ret_len + substring_len + 1);
                if (ret_tmp == NULL) {
                    am_free(result);
                    pcre_free_substring(rslt);
                    free(ovector);
                    return NULL;
                }
                result = ret_tmp;

                
                memcpy(result + ret_len, rslt, substring_len);
                result[ret_len + substring_len] = '\0';
                ret_len += substring_len + 1;
                k++;
            }
            pcre_free_substring(rslt);
        }
        offset = ovector[1];
    }
    *len = k;
    free(ovector);
    return result;
}

static void uri_normalize(struct url *url, char *path) {

    char *s, *o, *p = path != NULL ? strdup(path) : NULL;
    int i, m = 0, list_sz = 0;
    char **segment_list = NULL, **segment_list_norm = NULL, **tmp;
    char u[AM_URI_SIZE + 1];

    if (p == NULL) {
        if (url != NULL) {
            url->error = path != NULL ? AM_ENOMEM : AM_EINVAL;
        }
        return;
    }
    o = p; 

    
    while ((s = am_strsep(&p, "/")) != NULL) {
        if (strcmp(s, ".") == 0) {
            continue; 
        }
        tmp = (char **) realloc(segment_list, sizeof (char *) * (++list_sz));
        if (tmp == NULL) {
            AM_FREE(o, segment_list);
            url->error = AM_ENOMEM;
            return;
        }
        segment_list = tmp;
        segment_list[list_sz - 1] = s;
    }
    if (list_sz == 0) {
        
        AM_FREE(o, segment_list);
        if (url != NULL) {
            url->error = AM_SUCCESS;
        }
        return;
    }

    
    segment_list_norm = (char **) calloc(list_sz, sizeof (char *));
    if (segment_list_norm == NULL) {
        AM_FREE(o, segment_list);
        if (url != NULL) {
            url->error = AM_ENOMEM;
        }
        return;
    }

    for (i = 0; i < list_sz; i++) {
        if (strcmp(segment_list[i], "..") == 0) {
            
            if (m-- <= 1) {
                m = 1;
                continue;
            }
            segment_list_norm[m] = NULL;
        } else {
            segment_list_norm[m++] = segment_list[i];
        }
    }

    memset(&u[0], 0, sizeof (u));
    
    for (i = 0; i < list_sz; i++) {
        if (segment_list_norm[i] == NULL) {
            break;
        }
        if (i == 0) {
            strncpy(u, segment_list_norm[i], sizeof (u) - 1);
            if ((i + 1) < list_sz && segment_list_norm[i + 1] != NULL) {
                strncat(u, "/", sizeof (u) - 1);
            }
        } else {
            strncat(u, segment_list_norm[i], sizeof (u) - 1);
            if ((i + 1) < list_sz && segment_list_norm[i + 1] != NULL) {
                strncat(u, "/", sizeof (u) - 1);
            }
        }
    }
    memcpy(path, u, sizeof (u));

    AM_FREE(segment_list_norm, segment_list, o);

    if (url != NULL) {
        url->error = AM_SUCCESS;
    }
}

static int query_attribute_compare(const void *a, const void *b) {
    int status;
    struct query_attribute *ia = (struct query_attribute *) a;
    struct query_attribute *ib = (struct query_attribute *) b;
    status = strcmp(ia->key, ib->key);
    if (status == 0) {
        
        status = strcmp(ia->key_value, ib->key_value);
    }
    return status;
}


int parse_url(const char *u, struct url *url) {
    int i = 0, port = 0, last = 0;
    char *d, *p, uri[AM_URI_SIZE + 1];

    if (url == NULL) {
        return AM_ERROR;
    }
    if (u == NULL) {
        url->error = AM_EINVAL;
        return AM_ERROR;
    }
    if (strlen(u) > (AM_PROTO_SIZE + AM_HOST_SIZE + 6 + AM_URI_SIZE )) {
        url->error = AM_E2BIG;
        return AM_ERROR;
    }

    url->error = url->ssl = url->port = 0;
    memset(&uri[0], 0, sizeof (uri));
    memset(&url->proto[0], 0, sizeof (url->proto));
    memset(&url->host[0], 0, sizeof (url->host));
    memset(&url->path[0], 0, sizeof (url->path));
    memset(&url->query[0], 0, sizeof (url->query));

    if (sscanf(u, HD1, url->proto, url->host, &port, url->path) == 4) {
        ;
    } else if (sscanf(u, HD2, url->proto, url->host, url->path) == 3) {
        ;
    } else if (sscanf(u, HD3, url->proto, url->host, &port) == 3) {
        ;
    } else if (sscanf(u, HD4, url->proto, url->host) == 2) {
        ;
    } else {
        url->error = AM_EOF;
        return AM_ERROR;
    }

    url->port = port < 0 ? -(port) : port;
    if (strcasecmp(url->proto, "https") == 0) {
        url->ssl = 1;
    } else {
        url->ssl = 0;
    }
    if (strcasecmp(url->proto, "https") == 0 && url->port == 0) {
        url->port = 443;
    } else if (strcasecmp(url->proto, "http") == 0 && url->port == 0) {
        url->port = 80;
    }
    if (!ISVALID(url->path)) {
        strcpy(url->path, "/");
    } else if (url->path[0] != '/') {
        size_t ul = strlen(url->path);
        if (ul < sizeof (url->path)) {
            memmove(url->path + 1, url->path, ul);
        }
        url->path[0] = '/';
    }

    
    p = strchr(url->path, '?');
    if (p != NULL) {
        char *token, *temp, query[AM_URI_SIZE + 1], *sep;
        struct query_attribute *list;
        int sep_count, sep_count_init, j;
        strncpy(url->query, p, sizeof (url->query) - 1);
        *p = 0;

        strncpy(query, url->query + 1 , sizeof (url->query) - 1);
        sep_count = char_count(query, '&', NULL);
        if (sep_count > 0) {
            list = (struct query_attribute *) calloc(++sep_count, sizeof (struct query_attribute));
            if (list == NULL) {
                url->error = AM_ENOMEM;
                return AM_ERROR;
            }
            sep_count_init = sep_count;
            sep_count = 0;

            for ((token = strtok_r(query, "&", &temp)); token; (token = strtok_r(NULL, "&", &temp))) {
                struct query_attribute *elm = &list[sep_count++];
                elm->key_value = token;
                elm->key = strdup(token);
                if (elm->key == NULL) {
                    for (j = 0; j < sep_count_init; j++) {
                        struct query_attribute *elm = &list[j];
                        am_free(elm->key);
                    }
                    free(list);
                    url->error = AM_ENOMEM;
                    return AM_ERROR;
                }
                sep = strchr(elm->key, '=');
                if (sep != NULL) {
                    *sep = '\0';
                }
            }

            qsort(list, sep_count, sizeof (struct query_attribute), query_attribute_compare);

            strncpy(url->query, "?", sizeof (url->query) - 1);
            for (j = 0; j < sep_count; j++) {
                struct query_attribute *elm = &list[j];
                if (j > 0) {
                    strcat(url->query, "&");
                }
                strcat(url->query, elm->key_value);
                free(elm->key);
            }
            free(list);
        }
    }

    d = strdup(url->path);
    if (d == NULL) {
        url->error = AM_ENOMEM;
        return AM_ERROR;
    }
    
    p = d;
    
    while (*p != '\0') {
        if (*p != '/' || (*p == '/' && last != '/')) {
            uri[i++] = *p;
        }
        last = *p;
        p++;
    }
    free(d);

    
    uri_normalize(url, uri);

    strncpy(url->path, uri, sizeof (url->path) - 1);
    return AM_SUCCESS;
}


char *url_encode(const char *str) {
    if (str != NULL) {
        unsigned char *pstr = (unsigned char *) str;
        char *buf = (char *) calloc(1, strlen(str) * 3 + 1);
        char *pbuf = buf;

        if (buf == NULL) {
            return NULL;
        }
        while (*pstr) {

            
            if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '~') {

            
            if (isalnum(*pstr) || *pstr == '-' || *pstr == '_' || *pstr == '.' || *pstr == '*') {

                *pbuf++ = *pstr;
            } else if (*pstr == ' ') {
                *pbuf++ = '%';
                *pbuf++ = '2';
                *pbuf++ = '0';
            } else {
                *pbuf++ = '%';
                *pbuf++ = hex_chars[((*pstr) >> 4) & 0xF];
                *pbuf++ = hex_chars[(*pstr) & 0xF];
            }
            pstr++;
        }
        *pbuf = '\0';
        return buf;
    }
    return NULL;
}


char *url_decode(const char *str) {
    const char *c;
    char *ptr, *dest = NULL;

    if (str == NULL) {
        return NULL;
    }

    dest = ptr = strdup(str);
    if (dest == NULL) {
        return NULL;
    }



    for (c = str; *c; c++) {
        if (*c != '%' || !isxdigit(c[1]) || !isxdigit(c[2])) {
            *ptr++ = *c == '+' ? ' ' : *c;
        } else {
            *ptr++ = (BASE16_TO_BASE10(c[1]) * 16) + (BASE16_TO_BASE10(c[2]));
            c += 2;
        }
    }
    *ptr = 0;
    return dest;
}



int am_vsnprintf(char *s, size_t size, const char *format, va_list ap) {
    int count = -1;
    if (size != 0)
        count = _vsnprintf_s(s, size, _TRUNCATE, format, ap);
    if (count == -1)
        count = _vscprintf(format, ap);
    return count;
}

int am_snprintf(char *s, size_t n, const char *format, ...) {
    va_list ap;
    int ret;
    va_start(ap, format);
    ret = am_vsnprintf(s, n, format, ap);
    va_end(ap);
    return ret;
}




int am_vasprintf(char **buffer, const char *fmt, va_list arg) {
    int size;
    va_list ap;
    *buffer = NULL;
    va_copy(ap, arg);
    size = vsnprintf(NULL, 0, fmt, ap);
    if (size >= 0) {
        if ((*buffer = malloc(++size)) != NULL) {
            va_end(ap);
            va_copy(ap, arg);
            if ((size = vsnprintf(*buffer, size, fmt, ap)) < 0) {
                free(*buffer);
                *buffer = NULL;
            }
        }
    }
    va_end(ap);
    return size;
}


int am_asprintf(char **buffer, const char *fmt, ...) {
    int size;
    char *tmp;
    va_list ap;
    va_start(ap, fmt);
    tmp = *buffer;
    size = am_vasprintf(buffer, fmt, ap);
    am_free(tmp);
    va_end(ap);
    return size;
}

int gzip_inflate(const char *compressed, size_t *compressed_sz, char **uncompressed) {
    size_t full_length, half_length, uncompLength;
    char *uncomp = NULL;
    z_stream strm;
    int done = 1;

    if (compressed == NULL || compressed_sz == NULL || *compressed_sz == 0) {
        return 1;
    }

    full_length = *compressed_sz;
    half_length = *compressed_sz / 2;
    uncompLength = full_length;

    uncomp = (char *) calloc(sizeof (char), uncompLength);
    if (uncomp == NULL) return 1;

    strm.next_in = (Bytef *) compressed;
    strm.avail_in = (uInt) * compressed_sz;
    strm.total_out = 0;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;

    if (inflateInit2(&strm, (16 + MAX_WBITS)) != Z_OK) {
        free(uncomp);
        return 1;
    }

    while (done) {
        int err;

        if (strm.total_out >= uncompLength) {
            char *uncomp2 = (char *) calloc(sizeof (char), uncompLength + half_length);
            if (uncomp2 == NULL) {
                free(uncomp);
                return 1;
            }
            memcpy(uncomp2, uncomp, uncompLength);
            uncompLength += half_length;
            free(uncomp);
            uncomp = uncomp2;
        }

        strm.next_out = (Bytef *) (uncomp + strm.total_out);
        strm.avail_out = (uInt) uncompLength - strm.total_out;

        err = inflate(&strm, Z_SYNC_FLUSH);
        if (err == Z_STREAM_END) done = 0;
        else if (err != Z_OK) {
            break;
        }
    }

    if (inflateEnd(&strm) != Z_OK) {
        free(uncomp);
        return 1;
    }

    *uncompressed = uncomp;
    *compressed_sz = strm.total_out;
    return 0;
}

int gzip_deflate(const char *uncompressed, size_t *uncompressed_sz, char **compressed) {
    uLong comp_length, ucomp_length;
    char *comp = NULL;
    z_stream strm;
    int deflate_status;

    if (uncompressed == NULL || uncompressed_sz == NULL || *uncompressed_sz == 0) {
        return 1;
    }

    ucomp_length = (uLong) * uncompressed_sz;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.total_out = 0;
    strm.next_in = (Bytef *) uncompressed;
    strm.avail_in = ucomp_length;

    if (deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, (15 + 16), 8, Z_DEFAULT_STRATEGY) != Z_OK) {
        free(comp);
        return 1;
    }

    comp_length = deflateBound(&strm, ucomp_length);
    comp = (char *) calloc(sizeof (char), comp_length);
    if (comp == NULL) {
        deflateEnd(&strm);
        return 1;
    }

    do {
        strm.next_out = (Bytef *) (comp + strm.total_out);
        strm.avail_out = comp_length - strm.total_out;
        deflate_status = deflate(&strm, Z_FINISH);
    } while (deflate_status == Z_OK);

    if (deflate_status != Z_STREAM_END) {
        free(comp);
        deflateEnd(&strm);
        return 1;
    }

    if (deflateEnd(&strm) != Z_OK) {
        free(comp);
        return 1;
    }

    *compressed = comp;
    *uncompressed_sz = strm.total_out;
    return 0;
}

unsigned long am_instance_id(const char *instance_id) {
    uLong crc = crc32(0L, Z_NULL, 0);
    if (instance_id == NULL) return 0;
    crc = crc32(crc, (const Bytef *) instance_id, (uInt) strlen(instance_id));
    return crc;
}


void trim(char *str, char w) {
    char *in = str, *out = str;
    int i = 0;


    if (ISINVALID(str)) return;

    for (in = str; *in && TRIM_TEST(w, *in); ++in)
        ;
    if (*in == '\0') {
        out[0] = 0;
        return;
    }
    if (str != in) {
        memmove(str, in, in - str);
    }
    while (*in) {
        out[i++] = *in++;
    }
    out[i] = 0;

    while (--i >= 0) {
        if (!TRIM_TEST(w, out[i])) break;
    }
    out[++i] = 0;
}


char *am_strsep(char **str, const char *delim) {
    char *s, *t;
    const char *sp;
    int c, sc;

    if ((s = *str) == NULL) {
        return NULL;
    }
    for (t = s;;) {
        c = *s++;
        sp = delim;
        do {
            if ((sc = *sp++) == c) {
                if (c == 0) {
                    s = NULL;
                } else {
                    s[-1] = '\0';
                }
                *str = s;
                return t;
            }
        } while (sc != 0);
    }
}


char *am_strrstr(const char *str, const char *search) {
    char *last = NULL;
    char *ptr = (char *) str;
    while ((ptr = strstr(ptr, search))) {
        last = ptr++;
    }
    return last;
}

int compare_property(const char *line, const char *property) {
    if (ISVALID(line) && ISVALID(property)) {
        size_t l = strlen(property);
        if (strncmp(line, property, l) == 0 && line[l] != '\0' && (line[l] == ' ' || line[l] == '=' || line[l] == '[')) {
            return AM_SUCCESS;
        }
    }
    return AM_NOT_FOUND;
}

int get_line(char **line, size_t *size, FILE *file) {
    int c, l = 0;
    unsigned int i = 0;


    if (*line == NULL) {
        *line = malloc(DEFAULT_LINE_LEN);
        if (*line == NULL) {
            return -1;
        }
        *size = DEFAULT_LINE_LEN;
    }

    while (1) {
        c = getc(file);
        if (c < 0) {
            if (l == 0) {
                return -1; 
            } else {
                
                break;
            }
        }

        (*line)[i++] = (char) c;
        
        if (i >= *size) {
            size_t newsize = (*size) << 1;
            char *new = realloc(*line, newsize);
            if (new == NULL) {
                return -1;
            }
            *line = new;
            (*size) = newsize;
        }
        if (c == '\n' || c == '\r') {
            break;
        }
        l = 1;
    };

    (*line)[i] = 0;
    return i;
}


const char *am_method_num_to_str(int method) {
    if (method >= 0 && method < ARRAY_SIZE(request_method_str)) {
        return request_method_str[(unsigned char) method];
    }
    return request_method_str[0];
}


int am_method_str_to_num(const char *method_str) {
    unsigned char i;
    if (method_str != NULL) {
        for (i = 0; i < ARRAY_SIZE(request_method_str); i++) {
            if (!strcasecmp(method_str, request_method_str[i])) {
                return i;
            }
        }
    }
    return AM_REQUEST_UNKNOWN;
}

am_status_t get_cookie_value(am_request_t *rq, const char *separator, const char *cookie_name, const char *cookie_header_val, char **value) {
    size_t value_len = 0, ec = 0;
    am_status_t found = AM_NOT_FOUND;
    char *a, *b, *header_val = NULL, *c = NULL;

    if (ISINVALID(cookie_name)) {
        return AM_EINVAL;
    }
    if (ISINVALID(cookie_header_val)) {
        return AM_NOT_FOUND;
    }

    *value = NULL;
    header_val = strdup(cookie_header_val);
    if (header_val == NULL) {
        return AM_ENOMEM;
    }

    AM_LOG_DEBUG(rq->instance_id, "get_cookie_value(%s): parsing cookie header: %s", separator, cookie_header_val);

    for ((a = strtok_r(header_val, separator, &b)); a; (a = strtok_r(NULL, separator, &b))) {
        if (strcmp(separator, "=") == 0 || strcmp(separator, "~") == 0) {
            
            trim(a, ' ');
            if (found != AM_SUCCESS && strcmp(a, cookie_name) == 0) found = AM_SUCCESS;
            else if (found == AM_SUCCESS && a[0] != '\0') {
                value_len = strlen(a);
                if ((*value = strdup(a)) == NULL) {
                    found = AM_NOT_FOUND;
                } else {
                    (*value)[value_len] = '\0';
                    
                    trim(*value, '"');
                }
            }
        } else {
            if (strstr(a, cookie_name) == NULL) continue;
            for (ec = 0, c = a; *c != '\0'; ++c) {
                if (*c == '=') ++ec;
            }
            if (ec > 1) {
                c = strchr(a, '=');
                *c = '~';
                if ((found = get_cookie_value(rq, "~", cookie_name, a, value)) == AM_SUCCESS) break;
            } else {
                if ((found = get_cookie_value(rq, "=", cookie_name, a, value)) == AM_SUCCESS) break;
            }
        }
    }
    free(header_val);
    return found;
}

am_status_t get_token_from_url(am_request_t *rq) {
    char *token, *tmp = ISVALID(rq->url.query) ? strdup(rq->url.query + 1) : NULL;
    char *query = NULL;
    int ql = 0;
    char *o = tmp;
    size_t cn_sz;

    if (tmp == NULL) return AM_ENOMEM;
    if (!ISVALID(rq->conf->cookie_name)) {
        free(tmp);
        return AM_EINVAL;
    }
    cn_sz = strlen(rq->conf->cookie_name);

    while ((token = am_strsep(&tmp, "&")) != NULL) {
        if (!ISVALID(rq->token) && strncmp(token, rq->conf->cookie_name, cn_sz) == 0) {
            
            char *v = strstr(token, "=");
            if (v != NULL && *(v + 1) != '\n') {
                rq->token = strdup(v + 1);
            }
        } else if (!ISVALID(rq->token) && rq->conf->cdsso_enable && strncmp(token, "LARES=", 6) == 0) {
            
            size_t clear_sz = strlen(token) - 6;
            char *clear = clear_sz > 0 ? base64_decode(token + 6, &clear_sz) : NULL;
            if (clear != NULL) {
                struct am_namevalue *e, *t, *session_list;
                session_list = am_parse_session_saml(rq->instance_id, clear, clear_sz);

                AM_LIST_FOR_EACH(session_list, e, t) {
                    if (strcmp(e->n, "sid") == 0 && ISVALID(e->v)) {
                        rq->token = strdup(e->v);
                        break;
                    }
                }
                delete_am_namevalue_list(&session_list);
                free(clear);
            }
        } else {
            
            if (query == NULL) {
                ql = am_asprintf(&query, "?%s&", token);
            } else {
                ql = am_asprintf(&query, "%s%s&", query, token);
            }
        }
    }

    if (ql > 0 && query[ql - 1] == '&') {
        query[ql - 1] = 0;
        strncpy(rq->url.query, query, sizeof (rq->url.query) - 1);
    } else if (ql == 0 && ISVALID(rq->token)) {
        
        memset(rq->url.query, 0, sizeof (rq->url.query));
        
    }
    AM_FREE(query, o);
    return ISVALID(rq->token) ? AM_SUCCESS : AM_NOT_FOUND;
}

int remove_cookie(am_request_t *rq, const char *cookie_name, char **cookie_hdr) {
    char *tmp, *tok, *last = NULL;
    size_t cookie_name_len;

    if (rq == NULL || rq->ctx == NULL || !ISVALID(cookie_name)) {
        return AM_EINVAL;
    }

    if (!ISVALID(rq->cookies)) {
        return AM_SUCCESS;
    }

    if (strstr(rq->cookies, cookie_name) == NULL) {
        return AM_NOT_FOUND;
    }

    tmp = strdup(rq->cookies);
    if (tmp == NULL) return AM_ENOMEM;

    cookie_name_len = strlen(cookie_name);

    tok = strtok_r(tmp, ";", &last);
    while (tok != NULL) {
        char match = AM_FALSE;
        char *equal_sign = strchr(tok, '=');
        
        while (isspace(*tok)) tok++;
        if (equal_sign != NULL && equal_sign != tok) {
            
            while ((--equal_sign) >= tok && isspace(*equal_sign))
                ;
            equal_sign++;
            
            if (equal_sign != tok && (equal_sign - tok) == cookie_name_len && !strncmp(tok, cookie_name, cookie_name_len)) {
                match = AM_TRUE;
            }
        }
        
        if (!match) {
            am_asprintf(cookie_hdr, "%s%s%s", *cookie_hdr == NULL ? "" : *cookie_hdr, *cookie_hdr != NULL ? ";" : "", tok);


        }
        tok = strtok_r(NULL, ";", &last);
    }

    free(tmp);
    return AM_SUCCESS;
}

char *load_file(const char *filepath, size_t *data_sz) {
    char *text = NULL;
    int fd;
    struct stat st;
    if (stat(filepath, &st) == -1) {
        return NULL;
    }

    fd = _open(filepath, _O_BINARY | _O_RDONLY);

    fd = open(filepath, O_RDONLY);

    if (fd == -1) {
        return NULL;
    }
    text = malloc(st.st_size + 1);
    if (text != NULL) {
        if (st.st_size != read(fd, text, st.st_size)) {
            close(fd);
            free(text);
            return NULL;
        }
        text[st.st_size] = '\0';
        if (data_sz) {
            *data_sz = st.st_size;
        }
    }
    close(fd);
    return text;
}

ssize_t write_file(const char *filepath, const void *data, size_t data_sz) {
    int fd;
    ssize_t wr = 0;
    if (data == NULL) return AM_EINVAL;

    fd = _open(filepath, _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY, _S_IWRITE);

    fd = open(filepath, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);

    if (fd == -1) {
        return AM_EPERM;
    }
    if (data_sz != (size_t) (wr = write(fd, data,  (unsigned int)


            data_sz))) {
        close(fd);
        return AM_EOF;
    } else {

        _commit(fd);

        fsync(fd);

    }
    close(fd);
    return wr;
}

char file_exists(const char *fn) {

    if (_access(fn, 6) == 0) {
        return AM_TRUE;
    }

    struct stat sb;
    if (stat(fn, &sb) == 0) {
        if (S_ISREG(sb.st_mode) || S_ISDIR(sb.st_mode) || S_ISLNK(sb.st_mode)) {
            if (S_ISDIR(sb.st_mode)) {
                int mask = 0200 | 020;
                
                if (!(sb.st_mode & mask)) {
                    return AM_FALSE;
                }
            }
            return AM_TRUE;
        }
    }

    return AM_FALSE;
}






size_t strnlen(const char *string, size_t maxlen) {
    const char *end = memchr(string, '\0', maxlen);
    return end ? end - string : maxlen;
}




char *strndup(const char *s, size_t n) {
    size_t len = (s == NULL) ? 0 : strnlen(s, n);
    char *new = malloc(len + 1);
    if (new == NULL) {
        return NULL;
    }
    new[len] = '\0';
    return memcpy(new, s, len);
}



char* am_strldup(const char* src) {
    char* result = NULL;
    char* dest;
    if (src == NULL) {
        return result;
    }
    result = malloc(strlen(src) + 1);
    if (result == NULL) {
        return NULL;
    }
    dest = result;

    
    while ((*dest = tolower(*src)) != '\0') {
        dest++;
        src++;
    }
    return result;
}


char* stristr(char* str1, char* str2) {

    char* dup1;
    char* dup2;
    char* p;
    char* result = NULL;

    if (str1 == NULL || str2 == NULL) {
        return NULL;
    }

    dup1 = am_strldup(str1);
    dup2 = am_strldup(str2);
    if (dup1 == NULL || dup2 == NULL) {
        AM_FREE(dup1, dup2);
        return NULL;
    }

    p = strstr(dup1, dup2);
    if (p != NULL) {
        result = str1 + (p - dup1);
    }
    AM_FREE(dup1, dup2);
    return result;
}


char* base64_decode(const char* src, size_t* sz) {

    DWORD ulBlobSz = 0, ulSkipped = 0, ulFmt = 0;
    BYTE *out = NULL;
    if (src == NULL || sz == NULL) return NULL;
    if (CryptStringToBinaryA(src, (DWORD) * sz, CRYPT_STRING_BASE64, NULL, &ulBlobSz, &ulSkipped, &ulFmt) == TRUE) {
        if ((out = malloc(ulBlobSz + 1)) != NULL) {
            memset(out, 0, ulBlobSz + 1);
            if (CryptStringToBinaryA(src, (DWORD) * sz, CRYPT_STRING_BASE64, out, &ulBlobSz, &ulSkipped, &ulFmt) == TRUE) {
                out[ulBlobSz] = 0;
                *sz = ulBlobSz;
            }
        }
    }

    unsigned char table[256];
    unsigned char* out;
    unsigned char* pos;
    unsigned char* in;
    size_t i, count;

    if (src == NULL || sz == NULL) {
        return NULL;
    }

    memset(table, 64, 256);
    for (i = 0; i < sizeof (base64_table); i++) {
        table[base64_table[i]] = i;
    }

    for (in = (unsigned char *) src; table[*in++] <= 63; )
        ;

    i = (in - (unsigned char *) src) - 1;
    count = (((i + 3) / 4) * 3) + 1;

    pos = out = malloc(count);
    if (out == NULL) {
        return NULL;
    }

    in = (unsigned char *) src;

    while (i > 4) {
        *pos++ = (unsigned char) (table[in[0]] << 2 | table[in[1]] >> 4);
        *pos++ = (unsigned char) (table[in[1]] << 4 | table[in[2]] >> 2);
        *pos++ = (unsigned char) (table[in[2]] << 6 | table[in[3]]);
        in += 4;
        i -= 4;
    }

    if (i > 1) {
        *pos++ = (unsigned char) (table[in[0]] << 2 | table[in[1]] >> 4);
    }
    if (i > 2) {
        *pos++ = (unsigned char) (table[in[1]] << 4 | table[in[2]] >> 2);
    }
    if (i > 3) {
        *pos++ = (unsigned char) (table[in[2]] << 6 | table[in[3]]);
    }

    *pos = '\0';
    count -= (4 - i) & 3;
    *sz = count - 1;

    return (char *) out;
}


char *base64_encode(const void *in, size_t *sz) {
    size_t i;
    char* p;
    char* out;
    const uint8_t *src = in;

    if (src == NULL || sz == NULL) {
        return NULL;
    }

    p = out = malloc(((*sz + 2) / 3 * 4) + 1);
    if (out == NULL) {
        return NULL;
    }

    for (i = 0; i < *sz - 2; i += 3) {
        *p++ = base64_table[(src[i] >> 2) & 0x3F];
        *p++ = base64_table[((src[i] & 0x3) << 4) | ((int) (src[i + 1] & 0xF0) >> 4)];
        *p++ = base64_table[((src[i + 1] & 0xF) << 2) | ((int) (src[i + 2] & 0xC0) >> 6)];
        *p++ = base64_table[src[i + 2] & 0x3F];
    }

    if (i < *sz) {
        *p++ = base64_table[(src[i] >> 2) & 0x3F];
        if (i == (*sz - 1)) {
            *p++ = base64_table[((src[i] & 0x3) << 4)];
            *p++ = '=';
        } else {
            *p++ = base64_table[((src[i] & 0x3) << 4) | ((int) (src[i + 1] & 0xF0) >> 4)];
            *p++ = base64_table[((src[i + 1] & 0xF) << 2)];
        }
        *p++ = '=';
    }

    *p = '\0';
    *sz = p - out;
    return out;
}


void delete_am_cookie_list(struct am_cookie** list) {
    struct am_cookie* t;

    if (list == NULL || *list == NULL) {
        return;
    }

    t = *list;
    if (t != NULL) {
        delete_am_cookie_list(&t->next);
        AM_FREE(t->name, t->value, t->domain, t->max_age, t->path);
        free(t);
    }
}


int char_count(const char *string, int c, int *last) {
    int j, count;
    for (j = 0, count = 0; string[j] != '\0'; j++) {
        count += (string[j] == c);
    }
    if (last != NULL) {
        *last = (j > 0) ? string[j - 1] : 0;
    }
    return count;
}


am_status_t concat(char **str, size_t *str_sz, const char *s2, size_t s2sz) {
    size_t len = 0;
    char *str_tmp;
    if (str == NULL || s2 == NULL) {
        return AM_EINVAL;
    }
    if (*str != NULL) {
        len = str_sz == NULL ? strlen(*str) : *str_sz;
    }
    len += s2sz;
    str_tmp = realloc(*str, len + 1);
    if (str_tmp == NULL) {
        am_free(*str);
        return AM_ENOMEM;
    } else {
        *str = str_tmp;
    }
    (*str)[len - s2sz] = '\0';
    strncat(*str, s2, s2sz);
    if (str_sz != NULL) {
        *str_sz = len;
    }
    return AM_SUCCESS;
}


void uuid(char *buf, size_t buflen) {

    union {

        struct {
            uint32_t time_low;
            uint16_t time_mid;
            uint16_t time_hi_and_version;
            uint8_t clk_seq_hi_res;
            uint8_t clk_seq_low;
            uint8_t node[6];
            uint16_t node_low;
            uint32_t node_hi;
        } u;
        unsigned char __rnd[16];
    } uuid_data;


    HCRYPTPROV hcp;
    if (CryptAcquireContextA(&hcp, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {
        CryptGenRandom(hcp, sizeof (uuid_data), uuid_data.__rnd);
        CryptReleaseContext(hcp, 0);
    }

    size_t sz;
    FILE *fp = fopen("/dev/urandom", "r");
    if (fp != NULL) {
        sz = fread(uuid_data.__rnd, 1, sizeof (uuid_data), fp);
        fclose(fp);
    }


    uuid_data.u.clk_seq_hi_res = (uuid_data.u.clk_seq_hi_res & ~0xC0) | 0x80;
    uuid_data.u.time_hi_and_version = htons((uuid_data.u.time_hi_and_version & ~0xF000) | 0x4000);

    snprintf(buf, buflen, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", uuid_data.u.time_low, uuid_data.u.time_mid, uuid_data.u.time_hi_and_version, uuid_data.u.clk_seq_hi_res, uuid_data.u.clk_seq_low, uuid_data.u.node[0], uuid_data.u.node[1], uuid_data.u.node[2], uuid_data.u.node[3], uuid_data.u.node[4], uuid_data.u.node[5]);



}

int am_session_decode(am_request_t *r) {
    size_t tl, i;
    int nv = 0;
    char *begin, *end;

    enum {
        AM_NA, AM_SI, AM_SK, AM_S1 } ty = AM_NA;

    char *token = (r != NULL && ISVALID(r->token)) ? strdup(r->token) : NULL;

    if (token == NULL) return AM_EINVAL;

    memset(&r->session_info, 0, sizeof (struct am_session_info));
    tl = strlen(token);

    if (strchr(token, '*') != NULL) {
        
        char first_star = AM_TRUE;
        for (i = 0; i < tl; i++) {
            if (token[i] == '-') {
                token[i] = '+';
            } else if (token[i] == '_') {
                token[i] = '/';
            } else if (token[i] == '.') {
                token[i] = '=';
            } else if (token[i] == '*') {
                if (first_star) {
                    first_star = AM_FALSE;
                    token[i] = '@';
                } else {
                    token[i] = '#';
                }
            }
        }
    }

    begin = strstr(token, "@");
    if (begin != NULL) {
        end = strstr(begin + 1, "#");
        if (end != NULL) {
            size_t ssz = end - begin - 1;
            unsigned char *c = ssz > 0 ? (unsigned char *) base64_decode(begin + 1, &ssz) : NULL;
            if (c != NULL) {
                unsigned char *raw = c;
                size_t l = ssz;

                while (l > 0) {
                    uint16_t sz;
                    uint8_t len[2]; 

                    memcpy(len, raw, sizeof (len));
                    if (is_big_endian()) {
                        sz = (*((uint16_t *) len));
                    } else {
                        sz = len[1] | len[0] << 8;
                    }

                    l -= sizeof (len);
                    raw += sizeof (len);

                    if (nv % 2 == 0) {
                        if (memcmp(raw, "SI", 2) == 0) {
                            ty = AM_SI;
                        } else if (memcmp(raw, "SK", 2) == 0) {
                            ty = AM_SK;
                        } else if (memcmp(raw, "S1", 2) == 0) {
                            ty = AM_S1;
                        } else {
                            break;
                        }
                    } else {
                        if (ty == AM_SI) {
                            r->session_info.si = malloc(sz + 1);
                            if (r->session_info.si == NULL) {
                                r->session_info.error = AM_ENOMEM;
                                break;
                            }
                            memcpy(r->session_info.si, raw, sz);
                            r->session_info.si[sz] = 0;
                        } else if (ty == AM_SK) {
                            r->session_info.sk = malloc(sz + 1);
                            if (r->session_info.sk == NULL) {
                                r->session_info.error = AM_ENOMEM;
                                break;
                            }
                            memcpy(r->session_info.sk, raw, sz);
                            r->session_info.sk[sz] = 0;
                        } else if (ty == AM_S1) {
                            r->session_info.s1 = malloc(sz + 1);
                            if (r->session_info.s1 == NULL) {
                                r->session_info.error = AM_ENOMEM;
                                break;
                            }
                            memcpy(r->session_info.s1, raw, sz);
                            r->session_info.s1[sz] = 0;
                        }
                    }
                    l -= sz;
                    raw += sz;
                    nv += 1;
                }
                free(c);
            }
        }
    }

    free(token);
    return AM_SUCCESS;
}

const char *get_valid_openam_url(am_request_t *r) {
    const char *val = NULL;
    int valid_idx = get_valid_url_index(r->instance_id);
    
    if (r->conf->naming_url_sz > 0) {
        val = valid_idx >= r->conf->naming_url_sz ? r->conf->naming_url[0] : r->conf->naming_url[valid_idx];
        AM_LOG_DEBUG(r->instance_id, "get_valid_openam_url(): active OpenAM service url: %s (%d)", val, valid_idx);

    }
    return val;
}


void xml_entity_escape(char *temp_str, size_t str_len) {
    int k, nshifts = 0;
    const char ec[6] = "&'\"><";
    const char * const est[] = {
        "&amp;", "&apos;", "&quot;", "&gt;", "&lt;" };
    size_t i, j, nref = 0, ecl = strlen(ec);

    for (i = 0; i < str_len; i++) {
        for (nref = 0; nref < ecl; nref++) {
            if (temp_str[i] == ec[nref]) {
                if ((nshifts = (int) strlen(est[nref]) - 1) > 0) {
                    memmove(temp_str + i + nshifts, temp_str + i, str_len - i + nshifts);
                    for (j = i, k = 0; k <= nshifts; j++, k++) {
                        temp_str[j] = est[nref][k];
                    }
                    str_len += nshifts;
                }
            }
        }
    }
    temp_str[str_len] = '\0';
}



void am_timer(uint64_t *t) {

    QueryPerformanceCounter((LARGE_INTEGER *) t);

    struct timeval tv;
    gettimeofday(&tv, NULL); 
    *t = ((uint64_t) tv.tv_sec * AM_TIMER_USEC_PER_SEC) + tv.tv_usec;

}

void am_timer_start(am_timer_t *t) {
    t = t ? t : &am_timer_s;
    t->state = AM_TIMER_ACTIVE;

    t->freq = 0;

    t->freq = AM_TIMER_USEC_PER_SEC;

    am_timer(&t->start);
}

void am_timer_stop(am_timer_t *t) {
    t = t ? t : &am_timer_s;
    am_timer(&t->stop);
    t->state = AM_TIMER_INACTIVE;
}

void am_timer_pause(am_timer_t *t) {
    t = t ? t : &am_timer_s;
    am_timer(&t->stop);
    t->state |= AM_TIMER_PAUSED;
}

void am_timer_resume(am_timer_t *t) {
    uint64_t now, d;
    t = t ? t : &am_timer_s;
    t->state &= ~AM_TIMER_PAUSED;
    am_timer(&now);
    d = now - t->stop;
    t->start += d;

    t->freq = 0;

    t->freq = AM_TIMER_USEC_PER_SEC;

}

double am_timer_elapsed(am_timer_t *t) {
    uint64_t d, s;
    t = t ? t : &am_timer_s;

    QueryPerformanceFrequency((LARGE_INTEGER *) & t->freq);

    if (t->state != AM_TIMER_ACTIVE) {
        s = t->stop;
    } else {
        am_timer(&s);
    }
    d = s - t->start;
    return (double) d / (double) t->freq;
}

void am_timer_report(unsigned long instance_id, am_timer_t *t, const char *op) {
    AM_LOG_DEBUG(instance_id, "am_timer(): %s took %.0f seconds", NOTNULL(op), am_timer_elapsed(t));
}


static char *rc4(const char *input, size_t input_sz, const char *key, size_t key_sz) {
    int x, y, i, j = 0;
    int box[256];
    char *r = malloc(input_sz + 1);
    if (r == NULL) return NULL;
    for (i = 0; i < 256; i++) {
        box[i] = i;
    }
    for (i = 0; i < 256; i++) {
        j = (key[i % key_sz] + box[i] + j) % 256;
        x = box[i];
        box[i] = box[j];
        box[j] = x;
    }
    for (i = 0; i < (int) input_sz; i++) {
        y = (i + 1) % 256;
        j = (box[y] + j) % 256;
        x = box[y];
        box[y] = box[j];
        box[j] = x;
        r[i] = (char) (input[i] ^ box[(box[y] + box[j]) % 256]);
    }
    r[input_sz] = 0;
    return r;
}


int decrypt_password(const char *key, char **password) {
    char *key_clear, *pass_clear;
    size_t key_sz, pass_sz;

    if (key == NULL || password == NULL || !ISVALID(*password)) {
        return AM_EINVAL;
    }

    key_sz = strlen(key);
    pass_sz = strlen(*password);
    if (pass_sz < 2) {
        return AM_EINVAL;
    }

    key_clear = base64_decode(key, &key_sz);
    if (key_clear == NULL) {
        return AM_ENOMEM;
    }

    pass_clear = base64_decode(*password, &pass_sz);
    if (pass_clear == NULL) {
        free(key_clear);
        return AM_ENOMEM;
    }
    free(*password);

    *password = rc4(pass_clear, pass_sz, key_clear, key_sz);
    if (*password == NULL) {
        free(key_clear);
        free(pass_clear);
        return AM_ENOMEM;
    }
    free(key_clear);
    free(pass_clear);
    return (int) pass_sz;
}


int encrypt_password(const char *key, char **password) {
    char *key_clear;
    char *pass_enc, *pass_enc_b64;
    size_t key_sz, pass_sz;

    if (key == NULL || password == NULL || !ISVALID(*password)) {
        return AM_EINVAL;
    }

    key_sz = strlen(key);
    pass_sz = strlen(*password);
    if (pass_sz < 2) {
        return AM_EINVAL;
    }

    key_clear = base64_decode(key, &key_sz);
    if (key_clear == NULL) {
        return AM_ENOMEM;
    }

    pass_enc = rc4(*password, pass_sz, key_clear, key_sz);
    if (pass_enc == NULL) {
        free(key_clear);
        return AM_ENOMEM;
    }

    pass_enc_b64 = base64_encode(pass_enc, &pass_sz);
    if (pass_enc_b64 == NULL) {
        free(key_clear);
        free(pass_enc);
        return AM_ENOMEM;
    }
    AM_FREE(key_clear, pass_enc, *password);
    *password = pass_enc_b64;
    return (int) pass_sz;
}

void decrypt_agent_passwords(am_config_t *r) {
    char *pass;
    int pass_sz;

    if (r == NULL || !ISVALID(r->key)) {
        return;
    }

    if (ISVALID(r->pass)) {
        pass = strdup(r->pass);
        if (pass != NULL && (pass_sz = decrypt_password(r->key, &pass)) > 0) {
            free(r->pass);
            r->pass = pass;
            r->pass_sz = pass_sz;
        } else {
            AM_LOG_WARNING(r->instance_id, "failed to decrypt agent password");
            am_free(pass);
        }
    }

    if (ISVALID(r->cert_key_pass)) {
        pass = strdup(r->cert_key_pass);
        if (pass != NULL && (pass_sz = decrypt_password(r->key, &pass)) > 0) {
            free(r->cert_key_pass);
            r->cert_key_pass = pass;
            r->cert_key_pass_sz = pass_sz;
        } else {
            AM_LOG_WARNING(r->instance_id, "failed to decrypt certificate key password");
            am_free(pass);
        }
    }
    
    if (ISVALID(r->proxy_password)) {
        pass = strdup(r->proxy_password);
        if (pass != NULL && (pass_sz = decrypt_password(r->key, &pass)) > 0) {
            free(r->proxy_password);
            r->proxy_password = pass;
            r->proxy_password_sz = pass_sz;
        } else {
            AM_LOG_WARNING(r->instance_id, "failed to decrypt proxy password");
            am_free(pass);
        }
    }
}

void am_request_free(am_request_t *r) {
    if (r != NULL) {
        AM_FREE(r->normalized_url, r->overridden_url, r->normalized_url_pathinfo, r->overridden_url_pathinfo, r->token, r->client_ip, r->client_host, r->post_data, r->post_data_fn, r->session_info.s1, r->session_info.si, r->session_info.sk);


        delete_am_policy_result_list(&r->pattr);
        delete_am_namevalue_list(&r->sattr);
    }
}

size_t am_bin_path(char *buffer, size_t len) {

    if (GetModuleFileNameA(NULL, buffer, (DWORD) len) != 0) {
        PathRemoveFileSpecA(buffer);
        strcat(buffer, FILE_PATH_SEP);
        return (int) strlen(buffer);
    }
    return AM_ERROR;

    char *path_end;

    uint32_t size = (uint32_t) len;
    if (_NSGetExecutablePath(buffer, &size) != 0) {
        return AM_ENOMEM;
    }

    char path[64];
    snprintf(path, sizeof (path),  "/proc/%d/path/a.out"  "/proc/%d/exe"  "/proc/%d/cwd"  , getpid());







    int r = readlink(path, buffer, len);
    if (r <= 0) {
        fprintf(stderr, "readlink error %d\n", errno);
        return AM_ERROR;
    }

    path_end = strrchr(buffer, '/');
    if (path_end == NULL) {
        return AM_EINVAL;
    }
    ++path_end;
    *path_end = '\0';
    return (path_end - buffer);

}





int am_delete_directory(const char *path) {
    SHFILEOPSTRUCT file_op;
    int ret, len = (int) strlen(path) + 2; 
    char *tempdir = (char *) calloc(1, len);
    if (tempdir == NULL) return AM_ENOMEM;
    strcpy(tempdir, path);

    file_op.hwnd = NULL;
    file_op.wFunc = FO_DELETE;
    file_op.pFrom = tempdir;
    file_op.pTo = NULL;
    file_op.fFlags = FOF_NOCONFIRMATION | FOF_NOERRORUI | FOF_SILENT;
    file_op.fAnyOperationsAborted = FALSE;
    file_op.hNameMappings = NULL;
    file_op.lpszProgressTitle = "";

    ret = SHFileOperation(&file_op);
    free(tempdir);
    return ret;
}


static int delete_directory(const char *path, const struct stat *s, int flag, struct FTW *f) {
    int status;
    int (*rm_func)(const char *);
    switch (flag) {
        default: rm_func = unlink;
            break;
        case FTW_DP: rm_func = rmdir;
    }
    status = rm_func(path);
    return status;
}

int am_delete_directory(const char *path) {
    if (nftw(path, delete_directory, 32, FTW_DEPTH)) {
        return -1;
    }
    return 0;
}


int am_delete_file(const char *fn) {
    struct stat sb;
    if (stat(fn, &sb) == 0) {

        return am_delete_directory(fn);

        if (S_ISREG(sb.st_mode) || S_ISLNK(sb.st_mode)) {
            return unlink(fn);
        } else if (S_ISDIR(sb.st_mode)) {
            return am_delete_directory(fn);
        }

    }
    return -1;
}


int am_make_path(const char* path, uid_t* uid, gid_t* gid, void (*log)(const char *, ...)) {

    int skip = 0, s = '\\';
    int nmode = _S_IREAD | _S_IWRITE;

    int s = '/';
    int nmode = 0770;

    int rv;
    char *p = NULL;
    size_t len;
    char *tmp = strdup(path);
    struct stat st;

    if (tmp != NULL) {
        len = strlen(tmp);
        if (tmp[len - 1] == '/' || tmp[len - 1] == '\\') {
            tmp[len - 1] = 0;
        }
        for (p = tmp + 1; *p; p++) {
            if (*p == '/' || *p == '\\') {
                *p = 0;

                
                if (stat(tmp, &st) != 0  && skip++ > 0  ) {



                    rv = mkdir(tmp, nmode);
                    if (rv != 0 && log != NULL) {
                        log("failed to create directory %s (error: %d)", LOGEMPTY(tmp), errno);
                    }

                    if (uid != NULL) {
                        rv = chown(tmp, *uid, *gid);
                        if (rv != 0 && log != NULL) {
                            log("failed to change directory %s owner to %d:%d (error: %d)", LOGEMPTY(tmp), *uid, *gid, errno);
                        }
                    }

                }
                *p = s;
            }
        }

        
        if (stat(tmp, &st) != 0) {
            rv = mkdir(tmp, nmode);
            if (rv != 0 && log != NULL) {
                log("failed to create directory %s (error: %d)", LOGEMPTY(tmp), errno);
            }

            if (uid != NULL) {
                rv = chown(tmp, *uid, *gid);
                if (rv != 0 && log != NULL) {
                    log("failed to change directory %s owner to %d:%d (error: %d)", LOGEMPTY(tmp), *uid, *gid, errno);
                }
            }

        }
        free(tmp);
    }
    return 0;
}



static DIR *opendir(const char *dir) {
    DIR *dp;
    char *filespec;
    intptr_t handle;
    int index;

    if (dir == NULL) return NULL;
    filespec = malloc(strlen(dir) + 2 + 1);
    if (filespec == NULL) return NULL;

    strcpy(filespec, dir);
    index = (int) strlen(filespec) - 1;
    if (index >= 0 && (filespec[index] == '/' || filespec[index] == '\\')) {
        filespec[index] = '\0';
    }
    strcat(filespec, "\\*");

    dp = (DIR *) malloc(sizeof (DIR));
    if (dp == NULL) {
        free(filespec);
        return NULL;
    }

    dp->offset = 0;
    dp->finished = 0;
    dp->dir = strdup(dir);
    if (dp->dir == NULL) {
        free(dp);
        free(filespec);
        return NULL;
    }

    if ((handle = _findfirst(filespec, &(dp->fileinfo))) < 0) {
        if (errno == ENOENT) {
            dp->finished = 1;
        } else {
            free(dp->dir);
            free(dp);
            free(filespec);
            return NULL;
        }
    }
    dp->handle = handle;
    free(filespec);
    return dp;
}

static int closedir(DIR *dp) {
    if (dp != NULL) {
        _findclose(dp->handle);
        am_free(dp->dir);
        free(dp);
    }
    return 0;
}

struct dirent *readdir(DIR *dp) {
    if (!dp || dp->finished)
        return NULL;

    if (dp->offset != 0) {
        if (_findnext(dp->handle, &(dp->fileinfo)) < 0) {
            dp->finished = 1;
            return NULL;
        }
    }
    dp->offset++;
    strncpy(dp->dent.d_name, dp->fileinfo.name, AM_URI_SIZE);
    dp->dent.d_type = 0;
    if (dp->fileinfo.attrib & _A_SUBDIR) {
        dp->dent.d_type = 1;
    }
    dp->dent.d_ino = 1;
    dp->dent.d_reclen = (unsigned short) strlen(dp->dent.d_name);
    dp->dent.d_off = dp->offset;
    return &(dp->dent);
}

static int readdir_r(DIR *dp, struct dirent *entry, struct dirent **result) {
    if (!dp || dp->finished) {
        *result = NULL;
        return 0;
    }

    if (dp->offset != 0) {
        if (_findnext(dp->handle, &(dp->fileinfo)) < 0) {
            dp->finished = 1;
            *result = NULL;
            return 0;
        }
    }
    dp->offset++;
    strncpy(dp->dent.d_name, dp->fileinfo.name, AM_URI_SIZE);
    dp->dent.d_type = 0;
    if (dp->fileinfo.attrib & _A_SUBDIR) {
        dp->dent.d_type = 1;
    }
    dp->dent.d_ino = 1;
    dp->dent.d_reclen = (unsigned short) strlen(dp->dent.d_name);
    dp->dent.d_off = dp->offset;
    memcpy(entry, &dp->dent, sizeof (*entry));
    *result = &dp->dent;
    return 0;
}



static int am_alphasort(const struct dirent **_a, const struct dirent **_b) {
    struct dirent **a = (struct dirent **) _a;
    struct dirent **b = (struct dirent **) _b;
    int a_idx = atoi((*a)->d_name + 6); 
    int b_idx = atoi((*b)->d_name + 6);
    return a_idx == b_idx ? 0 : (a_idx > b_idx ? 1 : -1);
}

static int am_file_filter(const struct dirent *_a) {
    return (strncasecmp(_a->d_name, "agent_", 6) == 0);
}

static int am_scandir(const char *dirname, struct dirent ***ret_namelist, int (*select)(const struct dirent *), int (*compar)(const struct dirent **, const struct dirent **)) {

    int len, used, allocated, i;
    DIR *dir;
    struct dirent *ent, *ent2, *dirbuf;
    struct dirent **namelist = NULL;
    struct dirent **namelist_tmp;
    if ((dir = opendir(dirname)) == NULL) {
        return AM_EINVAL;
    }
    used = 0;
    allocated = 2;
    namelist = malloc(allocated * sizeof (struct dirent *));
    if (namelist == NULL) {
        closedir(dir);
        return AM_ENOMEM;
    }
    dirbuf = malloc(sizeof (struct dirent) + 255 + 1);
    if (dirbuf == NULL) {
        free(namelist);
        closedir(dir);
        return AM_ENOMEM;
    }
    while (readdir_r(dir, dirbuf, &ent) == 0 && ent) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
            continue;
        if (select != NULL && !select(ent))
            continue;
        len = offsetof(struct dirent, d_name) + (int) strlen(ent->d_name) + 1;
        if ((ent2 = malloc(len)) == NULL) {
            for (i = 0; i < used; i++) {
                am_free(namelist[i]);
            }
            AM_FREE(namelist, dirbuf);
            closedir(dir);
            return AM_ENOMEM;
        }
        if (used >= allocated) {
            allocated *= 2;
            namelist_tmp = realloc(namelist, allocated * sizeof (struct dirent *));
            if (namelist_tmp == NULL) {
                for (i = 0; i < used; i++) {
                    am_free(namelist[i]);
                }
                AM_FREE(namelist, dirbuf);
                closedir(dir);
                return AM_ENOMEM;
            } else {
                namelist = namelist_tmp;
            }
        }
        memcpy(ent2, ent, len);
        namelist[used++] = ent2;
    }
    free(dirbuf);
    closedir(dir);
    if (compar) {
        qsort(namelist, used, sizeof (struct dirent *), (int (*)(const void *, const void *)) compar);
    }
    *ret_namelist = namelist;
    return used;
}


int am_create_agent_dir(const char* sep, const char* path, char** created_name, char** created_name_simple, uid_t* uid, gid_t* gid, void (*log)(const char *, ...)) {


    struct dirent** instlist = NULL;
    int i, n, result = AM_ERROR, idx = 0;
    char* p = NULL;

    if ((n = am_scandir(path, &instlist, am_file_filter, am_alphasort)) <= 0) {

        
        if (created_name != NULL) {
            am_asprintf(created_name, "%s%sagent_1", path, sep);
        }
        if (created_name != NULL && *created_name == NULL) {
            return AM_ENOMEM;
        }
        if (created_name_simple != NULL) {
            am_asprintf(created_name_simple, "agent_1");
        }
        if (created_name_simple != NULL && *created_name_simple == NULL) {
            free(*created_name);
            *created_name = NULL;
            return AM_ENOMEM;
        }

        
        if (created_name != NULL) {
            result = am_make_path(*created_name, uid, gid, log);
        }
        am_asprintf(&p, "%s%sagent_1%sconfig", path, sep, sep);
        if (p == NULL) {
            AM_FREE(*created_name, *created_name_simple);
            *created_name = *created_name_simple = NULL;
            return AM_ENOMEM;
        }
        result = am_make_path(p, uid, gid, log);
        free(p);
        p = NULL;
        am_asprintf(&p, "%s%sagent_1%slogs%sdebug", path, sep, sep, sep);
        if (p == NULL) {
            AM_FREE(*created_name, *created_name_simple);
            *created_name = *created_name_simple = NULL;
            return AM_ENOMEM;
        }
        result = am_make_path(p, uid, gid, log);
        free(p);
        p = NULL;
        am_asprintf(&p, "%s%sagent_1%slogs%saudit", path, sep, sep, sep);
        if (p == NULL) {
            AM_FREE(*created_name, *created_name_simple);
            *created_name = *created_name_simple = NULL;
            return AM_ENOMEM;
        }
        result = am_make_path(p, uid, gid, log);
        free(p);
        am_free(instlist);

        return result;
    }

    
    for (i = 0; i < n; i++) {
        if (i == n - 1) {
            char* id = strstr(instlist[i]->d_name, "_");
            if (id != NULL && (idx = atoi(id + 1)) > 0) {
                if (created_name != NULL) {
                    am_asprintf(created_name, "%s%sagent_%d", path, sep, idx + 1);
                }
                if (created_name != NULL && *created_name == NULL) {
                    return AM_ENOMEM;
                }
                if (created_name_simple != NULL) {
                    am_asprintf(created_name_simple, "agent_%d", idx + 1);
                }
                if (created_name_simple != NULL && *created_name_simple == NULL) {
                    free(*created_name);
                    *created_name = NULL;
                    return AM_ENOMEM;
                }
                if (created_name != NULL) {
                    result = am_make_path(*created_name, uid, gid, log);
                }
                am_asprintf(&p, "%s%sagent_%d%sconfig", path, sep, idx + 1, sep);
                if (p == NULL) {
                    AM_FREE(*created_name, *created_name_simple);
                    *created_name = *created_name_simple = NULL;
                    return AM_ENOMEM;
                }
                result = am_make_path(p, uid, gid, log);
                free(p);
                p = NULL;
                am_asprintf(&p, "%s%sagent_%d%slogs%sdebug", path, sep, idx + 1, sep, sep);
                if (p == NULL) {
                    AM_FREE(*created_name, *created_name_simple);
                    *created_name = *created_name_simple = NULL;
                    return AM_ENOMEM;
                }
                result = am_make_path(p, uid, gid, log);
                free(p);
                p = NULL;
                am_asprintf(&p, "%s%sagent_%d%slogs%saudit", path, sep, idx + 1, sep, sep);
                if (p == NULL) {
                    AM_FREE(*created_name, *created_name_simple);
                    *created_name = *created_name_simple = NULL;
                    return AM_ENOMEM;
                }
                result = am_make_path(p, uid, gid, log);
                free(p);
                p = NULL;
            }
        }
        free(instlist[i]);
    }
    free(instlist);

    return result;
}

int string_replace(char **original, const char *pattern, const char *replace, size_t *sz) {
    size_t pcnt = 0;
    size_t replace_sz, pattern_sz, new_sz, e;
    char *p, *new_str;
    
    if (original == NULL || *original == NULL || pattern == NULL || replace == NULL || sz == NULL) {
        return AM_EINVAL;
    }
    
    pattern_sz = strlen(pattern);
    replace_sz = strlen(replace);
    
    
    if (pattern_sz == 0) {
        return AM_NOT_FOUND;
    }
    
    
    for (p = * original; ( p = strstr(p, pattern) ); p += pattern_sz) {
        pcnt++;
    }
    if (pcnt == 0) {
        return AM_NOT_FOUND;
    }
    
    
    new_sz = *sz + pcnt * (replace_sz - pattern_sz);
    if (*sz < new_sz) {
        new_str = realloc(*original, new_sz + 1);
        if (new_str == NULL) {
            free(*original);
            return AM_ENOMEM;
        }
    } else {
        new_str = *original;
    }
    
    
    e = (*sz) + 1;
    for (p = new_str; ( p = strstr(p, pattern) ); p += replace_sz, e += (replace_sz - pattern_sz)) {
        char *src = p + pattern_sz, *dest = p + replace_sz;
        memmove(dest, src, e - (src - new_str));
        memcpy(p, replace, replace_sz);
    }
    
    
    *sz = new_sz;
    *original = new_str;
    
    return AM_SUCCESS;
}

int copy_file(const char *from, const char *to) {
    int rv = AM_FILE_ERROR;
    am_bool_t local_alloc = AM_FALSE;
    char *to_tmp = NULL;

    if (!ISVALID(from)) {
        return AM_EINVAL;
    }
    if (!ISVALID(to)) {
        
        char tm[64];
        struct tm now;
        time_t tv = time(NULL);
        localtime_r(&tv, &now);
        strftime(tm, sizeof (tm) - 1, "%Y%m%d%H%M%S", &now);
        am_asprintf(&to_tmp, "%s_amagent_%s", from, tm);
        if (to_tmp == NULL) {
            return AM_ENOMEM;
        }
        local_alloc = AM_TRUE;
    } else {
        to_tmp = (char *) to;
    }

    if (CopyFileExA(from, to_tmp, NULL, NULL, FALSE, COPY_FILE_NO_BUFFERING) != 0) {
        rv = AM_SUCCESS;
    }

    {
        size_t content_sz = 0;
        char *content = load_file(from, &content_sz);
        if (content == NULL) {
            rv = AM_FILE_ERROR;
        } else {
            ssize_t wr_status = write_file(to_tmp, content, content_sz);
            am_free(content);

            if (wr_status == content_sz)
                rv = AM_SUCCESS;
            else if (wr_status < 0)
                rv = wr_status;
            else rv = AM_FILE_ERROR;
        }
    }

    if (local_alloc) {
        free(to_tmp);
    }
    return rv;
}

void read_directory(const char *path, struct am_namevalue **list) {
    DIR *d;
    char npath[AM_URI_SIZE];
    struct stat s;

    if ((d = opendir(path)) != NULL) {
        while (1) {
            struct dirent *e = readdir(d);
            if (e == NULL) {
                break;
            }
            snprintf(npath, sizeof (npath), "%s/%s", path, e->d_name);
            if (stat(npath, &s) == -1) {
                break;
            }

            if (strcmp(e->d_name, "..") != 0 && strcmp(e->d_name, ".") != 0) {
                struct am_namevalue *el = calloc(1, sizeof (struct am_namevalue));
                if (el == NULL) {
                    break;
                }
                el->ns = S_ISDIR(s.st_mode);
                am_asprintf(&el->n, el->ns ? "%s/%s/" : "%s/%s", path, e->d_name);
                el->v = NULL;
                el->next = NULL;
                AM_LIST_INSERT(*list, el);
            }

            if (S_ISDIR(s.st_mode) && strcmp(e->d_name, "..") != 0 && strcmp(e->d_name, ".") != 0) {
                read_directory(npath, list);
            }
        }
        closedir(d);
    } else {
        if (errno == ENOTDIR) {
            
            struct am_namevalue *el = calloc(1, sizeof (struct am_namevalue));
            if (el != NULL) {
                el->ns = 0;
                el->n = strdup(path);
                el->v = NULL;
                el->next = NULL;
                AM_LIST_INSERT(*list, el);
            }
        }
    }
}

int get_ttl_value(struct am_namevalue *session, const char *name, int def, int value_in_minutes) {
    struct am_namevalue *element, *tmp;
    int result;

    AM_LIST_FOR_EACH(session, element, tmp) {
        if (strcmp(element->n, name) == 0) {
            errno = 0;
            result = (int) strtol(element->v, NULL, AM_BASE_TEN);
            if (result < 0 || errno == ERANGE) {
                break;
            }
            return value_in_minutes ? result * 60 : result;
        }
    }
    return def < 0 ? -(def) : def;
}


void* mem2cpy(void* dest, const void* source1, size_t size1, const void* source2, size_t size2) {

    char* d = dest;

    memcpy(d, source1, size1);
    d[size1] = '\0';

    memcpy(d + size1 + 1, source2, size2);
    d[size1 + size2 + 1] = '\0';

    return dest;
}


void* mem3cpy(void* dest, const void* source1, size_t size1, const void* source2, size_t size2, const void* source3, size_t size3) {


    char* d = dest;

    memcpy(d, source1, size1);
    d[size1] = '\0';

    memcpy(d + size1 + 1, source2, size2);
    d[size1 + size2 + 1] = '\0';

    memcpy(d + size1 + size2 + 2, source3, size3);
    d[size1 + size2 + size3 + 2] = '\0';

    return dest;
}

char *am_json_escape(const char *str, size_t *escaped_sz) {
    char *data = NULL;
    const char *end;
    size_t len = 0;
    int err = 0;

    if (str == NULL) {
        return NULL;
    }

    err = concat(&data, &len, "\"", 1);
    if (err) {
        am_free(data);
        return NULL;
    }

    end = str;
    while (1) {
        const char *text;
        char seq[7];
        int length;

        while (*end && *end != '\\' && *end != '"' && *end != '/' && (unsigned char) *end > 0x1F) {
            end++;
        }
        if (end != str) {
            err = concat(&data, &len, str, end - str);
            if (err) {
                am_free(data);
                return NULL;
            }
        }
        if (!*end) {
            break;
        }

        
        length = 2;
        switch (*end) {
            case '/': text = "\\/";
                break;
            case '\\': text = "\\\\";
                break;
            case '\"': text = "\\\"";
                break;
            case '\b': text = "\\b";
                break;
            case '\f': text = "\\f";
                break;
            case '\n': text = "\\n";
                break;
            case '\r': text = "\\r";
                break;
            case '\t': text = "\\t";
                break;
            default:
            {
                snprintf(seq, sizeof (seq), "\\u%04X", *end);
                text = seq;
                length = 6;
                break;
            }
        }

        err = concat(&data, &len, text, length);
        if (err) {
            am_free(data);
            return NULL;
        }
        end++;
        str = end;
    }

    err = concat(&data, &len, "\"", 1);
    if (err) {
        am_free(data);
        return NULL;
    }

    if (escaped_sz) {
        *escaped_sz = len;
    }
    return data;
}


void update_agent_configuration_ttl(am_config_t *conf) {
    if (conf == NULL) {
        return;
    }



    
    UPDATE_VALUE_TO_SEC(conf->config_valid);
    
    
    UPDATE_VALUE_TO_SEC(conf->policy_cache_valid);
    
    
    UPDATE_VALUE_TO_SEC(conf->token_cache_valid);
    
    
    UPDATE_VALUE_TO_SEC(conf->pdp_cache_valid);
}

void update_agent_configuration_audit(am_config_t *conf) {
    int value;

    if (conf == NULL) {
        return;
    }

    if (AM_BITMASK_CHECK(conf->audit_level, (AM_LOG_LEVEL_AUDIT_ALLOW | AM_LOG_LEVEL_AUDIT_DENY))) {

        value = conf->audit_level;

        if (ISINVALID(conf->audit_file_disposition) || strcasecmp(conf->audit_file_disposition, "LOCAL") == 0) {
            value |= AM_LOG_LEVEL_AUDIT;
        } else if (strcasecmp(conf->audit_file_disposition, "REMOTE") == 0) {
            value |= AM_LOG_LEVEL_AUDIT_REMOTE;
        } else {
            value |= AM_LOG_LEVEL_AUDIT;
            value |= AM_LOG_LEVEL_AUDIT_REMOTE;
        }

        conf->audit_level = value;
    }
}


am_status_t remap_config_value(am_config_map_t * mapping, char *newvalue) {
    char *buffer = NULL;
    size_t name_sz;
    
    if (!ISVALID(mapping->name)) {
        return AM_EINVAL;
    }
    name_sz = strlen(mapping->name);
    buffer = realloc(mapping->name, name_sz + 1 + strlen(newvalue) + 1);
    if (!ISVALID(buffer)) {
        return AM_ENOMEM;
    }
    strcpy(buffer + name_sz + 1, newvalue);
    
    mapping->name = buffer;
    mapping->value = buffer + name_sz + 1;
    return AM_SUCCESS;
}

void update_agent_configuration_normalise_map_urls(am_config_t *conf) {
    static const char *thisfunc = "update_agent_configuration_normalise_map_urls()";

    int i;
    char *value, *newvalue;
    am_status_t remap_status;

    if (conf == NULL) {
        return;
    }
    
    
    if (!conf->not_enforced_regex_enable) {
        for (i = 0; i < conf->not_enforced_map_sz; i++) {
            if ( (value = conf->not_enforced_map[i].value) ) {
                if ( (newvalue = am_normalize_pattern(value)) ) {
                    remap_status = remap_config_value(conf->not_enforced_map + i, newvalue);
                    am_free(newvalue);
                    if (remap_status != AM_SUCCESS)
                        AM_LOG_WARNING(conf->instance_id, "%s error normalising not enforced URL %s (%s)", thisfunc, value, am_strerror(remap_status));
                }
            }
        }
    }
    
    if (!conf->not_enforced_ext_regex_enable) {
        for (i = 0; i < conf->not_enforced_ext_map_sz; i++) {
            if ( (value = conf->not_enforced_ext_map[i].value) ) {
                if ( (newvalue = am_normalize_pattern(value)) ) {
                    remap_status = remap_config_value(conf->not_enforced_ext_map + i, newvalue);
                    am_free(newvalue);
                    if (remap_status != AM_SUCCESS)
                        AM_LOG_WARNING(conf->instance_id, "%s error normalising extended not enforced URL %s (%s)", thisfunc, value, am_strerror(remap_status));
                }
            }
        }
    }
    
    if (!conf->logout_regex_enable) {
        for (i = 0; i < conf->logout_map_sz; i++) {
            if ( (value = conf->logout_map[i].value) ) {
                if ( (newvalue = am_normalize_pattern(value)) ) {
                    remap_status = remap_config_value(conf->logout_map + i, newvalue);
                    am_free(newvalue);
                    if (remap_status != AM_SUCCESS)
                        AM_LOG_WARNING(conf->instance_id, "%s error normalising logout URL %s (%s)", thisfunc, value, am_strerror(remap_status));
                }
            }
        }
    }
    
    for (i = 0; i < conf->json_url_map_sz; i++) {
        if ( (value = conf->json_url_map[i].value) ) {
            if ( (newvalue = am_normalize_pattern(value)) ) {
                remap_status = remap_config_value(conf->json_url_map + i, newvalue);
                am_free(newvalue);
                if (remap_status != AM_SUCCESS)
                    AM_LOG_WARNING(conf->instance_id, "%s error normalising JSON URL %s (%s)", thisfunc, value, am_strerror(remap_status));
            }
        }
    }
    
    for (i = 0; i < conf->skip_post_url_map_sz; i++) {
        if ( (value = conf->skip_post_url_map[i].value) ) {
            if ( (newvalue = am_normalize_pattern(value)) ) {
                remap_status = remap_config_value(conf->skip_post_url_map + i, newvalue);
                am_free(newvalue);
                if (remap_status != AM_SUCCESS)
                    AM_LOG_WARNING(conf->instance_id, "%s error normalising SKIP-POST URL %s (%s)", thisfunc, value, am_strerror(remap_status));
            }
        }
    }
}

static int config_map_name_compare(const void *a, const void *b) {
    int index_a = (int) strtol(((am_config_map_t *) a)->name, NULL, AM_BASE_TEN);
    int index_b = (int) strtol(((am_config_map_t *) b)->name, NULL, AM_BASE_TEN);
    return (index_a > index_b) - (index_a < index_b);
}

void update_agent_configuration_reorder_map_values(am_config_t *conf) {
    if (conf == NULL) {
        return;
    }
    if (conf->login_url_sz > 1 && conf->login_url != NULL) {
        qsort(conf->login_url, conf->login_url_sz, sizeof (am_config_map_t), config_map_name_compare);
    }
    if (conf->cdsso_login_map_sz > 1 && conf->cdsso_login_map != NULL) {
        qsort(conf->cdsso_login_map, conf->cdsso_login_map_sz, sizeof (am_config_map_t), config_map_name_compare);
    }
    if (conf->openam_logout_map_sz > 1 && conf->openam_logout_map != NULL) {
        qsort(conf->openam_logout_map, conf->openam_logout_map_sz, sizeof (am_config_map_t), config_map_name_compare);
    }
    if (conf->cond_login_url_sz > 1 && conf->cond_login_url != NULL) {
        qsort(conf->cond_login_url, conf->cond_login_url_sz, sizeof (am_config_map_t), config_map_name_compare);
    }
}

static uint32_t sdbm_hash(const void *s) {
    uint64_t hash = 0;
    int c;
    const unsigned char *str = (const unsigned char *) s;
    while ((c = *str++)) {
        hash = c + (hash << 6) + (hash << 16) - hash;
    }
    return (uint32_t) hash;
}

uint32_t am_hash(const void *k) {
    uint32_t i = sdbm_hash(k);
    i += ~(i << 9);
    i ^= ((i >> 14) | (i << 18));
    i += (i << 4);
    i ^= ((i >> 10) | (i << 22));
    return i;
}

uint32_t am_hash_buffer(const void *k, size_t sz) {
    void *tmp;
    uint32_t hash;
    if (k == NULL || sz == 0) {
        return 0;
    }
    tmp = calloc(1, sz + 1);
    if (tmp == NULL) {
        return 0;
    }
    memcpy(tmp, k, sz);
    hash = am_hash(tmp);
    free(tmp);
    return hash;
}


am_bool_t validate_directory_access(const char *path, int mask) {
    am_bool_t ret = AM_FALSE;

    PRIVILEGE_SET privileges = {0};
    DWORD length = 0, granted_access = 0, privileges_length = sizeof (privileges);
    PSECURITY_DESCRIPTOR security = NULL;
    HANDLE token = NULL, imp_token = NULL;
    GENERIC_MAPPING mapping = {0xFFFFFFFF};
    BOOL result = FALSE;

    if (!GetFileSecurityA(path, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, 0, &length) && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

        security = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, length);
    }

    if (security == NULL) {
        return AM_FALSE;
    }

    if (!GetFileSecurityA(path, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, security, length, &length) || !OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_DUPLICATE | STANDARD_RIGHTS_READ, &token)) {


        LocalFree(security);
        return AM_FALSE;
    }

    if (!DuplicateToken(token, SecurityImpersonation, &imp_token)) {
        CloseHandle(token);
        LocalFree(security);
        return AM_FALSE;
    }

    mapping.GenericRead = FILE_GENERIC_READ;
    mapping.GenericWrite = FILE_GENERIC_WRITE;
    mapping.GenericExecute = FILE_GENERIC_EXECUTE;
    mapping.GenericAll = FILE_ALL_ACCESS;
    MapGenericMask(&mask, &mapping);

    if (AccessCheck(security, imp_token, mask, &mapping, &privileges, &privileges_length, &granted_access, &result)) {
        ret = (result == TRUE);
    }

    CloseHandle(imp_token);
    CloseHandle(token);
    LocalFree(security);

    return ret;
}

am_bool_t contains_ctl(const char *string) {
    int j;
    if (string != NULL) {
        for (j = 0; string[j] != '\0'; j++) {
            if (iscntrl(string[j])) {
                return AM_TRUE;
            }
        }
    }
    return AM_FALSE;
}
