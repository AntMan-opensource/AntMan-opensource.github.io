





typedef enum {
    AM_FALSE = 0, AM_TRUE } am_bool_t;





























































































































typedef enum {
    AM_OK = 0, AM_FAIL, AM_RETRY, AM_QUIT } am_return_t;



enum {
    AM_REQUEST_UNKNOWN = 0, AM_REQUEST_GET, AM_REQUEST_POST, AM_REQUEST_HEAD, AM_REQUEST_PUT, AM_REQUEST_DELETE, AM_REQUEST_TRACE, AM_REQUEST_OPTIONS, AM_REQUEST_CONNECT, AM_REQUEST_COPY, AM_REQUEST_INVALID, AM_REQUEST_LOCK, AM_REQUEST_UNLOCK, AM_REQUEST_MOVE, AM_REQUEST_MKCOL, AM_REQUEST_PATCH, AM_REQUEST_PROPFIND, AM_REQUEST_PROPPATCH, AM_REQUEST_VERSION_CONTROL, AM_REQUEST_CHECKOUT, AM_REQUEST_UNCHECKOUT, AM_REQUEST_CHECKIN, AM_REQUEST_UPDATE, AM_REQUEST_LABEL, AM_REQUEST_REPORT, AM_REQUEST_MKWORKSPACE, AM_REQUEST_MKACTIVITY, AM_REQUEST_BASELINE_CONTROL, AM_REQUEST_MERGE, AM_REQUEST_CONFIG, AM_REQUEST_ENABLE_APP, AM_REQUEST_DISABLE_APP, AM_REQUEST_STOP_APP, AM_REQUEST_STOP_APP_RSP, AM_REQUEST_REMOVE_APP, AM_REQUEST_STATUS, AM_REQUEST_STATUS_RSP, AM_REQUEST_INFO, AM_REQUEST_INFO_RSP, AM_REQUEST_DUMP, AM_REQUEST_DUMP_RSP, AM_REQUEST_PING, AM_REQUEST_PING_RSP };











































enum {
    AM_LOG_LEVEL_NONE = 0, AM_LOG_LEVEL_ALWAYS = 1 << 0, AM_LOG_LEVEL_ERROR = 1 << 1, AM_LOG_LEVEL_WARNING = 1 << 2, AM_LOG_LEVEL_INFO = 1 << 3, AM_LOG_LEVEL_DEBUG = 1 << 4, AM_LOG_LEVEL_REMOTE = 1 << 5, AM_LOG_LEVEL_AUDIT = 1 << 6, AM_LOG_LEVEL_AUDIT_REMOTE = 1 << 7, AM_LOG_LEVEL_AUDIT_ALLOW = 1 << 8, AM_LOG_LEVEL_AUDIT_DENY = 1 << 9 };











struct url {
    unsigned int port;
    int error;
    char ssl;
    char proto[AM_PROTO_SIZE + 1];
    char host[AM_HOST_SIZE + 1];
    char path[AM_URI_SIZE + 1];
    char query[AM_URI_SIZE + 1];
};

typedef struct am_request {
    am_status_t status;
    unsigned int retry;

    am_bool_t not_enforced;
    am_bool_t is_logout_url;
    am_bool_t token_in_post;
    am_bool_t is_dummypost_url;
    am_bool_t is_json_url;

    const char *orig_url;
    const char *path_info;
    struct url url; 
    char *normalized_url; 
    char *overridden_url; 
    char *normalized_url_pathinfo;
    char *overridden_url_pathinfo;
    const char *cookies;
    const char *content_type;
    int method;

    char *token;
    struct am_session_info session_info;

    char *client_ip;
    char *client_host;

    const char *user;
    const char *user_temp;
    const char *user_password;

    struct am_namevalue *sattr; 
    struct am_policy_result *pattr; 
    struct am_namevalue *response_attributes; 
    struct am_namevalue *response_decisions;
    struct am_namevalue *policy_advice;

    const char *client_fqdn;

    char *post_data; 
    char *post_data_fn; 
    size_t post_data_sz;
    const char *post_data_url;

    unsigned long instance_id;
    am_config_t *conf; 

    void *ctx; 

    void *ctx_class;

    am_status_t(*am_get_request_url_f)(struct am_request *);
    am_status_t(*am_get_post_data_f)(struct am_request *);
    am_status_t(*am_set_post_data_f)(struct am_request *);
    am_status_t(*am_set_post_data_filename_f)(struct am_request *, const char *);
    am_status_t(*am_set_user_f)(struct am_request *, const char *);
    am_status_t(*am_set_method_f)(struct am_request *);
    am_status_t(*am_set_header_in_request_f)(struct am_request *, const char *, const char *);
    am_status_t(*am_add_header_in_response_f)(struct am_request *, const char *, const char *);
    am_status_t(*am_set_cookie_f)(struct am_request *, const char *);
    am_status_t(*am_render_result_f)(struct am_request *);
    am_status_t(*am_set_custom_response_f)(struct am_request *, const char *, const char *);
    const char *(*am_get_request_header_f)(struct am_request *, const char *);

} am_request_t;

struct http_status {
    int code;
    const char *code_str;
    const char *reason;
};

am_bool_t is_http_status(int status);
struct http_status *get_http_status(int status);

unsigned long am_instance_id(const char *);

void am_process_request(am_request_t *r);
void am_request_free(am_request_t *r);

const char *am_method_num_to_str(int method);
int am_method_str_to_num(const char *method_str);

int am_init(int id);
int am_init_worker(int id);
int am_shutdown(int id);
int am_shutdown_worker();
am_status_t am_remove_shm_and_locks(int id, void (*log_cb)(void *arg, char *name, int error), void *cb_arg);

int am_configuration_init(int id);
int am_configuration_shutdown();
int am_cache_init(int id);
int am_cache_shutdown();
void am_cache_destroy();

void am_restart_workers();
int am_log_init(int id);
void am_log_shutdown(int id);
int am_log_cleanup(int id);
void am_log_register_instance(unsigned long instance_id, const char *debug_log, int log_level, int log_size, const char *audit_log, int audit_level, int audit_size, const char *config_file);

void am_config_free(am_config_t **c);
am_config_t *am_get_config_file(unsigned long instance_id, const char *filename);
int am_get_agent_config(unsigned long instance_id, const char *config_file, am_config_t **cnf);

void uuid(char *buf, size_t buflen);
char *base64_decode(const char *in, size_t *length);
char *base64_encode(const void *in, size_t *length);
void am_free(void *ptr);
int am_asprintf(char **buffer, const char *fmt, ...);
char *am_json_escape(const char *str, size_t *escaped_sz);

char *am_normalize_pattern(const char *url);


int am_vsnprintf(char *s, size_t n, const char *format, va_list ap);
int am_snprintf(char *s, size_t n, const char *format, ...);



