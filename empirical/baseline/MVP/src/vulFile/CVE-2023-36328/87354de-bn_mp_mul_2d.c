





mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c)
{
   mp_digit d;
   mp_err   err;

   
   if (a != c) {
      if ((err = mp_copy(a, c)) != MP_OKAY) {
         return err;
      }
   }

   if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) {
      if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) {
         return err;
      }
   }

   
   if (b >= MP_DIGIT_BIT) {
      if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) {
         return err;
      }
   }

   
   d = (mp_digit)(b % MP_DIGIT_BIT);
   if (d != 0u) {
      mp_digit *tmpc, shift, mask, r, rr;
      int x;

      
      mask = ((mp_digit)1 << d) - (mp_digit)1;

      
      shift = (mp_digit)MP_DIGIT_BIT - d;

      
      tmpc = c->dp;

      
      r    = 0;
      for (x = 0; x < c->used; x++) {
         
         rr = (*tmpc >> shift) & mask;

         
         *tmpc = ((*tmpc << d) | r) & MP_MASK;
         ++tmpc;

         
         r = rr;
      }

      
      if (r != 0u) {
         c->dp[(c->used)++] = r;
      }
   }
   mp_clamp(c);
   return MP_OKAY;
}

