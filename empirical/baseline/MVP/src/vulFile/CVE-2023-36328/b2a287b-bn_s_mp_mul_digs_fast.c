





mp_err s_mp_mul_digs_fast(const mp_int *a, const mp_int *b, mp_int *c, int digs)
{
   int      olduse, pa, ix, iz;
   mp_err   err;
   mp_digit W[MP_WARRAY];
   mp_word  _W;

   
   if (c->alloc < digs) {
      if ((err = mp_grow(c, digs)) != MP_OKAY) {
         return err;
      }
   }

   
   pa = MP_MIN(digs, a->used + b->used);

   
   _W = 0;
   for (ix = 0; ix < pa; ix++) {
      int      tx, ty;
      int      iy;
      mp_digit *tmpx, *tmpy;

      
      ty = MP_MIN(b->used-1, ix);
      tx = ix - ty;

      
      tmpx = a->dp + tx;
      tmpy = b->dp + ty;

      
      iy = MP_MIN(a->used-tx, ty+1);

      
      for (iz = 0; iz < iy; ++iz) {
         _W += (mp_word)*tmpx++ * (mp_word)*tmpy--;

      }

      
      W[ix] = (mp_digit)_W & MP_MASK;

      
      _W = _W >> (mp_word)MP_DIGIT_BIT;
   }

   
   olduse  = c->used;
   c->used = pa;

   {
      mp_digit *tmpc;
      tmpc = c->dp;
      for (ix = 0; ix < pa; ix++) {
         
         *tmpc++ = W[ix];
      }

      
      MP_ZERO_DIGITS(tmpc, olduse - ix);
   }
   mp_clamp(c);
   return MP_OKAY;
}

