











static void close_fds(int, int, int);
static char *lookup(char *, struct author_data *);

static pid_t my_popen(char *, int *, int *, int *);

static int my_popen(char *, int *, int *, int *);

static char **read_args(int, int);
static int read_string(int, char *, int);
static char *substitute(char *, struct author_data *);

static int waitfor(pid_t);

static int waitfor(int);

static int write_args(int, char **, int);


static char * lookup(char *sym, struct author_data *data)
{
    static char buf[5];

    if (STREQ(sym, "user")) {
	return(tac_strdup(data->id->username));
    }
    if (STREQ(sym, "name")) {
	return(tac_strdup(data->id->NAS_name));
    }
    if (STREQ(sym, "ip")) {
	return(tac_strdup(data->id->NAS_ip));
    }
    if (STREQ(sym, "port")) {
	return(tac_strdup(data->id->NAS_port));
    }
    if (STREQ(sym, "address")) {
	return(tac_strdup(data->id->NAC_address));
    }
    if (STREQ(sym, "priv")) {
	snprintf(buf, sizeof(buf), "%d", data->id->priv_lvl);
	return(tac_strdup(buf));
    }
    if (STREQ(sym, "method")) {
	snprintf(buf, sizeof(buf), "%d", data->authen_method);
	return(tac_strdup(buf));
    }
    if (STREQ(sym, "type")) {
	snprintf(buf, sizeof(buf), "%d", data->authen_type);
	return(tac_strdup(buf));
    }
    if (STREQ(sym, "service")) {
	snprintf(buf, sizeof(buf), "%d", data->service);
	return(tac_strdup(buf));
    }
    if (STREQ(sym, "status")) {
	switch (data->status) {
	default:
	    return(tac_strdup("unknown"));
	case AUTHOR_STATUS_PASS_ADD:
	case AUTHOR_STATUS_PASS_REPL:
	    return(tac_strdup("pass"));
	case AUTHOR_STATUS_FAIL:
	    return(tac_strdup("fail"));
	case AUTHOR_STATUS_ERROR:
	    return(tac_strdup("error"));
	}
    }

    return(tac_strdup("unknown"));
}


static char * substitute(char *string, struct author_data *data)
{
    char *cp;
    char out[MAX_INPUT_LINE_LEN], *outp;
    char sym[MAX_INPUT_LINE_LEN], *symp;
    char *value, *valuep;

    if (debug & DEBUG_AUTHOR_FLAG)
	report(LOG_DEBUG, "substitute: %s", string);

    cp = string;
    outp = out;

    while (*cp) {
	if (*cp != DOLLARSIGN) {
	    *outp++ = *cp++;
	    continue;
	}
	cp++;			
	symp = sym;

	
	if (*cp == '{') {
	    cp++;		
	    while (*cp && *cp != '}')
		*symp++ = *cp++;
	    cp++;		

	} else {
	    
	    while (*cp && isalpha((int) *cp))
		*symp++ = *cp++;
	}

	*symp = '\0';
	

	if (debug & DEBUG_SUBST_FLAG)
	    report(LOG_DEBUG, "Lookup %s", sym);

	valuep = value = lookup(sym, data);

	if (debug & DEBUG_SUBST_FLAG)
	    report(LOG_DEBUG, "Expands to: %s", value);

	
	while (valuep && *valuep)
	    *outp++ = *valuep++;
	free(value);
    }
    *outp++ = '\0';

    if (debug & DEBUG_AUTHOR_FLAG)
	report(LOG_DEBUG, "Dollar substitution: %s", out);

    return(tac_strdup(out));
}


static int  waitfor(pid_t pid)


waitfor(int pid)

{

    pid_t ret;

    int ret;



    union wait status;

    int status;


    ret = waitpid(pid, &status, 0);

    if (ret < 0) {
	report(LOG_ERR, "%s: pid %ld no child exists", session.peer, (long)pid);
	return(-1);
    }
    if (!WIFEXITED(status)) {
	report(LOG_ERR, "%s: pid %ld child in illegal state", session.peer, (long)pid);
	return(-1);
    }
    if (debug & DEBUG_AUTHOR_FLAG)
	report(LOG_DEBUG, "pid %ld child exited status %ld", (long)pid, (long)WEXITSTATUS(status));

    return(WEXITSTATUS(status));
}


static int write_args(int fd, char **args, int arg_cnt)
{
    int i, m, n, o;

    for (i = 0; i < arg_cnt; i++) {
	n = strlen(args[i]);

	for (m = 0; m < n; ) {
	    if ((o = write(fd, args[i], n)) == -1) {
		if (errno != EINTR) {
		    report(LOG_ERR, "%s: Process write failure: %s", session.peer, strerror(errno));
		    return(-1);
		}
	    } else m += o;
	}
	while ((m = write(fd, "\n", 1)) != 1) {
	    if (m == -1 && errno != EINTR) {
		report(LOG_ERR, "%s: Process write failure: %s", session.peer, strerror(errno));
		return(-1);
	    }
	}
    }
    return(0);
}


static void close_fds(int fd1, int fd2, int fd3)
{
    if (fd1 >= 0) {
	close(fd1);
    }
    if (fd2 >= 0) {
	close(fd2);
    }
    if (fd3 >= 0) {
	close(fd3);
    }

    return;
}



static pid_t  static int  my_popen(char *cmd, int *readfdp, int *writefdp, int *errorfdp)



{
    int fd1[2], fd2[2], fd3[2];

    pid_t pid;

    int pid;


    fd1[0] = fd1[1] = fd2[0] = fd2[1] = fd3[0] = fd3[1] = -1;
    *readfdp = *writefdp = *errorfdp = -1;

    if (pipe(fd1) < 0 || pipe(fd2) < 0 || pipe(fd3) < 0) {
	report(LOG_ERR, "%s: Cannot create pipes", session.peer);
	close_fds(fd1[0], fd2[0], fd3[0]);
	close_fds(fd1[1], fd2[1], fd3[1]);
	return(-1);
    }

    

    signal(SIGCHLD, SIG_DFL);

    pid = fork();

    if (pid < 0) {
	report(LOG_ERR, "%s: fork failure", session.peer);
	close_fds(fd1[0], fd2[0], fd3[0]);
	close_fds(fd1[1], fd2[1], fd3[1]);
	return(-1);
    }
    if (pid > 0) {
	
	close_fds(fd1[0], fd2[1], fd3[1]);

	*writefdp = fd1[1];
	*readfdp = fd2[0];
	*errorfdp = fd3[0];

	return(pid);
    }
    
    closelog();
    close(session.sock);
    close_fds(fd1[1], fd2[0], fd3[0]);

    if (fd1[0] != STDIN_FILENO) {
	if (dup2(fd1[0], STDIN_FILENO) < 0)
	    exit(-1);
	close(fd1[0]);
    }
    if (fd2[1] != STDOUT_FILENO) {
	if (dup2(fd2[1], STDOUT_FILENO) < 0)
	    exit(-1);
	close(fd2[1]);
    }
    if (fd3[1] != STDERR_FILENO) {
	if (dup2(fd3[1], STDERR_FILENO) < 0)
	    exit(-1);
	close(fd3[1]);
    }
    (void) execl("/bin/sh", "sh", "-c", cmd, (char *) NULL);
    _exit(-1);

    return(0); 
}


static int read_string(int fd, char *string, int len)
{
    uint i, ret;
    char c;

    i = 0;
    do {
	ret = read(fd, &c, 1);
	if (ret > 0 && (i + 1) < len) {
	    string[i++] = c;
	    string[i] = '\0';
	}
    } while (i < len && ret > 0);
    return(ret);
}


static char ** read_args(int n, int fd)
{
    char buf[255], *bufp, c, **out;

    bufp = buf;

    while (read(fd, &c, 1) > 0) {
	if (c != '\n') {
	    *bufp++ = c;
	    continue;
	}
	*bufp = '\0';
	out = read_args(n + 1, fd);
	out[n] = (char *) tac_malloc(strlen(buf) + 1);
	strcpy(out[n], buf);
	return(out);
    }
    
    out = (char **) tac_malloc(sizeof(char *) * (n + 1));
    out[n] = NULL;

    return(out);
}


int call_pre_process(char *string, struct author_data *data, char ***outargsp, int *outargs_cntp, char *error, int err_len)

{
    char **new_args;
    int readfd, writefd, errorfd;
    int status, i;
    char *cmd = substitute(string, data);

    pid_t pid;

    int pid;


    pid = my_popen(cmd, &readfd, &writefd, &errorfd);
    memset(error, '\0', err_len);

    free(cmd);

    if (pid < 0) {
	close_fds(readfd, writefd, errorfd);
	return(1);		
    }

    for (i = 0; i < data->num_in_args; i++) {
	if (debug & DEBUG_AUTHOR_FLAG)
	    report(LOG_DEBUG, "input %s", data->input_args[i]);
    }

    if (write_args(writefd, data->input_args, data->num_in_args)) {
	close_fds(readfd, writefd, errorfd);
	return(1);		
    }

    close(writefd);
    writefd = -1;

    new_args = read_args(0, readfd);
    *outargsp = new_args;

    if (debug & DEBUG_AUTHOR_FLAG) {
	for (i = 0; new_args[i]; i++) {
	    report(LOG_DEBUG, "output %s", new_args[i]);
	}
    }

    read_string(errorfd, error, err_len);
    if (error[0] != '\0') {
	report(LOG_ERR, "Error from program (%d): \"%s\" ", strlen(error), error);
    }

    
    for (i = 0; new_args[i]; i++)
	  ;

    *outargs_cntp = i;

    status = waitfor(pid);
    close_fds(readfd, writefd, errorfd);
    return(status);
}


int call_post_process(char *string, struct author_data *data, char ***outargsp, int *outargs_cntp)

{
    char **new_args;
    int status;
    int readfd, writefd, errorfd;
    int i;
    char *cmd = substitute(string, data);

    pid_t pid;

    int pid;


    pid = my_popen(cmd, &readfd, &writefd, &errorfd);
    free(cmd);

    if (pid < 0) {
	close_fds(readfd, writefd, errorfd);
	return(1);		
    }

    

    if (data->status == AUTHOR_STATUS_PASS_ADD) {

	for (i = 0; i < data->num_in_args; i++) {
	    if (debug & DEBUG_AUTHOR_FLAG)
		report(LOG_DEBUG, "input %s", data->input_args[i]);
	}

	if (write_args(writefd, data->input_args, data->num_in_args)) {
	    close_fds(readfd, writefd, errorfd);
	    return(1);		
	}
    }
    for (i = 0; i < data->num_out_args; i++) {
	if (debug & DEBUG_AUTHOR_FLAG)
	    report(LOG_DEBUG, "input %s", data->output_args[i]);
    }

    if (write_args(writefd, data->output_args, data->num_out_args)) {
	close_fds(readfd, writefd, errorfd);
	return(1);		
    }

    close(writefd);
    writefd = -1;

    new_args = read_args(0, readfd);
    *outargsp = new_args;

    if (debug & DEBUG_AUTHOR_FLAG) {
	for (i = 0; new_args[i]; i++) {
	    report(LOG_DEBUG, "output %s", new_args[i]);
	}
    }
    
    for (i = 0; new_args[i]; i++)
	  ;

    *outargs_cntp = i;

    status = waitfor(pid);
    close_fds(readfd, writefd, errorfd);

    return(status);
}
