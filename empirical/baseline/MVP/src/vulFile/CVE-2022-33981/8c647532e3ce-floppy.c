
































































static int print_unex = 1;































static DEFINE_MUTEX(floppy_mutex);
static int slow_floppy;




static int FLOPPY_IRQ = 6;
static int FLOPPY_DMA = 2;
static int can_use_virtual_dma = 2;


static int use_virtual_dma;


static DEFINE_SPINLOCK(floppy_lock);

static unsigned short virtual_dma_port = 0x3f0;
irqreturn_t floppy_interrupt(int irq, void *dev_id);
static int set_dor(int fdc, char mask, char data);





static int allowed_drive_mask = 0x33;



static int irqdma_allocated;






static LIST_HEAD(floppy_reqs);
static struct request *current_req;
static int set_next_request(void);



















static inline void fallback_on_nodma_alloc(char **addr, size_t l)
{

	if (*addr)
		return;		
	if (can_use_virtual_dma != 2)
		return;		
	pr_info("DMA memory shortage. Temporarily falling back on virtual DMA\n");
	*addr = (char *)nodma_mem_alloc(l);

	return;

}



static unsigned long fake_change;
static bool initialized;





	




























static unsigned char reply_buffer[FD_RAW_REPLY_SIZE];
static int inr;		












static struct {
	struct floppy_drive_params params;
	const char *name;	
} default_drive_params[] = {

{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0, 0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, "unknown" },  {{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0, 0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, "360K PC" },  {{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0, 0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, "1.2M" },  {{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0, 0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, "720k" },  {{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0, 0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, "1.44M" },  {{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0, 0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, "2.88M AMI BIOS" },  {{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0, 0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, "2.88M" }



















};

static struct floppy_drive_params drive_params[N_DRIVE];
static struct floppy_drive_struct drive_state[N_DRIVE];
static struct floppy_write_errors write_errors[N_DRIVE];
static struct timer_list motor_off_timer[N_DRIVE];
static struct blk_mq_tag_set tag_sets[N_DRIVE];
static struct block_device *opened_bdev[N_DRIVE];
static DEFINE_MUTEX(open_lock);
static struct floppy_raw_cmd *raw_cmd, default_raw_cmd;



static struct floppy_struct floppy_type[32] = {
	{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },	 {  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,"d360"  }, { 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,"h1200" }, {  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,"D360"  }, { 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,"D720"  }, {  720, 9,2,40,1,0x23,0x01,0xDF,0x50,"h360"  }, { 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,"h720"  }, { 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,"H1440" }, { 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,"E2880" }, { 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,"E3120" },  { 2880,18,2,80,0,0x25,0x00,0xDF,0x02,"h1440" }, { 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,"H1680" }, {  820,10,2,41,1,0x25,0x01,0xDF,0x2E,"h410"  }, { 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,"H820"  }, { 2952,18,2,82,0,0x25,0x00,0xDF,0x02,"h1476" }, { 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,"H1722" }, {  840,10,2,42,1,0x25,0x01,0xDF,0x2E,"h420"  }, { 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,"H830"  }, { 2988,18,2,83,0,0x25,0x00,0xDF,0x02,"h1494" }, { 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,"H1743" },  { 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,"h880"  }, { 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,"D1040" }, { 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,"D1120" }, { 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,"h1600" }, { 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,"H1760" }, { 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,"H1920" }, { 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,"E3200" }, { 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,"E3520" }, { 7680,48,2,80,0,0x25,0x63,0xCF,0x00,"E3840" }, { 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,"H1840" },  { 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,"D800"  }, { 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,"H1600" }, };



































static struct gendisk *disks[N_DRIVE][ARRAY_SIZE(floppy_type)];




static struct floppy_struct *current_type[N_DRIVE];


static struct floppy_struct user_params[N_DRIVE];

static sector_t floppy_sizes[256];

static char floppy_device_name[] = "floppy";


static int probing;






static volatile int command_status = FD_COMMAND_NONE;
static unsigned long fdc_busy;
static DECLARE_WAIT_QUEUE_HEAD(fdc_wait);
static DECLARE_WAIT_QUEUE_HEAD(command_done);


static int format_errors;


static struct format_descr format_req;




static char *floppy_track_buffer;
static int max_buffer_sectors;

static int *errors;
typedef void (*done_f)(int);
static const struct cont_t {
	void (*interrupt)(void);
				
	void (*redo)(void);	
	void (*error)(void);	
	done_f done;		
} *cont;

static void floppy_ready(void);
static void floppy_start(void);
static void process_fd_request(void);
static void recalibrate_floppy(void);
static void floppy_shutdown(struct work_struct *);

static int floppy_request_regions(int);
static void floppy_release_regions(int);
static int floppy_grab_irq_and_dma(void);
static void floppy_release_irq_and_dma(void);


static void reset_fdc(void);
static int floppy_revalidate(struct gendisk *disk);






static atomic_t usage_count = ATOMIC_INIT(0);


static int buffer_track = -1;
static int buffer_drive = -1;
static int buffer_min = -1;
static int buffer_max = -1;


static struct floppy_fdc_state fdc_state[N_FDC];
static int current_fdc;			

static struct workqueue_struct *floppy_wq;

static struct floppy_struct *_floppy = floppy_type;
static unsigned char current_drive;
static long current_count_sectors;
static unsigned char fsector_t;	
static unsigned char in_sector_offset;	

static inline unsigned char fdc_inb(int fdc, int reg)
{
	return fd_inb(fdc_state[fdc].address, reg);
}

static inline void fdc_outb(unsigned char value, int fdc, int reg)
{
	fd_outb(value, fdc_state[fdc].address, reg);
}

static inline bool drive_no_geom(int drive)
{
	return !current_type[drive] && !ITYPE(drive_state[drive].fd_device);
}


static inline int fd_eject(int drive)
{
	return -EINVAL;
}




static long unsigned debugtimer;

static inline void set_debugt(void)
{
	debugtimer = jiffies;
}

static inline void debugt(const char *func, const char *msg)
{
	if (drive_params[current_drive].flags & DEBUGT)
		pr_info("%s:%s dtime=%lu\n", func, msg, jiffies - debugtimer);
}

static inline void set_debugt(void) { }
static inline void debugt(const char *func, const char *msg) { }



static DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);
static const char *timeout_message;

static void is_alive(const char *func, const char *message)
{
	
	if (test_bit(0, &fdc_busy) && command_status < 2 && !delayed_work_pending(&fd_timeout)) {
		DPRINT("%s: timeout handler died.  %s\n", func, message);
	}
}

static void (*do_floppy)(void) = NULL;



static void (*lasthandler)(void);
static unsigned long interruptjiffies;
static unsigned long resultjiffies;
static int resultsize;
static unsigned long lastredo;

static struct output_log {
	unsigned char data;
	unsigned char status;
	unsigned long jiffies;
} output_log[OLOGSIZE];

static int output_log_pos;



static void __reschedule_timeout(int drive, const char *message)
{
	unsigned long delay;

	if (drive < 0 || drive >= N_DRIVE) {
		delay = 20UL * HZ;
		drive = 0;
	} else delay = drive_params[drive].timeout;

	mod_delayed_work(floppy_wq, &fd_timeout, delay);
	if (drive_params[drive].flags & FD_DEBUG)
		DPRINT("reschedule timeout %s\n", message);
	timeout_message = message;
}

static void reschedule_timeout(int drive, const char *message)
{
	unsigned long flags;

	spin_lock_irqsave(&floppy_lock, flags);
	__reschedule_timeout(drive, message);
	spin_unlock_irqrestore(&floppy_lock, flags);
}








static int disk_change(int drive)
{
	int fdc = FDC(drive);

	if (time_before(jiffies, drive_state[drive].select_date + drive_params[drive].select_delay))
		DPRINT("WARNING disk change called early\n");
	if (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))) || (fdc_state[fdc].dor & 3) != UNIT(drive) || fdc != FDC(drive)) {
		DPRINT("probing disk change on unselected drive\n");
		DPRINT("drive=%d fdc=%d dor=%x\n", drive, FDC(drive), (unsigned int)fdc_state[fdc].dor);
	}

	debug_dcl(drive_params[drive].flags, "checking disk change line for drive %d\n", drive);
	debug_dcl(drive_params[drive].flags, "jiffies=%lu\n", jiffies);
	debug_dcl(drive_params[drive].flags, "disk change line=%x\n", fdc_inb(fdc, FD_DIR) & 0x80);
	debug_dcl(drive_params[drive].flags, "flags=%lx\n", drive_state[drive].flags);

	if (drive_params[drive].flags & FD_BROKEN_DCL)
		return test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);
	if ((fdc_inb(fdc, FD_DIR) ^ drive_params[drive].flags) & 0x80) {
		set_bit(FD_VERIFY_BIT, &drive_state[drive].flags);
					

		if (drive_state[drive].maxblock)	
			set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);

		
		if (drive_state[drive].keep_data >= 0) {
			if ((drive_params[drive].flags & FTD_MSG) && current_type[drive] != NULL)
				DPRINT("Disk type is undefined after disk change\n");
			current_type[drive] = NULL;
			floppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;
		}

		return 1;
	} else {
		drive_state[drive].last_checked = jiffies;
		clear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);
	}
	return 0;
}

static inline int is_selected(int dor, int unit)
{
	return ((dor & (0x10 << unit)) && (dor & 3) == unit);
}

static bool is_ready_state(int status)
{
	int state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);
	return state == STATUS_READY;
}

static int set_dor(int fdc, char mask, char data)
{
	unsigned char unit;
	unsigned char drive;
	unsigned char newdor;
	unsigned char olddor;

	if (fdc_state[fdc].address == -1)
		return -1;

	olddor = fdc_state[fdc].dor;
	newdor = (olddor & mask) | data;
	if (newdor != olddor) {
		unit = olddor & 0x3;
		if (is_selected(olddor, unit) && !is_selected(newdor, unit)) {
			drive = REVDRIVE(fdc, unit);
			debug_dcl(drive_params[drive].flags, "calling disk change from set_dor\n");
			disk_change(drive);
		}
		fdc_state[fdc].dor = newdor;
		fdc_outb(newdor, fdc, FD_DOR);

		unit = newdor & 0x3;
		if (!is_selected(olddor, unit) && is_selected(newdor, unit)) {
			drive = REVDRIVE(fdc, unit);
			drive_state[drive].select_date = jiffies;
		}
	}
	return olddor;
}

static void twaddle(int fdc, int drive)
{
	if (drive_params[drive].select_delay)
		return;
	fdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(drive)), fdc, FD_DOR);
	fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);
	drive_state[drive].select_date = jiffies;
}


static void reset_fdc_info(int fdc, int mode)
{
	int drive;

	fdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;
	fdc_state[fdc].need_configure = 1;
	fdc_state[fdc].perp_mode = 1;
	fdc_state[fdc].rawcmd = 0;
	for (drive = 0; drive < N_DRIVE; drive++)
		if (FDC(drive) == fdc && (mode || drive_state[drive].track != NEED_1_RECAL))
			drive_state[drive].track = NEED_2_RECAL;
}


static void set_fdc(int drive)
{
	unsigned int fdc;

	if (drive < 0 || drive >= N_DRIVE) {
		pr_info("bad drive value %d\n", drive);
		return;
	}

	fdc = FDC(drive);
	if (fdc >= N_FDC) {
		pr_info("bad fdc value\n");
		return;
	}

	set_dor(fdc, ~0, 8);

	set_dor(1 - fdc, ~8, 0);

	if (fdc_state[fdc].rawcmd == 2)
		reset_fdc_info(fdc, 1);
	if (fdc_inb(fdc, FD_STATUS) != STATUS_READY)
		fdc_state[fdc].reset = 1;

	current_drive = drive;
	current_fdc = fdc;
}


static int lock_fdc(int drive)
{
	if (WARN(atomic_read(&usage_count) == 0, "Trying to lock fdc while usage count=0\n"))
		return -1;

	if (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))
		return -EINTR;

	command_status = FD_COMMAND_NONE;

	reschedule_timeout(drive, "lock fdc");
	set_fdc(drive);
	return 0;
}


static void unlock_fdc(void)
{
	if (!test_bit(0, &fdc_busy))
		DPRINT("FDC access conflict!\n");

	raw_cmd = NULL;
	command_status = FD_COMMAND_NONE;
	cancel_delayed_work(&fd_timeout);
	do_floppy = NULL;
	cont = NULL;
	clear_bit(0, &fdc_busy);
	wake_up(&fdc_wait);
}


static void motor_off_callback(struct timer_list *t)
{
	unsigned long nr = t - motor_off_timer;
	unsigned char mask = ~(0x10 << UNIT(nr));

	if (WARN_ON_ONCE(nr >= N_DRIVE))
		return;

	set_dor(FDC(nr), mask, 0);
}


static void floppy_off(unsigned int drive)
{
	unsigned long volatile delta;
	int fdc = FDC(drive);

	if (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))))
		return;

	del_timer(motor_off_timer + drive);

	
	if (drive_params[drive].rps) {
		delta = jiffies - drive_state[drive].first_read_date + HZ - drive_params[drive].spindown_offset;
		delta = ((delta * drive_params[drive].rps) % HZ) / drive_params[drive].rps;
		motor_off_timer[drive].expires = jiffies + drive_params[drive].spindown - delta;
	}
	add_timer(motor_off_timer + drive);
}


static void scandrives(void)
{
	int i;
	int drive;
	int saved_drive;

	if (drive_params[current_drive].select_delay)
		return;

	saved_drive = current_drive;
	for (i = 0; i < N_DRIVE; i++) {
		drive = (saved_drive + i + 1) % N_DRIVE;
		if (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)
			continue;	
		set_fdc(drive);
		if (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) & (0x10 << UNIT(drive))))
			
			set_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);
	}
	set_fdc(saved_drive);
}

static void empty(void)
{
}

static void (*floppy_work_fn)(void);

static void floppy_work_workfn(struct work_struct *work)
{
	floppy_work_fn();
}

static DECLARE_WORK(floppy_work, floppy_work_workfn);

static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));

	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}

static void (*fd_timer_fn)(void) = NULL;

static void fd_timer_workfn(struct work_struct *work)
{
	fd_timer_fn();
}

static DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);

static void cancel_activity(void)
{
	do_floppy = NULL;
	cancel_delayed_work(&fd_timer);
	cancel_work_sync(&floppy_work);
}


static void fd_watchdog(void)
{
	debug_dcl(drive_params[current_drive].flags, "calling disk change from watchdog\n");

	if (disk_change(current_drive)) {
		DPRINT("disk removed during i/o\n");
		cancel_activity();
		cont->done(0);
		reset_fdc();
	} else {
		cancel_delayed_work(&fd_timer);
		fd_timer_fn = fd_watchdog;
		queue_delayed_work(floppy_wq, &fd_timer, HZ / 10);
	}
}

static void main_command_interrupt(void)
{
	cancel_delayed_work(&fd_timer);
	cont->interrupt();
}


static int fd_wait_for_completion(unsigned long expires, void (*function)(void))
{
	if (fdc_state[current_fdc].reset) {
		reset_fdc();	
		return 1;
	}

	if (time_before(jiffies, expires)) {
		cancel_delayed_work(&fd_timer);
		fd_timer_fn = function;
		queue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);
		return 1;
	}
	return 0;
}

static void setup_DMA(void)
{
	unsigned long f;

	if (raw_cmd->length == 0) {
		print_hex_dump(KERN_INFO, "zero dma transfer size: ", DUMP_PREFIX_NONE, 16, 1, raw_cmd->fullcmd, raw_cmd->cmd_count, false);

		cont->done(0);
		fdc_state[current_fdc].reset = 1;
		return;
	}
	if (((unsigned long)raw_cmd->kernel_data) % 512) {
		pr_info("non aligned address: %p\n", raw_cmd->kernel_data);
		cont->done(0);
		fdc_state[current_fdc].reset = 1;
		return;
	}
	f = claim_dma_lock();
	fd_disable_dma();

	if (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length, (raw_cmd->flags & FD_RAW_READ) ? DMA_MODE_READ : DMA_MODE_WRITE, fdc_state[current_fdc].address) < 0) {


		release_dma_lock(f);
		cont->done(0);
		fdc_state[current_fdc].reset = 1;
		return;
	}
	release_dma_lock(f);

	fd_clear_dma_ff();
	fd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);
	fd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ? DMA_MODE_READ : DMA_MODE_WRITE);
	fd_set_dma_addr(raw_cmd->kernel_data);
	fd_set_dma_count(raw_cmd->length);
	virtual_dma_port = fdc_state[current_fdc].address;
	fd_enable_dma();
	release_dma_lock(f);

}

static void show_floppy(int fdc);


static int wait_til_ready(int fdc)
{
	int status;
	int counter;

	if (fdc_state[fdc].reset)
		return -1;
	for (counter = 0; counter < 10000; counter++) {
		status = fdc_inb(fdc, FD_STATUS);
		if (status & STATUS_READY)
			return status;
	}
	if (initialized) {
		DPRINT("Getstatus times out (%x) on fdc %d\n", status, fdc);
		show_floppy(fdc);
	}
	fdc_state[fdc].reset = 1;
	return -1;
}


static int output_byte(int fdc, char byte)
{
	int status = wait_til_ready(fdc);

	if (status < 0)
		return -1;

	if (is_ready_state(status)) {
		fdc_outb(byte, fdc, FD_DATA);
		output_log[output_log_pos].data = byte;
		output_log[output_log_pos].status = status;
		output_log[output_log_pos].jiffies = jiffies;
		output_log_pos = (output_log_pos + 1) % OLOGSIZE;
		return 0;
	}
	fdc_state[fdc].reset = 1;
	if (initialized) {
		DPRINT("Unable to send byte %x to FDC. Fdc=%x Status=%x\n", byte, fdc, status);
		show_floppy(fdc);
	}
	return -1;
}


static int result(int fdc)
{
	int i;
	int status = 0;

	for (i = 0; i < FD_RAW_REPLY_SIZE; i++) {
		status = wait_til_ready(fdc);
		if (status < 0)
			break;
		status &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;
		if ((status & ~STATUS_BUSY) == STATUS_READY) {
			resultjiffies = jiffies;
			resultsize = i;
			return i;
		}
		if (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))
			reply_buffer[i] = fdc_inb(fdc, FD_DATA);
		else break;
	}
	if (initialized) {
		DPRINT("get result error. Fdc=%d Last status=%x Read bytes=%d\n", fdc, status, i);
		show_floppy(fdc);
	}
	fdc_state[fdc].reset = 1;
	return -1;
}



static int need_more_output(int fdc)
{
	int status = wait_til_ready(fdc);

	if (status < 0)
		return -1;

	if (is_ready_state(status))
		return MORE_OUTPUT;

	return result(fdc);
}


static void perpendicular_mode(int fdc)
{
	unsigned char perp_mode;

	if (raw_cmd->rate & 0x40) {
		switch (raw_cmd->rate & 3) {
		case 0:
			perp_mode = 2;
			break;
		case 3:
			perp_mode = 3;
			break;
		default:
			DPRINT("Invalid data rate for perpendicular mode!\n");
			cont->done(0);
			fdc_state[fdc].reset = 1;
					
			return;
		}
	} else perp_mode = 0;

	if (fdc_state[fdc].perp_mode == perp_mode)
		return;
	if (fdc_state[fdc].version >= FDC_82077_ORIG) {
		output_byte(fdc, FD_PERPENDICULAR);
		output_byte(fdc, perp_mode);
		fdc_state[fdc].perp_mode = perp_mode;
	} else if (perp_mode) {
		DPRINT("perpendicular mode not supported by this FDC.\n");
	}
}				

static int fifo_depth = 0xa;
static int no_fifo;

static int fdc_configure(int fdc)
{
	
	output_byte(fdc, FD_CONFIGURE);
	if (need_more_output(fdc) != MORE_OUTPUT)
		return 0;
	output_byte(fdc, 0);
	output_byte(fdc, 0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));
	output_byte(fdc, 0);    
	return 1;
}




static void fdc_specify(int fdc, int drive)
{
	unsigned char spec1;
	unsigned char spec2;
	unsigned long srt;
	unsigned long hlt;
	unsigned long hut;
	unsigned long dtr = NOMINAL_DTR;
	unsigned long scale_dtr = NOMINAL_DTR;
	int hlt_max_code = 0x7f;
	int hut_max_code = 0xf;

	if (fdc_state[fdc].need_configure && fdc_state[fdc].version >= FDC_82072A) {
		fdc_configure(fdc);
		fdc_state[fdc].need_configure = 0;
	}

	switch (raw_cmd->rate & 0x03) {
	case 3:
		dtr = 1000;
		break;
	case 1:
		dtr = 300;
		if (fdc_state[fdc].version >= FDC_82078) {
			
			output_byte(fdc, FD_DRIVESPEC);
			if (need_more_output(fdc) == MORE_OUTPUT) {
				output_byte(fdc, UNIT(drive));
				output_byte(fdc, 0xc0);
			}
		}
		break;
	case 2:
		dtr = 250;
		break;
	}

	if (fdc_state[fdc].version >= FDC_82072) {
		scale_dtr = dtr;
		hlt_max_code = 0x00;	
		hut_max_code = 0x0;	
	}

	
	srt = 16 - DIV_ROUND_UP(drive_params[drive].srt * scale_dtr / 1000, NOMINAL_DTR);
	if (slow_floppy)
		srt = srt / 4;

	SUPBOUND(srt, 0xf);
	INFBOUND(srt, 0);

	hlt = DIV_ROUND_UP(drive_params[drive].hlt * scale_dtr / 2, NOMINAL_DTR);
	if (hlt < 0x01)
		hlt = 0x01;
	else if (hlt > 0x7f)
		hlt = hlt_max_code;

	hut = DIV_ROUND_UP(drive_params[drive].hut * scale_dtr / 16, NOMINAL_DTR);
	if (hut < 0x1)
		hut = 0x1;
	else if (hut > 0xf)
		hut = hut_max_code;

	spec1 = (srt << 4) | hut;
	spec2 = (hlt << 1) | (use_virtual_dma & 1);

	
	if (fdc_state[fdc].spec1 != spec1 || fdc_state[fdc].spec2 != spec2) {
		
		output_byte(fdc, FD_SPECIFY);
		output_byte(fdc, fdc_state[fdc].spec1 = spec1);
		output_byte(fdc, fdc_state[fdc].spec2 = spec2);
	}
}				


static int fdc_dtr(void)
{
	
	if ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)
		return 0;

	
	fdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);

	
	fdc_state[current_fdc].dtr = raw_cmd->rate & 3;
	return fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);
}				

static void tell_sector(void)
{
	pr_cont(": track %d, head %d, sector %d, size %d", reply_buffer[R_TRACK], reply_buffer[R_HEAD], reply_buffer[R_SECTOR], reply_buffer[R_SIZECODE]);


}				

static void print_errors(void)
{
	DPRINT("");
	if (reply_buffer[ST0] & ST0_ECE) {
		pr_cont("Recalibrate failed!");
	} else if (reply_buffer[ST2] & ST2_CRC) {
		pr_cont("data CRC error");
		tell_sector();
	} else if (reply_buffer[ST1] & ST1_CRC) {
		pr_cont("CRC error");
		tell_sector();
	} else if ((reply_buffer[ST1] & (ST1_MAM | ST1_ND)) || (reply_buffer[ST2] & ST2_MAM)) {
		if (!probing) {
			pr_cont("sector not found");
			tell_sector();
		} else pr_cont("probe failed...");
	} else if (reply_buffer[ST2] & ST2_WC) {	
		pr_cont("wrong cylinder");
	} else if (reply_buffer[ST2] & ST2_BC) {	
		pr_cont("bad cylinder");
	} else {
		pr_cont("unknown error. ST[0..2] are: 0x%x 0x%x 0x%x", reply_buffer[ST0], reply_buffer[ST1], reply_buffer[ST2]);

		tell_sector();
	}
	pr_cont("\n");
}


static int interpret_errors(void)
{
	char bad;

	if (inr != 7) {
		DPRINT("-- FDC reply error\n");
		fdc_state[current_fdc].reset = 1;
		return 1;
	}

	
	switch (reply_buffer[ST0] & ST0_INTR) {
	case 0x40:		
		if (reply_buffer[ST1] & ST1_EOC)
			return 0;	
		bad = 1;
		if (reply_buffer[ST1] & ST1_WP) {
			DPRINT("Drive is write protected\n");
			clear_bit(FD_DISK_WRITABLE_BIT, &drive_state[current_drive].flags);
			cont->done(0);
			bad = 2;
		} else if (reply_buffer[ST1] & ST1_ND) {
			set_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags);
		} else if (reply_buffer[ST1] & ST1_OR) {
			if (drive_params[current_drive].flags & FTD_MSG)
				DPRINT("Over/Underrun - retrying\n");
			bad = 0;
		} else if (*errors >= drive_params[current_drive].max_errors.reporting) {
			print_errors();
		}
		if (reply_buffer[ST2] & ST2_WC || reply_buffer[ST2] & ST2_BC)
			
			drive_state[current_drive].track = NEED_2_RECAL;
		return bad;
	case 0x80:		
		DPRINT("Invalid FDC command given!\n");
		cont->done(0);
		return 2;
	case 0xc0:
		DPRINT("Abnormal termination caused by polling\n");
		cont->error();
		return 2;
	default:		
		return 0;
	}
}


static void setup_rw_floppy(void)
{
	int i;
	int r;
	int flags;
	unsigned long ready_date;
	void (*function)(void);

	flags = raw_cmd->flags;
	if (flags & (FD_RAW_READ | FD_RAW_WRITE))
		flags |= FD_RAW_INTR;

	if ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {
		ready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;
		
		if (time_after(ready_date, jiffies + drive_params[current_drive].select_delay)) {
			ready_date -= drive_params[current_drive].select_delay;
			function = floppy_start;
		} else function = setup_rw_floppy;

		
		if (fd_wait_for_completion(ready_date, function))
			return;
	}
	if ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))
		setup_DMA();

	if (flags & FD_RAW_INTR)
		do_floppy = main_command_interrupt;

	r = 0;
	for (i = 0; i < raw_cmd->cmd_count; i++)
		r |= output_byte(current_fdc, raw_cmd->fullcmd[i]);

	debugt(__func__, "rw_command");

	if (r) {
		cont->error();
		reset_fdc();
		return;
	}

	if (!(flags & FD_RAW_INTR)) {
		inr = result(current_fdc);
		cont->interrupt();
	} else if (flags & FD_RAW_NEED_DISK)
		fd_watchdog();
}

static int blind_seek;


static void seek_interrupt(void)
{
	debugt(__func__, "");
	if (inr != 2 || (reply_buffer[ST0] & 0xF8) != 0x20) {
		DPRINT("seek failed\n");
		drive_state[current_drive].track = NEED_2_RECAL;
		cont->error();
		cont->redo();
		return;
	}
	if (drive_state[current_drive].track >= 0 && drive_state[current_drive].track != reply_buffer[ST1] && !blind_seek) {

		debug_dcl(drive_params[current_drive].flags, "clearing NEWCHANGE flag because of effective seek\n");
		debug_dcl(drive_params[current_drive].flags, "jiffies=%lu\n", jiffies);
		clear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);
					
		drive_state[current_drive].select_date = jiffies;
	}
	drive_state[current_drive].track = reply_buffer[ST1];
	floppy_ready();
}

static void check_wp(int fdc, int drive)
{
	if (test_bit(FD_VERIFY_BIT, &drive_state[drive].flags)) {
					
		output_byte(fdc, FD_GETSTATUS);
		output_byte(fdc, UNIT(drive));
		if (result(fdc) != 1) {
			fdc_state[fdc].reset = 1;
			return;
		}
		clear_bit(FD_VERIFY_BIT, &drive_state[drive].flags);
		clear_bit(FD_NEED_TWADDLE_BIT, &drive_state[drive].flags);
		debug_dcl(drive_params[drive].flags, "checking whether disk is write protected\n");
		debug_dcl(drive_params[drive].flags, "wp=%x\n", reply_buffer[ST3] & 0x40);
		if (!(reply_buffer[ST3] & 0x40))
			set_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags);
		else clear_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags);

	}
}

static void seek_floppy(void)
{
	int track;

	blind_seek = 0;

	debug_dcl(drive_params[current_drive].flags, "calling disk change from %s\n", __func__);

	if (!test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) && disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {
		
		set_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags);
		cont->done(0);
		cont->redo();
		return;
	}
	if (drive_state[current_drive].track <= NEED_1_RECAL) {
		recalibrate_floppy();
		return;
	} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) && (raw_cmd->flags & FD_RAW_NEED_DISK) && (drive_state[current_drive].track <= NO_TRACK || drive_state[current_drive].track == raw_cmd->track)) {

		
		if (raw_cmd->track)
			track = raw_cmd->track - 1;
		else {
			if (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {
				set_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);
				blind_seek = 1;
				raw_cmd->flags |= FD_RAW_NEED_SEEK;
			}
			track = 1;
		}
	} else {
		check_wp(current_fdc, current_drive);
		if (raw_cmd->track != drive_state[current_drive].track && (raw_cmd->flags & FD_RAW_NEED_SEEK))
			track = raw_cmd->track;
		else {
			setup_rw_floppy();
			return;
		}
	}

	do_floppy = seek_interrupt;
	output_byte(current_fdc, FD_SEEK);
	output_byte(current_fdc, UNIT(current_drive));
	if (output_byte(current_fdc, track) < 0) {
		reset_fdc();
		return;
	}
	debugt(__func__, "");
}

static void recal_interrupt(void)
{
	debugt(__func__, "");
	if (inr != 2)
		fdc_state[current_fdc].reset = 1;
	else if (reply_buffer[ST0] & ST0_ECE) {
		switch (drive_state[current_drive].track) {
		case NEED_1_RECAL:
			debugt(__func__, "need 1 recal");
			
			cont->error();
			cont->redo();
			return;
		case NEED_2_RECAL:
			debugt(__func__, "need 2 recal");
			
			debug_dcl(drive_params[current_drive].flags, "clearing NEWCHANGE flag because of second recalibrate\n");

			clear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);
			drive_state[current_drive].select_date = jiffies;
			fallthrough;
		default:
			debugt(__func__, "default");
			
			drive_state[current_drive].track = NEED_1_RECAL;
			break;
		}
	} else drive_state[current_drive].track = reply_buffer[ST1];
	floppy_ready();
}

static void print_result(char *message, int inr)
{
	int i;

	DPRINT("%s ", message);
	if (inr >= 0)
		for (i = 0; i < inr; i++)
			pr_cont("repl[%d]=%x ", i, reply_buffer[i]);
	pr_cont("\n");
}


irqreturn_t floppy_interrupt(int irq, void *dev_id)
{
	int do_print;
	unsigned long f;
	void (*handler)(void) = do_floppy;

	lasthandler = handler;
	interruptjiffies = jiffies;

	f = claim_dma_lock();
	fd_disable_dma();
	release_dma_lock(f);

	do_floppy = NULL;
	if (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {
		
		pr_info("DOR0=%x\n", fdc_state[0].dor);
		pr_info("floppy interrupt on bizarre fdc %d\n", current_fdc);
		pr_info("handler=%ps\n", handler);
		is_alive(__func__, "bizarre fdc");
		return IRQ_NONE;
	}

	fdc_state[current_fdc].reset = 0;
	

	do_print = !handler && print_unex && initialized;

	inr = result(current_fdc);
	if (do_print)
		print_result("unexpected interrupt", inr);
	if (inr == 0) {
		int max_sensei = 4;
		do {
			output_byte(current_fdc, FD_SENSEI);
			inr = result(current_fdc);
			if (do_print)
				print_result("sensei", inr);
			max_sensei--;
		} while ((reply_buffer[ST0] & 0x83) != UNIT(current_drive) && inr == 2 && max_sensei);
	}
	if (!handler) {
		fdc_state[current_fdc].reset = 1;
		return IRQ_NONE;
	}
	schedule_bh(handler);
	is_alive(__func__, "normal interrupt end");

	
	return IRQ_HANDLED;
}

static void recalibrate_floppy(void)
{
	debugt(__func__, "");
	do_floppy = recal_interrupt;
	output_byte(current_fdc, FD_RECALIBRATE);
	if (output_byte(current_fdc, UNIT(current_drive)) < 0)
		reset_fdc();
}


static void reset_interrupt(void)
{
	debugt(__func__, "");
	result(current_fdc);		
	if (fdc_state[current_fdc].reset) {
		pr_info("reset set in interrupt, calling %ps\n", cont->error);
		cont->error();	
	}
	cont->redo();
}


static void reset_fdc(void)
{
	unsigned long flags;

	do_floppy = reset_interrupt;
	fdc_state[current_fdc].reset = 0;
	reset_fdc_info(current_fdc, 0);

	
	

	flags = claim_dma_lock();
	fd_disable_dma();
	release_dma_lock(flags);

	if (fdc_state[current_fdc].version >= FDC_82072A)
		fdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3), current_fdc, FD_STATUS);
	else {
		fdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);
		udelay(FD_RESET_DELAY);
		fdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);
	}
}

static void show_floppy(int fdc)
{
	int i;

	pr_info("\n");
	pr_info("floppy driver state\n");
	pr_info("-------------------\n");
	pr_info("now=%lu last interrupt=%lu diff=%lu last called handler=%ps\n", jiffies, interruptjiffies, jiffies - interruptjiffies, lasthandler);


	pr_info("timeout_message=%s\n", timeout_message);
	pr_info("last output bytes:\n");
	for (i = 0; i < OLOGSIZE; i++)
		pr_info("%2x %2x %lu\n", output_log[(i + output_log_pos) % OLOGSIZE].data, output_log[(i + output_log_pos) % OLOGSIZE].status, output_log[(i + output_log_pos) % OLOGSIZE].jiffies);


	pr_info("last result at %lu\n", resultjiffies);
	pr_info("last redo_fd_request at %lu\n", lastredo);
	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 1, reply_buffer, resultsize, true);

	pr_info("status=%x\n", fdc_inb(fdc, FD_STATUS));
	pr_info("fdc_busy=%lu\n", fdc_busy);
	if (do_floppy)
		pr_info("do_floppy=%ps\n", do_floppy);
	if (work_pending(&floppy_work))
		pr_info("floppy_work.func=%ps\n", floppy_work.func);
	if (delayed_work_pending(&fd_timer))
		pr_info("delayed work.function=%p expires=%ld\n", fd_timer.work.func, fd_timer.timer.expires - jiffies);

	if (delayed_work_pending(&fd_timeout))
		pr_info("timer_function=%p expires=%ld\n", fd_timeout.work.func, fd_timeout.timer.expires - jiffies);


	pr_info("cont=%p\n", cont);
	pr_info("current_req=%p\n", current_req);
	pr_info("command_status=%d\n", command_status);
	pr_info("\n");
}

static void floppy_shutdown(struct work_struct *arg)
{
	unsigned long flags;

	if (initialized)
		show_floppy(current_fdc);
	cancel_activity();

	flags = claim_dma_lock();
	fd_disable_dma();
	release_dma_lock(flags);

	

	if (initialized)
		DPRINT("floppy timeout called\n");
	fdc_state[current_fdc].reset = 1;
	if (cont) {
		cont->done(0);
		cont->redo();	
	} else {
		pr_info("no cont in shutdown!\n");
		process_fd_request();
	}
	is_alive(__func__, "");
}


static int start_motor(void (*function)(void))
{
	int mask;
	int data;

	mask = 0xfc;
	data = UNIT(current_drive);
	if (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {
		if (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {
			set_debugt();
			
			drive_state[current_drive].first_read_date = 0;
			
			drive_state[current_drive].spinup_date = jiffies;
			data |= (0x10 << UNIT(current_drive));
		}
	} else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))
		mask &= ~(0x10 << UNIT(current_drive));

	
	del_timer(motor_off_timer + current_drive);
	set_dor(current_fdc, mask, data);

	
	return fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay, function);
}

static void floppy_ready(void)
{
	if (fdc_state[current_fdc].reset) {
		reset_fdc();
		return;
	}
	if (start_motor(floppy_ready))
		return;
	if (fdc_dtr())
		return;

	debug_dcl(drive_params[current_drive].flags, "calling disk change from floppy_ready\n");
	if (!(raw_cmd->flags & FD_RAW_NO_MOTOR) && disk_change(current_drive) && !drive_params[current_drive].select_delay)
		twaddle(current_fdc, current_drive);	


	if ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {
		unsigned long flags = claim_dma_lock();
		fd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);
		release_dma_lock(flags);
	}


	if (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {
		perpendicular_mode(current_fdc);
		fdc_specify(current_fdc, current_drive); 
		seek_floppy();
	} else {
		if ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE))
			fdc_specify(current_fdc, current_drive);
		setup_rw_floppy();
	}
}

static void floppy_start(void)
{
	reschedule_timeout(current_drive, "floppy start");

	scandrives();
	debug_dcl(drive_params[current_drive].flags, "setting NEWCHANGE in floppy_start\n");
	set_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);
	floppy_ready();
}




static void do_wakeup(void)
{
	reschedule_timeout(MAXTIMEOUT, "do wakeup");
	cont = NULL;
	command_status += 2;
	wake_up(&command_done);
}

static const struct cont_t wakeup_cont = {
	.interrupt	= empty, .redo		= do_wakeup, .error		= empty, .done		= (done_f)empty };




static const struct cont_t intr_cont = {
	.interrupt	= empty, .redo		= process_fd_request, .error		= empty, .done		= (done_f)empty };





static int wait_til_done(void (*handler)(void), bool interruptible)
{
	int ret;

	schedule_bh(handler);

	if (interruptible)
		wait_event_interruptible(command_done, command_status >= 2);
	else wait_event(command_done, command_status >= 2);

	if (command_status < 2) {
		cancel_activity();
		cont = &intr_cont;
		reset_fdc();
		return -EINTR;
	}

	if (fdc_state[current_fdc].reset)
		command_status = FD_COMMAND_ERROR;
	if (command_status == FD_COMMAND_OKAY)
		ret = 0;
	else ret = -EIO;
	command_status = FD_COMMAND_NONE;
	return ret;
}

static void generic_done(int result)
{
	command_status = result;
	cont = &wakeup_cont;
}

static void generic_success(void)
{
	cont->done(1);
}

static void generic_failure(void)
{
	cont->done(0);
}

static void success_and_wakeup(void)
{
	generic_success();
	cont->redo();
}



static int next_valid_format(int drive)
{
	int probed_format;

	probed_format = drive_state[drive].probed_format;
	while (1) {
		if (probed_format >= FD_AUTODETECT_SIZE || !drive_params[drive].autodetect[probed_format]) {
			drive_state[drive].probed_format = 0;
			return 1;
		}
		if (floppy_type[drive_params[drive].autodetect[probed_format]].sect) {
			drive_state[drive].probed_format = probed_format;
			return 0;
		}
		probed_format++;
	}
}

static void bad_flp_intr(void)
{
	int err_count;

	if (probing) {
		drive_state[current_drive].probed_format++;
		if (!next_valid_format(current_drive))
			return;
	}
	err_count = ++(*errors);
	INFBOUND(write_errors[current_drive].badness, err_count);
	if (err_count > drive_params[current_drive].max_errors.abort)
		cont->done(0);
	if (err_count > drive_params[current_drive].max_errors.reset)
		fdc_state[current_fdc].reset = 1;
	else if (err_count > drive_params[current_drive].max_errors.recal)
		drive_state[current_drive].track = NEED_2_RECAL;
}

static void set_floppy(int drive)
{
	int type = ITYPE(drive_state[drive].fd_device);

	if (type)
		_floppy = floppy_type + type;
	else _floppy = current_type[drive];
}


static void format_interrupt(void)
{
	switch (interpret_errors()) {
	case 1:
		cont->error();
		break;
	case 2:
		break;
	case 0:
		cont->done(1);
	}
	cont->redo();
}




static void setup_format_params(int track)
{
	int n;
	int il;
	int count;
	int head_shift;
	int track_shift;
	struct fparm {
		unsigned char track, head, sect, size;
	} *here = (struct fparm *)floppy_track_buffer;

	raw_cmd = &default_raw_cmd;
	raw_cmd->track = track;

	raw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);
	raw_cmd->rate = _floppy->rate & 0x43;
	raw_cmd->cmd_count = NR_F;
	raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);
	raw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);
	raw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);
	raw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];
	raw_cmd->cmd[F_GAP] = _floppy->fmt_gap;
	raw_cmd->cmd[F_FILL] = FD_FILL_BYTE;

	raw_cmd->kernel_data = floppy_track_buffer;
	raw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];

	if (!raw_cmd->cmd[F_SECT_PER_TRACK])
		return;

	
	head_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;

	
	track_shift = 2 * head_shift + 3;

	
	n = (track_shift * format_req.track + head_shift * format_req.head)
	    % raw_cmd->cmd[F_SECT_PER_TRACK];

	
	il = 1;
	if (_floppy->fmt_gap < 0x22)
		il++;

	
	for (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {
		here[count].track = format_req.track;
		here[count].head = format_req.head;
		here[count].sect = 0;
		here[count].size = raw_cmd->cmd[F_SIZECODE];
	}
	
	for (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {
		here[n].sect = count;
		n = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];
		if (here[n].sect) {	
			++n;
			if (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {
				n -= raw_cmd->cmd[F_SECT_PER_TRACK];
				while (here[n].sect)
					++n;
			}
		}
	}
	if (_floppy->stretch & FD_SECTBASEMASK) {
		for (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)
			here[count].sect += FD_SECTBASE(_floppy) - 1;
	}
}

static void redo_format(void)
{
	buffer_track = -1;
	setup_format_params(format_req.track << STRETCH(_floppy));
	floppy_start();
	debugt(__func__, "queue format request");
}

static const struct cont_t format_cont = {
	.interrupt	= format_interrupt, .redo		= redo_format, .error		= bad_flp_intr, .done		= generic_done };




static int do_format(int drive, struct format_descr *tmp_format_req)
{
	int ret;

	if (lock_fdc(drive))
		return -EINTR;

	set_floppy(drive);
	if (!_floppy || _floppy->track > drive_params[current_drive].tracks || tmp_format_req->track >= _floppy->track || tmp_format_req->head >= _floppy->head || (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) || !_floppy->fmt_gap) {




		process_fd_request();
		return -EINVAL;
	}
	format_req = *tmp_format_req;
	format_errors = 0;
	cont = &format_cont;
	errors = &format_errors;
	ret = wait_til_done(redo_format, true);
	if (ret == -EINTR)
		return -EINTR;
	process_fd_request();
	return ret;
}



static void floppy_end_request(struct request *req, blk_status_t error)
{
	unsigned int nr_sectors = current_count_sectors;
	unsigned int drive = (unsigned long)req->q->disk->private_data;

	
	if (error)
		nr_sectors = blk_rq_cur_sectors(req);
	if (blk_update_request(req, error, nr_sectors << 9))
		return;
	__blk_mq_end_request(req, error);

	
	floppy_off(drive);
	current_req = NULL;
}


static void request_done(int uptodate)
{
	struct request *req = current_req;
	int block;
	char msg[sizeof("request done ") + sizeof(int) * 3];

	probing = 0;
	snprintf(msg, sizeof(msg), "request done %d", uptodate);
	reschedule_timeout(MAXTIMEOUT, msg);

	if (!req) {
		pr_info("floppy.c: no request in request_done\n");
		return;
	}

	if (uptodate) {
		
		block = current_count_sectors + blk_rq_pos(req);
		INFBOUND(drive_state[current_drive].maxblock, block);
		if (block > _floppy->sect)
			drive_state[current_drive].maxtrack = 1;

		floppy_end_request(req, 0);
	} else {
		if (rq_data_dir(req) == WRITE) {
			
			write_errors[current_drive].write_errors++;
			if (write_errors[current_drive].write_errors == 1) {
				write_errors[current_drive].first_error_sector = blk_rq_pos(req);
				write_errors[current_drive].first_error_generation = drive_state[current_drive].generation;
			}
			write_errors[current_drive].last_error_sector = blk_rq_pos(req);
			write_errors[current_drive].last_error_generation = drive_state[current_drive].generation;
		}
		floppy_end_request(req, BLK_STS_IOERR);
	}
}


static void rw_interrupt(void)
{
	int eoc;
	int ssize;
	int heads;
	int nr_sectors;

	if (reply_buffer[R_HEAD] >= 2) {
		
		return;
	}

	if (!drive_state[current_drive].first_read_date)
		drive_state[current_drive].first_read_date = jiffies;

	ssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);

	if (reply_buffer[ST1] & ST1_EOC)
		eoc = 1;
	else eoc = 0;

	if (raw_cmd->cmd[COMMAND] & 0x80)
		heads = 2;
	else heads = 1;

	nr_sectors = (((reply_buffer[R_TRACK] - raw_cmd->cmd[TRACK]) * heads + reply_buffer[R_HEAD] - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] + reply_buffer[R_SECTOR] - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;


	if (nr_sectors / ssize > DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {
		DPRINT("long rw: %x instead of %lx\n", nr_sectors, current_count_sectors);
		pr_info("rs=%d s=%d\n", reply_buffer[R_SECTOR], raw_cmd->cmd[SECTOR]);
		pr_info("rh=%d h=%d\n", reply_buffer[R_HEAD], raw_cmd->cmd[HEAD]);
		pr_info("rt=%d t=%d\n", reply_buffer[R_TRACK], raw_cmd->cmd[TRACK]);
		pr_info("heads=%d eoc=%d\n", heads, eoc);
		pr_info("spt=%d st=%d ss=%d\n", raw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);
		pr_info("in_sector_offset=%d\n", in_sector_offset);
	}

	nr_sectors -= in_sector_offset;
	INFBOUND(nr_sectors, 0);
	SUPBOUND(current_count_sectors, nr_sectors);

	switch (interpret_errors()) {
	case 2:
		cont->redo();
		return;
	case 1:
		if (!current_count_sectors) {
			cont->error();
			cont->redo();
			return;
		}
		break;
	case 0:
		if (!current_count_sectors) {
			cont->redo();
			return;
		}
		current_type[current_drive] = _floppy;
		floppy_sizes[TOMINOR(current_drive)] = _floppy->size;
		break;
	}

	if (probing) {
		if (drive_params[current_drive].flags & FTD_MSG)
			DPRINT("Auto-detected floppy type %s in fd%d\n", _floppy->name, current_drive);
		current_type[current_drive] = _floppy;
		floppy_sizes[TOMINOR(current_drive)] = _floppy->size;
		probing = 0;
	}

	if (CT(raw_cmd->cmd[COMMAND]) != FD_READ) {
		
		cont->done(1);
	} else {
		buffer_track = raw_cmd->track;
		buffer_drive = current_drive;
		INFBOUND(buffer_max, nr_sectors + fsector_t);
	}
	cont->redo();
}


static int transfer_size(int ssize, int max_sector, int max_size)
{
	SUPBOUND(max_sector, fsector_t + max_size);

	
	max_sector -= (max_sector % _floppy->sect) % ssize;

	
	current_count_sectors = max_sector - fsector_t;

	return max_sector;
}


static void copy_buffer(int ssize, int max_sector, int max_sector_2)
{
	int remaining;		
	struct bio_vec bv;
	char *dma_buffer;
	int size;
	struct req_iterator iter;

	max_sector = transfer_size(ssize, min(max_sector, max_sector_2), blk_rq_sectors(current_req));


	if (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE && buffer_max > fsector_t + blk_rq_sectors(current_req))
		current_count_sectors = min_t(int, buffer_max - fsector_t, blk_rq_sectors(current_req));

	remaining = current_count_sectors << 9;
	if (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {
		DPRINT("in copy buffer\n");
		pr_info("current_count_sectors=%ld\n", current_count_sectors);
		pr_info("remaining=%d\n", remaining >> 9);
		pr_info("current_req->nr_sectors=%u\n", blk_rq_sectors(current_req));
		pr_info("current_req->current_nr_sectors=%u\n", blk_rq_cur_sectors(current_req));
		pr_info("max_sector=%d\n", max_sector);
		pr_info("ssize=%d\n", ssize);
	}

	buffer_max = max(max_sector, buffer_max);

	dma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);

	size = blk_rq_cur_bytes(current_req);

	rq_for_each_segment(bv, current_req, iter) {
		if (!remaining)
			break;

		size = bv.bv_len;
		SUPBOUND(size, remaining);
		if (dma_buffer + size > floppy_track_buffer + (max_buffer_sectors << 10) || dma_buffer < floppy_track_buffer) {

			DPRINT("buffer overrun in copy buffer %d\n", (int)((floppy_track_buffer - dma_buffer) >> 9));
			pr_info("fsector_t=%d buffer_min=%d\n", fsector_t, buffer_min);
			pr_info("current_count_sectors=%ld\n", current_count_sectors);
			if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)
				pr_info("read\n");
			if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)
				pr_info("write\n");
			break;
		}

		if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)
			memcpy_to_bvec(&bv, dma_buffer);
		else memcpy_from_bvec(dma_buffer, &bv);

		remaining -= size;
		dma_buffer += size;
	}
	if (remaining) {
		if (remaining > 0)
			max_sector -= remaining >> 9;
		DPRINT("weirdness: remaining %d\n", remaining >> 9);
	}
}


static void virtualdmabug_workaround(void)
{
	int hard_sectors;
	int end_sector;

	if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {
		raw_cmd->cmd[COMMAND] &= ~0x80;	

		hard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);
		end_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;
		if (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {
			pr_info("too many sectors %d > %d\n", end_sector, raw_cmd->cmd[SECT_PER_TRACK]);
			return;
		}
		raw_cmd->cmd[SECT_PER_TRACK] = end_sector;
					
	}
}



static int make_raw_rw_request(void)
{
	int aligned_sector_t;
	int max_sector;
	int max_size;
	int tracksize;
	int ssize;

	if (WARN(max_buffer_sectors == 0, "VFS: Block I/O scheduled on unopened device\n"))
		return 0;

	set_fdc((long)current_req->q->disk->private_data);

	raw_cmd = &default_raw_cmd;
	raw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;
	raw_cmd->cmd_count = NR_RW;
	if (rq_data_dir(current_req) == READ) {
		raw_cmd->flags |= FD_RAW_READ;
		raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);
	} else if (rq_data_dir(current_req) == WRITE) {
		raw_cmd->flags |= FD_RAW_WRITE;
		raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);
	} else {
		DPRINT("%s: unknown command\n", __func__);
		return 0;
	}

	max_sector = _floppy->sect * _floppy->head;

	raw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;
	fsector_t = (int)blk_rq_pos(current_req) % max_sector;
	if (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {
		if (blk_rq_cur_sectors(current_req) & 1) {
			current_count_sectors = 1;
			return 1;
		} else return 0;
	}
	raw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;

	if (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) || test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) && fsector_t < _floppy->sect)

		max_sector = _floppy->sect;

	
	if ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {
		max_sector = 2 * _floppy->sect / 3;
		if (fsector_t >= max_sector) {
			current_count_sectors = min_t(int, _floppy->sect - fsector_t, blk_rq_sectors(current_req));

			return 1;
		}
		raw_cmd->cmd[SIZECODE] = 2;
	} else raw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);
	raw_cmd->rate = _floppy->rate & 0x43;
	if ((_floppy->rate & FD_2M) && (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)
		raw_cmd->rate = 1;

	if (raw_cmd->cmd[SIZECODE])
		raw_cmd->cmd[SIZECODE2] = 0xff;
	else raw_cmd->cmd[SIZECODE2] = 0x80;
	raw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);
	raw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);
	raw_cmd->cmd[GAP] = _floppy->gap;
	ssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);
	raw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];
	raw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) + FD_SECTBASE(_floppy);

	
	tracksize = _floppy->sect - _floppy->sect % ssize;
	if (tracksize < _floppy->sect) {
		raw_cmd->cmd[SECT_PER_TRACK]++;
		if (tracksize <= fsector_t % _floppy->sect)
			raw_cmd->cmd[SECTOR]--;

		
		while (tracksize <= fsector_t % _floppy->sect) {
			while (tracksize + ssize > _floppy->sect) {
				raw_cmd->cmd[SIZECODE]--;
				ssize >>= 1;
			}
			raw_cmd->cmd[SECTOR]++;
			raw_cmd->cmd[SECT_PER_TRACK]++;
			tracksize += ssize;
		}
		max_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;
	} else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {
		max_sector = _floppy->sect;
	} else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {
		
		max_sector = _floppy->sect;
	}

	in_sector_offset = (fsector_t % _floppy->sect) % ssize;
	aligned_sector_t = fsector_t - in_sector_offset;
	max_size = blk_rq_sectors(current_req);
	if ((raw_cmd->track == buffer_track) && (current_drive == buffer_drive) && (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {

		
		if (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {
			copy_buffer(1, max_sector, buffer_max);
			return 1;
		}
	} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {
		if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {
			unsigned int sectors;

			sectors = fsector_t + blk_rq_sectors(current_req);
			if (sectors > ssize && sectors < ssize + ssize)
				max_size = ssize + ssize;
			else max_size = ssize;
		}
		raw_cmd->flags &= ~FD_RAW_WRITE;
		raw_cmd->flags |= FD_RAW_READ;
		raw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);
	}

	if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)
		max_size = max_sector;	

	
	if (buffer_track != raw_cmd->track ||	 buffer_drive != current_drive || fsector_t > buffer_max || fsector_t < buffer_min || ((CT(raw_cmd->cmd[COMMAND]) == FD_READ || (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) && max_sector > 2 * max_buffer_sectors + buffer_min && max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {






		
		buffer_track = -1;
		buffer_drive = current_drive;
		buffer_max = buffer_min = aligned_sector_t;
	}
	raw_cmd->kernel_data = floppy_track_buffer + ((aligned_sector_t - buffer_min) << 9);

	if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {
		
		if (in_sector_offset && buffer_track == -1)
			DPRINT("internal error offset !=0 on write\n");
		buffer_track = raw_cmd->track;
		buffer_drive = current_drive;
		copy_buffer(ssize, max_sector, 2 * max_buffer_sectors + buffer_min);
	} else transfer_size(ssize, max_sector, 2 * max_buffer_sectors + buffer_min - aligned_sector_t);



	
	raw_cmd->length = in_sector_offset + current_count_sectors;
	raw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;
	raw_cmd->length <<= 9;
	if ((raw_cmd->length < current_count_sectors << 9) || (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE && (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max || aligned_sector_t < buffer_min)) || raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) || raw_cmd->length <= 0 || current_count_sectors <= 0) {




		DPRINT("fractionary current count b=%lx s=%lx\n", raw_cmd->length, current_count_sectors);
		pr_info("addr=%d, length=%ld\n", (int)((raw_cmd->kernel_data - floppy_track_buffer) >> 9), current_count_sectors);


		pr_info("st=%d ast=%d mse=%d msi=%d\n", fsector_t, aligned_sector_t, max_sector, max_size);
		pr_info("ssize=%x SIZECODE=%d\n", ssize, raw_cmd->cmd[SIZECODE]);
		pr_info("command=%x SECTOR=%d HEAD=%d, TRACK=%d\n", raw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR], raw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);

		pr_info("buffer drive=%d\n", buffer_drive);
		pr_info("buffer track=%d\n", buffer_track);
		pr_info("buffer_min=%d\n", buffer_min);
		pr_info("buffer_max=%d\n", buffer_max);
		return 0;
	}

	if (raw_cmd->kernel_data < floppy_track_buffer || current_count_sectors < 0 || raw_cmd->length < 0 || raw_cmd->kernel_data + raw_cmd->length > floppy_track_buffer + (max_buffer_sectors << 10)) {



		DPRINT("buffer overrun in schedule dma\n");
		pr_info("fsector_t=%d buffer_min=%d current_count=%ld\n", fsector_t, buffer_min, raw_cmd->length >> 9);
		pr_info("current_count_sectors=%ld\n", current_count_sectors);
		if (CT(raw_cmd->cmd[COMMAND]) == FD_READ)
			pr_info("read\n");
		if (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)
			pr_info("write\n");
		return 0;
	}
	if (raw_cmd->length == 0) {
		DPRINT("zero dma transfer attempted from make_raw_request\n");
		return 0;
	}

	virtualdmabug_workaround();
	return 2;
}

static int set_next_request(void)
{
	current_req = list_first_entry_or_null(&floppy_reqs, struct request, queuelist);
	if (current_req) {
		current_req->error_count = 0;
		list_del_init(&current_req->queuelist);
	}
	return current_req != NULL;
}


static void redo_fd_request(void)
{
	int drive;
	int tmp;

	lastredo = jiffies;
	if (current_drive < N_DRIVE)
		floppy_off(current_drive);

do_request:
	if (!current_req) {
		int pending;

		spin_lock_irq(&floppy_lock);
		pending = set_next_request();
		spin_unlock_irq(&floppy_lock);
		if (!pending) {
			do_floppy = NULL;
			unlock_fdc();
			return;
		}
	}
	drive = (long)current_req->q->disk->private_data;
	set_fdc(drive);
	reschedule_timeout(current_drive, "redo fd request");

	set_floppy(drive);
	raw_cmd = &default_raw_cmd;
	raw_cmd->flags = 0;
	if (start_motor(redo_fd_request))
		return;

	disk_change(current_drive);
	if (test_bit(current_drive, &fake_change) || test_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags)) {
		DPRINT("disk absent or changed during operation\n");
		request_done(0);
		goto do_request;
	}
	if (!_floppy) {	
		if (!probing) {
			drive_state[current_drive].probed_format = 0;
			if (next_valid_format(current_drive)) {
				DPRINT("no autodetectable formats\n");
				_floppy = NULL;
				request_done(0);
				goto do_request;
			}
		}
		probing = 1;
		_floppy = floppy_type + drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];
	} else probing = 0;
	errors = &(current_req->error_count);
	tmp = make_raw_rw_request();
	if (tmp < 2) {
		request_done(tmp);
		goto do_request;
	}

	if (test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags))
		twaddle(current_fdc, current_drive);
	schedule_bh(floppy_start);
	debugt(__func__, "queue fd request");
	return;
}

static const struct cont_t rw_cont = {
	.interrupt	= rw_interrupt, .redo		= redo_fd_request, .error		= bad_flp_intr, .done		= request_done };





static void process_fd_request(void)
{
	cont = &rw_cont;
	schedule_bh(redo_fd_request);
}

static blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data *bd)
{
	blk_mq_start_request(bd->rq);

	if (WARN(max_buffer_sectors == 0, "VFS: %s called on non-open device\n", __func__))
		return BLK_STS_IOERR;

	if (WARN(atomic_read(&usage_count) == 0, "warning: usage count=0, current_req=%p sect=%ld flags=%llx\n", current_req, (long)blk_rq_pos(current_req), (unsigned long long) current_req->cmd_flags))


		return BLK_STS_IOERR;

	if (test_and_set_bit(0, &fdc_busy)) {
		
		is_alive(__func__, "old request running");
		return BLK_STS_RESOURCE;
	}

	spin_lock_irq(&floppy_lock);
	list_add_tail(&bd->rq->queuelist, &floppy_reqs);
	spin_unlock_irq(&floppy_lock);

	command_status = FD_COMMAND_NONE;
	__reschedule_timeout(MAXTIMEOUT, "fd_request");
	set_fdc(0);
	process_fd_request();
	is_alive(__func__, "");
	return BLK_STS_OK;
}

static const struct cont_t poll_cont = {
	.interrupt	= success_and_wakeup, .redo		= floppy_ready, .error		= generic_failure, .done		= generic_done };




static int poll_drive(bool interruptible, int flag)
{
	
	raw_cmd = &default_raw_cmd;
	raw_cmd->flags = flag;
	raw_cmd->track = 0;
	raw_cmd->cmd_count = 0;
	cont = &poll_cont;
	debug_dcl(drive_params[current_drive].flags, "setting NEWCHANGE in poll_drive\n");
	set_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);

	return wait_til_done(floppy_ready, interruptible);
}



static void reset_intr(void)
{
	pr_info("weird, reset interrupt called\n");
}

static const struct cont_t reset_cont = {
	.interrupt	= reset_intr, .redo		= success_and_wakeup, .error		= generic_failure, .done		= generic_done };





static int user_reset_fdc(int drive, int arg, bool interruptible)
{
	int ret;

	if (lock_fdc(drive))
		return -EINTR;

	if (arg == FD_RESET_ALWAYS)
		fdc_state[current_fdc].reset = 1;
	if (fdc_state[current_fdc].reset) {
		
		cont = &reset_cont;
		ret = wait_til_done(reset_fdc, interruptible);
		if (ret == -EINTR)
			return -EINTR;
	}
	process_fd_request();
	return 0;
}


static inline int fd_copyout(void __user *param, const void *address, unsigned long size)
{
	return copy_to_user(param, address, size) ? -EFAULT : 0;
}

static inline int fd_copyin(void __user *param, void *address, unsigned long size)
{
	return copy_from_user(address, param, size) ? -EFAULT : 0;
}

static const char *drive_name(int type, int drive)
{
	struct floppy_struct *floppy;

	if (type)
		floppy = floppy_type + type;
	else {
		if (drive_params[drive].native_format)
			floppy = floppy_type + drive_params[drive].native_format;
		else return "(null)";
	}
	if (floppy->name)
		return floppy->name;
	else return "(null)";
}


static void raw_cmd_done(int flag)
{
	if (!flag) {
		raw_cmd->flags |= FD_RAW_FAILURE;
		raw_cmd->flags |= FD_RAW_HARDFAILURE;
	} else {
		raw_cmd->reply_count = inr;
		if (raw_cmd->reply_count > FD_RAW_REPLY_SIZE)
			raw_cmd->reply_count = 0;
		memcpy(raw_cmd->reply, reply_buffer, raw_cmd->reply_count);

		if (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
			unsigned long flags;
			flags = claim_dma_lock();
			raw_cmd->length = fd_get_dma_residue();
			release_dma_lock(flags);
		}

		if ((raw_cmd->flags & FD_RAW_SOFTFAILURE) && (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))
			raw_cmd->flags |= FD_RAW_FAILURE;

		if (disk_change(current_drive))
			raw_cmd->flags |= FD_RAW_DISK_CHANGE;
		else raw_cmd->flags &= ~FD_RAW_DISK_CHANGE;
		if (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)
			motor_off_callback(&motor_off_timer[current_drive]);

		if (raw_cmd->next && (!(raw_cmd->flags & FD_RAW_FAILURE) || !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) && ((raw_cmd->flags & FD_RAW_FAILURE) || !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {



			raw_cmd = raw_cmd->next;
			return;
		}
	}
	generic_done(flag);
}

static const struct cont_t raw_cmd_cont = {
	.interrupt	= success_and_wakeup, .redo		= floppy_start, .error		= generic_failure, .done		= raw_cmd_done };




static int raw_cmd_copyout(int cmd, void __user *param, struct floppy_raw_cmd *ptr)
{
	int ret;

	while (ptr) {
		struct floppy_raw_cmd cmd = *ptr;
		cmd.next = NULL;
		cmd.kernel_data = NULL;
		ret = copy_to_user(param, &cmd, sizeof(cmd));
		if (ret)
			return -EFAULT;
		param += sizeof(struct floppy_raw_cmd);
		if ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {
			if (ptr->length >= 0 && ptr->length <= ptr->buffer_length) {
				long length = ptr->buffer_length - ptr->length;
				ret = fd_copyout(ptr->data, ptr->kernel_data, length);
				if (ret)
					return ret;
			}
		}
		ptr = ptr->next;
	}

	return 0;
}

static void raw_cmd_free(struct floppy_raw_cmd **ptr)
{
	struct floppy_raw_cmd *next;
	struct floppy_raw_cmd *this;

	this = *ptr;
	*ptr = NULL;
	while (this) {
		if (this->buffer_length) {
			fd_dma_mem_free((unsigned long)this->kernel_data, this->buffer_length);
			this->buffer_length = 0;
		}
		next = this->next;
		kfree(this);
		this = next;
	}
}



static int raw_cmd_copyin(int cmd, void __user *param, struct floppy_raw_cmd **rcmd)
{
	struct floppy_raw_cmd *ptr;
	int ret;

	*rcmd = NULL;

loop:
	ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);
	if (!ptr)
		return -ENOMEM;
	*rcmd = ptr;
	ret = copy_from_user(ptr, param, sizeof(*ptr));
	ptr->next = NULL;
	ptr->buffer_length = 0;
	ptr->kernel_data = NULL;
	if (ret)
		return -EFAULT;
	param += sizeof(struct floppy_raw_cmd);
	if (ptr->cmd_count > FD_RAW_CMD_FULLSIZE)
		return -EINVAL;

	memset(ptr->reply, 0, FD_RAW_REPLY_SIZE);
	ptr->resultcode = 0;

	if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
		if (ptr->length <= 0 || ptr->length >= MAX_LEN)
			return -EINVAL;
		ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
		fallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);
		if (!ptr->kernel_data)
			return -ENOMEM;
		ptr->buffer_length = ptr->length;
	}
	if (ptr->flags & FD_RAW_WRITE) {
		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
		if (ret)
			return ret;
	}

	if (ptr->flags & FD_RAW_MORE) {
		rcmd = &(ptr->next);
		ptr->rate &= 0x43;
		goto loop;
	}

	return 0;
}

static int raw_cmd_ioctl(int cmd, void __user *param)
{
	struct floppy_raw_cmd *my_raw_cmd;
	int drive;
	int ret2;
	int ret;

	if (fdc_state[current_fdc].rawcmd <= 1)
		fdc_state[current_fdc].rawcmd = 1;
	for (drive = 0; drive < N_DRIVE; drive++) {
		if (FDC(drive) != current_fdc)
			continue;
		if (drive == current_drive) {
			if (drive_state[drive].fd_ref > 1) {
				fdc_state[current_fdc].rawcmd = 2;
				break;
			}
		} else if (drive_state[drive].fd_ref) {
			fdc_state[current_fdc].rawcmd = 2;
			break;
		}
	}

	if (fdc_state[current_fdc].reset)
		return -EIO;

	ret = raw_cmd_copyin(cmd, param, &my_raw_cmd);
	if (ret) {
		raw_cmd_free(&my_raw_cmd);
		return ret;
	}

	raw_cmd = my_raw_cmd;
	cont = &raw_cmd_cont;
	ret = wait_til_done(floppy_start, true);
	debug_dcl(drive_params[current_drive].flags, "calling disk change from raw_cmd ioctl\n");

	if (ret != -EINTR && fdc_state[current_fdc].reset)
		ret = -EIO;

	drive_state[current_drive].track = NO_TRACK;

	ret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);
	if (!ret)
		ret = ret2;
	raw_cmd_free(&my_raw_cmd);
	return ret;
}

static int invalidate_drive(struct block_device *bdev)
{
	
	set_bit((long)bdev->bd_disk->private_data, &fake_change);
	process_fd_request();
	if (bdev_check_media_change(bdev))
		floppy_revalidate(bdev->bd_disk);
	return 0;
}

static int set_geometry(unsigned int cmd, struct floppy_struct *g, int drive, int type, struct block_device *bdev)
{
	int cnt;

	
	if ((int)g->sect <= 0 || (int)g->head <= 0 ||  (int)(g->sect * g->head) <= 0 ||  (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 || g->track <= 0 || g->track > drive_params[drive].tracks >> STRETCH(g) ||  (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)







		return -EINVAL;
	if (type) {
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		mutex_lock(&open_lock);
		if (lock_fdc(drive)) {
			mutex_unlock(&open_lock);
			return -EINTR;
		}
		floppy_type[type] = *g;
		floppy_type[type].name = "user format";
		for (cnt = type << 2; cnt < (type << 2) + 4; cnt++)
			floppy_sizes[cnt] = floppy_sizes[cnt + 0x80] = floppy_type[type].size + 1;
		process_fd_request();
		for (cnt = 0; cnt < N_DRIVE; cnt++) {
			struct block_device *bdev = opened_bdev[cnt];
			if (!bdev || ITYPE(drive_state[cnt].fd_device) != type)
				continue;
			__invalidate_device(bdev, true);
		}
		mutex_unlock(&open_lock);
	} else {
		int oldStretch;

		if (lock_fdc(drive))
			return -EINTR;
		if (cmd != FDDEFPRM) {
			
			if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
				return -EINTR;
		}
		oldStretch = g->stretch;
		user_params[drive] = *g;
		if (buffer_drive == drive)
			SUPBOUND(buffer_max, user_params[drive].sect);
		current_type[drive] = &user_params[drive];
		floppy_sizes[drive] = user_params[drive].size;
		if (cmd == FDDEFPRM)
			drive_state[current_drive].keep_data = -1;
		else drive_state[current_drive].keep_data = 1;
		
		if (drive_state[current_drive].maxblock > user_params[drive].sect || drive_state[current_drive].maxtrack || ((user_params[drive].sect ^ oldStretch) & (FD_SWAPSIDES | FD_SECTBASEMASK)))


			invalidate_drive(bdev);
		else process_fd_request();
	}
	return 0;
}


static unsigned int ioctl_table[] = {
	FDCLRPRM, FDSETPRM, FDDEFPRM, FDGETPRM, FDMSGON, FDMSGOFF, FDFMTBEG, FDFMTTRK, FDFMTEND, FDSETEMSGTRESH, FDFLUSH, FDSETMAXERRS, FDGETMAXERRS, FDGETDRVTYP, FDSETDRVPRM, FDGETDRVPRM, FDGETDRVSTAT, FDPOLLDRVSTAT, FDRESET, FDGETFDCSTAT, FDWERRORCLR, FDWERRORGET, FDRAWCMD, FDEJECT, FDTWADDLE };

























static int normalize_ioctl(unsigned int *cmd, int *size)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {
		if ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {
			*size = _IOC_SIZE(*cmd);
			*cmd = ioctl_table[i];
			if (*size > _IOC_SIZE(*cmd)) {
				pr_info("ioctl not yet supported\n");
				return -EFAULT;
			}
			return 0;
		}
	}
	return -EINVAL;
}

static int get_floppy_geometry(int drive, int type, struct floppy_struct **g)
{
	if (type)
		*g = &floppy_type[type];
	else {
		if (lock_fdc(drive))
			return -EINTR;
		if (poll_drive(false, 0) == -EINTR)
			return -EINTR;
		process_fd_request();
		*g = current_type[drive];
	}
	if (!*g)
		return -ENODEV;
	return 0;
}

static int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)
{
	int drive = (long)bdev->bd_disk->private_data;
	int type = ITYPE(drive_state[drive].fd_device);
	struct floppy_struct *g;
	int ret;

	ret = get_floppy_geometry(drive, type, &g);
	if (ret)
		return ret;

	geo->heads = g->head;
	geo->sectors = g->sect;
	geo->cylinders = g->track;
	return 0;
}

static bool valid_floppy_drive_params(const short autodetect[FD_AUTODETECT_SIZE], int native_format)
{
	size_t floppy_type_size = ARRAY_SIZE(floppy_type);
	size_t i = 0;

	for (i = 0; i < FD_AUTODETECT_SIZE; ++i) {
		if (autodetect[i] < 0 || autodetect[i] >= floppy_type_size)
			return false;
	}

	if (native_format < 0 || native_format >= floppy_type_size)
		return false;

	return true;
}

static int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long param)
{
	int drive = (long)bdev->bd_disk->private_data;
	int type = ITYPE(drive_state[drive].fd_device);
	int i;
	int ret;
	int size;
	union inparam {
		struct floppy_struct g;	
		struct format_descr f;
		struct floppy_max_errors max_errors;
		struct floppy_drive_params dp;
	} inparam;		
	const void *outparam;	

	
	if (cmd == CDROMEJECT ||	 cmd == 0x6470) {
		DPRINT("obsolete eject ioctl\n");
		DPRINT("please use floppycontrol --eject\n");
		cmd = FDEJECT;
	}

	if (!((cmd & 0xff00) == 0x0200))
		return -EINVAL;

	
	ret = normalize_ioctl(&cmd, &size);
	if (ret)
		return ret;

	
	if (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) || ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))
		return -EPERM;

	if (WARN_ON(size < 0 || size > sizeof(inparam)))
		return -EINVAL;

	
	memset(&inparam, 0, sizeof(inparam));
	if (_IOC_DIR(cmd) & _IOC_WRITE) {
		ret = fd_copyin((void __user *)param, &inparam, size);
		if (ret)
			return ret;
	}

	switch (cmd) {
	case FDEJECT:
		if (drive_state[drive].fd_ref != 1)
			
			return -EBUSY;
		if (lock_fdc(drive))
			return -EINTR;

		
		ret = fd_eject(UNIT(drive));

		set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);
		set_bit(FD_VERIFY_BIT, &drive_state[drive].flags);
		process_fd_request();
		return ret;
	case FDCLRPRM:
		if (lock_fdc(drive))
			return -EINTR;
		current_type[drive] = NULL;
		floppy_sizes[drive] = MAX_DISK_SIZE << 1;
		drive_state[drive].keep_data = 0;
		return invalidate_drive(bdev);
	case FDSETPRM:
	case FDDEFPRM:
		return set_geometry(cmd, &inparam.g, drive, type, bdev);
	case FDGETPRM:
		ret = get_floppy_geometry(drive, type, (struct floppy_struct **)&outparam);
		if (ret)
			return ret;
		memcpy(&inparam.g, outparam, offsetof(struct floppy_struct, name));
		outparam = &inparam.g;
		break;
	case FDMSGON:
		drive_params[drive].flags |= FTD_MSG;
		return 0;
	case FDMSGOFF:
		drive_params[drive].flags &= ~FTD_MSG;
		return 0;
	case FDFMTBEG:
		if (lock_fdc(drive))
			return -EINTR;
		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
			return -EINTR;
		ret = drive_state[drive].flags;
		process_fd_request();
		if (ret & FD_VERIFY)
			return -ENODEV;
		if (!(ret & FD_DISK_WRITABLE))
			return -EROFS;
		return 0;
	case FDFMTTRK:
		if (drive_state[drive].fd_ref != 1)
			return -EBUSY;
		return do_format(drive, &inparam.f);
	case FDFMTEND:
	case FDFLUSH:
		if (lock_fdc(drive))
			return -EINTR;
		return invalidate_drive(bdev);
	case FDSETEMSGTRESH:
		drive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);
		return 0;
	case FDGETMAXERRS:
		outparam = &drive_params[drive].max_errors;
		break;
	case FDSETMAXERRS:
		drive_params[drive].max_errors = inparam.max_errors;
		break;
	case FDGETDRVTYP:
		outparam = drive_name(type, drive);
		SUPBOUND(size, strlen((const char *)outparam) + 1);
		break;
	case FDSETDRVPRM:
		if (!valid_floppy_drive_params(inparam.dp.autodetect, inparam.dp.native_format))
			return -EINVAL;
		drive_params[drive] = inparam.dp;
		break;
	case FDGETDRVPRM:
		outparam = &drive_params[drive];
		break;
	case FDPOLLDRVSTAT:
		if (lock_fdc(drive))
			return -EINTR;
		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
			return -EINTR;
		process_fd_request();
		fallthrough;
	case FDGETDRVSTAT:
		outparam = &drive_state[drive];
		break;
	case FDRESET:
		return user_reset_fdc(drive, (int)param, true);
	case FDGETFDCSTAT:
		outparam = &fdc_state[FDC(drive)];
		break;
	case FDWERRORCLR:
		memset(&write_errors[drive], 0, sizeof(write_errors[drive]));
		return 0;
	case FDWERRORGET:
		outparam = &write_errors[drive];
		break;
	case FDRAWCMD:
		if (type)
			return -EINVAL;
		if (lock_fdc(drive))
			return -EINTR;
		set_floppy(drive);
		i = raw_cmd_ioctl(cmd, (void __user *)param);
		if (i == -EINTR)
			return -EINTR;
		process_fd_request();
		return i;
	case FDTWADDLE:
		if (lock_fdc(drive))
			return -EINTR;
		twaddle(current_fdc, current_drive);
		process_fd_request();
		return 0;
	default:
		return -EINVAL;
	}

	if (_IOC_DIR(cmd) & _IOC_READ)
		return fd_copyout((void __user *)param, outparam, size);

	return 0;
}

static int fd_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long param)
{
	int ret;

	mutex_lock(&floppy_mutex);
	ret = fd_locked_ioctl(bdev, mode, cmd, param);
	mutex_unlock(&floppy_mutex);

	return ret;
}



struct compat_floppy_drive_params {
	char		cmos;
	compat_ulong_t	max_dtr;
	compat_ulong_t	hlt;
	compat_ulong_t	hut;
	compat_ulong_t	srt;
	compat_ulong_t	spinup;
	compat_ulong_t	spindown;
	unsigned char	spindown_offset;
	unsigned char	select_delay;
	unsigned char	rps;
	unsigned char	tracks;
	compat_ulong_t	timeout;
	unsigned char	interleave_sect;
	struct floppy_max_errors max_errors;
	char		flags;
	char		read_track;
	short		autodetect[FD_AUTODETECT_SIZE];
	compat_int_t	checkfreq;
	compat_int_t	native_format;
};

struct compat_floppy_drive_struct {
	signed char	flags;
	compat_ulong_t	spinup_date;
	compat_ulong_t	select_date;
	compat_ulong_t	first_read_date;
	short		probed_format;
	short		track;
	short		maxblock;
	short		maxtrack;
	compat_int_t	generation;
	compat_int_t	keep_data;
	compat_int_t	fd_ref;
	compat_int_t	fd_device;
	compat_int_t	last_checked;
	compat_caddr_t dmabuf;
	compat_int_t	bufblocks;
};

struct compat_floppy_fdc_state {
	compat_int_t	spec1;
	compat_int_t	spec2;
	compat_int_t	dtr;
	unsigned char	version;
	unsigned char	dor;
	compat_ulong_t	address;
	unsigned int	rawcmd:2;
	unsigned int	reset:1;
	unsigned int	need_configure:1;
	unsigned int	perp_mode:2;
	unsigned int	has_fifo:1;
	unsigned int	driver_version;
	unsigned char	track[4];
};

struct compat_floppy_write_errors {
	unsigned int	write_errors;
	compat_ulong_t	first_error_sector;
	compat_int_t	first_error_generation;
	compat_ulong_t	last_error_sector;
	compat_int_t	last_error_generation;
	compat_uint_t	badness;
};










static int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd, struct compat_floppy_struct __user *arg)
{
	struct floppy_struct v;
	int drive, type;
	int err;

	BUILD_BUG_ON(offsetof(struct floppy_struct, name) != offsetof(struct compat_floppy_struct, name));

	if (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))
		return -EPERM;

	memset(&v, 0, sizeof(struct floppy_struct));
	if (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))
		return -EFAULT;

	mutex_lock(&floppy_mutex);
	drive = (long)bdev->bd_disk->private_data;
	type = ITYPE(drive_state[drive].fd_device);
	err = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM, &v, drive, type, bdev);
	mutex_unlock(&floppy_mutex);
	return err;
}

static int compat_get_prm(int drive, struct compat_floppy_struct __user *arg)
{
	struct compat_floppy_struct v;
	struct floppy_struct *p;
	int err;

	memset(&v, 0, sizeof(v));
	mutex_lock(&floppy_mutex);
	err = get_floppy_geometry(drive, ITYPE(drive_state[drive].fd_device), &p);
	if (err) {
		mutex_unlock(&floppy_mutex);
		return err;
	}
	memcpy(&v, p, offsetof(struct floppy_struct, name));
	mutex_unlock(&floppy_mutex);
	if (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))
		return -EFAULT;
	return 0;
}

static int compat_setdrvprm(int drive, struct compat_floppy_drive_params __user *arg)
{
	struct compat_floppy_drive_params v;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	if (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))
		return -EFAULT;
	if (!valid_floppy_drive_params(v.autodetect, v.native_format))
		return -EINVAL;
	mutex_lock(&floppy_mutex);
	drive_params[drive].cmos = v.cmos;
	drive_params[drive].max_dtr = v.max_dtr;
	drive_params[drive].hlt = v.hlt;
	drive_params[drive].hut = v.hut;
	drive_params[drive].srt = v.srt;
	drive_params[drive].spinup = v.spinup;
	drive_params[drive].spindown = v.spindown;
	drive_params[drive].spindown_offset = v.spindown_offset;
	drive_params[drive].select_delay = v.select_delay;
	drive_params[drive].rps = v.rps;
	drive_params[drive].tracks = v.tracks;
	drive_params[drive].timeout = v.timeout;
	drive_params[drive].interleave_sect = v.interleave_sect;
	drive_params[drive].max_errors = v.max_errors;
	drive_params[drive].flags = v.flags;
	drive_params[drive].read_track = v.read_track;
	memcpy(drive_params[drive].autodetect, v.autodetect, sizeof(v.autodetect));
	drive_params[drive].checkfreq = v.checkfreq;
	drive_params[drive].native_format = v.native_format;
	mutex_unlock(&floppy_mutex);
	return 0;
}

static int compat_getdrvprm(int drive, struct compat_floppy_drive_params __user *arg)
{
	struct compat_floppy_drive_params v;

	memset(&v, 0, sizeof(struct compat_floppy_drive_params));
	mutex_lock(&floppy_mutex);
	v.cmos = drive_params[drive].cmos;
	v.max_dtr = drive_params[drive].max_dtr;
	v.hlt = drive_params[drive].hlt;
	v.hut = drive_params[drive].hut;
	v.srt = drive_params[drive].srt;
	v.spinup = drive_params[drive].spinup;
	v.spindown = drive_params[drive].spindown;
	v.spindown_offset = drive_params[drive].spindown_offset;
	v.select_delay = drive_params[drive].select_delay;
	v.rps = drive_params[drive].rps;
	v.tracks = drive_params[drive].tracks;
	v.timeout = drive_params[drive].timeout;
	v.interleave_sect = drive_params[drive].interleave_sect;
	v.max_errors = drive_params[drive].max_errors;
	v.flags = drive_params[drive].flags;
	v.read_track = drive_params[drive].read_track;
	memcpy(v.autodetect, drive_params[drive].autodetect, sizeof(v.autodetect));
	v.checkfreq = drive_params[drive].checkfreq;
	v.native_format = drive_params[drive].native_format;
	mutex_unlock(&floppy_mutex);

	if (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_params)))
		return -EFAULT;
	return 0;
}

static int compat_getdrvstat(int drive, bool poll, struct compat_floppy_drive_struct __user *arg)
{
	struct compat_floppy_drive_struct v;

	memset(&v, 0, sizeof(struct compat_floppy_drive_struct));
	mutex_lock(&floppy_mutex);

	if (poll) {
		if (lock_fdc(drive))
			goto Eintr;
		if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
			goto Eintr;
		process_fd_request();
	}
	v.spinup_date = drive_state[drive].spinup_date;
	v.select_date = drive_state[drive].select_date;
	v.first_read_date = drive_state[drive].first_read_date;
	v.probed_format = drive_state[drive].probed_format;
	v.track = drive_state[drive].track;
	v.maxblock = drive_state[drive].maxblock;
	v.maxtrack = drive_state[drive].maxtrack;
	v.generation = drive_state[drive].generation;
	v.keep_data = drive_state[drive].keep_data;
	v.fd_ref = drive_state[drive].fd_ref;
	v.fd_device = drive_state[drive].fd_device;
	v.last_checked = drive_state[drive].last_checked;
	v.dmabuf = (uintptr_t) drive_state[drive].dmabuf;
	v.bufblocks = drive_state[drive].bufblocks;
	mutex_unlock(&floppy_mutex);

	if (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))
		return -EFAULT;
	return 0;
Eintr:
	mutex_unlock(&floppy_mutex);
	return -EINTR;
}

static int compat_getfdcstat(int drive, struct compat_floppy_fdc_state __user *arg)
{
	struct compat_floppy_fdc_state v32;
	struct floppy_fdc_state v;

	mutex_lock(&floppy_mutex);
	v = fdc_state[FDC(drive)];
	mutex_unlock(&floppy_mutex);

	memset(&v32, 0, sizeof(struct compat_floppy_fdc_state));
	v32.spec1 = v.spec1;
	v32.spec2 = v.spec2;
	v32.dtr = v.dtr;
	v32.version = v.version;
	v32.dor = v.dor;
	v32.address = v.address;
	v32.rawcmd = v.rawcmd;
	v32.reset = v.reset;
	v32.need_configure = v.need_configure;
	v32.perp_mode = v.perp_mode;
	v32.has_fifo = v.has_fifo;
	v32.driver_version = v.driver_version;
	memcpy(v32.track, v.track, 4);
	if (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))
		return -EFAULT;
	return 0;
}

static int compat_werrorget(int drive, struct compat_floppy_write_errors __user *arg)
{
	struct compat_floppy_write_errors v32;
	struct floppy_write_errors v;

	memset(&v32, 0, sizeof(struct compat_floppy_write_errors));
	mutex_lock(&floppy_mutex);
	v = write_errors[drive];
	mutex_unlock(&floppy_mutex);
	v32.write_errors = v.write_errors;
	v32.first_error_sector = v.first_error_sector;
	v32.first_error_generation = v.first_error_generation;
	v32.last_error_sector = v.last_error_sector;
	v32.last_error_generation = v.last_error_generation;
	v32.badness = v.badness;
	if (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))
		return -EFAULT;
	return 0;
}

static int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long param)
{
	int drive = (long)bdev->bd_disk->private_data;
	switch (cmd) {
	case CDROMEJECT: 
	case 0x6470:	 

	case FDMSGON:
	case FDMSGOFF:
	case FDSETEMSGTRESH:
	case FDFLUSH:
	case FDWERRORCLR:
	case FDEJECT:
	case FDCLRPRM:
	case FDFMTBEG:
	case FDRESET:
	case FDTWADDLE:
		return fd_ioctl(bdev, mode, cmd, param);
	case FDSETMAXERRS:
	case FDGETMAXERRS:
	case FDGETDRVTYP:
	case FDFMTEND:
	case FDFMTTRK:
	case FDRAWCMD:
		return fd_ioctl(bdev, mode, cmd, (unsigned long)compat_ptr(param));
	case FDSETPRM32:
	case FDDEFPRM32:
		return compat_set_geometry(bdev, mode, cmd, compat_ptr(param));
	case FDGETPRM32:
		return compat_get_prm(drive, compat_ptr(param));
	case FDSETDRVPRM32:
		return compat_setdrvprm(drive, compat_ptr(param));
	case FDGETDRVPRM32:
		return compat_getdrvprm(drive, compat_ptr(param));
	case FDPOLLDRVSTAT32:
		return compat_getdrvstat(drive, true, compat_ptr(param));
	case FDGETDRVSTAT32:
		return compat_getdrvstat(drive, false, compat_ptr(param));
	case FDGETFDCSTAT32:
		return compat_getfdcstat(drive, compat_ptr(param));
	case FDWERRORGET32:
		return compat_werrorget(drive, compat_ptr(param));
	}
	return -EINVAL;
}


static void __init config_types(void)
{
	bool has_drive = false;
	int drive;

	
	drive = 0;
	if (!drive_params[drive].cmos)
		drive_params[drive].cmos = FLOPPY0_TYPE;
	drive = 1;
	if (!drive_params[drive].cmos)
		drive_params[drive].cmos = FLOPPY1_TYPE;

	

	for (drive = 0; drive < N_DRIVE; drive++) {
		unsigned int type = drive_params[drive].cmos;
		struct floppy_drive_params *params;
		const char *name = NULL;
		char temparea[32];

		if (type < ARRAY_SIZE(default_drive_params)) {
			params = &default_drive_params[type].params;
			if (type) {
				name = default_drive_params[type].name;
				allowed_drive_mask |= 1 << drive;
			} else allowed_drive_mask &= ~(1 << drive);
		} else {
			params = &default_drive_params[0].params;
			snprintf(temparea, sizeof(temparea), "unknown type %d (usb?)", type);
			name = temparea;
		}
		if (name) {
			const char *prepend;
			if (!has_drive) {
				prepend = "";
				has_drive = true;
				pr_info("Floppy drive(s):");
			} else {
				prepend = ",";
			}

			pr_cont("%s fd%d is %s", prepend, drive, name);
		}
		drive_params[drive] = *params;
	}

	if (has_drive)
		pr_cont("\n");
}

static void floppy_release(struct gendisk *disk, fmode_t mode)
{
	int drive = (long)disk->private_data;

	mutex_lock(&floppy_mutex);
	mutex_lock(&open_lock);
	if (!drive_state[drive].fd_ref--) {
		DPRINT("floppy_release with fd_ref == 0");
		drive_state[drive].fd_ref = 0;
	}
	if (!drive_state[drive].fd_ref)
		opened_bdev[drive] = NULL;
	mutex_unlock(&open_lock);
	mutex_unlock(&floppy_mutex);
}


static int floppy_open(struct block_device *bdev, fmode_t mode)
{
	int drive = (long)bdev->bd_disk->private_data;
	int old_dev, new_dev;
	int try;
	int res = -EBUSY;
	char *tmp;

	mutex_lock(&floppy_mutex);
	mutex_lock(&open_lock);
	old_dev = drive_state[drive].fd_device;
	if (opened_bdev[drive] && opened_bdev[drive] != bdev)
		goto out2;

	if (!drive_state[drive].fd_ref && (drive_params[drive].flags & FD_BROKEN_DCL)) {
		set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);
		set_bit(FD_VERIFY_BIT, &drive_state[drive].flags);
	}

	drive_state[drive].fd_ref++;

	opened_bdev[drive] = bdev;

	res = -ENXIO;

	if (!floppy_track_buffer) {
		
		if ((drive_params[drive].cmos == 6) || (drive_params[drive].cmos == 5))
			try = 64;	
		else try = 32;

		tmp = (char *)fd_dma_mem_alloc(1024 * try);
		if (!tmp && !floppy_track_buffer) {
			try >>= 1;	
			INFBOUND(try, 16);
			tmp = (char *)fd_dma_mem_alloc(1024 * try);
		}
		if (!tmp && !floppy_track_buffer)
			fallback_on_nodma_alloc(&tmp, 2048 * try);
		if (!tmp && !floppy_track_buffer) {
			DPRINT("Unable to allocate DMA memory\n");
			goto out;
		}
		if (floppy_track_buffer) {
			if (tmp)
				fd_dma_mem_free((unsigned long)tmp, try * 1024);
		} else {
			buffer_min = buffer_max = -1;
			floppy_track_buffer = tmp;
			max_buffer_sectors = try;
		}
	}

	new_dev = MINOR(bdev->bd_dev);
	drive_state[drive].fd_device = new_dev;
	set_capacity(disks[drive][ITYPE(new_dev)], floppy_sizes[new_dev]);
	if (old_dev != -1 && old_dev != new_dev) {
		if (buffer_drive == drive)
			buffer_track = -1;
	}

	if (fdc_state[FDC(drive)].rawcmd == 1)
		fdc_state[FDC(drive)].rawcmd = 2;

	if (!(mode & FMODE_NDELAY)) {
		if (mode & (FMODE_READ|FMODE_WRITE)) {
			drive_state[drive].last_checked = 0;
			clear_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);
			if (bdev_check_media_change(bdev))
				floppy_revalidate(bdev->bd_disk);
			if (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags))
				goto out;
			if (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags))
				goto out;
		}
		res = -EROFS;
		if ((mode & FMODE_WRITE) && !test_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags))
			goto out;
	}
	mutex_unlock(&open_lock);
	mutex_unlock(&floppy_mutex);
	return 0;
out:
	drive_state[drive].fd_ref--;

	if (!drive_state[drive].fd_ref)
		opened_bdev[drive] = NULL;
out2:
	mutex_unlock(&open_lock);
	mutex_unlock(&floppy_mutex);
	return res;
}


static unsigned int floppy_check_events(struct gendisk *disk, unsigned int clearing)
{
	int drive = (long)disk->private_data;

	if (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) || test_bit(FD_VERIFY_BIT, &drive_state[drive].flags))
		return DISK_EVENT_MEDIA_CHANGE;

	if (time_after(jiffies, drive_state[drive].last_checked + drive_params[drive].checkfreq)) {
		if (lock_fdc(drive))
			return 0;
		poll_drive(false, 0);
		process_fd_request();
	}

	if (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) || test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) || test_bit(drive, &fake_change) || drive_no_geom(drive))


		return DISK_EVENT_MEDIA_CHANGE;
	return 0;
}



struct rb0_cbdata {
	int drive;
	struct completion complete;
};

static void floppy_rb0_cb(struct bio *bio)
{
	struct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;
	int drive = cbdata->drive;

	if (bio->bi_status) {
		pr_info("floppy: error %d while reading block 0\n", bio->bi_status);
		set_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);
	}
	complete(&cbdata->complete);
}

static int __floppy_read_block_0(struct block_device *bdev, int drive)
{
	struct bio bio;
	struct bio_vec bio_vec;
	struct page *page;
	struct rb0_cbdata cbdata;

	page = alloc_page(GFP_NOIO);
	if (!page) {
		process_fd_request();
		return -ENOMEM;
	}

	cbdata.drive = drive;

	bio_init(&bio, bdev, &bio_vec, 1, REQ_OP_READ);
	bio_add_page(&bio, page, block_size(bdev), 0);

	bio.bi_iter.bi_sector = 0;
	bio.bi_flags |= (1 << BIO_QUIET);
	bio.bi_private = &cbdata;
	bio.bi_end_io = floppy_rb0_cb;

	init_completion(&cbdata.complete);

	submit_bio(&bio);
	process_fd_request();

	wait_for_completion(&cbdata.complete);

	__free_page(page);

	return 0;
}


static int floppy_revalidate(struct gendisk *disk)
{
	int drive = (long)disk->private_data;
	int cf;
	int res = 0;

	if (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) || test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) || test_bit(drive, &fake_change) || drive_no_geom(drive)) {


		if (WARN(atomic_read(&usage_count) == 0, "VFS: revalidate called on non-open device.\n"))
			return -EFAULT;

		res = lock_fdc(drive);
		if (res)
			return res;
		cf = (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) || test_bit(FD_VERIFY_BIT, &drive_state[drive].flags));
		if (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {
			process_fd_request();	
			return 0;
		}
		drive_state[drive].maxblock = 0;
		drive_state[drive].maxtrack = 0;
		if (buffer_drive == drive)
			buffer_track = -1;
		clear_bit(drive, &fake_change);
		clear_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);
		if (cf)
			drive_state[drive].generation++;
		if (drive_no_geom(drive)) {
			
			res = __floppy_read_block_0(opened_bdev[drive], drive);
		} else {
			if (cf)
				poll_drive(false, FD_RAW_NEED_DISK);
			process_fd_request();
		}
	}
	set_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);
	return res;
}

static const struct block_device_operations floppy_fops = {
	.owner			= THIS_MODULE, .open			= floppy_open, .release		= floppy_release, .ioctl			= fd_ioctl, .getgeo			= fd_getgeo, .check_events		= floppy_check_events,  .compat_ioctl		= fd_compat_ioctl,  };













static char __init get_fdc_version(int fdc)
{
	int r;

	output_byte(fdc, FD_DUMPREGS);	
	if (fdc_state[fdc].reset)
		return FDC_NONE;
	r = result(fdc);
	if (r <= 0x00)
		return FDC_NONE;	
	if ((r == 1) && (reply_buffer[ST0] == 0x80)) {
		pr_info("FDC %d is an 8272A\n", fdc);
		return FDC_8272A;	
	}
	if (r != 10) {
		pr_info("FDC %d init: DUMPREGS: unexpected return of %d bytes.\n", fdc, r);
		return FDC_UNKNOWN;
	}

	if (!fdc_configure(fdc)) {
		pr_info("FDC %d is an 82072\n", fdc);
		return FDC_82072;	
	}

	output_byte(fdc, FD_PERPENDICULAR);
	if (need_more_output(fdc) == MORE_OUTPUT) {
		output_byte(fdc, 0);
	} else {
		pr_info("FDC %d is an 82072A\n", fdc);
		return FDC_82072A;	
	}

	output_byte(fdc, FD_UNLOCK);
	r = result(fdc);
	if ((r == 1) && (reply_buffer[ST0] == 0x80)) {
		pr_info("FDC %d is a pre-1991 82077\n", fdc);
		return FDC_82077_ORIG;	
	}
	if ((r != 1) || (reply_buffer[ST0] != 0x00)) {
		pr_info("FDC %d init: UNLOCK: unexpected return of %d bytes.\n", fdc, r);
		return FDC_UNKNOWN;
	}
	output_byte(fdc, FD_PARTID);
	r = result(fdc);
	if (r != 1) {
		pr_info("FDC %d init: PARTID: unexpected return of %d bytes.\n", fdc, r);
		return FDC_UNKNOWN;
	}
	if (reply_buffer[ST0] == 0x80) {
		pr_info("FDC %d is a post-1991 82077\n", fdc);
		return FDC_82077;	
	}
	switch (reply_buffer[ST0] >> 5) {
	case 0x0:
		
		pr_info("FDC %d is an 82078.\n", fdc);
		return FDC_82078;
	case 0x1:
		pr_info("FDC %d is a 44pin 82078\n", fdc);
		return FDC_82078;
	case 0x2:
		pr_info("FDC %d is a S82078B\n", fdc);
		return FDC_S82078B;
	case 0x3:
		pr_info("FDC %d is a National Semiconductor PC87306\n", fdc);
		return FDC_87306;
	default:
		pr_info("FDC %d init: 82078 variant with unknown PARTID=%d.\n", fdc, reply_buffer[ST0] >> 5);
		return FDC_82078_UNKN;
	}
}				



static void __init floppy_set_flags(int *ints, int param, int param2)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {
		if (param)
			default_drive_params[i].params.flags |= param2;
		else default_drive_params[i].params.flags &= ~param2;
	}
	DPRINT("%s flag 0x%x\n", param2 ? "Setting" : "Clearing", param);
}

static void __init daring(int *ints, int param, int param2)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {
		if (param) {
			default_drive_params[i].params.select_delay = 0;
			default_drive_params[i].params.flags |= FD_SILENT_DCL_CLEAR;
		} else {
			default_drive_params[i].params.select_delay = 2 * HZ / 100;
			default_drive_params[i].params.flags &= ~FD_SILENT_DCL_CLEAR;
		}
	}
	DPRINT("Assuming %s floppy hardware\n", param ? "standard" : "broken");
}

static void __init set_cmos(int *ints, int dummy, int dummy2)
{
	int current_drive = 0;

	if (ints[0] != 2) {
		DPRINT("wrong number of parameters for CMOS\n");
		return;
	}
	current_drive = ints[1];
	if (current_drive < 0 || current_drive >= 8) {
		DPRINT("bad drive for set_cmos\n");
		return;
	}

	if (current_drive >= 4 && !FDC2)
		FDC2 = 0x370;

	drive_params[current_drive].cmos = ints[2];
	DPRINT("setting CMOS code to %d\n", ints[2]);
}

static struct param_table {
	const char *name;
	void (*fn) (int *ints, int param, int param2);
	int *var;
	int def_param;
	int param2;
} config_params[] __initdata = {
	{"allowed_drive_mask", NULL, &allowed_drive_mask, 0xff, 0},  {"all_drives", NULL, &allowed_drive_mask, 0xff, 0}, {"asus_pci", NULL, &allowed_drive_mask, 0x33, 0}, {"irq", NULL, &FLOPPY_IRQ, 6, 0}, {"dma", NULL, &FLOPPY_DMA, 2, 0}, {"daring", daring, NULL, 1, 0},  {"two_fdc", NULL, &FDC2, 0x370, 0}, {"one_fdc", NULL, &FDC2, 0, 0},  {"thinkpad", floppy_set_flags, NULL, 1, FD_INVERTED_DCL}, {"broken_dcl", floppy_set_flags, NULL, 1, FD_BROKEN_DCL}, {"messages", floppy_set_flags, NULL, 1, FTD_MSG}, {"silent_dcl_clear", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR}, {"debug", floppy_set_flags, NULL, 1, FD_DEBUG}, {"nodma", NULL, &can_use_virtual_dma, 1, 0}, {"omnibook", NULL, &can_use_virtual_dma, 1, 0}, {"yesdma", NULL, &can_use_virtual_dma, 0, 0}, {"fifo_depth", NULL, &fifo_depth, 0xa, 0}, {"nofifo", NULL, &no_fifo, 0x20, 0}, {"usefifo", NULL, &no_fifo, 0, 0}, {"cmos", set_cmos, NULL, 0, 0}, {"slow", NULL, &slow_floppy, 1, 0}, {"unexpected_interrupts", NULL, &print_unex, 1, 0}, {"no_unexpected_interrupts", NULL, &print_unex, 0, 0}, {"L40SX", NULL, &print_unex, 0, 0}

























	EXTRA_FLOPPY_PARAMS };

static int __init floppy_setup(char *str)
{
	int i;
	int param;
	int ints[11];

	str = get_options(str, ARRAY_SIZE(ints), ints);
	if (str) {
		for (i = 0; i < ARRAY_SIZE(config_params); i++) {
			if (strcmp(str, config_params[i].name) == 0) {
				if (ints[0])
					param = ints[1];
				else param = config_params[i].def_param;
				if (config_params[i].fn)
					config_params[i].fn(ints, param, config_params[i]. param2);

				if (config_params[i].var) {
					DPRINT("%s=%d\n", str, param);
					*config_params[i].var = param;
				}
				return 1;
			}
		}
	}
	if (str) {
		DPRINT("unknown floppy option [%s]\n", str);

		DPRINT("allowed options are:");
		for (i = 0; i < ARRAY_SIZE(config_params); i++)
			pr_cont(" %s", config_params[i].name);
		pr_cont("\n");
	} else DPRINT("botched floppy option\n");
	DPRINT("Read Documentation/admin-guide/blockdev/floppy.rst\n");
	return 0;
}

static int have_no_fdc = -ENODEV;

static ssize_t floppy_cmos_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct platform_device *p = to_platform_device(dev);
	int drive;

	drive = p->id;
	return sprintf(buf, "%X\n", drive_params[drive].cmos);
}

static DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);

static struct attribute *floppy_dev_attrs[] = {
	&dev_attr_cmos.attr, NULL };


ATTRIBUTE_GROUPS(floppy_dev);

static void floppy_device_release(struct device *dev)
{
}

static int floppy_resume(struct device *dev)
{
	int fdc;
	int saved_drive;

	saved_drive = current_drive;
	for (fdc = 0; fdc < N_FDC; fdc++)
		if (fdc_state[fdc].address != -1)
			user_reset_fdc(REVDRIVE(fdc, 0), FD_RESET_ALWAYS, false);
	set_fdc(saved_drive);
	return 0;
}

static const struct dev_pm_ops floppy_pm_ops = {
	.resume = floppy_resume, .restore = floppy_resume, };


static struct platform_driver floppy_driver = {
	.driver = {
		   .name = "floppy", .pm = &floppy_pm_ops, }, };



static const struct blk_mq_ops floppy_mq_ops = {
	.queue_rq = floppy_queue_rq, };

static struct platform_device floppy_device[N_DRIVE];
static bool registered[N_DRIVE];

static bool floppy_available(int drive)
{
	if (!(allowed_drive_mask & (1 << drive)))
		return false;
	if (fdc_state[FDC(drive)].version == FDC_NONE)
		return false;
	return true;
}

static int floppy_alloc_disk(unsigned int drive, unsigned int type)
{
	struct gendisk *disk;

	disk = blk_mq_alloc_disk(&tag_sets[drive], NULL);
	if (IS_ERR(disk))
		return PTR_ERR(disk);

	blk_queue_max_hw_sectors(disk->queue, 64);
	disk->major = FLOPPY_MAJOR;
	disk->first_minor = TOMINOR(drive) | (type << 2);
	disk->minors = 1;
	disk->fops = &floppy_fops;
	disk->flags |= GENHD_FL_NO_PART;
	disk->events = DISK_EVENT_MEDIA_CHANGE;
	if (type)
		sprintf(disk->disk_name, "fd%d_type%d", drive, type);
	else sprintf(disk->disk_name, "fd%d", drive);
	
	disk->private_data = (void *)(long)drive;
	disk->flags |= GENHD_FL_REMOVABLE;

	disks[drive][type] = disk;
	return 0;
}

static DEFINE_MUTEX(floppy_probe_lock);

static void floppy_probe(dev_t dev)
{
	unsigned int drive = (MINOR(dev) & 3) | ((MINOR(dev) & 0x80) >> 5);
	unsigned int type = (MINOR(dev) >> 2) & 0x1f;

	if (drive >= N_DRIVE || !floppy_available(drive) || type >= ARRAY_SIZE(floppy_type))
		return;

	mutex_lock(&floppy_probe_lock);
	if (disks[drive][type])
		goto out;
	if (floppy_alloc_disk(drive, type))
		goto out;
	if (add_disk(disks[drive][type]))
		goto cleanup_disk;
out:
	mutex_unlock(&floppy_probe_lock);
	return;

cleanup_disk:
	blk_cleanup_disk(disks[drive][type]);
	disks[drive][type] = NULL;
	mutex_unlock(&floppy_probe_lock);
}

static int __init do_floppy_init(void)
{
	int i, unit, drive, err;

	set_debugt();
	interruptjiffies = resultjiffies = jiffies;


	if (check_legacy_ioport(FDC1))
		return -ENODEV;


	raw_cmd = NULL;

	floppy_wq = alloc_ordered_workqueue("floppy", 0);
	if (!floppy_wq)
		return -ENOMEM;

	for (drive = 0; drive < N_DRIVE; drive++) {
		memset(&tag_sets[drive], 0, sizeof(tag_sets[drive]));
		tag_sets[drive].ops = &floppy_mq_ops;
		tag_sets[drive].nr_hw_queues = 1;
		tag_sets[drive].nr_maps = 1;
		tag_sets[drive].queue_depth = 2;
		tag_sets[drive].numa_node = NUMA_NO_NODE;
		tag_sets[drive].flags = BLK_MQ_F_SHOULD_MERGE;
		err = blk_mq_alloc_tag_set(&tag_sets[drive]);
		if (err)
			goto out_put_disk;

		err = floppy_alloc_disk(drive, 0);
		if (err)
			goto out_put_disk;

		timer_setup(&motor_off_timer[drive], motor_off_callback, 0);
	}

	err = __register_blkdev(FLOPPY_MAJOR, "fd", floppy_probe);
	if (err)
		goto out_put_disk;

	err = platform_driver_register(&floppy_driver);
	if (err)
		goto out_unreg_blkdev;

	for (i = 0; i < 256; i++)
		if (ITYPE(i))
			floppy_sizes[i] = floppy_type[ITYPE(i)].size;
		else floppy_sizes[i] = MAX_DISK_SIZE << 1;

	reschedule_timeout(MAXTIMEOUT, "floppy init");
	config_types();

	for (i = 0; i < N_FDC; i++) {
		memset(&fdc_state[i], 0, sizeof(*fdc_state));
		fdc_state[i].dtr = -1;
		fdc_state[i].dor = 0x4;

	

		if (MACH_IS_SUN3X)

			fdc_state[i].version = FDC_82072A;

	}

	use_virtual_dma = can_use_virtual_dma & 1;
	fdc_state[0].address = FDC1;
	if (fdc_state[0].address == -1) {
		cancel_delayed_work(&fd_timeout);
		err = -ENODEV;
		goto out_unreg_driver;
	}

	fdc_state[1].address = FDC2;


	current_fdc = 0;	
	err = floppy_grab_irq_and_dma();
	if (err) {
		cancel_delayed_work(&fd_timeout);
		err = -EBUSY;
		goto out_unreg_driver;
	}

	
	for (drive = 0; drive < N_DRIVE; drive++) {
		memset(&drive_state[drive], 0, sizeof(drive_state[drive]));
		memset(&write_errors[drive], 0, sizeof(write_errors[drive]));
		set_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);
		set_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);
		set_bit(FD_VERIFY_BIT, &drive_state[drive].flags);
		drive_state[drive].fd_device = -1;
		floppy_track_buffer = NULL;
		max_buffer_sectors = 0;
	}
	
	msleep(10);

	for (i = 0; i < N_FDC; i++) {
		fdc_state[i].driver_version = FD_DRIVER_VERSION;
		for (unit = 0; unit < 4; unit++)
			fdc_state[i].track[unit] = 0;
		if (fdc_state[i].address == -1)
			continue;
		fdc_state[i].rawcmd = 2;
		if (user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false)) {
			
			floppy_release_regions(i);
			fdc_state[i].address = -1;
			fdc_state[i].version = FDC_NONE;
			continue;
		}
		
		fdc_state[i].version = get_fdc_version(i);
		if (fdc_state[i].version == FDC_NONE) {
			
			floppy_release_regions(i);
			fdc_state[i].address = -1;
			continue;
		}
		if (can_use_virtual_dma == 2 && fdc_state[i].version < FDC_82072A)
			can_use_virtual_dma = 0;

		have_no_fdc = 0;
		
		user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false);
	}
	current_fdc = 0;
	cancel_delayed_work(&fd_timeout);
	current_drive = 0;
	initialized = true;
	if (have_no_fdc) {
		DPRINT("no floppy controllers found\n");
		err = have_no_fdc;
		goto out_release_dma;
	}

	for (drive = 0; drive < N_DRIVE; drive++) {
		if (!floppy_available(drive))
			continue;

		floppy_device[drive].name = floppy_device_name;
		floppy_device[drive].id = drive;
		floppy_device[drive].dev.release = floppy_device_release;
		floppy_device[drive].dev.groups = floppy_dev_groups;

		err = platform_device_register(&floppy_device[drive]);
		if (err)
			goto out_remove_drives;

		registered[drive] = true;

		err = device_add_disk(&floppy_device[drive].dev, disks[drive][0], NULL);
		if (err)
			goto out_remove_drives;
	}

	return 0;

out_remove_drives:
	while (drive--) {
		if (floppy_available(drive)) {
			del_gendisk(disks[drive][0]);
			if (registered[drive])
				platform_device_unregister(&floppy_device[drive]);
		}
	}
out_release_dma:
	if (atomic_read(&usage_count))
		floppy_release_irq_and_dma();
out_unreg_driver:
	platform_driver_unregister(&floppy_driver);
out_unreg_blkdev:
	unregister_blkdev(FLOPPY_MAJOR, "fd");
out_put_disk:
	destroy_workqueue(floppy_wq);
	for (drive = 0; drive < N_DRIVE; drive++) {
		if (!disks[drive][0])
			break;
		del_timer_sync(&motor_off_timer[drive]);
		blk_cleanup_disk(disks[drive][0]);
		blk_mq_free_tag_set(&tag_sets[drive]);
	}
	return err;
}


static __init void floppy_async_init(void *data, async_cookie_t cookie)
{
	do_floppy_init();
}


static int __init floppy_init(void)
{

	return do_floppy_init();

	
	async_schedule(floppy_async_init, NULL);
	return 0;

}

static const struct io_region {
	int offset;
	int size;
} io_regions[] = {
	{ 2, 1 },  { 4, 2 },  { 7, 1 }, };





static void floppy_release_allocated_regions(int fdc, const struct io_region *p)
{
	while (p != io_regions) {
		p--;
		release_region(fdc_state[fdc].address + p->offset, p->size);
	}
}



static int floppy_request_regions(int fdc)
{
	const struct io_region *p;

	for (p = io_regions; p < ARRAY_END(io_regions); p++) {
		if (!request_region(fdc_state[fdc].address + p->offset, p->size, "floppy")) {
			DPRINT("Floppy io-port 0x%04lx in use\n", fdc_state[fdc].address + p->offset);
			floppy_release_allocated_regions(fdc, p);
			return -EBUSY;
		}
	}
	return 0;
}

static void floppy_release_regions(int fdc)
{
	floppy_release_allocated_regions(fdc, ARRAY_END(io_regions));
}

static int floppy_grab_irq_and_dma(void)
{
	int fdc;

	if (atomic_inc_return(&usage_count) > 1)
		return 0;

	
	flush_workqueue(floppy_wq);

	if (fd_request_irq()) {
		DPRINT("Unable to grab IRQ%d for the floppy driver\n", FLOPPY_IRQ);
		atomic_dec(&usage_count);
		return -1;
	}
	if (fd_request_dma()) {
		DPRINT("Unable to grab DMA%d for the floppy driver\n", FLOPPY_DMA);
		if (can_use_virtual_dma & 2)
			use_virtual_dma = can_use_virtual_dma = 1;
		if (!(can_use_virtual_dma & 1)) {
			fd_free_irq();
			atomic_dec(&usage_count);
			return -1;
		}
	}

	for (fdc = 0; fdc < N_FDC; fdc++) {
		if (fdc_state[fdc].address != -1) {
			if (floppy_request_regions(fdc))
				goto cleanup;
		}
	}
	for (fdc = 0; fdc < N_FDC; fdc++) {
		if (fdc_state[fdc].address != -1) {
			reset_fdc_info(fdc, 1);
			fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);
		}
	}

	set_dor(0, ~0, 8);	

	for (fdc = 0; fdc < N_FDC; fdc++)
		if (fdc_state[fdc].address != -1)
			fdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);
	
	current_fdc = 0;
	irqdma_allocated = 1;
	return 0;
cleanup:
	fd_free_irq();
	fd_free_dma();
	while (--fdc >= 0)
		floppy_release_regions(fdc);
	current_fdc = 0;
	atomic_dec(&usage_count);
	return -1;
}

static void floppy_release_irq_and_dma(void)
{
	int fdc;

	int drive;

	long tmpsize;
	unsigned long tmpaddr;

	if (!atomic_dec_and_test(&usage_count))
		return;

	if (irqdma_allocated) {
		fd_disable_dma();
		fd_free_dma();
		fd_free_irq();
		irqdma_allocated = 0;
	}
	set_dor(0, ~0, 8);

	set_dor(1, ~8, 0);


	if (floppy_track_buffer && max_buffer_sectors) {
		tmpsize = max_buffer_sectors * 1024;
		tmpaddr = (unsigned long)floppy_track_buffer;
		floppy_track_buffer = NULL;
		max_buffer_sectors = 0;
		buffer_min = buffer_max = -1;
		fd_dma_mem_free(tmpaddr, tmpsize);
	}

	for (drive = 0; drive < N_FDC * 4; drive++)
		if (timer_pending(motor_off_timer + drive))
			pr_info("motor off timer %d still active\n", drive);


	if (delayed_work_pending(&fd_timeout))
		pr_info("floppy timer still active:%s\n", timeout_message);
	if (delayed_work_pending(&fd_timer))
		pr_info("auxiliary floppy timer still active\n");
	if (work_pending(&floppy_work))
		pr_info("work still pending\n");
	for (fdc = 0; fdc < N_FDC; fdc++)
		if (fdc_state[fdc].address != -1)
			floppy_release_regions(fdc);
}



static char *floppy;

static void __init parse_floppy_cfg_string(char *cfg)
{
	char *ptr;

	while (*cfg) {
		ptr = cfg;
		while (*cfg && *cfg != ' ' && *cfg != '\t')
			cfg++;
		if (*cfg) {
			*cfg = '\0';
			cfg++;
		}
		if (*ptr)
			floppy_setup(ptr);
	}
}

static int __init floppy_module_init(void)
{
	if (floppy)
		parse_floppy_cfg_string(floppy);
	return floppy_init();
}
module_init(floppy_module_init);

static void __exit floppy_module_exit(void)
{
	int drive, i;

	unregister_blkdev(FLOPPY_MAJOR, "fd");
	platform_driver_unregister(&floppy_driver);

	destroy_workqueue(floppy_wq);

	for (drive = 0; drive < N_DRIVE; drive++) {
		del_timer_sync(&motor_off_timer[drive]);

		if (floppy_available(drive)) {
			for (i = 0; i < ARRAY_SIZE(floppy_type); i++) {
				if (disks[drive][i])
					del_gendisk(disks[drive][i]);
			}
			if (registered[drive])
				platform_device_unregister(&floppy_device[drive]);
		}
		for (i = 0; i < ARRAY_SIZE(floppy_type); i++) {
			if (disks[drive][i])
				blk_cleanup_disk(disks[drive][i]);
		}
		blk_mq_free_tag_set(&tag_sets[drive]);
	}

	cancel_delayed_work_sync(&fd_timeout);
	cancel_delayed_work_sync(&fd_timer);

	if (atomic_read(&usage_count))
		floppy_release_irq_and_dma();

	
	fd_eject(0);
}

module_exit(floppy_module_exit);

module_param(floppy, charp, 0);
module_param(FLOPPY_IRQ, int, 0);
module_param(FLOPPY_DMA, int, 0);
MODULE_AUTHOR("Alain L. Knaff");
MODULE_LICENSE("GPL");


static const struct pnp_device_id floppy_pnpids[] = {
	{"PNP0700", 0}, {}
};

MODULE_DEVICE_TABLE(pnp, floppy_pnpids);



__setup("floppy=", floppy_setup);
module_init(floppy_init)


MODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);
