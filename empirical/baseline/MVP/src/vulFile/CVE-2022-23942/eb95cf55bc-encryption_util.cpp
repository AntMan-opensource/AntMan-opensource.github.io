
























namespace doris {

static const int ENCRYPTION_MAX_KEY_LENGTH = 256;

const EVP_CIPHER* get_evp_type(const EncryptionMode mode) {
    switch (mode) {
    case AES_128_ECB:
        return EVP_aes_128_ecb();
    case AES_128_CBC:
        return EVP_aes_128_cbc();
    case AES_128_CFB:
        return EVP_aes_128_cfb();
    case AES_128_CFB1:
        return EVP_aes_128_cfb1();
    case AES_128_CFB8:
        return EVP_aes_128_cfb8();
    case AES_128_CFB128:
        return EVP_aes_128_cfb128();
    case AES_128_CTR:
        return EVP_aes_128_ctr();
    case AES_128_OFB:
        return EVP_aes_128_ofb();
    case AES_192_ECB:
        return EVP_aes_192_ecb();
    case AES_192_CBC:
        return EVP_aes_192_cbc();
    case AES_192_CFB:
        return EVP_aes_192_cfb();
    case AES_192_CFB1:
        return EVP_aes_192_cfb1();
    case AES_192_CFB8:
        return EVP_aes_192_cfb8();
    case AES_192_CFB128:
        return EVP_aes_192_cfb128();
    case AES_192_CTR:
        return EVP_aes_192_ctr();
    case AES_192_OFB:
        return EVP_aes_192_ofb();
    case AES_256_ECB:
        return EVP_aes_256_ecb();
    case AES_256_CBC:
        return EVP_aes_256_cbc();
    case AES_256_CFB:
        return EVP_aes_256_cfb();
    case AES_256_CFB1:
        return EVP_aes_256_cfb1();
    case AES_256_CFB8:
        return EVP_aes_256_cfb8();
    case AES_256_CFB128:
        return EVP_aes_256_cfb128();
    case AES_256_CTR:
        return EVP_aes_256_ctr();
    case AES_256_OFB:
        return EVP_aes_256_ofb();
    case SM4_128_CBC:
        return EVP_sm4_cbc();
    case SM4_128_ECB:
        return EVP_sm4_ecb();
    case SM4_128_CFB128:
        return EVP_sm4_cfb128();
    case SM4_128_OFB:
        return EVP_sm4_ofb();
    case SM4_128_CTR:
        return EVP_sm4_ctr();
    default:
        return nullptr;
    }
}

static uint mode_key_sizes[] = {
        128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 192 , 256 , 128 , 128 , 128 , 128 , 128 };





























static void create_key(const unsigned char* origin_key, uint32_t key_length, uint8_t* encrypt_key, EncryptionMode mode) {
    const uint key_size = mode_key_sizes[mode] / 8;
    uint8_t* origin_key_end = ((uint8_t*)origin_key) + key_length; 

    uint8_t* encrypt_key_end; 
    encrypt_key_end = encrypt_key + key_size;

    std::memset(encrypt_key, 0, key_size); 

    uint8_t* ptr;        
    uint8_t* origin_ptr; 
    for (ptr = encrypt_key, origin_ptr = (uint8_t*)origin_key; origin_ptr < origin_key_end;
         ptr++, origin_ptr++) {
        if (ptr == encrypt_key_end) {
            
            ptr = encrypt_key;
        }
        *ptr ^= *origin_ptr;
    }
}

static int do_encrypt(EVP_CIPHER_CTX* cipher_ctx, const EVP_CIPHER* cipher, const unsigned char* source, uint32_t source_length, const unsigned char* encrypt_key, const unsigned char* iv, bool padding, unsigned char* encrypt, int* length_ptr) {


    int ret = EVP_EncryptInit(cipher_ctx, cipher, encrypt_key, iv);
    if (ret == 0) {
        return ret;
    }
    ret = EVP_CIPHER_CTX_set_padding(cipher_ctx, padding);
    if (ret == 0) {
        return ret;
    }
    int u_len = 0;
    ret = EVP_EncryptUpdate(cipher_ctx, encrypt, &u_len, source, source_length);
    if (ret == 0) {
        return ret;
    }
    int f_len = 0;
    ret = EVP_EncryptFinal(cipher_ctx, encrypt + u_len, &f_len);
    *length_ptr = u_len + f_len;
    return ret;
}

int EncryptionUtil::encrypt(EncryptionMode mode, const unsigned char* source, uint32_t source_length, const unsigned char* key, uint32_t key_length, const unsigned char* iv, bool padding, unsigned char* encrypt) {

    const EVP_CIPHER* cipher = get_evp_type(mode);
    
    unsigned char encrypt_key[ENCRYPTION_MAX_KEY_LENGTH / 8];
    create_key(key, key_length, encrypt_key, mode);

    if (cipher == nullptr || (EVP_CIPHER_iv_length(cipher) > 0 && !iv)) {
        return AES_BAD_DATA;
    }
    EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
    EVP_CIPHER_CTX_reset(cipher_ctx);
    int length = 0;
    int ret = do_encrypt(cipher_ctx, cipher, source, source_length, encrypt_key, iv, padding, encrypt, &length);
    EVP_CIPHER_CTX_free(cipher_ctx);
    if (ret == 0) {
        ERR_clear_error();
        return AES_BAD_DATA;
    } else {
        return length;
    }
}

static int do_decrypt(EVP_CIPHER_CTX* cipher_ctx, const EVP_CIPHER* cipher, const unsigned char* encrypt, uint32_t encrypt_length, const unsigned char* encrypt_key, const unsigned char* iv, bool padding, unsigned char* decrypt_content, int* length_ptr) {


    int ret = EVP_DecryptInit(cipher_ctx, cipher, encrypt_key, iv);
    if (ret == 0) {
        return ret;
    }
    ret = EVP_CIPHER_CTX_set_padding(cipher_ctx, padding);
    if (ret == 0) {
        return ret;
    }
    int u_len = 0;
    ret = EVP_DecryptUpdate(cipher_ctx, decrypt_content, &u_len, encrypt, encrypt_length);
    if (ret == 0) {
        return ret;
    }
    int f_len = 0;
    ret = EVP_DecryptFinal_ex(cipher_ctx, decrypt_content + u_len, &f_len);
    *length_ptr = u_len + f_len;
    return ret;
}

int EncryptionUtil::decrypt(EncryptionMode mode, const unsigned char* encrypt, uint32_t encrypt_length, const unsigned char* key, uint32_t key_length, const unsigned char* iv, bool padding, unsigned char* decrypt_content) {

    const EVP_CIPHER* cipher = get_evp_type(mode);

    
    unsigned char encrypt_key[ENCRYPTION_MAX_KEY_LENGTH / 8];
    create_key(key, key_length, encrypt_key, mode);

    if (cipher == nullptr || (EVP_CIPHER_iv_length(cipher) > 0 && !iv)) {
        return AES_BAD_DATA;
    }
    EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
    EVP_CIPHER_CTX_reset(cipher_ctx);
    int length = 0;
    int ret = do_decrypt(cipher_ctx, cipher, encrypt, encrypt_length, encrypt_key, iv, padding, decrypt_content, &length);
    EVP_CIPHER_CTX_free(cipher_ctx);
    if (ret > 0) {
        return length;
    } else {
        ERR_clear_error();
        return AES_BAD_DATA;
    }
}

} 
