



























namespace doris {
class FunctionContextImpl;
struct ColumnPtrWrapper;
struct StringValue;
class BitmapValue;
class DecimalV2Value;
class DateTimeValue;
struct CollectionValue;
} 

namespace doris_udf {




struct AnyVal;
struct BooleanVal;
struct TinyIntVal;
struct SmallIntVal;
struct IntVal;
struct BigIntVal;
struct StringVal;
struct DateTimeVal;
struct DecimalV2Val;
struct HllVal;
struct CollectionVal;




class FunctionContext {
public:
    enum DorisVersion {
        V2_0, };

    enum Type {
        INVALID_TYPE = 0, TYPE_NULL, TYPE_BOOLEAN, TYPE_TINYINT, TYPE_SMALLINT, TYPE_INT, TYPE_BIGINT, TYPE_LARGEINT, TYPE_FLOAT, TYPE_DOUBLE, TYPE_DECIMAL_DEPRACTED, TYPE_DATE, TYPE_DATETIME, TYPE_CHAR, TYPE_VARCHAR, TYPE_HLL, TYPE_STRING, TYPE_FIXED_BUFFER, TYPE_DECIMALV2, TYPE_OBJECT, TYPE_ARRAY };





















    struct TypeDesc {
        Type type;

        
        int precision;
        int scale;

        
        int len;

        
        std::vector<TypeDesc> children;
    };

    struct UniqueId {
        int64_t hi;
        int64_t lo;
    };

    enum FunctionStateScope {
        
        
        
        
        
        
        
        
        
        
        FRAGMENT_LOCAL,        THREAD_LOCAL, };









    
    DorisVersion version() const;

    
    
    const char* user() const;

    
    UniqueId query_id() const;

    
    
    
    
    void set_error(const char* error_msg);

    
    void clear_error_msg();

    
    
    
    
    bool add_warning(const char* warning_msg);

    
    bool has_error() const;

    
    const char* error_msg() const;

    
    
    
    
    
    uint8_t* allocate(int byte_size);

    
    
    
    
    
    uint8_t* reallocate(uint8_t* ptr, int byte_size);

    
    void free(uint8_t* buffer);

    
    
    
    
    void track_allocation(int64_t byte_size);
    void free(int64_t byte_size);

    
    
    

    

    

    
    
    doris::FunctionContextImpl* impl() { return _impl; }

    
    
    
    
    
    void set_function_state(FunctionStateScope scope, void* ptr);
    void* get_function_state(FunctionStateScope scope) const;

    
    
    const TypeDesc& get_return_type() const;

    
    
    const TypeDesc& get_intermediate_type() const;

    
    
    int get_num_args() const;

    
    int get_num_constant_args() const;

    
    
    const TypeDesc* get_arg_type(int arg_idx) const;

    
    
    bool is_arg_constant(int arg_idx) const;

    bool is_col_constant(int arg_idx) const;

    
    
    
    
    AnyVal* get_constant_arg(int arg_idx) const;

    doris::ColumnPtrWrapper* get_constant_col(int arg_idx) const;

    
    
    static FunctionContext* create_test_context();

    ~FunctionContext();

private:
    friend class doris::FunctionContextImpl;
    FunctionContext();

    
    FunctionContext(const FunctionContext& other);
    FunctionContext& operator=(const FunctionContext& other);

    doris::FunctionContextImpl* _impl; 
};






































typedef void (*UdfPrepareFn)(FunctionContext* context);













typedef void (*UdfPrepare)(FunctionContext* context, FunctionContext::FunctionStateScope scope);











typedef void (*UdfClose)(FunctionContext* context, FunctionContext::FunctionStateScope scope);





























typedef AnyVal InputType;
typedef AnyVal InputType2;
typedef AnyVal ResultType;
typedef AnyVal IntermediateType;



typedef void (*UdaInit)(FunctionContext* context, IntermediateType* result);




typedef void (*UdaUpdate)(FunctionContext* context, const InputType& input, IntermediateType* result);
typedef void (*UdaUpdate2)(FunctionContext* context, const InputType& input, const InputType2& input2, IntermediateType* result);


typedef void (*UdaMerge)(FunctionContext* context, const IntermediateType& src, IntermediateType* dst);





typedef const IntermediateType (*UdaSerialize)(FunctionContext* context, const IntermediateType& type);




typedef ResultType (*UdaFinalize)(FunctionContext* context, const IntermediateType& v);




struct AnyVal {
    bool is_null;
    AnyVal() : is_null(false) {}
    AnyVal(bool is_null) : is_null(is_null) {}
};

struct BooleanVal : public AnyVal {
    bool val;

    BooleanVal() : val(false) {}
    BooleanVal(bool val) : val(val) {}

    static BooleanVal null() {
        BooleanVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const BooleanVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const BooleanVal& other) const { return !(*this == other); }
};

struct TinyIntVal : public AnyVal {
    int8_t val;

    TinyIntVal() : val(0) {}
    TinyIntVal(int8_t val) : val(val) {}

    static TinyIntVal null() {
        TinyIntVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const TinyIntVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const TinyIntVal& other) const { return !(*this == other); }
};

struct SmallIntVal : public AnyVal {
    int16_t val;

    SmallIntVal() : val(0) {}
    SmallIntVal(int16_t val) : val(val) {}

    static SmallIntVal null() {
        SmallIntVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const SmallIntVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const SmallIntVal& other) const { return !(*this == other); }
};

struct IntVal : public AnyVal {
    int32_t val;

    IntVal() : val(0) {}
    IntVal(int32_t val) : val(val) {}

    static IntVal null() {
        IntVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const IntVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const IntVal& other) const { return !(*this == other); }
};

struct BigIntVal : public AnyVal {
    int64_t val;

    BigIntVal() : val(0) {}
    BigIntVal(int64_t val) : val(val) {}

    static BigIntVal null() {
        BigIntVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const BigIntVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const BigIntVal& other) const { return !(*this == other); }
};

struct FloatVal : public AnyVal {
    float val;

    FloatVal() : val(0.0) {}
    FloatVal(float val) : val(val) {}

    static FloatVal null() {
        FloatVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const FloatVal& other) const {
        return is_null == other.is_null && val == other.val;
    }
    bool operator!=(const FloatVal& other) const { return !(*this == other); }
};

struct DoubleVal : public AnyVal {
    double val;

    DoubleVal() : val(0.0) {}
    DoubleVal(double val) : val(val) {}

    static DoubleVal null() {
        DoubleVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const DoubleVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const DoubleVal& other) const { return !(*this == other); }
};


struct DateTimeVal : public AnyVal {
    
    int64_t packed_time;
    
    int type;

    
    DateTimeVal() : packed_time(0), type(3) {}

    static DateTimeVal null() {
        DateTimeVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const DateTimeVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return packed_time == other.packed_time;
    }
    bool operator!=(const DateTimeVal& other) const { return !(*this == other); }
};



struct StringVal : public AnyVal {
    static const int MAX_LENGTH = (1 << 30);

    int64_t len;
    uint8_t* ptr;

    
    
    StringVal() : len(0), ptr(nullptr) {}

    
    
    StringVal(uint8_t* ptr, int64_t len) : len(len), ptr(ptr) {}

    
    
    StringVal(const char* ptr) : len(strlen(ptr)), ptr((uint8_t*)ptr) {}

    static StringVal null() {
        StringVal sv;
        sv.is_null = true;
        return sv;
    }

    
    
    
    StringVal(FunctionContext* context, int64_t len);

    
    static StringVal create_temp_string_val(FunctionContext* ctx, int64_t len);

    bool resize(FunctionContext* context, int64_t len);

    bool operator==(const StringVal& other) const {
        if (is_null != other.is_null) {
            return false;
        }

        if (is_null) {
            return true;
        }

        if (len != other.len) {
            return false;
        }

        return len == 0 || ptr == other.ptr || memcmp(ptr, other.ptr, len) == 0;
    }

    bool operator!=(const StringVal& other) const { return !(*this == other); }

    
    
    
    static StringVal copy_from(FunctionContext* ctx, const uint8_t* buf, int64_t len);

    
    
    
    void append(FunctionContext* ctx, const uint8_t* buf, int64_t len);
    void append(FunctionContext* ctx, const uint8_t* buf, int64_t len, const uint8_t* buf2, int64_t buf2_len);
};

struct DecimalV2Val : public AnyVal {
    __int128 val;

    
    DecimalV2Val() : val(0) {}

    const __int128& value() const { return val; }

    DecimalV2Val(__int128 value) : val(value) {}

    static DecimalV2Val null() {
        DecimalV2Val result;
        result.is_null = true;
        return result;
    }

    void set_to_zero() { val = 0; }

    void set_to_abs_value() {
        if (val < 0) val = -val;
    }

    bool operator==(const DecimalV2Val& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }

    bool operator!=(const DecimalV2Val& other) const { return !(*this == other); }
};

struct LargeIntVal : public AnyVal {
    __int128 val;

    LargeIntVal() : val(0) {}

    LargeIntVal(__int128 large_value) : val(large_value) {}

    static LargeIntVal null() {
        LargeIntVal result;
        result.is_null = true;
        return result;
    }

    bool operator==(const LargeIntVal& other) const {
        if (is_null && other.is_null) {
            return true;
        }

        if (is_null || other.is_null) {
            return false;
        }

        return val == other.val;
    }
    bool operator!=(const LargeIntVal& other) const { return !(*this == other); }
};



struct HllVal : public StringVal {
    HllVal() : StringVal() {}

    void init(FunctionContext* ctx);

    void agg_parse_and_cal(FunctionContext* ctx, const HllVal& other);

    void agg_merge(const HllVal& other);
};

struct CollectionVal : public AnyVal {
    void* data;
    uint32_t length;
    
    
    bool has_null;
    
    bool* null_signs;

    CollectionVal() = default;

    CollectionVal(void* data, uint32_t length, bool has_null, bool* null_signs)
            : data(data), length(length), has_null(has_null), null_signs(null_signs) {};

    static CollectionVal null() {
        CollectionVal val;
        val.is_null = true;
        return val;
    }
};
typedef uint8_t* BufferVal;
} 

using doris_udf::BooleanVal;
using doris_udf::TinyIntVal;
using doris_udf::SmallIntVal;
using doris_udf::IntVal;
using doris_udf::BigIntVal;
using doris_udf::LargeIntVal;
using doris_udf::FloatVal;
using doris_udf::DoubleVal;
using doris_udf::StringVal;
using doris_udf::DecimalV2Val;
using doris_udf::DateTimeVal;
using doris_udf::HllVal;
using doris_udf::FunctionContext;
using doris_udf::CollectionVal;


