







NEARDATA struct flag flags;	

NEARDATA struct sysflag sysflags;	

NEARDATA struct instance_flags iflags;	


























static struct Bool_Opt {
	const char *name;
	boolean	*addr, initvalue;
	int optflags;
} boolopt[] = {
	{"acoustics", &flags.acoustics, TRUE, SET_IN_GAME},   {"altmeta", &sysflags.altmeta, TRUE, DISP_IN_GAME},    {"altmeta", &iflags.altmeta, FALSE, SET_IN_GAME},  {"altmeta", (boolean *)0, TRUE, DISP_IN_GAME},   {"ascii_map",     &iflags.wc_ascii_map, !PREFER_TILED, SET_IN_GAME},  {"asksavedisk", &sysflags.asksavedisk, FALSE, SET_IN_GAME},  {"asksavedisk", (boolean *)0, FALSE, SET_IN_FILE},  {"autodig", &flags.autodig, FALSE, SET_IN_GAME}, {"autopickup", &flags.pickup, TRUE, SET_IN_GAME}, {"autoquiver", &flags.autoquiver, FALSE, SET_IN_GAME},  {"BIOS", &iflags.BIOS, FALSE, SET_IN_FILE},  {"BIOS", (boolean *)0, FALSE, SET_IN_FILE},   {"checkpoint", &flags.ins_chkpt, TRUE, SET_IN_GAME},  {"checkpoint", (boolean *)0, FALSE, SET_IN_FILE},   {"checkspace", &iflags.checkspace, TRUE, SET_IN_GAME},  {"checkspace", (boolean *)0, FALSE, SET_IN_FILE},  {"clicklook", &iflags.clicklook, FALSE, SET_IN_GAME}, {"cmdassist", &iflags.cmdassist, TRUE, SET_IN_GAME},  {"color",	  &iflags.wc_color,TRUE, SET_IN_GAME},  {"color",	  &iflags.wc_color, FALSE, SET_IN_GAME},  {"confirm",&flags.confirm, TRUE, SET_IN_GAME}, {"eight_bit_tty", &iflags.wc_eight_bit_input, FALSE, SET_IN_GAME},  {"extmenu", &iflags.extmenu, FALSE, SET_IN_GAME},  {"extmenu", (boolean *)0, FALSE, SET_IN_FILE},   {"fast_map", &flags.fast_map, TRUE, SET_IN_GAME},  {"fast_map", (boolean *)0, TRUE, SET_IN_FILE},  {"female", &flags.female, FALSE, DISP_IN_GAME}, {"fixinv", &flags.invlet_constant, TRUE, SET_IN_GAME},  {"flush", &sysflags.amiflush, FALSE, SET_IN_GAME},  {"flush", (boolean *)0, FALSE, SET_IN_FILE},  {"fullscreen", &iflags.wc2_fullscreen, FALSE, SET_IN_FILE}, {"help", &flags.help, TRUE, SET_IN_GAME}, {"hilite_pet",    &iflags.wc_hilite_pet, FALSE, SET_IN_GAME},  {"ignintr", &flags.ignintr, FALSE, SET_IN_GAME},  {"ignintr", (boolean *)0, FALSE, SET_IN_FILE},  {"large_font", &iflags.obsolete, FALSE, SET_IN_FILE}, {"legacy", &flags.legacy, TRUE, DISP_IN_GAME}, {"lit_corridor", &flags.lit_corridor, FALSE, SET_IN_GAME}, {"lootabc", &flags.lootabc, FALSE, SET_IN_GAME},  {"mail", &flags.biff, TRUE, SET_IN_GAME},  {"mail", (boolean *)0, TRUE, SET_IN_FILE},    {"menu_tab_sep", &iflags.menu_tab_sep, FALSE, SET_IN_GAME},  {"menu_tab_sep", (boolean *)0, FALSE, SET_IN_FILE},  {"mouse_support", &iflags.wc_mouse_support, TRUE, DISP_IN_GAME},  {"news", &iflags.news, TRUE, DISP_IN_GAME},  {"news", (boolean *)0, FALSE, SET_IN_FILE},  {"null", &flags.null, TRUE, SET_IN_GAME},  {"page_wait", &sysflags.page_wait, TRUE, SET_IN_GAME},  {"page_wait", (boolean *)0, FALSE, SET_IN_FILE},  {"perm_invent", &flags.perm_invent, FALSE, SET_IN_GAME}, {"pickup_thrown", &flags.pickup_thrown, TRUE, SET_IN_GAME}, {"popup_dialog",  &iflags.wc_popup_dialog, FALSE, SET_IN_GAME}, {"preload_tiles", &iflags.wc_preload_tiles, TRUE, DISP_IN_GAME}, {"pushweapon", &flags.pushweapon, FALSE, SET_IN_GAME},  {"rawio", &iflags.rawio, FALSE, DISP_IN_GAME},  {"rawio", (boolean *)0, FALSE, SET_IN_FILE},  {"rest_on_space", &flags.rest_on_space, FALSE, SET_IN_GAME},  {"rlecomp", &iflags.rlecomp,  FALSE,  TRUE,  DISP_IN_GAME},  {"safe_pet", &flags.safe_dog, TRUE, SET_IN_GAME},  {"sanity_check", &iflags.sanity_check, FALSE, SET_IN_GAME},  {"sanity_check", (boolean *)0, FALSE, SET_IN_FILE},  {"selectsaved", &iflags.wc2_selectsaved, TRUE, DISP_IN_GAME},  {"showexp", &flags.showexp, FALSE, SET_IN_GAME},  {"showexp", (boolean *)0, FALSE, SET_IN_FILE},  {"showrace", &flags.showrace, FALSE, SET_IN_GAME},  {"showscore", &flags.showscore, FALSE, SET_IN_GAME},  {"showscore", (boolean *)0, FALSE, SET_IN_FILE},  {"silent", &flags.silent, TRUE, SET_IN_GAME}, {"softkeyboard", &iflags.wc2_softkeyboard, FALSE, SET_IN_FILE}, {"sortpack", &flags.sortpack, TRUE, SET_IN_GAME}, {"sparkle", &flags.sparkle, TRUE, SET_IN_GAME}, {"splash_screen", &iflags.wc_splash_screen, TRUE, DISP_IN_GAME}, {"standout", &flags.standout, FALSE, SET_IN_GAME}, {"tiled_map",     &iflags.wc_tiled_map, PREFER_TILED, DISP_IN_GAME}, {"time", &flags.time, FALSE, SET_IN_GAME},  {"timed_delay", &flags.nap, TRUE, SET_IN_GAME},  {"timed_delay", (boolean *)0, FALSE, SET_IN_GAME},  {"tombstone",&flags.tombstone, TRUE, SET_IN_GAME}, {"toptenwin",&flags.toptenwin, FALSE, SET_IN_GAME}, {"travel", &flags.travelcmd, TRUE, SET_IN_GAME},  {"unicode", &iflags.unicodedisp, FALSE, SET_IN_GAME},   {"use_inverse",   &iflags.wc_inverse, TRUE, SET_IN_GAME},  {"use_inverse",   &iflags.wc_inverse, FALSE, SET_IN_GAME},  {"verbose", &flags.verbose, TRUE, SET_IN_GAME}, {"wraptext", &iflags.wc2_wraptext, FALSE, SET_IN_GAME},  {"zerocomp", &iflags.zerocomp,  FALSE,  TRUE,  DISP_IN_GAME},  {(char *)0, (boolean *)0, FALSE, 0}









































































































































































};


static struct Comp_Opt {
	const char *name, *descr;
	int size;	
	int optflags;
} compopt[] = {
	{ "align",    "your starting alignment (lawful, neutral, or chaotic)", 8, DISP_IN_GAME }, { "align_message", "message window alignment", 20, DISP_IN_GAME }, { "align_status", "status window alignment", 20, DISP_IN_GAME }, { "altkeyhandler", "alternate key handler", 20, DISP_IN_GAME },  { "boulder",  "deprecated (use S_boulder in sym file instead)", 1, SET_IN_FILE },  { "catname",  "the name of your (first) cat (e.g., catname:Tabby)", PL_PSIZ, DISP_IN_GAME }, { "disclose", "the kinds of information to disclose at end of game", sizeof(flags.end_disclose) * 2, SET_IN_GAME }, { "dogname",  "the name of your (first) dog (e.g., dogname:Fang)", PL_PSIZ, DISP_IN_GAME }, { "dungeon",  "the symbols to use in drawing the dungeon map", MAXDCHARS+1, SET_IN_FILE }, { "effects",  "the symbols to use in drawing special effects", MAXECHARS+1, SET_IN_FILE }, { "font_map", "the font to use in the map window", 40, DISP_IN_GAME }, { "font_menu", "the font to use in menus", 40, DISP_IN_GAME }, { "font_message", "the font to use in the message window", 40, DISP_IN_GAME }, { "font_size_map", "the size of the map font", 20, DISP_IN_GAME }, { "font_size_menu", "the size of the menu font", 20, DISP_IN_GAME }, { "font_size_message", "the size of the message font", 20, DISP_IN_GAME }, { "font_size_status", "the size of the status font", 20, DISP_IN_GAME }, { "font_size_text", "the size of the text font", 20, DISP_IN_GAME }, { "font_status", "the font to use in status window", 40, DISP_IN_GAME }, { "font_text", "the font to use in text windows", 40, DISP_IN_GAME }, { "fruit",    "the name of a fruit you enjoy eating", PL_FSIZ, SET_IN_GAME }, { "gender",   "your starting gender (male or female)", 8, DISP_IN_GAME }, { "horsename", "the name of your (first) horse (e.g., horsename:Silver)", PL_PSIZ, DISP_IN_GAME }, { "map_mode", "map display mode under Windows", 20, DISP_IN_GAME }, { "menustyle", "user interface for object selection", MENUTYPELEN, SET_IN_GAME }, { "menu_deselect_all", "deselect all items in a menu", 4, SET_IN_FILE }, { "menu_deselect_page", "deselect all items on this page of a menu", 4, SET_IN_FILE }, { "menu_first_page", "jump to the first page in a menu", 4, SET_IN_FILE }, { "menu_headings", "bold, inverse, or underline headings", 9, SET_IN_GAME }, { "menu_invert_all", "invert all items in a menu", 4, SET_IN_FILE }, { "menu_invert_page", "invert all items on this page of a menu", 4, SET_IN_FILE }, { "menu_last_page", "jump to the last page in a menu", 4, SET_IN_FILE }, { "menu_next_page", "goto the next menu page", 4, SET_IN_FILE }, { "menu_previous_page", "goto the previous menu page", 4, SET_IN_FILE }, { "menu_search", "search for a menu item", 4, SET_IN_FILE }, { "menu_select_all", "select all items in a menu", 4, SET_IN_FILE }, { "menu_select_page", "select all items on this page of a menu", 4, SET_IN_FILE }, { "monsters", "the symbols to use for monsters", MAXMCLASSES, SET_IN_FILE }, { "msghistory", "number of top line messages to save", 5, DISP_IN_GAME },  {"msg_window", "the type of message window required",1, SET_IN_GAME},  {"msg_window", "the type of message window required", 1, SET_IN_FILE},  { "name",     "your character's name (e.g., name:Merlin-W)", PL_NSIZ, DISP_IN_GAME }, { "number_pad", "use the number pad for movement", 1, SET_IN_GAME}, { "objects",  "the symbols to use for objects", MAXOCLASSES, SET_IN_FILE }, { "packorder", "the inventory order of the items in your pack", MAXOCLASSES, SET_IN_GAME },  { "palette",  "palette (00c/880/-fff is blue/yellow/reverse white)", 15 , SET_IN_GAME },  "palette (adjust an RGB color in palette (color-R-G-B)", 15 , SET_IN_FILE },   { "hicolor",  "same as palette, only order is reversed", 15, SET_IN_FILE },   { "paranoid_confirmation", "extra prompting in certain situations", 28, SET_IN_GAME }, { "pettype",  "your preferred initial pet type", 4, DISP_IN_GAME }, { "pickup_burden",  "maximum burden picked up before prompt", 20, SET_IN_GAME }, { "pickup_types", "types of objects to pick up automatically", MAXOCLASSES, SET_IN_GAME }, { "pile_limit", "threshold for \"there are many objects here\"", 24, SET_IN_GAME }, { "playmode",  "normal play, non-scoring explore mode, or debug mode",  "normal play or non-scoring explore mode",  8, DISP_IN_GAME }, { "player_selection", "choose character via dialog or prompts", 12, DISP_IN_GAME }, { "race",     "your starting race (e.g., Human, Elf)", PL_CSIZ, DISP_IN_GAME }, { "role",     "your starting role (e.g., Barbarian, Valkyrie)", PL_CSIZ, DISP_IN_GAME }, { "runmode", "display frequency when `running' or `travelling'", sizeof "teleport", SET_IN_GAME }, { "scores",   "the parts of the score list you wish to see", 32, SET_IN_GAME }, { "scroll_amount", "amount to scroll map when scroll_margin is reached", 20, DISP_IN_GAME }, { "scroll_margin", "scroll map when this far from the edge", 20, DISP_IN_GAME },  { "soundcard", "type of sound card to use", 20, SET_IN_FILE },  { "symset", "load a set of display symbols from the symbols file", 70,  SET_IN_GAME },  DISP_IN_GAME},  { "roguesymset", "load a set of rogue display symbols from the symbols file", 70,   SET_IN_GAME },  DISP_IN_GAME},   SET_IN_FILE},  { "suppress_alert", "suppress alerts about version-specific features", 8, SET_IN_GAME }, { "tile_width", "width of tiles", 20, DISP_IN_GAME}, { "tile_height", "height of tiles", 20, DISP_IN_GAME}, { "tile_file", "name of tile file", 70, DISP_IN_GAME}, { "traps",    "the symbols to use in drawing traps", MAXTCHARS+1, SET_IN_FILE }, { "vary_msgcount", "show more old messages at a time", 20, DISP_IN_GAME },  { "video",    "method of video updating", 20, SET_IN_FILE },   { "videocolors", "color mappings for internal screen routines", 40, DISP_IN_GAME }, { "videoshades", "gray shades to map to black/gray/white", 32, DISP_IN_GAME },   {"subkeyvalue", "override keystroke value", 7, SET_IN_FILE},  { "windowcolors",  "the foreground/background colors of windows", 80, DISP_IN_GAME }, { "windowtype", "windowing system to use", WINTYPELEN, DISP_IN_GAME },  {"DECgraphics", "load DECGraphics display symbols", 70, SET_IN_FILE}, {"IBMgraphics", "load IBMGraphics display symbols", 70, SET_IN_FILE},  {"Macgraphics", "load MACGraphics display symbols", 70, SET_IN_FILE},   { (char *)0, (char *)0, 0, 0 }



































































































































































};






extern struct symparse loadsyms[];
static boolean need_redraw; 


extern boolean colors_changed;	



extern char *shade[3];		  
extern char ttycolors[CLR_MAX];	  


static char def_inv_order[MAXOCLASSES] = {
	COIN_CLASS, AMULET_CLASS, WEAPON_CLASS, ARMOR_CLASS, FOOD_CLASS, SCROLL_CLASS, SPBOOK_CLASS, POTION_CLASS, RING_CLASS, WAND_CLASS, TOOL_CLASS, GEM_CLASS, ROCK_CLASS, BALL_CLASS, CHAIN_CLASS, 0, };




typedef struct {
    const char *name;
    char cmd;
} menu_cmd_t;


static const menu_cmd_t default_menu_cmd_info[NUM_MENU_CMDS] = {
	{ "menu_first_page",	MENU_FIRST_PAGE }, { "menu_last_page",	MENU_LAST_PAGE }, { "menu_next_page",	MENU_NEXT_PAGE }, { "menu_previous_page",	MENU_PREVIOUS_PAGE }, { "menu_select_all",	MENU_SELECT_ALL }, { "menu_deselect_all",	MENU_UNSELECT_ALL }, { "menu_invert_all",	MENU_INVERT_ALL }, { "menu_select_page",	MENU_SELECT_PAGE }, { "menu_deselect_page",	MENU_UNSELECT_PAGE }, { "menu_invert_page",	MENU_INVERT_PAGE }, { "menu_search",		MENU_SEARCH }, };













       char mapped_menu_cmds[MAX_MENU_MAPPED_CMDS+1];	
static char mapped_menu_op[MAX_MENU_MAPPED_CMDS+1];
static short n_menu_mapped = 0;


static boolean initial, from_file;

STATIC_DCL void FDECL(doset_add_menu, (winid,const char *,int));
STATIC_DCL void FDECL(nmcpy, (char *, const char *, int));
STATIC_DCL void FDECL(escapes, (const char *, char *));
STATIC_DCL void FDECL(rejectoption, (const char *));
STATIC_DCL void FDECL(badoption, (const char *));
STATIC_DCL char *FDECL(string_for_opt, (char *,BOOLEAN_P));
STATIC_DCL char *FDECL(string_for_env_opt, (const char *, char *,BOOLEAN_P));
STATIC_DCL void FDECL(bad_negation, (const char *,BOOLEAN_P));
STATIC_DCL int FDECL(change_inv_order, (char *));
STATIC_DCL void FDECL(oc_to_str, (char *, char *));
STATIC_DCL int FDECL(feature_alert_opts, (char *, const char *));
STATIC_DCL const char *FDECL(get_compopt_value, (const char *, char *));
STATIC_DCL boolean FDECL(special_handling, (const char *, BOOLEAN_P, BOOLEAN_P));
STATIC_DCL void FDECL(warning_opts, (char *,const char *));
STATIC_DCL boolean FDECL(duplicate_opt_detection, (const char *, int));
STATIC_DCL void FDECL(complain_about_duplicate, (const char *, int));

STATIC_OVL void FDECL(wc_set_font_name, (int, char *));
STATIC_OVL int FDECL(wc_set_window_colors, (char *));
STATIC_OVL boolean FDECL(is_wc_option, (const char *));
STATIC_OVL boolean FDECL(wc_supported, (const char *));
STATIC_OVL boolean FDECL(is_wc2_option, (const char *));
STATIC_OVL boolean FDECL(wc2_supported, (const char *));

STATIC_DCL void FDECL(remove_autopickup_exception, (struct autopickup_exception *));
STATIC_OVL int FDECL(count_ape_maps, (int *, int *));



boolean match_optname(user_string, opt_name, min_length, val_allowed)
const char *user_string, *opt_name;
int min_length;
boolean val_allowed;
{
	int len = (int)strlen(user_string);

	if (val_allowed) {
	    const char *p = index(user_string, ':'), *q = index(user_string, '=');

	    if (!p || (q && q < p)) p = q;
	    while(p && p > user_string && isspace(*(p-1))) p--;
	    if (p) len = (int)(p - user_string);
	}

	return (len >= min_length) && !strncmpi(opt_name, user_string, len);
}


char * nh_getenv(ev)
const char *ev;
{
	char *getev = getenv(ev);

	if (getev && strlen(getev) <= (BUFSZ / 2))
		return getev;
	else return (char *)0;
}


void initoptions()
{
	initoptions_init();

	

	read_config_file(SYSCF_FILE, SET_IN_SYS);


	initoptions_finish();
}

void initoptions_init()
{

	char *opts;

	int i;

	
	reset_commands(TRUE);		

	
	setrandom();

	
	iflags.opt_booldup = iflags.opt_compdup = (int *)0;

	for (i = 0; boolopt[i].name; i++) {
		if (boolopt[i].addr)
			*(boolopt[i].addr) = boolopt[i].initvalue;
	}

	set_savepref("externalcomp");
	set_restpref("externalcomp");

	set_savepref("!rlecomp");
	set_restpref("!rlecomp");



	set_savepref("zerocomp");
	set_restpref("zerocomp");


	set_savepref("rlecomp");
	set_restpref("rlecomp");



	Strcpy(sysflags.sysflagsid, "sysflags");
	sysflags.sysflagsid[9] = (char)sizeof(struct sysflag);

	flags.end_own = FALSE;
	flags.end_top = 3;
	flags.end_around = 2;
	flags.paranoia_bits = PARANOID_PRAY;	
	flags.pile_limit = PILE_LIMIT_DFLT;	
	flags.runmode = RUN_LEAP;
	iflags.msg_history = 20;

	iflags.prevmsg_window = 's';

	iflags.unicodecapable = TRUE;


	iflags.menu_headings = ATR_INVERSE;

	
	flags.initrole = flags.initrace = flags.initgend = flags.initalign = ROLE_NONE;

	
	init_symbols();
	for (i = 0; i < WARNCOUNT; i++)
		warnsyms[i] = def_warnsyms[i].sym;
	iflags.bouldersym = 0;

	iflags.travelcc.x = iflags.travelcc.y = -1;

     
	(void)memcpy((genericptr_t)flags.inv_order, (genericptr_t)def_inv_order, sizeof flags.inv_order);
	flags.pickup_types[0] = '\0';
	flags.pickup_burden = MOD_ENCUMBER;

	for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++)
		flags.end_disclose[i] = DISCLOSE_PROMPT_DEFAULT_NO;
	switch_symbols(FALSE);	

	
	
	if ((opts = nh_getenv("TERM")) && !strncmp(opts, "AT", 2)) {

		if (!symset[PRIMARY].name) load_symset("IBMGraphics", PRIMARY);
		if (!symset[ROGUESET].name) load_symset("RogueIBM", ROGUESET);
		switch_symbols(TRUE);


		iflags.use_color = TRUE;

	}



	
	if ((opts = nh_getenv("TERM")) && !strncmpi(opts, "vt", 2) && AS && AE && index(AS, '\016') && index(AE, '\017')) {


		if (!symset[PRIMARY].name) load_symset("DECGraphics", PRIMARY);
		switch_symbols(TRUE);

	}




	if (!symset[PRIMARY].name) load_symset("MACGraphics", PRIMARY);
	switch_symbols(TRUE);

	flags.menu_style = MENU_FULL;

	
	objects[SLIME_MOLD].oc_name_idx = SLIME_MOLD;
	nmcpy(pl_fruit, OBJ_NAME(objects[SLIME_MOLD]), PL_FSIZ);
}

void initoptions_finish()
{

	char *opts = getenv("NETHACKOPTIONS");
	if (!opts) opts = getenv("HACKOPTIONS");
	if (opts) {
		if (*opts == '/' || *opts == '\\' || *opts == '@') {
			if (*opts == '@') opts++;	
			
			if (strlen(opts) < BUFSZ/2)
			    read_config_file(opts, SET_IN_FILE);
		} else {
			read_config_file((char *)0, SET_IN_FILE);
			
			parseoptions(opts, TRUE, FALSE);
		}
	} else  read_config_file((char *)0, SET_IN_FILE);


	(void)fruitadd(pl_fruit);
	
	
	
	
	obj_descr[SLIME_MOLD].oc_name = "fruit";

	return;
}

STATIC_OVL void nmcpy(dest, src, maxlen)
	char	*dest;
	const char *src;
	int	maxlen;
{
	int	count;

	for(count = 1; count < maxlen; count++) {
		if(*src == ',' || *src == '\0') break; 
		*dest++ = *src++;
	}
	*dest = 0;
}


STATIC_OVL void escapes(cp, tp)
const char	*cp;
char *tp;
{
    while (*cp) {
	int	cval = 0, meta = 0;

	if (*cp == '\\' && cp[1] && index("mM", cp[1]) && cp[2]) {
		meta = 1;
		cp += 2;
	}
	if (*cp == '\\' && cp[1] && index("0123456789xXoO", cp[1]) && cp[2]) {
	    NEARDATA const char hex[] = "00112233445566778899aAbBcCdDeEfF";
	    const char *dp;
	    int dcount = 0;

	    cp++;
	    if (*cp == 'x' || *cp == 'X')
		for (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)
		    cval = (cval * 16) + ((int)(dp - hex) / 2);
	    else if (*cp == 'o' || *cp == 'O')
		for (++cp; *cp && (index("01234567",*cp)) && (dcount++ < 3); cp++)
		    cval = (cval * 8) + (*cp - '0');
	    else for (; *cp && (index("0123456789",*cp)) && (dcount++ < 3); cp++)
		    cval = (cval * 10) + (*cp - '0');
	} else if (*cp == '\\' && cp[1]) {	
	    switch (*++cp) {
	    case '\\': cval = '\\'; break;
	    case 'n': cval = '\n'; break;
	    case 't': cval = '\t'; break;
	    case 'b': cval = '\b'; break;
	    case 'r': cval = '\r'; break;
	    default: cval = *cp;
	    }
	    cp++;
	} else if (*cp == '^' && cp[1]) { 
	    cval = (*++cp & 0x1f);
	    cp++;
	} else cval = *cp++;

	if (meta)
	    cval |= 0x80;
	*tp++ = cval;
    }
    *tp = '\0';
}

STATIC_OVL void rejectoption(optname)
const char *optname;
{

	pline("\"%s\" settable only from %s.", optname, configfile);

	pline("%s can be set only from NETHACKOPTIONS or %s.", optname, configfile);

}

STATIC_OVL void badoption(opts)
const char *opts;
{
	if (!initial) {
	    if (!strncmp(opts, "h", 1) || !strncmp(opts, "?", 1))
		option_help();
	    else pline("Bad syntax: %s.  Enter \"?g\" for help.", opts);
	    return;
	}

	else return;


	if(from_file)
	    raw_printf("Bad syntax in OPTIONS in %s: %s.", configfile, opts);
	else raw_printf("Bad syntax in NETHACKOPTIONS: %s.", opts);

	wait_synch();
}

STATIC_OVL char * string_for_opt(opts, val_optional)
char *opts;
boolean val_optional;
{
	char *colon, *equals;

	colon = index(opts, ':');
	equals = index(opts, '=');
	if (!colon || (equals && equals < colon)) colon = equals;

	if (!colon || !*++colon) {
		if (!val_optional) badoption(opts);
		return (char *)0;
	}
	return colon;
}

STATIC_OVL char * string_for_env_opt(optname, opts, val_optional)
const char *optname;
char *opts;
boolean val_optional;
{
	if(!initial) {
		rejectoption(optname);
		return (char *)0;
	}
	return string_for_opt(opts, val_optional);
}

STATIC_OVL void bad_negation(optname, with_parameter)
const char *optname;
boolean with_parameter;
{
	pline_The("%s option may not %sbe negated.", optname, with_parameter ? "both have a value and " : "");

}


STATIC_OVL int change_inv_order(op)
char *op;
{
    int oc_sym, num;
    char *sp, buf[BUFSZ];

    num = 0;

    if (!index(op, GOLD_SYM))
	buf[num++] = COIN_CLASS;

    


    for (sp = op; *sp; sp++) {
	oc_sym = def_char_to_objclass(*sp);
	
	if (oc_sym == MAXOCLASSES || oc_sym == RANDOM_CLASS || oc_sym == ILLOBJ_CLASS || !index(flags.inv_order, oc_sym) || index(sp+1, *sp))

	    return 0;
	
	buf[num++] = (char) oc_sym;
    }
    buf[num] = '\0';

    
    for (sp = flags.inv_order; *sp; sp++)
	if (!index(buf, *sp)) {
	    buf[num++] = *sp;
	    buf[num] = '\0';	
	}

    Strcpy(flags.inv_order, buf);
    return 1;
}

STATIC_OVL void warning_opts(opts, optype)
register char *opts;
const char *optype;
{
	uchar translate[MAXPCHARS+1];
	int length, i;

	if (!(opts = string_for_env_opt(optype, opts, FALSE)))
		return;
	escapes(opts, opts);

	length = strlen(opts);
	if (length > WARNCOUNT) length = WARNCOUNT;
	
	for (i = 0; i < length; i++)
	     translate[i] = (((i < WARNCOUNT) && opts[i]) ? (uchar) opts[i] : def_warnsyms[i].sym);
	assign_warnings(translate);
}

void assign_warnings(graph_chars)
register uchar *graph_chars;
{
	int i;
	for (i = 0; i < WARNCOUNT; i++)
	    if (graph_chars[i]) warnsyms[i] = graph_chars[i];
}

STATIC_OVL int feature_alert_opts(op, optn)
char *op;
const char *optn;
{
	char buf[BUFSZ];
	boolean rejectver = FALSE;
	unsigned long fnv = get_feature_notice_ver(op);		
	if (fnv == 0L) return 0;
	if (fnv > get_current_feature_ver())
		rejectver = TRUE;
	else flags.suppress_alert = fnv;
	if (rejectver) {
		if (!initial)
			You_cant("disable new feature alerts for future versions.");
		else {
			Sprintf(buf, "\n%s=%s Invalid reference to a future version ignored", optn, op);

			badoption(buf);
		}
		return 0;
	}
	if (!initial) {
		Sprintf(buf, "%lu.%lu.%lu", FEATURE_NOTICE_VER_MAJ, FEATURE_NOTICE_VER_MIN, FEATURE_NOTICE_VER_PATCH);
		pline("Feature change alerts disabled for NetHack %s features and prior.", buf);
	}
	return 1;
}

void set_duplicate_opt_detection(on_or_off)
int on_or_off;
{
	int k, *optptr;
	if (on_or_off != 0) {
		
		if (iflags.opt_booldup)
			impossible("iflags.opt_booldup already on (memory leak)");
		iflags.opt_booldup = (int *)alloc(SIZE(boolopt) * sizeof(int));
		optptr = iflags.opt_booldup;
		for (k = 0; k < SIZE(boolopt); ++k)
			*optptr++ = 0;

		if (iflags.opt_compdup)
			impossible("iflags.opt_compdup already on (memory leak)");
		iflags.opt_compdup = (int *)alloc(SIZE(compopt) * sizeof(int));
		optptr = iflags.opt_compdup;
		for (k = 0; k < SIZE(compopt); ++k)
			*optptr++ = 0;
	} else {
		
		if (iflags.opt_booldup) free((genericptr_t) iflags.opt_booldup);
		iflags.opt_booldup = (int *)0;
		if (iflags.opt_compdup) free((genericptr_t) iflags.opt_compdup);
		iflags.opt_compdup = (int *)0;
	}
}

STATIC_OVL boolean duplicate_opt_detection(opts, iscompound)
const char *opts;
int iscompound;	
{
	int i, *optptr;
	if (!iscompound && iflags.opt_booldup && initial && from_file) {
	    for (i = 0; boolopt[i].name; i++) {
		if (match_optname(opts, boolopt[i].name, 3, FALSE)) {
			optptr = iflags.opt_booldup + i;
			*optptr += 1;
			if (*optptr > 1) return TRUE;
			else return FALSE;
		}
	    }
	} else if (iscompound && iflags.opt_compdup && initial && from_file) {
	    for (i = 0; compopt[i].name; i++) {
		if (match_optname(opts, compopt[i].name, strlen(compopt[i].name), TRUE)) {
			optptr = iflags.opt_compdup + i;
			*optptr += 1;
			if (*optptr > 1) return TRUE;
			else return FALSE;
		}
	    }
	}
	return FALSE;
}

STATIC_OVL void complain_about_duplicate(opts, iscompound)
const char *opts;
int iscompound;		
{

	
	return;


	raw_printf( "\nWarning - %s option specified multiple times: %s.\n", iscompound ? "compound" : "boolean", opts);

	wait_synch();
	return;
}


STATIC_VAR const struct paranoia_opts {
	int flagmask;		
	const char *argname;	
	int argMinLen;		
	const char *synonym;	
	int synMinLen;
	const char *explain;	
} paranoia[] = {
	
	{ PARANOID_CONFIRM, "Confirm", 1, "Paranoia", 2, "for \"yes\" confirmations, require \"no\" to reject" }, { PARANOID_QUIT,    "quit", 1,    "explore", 1, "yes vs y to quit or to enter explore mode" }, { PARANOID_DIE,     "die", 1,     "death", 2,  "yes vs y to die (explore mode or debug mode)" },  "yes vs y to die (explore mode only)" },  { PARANOID_BONES,   "bones", 1,   0, 0,  "yes vs y to save bones data when dying in debug mode" },  "(only applicable for debug mode)" },  { PARANOID_HIT,     "attack", 1,  "hit", 1, "yes vs y to attack a peaceful monster" }, { PARANOID_PRAY,    "pray", 1,    0, 0, "y to pray (supersedes old \"prayconfirm\" option)" }, { PARANOID_REMOVE,  "Remove", 1,  "Takeoff", 1, "always pick from inventory for Remove and Takeoff" },  {  0, "none", 4, 0, 0, 0 }, { ~0, "all", 3, 0, 0, 0 }, };

























void parseoptions(opts, tinitial, tfrom_file)
register char *opts;
boolean tinitial, tfrom_file;
{
	register char *op;
	unsigned num;
	boolean negated, duplicate;
	int i;
	const char *fullname;

	initial = tinitial;
	from_file = tfrom_file;
	if ((op = index(opts, ',')) != 0) {
		*op++ = 0;
		parseoptions(op, initial, from_file);
	}
	if (strlen(opts) > BUFSZ/2) {
		badoption("option too long");
		return;
	}

	
	while (isspace(*opts)) opts++;
	op = eos(opts);
	while (--op >= opts && isspace(*op)) *op = '\0';

	if (!*opts) return;
	negated = FALSE;
	while ((*opts == '!') || !strncmpi(opts, "no", 2)) {
		if (*opts == '!') opts++; else opts += 2;
		negated = !negated;
	}

	

	if (match_optname(opts, "colour", 5, FALSE))
		Strcpy(opts, "color");	

	

	if (match_optname(opts, "female", 3, FALSE)) {
		if (duplicate_opt_detection(opts,0))
			complain_about_duplicate(opts,0);
		if(!initial && flags.female == negated)
			pline("That is not anatomically possible.");
		else flags.initgend = flags.female = !negated;
		return;
	}

	if (match_optname(opts, "male", 4, FALSE)) {
		if (duplicate_opt_detection(opts,0))
			complain_about_duplicate(opts,0);
		if(!initial && flags.female != negated)
			pline("That is not anatomically possible.");
		else flags.initgend = flags.female = negated;
		return;
	}


	
	if (match_optname(opts, "IBM_", 4, FALSE)) {
		iflags.BIOS = !negated;
		return;
	}


	

	

	
	fullname = "align";
	if (match_optname(opts, fullname, sizeof("align")-1, TRUE)) {
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
			boolean val_negated = FALSE;
			while ((*op == '!') || !strncmpi(op, "no", 2)) {
				if (*op == '!') op++; else op += 2;
				val_negated = !val_negated;
			}
			if (val_negated) {
				if (!setrolefilter(op))
					badoption(opts);
			} else {
				if (duplicate_opt_detection(opts,1))
					complain_about_duplicate(opts,1);
				if ((flags.initalign = str2align(op)) == ROLE_NONE)
					badoption(opts);
			}
		}
		return;
	}

	
	fullname = "role";
	if (match_optname(opts, fullname, 4, TRUE) || match_optname(opts, (fullname = "character"), 4, TRUE)) {
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
			boolean val_negated = FALSE;
			while ((*op == '!') || !strncmpi(op, "no", 2)) {
				if (*op == '!') op++; else op += 2;
				val_negated = !val_negated;
			}
			if (val_negated) {
				if (!setrolefilter(op))
					badoption(opts);
			} else {
				if (duplicate_opt_detection(opts,1))
					complain_about_duplicate(opts,1);
				if ((flags.initrole = str2role(op)) == ROLE_NONE)
					badoption(opts);
				else   nmcpy(pl_character, op, PL_NSIZ);
			}
		}
		return;
	}

	
	fullname = "race";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
			boolean val_negated = FALSE;
			while ((*op == '!') || !strncmpi(op, "no", 2)) {
				if (*op == '!') op++; else op += 2;
				val_negated = !val_negated;
			}
			if (val_negated) {
				if (!setrolefilter(op))
					badoption(opts);
			} else {
				if (duplicate_opt_detection(opts,1))
					complain_about_duplicate(opts,1);
				if ((flags.initrace = str2race(op)) == ROLE_NONE)
					badoption(opts);
				else  pl_race = *op;
			}
		}
		return;
	}

	
	fullname = "gender";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
			boolean val_negated = FALSE;
			while ((*op == '!') || !strncmpi(op, "no", 2)) {
				if (*op == '!') op++; else op += 2;
				val_negated = !val_negated;
			}
			if (val_negated) {
				if (!setrolefilter(op))
					badoption(opts);
			} else {
				if (duplicate_opt_detection(opts,1))
					complain_about_duplicate(opts,1);
				if ((flags.initgend = str2gend(op)) == ROLE_NONE)
					badoption(opts);
				else flags.female = flags.initgend;
			}
		}
		return;
	}

	

	duplicate = duplicate_opt_detection(opts,1);	

	fullname = "pettype";
	if (match_optname(opts, fullname, 3, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if ((op = string_for_env_opt(fullname, opts, negated)) != 0) {
		    if (negated) bad_negation(fullname, TRUE);
		    else switch (lowc(*op)) {
			case 'd':	
			    preferred_pet = 'd';
			    break;
			case 'c':	
			case 'f':	
			    preferred_pet = 'c';
			    break;
			case 'h':	
			case 'q':	
			    
			    preferred_pet = 'h';
			    break;
			case 'n':	
			    preferred_pet = 'n';
			    break;
			case '*':	
			    preferred_pet = '\0';
			    break;
			default:
			    pline("Unrecognized pet type '%s'.", op);
			    break;
		    }
		} else if (negated) preferred_pet = 'n';
		return;
	}

	fullname = "catname";
	if (match_optname(opts, fullname, 3, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
			nmcpy(catname, op, PL_PSIZ);
		return;
	}

	fullname = "dogname";
	if (match_optname(opts, fullname, 3, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
			nmcpy(dogname, op, PL_PSIZ);
		return;
	}

	fullname = "horsename";
	if (match_optname(opts, fullname, 5, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
			nmcpy(horsename, op, PL_PSIZ);
		return;
	}

	fullname = "number_pad";
	if (match_optname(opts, fullname, 10, TRUE)) {
		boolean compat = (strlen(opts) <= 10);

		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, (compat || !initial));
		if (!op) {
		    if (compat || negated || initial) {
			
			iflags.num_pad = !negated;
			iflags.num_pad_mode = 0;
		    }
		} else if (negated) {
		    bad_negation("number_pad", TRUE);
		    return;
		} else {
		    int mode = atoi(op);

		    if (mode < -1 || mode > 4 || (mode == 0 && *op != '0')) {
			badoption(opts);
			return;
		    } else if (mode <= 0) {
			iflags.num_pad = FALSE;
			
			iflags.num_pad_mode = (mode < 0);	
		    } else {	
			iflags.num_pad = TRUE;
			iflags.num_pad_mode = 0;
			
			if (mode == 2 || mode == 4) iflags.num_pad_mode |= 1;
			
			if (mode == 3 || mode == 4) iflags.num_pad_mode |= 2;
		    }
		}
		reset_commands(FALSE);
		number_pad(iflags.num_pad ? 1 : 0);
		return;
	}

	fullname = "roguesymset";
	if (match_optname(opts, fullname, 7, TRUE)) {

		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_opt(opts, FALSE)) != 0) {
		    symset[ROGUESET].name = (char *)alloc(strlen(op) + 1);
		    Strcpy(symset[ROGUESET].name, op);
		    if (!read_sym_file(ROGUESET)) {
		    	clear_symsetentry(ROGUESET, TRUE);
	    		raw_printf("Unable to load symbol set \"%s\" from \"%s\".", op, SYMBOLS);
			wait_synch();
		    } else {
			if (!initial && Is_rogue_level(&u.uz))
				assign_graphics(ROGUESET);
				need_redraw = TRUE;
		    }
		}

		return;
	}

	fullname = "symset";
	if (match_optname(opts, fullname, 6, TRUE)) {

		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_opt(opts, FALSE)) != 0) {
		    symset[PRIMARY].name = (char *)alloc(strlen(op) + 1);
		    Strcpy(symset[PRIMARY].name, op);
		    if (!read_sym_file(PRIMARY)) {
		    	clear_symsetentry(PRIMARY, TRUE);
	    		raw_printf("Unable to load symbol set \"%s\" from \"%s\".", op, SYMBOLS);
			wait_synch();
		    } else {
		    	switch_symbols(TRUE);
			need_redraw = TRUE;
		    }
		}

		return;
	}

	fullname = "runmode";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
		    flags.runmode = RUN_TPORT;
		} else if ((op = string_for_opt(opts, FALSE)) != 0) {
		    if (!strncmpi(op, "teleport", strlen(op)))
			flags.runmode = RUN_TPORT;
		    else if (!strncmpi(op, "run", strlen(op)))
			flags.runmode = RUN_LEAP;
		    else if (!strncmpi(op, "walk", strlen(op)))
			flags.runmode = RUN_STEP;
		    else if (!strncmpi(op, "crawl", strlen(op)))
			flags.runmode = RUN_CRAWL;
		    else badoption(opts);
		}
		return;
	}

	fullname = "msghistory";
	if (match_optname(opts, fullname, 3, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_env_opt(fullname, opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.msg_history = negated ? 0 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}

	fullname="msg_window";
	
	if (match_optname(opts, fullname, 4, TRUE)) {
	

		int tmp;
		if (duplicate) complain_about_duplicate(opts,1);
		if (!(op = string_for_opt(opts, TRUE))) {
		    tmp = negated ? 's' : 'f';
		} else {
		    if (negated) {
			bad_negation(fullname, TRUE);
			return;
		    }
		    tmp = tolower(*op);
		}
		switch (tmp) {
			case 's':	
				iflags.prevmsg_window = 's';
				break;
			case 'c':	
				iflags.prevmsg_window = 'c';
				break;
			case 'f':	
				iflags.prevmsg_window = 'f';
				break;
			case 'r':	
				iflags.prevmsg_window = 'r';
				break;
			default:
				badoption(opts);
		}

		return;
	}

	
	fullname = "font";
	if (!strncmpi(opts, fullname, 4)) {
		int opttype = -1;
		char *fontopts = opts + 4;

		if (!strncmpi(fontopts, "map", 3) || !strncmpi(fontopts, "_map", 4))
			opttype = MAP_OPTION;
		else if (!strncmpi(fontopts, "message", 7) || !strncmpi(fontopts, "_message", 8))
			opttype = MESSAGE_OPTION;
		else if (!strncmpi(fontopts, "text", 4) || !strncmpi(fontopts, "_text", 5))
			opttype = TEXT_OPTION;
		else if (!strncmpi(fontopts, "menu", 4) || !strncmpi(fontopts, "_menu", 5))
			opttype = MENU_OPTION;
		else if (!strncmpi(fontopts, "status", 6) || !strncmpi(fontopts, "_status", 7))
			opttype = STATUS_OPTION;
		else if (!strncmpi(fontopts, "_size", 5)) {
			if (!strncmpi(fontopts, "_size_map", 8))
				opttype = MAP_OPTION;
			else if (!strncmpi(fontopts, "_size_message", 12))
				opttype = MESSAGE_OPTION;
			else if (!strncmpi(fontopts, "_size_text", 9))
				opttype = TEXT_OPTION;
			else if (!strncmpi(fontopts, "_size_menu", 9))
				opttype = MENU_OPTION;
			else if (!strncmpi(fontopts, "_size_status", 11))
				opttype = STATUS_OPTION;
			else {
				badoption(opts);
				return;
			}
			if (duplicate) complain_about_duplicate(opts,1);
			if (opttype > 0 && !negated && (op = string_for_opt(opts, FALSE)) != 0) {
			    switch(opttype)  {
				case MAP_OPTION:
					iflags.wc_fontsiz_map = atoi(op);
					break;
				case MESSAGE_OPTION:
					iflags.wc_fontsiz_message = atoi(op);
					break;
				case TEXT_OPTION:
					iflags.wc_fontsiz_text = atoi(op);
					break;
				case MENU_OPTION:
					iflags.wc_fontsiz_menu = atoi(op);
					break;
				case STATUS_OPTION:
					iflags.wc_fontsiz_status = atoi(op);
					break;
			    }
			}
			return;
		} else {
			badoption(opts);
		}
		if (opttype > 0 && (op = string_for_opt(opts, FALSE)) != 0) {
			wc_set_font_name(opttype, op);

			set_font_name (opttype, op);

			return;
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}

	if (match_optname(opts, "palette", 3, TRUE)

	    || match_optname(opts, "hicolor", 3, TRUE)

							) {
	    int color_number, color_incr;


	    if (duplicate) complain_about_duplicate(opts,1);


	    if (match_optname(opts, "hicolor", 3, TRUE)) {
		if (negated) {
		    bad_negation("hicolor", FALSE);
		    return;
		}
		color_number = CLR_MAX + 4;	
		color_incr = -1;
	    } else {

		if (negated) {
		    bad_negation("palette", FALSE);
		    return;
		}
		color_number = 0;
		color_incr = 1;

	    }


	    op = string_for_opt(opts, TRUE);
	    if (!alternative_palette(op))
		badoption(opts);

	    if ((op = string_for_opt(opts, FALSE)) != (char *)0) {
		char *pt = op;
		int cnt, tmp, reverse;
		long rgb;

		while (*pt && color_number >= 0) {
		    cnt = 3;
		    rgb = 0L;
		    if (*pt == '-') {
			reverse = 1;
			pt++;
		    } else {
			reverse = 0;
		    }
		    while (cnt-- > 0) {
			if (*pt && *pt != '/') {

			    rgb <<= 4;

			    rgb <<= 8;

			    tmp = *(pt++);
			    if (isalpha(tmp)) {
				tmp = (tmp + 9) & 0xf;	
			    } else {
				tmp &= 0xf;	
			    }

			    
			    rgb += tmp << 4;

			    rgb += tmp;
			}
		    }
		    if (*pt == '/') {
			pt++;
		    }
		    change_color(color_number, rgb, reverse);
		    color_number += color_incr;
		}
	    }

	    if (!initial) {
		need_redraw = TRUE;
	    }
	    return;
	}


	if (match_optname(opts, "fruit", 2, TRUE)) {
		char empty_str = '\0';
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if (negated) {
		    if (op) {
			bad_negation("fruit", TRUE);
			return;
		    }
		    op = &empty_str;
		    goto goodfruit;
		}
		if (!op) return;
		if (!initial) {
		    struct fruit *f;

		    num = 0;
		    for(f=ffruit; f; f=f->nextf) {
			if (!strcmp(op, f->fname)) goto goodfruit;
			num++;
		    }
		    if (num >= 100) {
			pline("Doing that so many times isn't very fruitful.");
			return;
		    }
		}
goodfruit:
		nmcpy(pl_fruit, op, PL_FSIZ);
	
		if (!*pl_fruit)
		    nmcpy(pl_fruit, "slime mold", PL_FSIZ);
		if (!initial) {
		    (void)fruitadd(pl_fruit);
		    pline("Fruit is now \"%s\".", pl_fruit);
		}
		
		return;
	}

	fullname = "warnings";
	if (match_optname(opts, fullname, 5, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else warning_opts(opts, fullname);
		return;
	}


	
	fullname = "boulder";
	if (match_optname(opts, fullname, 7, TRUE)) {
		int clash = 0;
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
		    bad_negation(fullname, FALSE);
		    return;
		}

		if (!(opts = string_for_opt(opts, FALSE)))
			return;
		escapes(opts, opts);
		if (def_char_to_monclass(opts[0]) != MAXMCLASSES)
			clash = 1;
		else if (opts[0] >= '1' && opts[0] <= '5')
			clash = 2;
		if (clash) {
			
			pline( "Badoption - boulder symbol '%c' conflicts with a %s symbol.", opts[0], (clash == 1) ? "monster" : "warning");

		} else {
			
			iflags.bouldersym = (uchar) opts[0];
		}
		if (!initial) need_redraw = TRUE;
		return;
	}


	
	fullname = "name";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0)
			nmcpy(plname, op, PL_NSIZ);
		return;
	}

	
	fullname = "altkeyhandler";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) bad_negation(fullname, FALSE);
		else if ((op = string_for_opt(opts, negated))) {

		    (void)strncpy(iflags.altkeyhandler, op, MAX_ALTKEYHANDLER - 5);
		    load_keyboard_handler();

		}
		return;
	}

	
	fullname = "align_status";
	if (match_optname(opts, fullname, sizeof("align_status")-1, TRUE)) {
		op = string_for_opt(opts, negated);
		if (op && !negated) {
		    if (!strncmpi (op, "left", sizeof("left")-1))
			iflags.wc_align_status = ALIGN_LEFT;
		    else if (!strncmpi (op, "top", sizeof("top")-1))
			iflags.wc_align_status = ALIGN_TOP;
		    else if (!strncmpi (op, "right", sizeof("right")-1))
			iflags.wc_align_status = ALIGN_RIGHT;
		    else if (!strncmpi (op, "bottom", sizeof("bottom")-1))
			iflags.wc_align_status = ALIGN_BOTTOM;
		    else badoption(opts);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "align_message";
	if (match_optname(opts, fullname, sizeof("align_message")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if (op && !negated) {
		    if (!strncmpi (op, "left", sizeof("left")-1))
			iflags.wc_align_message = ALIGN_LEFT;
		    else if (!strncmpi (op, "top", sizeof("top")-1))
			iflags.wc_align_message = ALIGN_TOP;
		    else if (!strncmpi (op, "right", sizeof("right")-1))
			iflags.wc_align_message = ALIGN_RIGHT;
		    else if (!strncmpi (op, "bottom", sizeof("bottom")-1))
			iflags.wc_align_message = ALIGN_BOTTOM;
		    else badoption(opts);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "packorder";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
		    bad_negation(fullname, FALSE);
		    return;
		} else if (!(op = string_for_opt(opts, FALSE))) return;

		if (!change_inv_order(op))
			badoption(opts);
		return;
	}

	
	fullname = "paranoid_confirmation";
	if (match_optname(opts, fullname, 8, TRUE)) {
	    
	    flags.paranoia_bits = 0;	      
	    if (negated) {
		flags.paranoia_bits = 0;	
	    } else if ((op = string_for_opt(opts, TRUE)) != 0) {
		char *pp, buf[BUFSZ];

		op = mungspaces(strcpy(buf, op));
		for (;;) {
		    
		    pp = index(op, ' ');
		    if (pp) *pp = '\0';
		    
		    for (i = 0; i < SIZE(paranoia); ++i) {
			if (match_optname(op, paranoia[i].argname, paranoia[i].argMinLen, FALSE) || (paranoia[i].synonym && match_optname(op, paranoia[i].synonym, paranoia[i].synMinLen, FALSE))) {



			    if (paranoia[i].flagmask)
				flags.paranoia_bits |= paranoia[i].flagmask;
			    else	 flags.paranoia_bits = 0;
			    break;
			}
		    }
		    if (i == SIZE(paranoia)) {
			
			badoption(opts);
			break;
		    }
		    
		    if (pp) op = pp + 1;
		    else break;	
		} 
	    }
	    return;
	}

	
	fullname = "prayconfirm";
	if (match_optname(opts, fullname, 4, FALSE)) {
	    if (negated)
		flags.paranoia_bits &= ~PARANOID_PRAY;
	    else flags.paranoia_bits |= PARANOID_PRAY;
	    return;
	}

	
	fullname = "pickup_burden";
	if (match_optname(opts, fullname, 8, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		} else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
		    switch (tolower(*op)) {
				
				case 'u':
					flags.pickup_burden = UNENCUMBERED;
					break;
				
				case 'b':
					flags.pickup_burden = SLT_ENCUMBER;
					break;
				
				case 's':
					flags.pickup_burden = MOD_ENCUMBER;
					break;
				
				case 'n':
					flags.pickup_burden = HVY_ENCUMBER;
					break;
				
				case 'o':
				case 't':
					flags.pickup_burden = EXT_ENCUMBER;
					break;
				
				case 'l':
					flags.pickup_burden = OVERLOADED;
					break;
				default:
				badoption(opts);
		    }
		}
		return;
	}

	
	if (match_optname(opts, "pickup_types", 8, TRUE)) {
		char ocl[MAXOCLASSES + 1], tbuf[MAXOCLASSES + 1], qbuf[QBUFSZ], abuf[BUFSZ];
		int oc_sym;
		boolean badopt = FALSE, compat = (strlen(opts) <= 6), use_menu;

		if (duplicate) complain_about_duplicate(opts,1);
		oc_to_str(flags.pickup_types, tbuf);
		flags.pickup_types[0] = '\0';	
		op = string_for_opt(opts, (compat || !initial));
		if (!op) {
		    if (compat || negated || initial) {
			
			flags.pickup = !negated;
			return;
		    }
		    oc_to_str(flags.inv_order, ocl);
		    use_menu = TRUE;
		    if (flags.menu_style == MENU_TRADITIONAL || flags.menu_style == MENU_COMBINATION) {
			use_menu = FALSE;
			Sprintf(qbuf, "New pickup_types: [%s am] (%s)", ocl, *tbuf ? tbuf : "all");
			getlin(qbuf, abuf);
			op = mungspaces(abuf);
			if (abuf[0] == '\0' || abuf[0] == '\033')
			    op = tbuf;		
			else if (abuf[0] == 'm')
			    use_menu = TRUE;
		    }
		    if (use_menu) {
			(void) choose_classes_menu("Auto-Pickup what?", 1, TRUE, ocl, tbuf);
			op = tbuf;
		    }
		}
		if (negated) {
		    bad_negation("pickup_types", TRUE);
		    return;
		}
		while (*op == ' ') op++;
		if (*op != 'a' && *op != 'A') {
		    num = 0;
		    while (*op) {
			oc_sym = def_char_to_objclass(*op);
			
			if (oc_sym != MAXOCLASSES && !index(flags.pickup_types, oc_sym)) {
			    flags.pickup_types[num] = (char)oc_sym;
			    flags.pickup_types[++num] = '\0';
			} else badopt = TRUE;
			op++;
		    }
		    if (badopt) badoption(opts);
		}
		return;
	}

	
	fullname = "pile_limit";
	if (match_optname(opts, fullname, 4, TRUE)) {
	    if (duplicate) complain_about_duplicate(opts, 1);
	    op = string_for_opt(opts, negated);
	    if ((negated && !op) || (!negated && op))
		flags.pile_limit = negated ? 0 : atoi(op);
	    else if (negated)
		bad_negation(fullname, TRUE);
	    else  flags.pile_limit = PILE_LIMIT_DFLT;
	    
	    if (flags.pile_limit < 0) flags.pile_limit = PILE_LIMIT_DFLT;
	    return;
	}

	
	fullname = "playmode";
	if (match_optname(opts, fullname, 4, TRUE)) {
	    if (duplicate) complain_about_duplicate(opts, 1);
	    if (negated) bad_negation(fullname, FALSE);
	    if (duplicate || negated) return;
	    op = string_for_opt(opts, TRUE);
	    if (!strncmpi(op, "normal", 6) || !strcmpi(op, "play")) {
		wizard = discover = FALSE;
	    } else if (!strncmpi(op, "explore", 6) || !strncmpi(op, "discovery", 6)) {
		wizard = FALSE, discover = TRUE;
	    } else if (!strncmpi(op, "debug", 5) || !strncmpi(op, "wizard", 6)) {

		wizard = TRUE, discover = FALSE;

		raw_printf("\"%s\":%s -- debug mode not available.", fullname, op);

	    } else {
		raw_printf("Invalid value for \"%s\":%s.", fullname, op);
	    }
	    return;
	}

	
	fullname = "player_selection";
	if (match_optname(opts, fullname, sizeof("player_selection")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if (op && !negated) {
		    if (!strncmpi(op, "dialog", sizeof("dialog")-1))
			iflags.wc_player_selection = VIA_DIALOG;
		    else if (!strncmpi(op, "prompt", sizeof("prompt")-1))
			iflags.wc_player_selection = VIA_PROMPTS;
		    else badoption(opts);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}

	
	if (match_optname(opts, "disclose", 7, TRUE)) {
		
		boolean badopt = FALSE;
		int idx, prefix_val;

		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, TRUE);
		if (op && negated) {
			bad_negation("disclose", TRUE);
			return;
		}
		
		if (!op || !strcmpi(op, "all") || !strcmpi(op, "none")) {
			if (op && !strcmpi(op, "none")) negated = TRUE;
			for (num = 0; num < NUM_DISCLOSURE_OPTIONS; num++)
			    flags.end_disclose[num] = negated ? DISCLOSE_NO_WITHOUT_PROMPT :
						DISCLOSE_PROMPT_DEFAULT_YES;
			return;
		}

		num = 0;
		prefix_val = -1;
		while (*op && num < sizeof flags.end_disclose - 1) {
			register char c, *dop;
			static char valid_settings[] = {
				DISCLOSE_PROMPT_DEFAULT_YES, DISCLOSE_PROMPT_DEFAULT_NO, DISCLOSE_YES_WITHOUT_PROMPT, DISCLOSE_NO_WITHOUT_PROMPT, '\0' };




			c = lowc(*op);
			if (c == 'k') c = 'v';	
			dop = index(disclosure_options, c);
			if (dop) {
				idx = (int)(dop - disclosure_options);
				if (idx < 0 || idx > NUM_DISCLOSURE_OPTIONS - 1) {
				    impossible("bad disclosure index %d %c", idx, c);
				    continue;
				}
				if (prefix_val != -1) {
				    flags.end_disclose[idx] = prefix_val;
				    prefix_val = -1;
				} else flags.end_disclose[idx] = DISCLOSE_YES_WITHOUT_PROMPT;
			} else if (index(valid_settings, c)) {
				prefix_val = c;
			} else if (c == ' ') {
				;	
			} else badopt = TRUE;
			op++;
		}
		if (badopt) badoption(opts);
		return;
	}

	
	if (match_optname(opts, "scores", 4, TRUE)) {
	    if (duplicate) complain_about_duplicate(opts,1);
	    if (negated) {
		bad_negation("scores", FALSE);
		return;
	    }
	    if (!(op = string_for_opt(opts, FALSE))) return;

	    while (*op) {
		int inum = 1;

		if (digit(*op)) {
		    inum = atoi(op);
		    while (digit(*op)) op++;
		} else if (*op == '!') {
		    negated = !negated;
		    op++;
		}
		while (*op == ' ') op++;

		switch (*op) {
		 case 't':
		 case 'T':  flags.end_top = inum;
			    break;
		 case 'a':
		 case 'A':  flags.end_around = inum;
			    break;
		 case 'o':
		 case 'O':  flags.end_own = !negated;
			    break;
		 default:   badoption(opts);
			    return;
		}
		while (letter(*++op) || *op == ' ') continue;
		if (*op == '/') op++;
	    }
	    return;
	}

	fullname = "suppress_alert";
	if (match_optname(opts, fullname, 4, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if (negated) bad_negation(fullname, FALSE);
		else if (op) (void) feature_alert_opts(op,fullname);
		return;
	}


	
	fullname = "videocolors";
	if (match_optname(opts, fullname, 6, TRUE) || match_optname(opts, "videocolours", 10, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		}
		else if (!(opts = string_for_env_opt(fullname, opts, FALSE))) {
			return;
		}
		if (!assign_videocolors(opts))
			badoption(opts);
		return;
	}
	
	fullname = "videoshades";
	if (match_optname(opts, fullname, 6, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		}
		else if (!(opts = string_for_env_opt(fullname, opts, FALSE))) {
			return;
		}
		if (!assign_videoshades(opts))
			badoption(opts);
		return;
	}



	
	fullname = "video";
	if (match_optname(opts, fullname, 5, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		}
		else if (!(opts = string_for_env_opt(fullname, opts, FALSE))) {
			return;
		}
		if (!assign_video(opts))
			badoption(opts);
		return;
	}

	
	fullname = "soundcard";
	if (match_optname(opts, fullname, 6, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		}
		else if (!(opts = string_for_env_opt(fullname, opts, FALSE))) {
			return;
		}
		if (!assign_soundcard(opts))
			badoption(opts);
		return;
	}


	
	fullname = "map_mode";
	if (match_optname(opts, fullname, sizeof("map_mode")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if (op && !negated) {
		    if (!strncmpi (op, "tiles", sizeof("tiles")-1))
			iflags.wc_map_mode = MAP_MODE_TILES;
		    else if (!strncmpi (op, "ascii4x6", sizeof("ascii4x6")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII4x6;
		    else if (!strncmpi (op, "ascii6x8", sizeof("ascii6x8")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII6x8;
		    else if (!strncmpi (op, "ascii8x8", sizeof("ascii8x8")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII8x8;
		    else if (!strncmpi (op, "ascii16x8", sizeof("ascii16x8")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII16x8;
		    else if (!strncmpi (op, "ascii7x12", sizeof("ascii7x12")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII7x12;
		    else if (!strncmpi (op, "ascii8x12", sizeof("ascii8x12")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII8x12;
		    else if (!strncmpi (op, "ascii16x12", sizeof("ascii16x12")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII16x12;
		    else if (!strncmpi (op, "ascii12x16", sizeof("ascii12x16")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII12x16;
		    else if (!strncmpi (op, "ascii10x18", sizeof("ascii10x18")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII10x18;
		    else if (!strncmpi (op, "fit_to_screen", sizeof("fit_to_screen")-1))
			iflags.wc_map_mode = MAP_MODE_ASCII_FIT_TO_SCREEN;
		    else badoption(opts);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "scroll_amount";
	if (match_optname(opts, fullname, sizeof("scroll_amount")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.wc_scroll_amount = negated ? 1 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "scroll_margin";
	if (match_optname(opts, fullname, sizeof("scroll_margin")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.wc_scroll_margin = negated ? 5 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	fullname = "subkeyvalue";
	if (match_optname(opts, fullname, 5, TRUE)) {
		
		if (negated) bad_negation(fullname, FALSE);
		else {

			op = string_for_opt(opts, 0);
			map_subkeyvalue(op);

		}
		return;
	}
	
	fullname = "tile_width";
	if (match_optname(opts, fullname, sizeof("tile_width")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.wc_tile_width = negated ? 0 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "tile_file";
	if (match_optname(opts, fullname, sizeof("tile_file")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if ((op = string_for_opt(opts, FALSE)) != 0) {
			if (iflags.wc_tile_file) free(iflags.wc_tile_file);
			iflags.wc_tile_file = (char *)alloc(strlen(op) + 1);
			Strcpy(iflags.wc_tile_file, op);
		}
		return;
	}
	
	fullname = "tile_height";
	if (match_optname(opts, fullname, sizeof("tile_height")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.wc_tile_height = negated ? 0 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	
	fullname = "vary_msgcount";
	if (match_optname(opts, fullname, sizeof("vary_msgcount")-1, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, negated);
		if ((negated && !op) || (!negated && op)) {
			iflags.wc_vary_msgcount = negated ? 0 : atoi(op);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}
	fullname = "windowtype";
	if (match_optname(opts, fullname, 3, TRUE)) {
	    if (duplicate) complain_about_duplicate(opts,1);
	    if (negated) {
		bad_negation(fullname, FALSE);
		return;
	    } else if ((op = string_for_env_opt(fullname, opts, FALSE)) != 0) {
		char buf[WINTYPELEN];
		nmcpy(buf, op, WINTYPELEN);
		choose_windows(buf);
	    }
	    return;
	}

	
	fullname = "windowcolors";
	if (match_optname(opts, fullname, 7, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if ((op = string_for_opt(opts, FALSE)) != 0) {
			if (!wc_set_window_colors(op))
				badoption(opts);
		} else if (negated) bad_negation(fullname, TRUE);
		return;
	}

	
	if (match_optname(opts, "menustyle", 4, TRUE)) {
		int tmp;
		boolean val_required = (strlen(opts) > 5 && !negated);

		if (duplicate) complain_about_duplicate(opts,1);
		if (!(op = string_for_opt(opts, !val_required))) {
		    if (val_required) return; 
		    tmp = negated ? 'n' : 'f';
		} else {
		    tmp = tolower(*op);
		}
		switch (tmp) {
			case 'n':	
			case 't':	
				flags.menu_style = MENU_TRADITIONAL;
				break;
			case 'c':	
				flags.menu_style = MENU_COMBINATION;
				break;
			case 'p':	
				flags.menu_style = MENU_PARTIAL;
				break;
			case 'f':	
				flags.menu_style = MENU_FULL;
				break;
			default:
				badoption(opts);
		}
		return;
	}

	fullname = "menu_headings";
	if (match_optname(opts, fullname, 12, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		if (negated) {
			bad_negation(fullname, FALSE);
			return;
		}
		else if (!(opts = string_for_env_opt(fullname, opts, FALSE))) {
			return;
		}
		if (!strcmpi(opts,"bold"))
			iflags.menu_headings = ATR_BOLD;
		else if (!strcmpi(opts,"inverse"))
			iflags.menu_headings = ATR_INVERSE;
		else if (!strcmpi(opts,"underline"))
			iflags.menu_headings = ATR_ULINE;
		else badoption(opts);
		return;
	}

	
	for (i = 0; i < NUM_MENU_CMDS; i++) {
	    fullname = default_menu_cmd_info[i].name;
	    if (duplicate) complain_about_duplicate(opts,1);
	    if (match_optname(opts, fullname, (int)strlen(fullname), TRUE)) {
		if (negated)
		    bad_negation(fullname, FALSE);
		else if ((op = string_for_opt(opts, FALSE)) != 0) {
		    int j;
		    char c, op_buf[BUFSZ];
		    boolean isbad = FALSE;

		    escapes(op, op_buf);
		    c = *op_buf;

		    if (c == 0 || c == '\r' || c == '\n' || c == '\033' || c == ' ' || digit(c) || (letter(c) && c != '@'))
			isbad = TRUE;
		    else	 for (j = 1; j < MAXOCLASSES; j++)
			    if (c == def_oc_syms[i].sym) {
				isbad = TRUE;
				break;
			    }

		    if (isbad)
			badoption(opts);
		    else add_menu_cmd_alias(c, default_menu_cmd_info[i].cmd);
		}
		return;
	    }
	}

	
	if (match_optname(opts, "hilite_status", 13, TRUE)) {
		if (duplicate) complain_about_duplicate(opts,1);
		op = string_for_opt(opts, TRUE);
		if (op && negated) {
			clear_status_hilites();
			return;
		} else if (!op) {
			
			badoption(opts);
			return;
		}
		if (!set_status_hilites(op))
			badoption(opts);
		return;
	}



	fullname = "DECgraphics";
	if (match_optname(opts, fullname, 10, TRUE)) {
		boolean badflag = FALSE;

		if (duplicate) complain_about_duplicate(opts,1);
		if (!negated) {
		    
		    if (symset[PRIMARY].name)
			badflag = TRUE;
		    else {
			symset[PRIMARY].name = (char *)alloc(strlen(fullname) + 1);
			Strcpy(symset[PRIMARY].name, fullname);
			if (!read_sym_file(PRIMARY)) {
				badflag = TRUE;
				clear_symsetentry(PRIMARY, TRUE);
		        } else switch_symbols(TRUE);
		    }
		    if (badflag) {
		    	pline("Failure to load symbol set %s.", fullname);
			wait_synch();
		    }
		}

		return;
	}
	fullname = "IBMgraphics";
	if (match_optname(opts, fullname, 10, TRUE)) {
		const char *sym_name = fullname;
		boolean badflag = FALSE;

		if (duplicate) complain_about_duplicate(opts,1);
		if (!negated) {
		    for (i = PRIMARY; i <= ROGUESET; ++i) { 
			if (symset[i].name)
			    badflag = TRUE;
			else {
			    if (i == ROGUESET) sym_name = "RogueIBM";
			    symset[i].name = (char *)alloc(strlen(sym_name) + 1);
			    Strcpy(symset[i].name, sym_name);
			    if (!read_sym_file(i)) {
				badflag = TRUE;
				clear_symsetentry(i, TRUE);
				break;
			    }
			}
		    }
		    if (badflag) {
		    	pline("Failure to load symbol set %s.", sym_name);
			wait_synch();
		    } else {
			switch_symbols(TRUE);

			if (!initial && Is_rogue_level(&u.uz))
				assign_graphics(ROGUESET);

		    }
		}

		return;
	}


	fullname = "MACgraphics";
	if (match_optname(opts, fullname, 11, TRUE)) {
		boolean badflag = FALSE;

		if (duplicate) complain_about_duplicate(opts,1);
		if (!negated) {
		    if (symset[PRIMARY]).name badflag = TRUE;
		    else {
			symset[PRIMARY].name = (char *)alloc(strlen(fullname) + 1);
			Strcpy(symset[PRIMARY].name, fullname);
			if (!read_sym_file(PRIMARY)) {
				badflag = TRUE;
				clear_symsetentry(PRIMARY, TRUE);
		        }
		    }
		    if (badflag) {
		    	pline("Failure to load symbol set %s.", fullname);
			wait_synch();
		    } else {
			switch_symbols(TRUE);
			if (!initial && Is_rogue_level(&u.uz))
				assign_graphics(ROGUESET);
		    }
		}

		return;
	}

	
	for (i = 0; boolopt[i].name; i++) {
		if (match_optname(opts, boolopt[i].name, 3, FALSE)) {

			
			if (!boolopt[i].addr) {
			    if (!initial && !negated)
				pline_The("\"%s\" option is not available.", boolopt[i].name);
			    return;
			}
			
			if (!initial && (boolopt[i].optflags == SET_IN_FILE)) {
			    rejectoption(boolopt[i].name);
			    return;
			}

			*(boolopt[i].addr) = !negated;

			
			if (duplicate_opt_detection(boolopt[i].name, 0))
			    complain_about_duplicate(boolopt[i].name,0);


			if ((boolopt[i].addr) == &iflags.rlecomp) {
				if (*boolopt[i].addr)
					set_savepref("rlecomp");
				else set_savepref("!rlecomp");
			}


			if ((boolopt[i].addr) == &iflags.zerocomp) {
				if (*boolopt[i].addr)
					set_savepref("zerocomp");
				else set_savepref("externalcomp");
			}

			
			if (initial) return;

			if ((boolopt[i].addr) == &flags.time  || (boolopt[i].addr) == &flags.showexp   || (boolopt[i].addr) == &flags.showscore  ) {







			    status_initialize(REASSESS_ONLY);

			    context.botl = TRUE;
			}
			else if ((boolopt[i].addr) == &flags.invlet_constant) {
			    if (flags.invlet_constant) reassign();
			}
			else if ((boolopt[i].addr) == &flags.lit_corridor) {
			    
			    vision_recalc(2);		
			    vision_full_recalc = 1;	
			}
			else if ((boolopt[i].addr) == &iflags.use_inverse || (boolopt[i].addr) == &flags.showrace || (boolopt[i].addr) == &iflags.hilite_pet) {

			    need_redraw = TRUE;
			}

			else if ((boolopt[i].addr) == &iflags.use_color) {
			    need_redraw = TRUE;

			    if ((boolopt[i].addr) == &iflags.use_color && iflags.BIOS) {
				if (colors_changed)
				    restore_colors();
				else set_colors();
			    }

			}


			return;
		}
	}

	
	badoption(opts);
}

static NEARDATA const char *menutype[] = {
	"traditional", "combination", "partial", "full" };

static NEARDATA const char *burdentype[] = {
	"unencumbered", "burdened", "stressed", "strained", "overtaxed", "overloaded" };


static NEARDATA const char *runmodes[] = {
	"teleport", "run", "walk", "crawl" };


STATIC_OVL void oc_to_str(src,dest)
    char *src, *dest;
{
    int i;

    while ((i = (int) *src++) != 0) {
	if (i < 0 || i >= MAXOCLASSES)
	    impossible("oc_to_str:  illegal object class %d", i);
	else *dest++ = def_oc_syms[i].sym;
    }
    *dest = '\0';
}


void add_menu_cmd_alias(from_ch, to_ch)
    char from_ch, to_ch;
{
    if (n_menu_mapped >= MAX_MENU_MAPPED_CMDS)
	pline("out of menu map space.");
    else {
	mapped_menu_cmds[n_menu_mapped] = from_ch;
	mapped_menu_op[n_menu_mapped] = to_ch;
	n_menu_mapped++;
	mapped_menu_cmds[n_menu_mapped] = 0;
	mapped_menu_op[n_menu_mapped] = 0;
    }
}


char map_menu_cmd(ch)
    char ch;
{
    char *found = index(mapped_menu_cmds, ch);
    if (found) {
	int idx = (int)(found - mapped_menu_cmds);
	ch = mapped_menu_op[idx];
    }
    return ch;
}








static char fmtstr_doset_add_menu[] = "%s%-15s [%s]   ";
static char fmtstr_doset_add_menu_tab[] = "%s\t[%s]";

STATIC_OVL void doset_add_menu(win, option, indexoffset)
    winid win;			
    const char *option;		
    int indexoffset;		
{
    const char *value = "unknown";		
    char buf[BUFSZ], buf2[BUFSZ];
    anything any;
    int i;

    any = zeroany;
    if (indexoffset == 0) {
	any.a_int = 0;
	value = get_compopt_value(option, buf2);
    } else {
	for (i=0; compopt[i].name; i++)
	    if (strcmp(option, compopt[i].name) == 0) break;

	if (compopt[i].name) {
	    any.a_int = i + 1 + indexoffset;
	    value = get_compopt_value(option, buf2);
	} else {
	    
	    any.a_int = 0;
	}
    }
    
    if (!iflags.menu_tab_sep)
	Sprintf(buf, fmtstr_doset_add_menu, any.a_int ? "" : "    ", option, value);
    else Sprintf(buf, fmtstr_doset_add_menu_tab, option, value);
    add_menu(win, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
}


int doset()
{
	char buf[BUFSZ], buf2[BUFSZ];
	int i, pass, boolcount, pick_cnt, pick_idx, opt_indx;
	boolean *bool_p;
	winid tmpwin;
	anything any;
	menu_item *pick_list;
	int indexoffset, startpass, endpass;
	boolean setinitial = FALSE, fromfile = FALSE;
	int biggest_name = 0;

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);

	any = zeroany;
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings, "Booleans (selecting will toggle value):", MENU_UNSELECTED);
	any.a_int = 0;
	
	for (pass = 0; pass <= 1; pass++)
	    for (i = 0; boolopt[i].name; i++)
		if ((bool_p = boolopt[i].addr) != 0 && ((boolopt[i].optflags == DISP_IN_GAME && pass == 0) || (boolopt[i].optflags == SET_IN_GAME && pass == 1))) {

		    if (bool_p == &flags.female) continue;  

		    if (bool_p == &iflags.sanity_check && !wizard) continue;
		    if (bool_p == &iflags.menu_tab_sep && !wizard) continue;

		    if (is_wc_option(boolopt[i].name) && !wc_supported(boolopt[i].name)) continue;
		    if (is_wc2_option(boolopt[i].name) && !wc2_supported(boolopt[i].name)) continue;
		    any.a_int = (pass == 0) ? 0 : i + 1;
		    if (!iflags.menu_tab_sep)
			Sprintf(buf, "%s%-13s [%s]", pass == 0 ? "    " : "", boolopt[i].name, *bool_p ? "true" : "false");

		    else Sprintf(buf, "%s\t[%s]", boolopt[i].name, *bool_p ? "true" : "false");

		    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);
		}

	boolcount = i;
	indexoffset = boolcount;
	any = zeroany;
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings, "Compounds (selecting will prompt for new value):", MENU_UNSELECTED);




	if(wizard)
	    startpass = SET_IN_SYS;
	else  startpass = DISP_IN_GAME;

	endpass = SET_IN_GAME;

	
	biggest_name = 0;
	for (i = 0; compopt[i].name; i++)
		if (compopt[i].optflags >= startpass && compopt[i].optflags <= endpass && strlen(compopt[i].name) > (unsigned) biggest_name)
			biggest_name = (int) strlen(compopt[i].name);
	if (biggest_name > 30) biggest_name = 30;
	if (!iflags.menu_tab_sep)
		Sprintf(fmtstr_doset_add_menu, "%%s%%-%ds [%%s]", biggest_name);

	
	doset_add_menu(tmpwin, "playmode", 0);
	doset_add_menu(tmpwin, "name", 0);
	doset_add_menu(tmpwin, "role", 0);
	doset_add_menu(tmpwin, "race", 0);
	doset_add_menu(tmpwin, "gender", 0);

	for (pass = startpass; pass <= endpass; pass++)
	    for (i = 0; compopt[i].name; i++)
		if (compopt[i].optflags == pass) {
			if (!strcmp(compopt[i].name, "playmode") || !strcmp(compopt[i].name, "name") || !strcmp(compopt[i].name, "role") || !strcmp(compopt[i].name, "race") || !strcmp(compopt[i].name, "gender"))



				continue;
			else if (is_wc_option(compopt[i].name) && !wc_supported(compopt[i].name))
				continue;
			else if (is_wc2_option(compopt[i].name) && !wc2_supported(compopt[i].name))
				continue;
			else doset_add_menu(tmpwin, compopt[i].name, (pass == DISP_IN_GAME) ? 0 : indexoffset);

		}


	any.a_int = -2;
	get_status_hilites(buf2, 60);
	if (!iflags.menu_tab_sep)
		Sprintf(buf, fmtstr_doset_add_menu, any.a_int ? "" : "    ", "status_hilites", buf2);
	else Sprintf(buf, fmtstr_doset_add_menu_tab, "status_hilites", buf2);
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);



	any.a_int = -1;
	Sprintf(buf, "autopickup exceptions (%d currently set)", count_ape_maps((int *)0, (int *)0));
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, buf, MENU_UNSELECTED);


	any = zeroany;
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, "", MENU_UNSELECTED);
	add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings, "Variable playground locations:", MENU_UNSELECTED);
	for (i = 0; i < PREFIX_COUNT; i++)
		doset_add_menu(tmpwin, fqn_prefix_names[i], 0);

	end_menu(tmpwin, "Set what options?");
	need_redraw = FALSE;
	if ((pick_cnt = select_menu(tmpwin, PICK_ANY, &pick_list)) > 0) {
	    
	    for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
		opt_indx = pick_list[pick_idx].item.a_int - 1;

		if (opt_indx == -2) {	
		    (void)special_handling("autopickup_exception", setinitial, fromfile);
		} else    if (opt_indx == -3) {



			if (!status_hilite_menu())
				pline("Bad status hilite(s) specified.");
			else {
				if (wc2_supported("status_hilites"))
					preference_update("status_hilites");
			}
		} else   if (opt_indx < boolcount) {


		    
		    Sprintf(buf, "%s%s", *boolopt[opt_indx].addr ? "!" : "", boolopt[opt_indx].name);
		    parseoptions(buf, setinitial, fromfile);
		    if (wc_supported(boolopt[opt_indx].name) || wc2_supported(boolopt[opt_indx].name))
			preference_update(boolopt[opt_indx].name);
		} else {
		    
		    opt_indx -= boolcount;

		    if (!special_handling(compopt[opt_indx].name, setinitial, fromfile)) {
			Sprintf(buf, "Set %s to what?", compopt[opt_indx].name);
			getlin(buf, buf2);
			if (buf2[0] == '\033')
			    continue;
			Sprintf(buf, "%s:%s", compopt[opt_indx].name, buf2);
			
			parseoptions(buf, setinitial, fromfile);
		    }
		    if (wc_supported(compopt[opt_indx].name) || wc2_supported(compopt[opt_indx].name))
			preference_update(compopt[opt_indx].name);
		}
	    }
	    free((genericptr_t)pick_list);
	    pick_list = (menu_item *)0;
	}

	destroy_nhwindow(tmpwin);
	if (need_redraw)
	    (void) doredraw();
	return 0;
}


struct symsetentry *symset_list = 0;	


STATIC_OVL boolean special_handling(optname, setinitial, setfromfile)
const char *optname;
boolean setinitial,setfromfile;
{
    winid tmpwin;
    anything any;
    int i;
    char buf[BUFSZ];

    
    if (!strcmp("menustyle", optname)) {
	const char *style_name;
	menu_item *style_pick = (menu_item *)0;
	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	for (i = 0; i < SIZE(menutype); i++) {
		style_name = menutype[i];
		
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, *style_name, 0, ATR_NONE, style_name, MENU_UNSELECTED);
	}
	end_menu(tmpwin, "Select menustyle:");
	if (select_menu(tmpwin, PICK_ONE, &style_pick) > 0) {
		flags.menu_style = style_pick->item.a_int - 1;
		free((genericptr_t)style_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("paranoid_confirmation", optname)) {
	menu_item *paranoia_picks = (menu_item *)0;

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; paranoia[i].flagmask != 0; ++i) {
	    if (paranoia[i].flagmask == PARANOID_BONES && !wizard) continue;
	    any.a_int = paranoia[i].flagmask;
	    add_menu(tmpwin, NO_GLYPH, &any, *paranoia[i].argname, 0, ATR_NONE, paranoia[i].explain, (flags.paranoia_bits & paranoia[i].flagmask) ? MENU_SELECTED : MENU_UNSELECTED);


	}
	end_menu(tmpwin, "Actions requiring extra confirmation:");
	i = select_menu(tmpwin, PICK_ANY, &paranoia_picks);
	if (i >= 0) {
	    
	    flags.paranoia_bits = 0;
	    if (i > 0) {
		
		while (--i >= 0)
		    flags.paranoia_bits |= paranoia_picks[i].item.a_int;
		free((genericptr_t)paranoia_picks);
	    }
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("pickup_burden", optname)) {
	const char *burden_name, *burden_letters = "ubsntl";
	menu_item *burden_pick = (menu_item *)0;
	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < SIZE(burdentype); i++) {
		burden_name = burdentype[i];
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, burden_letters[i], 0, ATR_NONE, burden_name, MENU_UNSELECTED);
	}
	end_menu(tmpwin, "Select encumbrance level:");
	if (select_menu(tmpwin, PICK_ONE, &burden_pick) > 0) {
		flags.pickup_burden = burden_pick->item.a_int - 1;
		free((genericptr_t)burden_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("pickup_types", optname)) {
	
	parseoptions(strcpy(buf, "pickup_types"), setinitial, setfromfile);
    } else if (!strcmp("disclose", optname)) {
	int pick_cnt, pick_idx, opt_idx;
	menu_item *disclosure_category_pick = (menu_item *)0;
	
	static const char *disclosure_names[] = {
		"inventory", "attributes", "vanquished", "genocides", "conduct" };
	int disc_cat[NUM_DISCLOSURE_OPTIONS];
	const char *disclosure_name;

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
		disclosure_name = disclosure_names[i];
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, disclosure_options[i], 0, ATR_NONE, disclosure_name, MENU_UNSELECTED);
		disc_cat[i] = 0;
	}
	end_menu(tmpwin, "Change which disclosure options categories:");
	if ((pick_cnt = select_menu(tmpwin, PICK_ANY, &disclosure_category_pick)) > 0) {
	    for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
		opt_idx = disclosure_category_pick[pick_idx].item.a_int - 1;
		disc_cat[opt_idx] = 1;
	    }
	    free((genericptr_t)disclosure_category_pick);
	    disclosure_category_pick = (menu_item *)0;
	}
	destroy_nhwindow(tmpwin);

	for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
	    if (disc_cat[i]) {
		char dbuf[BUFSZ];
		menu_item *disclosure_option_pick = (menu_item *)0;

		Sprintf(dbuf, "Disclosure options for %s:", disclosure_names[i]);
		tmpwin = create_nhwindow(NHW_MENU);
		start_menu(tmpwin);
		any.a_char = DISCLOSE_NO_WITHOUT_PROMPT;
		add_menu(tmpwin, NO_GLYPH, &any, 'a', 0, ATR_NONE,"Never disclose and don't prompt", MENU_UNSELECTED);
		any = zeroany;
		any.a_char = DISCLOSE_YES_WITHOUT_PROMPT;
		add_menu(tmpwin, NO_GLYPH, &any, 'b', 0, ATR_NONE,"Always disclose and don't prompt", MENU_UNSELECTED);
		any = zeroany;
		any.a_char = DISCLOSE_PROMPT_DEFAULT_NO;
		add_menu(tmpwin, NO_GLYPH, &any, 'c', 0, ATR_NONE,"Prompt and default answer to \"No\"", MENU_UNSELECTED);
		any = zeroany;
		any.a_char = DISCLOSE_PROMPT_DEFAULT_YES;
		add_menu(tmpwin, NO_GLYPH, &any, 'd', 0, ATR_NONE,"Prompt and default answer to \"Yes\"", MENU_UNSELECTED);
		end_menu(tmpwin, dbuf);
		if (select_menu(tmpwin, PICK_ONE, &disclosure_option_pick) > 0) {
			flags.end_disclose[i] = disclosure_option_pick->item.a_char;
			free((genericptr_t)disclosure_option_pick);
		}
		destroy_nhwindow(tmpwin);
	    }
	}
    } else if (!strcmp("runmode", optname)) {
	const char *mode_name;
	menu_item *mode_pick = (menu_item *)0;
	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < SIZE(runmodes); i++) {
		mode_name = runmodes[i];
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, *mode_name, 0, ATR_NONE, mode_name, MENU_UNSELECTED);
	}
	end_menu(tmpwin, "Select run/travel display mode:");
	if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
		flags.runmode = mode_pick->item.a_int - 1;
		free((genericptr_t)mode_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("msg_window", optname)) {

	
	menu_item *window_pick = (menu_item *)0;
	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	any.a_char = 's';
	add_menu(tmpwin, NO_GLYPH, &any, 's', 0, ATR_NONE, "single", MENU_UNSELECTED);
	any.a_char = 'c';
	add_menu(tmpwin, NO_GLYPH, &any, 'c', 0, ATR_NONE, "combination", MENU_UNSELECTED);
	any.a_char = 'f';
	add_menu(tmpwin, NO_GLYPH, &any, 'f', 0, ATR_NONE, "full", MENU_UNSELECTED);
	any.a_char = 'r';
	add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "reversed", MENU_UNSELECTED);
	end_menu(tmpwin, "Select message history display type:");
	if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
		iflags.prevmsg_window = window_pick->item.a_char;
		free((genericptr_t)window_pick);
	}
	destroy_nhwindow(tmpwin);

    } else if (!strcmp("align_message", optname) || !strcmp("align_status", optname)) {
	menu_item *window_pick = (menu_item *)0;
	char abuf[BUFSZ];
	boolean msg = (*(optname+6) == 'm');

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	any.a_int = ALIGN_TOP;
	add_menu(tmpwin, NO_GLYPH, &any, 't', 0, ATR_NONE, "top", MENU_UNSELECTED);
	any.a_int = ALIGN_BOTTOM;
	add_menu(tmpwin, NO_GLYPH, &any, 'b', 0, ATR_NONE, "bottom", MENU_UNSELECTED);
	any.a_int = ALIGN_LEFT;
	add_menu(tmpwin, NO_GLYPH, &any, 'l', 0, ATR_NONE, "left", MENU_UNSELECTED);
	any.a_int = ALIGN_RIGHT;
	add_menu(tmpwin, NO_GLYPH, &any, 'r', 0, ATR_NONE, "right", MENU_UNSELECTED);
	Sprintf(abuf, "Select %s window placement relative to the map:", msg ? "message" : "status");
	end_menu(tmpwin, abuf);
	if (select_menu(tmpwin, PICK_ONE, &window_pick) > 0) {
		if (msg) iflags.wc_align_message = window_pick->item.a_int;
		else iflags.wc_align_status = window_pick->item.a_int;
		free((genericptr_t)window_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("number_pad", optname)) {
	static const char *npchoices[] = {
		" 0 (off)", " 1 (on)", " 2 (on, MSDOS compatible)", " 3 (on, phone-style digit layout)", " 4 (on, phone-style layout, MSDOS compatible)", "-1 (off, 'z' to move upper-left, 'y' to zap wands)" };



	menu_item *mode_pick = (menu_item *)0;

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < SIZE(npchoices); i++) {
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, 'a' + i, 0, ATR_NONE, npchoices[i], MENU_UNSELECTED);
	}
	end_menu(tmpwin, "Select number_pad mode:");
	if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
		switch (mode_pick->item.a_int - 1) {
		case 0: iflags.num_pad = FALSE; iflags.num_pad_mode = 0; break;
		case 1: iflags.num_pad = TRUE;  iflags.num_pad_mode = 0; break;
		case 2: iflags.num_pad = TRUE;  iflags.num_pad_mode = 1; break;
		case 3: iflags.num_pad = TRUE;  iflags.num_pad_mode = 2; break;
		case 4: iflags.num_pad = TRUE;  iflags.num_pad_mode = 3; break;
			
		case 5: iflags.num_pad = FALSE; iflags.num_pad_mode = 1; break;
		}
		reset_commands(FALSE);
		number_pad(iflags.num_pad ? 1 : 0);
		free((genericptr_t)mode_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("menu_headings", optname)) {
	static const char *mhchoices[3] = {"bold", "inverse", "underline";
	const char *npletters = "biu";
	menu_item *mode_pick = (menu_item *)0;

	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < SIZE(mhchoices); i++) {
		any.a_int = i + 1;
		add_menu(tmpwin, NO_GLYPH, &any, npletters[i], 0, ATR_NONE, mhchoices[i], MENU_UNSELECTED);
	}
	end_menu(tmpwin, "How to highlight menu headings:");
	if (select_menu(tmpwin, PICK_ONE, &mode_pick) > 0) {
		int mode = mode_pick->item.a_int - 1;
		switch(mode) {
			case 2:
				iflags.menu_headings = ATR_ULINE;
				break;
			case 0:
				iflags.menu_headings = ATR_BOLD;
				break;
			case 1:
			default:
				iflags.menu_headings = ATR_INVERSE;
		}
		free((genericptr_t)mode_pick);
	}
	destroy_nhwindow(tmpwin);
    } else if (!strcmp("autopickup_exception", optname)) {

	int pick_cnt, pick_idx, opt_idx, pass;
	int totalapes = 0, numapes[2] = {0,0};
	menu_item *pick_list = (menu_item *)0;
	char apebuf[1+BUFSZ];	
	struct autopickup_exception *ape;
	static const struct ape_action {
	    char letr;
	    const char *desc;
	} action_titles[] = {
	    { 'a', "add new autopickup exception" },		 { 'l', "list autopickup exceptions" }, { 'r', "remove existing autopickup exception" }, { 'x', "exit this menu" }, };




 ape_again:
	opt_idx = 0;
	totalapes = count_ape_maps(&numapes[AP_LEAVE], &numapes[AP_GRAB]);
	tmpwin = create_nhwindow(NHW_MENU);
	start_menu(tmpwin);
	any = zeroany;
	for (i = 0; i < SIZE(action_titles); i++) {
		any.a_int++;
		
		if (!totalapes && (i == 1 || i == 2)) continue;
		add_menu(tmpwin, NO_GLYPH, &any, action_titles[i].letr, 0, ATR_NONE, action_titles[i].desc,  (action_titles[i].letr == 'x') ? MENU_SELECTED :



			 MENU_UNSELECTED);
	}
	end_menu(tmpwin, "Do what?");
	if ((pick_cnt = select_menu(tmpwin, PICK_ONE, &pick_list)) > 0) {
		for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx) {
			opt_idx = pick_list[pick_idx].item.a_int - 1;
		}
		free((genericptr_t)pick_list);
		pick_list = (menu_item *)0;
	}
	destroy_nhwindow(tmpwin);

	if (pick_cnt < 1 || opt_idx == 3) {
		;	
	} else if (opt_idx == 0) {	
		getlin("What new autopickup exception pattern?", &apebuf[1]);
		mungspaces(&apebuf[1]);	
		if (apebuf[1] == '\033') {
		    ;	
		} else {
		    if (apebuf[1]) {
			apebuf[0] = '\"';
			
			apebuf[sizeof apebuf - 3] = '\0';
			Strcat(apebuf, "\"");
			add_autopickup_exception(apebuf);
		    }
		    goto ape_again;
		}
	} else {	
		tmpwin = create_nhwindow(NHW_MENU);
		start_menu(tmpwin);
		for (pass = AP_LEAVE; pass <= AP_GRAB; ++pass) {
		    if (numapes[pass] == 0) continue;
		    ape = iflags.autopickup_exceptions[pass];
		    any = zeroany;
		    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, iflags.menu_headings, (pass == 0) ? "Never pickup" : "Always pickup", MENU_UNSELECTED);

		    for (i = 0; i < numapes[pass] && ape; i++) {
			any.a_void = (opt_idx == 1) ? 0 : ape;
			Sprintf(apebuf, "\"%s\"", ape->pattern);
			add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_NONE, apebuf, MENU_UNSELECTED);
			ape = ape->next;
		    }
		}
		Sprintf(apebuf, "%s autopickup exceptions", (opt_idx == 1) ? "List of" : "Remove which");
		end_menu(tmpwin, apebuf);
		pick_cnt = select_menu(tmpwin, (opt_idx == 1) ?  PICK_NONE : PICK_ANY, &pick_list);

		if (pick_cnt > 0) {
		    for (pick_idx = 0; pick_idx < pick_cnt; ++pick_idx)
			remove_autopickup_exception( (struct autopickup_exception *)pick_list[pick_idx].item.a_void);
		}
		free((genericptr_t)pick_list);
		pick_list = (menu_item *)0;
		destroy_nhwindow(tmpwin);
		if (pick_cnt >= 0) goto ape_again;
	}

    } else if (!strcmp("symset", optname)
 	    || !strcmp("roguesymset", optname)) {
	menu_item *symset_pick = (menu_item *)0;
	boolean primaryflag = (*optname == 's'), rogueflag = (*optname == 'r'), ready_to_switch = FALSE, nothing_to_do = FALSE;



	int res;
	char *symset_name, fmtstr[20];
	struct symsetentry *sl;
	int setcount = 0;

	int chosen = -2, which_set;
 

	if (rogueflag) which_set = ROGUESET;
	else  which_set = PRIMARY;



	if (rogueflag) return TRUE;



	
	symset_name = symset[which_set].name;
	symset[which_set].name = (char *)0;
	symset_list = (struct symsetentry *)0;

	res = read_sym_file(which_set);
	if (res && symset_list) {
		char symsetchoice[BUFSZ];
		int let = 'a', biggest = 0, thissize = 0;
		sl = symset_list;
		while (sl) {
		    
		    if ((!rogueflag && sl->rogue)     || (!iflags.unicodedisp && sl->unicode) || (!primaryflag && sl->primary)) {

		    	sl = sl->next;
		    	continue;
		    }
		    setcount++;
		    
		    if (sl->name) thissize = strlen(sl->name);
		    if (thissize > biggest) biggest = thissize;
		    sl = sl->next;
		}
		if (!setcount) {
			pline("There are no appropriate %ssymbol sets available.", (rogueflag) ? "rogue level " :
				(primaryflag) ? "primary "     :
				"");
			return TRUE;
		}

		Sprintf(fmtstr,"%%-%ds %%s", biggest + 5);
		tmpwin = create_nhwindow(NHW_MENU);
		start_menu(tmpwin);
		any.a_int = 1;
		add_menu(tmpwin, NO_GLYPH, &any, let++, 0, ATR_NONE, "Default Symbols", MENU_UNSELECTED);

		sl = symset_list;
		while (sl) {
		    
		    if ((!rogueflag && sl->rogue) || (!iflags.unicodedisp && sl->unicode) || (!primaryflag && sl->primary)) {

		    	sl = sl->next;
		    	continue;
		    }
		    if (sl->name) {
			any.a_int = sl->idx + 2;
			Sprintf(symsetchoice, fmtstr, sl->name, sl->desc ? sl->desc : "");
			add_menu(tmpwin, NO_GLYPH, &any, let, 0, ATR_NONE, symsetchoice, MENU_UNSELECTED);
			if (let == 'z') let = 'A';
			else let++;
		    }
		    sl = sl->next;
		}
		end_menu(tmpwin, "Select symbol set:");
		if (select_menu(tmpwin, PICK_ONE, &symset_pick) > 0) {
			chosen = symset_pick->item.a_int - 2;
			free((genericptr_t)symset_pick);
		}
		destroy_nhwindow(tmpwin);

		if (chosen > -1) {
		    
		    sl = symset_list;
		    while (sl) {
			if (sl->idx == chosen) {
			    if (symset_name) {
					free((genericptr_t)symset_name);
					symset_name = (char *)0;
			    }
			    
			    clear_symsetentry(which_set, TRUE);

			    
			    symset[which_set].name = (char *)alloc(strlen(sl->name)+1);
			    Strcpy(symset[which_set].name, sl->name);
			    ready_to_switch = TRUE;
			    break;
			}
			sl = sl->next;
		    }
		}

		else if (chosen == -1) {
			
			
			if (symset_name) free ((genericptr_t)symset_name);
			symset_name = (char *)0;
			clear_symsetentry(which_set, TRUE);
		}
		else nothing_to_do = TRUE;
	} else if (!res) {
		
		pline("Unable to access \"%s\" file.", SYMBOLS);
		return TRUE;
	} else if (!symset_list) {
		
		pline("There were no symbol sets found in \"%s\".", SYMBOLS);
		return TRUE;
	}

	
	while (symset_list) {
		sl = symset_list;
		if (sl->name) free((genericptr_t)sl->name);
		sl->name = (char *)0;

		if (sl->desc) free((genericptr_t)sl->desc);
		sl->desc = (char *)0;

		symset_list = sl->next;
		free((genericptr_t)sl);
	}

	if (nothing_to_do) return TRUE;

	if (!symset[which_set].name && symset_name)
	    symset[which_set].name = symset_name;

	

	if(rogueflag)
	    init_r_symbols();
	else  init_l_symbols();


	if (symset[which_set].name) {
	    if (read_sym_file(which_set))
		ready_to_switch = TRUE;
	    else {
		clear_symsetentry(which_set, TRUE);
		return TRUE;
	    }
	}

	if (ready_to_switch) switch_symbols(TRUE);


	if (Is_rogue_level(&u.uz)) {
		if (rogueflag)
		    assign_graphics(ROGUESET);
	} else  if (!rogueflag) assign_graphics(PRIMARY);

	need_redraw = TRUE;

	return TRUE;

    } else {
	
	return FALSE;
    }
    return TRUE;
}




STATIC_OVL const char * get_compopt_value(optname, buf)
const char *optname;
char *buf;
{
	char ocl[MAXOCLASSES+1];
	static const char none[] = "(none)", randomrole[] = "random", to_be_done[] = "(to be done)", defopt[] = "default", defbrief[] = "def";


	int i;

	buf[0] = '\0';
	if (!strcmp(optname,"align_message"))
		Sprintf(buf, "%s", iflags.wc_align_message == ALIGN_TOP     ? "top" :
				   iflags.wc_align_message == ALIGN_LEFT    ? "left" :
				   iflags.wc_align_message == ALIGN_BOTTOM  ? "bottom" :
				   iflags.wc_align_message == ALIGN_RIGHT   ? "right" :
				   defopt);
	else if (!strcmp(optname,"align_status"))
		Sprintf(buf, "%s", iflags.wc_align_status == ALIGN_TOP     ? "top" :
				   iflags.wc_align_status == ALIGN_LEFT    ? "left" :
				   iflags.wc_align_status == ALIGN_BOTTOM  ? "bottom" :
				   iflags.wc_align_status == ALIGN_RIGHT   ? "right" :
				   defopt);
	else if (!strcmp(optname,"align"))
		Sprintf(buf, "%s", rolestring(flags.initalign, aligns, adj));

	else if (!strcmp(optname,"altkeyhandler"))
		Sprintf(buf, "%s", iflags.altkeyhandler[0] ? iflags.altkeyhandler : "default");


	else if (!strcmp(optname, "boulder"))

		Sprintf(buf, "\\x%04X", iflags.bouldersym ?  Sprintf(buf, "%c", iflags.bouldersym ?  iflags.bouldersym :



			showsyms[(int)objects[BOULDER].oc_class + SYM_OFF_O]);

	else if (!strcmp(optname, "catname"))
		Sprintf(buf, "%s", catname[0] ? catname : none );
	else if (!strcmp(optname, "disclose")) {
		for (i = 0; i < NUM_DISCLOSURE_OPTIONS; i++) {
			char topt[2];
			if (i) Strcat(buf," ");
			topt[1] = '\0';
			topt[0] = flags.end_disclose[i];
			Strcat(buf, topt);
			topt[0] = disclosure_options[i];
			Strcat(buf, topt);
		}
	}
	else if (!strcmp(optname, "dogname"))
		Sprintf(buf, "%s", dogname[0] ? dogname : none );
	else if (!strcmp(optname, "dungeon"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "effects"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "font_map"))
		Sprintf(buf, "%s", iflags.wc_font_map ? iflags.wc_font_map : defopt);
	else if (!strcmp(optname, "font_message"))
		Sprintf(buf, "%s", iflags.wc_font_message ? iflags.wc_font_message : defopt);
	else if (!strcmp(optname, "font_status"))
		Sprintf(buf, "%s", iflags.wc_font_status ? iflags.wc_font_status : defopt);
	else if (!strcmp(optname, "font_menu"))
		Sprintf(buf, "%s", iflags.wc_font_menu ? iflags.wc_font_menu : defopt);
	else if (!strcmp(optname, "font_text"))
		Sprintf(buf, "%s", iflags.wc_font_text ? iflags.wc_font_text : defopt);
	else if (!strcmp(optname, "font_size_map")) {
		if (iflags.wc_fontsiz_map) Sprintf(buf, "%d", iflags.wc_fontsiz_map);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "font_size_message")) {
		if (iflags.wc_fontsiz_message) Sprintf(buf, "%d", iflags.wc_fontsiz_message);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "font_size_status")) {
		if (iflags.wc_fontsiz_status) Sprintf(buf, "%d", iflags.wc_fontsiz_status);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "font_size_menu")) {
		if (iflags.wc_fontsiz_menu) Sprintf(buf, "%d", iflags.wc_fontsiz_menu);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "font_size_text")) {
		if (iflags.wc_fontsiz_text) Sprintf(buf, "%d",iflags.wc_fontsiz_text);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "fruit"))
		Sprintf(buf, "%s", pl_fruit);
	else if (!strcmp(optname, "gender"))
		Sprintf(buf, "%s", rolestring(flags.initgend, genders, adj));
	else if (!strcmp(optname, "horsename"))
		Sprintf(buf, "%s", horsename[0] ? horsename : none);
	else if (!strcmp(optname, "map_mode"))
		Sprintf(buf, "%s", iflags.wc_map_mode == MAP_MODE_TILES      ? "tiles" :
			iflags.wc_map_mode == MAP_MODE_ASCII4x6   ? "ascii4x6" :
			iflags.wc_map_mode == MAP_MODE_ASCII6x8   ? "ascii6x8" :
			iflags.wc_map_mode == MAP_MODE_ASCII8x8   ? "ascii8x8" :
			iflags.wc_map_mode == MAP_MODE_ASCII16x8  ? "ascii16x8" :
			iflags.wc_map_mode == MAP_MODE_ASCII7x12  ? "ascii7x12" :
			iflags.wc_map_mode == MAP_MODE_ASCII8x12  ? "ascii8x12" :
			iflags.wc_map_mode == MAP_MODE_ASCII16x12 ? "ascii16x12" :
			iflags.wc_map_mode == MAP_MODE_ASCII12x16 ? "ascii12x16" :
			iflags.wc_map_mode == MAP_MODE_ASCII10x18 ? "ascii10x18" :
			iflags.wc_map_mode == MAP_MODE_ASCII_FIT_TO_SCREEN ? "fit_to_screen" : defopt);
	else if (!strcmp(optname, "menustyle"))
		Sprintf(buf, "%s", menutype[(int)flags.menu_style] );
	else if (!strcmp(optname, "menu_deselect_all"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_deselect_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_first_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_invert_all"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_headings")) {
		Sprintf(buf, "%s", (iflags.menu_headings == ATR_BOLD) ? "bold" :   (iflags.menu_headings == ATR_INVERSE) ? "inverse" :   (iflags.menu_headings == ATR_ULINE) ? "underline" : "unknown");


	}
	else if (!strcmp(optname, "menu_invert_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_last_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_next_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_previous_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_search"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_select_all"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "menu_select_page"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "monsters"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "msghistory"))
		Sprintf(buf, "%u", iflags.msg_history);

	else if (!strcmp(optname, "msg_window"))
		Sprintf(buf, "%s", (iflags.prevmsg_window=='s') ? "single" :
					(iflags.prevmsg_window=='c') ? "combination" :
					(iflags.prevmsg_window=='f') ? "full" : "reversed");

	else if (!strcmp(optname, "name"))
		Sprintf(buf, "%s", plname);
	else if (!strcmp(optname, "number_pad")) {
		static const char *numpadmodes[] = {
		    "0=off", "1=on", "2=on, MSDOS compatible", "3=on, phone-style layout", "4=on, phone layout, MSDOS compatible", "-1=off, y & z swapped", };



		int indx = Cmd.num_pad ?  (Cmd.phone_layout ? (Cmd.pcHack_compat ? 4 : 3) :
						(Cmd.pcHack_compat ? 2 : 1)) :
			    Cmd.swap_yz ? 5 : 0;

		Strcpy(buf, numpadmodes[indx]);
	} else if (!strcmp(optname, "objects"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "packorder")) {
		oc_to_str(flags.inv_order, ocl);
		Sprintf(buf, "%s", ocl);
	     }

	else if (!strcmp(optname, "palette"))
		Sprintf(buf, "%s", get_color_string());

	else if (!strcmp(optname, "paranoid_confirmation")) {
		char tmpbuf[QBUFSZ];

		tmpbuf[0] = '\0';
		if (ParanoidConfirm) Strcat(tmpbuf, " Confirm");
		if (ParanoidQuit)    Strcat(tmpbuf, " quit");
		if (ParanoidDie)     Strcat(tmpbuf, " die");
		if (ParanoidBones)   Strcat(tmpbuf, " bones");
		if (ParanoidHit)     Strcat(tmpbuf, " attack");
		if (ParanoidPray)    Strcat(tmpbuf, " pray");
		if (ParanoidRemove)  Strcat(tmpbuf, " Remove");
		Strcpy(buf, tmpbuf[0] ? &tmpbuf[1] : "none");
	} else if (!strcmp(optname, "pettype"))
		Sprintf(buf, "%s", (preferred_pet == 'c') ? "cat" :
				(preferred_pet == 'd') ? "dog" :
				(preferred_pet == 'h') ? "horse" :
				(preferred_pet == 'n') ? "none" : "random");
	else if (!strcmp(optname, "pickup_burden"))
		Sprintf(buf, "%s", burdentype[flags.pickup_burden] );
	else if (!strcmp(optname, "pickup_types")) {
		oc_to_str(flags.pickup_types, ocl);
		Sprintf(buf, "%s", ocl[0] ? ocl : "all" );
	}
	else if (!strcmp(optname, "pile_limit"))
		Sprintf(buf, "%d", flags.pile_limit);
	else if (!strcmp(optname, "playmode")) {
		Strcpy(buf, wizard ? "debug" : discover ? "explore" : "normal");
	}
	else if (!strcmp(optname, "race"))
		Sprintf(buf, "%s", rolestring(flags.initrace, races, noun));

	else if (!strcmp(optname, "roguesymset")) {
		Sprintf(buf, "%s",  symset[ROGUESET].name ? symset[ROGUESET].name :



			"default");
		if (currentgraphics == ROGUESET && symset[ROGUESET].name)
			Strcat(buf, ", active");

	}
	else if (!strcmp(optname, "role"))
		Sprintf(buf, "%s", rolestring(flags.initrole, roles, name.m));
	else if (!strcmp(optname, "runmode"))
		Sprintf(buf, "%s", runmodes[flags.runmode]);
	else if (!strcmp(optname, "scores")) {
		Sprintf(buf, "%d top/%d around%s", flags.end_top, flags.end_around, flags.end_own ? "/own" : "");
	}
	else if (!strcmp(optname, "scroll_amount")) {
		if (iflags.wc_scroll_amount) Sprintf(buf, "%d",iflags.wc_scroll_amount);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "scroll_margin")) {
		if (iflags.wc_scroll_margin) Sprintf(buf, "%d",iflags.wc_scroll_margin);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "player_selection"))
		Sprintf(buf, "%s", iflags.wc_player_selection ? "prompts" : "dialog");

	else if (!strcmp(optname, "soundcard"))
		Sprintf(buf, "%s", to_be_done);

	else if (!strcmp(optname, "suppress_alert")) {
	    if (flags.suppress_alert == 0L)
		Strcpy(buf, none);
	    else Sprintf(buf, "%lu.%lu.%lu", FEATURE_NOTICE_VER_MAJ, FEATURE_NOTICE_VER_MIN, FEATURE_NOTICE_VER_PATCH);



	}
	else if (!strcmp(optname, "symset")) {
		Sprintf(buf, "%s",  symset[PRIMARY].name ? symset[PRIMARY].name :



			"default");
		if (currentgraphics == PRIMARY && symset[PRIMARY].name)
			Strcat(buf, ", active");
	}
	else if (!strcmp(optname, "tile_file"))
		Sprintf(buf, "%s", iflags.wc_tile_file ? iflags.wc_tile_file : defopt);
	else if (!strcmp(optname, "tile_height")) {
		if (iflags.wc_tile_height) Sprintf(buf, "%d",iflags.wc_tile_height);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "tile_width")) {
		if (iflags.wc_tile_width) Sprintf(buf, "%d",iflags.wc_tile_width);
		else Strcpy(buf, defopt);
	}
	else if (!strcmp(optname, "traps"))
		Sprintf(buf, "%s", to_be_done);
	else if (!strcmp(optname, "vary_msgcount")) {
		if (iflags.wc_vary_msgcount) Sprintf(buf, "%d",iflags.wc_vary_msgcount);
		else Strcpy(buf, defopt);
	}

	else if (!strcmp(optname, "video"))
		Sprintf(buf, "%s", to_be_done);


	else if (!strcmp(optname, "videoshades"))
		Sprintf(buf, "%s-%s-%s", shade[0],shade[1],shade[2]);
	else if (!strcmp(optname, "videocolors"))
		Sprintf(buf, "%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d-%d", ttycolors[CLR_RED], ttycolors[CLR_GREEN], ttycolors[CLR_BROWN], ttycolors[CLR_BLUE], ttycolors[CLR_MAGENTA], ttycolors[CLR_CYAN], ttycolors[CLR_ORANGE], ttycolors[CLR_BRIGHT_GREEN], ttycolors[CLR_YELLOW], ttycolors[CLR_BRIGHT_BLUE], ttycolors[CLR_BRIGHT_MAGENTA], ttycolors[CLR_BRIGHT_CYAN]);







	else if (!strcmp(optname, "windowtype"))
		Sprintf(buf, "%s", windowprocs.name);
	else if (!strcmp(optname, "windowcolors"))
		Sprintf(buf, "%s/%s %s/%s %s/%s %s/%s", iflags.wc_foregrnd_menu    ? iflags.wc_foregrnd_menu : defbrief, iflags.wc_backgrnd_menu    ? iflags.wc_backgrnd_menu : defbrief, iflags.wc_foregrnd_message ? iflags.wc_foregrnd_message : defbrief, iflags.wc_backgrnd_message ? iflags.wc_backgrnd_message : defbrief, iflags.wc_foregrnd_status  ? iflags.wc_foregrnd_status : defbrief, iflags.wc_backgrnd_status  ? iflags.wc_backgrnd_status : defbrief, iflags.wc_foregrnd_text    ? iflags.wc_foregrnd_text : defbrief, iflags.wc_backgrnd_text    ? iflags.wc_backgrnd_text : defbrief);








	else {
	    for (i = 0; i < PREFIX_COUNT; ++i)
		if (!strcmp(optname, fqn_prefix_names[i]) && fqn_prefix[i])
			Sprintf(buf, "%s", fqn_prefix[i]);
	}


	if (buf[0]) return buf;
	else return "unknown";
}

int dotogglepickup()
{
	char buf[BUFSZ], ocl[MAXOCLASSES+1];

	flags.pickup = !flags.pickup;
	if (flags.pickup) {
	    oc_to_str(flags.pickup_types, ocl);
	    Sprintf(buf, "ON, for %s objects%s", ocl[0] ? ocl : "all",  (iflags.autopickup_exceptions[AP_LEAVE] || iflags.autopickup_exceptions[AP_GRAB]) ? ((count_ape_maps((int *)0, (int *)0) == 1) ? ", with one exception" : ", with some exceptions") :





			"");
	} else {
	    Strcpy(buf, "OFF");
	}
	pline("Autopickup: %s.", buf);
	return 0;
}


int add_autopickup_exception(mapping)
const char *mapping;
{
	struct autopickup_exception *ape, **apehead;
	char text[256], *text2;
	int textsize = 0;
	boolean grab = FALSE;

	if (sscanf(mapping, "\"%255[^\"]\"", text) == 1) {
		text2 = &text[0];
		if (*text2 == '<') {		
			grab = TRUE;
			++text2;
		} else if (*text2 == '>') {	
			grab = FALSE;
			++text2;
		}
		textsize = strlen(text2);
		apehead = (grab) ? &iflags.autopickup_exceptions[AP_GRAB] :
				   &iflags.autopickup_exceptions[AP_LEAVE];
		ape = (struct autopickup_exception *)
				alloc(sizeof(struct autopickup_exception));
		ape->pattern = (char *) alloc(textsize+1);
		Strcpy(ape->pattern, text2);
		ape->grab = grab;
		if (!*apehead) ape->next = (struct autopickup_exception *)0;
		else ape->next = *apehead;
		*apehead = ape;
	} else {
	    raw_print("syntax error in AUTOPICKUP_EXCEPTION");
	    return 0;
	}
	return 1;
}

STATIC_OVL void remove_autopickup_exception(whichape)
struct autopickup_exception *whichape;
{
    struct autopickup_exception *ape, *prev = 0;
    int chain = whichape->grab ? AP_GRAB : AP_LEAVE;

    for (ape = iflags.autopickup_exceptions[chain]; ape;) {
	if (ape == whichape) {
	    struct autopickup_exception *freeape = ape;
	    ape = ape->next;
	    if (prev) prev->next = ape;
	    else iflags.autopickup_exceptions[chain] = ape;
	    free(freeape->pattern);
	    free(freeape);
	} else {
	    prev = ape;
	    ape = ape->next;
	}
    }
}

STATIC_OVL int count_ape_maps(leave, grab)
int *leave, *grab;
{
	struct autopickup_exception *ape;
	int pass, totalapes, numapes[2] = {0,0};

	for (pass = AP_LEAVE; pass <= AP_GRAB; ++pass) {
		ape = iflags.autopickup_exceptions[pass];
		while(ape) {
			ape = ape->next;
			numapes[pass]++;
		}
	}
	totalapes = numapes[AP_LEAVE] + numapes[AP_GRAB];
	if (leave) *leave = numapes[AP_LEAVE];
	if (grab) *grab = numapes[AP_GRAB];
	return totalapes;
}

void free_autopickup_exceptions()
{
	struct autopickup_exception *ape;
	int pass;

	for (pass = AP_LEAVE; pass <= AP_GRAB; ++pass) {
		while((ape = iflags.autopickup_exceptions[pass]) != 0) {
			free(ape->pattern);
			iflags.autopickup_exceptions[pass] = ape->next;
			free(ape);
		}
	}
}




int load_symset(s, which_set)
const char *s;
int which_set;
{
	clear_symsetentry(which_set, TRUE);

	symset[which_set].name = (char *)alloc(strlen(s)+1);
	Strcpy(symset[which_set].name,s);
	if (read_sym_file(which_set))
		switch_symbols(TRUE);
	else {
		clear_symsetentry(which_set, TRUE);
		return 0;
	}
	return 1;
}


void parsesymbols(opts)
register char *opts;
{
	int val;
	char *op, *symname, *strval, *p;
	struct symparse *symp;

	if ((op = index(opts, ',')) != 0) {
		*op++ = 0;
		parsesymbols(op);
	}

	
	symname = opts;
	strval = index(opts, ':');
	if (!symname || !strval) return;
	*strval++ = 0;

	
	while (isspace(*symname)) symname++;
	p = eos(symname);
	while (--p >= symname && isspace(*p)) *p = '\0';

	
	while (isspace(*strval)) strval++;
	p = eos(strval);
	while (--p >= strval && isspace(*p)) *p = '\0';

	symp = match_sym(symname);
	if (!symp) return;

	if (symp->range && symp->range != SYM_CONTROL) {
		val = sym_val(strval);
		update_l_symset(symp, val);
	}
}

struct symparse * match_sym(buf)
char *buf;
{
	size_t len = strlen(buf);
	const char *p = index(buf, ':'), *q = index(buf, '=');
	struct symparse *sp = loadsyms;

	if (!p || (q && q < p)) p = q;
	while(p && p > buf && isspace(*(p-1))) p--;
	if (p) len = (int)(p - buf);
	while(sp->range) {
	    if ((len >= strlen(sp->name)) && !strncmpi(buf, sp->name, len))
		return sp;
	    sp++;
	}
	return (struct symparse *)0;
}



static const char *opt_intro[] = {
	"", "                 NetHack Options Help:", "",  (char *)0,  "or use `NETHACKOPTIONS=\"<options>\"' in your environment",  "(<options> is a list of options separated by commas)",  "-- for example, $ DEFINE NETHACKOPTIONS \"noautopickup,fruit:kumquat\"",  "or press \"O\" while playing and use the menu.", "", "Boolean options (which can be negated by prefixing them with '!' or \"no\"):", (char *)0 };
















static const char *opt_epilog[] = {
	"", "Some of the options can be set only before the game is started; those", "items will not be selectable in the 'O' command's menu.", (char *)0 };




void option_help()
{
    char buf[BUFSZ], buf2[BUFSZ];
    register int i;
    winid datawin;

    datawin = create_nhwindow(NHW_TEXT);
    Sprintf(buf, "Set options as OPTIONS=<options> in %s", configfile);
    opt_intro[CONFIG_SLOT] = (const char *) buf;
    for (i = 0; opt_intro[i]; i++)
	putstr(datawin, 0, opt_intro[i]);

    
    for (i = 0; boolopt[i].name; i++) {
	if (boolopt[i].addr) {

	    if (boolopt[i].addr == &iflags.sanity_check && !wizard) continue;
	    if (boolopt[i].addr == &iflags.menu_tab_sep && !wizard) continue;

	    next_opt(datawin, boolopt[i].name);
	}
    }
    next_opt(datawin, "");

    
    putstr(datawin, 0, "Compound options:");
    for (i = 0; compopt[i].name; i++) {
	Sprintf(buf2, "`%s'", compopt[i].name);
	Sprintf(buf, "%-20s - %s%c", buf2, compopt[i].descr, compopt[i+1].name ? ',' : '.');
	putstr(datawin, 0, buf);
    }

    for (i = 0; opt_epilog[i]; i++)
	putstr(datawin, 0, opt_epilog[i]);

    display_nhwindow(datawin, FALSE);
    destroy_nhwindow(datawin);
    return;
}


void next_opt(datawin, str)
winid datawin;
const char *str;
{
	static char *buf = 0;
	int i;
	char *s;

	if (!buf) *(buf = (char *)alloc(BUFSZ)) = '\0';

	if (!*str) {
		s = eos(buf);
		if (s > &buf[1] && s[-2] == ',')
		    Strcpy(s - 2, ".");	
		i = COLNO;	
	} else {
		i = strlen(buf) + strlen(str) + 2;
	}

	if (i > COLNO - 2) { 
		putstr(datawin, 0, buf);
		buf[0] = 0;
	}
	if (*str) {
		Strcat(buf, str);
		Strcat(buf, ", ");
	} else {
		putstr(datawin, 0, str);
		free(buf),  buf = 0;
	}
	return;
}


int fruitadd(str)
char *str;
{
	register int i;
	register struct fruit *f;
	int highest_fruit_id = 0;
	char buf[PL_FSIZ], altname[PL_FSIZ];
	boolean user_specified = (str == pl_fruit);
	

	
	if (user_specified) {
		boolean found = FALSE, numeric = FALSE;

		
		nmcpy(pl_fruit, makesingular(str), PL_FSIZ);
	     

		

		for (i = bases[FOOD_CLASS]; objects[i].oc_class == FOOD_CLASS;
						i++) {
			if (!strcmp(OBJ_NAME(objects[i]), pl_fruit)) {
				found = TRUE;
				break;
			}
		}
		{
		    char *c;

		    c = pl_fruit;

		    for(c = pl_fruit; *c >= '0' && *c <= '9'; c++)
			;
		    if (isspace(*c) || *c == 0) numeric = TRUE;
		}
		if (found || numeric || !strncmp(str, "cursed ", 7) || !strncmp(str, "uncursed ", 9) || !strncmp(str, "blessed ", 8) || !strncmp(str, "partly eaten ", 13) || (!strncmp(str, "tin of ", 7) && (!strcmp(str+7, "spinach") || name_to_mon(str+7) >= LOW_PM)) || !strcmp(str, "empty tin") || ((!strncmp(eos(str)-7," corpse",7) || !strncmp(eos(str)-4, " egg",4)) && name_to_mon(str) >= LOW_PM))










			{
				Strcpy(buf, pl_fruit);
				Strcpy(pl_fruit, "candied ");
				nmcpy(pl_fruit+8, buf, PL_FSIZ-8);
		}
		*altname = '\0';
	} else {
		
		copynchars(altname, str, PL_FSIZ-1);
		sanitize_name(altname);
	}
	for(f=ffruit; f; f = f->nextf) {
		if(f->fid > highest_fruit_id) highest_fruit_id = f->fid;
		if (!strncmp(str, f->fname, PL_FSIZ-1) || (*altname && !strcmp(altname, f->fname)))
			goto nonew;
	}
	
	if (highest_fruit_id >= 127) return rnd(127);

	f = newfruit();
	copynchars(f->fname, *altname ? altname : str, PL_FSIZ-1);
	f->fid = ++highest_fruit_id;
	
	f->nextf = ffruit;
	ffruit = f;
 nonew:
	if (user_specified) context.current_fruit = f->fid;
	return f->fid;
}


int choose_classes_menu(prompt, category, way, class_list, class_select)
const char *prompt;
int category;
boolean way;
char *class_list;
char *class_select;
{
    menu_item *pick_list = (menu_item *)0;
    winid win;
    anything any;
    char buf[BUFSZ];
    int i, n;
    int ret;
    int next_accelerator, accelerator;

    if (class_list == (char *)0 || class_select == (char *)0) return 0;
    accelerator = 0;
    next_accelerator = 'a';
    any = zeroany;
    win = create_nhwindow(NHW_MENU);
    start_menu(win);
    while (*class_list) {
	const char *text;
	boolean selected;

	text = (char *)0;
	selected = FALSE;
	switch (category) {
		case 0:
			text = def_monsyms[def_char_to_monclass(*class_list)].explain;
			accelerator = *class_list;
			Sprintf(buf, "%s", text);
			break;
		case 1:
			text = def_oc_syms[def_char_to_objclass(*class_list)].explain;
			accelerator = next_accelerator;
			Sprintf(buf, "%c  %s", *class_list, text);
			break;
		default:
			impossible("choose_classes_menu: invalid category %d", category);
	}
	if (way && *class_select) {	
		if (index(class_select, *class_list)) {
			selected = TRUE;
		}
	}
	any.a_int = *class_list;
	add_menu(win, NO_GLYPH, &any, accelerator, category ? *class_list : 0, ATR_NONE, buf, selected);

	++class_list;
	if (category > 0) {
		++next_accelerator;
		if (next_accelerator == ('z' + 1)) next_accelerator = 'A';
		if (next_accelerator == ('Z' + 1)) break;
	}
    }
    end_menu(win, prompt);
    n = select_menu(win, way ? PICK_ANY : PICK_ONE, &pick_list);
    destroy_nhwindow(win);
    if (n > 0) {
	for (i = 0; i < n; ++i)
	    *class_select++ = (char)pick_list[i].item.a_int;
	free((genericptr_t)pick_list);
	ret = n;
    } else if (n == -1) {
	class_select = eos(class_select);
	ret = -1;
    } else ret = 0;
    *class_select = '\0';
    return ret;
}

struct wc_Opt wc_options[] = {
	{"ascii_map", WC_ASCII_MAP}, {"color", WC_COLOR}, {"eight_bit_tty", WC_EIGHT_BIT_IN}, {"hilite_pet", WC_HILITE_PET}, {"popup_dialog", WC_POPUP_DIALOG}, {"player_selection", WC_PLAYER_SELECTION}, {"preload_tiles", WC_PRELOAD_TILES}, {"tiled_map", WC_TILED_MAP}, {"tile_file", WC_TILE_FILE}, {"tile_width", WC_TILE_WIDTH}, {"tile_height", WC_TILE_HEIGHT}, {"use_inverse", WC_INVERSE}, {"align_message", WC_ALIGN_MESSAGE}, {"align_status", WC_ALIGN_STATUS}, {"font_map", WC_FONT_MAP}, {"font_menu", WC_FONT_MENU}, {"font_message",WC_FONT_MESSAGE},  {"perm_invent",WC_PERM_INVENT},  {"font_size_map", WC_FONTSIZ_MAP}, {"font_size_menu", WC_FONTSIZ_MENU}, {"font_size_message", WC_FONTSIZ_MESSAGE}, {"font_size_status", WC_FONTSIZ_STATUS}, {"font_size_text", WC_FONTSIZ_TEXT}, {"font_status", WC_FONT_STATUS}, {"font_text", WC_FONT_TEXT}, {"map_mode", WC_MAP_MODE}, {"scroll_amount", WC_SCROLL_AMOUNT}, {"scroll_margin", WC_SCROLL_MARGIN}, {"splash_screen", WC_SPLASH_SCREEN}, {"vary_msgcount",WC_VARY_MSGCOUNT}, {"windowcolors", WC_WINDOWCOLORS}, {"mouse_support", WC_MOUSE_SUPPORT}, {(char *)0, 0L}

































};

struct wc_Opt wc2_options[] = {
	{"fullscreen", WC2_FULLSCREEN}, {"softkeyboard", WC2_SOFTKEYBOARD}, {"wraptext", WC2_WRAPTEXT},  {"hilite_status", WC2_HILITE_STATUS},  {(char *)0, 0L}





};


void set_option_mod_status(optnam, status)
const char *optnam;
int status;
{
	int k;
	if ( SET__IS_VALUE_VALID(status) ) {
		impossible("set_option_mod_status: status out of range %d.", status);
		return;
	}
	for (k = 0; boolopt[k].name; k++) {
		if (!strncmpi(boolopt[k].name, optnam, strlen(optnam))) {
			boolopt[k].optflags = status;
			return;
		}
	}
	for (k = 0; compopt[k].name; k++) {
		if (!strncmpi(compopt[k].name, optnam, strlen(optnam))) {
			compopt[k].optflags = status;
			return;
		}
	}
}


void set_wc_option_mod_status(optmask, status)
unsigned long optmask;
int status;
{
	int k = 0;
	if ( SET__IS_VALUE_VALID(status) ) {
		impossible("set_wc_option_mod_status: status out of range %d.", status);
		return;
	}
	while (wc_options[k].wc_name) {
		if (optmask & wc_options[k].wc_bit) {
			set_option_mod_status(wc_options[k].wc_name, status);
		}
		k++;
	}
}

STATIC_OVL boolean is_wc_option(optnam)
const char *optnam;
{
	int k = 0;
	while (wc_options[k].wc_name) {
		if (strcmp(wc_options[k].wc_name, optnam) == 0)
			return TRUE;
		k++;
	}
	return FALSE;
}

STATIC_OVL boolean wc_supported(optnam)
const char *optnam;
{
	int k = 0;
	while (wc_options[k].wc_name) {
		if (!strcmp(wc_options[k].wc_name, optnam) && (windowprocs.wincap & wc_options[k].wc_bit))
			return TRUE;
		k++;
	}
	return FALSE;
}




void set_wc2_option_mod_status(optmask, status)
unsigned long optmask;
int status;
{
	int k = 0;
	if ( SET__IS_VALUE_VALID(status) ) {
		impossible("set_wc2_option_mod_status: status out of range %d.", status);
		return;
	}
	while (wc2_options[k].wc_name) {
		if (optmask & wc2_options[k].wc_bit) {
			set_option_mod_status(wc2_options[k].wc_name, status);
		}
		k++;
	}
}

STATIC_OVL boolean is_wc2_option(optnam)
const char *optnam;
{
	int k = 0;
	while (wc2_options[k].wc_name) {
		if (strcmp(wc2_options[k].wc_name, optnam) == 0)
			return TRUE;
		k++;
	}
	return FALSE;
}

STATIC_OVL boolean wc2_supported(optnam)
const char *optnam;
{
	int k = 0;
	while (wc2_options[k].wc_name) {
		if (!strcmp(wc2_options[k].wc_name, optnam) && (windowprocs.wincap2 & wc2_options[k].wc_bit))
			return TRUE;
		k++;
	}
	return FALSE;
}


STATIC_OVL void wc_set_font_name(opttype, fontname)
int opttype;
char *fontname;
{
	char **fn = (char **)0;
	if (!fontname) return;
	switch(opttype) {
	    case MAP_OPTION:
			fn = &iflags.wc_font_map;
			break;
	    case MESSAGE_OPTION:
			fn = &iflags.wc_font_message;
			break;
	    case TEXT_OPTION:
			fn = &iflags.wc_font_text;
			break;
	    case MENU_OPTION:
			fn = &iflags.wc_font_menu;
			break;
	    case STATUS_OPTION:
			fn = &iflags.wc_font_status;
			break;
	    default:
			return;
	}
	if (fn) {
		if (*fn) free(*fn);
		*fn = (char *)alloc(strlen(fontname) + 1);
		Strcpy(*fn, fontname);
	}
	return;
}

STATIC_OVL int wc_set_window_colors(op)
char *op;
{
	

	int j;
	char buf[BUFSZ];
	char *wn, *tfg, *tbg, *newop;
	static const char *wnames[] = { "menu", "message", "status", "text" };
	static const char *shortnames[] = { "mnu", "msg", "sts", "txt" };
	static char **fgp[] = {
		&iflags.wc_foregrnd_menu, &iflags.wc_foregrnd_message, &iflags.wc_foregrnd_status, &iflags.wc_foregrnd_text };



	static char **bgp[] = {
		&iflags.wc_backgrnd_menu, &iflags.wc_backgrnd_message, &iflags.wc_backgrnd_status, &iflags.wc_backgrnd_text };




	Strcpy(buf, op);
	newop = mungspaces(buf);
	while (newop && *newop) {

		wn = tfg = tbg = (char *)0;

		
		while(*newop && isspace(*newop)) newop++;
		if (*newop) wn = newop;
		else return 0;

		
		while(*newop && !isspace(*newop)) newop++;
		if (*newop) *newop = '\0';
		else return 0;
		newop++;

		
		while(*newop && isspace(*newop)) newop++;
		if (*newop) tfg = newop;
		else return 0;

		
		while(*newop && *newop != '/') newop++;
		if (*newop) *newop = '\0';
		else return 0;
		newop++;

		
		while(*newop && isspace(*newop)) newop++;
		if (*newop) tbg = newop;
		else return 0;

		
		while(*newop && !isspace(*newop)) newop++;
		if (*newop) *newop++ = '\0';

		for (j = 0; j < 4; ++j) {
			if (!strcmpi(wn, wnames[j]) || !strcmpi(wn, shortnames[j])) {
				if (tfg && !strstri(tfg, " ")) {
					if (*fgp[j]) free(*fgp[j]);
					*fgp[j] = (char *)alloc(strlen(tfg) + 1);
					Strcpy(*fgp[j], tfg);
				}
				if (tbg && !strstri(tbg, " ")) {
					if (*bgp[j]) free(*bgp[j]);
					*bgp[j] = (char *)alloc(strlen(tbg) + 1);
					Strcpy(*bgp[j], tbg);
				}
				break;
			}
		}
	}
	return 1;
}


void set_playmode()
{
    if (wizard) {

	if (authorize_wizard_mode())
	    Strcpy(plname, "wizard");
	else  wizard = FALSE;

	
	discover = !wizard;
	iflags.deferred_X = FALSE;
    }
    
}




