














































































































namespace llvh {
class raw_ostream;
}

namespace hermes {
namespace vm {

class BigIntPrimitive;
class StringPrimitive;
template <typename T> class PseudoHandle;

template <typename T> class PseudoHandle;


class PointerBase;
class GCCell;
class Runtime;


class HermesValue {
 public:
  using TagType = intptr_t;
  
  
  enum class Tag : TagType {
    
    First = llvh::SignExtend32<8>(0xf9), EmptyInvalid = First, UndefinedNull, BoolSymbol, NativeValue,   FirstPointer, Str = FirstPointer, BigInt, Object, Last = llvh::SignExtend32<8>(0xff), };











  static_assert(Tag::Object <= Tag::Last, "Tags overflow");

  
  enum class ETag : TagType {
    Empty = (TagType)Tag::EmptyInvalid * 2,    Invalid = (TagType)Tag::EmptyInvalid * 2 + 1,  Undefined = (TagType)Tag::UndefinedNull * 2, Null = (TagType)Tag::UndefinedNull * 2 + 1, Bool = (TagType)Tag::BoolSymbol * 2, Symbol = (TagType)Tag::BoolSymbol * 2 + 1, Native1 = (TagType)Tag::NativeValue * 2, Native2 = (TagType)Tag::NativeValue * 2 + 1, Str1 = (TagType)Tag::Str * 2, Str2 = (TagType)Tag::Str * 2 + 1, BigInt1 = (TagType)Tag::BigInt * 2, BigInt2 = (TagType)Tag::BigInt * 2 + 1, Object1 = (TagType)Tag::Object * 2, Object2 = (TagType)Tag::Object * 2 + 1,  FirstPointer = Str1, };




















  
  static constexpr unsigned kNumTagExpBits = 16;
  
  static constexpr unsigned kNumDataBits = (64 - kNumTagExpBits);

  
  static constexpr unsigned kTagWidth = 3;
  static constexpr unsigned kTagMask = (1 << kTagWidth) - 1;
  
  static constexpr uint64_t kDataMask = (1ull << kNumDataBits) - 1;

  static constexpr unsigned kETagWidth = 4;
  static constexpr unsigned kETagMask = (1 << kETagWidth) - 1;

  
  static void validatePointer(const void *ptr) {

    assert( (reinterpret_cast<uintptr_t>(ptr) & ~kDataMask) == 0 && "Pointer top bits are set");


  }

  using RawType = uint64_t;

  HermesValue() = default;
  HermesValue(const HermesValue &) = default;

  
  HermesValue(HermesValue &&) = default;


  constexpr inline static HermesValue fromRaw(RawType raw) {
    return HermesValue(raw);
  }

  
  void dump(llvh::raw_ostream &stream = llvh::errs()) const;

  inline Tag getTag() const {
    return (Tag)((int64_t)raw_ >> kNumDataBits);
  }
  inline ETag getETag() const {
    return (ETag)((int64_t)raw_ >> (kNumDataBits - 1));
  }

  
  inline static constexpr unsigned combineETags(ETag aTag, ETag bTag) {
    using UTagType = std::make_unsigned<TagType>::type;
    auto a = static_cast<UTagType>(aTag), b = static_cast<UTagType>(bTag);
    return ((a & kETagMask) << kETagWidth) | (b & kETagMask);
  }

  
  
  
  constexpr inline static HermesValue encodeNullptrObjectValueUnsafe() {
    return HermesValue(0, Tag::Object);
  }

  inline static HermesValue encodeObjectValueUnsafe(void *val) {
    validatePointer(val);
    HermesValue RV(reinterpret_cast<uintptr_t>(val), Tag::Object);
    assert(RV.isObject());
    return RV;
  }

  inline static HermesValue encodeStringValueUnsafe( const StringPrimitive *val) {
    validatePointer(val);
    HermesValue RV(reinterpret_cast<uintptr_t>(val), Tag::Str);
    assert(RV.isString());
    return RV;
  }

  inline static HermesValue encodeBigIntValueUnsafe( const BigIntPrimitive *val) {
    validatePointer(val);
    HermesValue RV(reinterpret_cast<uintptr_t>(val), Tag::BigInt);
    assert(RV.isBigInt());
    return RV;
  }

  inline static HermesValue encodeObjectValue(void *val) {
    assert(val && "Null pointers require special handling.");
    return encodeObjectValueUnsafe(val);
  }

  inline static HermesValue encodeStringValue(const StringPrimitive *val) {
    assert(val && "Null pointers require special handling.");
    return encodeStringValueUnsafe(val);
  }

  inline static HermesValue encodeBigIntValue(const BigIntPrimitive *val) {
    assert(val && "Null pointers require special handling.");
    return encodeBigIntValueUnsafe(val);
  }

  inline static HermesValue encodeNativeUInt32(uint32_t val) {
    HermesValue RV(val, Tag::NativeValue);
    assert( RV.isNativeValue() && RV.getNativeUInt32() == val && "native value doesn't fit");

    return RV;
  }

  inline static HermesValue encodeNativePointer(const void *p) {
    HermesValue RV(reinterpret_cast<uintptr_t>(p));
    assert( RV.isDouble() && RV.getNativePointer<void>() == p && "Native pointer cannot be represented as a double");

    return RV;
  }

  inline static HermesValue encodeSymbolValue(SymbolID val) {
    HermesValue RV(val.unsafeGetRaw(), ETag::Symbol);
    assert(RV.isSymbol());
    return RV;
  }

  constexpr inline static HermesValue encodeBoolValue(bool val) {
    return HermesValue((uint64_t)(val), ETag::Bool);
  }

  inline static constexpr HermesValue encodeNullValue() {
    return HermesValue(0, ETag::Null);
  }

  inline static constexpr HermesValue encodeUndefinedValue() {
    return HermesValue(0, ETag::Undefined);
  }

  inline static constexpr HermesValue encodeEmptyValue() {
    return HermesValue(0, ETag::Empty);
  }


  inline static constexpr HermesValue encodeInvalidValue() {
    return HermesValue(0, ETag::Invalid);
  }


  inline static HermesValue encodeDoubleValue(double num) {
    HermesValue RV(llvh::DoubleToBits(num));
    assert(RV.isDouble());
    return RV;
  }

  
  
  inline static HermesValue encodeUntrustedDoubleValue(double num) {
    return std::isnan(num) ? encodeNaNValue() : encodeDoubleValue(num);
  }

  
  
  
  inline static HermesValue encodeNumberValue(double num) {
    return encodeDoubleValue(num);
  }

  
  
  
  template <typename T> inline static typename std::enable_if<std::is_integral<T>::value, HermesValue>::type encodeNumberValue(T num) {


    assert((double)num == num && "value not representable as double");
    return encodeDoubleValue((double)num);
  }

  static HermesValue encodeNaNValue() {
    return HermesValue( llvh::DoubleToBits(std::numeric_limits<double>::quiet_NaN()));
  }

  
  inline HermesValue updatePointer(void *val) const {
    assert(isPointer());
    HermesValue V(reinterpret_cast<uintptr_t>(val), getTag());
    assert(V.isPointer());
    return V;
  }

  
  inline void unsafeUpdatePointer(void *ptr) {
    setNoBarrier(updatePointer(ptr));
  }

  inline bool isNull() const {
    return getETag() == ETag::Null;
  }
  inline bool isUndefined() const {
    return getETag() == ETag::Undefined;
  }
  inline bool isEmpty() const {
    return getETag() == ETag::Empty;
  }

  inline bool isInvalid() const {
    return getETag() == ETag::Invalid;
  }

  inline bool isNativeValue() const {
    return getTag() == Tag::NativeValue;
  }
  inline bool isSymbol() const {
    return getETag() == ETag::Symbol;
  }
  inline bool isBool() const {
    return getETag() == ETag::Bool;
  }
  inline bool isObject() const {
    return getTag() == Tag::Object;
  }
  inline bool isString() const {
    return getTag() == Tag::Str;
  }
  inline bool isBigInt() const {
    return getTag() == Tag::BigInt;
  }
  inline bool isDouble() const {
    return raw_ < ((uint64_t)Tag::First << kNumDataBits);
  }
  inline bool isPointer() const {
    return raw_ >= ((uint64_t)Tag::FirstPointer << kNumDataBits);
  }
  inline bool isNumber() const {
    return isDouble();
  }

  inline RawType getRaw() const {
    return raw_;
  }

  inline void *getPointer() const {
    assert(isPointer());
    
    return reinterpret_cast<void *>(raw_ & kDataMask);
  }

  inline double getDouble() const {
    assert(isDouble());
    return llvh::BitsToDouble(raw_);
  }

  inline uint32_t getNativeUInt32() const {
    assert(isNativeValue());
    return (uint32_t)raw_;
  }

  template <class T> inline T *getNativePointer() const {
    assert(isDouble() && "Native pointers must look like doubles.");
    return reinterpret_cast<T *>(raw_);
  }

  inline SymbolID getSymbol() const {
    assert(isSymbol());
    return SymbolID::unsafeCreate((uint32_t)raw_);
  }

  inline bool getBool() const {
    assert(isBool());
    return (bool)(raw_ & 0x1);
  }

  inline StringPrimitive *getString() const {
    assert(isString());
    return static_cast<StringPrimitive *>(getPointer());
  }

  inline BigIntPrimitive *getBigInt() const {
    assert(isBigInt());
    return static_cast<BigIntPrimitive *>(getPointer());
  }

  inline void *getObject() const {
    assert(isObject());
    return getPointer();
  }

  inline double getNumber() const {
    return getDouble();
  }

  template <class T> inline typename std::enable_if<std::is_integral<T>::value, T>::type getNumberAs() const {

    double num = getDouble();
    assert( num >= std::numeric_limits<T>::lowest() &&   num <= (double)std::numeric_limits<T>::max() && (T)num == num && "value not representable as type");




    return num;
  }

  template <class T> inline typename std::enable_if<!std::is_integral<T>::value, T>::type getNumberAs() const {

    return getDouble();
  }

  
  
  
  inline void setInGC(HermesValue hv, GC &gc);

  
  
  
  
  
  
  

  HermesValue &operator=(const HermesValue &hv) = delete;

  HermesValue &operator=(const HermesValue &hv) = default;


  
  

  GCCell *getPointer(PointerBase &) const {
    return static_cast<GCCell *>(getPointer());
  }
  GCCell *getObject(PointerBase &) const {
    return static_cast<GCCell *>(getObject());
  }

  static HermesValue encodeHermesValue(HermesValue hv, Runtime &) {
    return hv;
  }
  static HermesValue encodeObjectValue(GCCell *obj, Runtime &) {
    return encodeObjectValue(obj);
  }

  

 protected:
  
  
  
  
  
  
  void setNoBarrier(HermesValue hv) {
    raw_ = hv.raw_;
  }

 private:
  constexpr explicit HermesValue(uint64_t val) : raw_(val) {}
  constexpr explicit HermesValue(uint64_t val, Tag tag)
      : raw_(val | ((uint64_t)tag << kNumDataBits)) {}
  constexpr explicit HermesValue(uint64_t val, ETag etag)
      : raw_(val | ((uint64_t)etag << (kNumDataBits - 1))) {}

  
  
  
  
  
  HermesValue &operator=(HermesValue &&) = default;

  
  uint64_t raw_;

  friend class PseudoHandle<HermesValue>;
  friend struct HVConstants;
}; 

static_assert( std::is_trivial<HermesValue>::value, "HermesValue must be trivial");




struct HVConstants {
  static constexpr HermesValue kZero = HermesValue(0);
  static constexpr HermesValue kOne = HermesValue(0x3ff0ull << 48);
  static constexpr HermesValue kNegOne = HermesValue(0xbff0ull << 48);
};



class PinnedHermesValue : public HermesValue {
 public:
  constexpr PinnedHermesValue()
      : HermesValue(HermesValue::encodeUndefinedValue()) {}
  constexpr PinnedHermesValue(HermesValue v) : HermesValue(v) {}
  constexpr PinnedHermesValue(const PinnedHermesValue &) = default;
  PinnedHermesValue &operator=(const PinnedHermesValue &phv) {
    setNoBarrier(phv);
    return *this;
  }
  PinnedHermesValue &operator=(const HermesValue &hv) {
    setNoBarrier(hv);
    return *this;
  }
  template <typename T> inline PinnedHermesValue &operator=(PseudoHandle<T> &&hv);
} HERMES_ATTRIBUTE_WARN_UNUSED_VARIABLES;





template <typename HVType> class GCHermesValueBase final : public HVType {
 public:
  GCHermesValueBase() : HVType(HVType::encodeUndefinedValue()) {}
  
  template <typename NeedsBarriers = std::true_type> GCHermesValueBase(HVType hv, GC &gc);
  
  
  
  template <typename NeedsBarriers = std::true_type> GCHermesValueBase(HVType hv, GC &gc, std::nullptr_t);
  GCHermesValueBase(const HVType &) = delete;

  
  
  template <typename NeedsBarriers = std::true_type> inline void set(HVType hv, GC &gc);

  
  
  
  inline void setNonPtr(HVType hv, GC &gc);

  
  
  
  
  
  inline void unreachableWriteBarrier(GC &gc);

  
  
  
  template <typename InputIt> static inline void fill(InputIt first, InputIt last, HVType fill, GC &gc);

  
  
  
  template <typename InputIt> static inline void uninitialized_fill(InputIt first, InputIt last, HVType fill, GC &gc);


  
  template <typename InputIt, typename OutputIt> static inline OutputIt copy(InputIt first, InputIt last, OutputIt result, GC &gc);


  
  
  
  template <typename InputIt, typename OutputIt> static inline OutputIt uninitialized_copy(InputIt first, InputIt last, OutputIt result, GC &gc);



  
  static inline GCHermesValueBase<HVType> *copy( GCHermesValueBase<HVType> *first, GCHermesValueBase<HVType> *last, GCHermesValueBase<HVType> *result, GC &gc);





  
  
  
  
  static inline GCHermesValueBase<HVType> *uninitialized_copy( GCHermesValueBase<HVType> *first, GCHermesValueBase<HVType> *last, GCHermesValueBase<HVType> *result, GC &gc);




  
  template <typename InputIt, typename OutputIt> static inline OutputIt copy_backward(InputIt first, InputIt last, OutputIt result, GC &gc);


  
  
  static inline void rangeUnreachableWriteBarrier( GCHermesValueBase<HVType> *first, GCHermesValueBase<HVType> *last, GC &gc);


};

using GCHermesValue = GCHermesValueBase<HermesValue>;



struct GCHermesValueUtil {
  
  static inline void copyToPinned( const GCHermesValue *first, const GCHermesValue *last, PinnedHermesValue *result);


};

llvh::raw_ostream &operator<<(llvh::raw_ostream &OS, HermesValue hv);



template <typename T, bool b = std::is_floating_point<T>::value> struct SafeNumericEncoder {
  static HermesValue encode(T val) {
    return HermesValue::encodeNumberValue(val);
  }
};

template <typename T> struct SafeNumericEncoder<T, true> {
  static HermesValue encode(T val) {
    return HermesValue::encodeUntrustedDoubleValue(val);
  }
};

} 
} 



