



















extern "C" {




void gf_node_setup(GF_Node *p, u32 tag);

typedef struct _parent_list {
	struct _parent_list *next;
	GF_Node *node;
} GF_ParentList;
















struct _node_interactive_ext {
	
	GF_List *routes;


	
	struct _node_js_binding *js_binding;



	
	GF_DOMEventTarget *dom_evt;

	
	GF_List *animations;


};

typedef struct _nodepriv {
	
	u16 tag;
	
	u16 num_instances;
	
	u32 flags;
	
	struct __tag_scene_graph *scenegraph;

	
	void (*UserCallback)(struct _base_node *node, void *render_stack, Bool node_destroy);
	
	void *UserPrivate;

	
	GF_ParentList *parents;

	
	struct _node_interactive_ext *interact;
} NodePriv;


typedef struct __tag_node_id {
	struct __tag_node_id *next;
	GF_Node *node;

	
	u32 NodeID;
	
	char *NodeName;
} NodeIDedItem;

typedef struct {
	char *name;
	char *qname;
	u32 xmlns_id;
} GF_XMLNS;

struct __tag_scene_graph {
	
	u64 __reserved_null;

	
	NodeIDedItem *id_node, *id_node_last;

	
	GF_Node *RootNode;

	
	GF_List *exported_nodes;


	
	void *userpriv;

	
	
	gf_sg_node_init_callback NodeCallback;
	
	Double (*GetSceneTime)(void *userpriv);

	
	struct __tag_scene_graph *parent_scene;

	
	u32 width, height;
	Bool usePixelMetrics;

	Bool modified;

	
	gf_sg_script_action script_action;
	void *script_action_cbck;

	
	void (*script_load)(GF_Node *node);
	
	void (*on_node_modified)(struct __tag_scene_graph *sg, GF_Node *node, GF_FieldInfo *info, GF_Node *script);


	
	Bool graph_has_been_reset;



	
	GF_List *ns;

	
	char szNameBuffer[100];



	
	GF_List *Routes;

	
	struct _proto_instance *pOwningProto;

	
	GF_List *protos;
	
	GF_List *unregistered_protos;

	
	GF_List *routes_to_activate;

	
	GF_List *routes_to_destroy;

	u32 simulation_tick;

	GF_SceneGraph *(*GetExternProtoLib)(void *userpriv, MFURL *lib_url);

	u32 max_defined_route_id;

	
	GF_Node *global_qp;




	
	GF_List *use_stack;
	Bool abort_bubbling;


	GF_Mutex *dom_evt_mx;
	GF_DOMEventTarget *dom_evt;
	u32 nb_evts_focus;
	u32 nb_evts_mouse;
	u32 nb_evts_key;
	u32 nb_evts_ui;
	u32 nb_evts_text;
	u32 nb_evts_smil;
	u32 nb_evts_mutation;
	u32 nb_evts_laser;
	u32 nb_evts_media;
	u32 nb_evts_svg;
	GF_DOMEventCategory dom_evt_filter;

	GF_List *xlink_hrefs;
	GF_List *smil_timed_elements;
	GF_List *modified_smil_timed_elements;
	Bool update_smil_timing;

	
	GF_List *listeners_to_add;


	struct __tag_svg_script_ctx *svg_js;
	struct __tag_html_media_script_ctx *html_media_js;





	GF_List *scripts;
	
	u32 reference_count;
	
	GF_List *objects;
	struct _dom_js_data *js_data;
	Bool trigger_gc;

	u32 (*get_element_class)(GF_Node *n);
	u32 (*get_document_class)(GF_SceneGraph *n);
	struct __gf_filter_session *attached_session;

};

void gf_sg_parent_setup(GF_Node *pNode);
void gf_sg_parent_reset(GF_Node *pNode);

void gf_node_changed_internal(GF_Node *node, GF_FieldInfo *field, Bool notify_scripts);

void gf_node_dirty_parent_graph(GF_Node *node);



void gf_node_free(GF_Node *node);


void gf_node_del(GF_Node *node);


GF_Node *gf_sg_new_base_node();



struct _route {
	u8 is_setup;
	
	u8 IS_route;
	
	u8 script_route;

	u32 ID;
	char *name;

	
	GF_SceneGraph *graph;
	u32 lastActivateTime;

	GF_Node *FromNode;
	GF_FieldInfo FromField;

	GF_Node *ToNode;
	GF_FieldInfo ToField;
};

void gf_sg_route_unqueue(GF_SceneGraph *sg, GF_Route *r);

Bool gf_sg_route_activate(GF_Route *r);
void gf_sg_route_queue(GF_SceneGraph *pSG, GF_Route *r);
void gf_sg_destroy_routes(GF_SceneGraph *sg);
void gf_sg_route_setup(GF_Route *r);



GF_Node *gf_sg_mpeg4_node_new(u32 NodeTag);
u32 gf_sg_mpeg4_node_get_child_ndt(GF_Node *node);
GF_Err gf_sg_mpeg4_node_get_field_index(GF_Node *node, u32 inField, u8 code_mode, u32 *fieldIndex);
GF_Err gf_sg_mpeg4_node_get_field(GF_Node *node, GF_FieldInfo *field);
u32 gf_sg_mpeg4_node_get_field_count(GF_Node *node, u8 code_mode);
void gf_sg_mpeg4_node_del(GF_Node *node);
const char *gf_sg_mpeg4_node_get_class_name(u32 NodeTag);
Bool gf_sg_mpeg4_node_get_aq_info(GF_Node *node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits);
s32 gf_sg_mpeg4_node_get_field_index_by_name(GF_Node *node, char *name);



GF_Node *gf_sg_x3d_node_new(u32 NodeTag);
GF_Err gf_sg_x3d_node_get_field(GF_Node *node, GF_FieldInfo *field);
u32 gf_sg_x3d_node_get_field_count(GF_Node *node);
void gf_sg_x3d_node_del(GF_Node *node);
const char *gf_sg_x3d_node_get_class_name(u32 NodeTag);
s32 gf_sg_x3d_node_get_field_index_by_name(GF_Node *node, char *name);
Bool gf_x3d_get_node_type(u32 NDT_Tag, u32 NodeTag);




void gf_sg_mfint32_del(MFInt32 par);
void gf_sg_mffloat_del(MFFloat par);
void gf_sg_mfdouble_del(MFDouble par);
void gf_sg_mfbool_del(MFBool par);
void gf_sg_mfcolor_del(MFColor par);
void gf_sg_mfcolorrgba_del(MFColorRGBA par);
void gf_sg_mfrotation_del(MFRotation par);
void gf_sg_mfstring_del(MFString par);
void gf_sg_mftime_del(MFTime par);
void gf_sg_mfvec2f_del(MFVec2f par);
void gf_sg_mfvec3f_del(MFVec3f par);
void gf_sg_mfvec4f_del(MFVec4f par);
void gf_sg_mfvec2d_del(MFVec2d par);
void gf_sg_mfvec3d_del(MFVec3d par);
void gf_sg_sfimage_del(SFImage im);
void gf_sg_sfstring_del(SFString par);
void gf_sg_mfscript_del(MFScript sc);
void gf_sg_sfcommand_del(SFCommandBuffer cb);
void gf_sg_sfurl_del(SFURL url);
	void gf_sg_mfattrref_del(MFAttrRef par);

Bool gf_sg_vrml_node_init(GF_Node *node);
Bool gf_sg_vrml_node_changed(GF_Node *node, GF_FieldInfo *field);








u32 gf_sg_vrml_get_sf_size(u32 FieldType);


u32 gf_sg_field_type_by_name(char *fieldType);


GF_Command *gf_sg_vrml_command_clone(GF_Command *com, GF_SceneGraph *inGraph, Bool force_clone);





struct _protofield {
	u8 EventType;
	u8 FieldType;
	
	char *FieldName;

	
	void *def_value;

	GF_Node *def_sfnode_value;
	GF_ChildNodeItem *def_mfnode_value;

	
	u32 IN_index, OUT_index, DEF_index, ALL_index;

	
	u32 QP_Type, hasMinMax;
	void *qp_min_value, *qp_max_value;
	
	u32 NumBits;

	
	u32 Anim_Type;

	void *userpriv;
	void (*OnDelete)(void *ptr);
};

GF_ProtoFieldInterface *gf_sg_proto_new_field_interface(u32 FieldType);


GF_Err gf_bifs_proto_field_set_aq_info(GF_ProtoFieldInterface *field, u32 QP_Type, u32 hasMinMax, u32 QPSFType, void *qp_min_value, void *qp_max_value, u32 QP13_NumBits);


typedef struct {
	u8 EventType;
	u8 FieldType;
	u8 has_been_accessed;
	void *field_pointer;
	void (*on_event_in)(GF_Node *pThis, struct _route *route);	
} GF_ProtoField;


struct _proto {
	
	u32 ID;
	char *Name;
	GF_List *proto_fields;

	
	struct __tag_scene_graph *parent_graph;
	
	struct __tag_scene_graph *sub_graph;

	
	GF_List *node_code;

	
	u32 NumIn, NumOut, NumDef, NumDyn;

	void *userpriv;
	void (*OnDelete)(void *ptr);

	
	MFURL ExternProto;

	
	GF_List *instances;
};


u32 gf_sg_proto_get_num_fields(GF_Node *node, u8 code_mode);
GF_Err gf_sg_proto_get_field(GF_Proto *proto, GF_Node *node, GF_FieldInfo *field);

enum {
	GF_SG_PROTO_LOADED	=	1, GF_SG_PROTO_IS_GROUPING =	2, GF_SG_PROTO_HARDCODED =	4, };



typedef struct _proto_instance {
	
	BASE_NODE   GF_Proto *proto_interface;



	
	GF_List *fields;

	
	GF_List *node_code;

	
	GF_Node *RenderingNode;

	
	char *proto_name;

	
	GF_List *scripts_to_load;

	u32 flags;
} GF_ProtoInstance;


void gf_sg_proto_del_instance(GF_ProtoInstance *inst);
GF_Err gf_sg_proto_get_field_index(GF_ProtoInstance *proto, u32 index, u32 code_mode, u32 *all_index);
Bool gf_sg_proto_get_aq_info(GF_Node *Node, u32 FieldIndex, u8 *QType, u8 *AType, Fixed *b_min, Fixed *b_max, u32 *QT13_bits);
GF_Err gf_sg_proto_get_field_ind_static(GF_Node *Node, u32 inField, u8 IndexMode, u32 *allField);
GF_Node *gf_sg_proto_create_node(GF_SceneGraph *scene, GF_Proto *proto, GF_ProtoInstance *from_inst);
void gf_sg_proto_instantiate(GF_ProtoInstance *proto_node);


u32 gf_sg_proto_get_root_tag(GF_Proto *proto);



void gf_sg_proto_propagate_event(GF_Node *node, u32 fieldIndex, GF_Node *from_node);

s32 gf_sg_proto_get_field_index_by_name(GF_Proto *proto, GF_Node *node, char *name);

GF_Node *gf_vrml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id_suffix);





GF_Err gf_node_try_destroy(GF_SceneGraph *sg, GF_Node *pNode, GF_Node *parentNode);





void gf_svg_reset_iri(GF_SceneGraph *sg, XMLRI*iri);

void gf_svg_delete_paint		(GF_SceneGraph *sg, SVG_Paint *paint);
void gf_smil_delete_times		(GF_List *l);

void gf_smil_delete_key_types	(GF_List *l);

u32 gf_node_get_attribute_count(GF_Node *node);
GF_Err gf_node_get_attribute_info(GF_Node *node, GF_FieldInfo *info) ;




typedef struct __xlink_attrip_ptrs {
	XMLRI *href;
	SVG_ContentType *type;
	SVG_String *title;
	XMLRI *arcrole;
	XMLRI *role;
	SVG_String *show;
	SVG_String *actuate;
} XLinkAttributesPointers;

typedef struct __smil_time_attrip_ptrs {
	SMIL_Times *begin, *end;
	SVG_Clock *clipBegin, *clipEnd;
	SMIL_Duration *dur;
	SMIL_RepeatCount *repeatCount;
	SMIL_Duration *repeatDur;
	SMIL_Restart *restart;
	SMIL_Fill *fill;
	SMIL_Duration *max;
	SMIL_Duration *min;
	struct _smil_timing_rti *runtime; 
} SMILTimingAttributesPointers;

typedef struct __smil_sync_attrip_ptrs {
	SMIL_SyncBehavior *syncBehavior, *syncBehaviorDefault;
	SMIL_SyncTolerance *syncTolerance, *syncToleranceDefault;
	SVG_Boolean *syncMaster;
	XMLRI *syncReference;
} SMILSyncAttributesPointers;

typedef struct __smil_anim_attrip_ptrs {
	SMIL_AttributeName *attributeName;
	SMIL_AttributeType *attributeType;
	SMIL_AnimateValue *to, *by, *from;
	SMIL_AnimateValues *values;
	SMIL_CalcMode *calcMode;
	SMIL_Accumulate *accumulate;
	SMIL_Additive *additive;
	SMIL_KeySplines *keySplines;
	SMIL_KeyTimes *keyTimes;
	SVG_TransformType *type;
	SVG_Boolean *lsr_enabled;

	SMIL_KeyPoints *keyPoints;
	SVG_String *origin;
	SVG_Rotate *rotate;
	SVG_PathData *path;
} SMILAnimationAttributesPointers;


typedef struct {
	GF_DOM_BASE_NODE   XLinkAttributesPointers *xlinkp;


	SMILAnimationAttributesPointers *animp;
	SMILTimingAttributesPointers *timingp;
} SVGTimedAnimBaseElement;

GF_Err gf_node_animation_add(GF_Node *node, void *animation);
GF_Err gf_node_animation_del(GF_Node *node);
u32 gf_node_animation_count(GF_Node *node);
void *gf_node_animation_get(GF_Node *node, u32 i);
Bool gf_svg_is_inherit(GF_FieldInfo *a);
Bool gf_svg_is_current_color(GF_FieldInfo *a);

void gf_svg_reset_animate_values(SMIL_AnimateValues anim_values, GF_SceneGraph *sg);

Bool gf_svg_is_timing_tag(u32 tag);
Bool gf_svg_is_animation_tag(u32 tag);
u32 gf_svg_get_modification_flags(SVG_Element *n, GF_FieldInfo *info);

Bool gf_svg_resolve_smil_times(GF_Node *anim, void *event_base_element, GF_List *smil_times, Bool is_end, const char *node_name);




enum {
	SMIL_STATUS_WAITING_TO_BEGIN = 0, SMIL_STATUS_ACTIVE, SMIL_STATUS_POST_ACTIVE, SMIL_STATUS_FROZEN, SMIL_STATUS_DONE };





typedef struct {
	u32 activation_cycle;
	u32 nb_iterations;

	
	Bool min_active;

	
	Double begin, end, simple_duration, active_duration, repeat_duration;




} SMIL_Interval;

struct _smil_timing_rti {
	GF_Node *timed_elt;
	SMILTimingAttributesPointers *timingp;

	Double scene_time;
	Fixed normalized_simple_time;
	Bool force_reevaluation;

	
	u8 status;

	SMIL_Interval *current_interval;
	SMIL_Interval *next_interval;

	
	Bool postpone;

	void (*evaluate)(struct _smil_timing_rti *rti, Fixed normalized_simple_time, GF_SGSMILTimingEvalState state);
	GF_SGSMILTimingEvalState evaluate_status;


	
	void (*activation)(struct _smil_timing_rti *rti, Fixed normalized_simple_time);

	
	void (*freeze)(struct _smil_timing_rti *rti, Fixed normalized_simple_time);

	
	void (*restore)(struct _smil_timing_rti *rti, Fixed normalized_simple_time);

	
	void (*fraction_activation)(struct _smil_timing_rti *rti, Fixed normalized_simple_time);

	
	Fixed fraction;

	Bool paused;
	Double media_duration;

	
	struct _smil_anim_rti *rai;
};

void gf_smil_timing_init_runtime_info(GF_Node *timed_elt);
void gf_smil_timing_delete_runtime_info(GF_Node *timed_elt, SMIL_Timing_RTI *rti);
Fixed gf_smil_timing_get_normalized_simple_time(SMIL_Timing_RTI *rti, Double scene_time, Bool *force_end);

s32 gf_smil_timing_notify_time(SMIL_Timing_RTI *rti, Double scene_time);




typedef struct {
	GF_List *anims;
	GF_FieldInfo specified_value;
	GF_FieldInfo presentation_value;
	Bool is_property;
	GF_FieldInfo parent_presentation_value;
	GF_FieldInfo current_color_value;
	void *orig_dom_ptr;
	
	Bool presentation_value_changed;
	
	u32 dirty_flags;
	Bool dirty_parents;
} SMIL_AttributeAnimations;


typedef struct _smil_anim_rti {
	SMIL_AttributeAnimations *owner;

	Bool is_first_anim;

	
	GF_Node *anim_elt;
	SMILAnimationAttributesPointers *animp;
	SMILTimingAttributesPointers *timingp;
	XLinkAttributesPointers *xlinkp;

	
	GF_Matrix2D identity;
	GF_FieldInfo default_transform_value;

	
	GF_FieldInfo interpolated_value;

	
	
	GF_FieldInfo last_specified_value;

	
	GF_FieldInfo tmp_value;

	
	u32 values_count;
	u32 key_times_count;
	u32 key_points_count;
	u32 key_splines_count;


	
	Bool	change_detection_mode;
	Bool	interpolated_value_changed;
	s32		previous_key_index;
	u32		previous_keytime_index;
	Fixed	previous_coef;
	s32		previous_iteration;
	Bool	anim_done;

	GF_Path *path;
	u8 rotate;
	GF_PathIterator *path_iterator;
	Fixed length;

} SMIL_Anim_RTI;

void gf_smil_anim_init_node(GF_Node *node);
void gf_smil_anim_init_discard(GF_Node *node);
void gf_smil_anim_init_runtime_info(GF_Node *node);
void gf_smil_anim_delete_runtime_info(SMIL_Anim_RTI *rai);
void gf_smil_anim_delete_animations(GF_Node *e);
void gf_smil_anim_remove_from_target(GF_Node *anim, GF_Node *target);
GF_Node *gf_smil_anim_get_target(GF_Node *e);

void gf_sg_handle_dom_event(GF_Node *hdl, GF_DOM_Event *event, GF_Node *observer);
void gf_smil_setup_events(GF_Node *node);

void gf_smil_anim_reset_variables(SMIL_Anim_RTI *rai);
void gf_smil_anim_set_anim_runtime_in_timing(GF_Node *n);

void gf_smil_timing_pause(GF_Node *node);
void gf_smil_timing_resume(GF_Node *node);




typedef struct _gf_vrml_script_priv GF_ScriptPriv;



void gf_sg_script_init(GF_Node *node);

GF_Err gf_sg_script_get_field(GF_Node *node, GF_FieldInfo *info);

u32 gf_sg_script_get_num_fields(GF_Node *node, u8 IndexMode);

GF_Err gf_sg_script_get_field_index(GF_Node *Node, u32 inField, u8 IndexMode, u32 *allField);

GF_Err gf_sg_script_prepare_clone(GF_Node *dest, GF_Node *orig);

struct _scriptfield {
	u32 eventType;
	u32 fieldType;
	char *name;

	s32 IN_index, OUT_index, DEF_index;
	u32 ALL_index;

	
	void *pField;

	Double last_route_time;
	Bool activate_event_out;
	s32 magic;
};








void gf_js_vrml_flush_event_out(GF_Node *node, GF_ScriptPriv *priv);


enum {
	GF_DOM_EXC_INDEX_SIZE_ERR = 1, GF_DOM_EXC_DOMSTRING_SIZE_ERR = 2, GF_DOM_EXC_HIERARCHY_REQUEST_ERR = 3, GF_DOM_EXC_WRONG_DOCUMENT_ERR = 4, GF_DOM_EXC_INVALID_CHARACTER_ERR = 5, GF_DOM_EXC_NO_DATA_ALLOWED_ERR = 6, GF_DOM_EXC_NO_MODIFICATION_ALLOWED_ERR = 7, GF_DOM_EXC_NOT_FOUND_ERR = 8, GF_DOM_EXC_NOT_SUPPORTED_ERR = 9, GF_DOM_EXC_INUSE_ATTRIBUTE_ERR = 10, GF_DOM_EXC_INVALID_STATE_ERR = 11, GF_DOM_EXC_SYNTAX_ERR = 12, GF_DOM_EXC_INVALID_MODIFICATION_ERR = 13, GF_DOM_EXC_NAMESPACE_ERR = 14, GF_DOM_EXC_INVALID_ACCESS_ERR = 15, GF_DOM_EXC_VALIDATION_ERR = 16, GF_DOM_EXC_TYPE_MISMATCH_ERR = 17, GF_DOM_EXC_SECURITY_ERR = 18, GF_DOM_EXC_NETWORK_ERR = 19, GF_DOM_EXC_ABORT_ERR = 20, GF_DOM_EXC_URL_MISMATCH_ERR = 21, GF_DOM_EXC_QUOTA_EXCEEDED_ERR = 22, GF_DOM_EXC_TIMEOUT_ERR = 23, GF_DOM_EXC_INVALID_NODE_TYPE_ERR = 24, GF_DOM_EXC_DATA_CLONE_ERR = 25,  };


























void gf_sg_handle_dom_event_for_vrml(GF_Node *hdl, GF_DOM_Event *event, GF_Node *observer);

Bool gf_sg_javascript_initialized();


SVG_Element *gf_svg_create_node(u32 tag);
Bool gf_svg_node_init(GF_Node *node);
void gf_svg_node_del(GF_Node *node);
Bool gf_svg_node_changed(GF_Node *node, GF_FieldInfo *field);
const char *gf_xml_get_element_name(GF_Node *node);

SVGAttribute *gf_node_create_attribute_from_datatype(u32 data_type, u32 attribute_tag);

GF_Err gf_node_get_attribute_by_name(GF_Node *node, char *name, u32 xmlns_code, Bool create_if_not_found, Bool set_default, GF_FieldInfo *field);
void *gf_svg_get_property_pointer_from_tag(SVGPropertiesPointers *output_property_context, u32 prop_tag);
void *gf_svg_get_property_pointer(SVG_Element *elt, void *input_attribute, SVGPropertiesPointers *output_property_context);

Bool gf_svg_is_property(GF_Node *node, GF_FieldInfo *target_attribute);


u32 svg_parse_point(SVG_Point *p, char *value_string);


GF_Err gf_node_activate(GF_Node *node);

GF_Err gf_node_deactivate(GF_Node *node);


void gf_sg_listener_post_add(GF_Node *obs, GF_Node *listener);

void gf_dom_listener_process_add(GF_SceneGraph *sg);
void gf_dom_listener_reset_deferred(GF_SceneGraph *sg);


void gf_node_delete_attributes(GF_Node *node);

GF_Node *gf_xml_node_clone(GF_SceneGraph *inScene, GF_Node *orig, GF_Node *cloned_parent, char *inst_id, Bool deep);

GF_Err gf_dom_listener_del(GF_Node *listener, GF_DOMEventTarget *target);

GF_DOMHandler *gf_dom_listener_build_ex(GF_Node *node, u32 event_type, u32 event_parameter, GF_Node *handler, GF_Node **out_listener);

void	gf_dom_event_dump_listeners(GF_Node *n, FILE *f);
void	gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target);
void	gf_dom_event_target_del(GF_DOMEventTarget *target);
GF_Err	gf_dom_event_remove_listener_from_parent(GF_DOMEventTarget *event_target, GF_Node *listener);


GF_DOMEventTarget *gf_dom_event_get_target_from_node(GF_Node *n);


}




