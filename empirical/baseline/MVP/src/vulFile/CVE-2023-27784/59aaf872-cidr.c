

















extern int debug;


static tcpr_cidr_t *cidr2cidr(char *);


void print_cidr(tcpr_cidr_t * mycidr)
{
    tcpr_cidr_t *cidr_ptr;

    fprintf(stderr, "Cidr List: ");

    cidr_ptr = mycidr;
    while (cidr_ptr != NULL) {
        
        fprintf(stderr, "%s/%d, ", get_cidr2name(cidr_ptr, RESOLVE), cidr_ptr->masklen);

        
        if (cidr_ptr->next != NULL) {
            cidr_ptr = cidr_ptr->next;
        }
        else {
            break;
        }
    }
    fprintf(stderr, "\n");
}


void destroy_cidr(tcpr_cidr_t * cidr)
{

    if (cidr != NULL) {
        if (cidr->next != NULL)
            destroy_cidr(cidr->next);

        safe_free(cidr);
    }
    return;

}


void add_cidr(tcpr_cidr_t ** cidrdata, tcpr_cidr_t ** newcidr)
{
    tcpr_cidr_t *cidr_ptr;
    dbg(1, "Running new_cidr()");

    if (*cidrdata == NULL) {
        *cidrdata = *newcidr;
    } else {
        cidr_ptr = *cidrdata;

        while (cidr_ptr->next != NULL)
            cidr_ptr = cidr_ptr->next;

        cidr_ptr->next = *newcidr;
    }
}


u_char * ip2cidr(const unsigned long ip, const int masklen)
{
    u_char *network;
    char mask[32];

    network = (u_char *)safe_malloc(20);

    strlcpy((char *)network, (char *)get_addr2name4(ip, RESOLVE), 20);

    strcat((char *)network, "/");
    snprintf(mask, sizeof(mask), "%d", masklen);
    if (masklen < 10)
        strncat((char *)network, mask, 1);
    else strncat((char *)network, mask, 2);

    return (network);
}



tcpr_cidr_t * new_cidr(void)
{
    tcpr_cidr_t *newcidr;

    newcidr = (tcpr_cidr_t *)safe_malloc(sizeof(tcpr_cidr_t));
    
    memset(newcidr, '\0', sizeof(tcpr_cidr_t));
    newcidr->masklen = 99;
    newcidr->next = NULL;

    return (newcidr);
}


tcpr_cidrmap_t * new_cidr_map(void)
{
    tcpr_cidrmap_t *new;

    new = (tcpr_cidrmap_t *)safe_malloc(sizeof(tcpr_cidrmap_t));
    
    memset(new, '\0', sizeof(tcpr_cidrmap_t));
    new->next = NULL;

    return (new);
}



static tcpr_cidr_t * cidr2cidr(char *cidr)
{
    int count = 0;
    unsigned int octets[4];     
    tcpr_cidr_t *newcidr;
    char networkip[16], tempoctet[4];
    int family;
    char* p;

    assert(cidr);

    newcidr = new_cidr();

    for (p = cidr; *p; ++p) {
        if (*p == '#') {
            *p = ':';
        } else if (*p == ']') {
            *p = 0;
            break;
        }
    }

    
    count = sscanf(cidr, "%u.%u.%u.%u/%d", &octets[0], &octets[1], &octets[2], &octets[3], &newcidr->masklen);

    if (count == 4) {
        newcidr->masklen = 32;
        family = AF_INET;
    } else if (count == 5) {
        family = AF_INET;
    } else {
        p = strstr(cidr, "/");
        if (p) {
            *p = 0;
            ++p;
            sscanf(p, "%d", &newcidr->masklen);
        } else {
            newcidr->masklen = 128;
        }

        if (newcidr->masklen < 0 || newcidr->masklen > 128)
            goto error;

        
        if (*cidr == '[')
            cidr ++;

        if (get_name2addr6(cidr, RESOLVE, &newcidr->u.network6) > 0) {
            family = AF_INET6;
        } else {
            goto error;
        }
    }

    if (family == AF_INET) {
        
        if (newcidr->masklen > 32)
            goto error;

        
        memset(networkip, '\0', 16);
        for (count = 0; count < 4; count++) {
            if (octets[count] > 255)
                goto error;

            snprintf(tempoctet, sizeof(octets[count]), "%u", octets[count]);
            strcat(networkip, tempoctet);
            
            if (count < 3)
                strcat(networkip, ".");
        }

        

        inet_aton(networkip, (struct in_addr *)&newcidr->u.network);

        newcidr->network = inet_addr(networkip);

    } else if (family == AF_INET6) {
        
    } else {
        goto error;
    }

    newcidr->family = family;
    return (newcidr);

    
error:
    errx(-1, "%s: %s", "Unable to parse as a valid CIDR", cidr);
    return NULL;
}

static void  mask_cidr6(char **cidrin, char* delim)
{
    if (**cidrin == '[' && *delim == ':') {
        char *p;
        ++*cidrin;
        
        for (p = *cidrin; *p && *p != ']'; ++p) {
            if (*p == ':') {
                *p = '#';
            }
        }
    }
}


int parse_cidr(tcpr_cidr_t ** cidrdata, char *cidrin, char *delim)
{
    tcpr_cidr_t *cidr_ptr;             
    char *network;
    char *token = NULL;

    mask_cidr6(&cidrin, delim);

    
    network = strtok_r(cidrin, delim, &token);

    *cidrdata = cidr2cidr(network);
    cidr_ptr = *cidrdata;

    
    while (1) {
        if (token)
            mask_cidr6(&token, delim);

        network = strtok_r(NULL, delim, &token);
        
        if (network == NULL)
            break;

        
        cidr_ptr->next = cidr2cidr(network);
        cidr_ptr = cidr_ptr->next;
    }
    return 1;

}


int parse_endpoints(tcpr_cidrmap_t ** cidrmap1, tcpr_cidrmap_t ** cidrmap2, const char *optarg)
{

    char *map = NULL, newmap[NEWMAP_LEN];
    char *token = NULL;
    char *string;
    char *p;
    int res = 0;

    string = safe_strdup(optarg);

    if (*string == '[') {
        
        memset(newmap, '\0', NEWMAP_LEN);
        p = strstr(string, "]:[");
        if (!p)
            goto done;
            
        *p = 0;
        strlcpy(newmap, "[::/0]:", NEWMAP_LEN);
        strlcat(newmap, string, NEWMAP_LEN);
        strlcat(newmap, "]", NEWMAP_LEN);
        
        if (! parse_cidr_map(cidrmap1, newmap))
            goto done;

        
        memset(newmap, '\0', NEWMAP_LEN);
        strlcpy(newmap, "[::/0]:", NEWMAP_LEN);
        strlcat(newmap, p + 2, NEWMAP_LEN);

        if (! parse_cidr_map(cidrmap2, newmap))
            goto done;

    } else {
        
        memset(newmap, '\0', NEWMAP_LEN);
        map = strtok_r(string, ":", &token);

        strlcpy(newmap, "0.0.0.0/0:", NEWMAP_LEN);
        strlcat(newmap, map, NEWMAP_LEN);
        if (! parse_cidr_map(cidrmap1, newmap))
            goto done;
    
        
        memset(newmap, '\0', NEWMAP_LEN);
        map = strtok_r(NULL, ":", &token);
    
        strlcpy(newmap, "0.0.0.0/0:", NEWMAP_LEN);
        strlcat(newmap, map, NEWMAP_LEN);
        if (! parse_cidr_map(cidrmap2, newmap))
            goto done;
    }
    
    
    res = 1;

done:
    safe_free(string);
    return res;
}



int parse_cidr_map(tcpr_cidrmap_t **cidrmap, const char *optarg)
{
    tcpr_cidr_t *cidr = NULL;
    char *map;
    char *token = NULL, *string;
    tcpr_cidrmap_t *ptr;
    int res = 0;
    
    string = safe_strdup(optarg);

    
    map = strtok_r(string, ",", &token);
    if (! parse_cidr(&cidr, map, ":"))
        goto done;

    
    if (cidr->next == NULL)
        goto done;

    
    *cidrmap = new_cidr_map();
    ptr = *cidrmap;

    ptr->from = cidr;
    ptr->to = cidr->next;
    ptr->from->next = NULL;

    
    while(1) {
        map = strtok_r(NULL, ",", &token);
        if (map == NULL)
            break;

        if (! parse_cidr(&cidr, map, ":"))
            goto done;

        
        if (cidr->next == NULL)
            goto done;

        
        ptr->next = new_cidr_map();
        ptr = ptr->next;
        ptr->from = cidr;
        ptr->to = cidr->next;
        ptr->from->next = NULL;
    }

    
    res = 1;

done:
    safe_free(string);
    return res;
}


int ip_in_cidr(const tcpr_cidr_t * mycidr, const unsigned long ip)
{
    unsigned long ipaddr = 0, network = 0, mask = 0;
    int ret = 0;

    char netstr[20];

    
    if (mycidr->family != AF_INET)
        return 0;

    
    if (mycidr->masklen == 0 && mycidr->u.network == 0)
        return 1;

    mask = ~0;                  

    
    mask = mask << (32 - mycidr->masklen);

    
    ipaddr = ntohl(ip) & mask;

    network = htonl(mycidr->u.network) & mask;



    
    strlcpy(netstr, get_addr2name4(mycidr->u.network, RESOLVE), 20);


    
    if (network == ipaddr) {

        dbgx(1, "The ip %s is inside of %s/%d", get_addr2name4(ip, RESOLVE), netstr, mycidr->masklen);

        ret = 1;
    } else {

        dbgx(1, "The ip %s is not inside of %s/%d", get_addr2name4(ip, RESOLVE), netstr, mycidr->masklen);

        ret = 0;
    }
    return ret;

}

static int ip6_addr_is_unspec(const struct tcpr_in6_addr *addr)
{
    return addr->tcpr_s6_addr32[0] == 0 && addr->tcpr_s6_addr32[1] == 0 && addr->tcpr_s6_addr32[2] == 0 && addr->tcpr_s6_addr32[3] == 0;
}

int ip6_in_cidr(const tcpr_cidr_t * mycidr, const struct tcpr_in6_addr *addr)
{
    int ret = 0;

    char netstr[INET6_ADDRSTRLEN];

    uint32_t i, j, k;

    if (mycidr->family != AF_INET6)
        return 0;

    
    if (mycidr->masklen == 0 && ip6_addr_is_unspec(addr))
        return 1;

    j = mycidr->masklen / 8;

    for (i = 0; i < j; i++) {
        if (addr->tcpr_s6_addr[i] != mycidr->u.network6.tcpr_s6_addr[i]) {
            ret = 0;
            goto out;
        }
    }
    
    if ((k = mycidr->masklen % 8) == 0) {
        ret = 1;
        goto out;
    }

    k = (uint32_t)~0 << (8 - k);
    i = addr->tcpr_s6_addr[j] & k;
    j = mycidr->u.network6.tcpr_s6_addr[j] & k;
    ret = i == j;
out:


    
    strlcpy(netstr, get_addr2name6(&mycidr->u.network6, RESOLVE), INET6_ADDRSTRLEN);


    
    if (ret) {

        dbgx(1, "The ip %s is inside of %s/%d", get_addr2name6(addr, RESOLVE), netstr, mycidr->masklen);

    } else {

        dbgx(1, "The ip %s is not inside of %s/%d", get_addr2name6(addr, RESOLVE), netstr, mycidr->masklen);

    }
    return ret;

}




int check_ip_cidr(tcpr_cidr_t * cidrdata, const unsigned long ip)
{
    tcpr_cidr_t *mycidr;

    
    if (cidrdata == NULL)
        return 1;
        
    mycidr = cidrdata;

    
    while (1) {

        
        if (ip_in_cidr(mycidr, ip)) {
            dbgx(3, "Found %s in cidr", get_addr2name4(ip, RESOLVE));
            return 1;
        }
        
        
        if (mycidr->next != NULL) {
            mycidr = mycidr->next;
        } else {
            break;
        }
    }

    
    dbgx(3, "Didn't find %s in cidr", get_addr2name4(ip, RESOLVE));
    return 0;
}

int check_ip6_cidr(tcpr_cidr_t * cidrdata, const struct tcpr_in6_addr *addr)
{
    tcpr_cidr_t *mycidr;

    
    if (cidrdata == NULL) {
        return 1;
    }

    mycidr = cidrdata;

    
    while (1) {

        
        if (ip6_in_cidr(mycidr, addr)) {
            dbgx(3, "Found %s in cidr", get_addr2name6(addr, RESOLVE));
            return 1;
        }
        
        
        if (mycidr->next != NULL) {
            mycidr = mycidr->next;
        } else {
            break;
        }
    }

    
    dbgx(3, "Didn't find %s in cidr", get_addr2name6(addr, RESOLVE));
    return 0;
}



char * cidr2iplist(tcpr_cidr_t * cidr, char delim)
{
    char *list = NULL;
    char ipaddr[18], tempbuff[20];
    u_int32_t size, addr, first, last, numips;
    struct in_addr in;
    int i;

    
    numips = 2;
    for (i = 2; i <= (32 - cidr->masklen); i++)
        numips *= 2;

    size = 17 * numips - 1;

    list = (char *)safe_malloc(size);

    memset(list, 0, size);

    
    first = ntohl(cidr->u.network) + 1;
    last = first + numips - 3;

    dbgx(1, "First: %u\t\tLast: %u", first, last);

    
    for (addr = first; addr < last; addr++) {
        in.s_addr = htonl(addr);
        snprintf(tempbuff, 17, "%s%c", inet_ntoa(in), delim);
        memcpy(ipaddr, tempbuff, 16);
        dbgx(2, "%s", ipaddr);
        strlcat(list, ipaddr, size);
    }

    
    in.s_addr = htonl(addr);
    snprintf(ipaddr, 17, "%s", inet_ntoa(in));
    strlcat(list, ipaddr, size);

    return list;
}
