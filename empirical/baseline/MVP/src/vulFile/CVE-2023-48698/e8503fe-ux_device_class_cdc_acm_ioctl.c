












 
 
















 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 
 







 
 
 
 
 
 
 
 
 




























UINT _ux_device_class_cdc_acm_ioctl(UX_SLAVE_CLASS_CDC_ACM *cdc_acm, ULONG ioctl_function, VOID *parameter)
{

UINT                                                status;
UX_SLAVE_CLASS_CDC_ACM_LINE_CODING_PARAMETER        *line_coding;
UX_SLAVE_CLASS_CDC_ACM_LINE_STATE_PARAMETER         *line_state;

UX_SLAVE_CLASS_CDC_ACM_CALLBACK_PARAMETER           *callback;

UX_SLAVE_ENDPOINT                                   *endpoint;
UX_SLAVE_INTERFACE                                  *interface_ptr;
UX_SLAVE_TRANSFER                                   *transfer_request;

    
    status = UX_SUCCESS;

    
    switch (ioctl_function)
    {

        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_SET_LINE_CODING:
    
            
            line_coding = (UX_SLAVE_CLASS_CDC_ACM_LINE_CODING_PARAMETER *) parameter;
    
            
            cdc_acm -> ux_slave_class_cdc_acm_baudrate  =  line_coding -> ux_slave_class_cdc_acm_parameter_baudrate;
            cdc_acm -> ux_slave_class_cdc_acm_stop_bit  =  line_coding -> ux_slave_class_cdc_acm_parameter_stop_bit;
            cdc_acm -> ux_slave_class_cdc_acm_parity    =  line_coding -> ux_slave_class_cdc_acm_parameter_parity;
            cdc_acm -> ux_slave_class_cdc_acm_data_bit  =  line_coding -> ux_slave_class_cdc_acm_parameter_data_bit;
            
            break;
            
        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_GET_LINE_CODING:
    
            
            line_coding = (UX_SLAVE_CLASS_CDC_ACM_LINE_CODING_PARAMETER *) parameter;
    
            
            line_coding -> ux_slave_class_cdc_acm_parameter_baudrate = cdc_acm -> ux_slave_class_cdc_acm_baudrate;
            line_coding -> ux_slave_class_cdc_acm_parameter_stop_bit = cdc_acm -> ux_slave_class_cdc_acm_stop_bit;
            line_coding -> ux_slave_class_cdc_acm_parameter_parity   = cdc_acm -> ux_slave_class_cdc_acm_parity;
            line_coding -> ux_slave_class_cdc_acm_parameter_data_bit = cdc_acm -> ux_slave_class_cdc_acm_data_bit;
            
            break;
            

        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_GET_LINE_STATE:
        
            
            line_state = (UX_SLAVE_CLASS_CDC_ACM_LINE_STATE_PARAMETER *) parameter;
    
            
            line_state -> ux_slave_class_cdc_acm_parameter_rts = cdc_acm -> ux_slave_class_cdc_acm_data_rts_state;
            line_state -> ux_slave_class_cdc_acm_parameter_dtr = cdc_acm -> ux_slave_class_cdc_acm_data_dtr_state;
            
            break;
            
        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_SET_LINE_STATE:
        
            
            line_state = (UX_SLAVE_CLASS_CDC_ACM_LINE_STATE_PARAMETER *) parameter;
    
            
            cdc_acm -> ux_slave_class_cdc_acm_data_rts_state = line_state -> ux_slave_class_cdc_acm_parameter_rts;
            cdc_acm -> ux_slave_class_cdc_acm_data_dtr_state = line_state -> ux_slave_class_cdc_acm_parameter_dtr;
            
            break;
            

        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_ABORT_PIPE:

            
            interface_ptr =  cdc_acm -> ux_slave_class_cdc_acm_interface;
    
            
            endpoint =  interface_ptr -> ux_slave_interface_first_endpoint;
            
            
            switch( (ULONG) (ALIGN_TYPE) parameter)
            {
                case UX_SLAVE_CLASS_CDC_ACM_ENDPOINT_XMIT : 
    
                
                if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
                {

                    
                    endpoint =  endpoint -> ux_slave_endpoint_next_endpoint;
                }
                break;
                
                case UX_SLAVE_CLASS_CDC_ACM_ENDPOINT_RCV : 
    
                
                if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_OUT)
                {

                    
                    endpoint =  endpoint -> ux_slave_endpoint_next_endpoint;
                }
                break;
                


                default :
                
                
                status =  UX_ENDPOINT_HANDLE_UNKNOWN;
            }
        
            
            transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;



            
            _ux_device_stack_transfer_abort(transfer_request, UX_TRANSFER_STATUS_ABORT);
            if ((ULONG) (ALIGN_TYPE) parameter == UX_SLAVE_CLASS_CDC_ACM_ENDPOINT_XMIT)
                cdc_acm -> ux_device_class_cdc_acm_write_state = UX_STATE_RESET;
            else cdc_acm -> ux_device_class_cdc_acm_read_state = UX_STATE_RESET;


             
            if (transfer_request -> ux_slave_transfer_request_status ==  UX_TRANSFER_STATUS_PENDING)
            {

                
            _ux_device_stack_transfer_abort(transfer_request, UX_ABORTED);

            }

            break;

        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_SET_READ_TIMEOUT:
        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_SET_WRITE_TIMEOUT:

            
            interface_ptr =  cdc_acm -> ux_slave_class_cdc_acm_interface;

            
            endpoint =  interface_ptr -> ux_slave_interface_first_endpoint;

            
            if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != (ULONG)((ioctl_function == UX_SLAVE_CLASS_CDC_ACM_IOCTL_SET_READ_TIMEOUT) ? UX_ENDPOINT_OUT : UX_ENDPOINT_IN))
                endpoint = endpoint -> ux_slave_endpoint_next_endpoint;

            
            transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;

             
            if (transfer_request -> ux_slave_transfer_request_status ==  UX_TRANSFER_STATUS_PENDING)
                status = UX_ERROR;
            else transfer_request -> ux_slave_transfer_request_timeout = (ULONG) (ALIGN_TYPE) parameter;

            break;



        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_TRANSMISSION_START:

            
            if (cdc_acm -> ux_slave_class_cdc_acm_transmission_status == UX_TRUE)
            {
                
                return(UX_ERROR);
            
            }
            
            
            callback = (UX_SLAVE_CLASS_CDC_ACM_CALLBACK_PARAMETER *) parameter;

            
            cdc_acm -> ux_device_class_cdc_acm_write_callback  = callback -> ux_device_class_cdc_acm_parameter_write_callback;

            
            cdc_acm -> ux_device_class_cdc_acm_read_callback = callback -> ux_device_class_cdc_acm_parameter_read_callback;



            
            _ux_utility_thread_resume(&cdc_acm -> ux_slave_class_cdc_acm_bulkin_thread);
            _ux_utility_thread_resume(&cdc_acm -> ux_slave_class_cdc_acm_bulkout_thread);


            
            cdc_acm -> ux_slave_class_cdc_acm_transmission_status = UX_TRUE;
            
            
            return(UX_SUCCESS);

        case UX_SLAVE_CLASS_CDC_ACM_IOCTL_TRANSMISSION_STOP:
        
            
            if (cdc_acm -> ux_slave_class_cdc_acm_transmission_status == UX_TRUE)
            {
        
                
                interface_ptr =  cdc_acm -> ux_slave_class_cdc_acm_interface;
    
                
                endpoint =  interface_ptr -> ux_slave_interface_first_endpoint;

                
                transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
                
                
                _ux_device_stack_transfer_abort(transfer_request, UX_ABORTED);
        
                
                endpoint =  endpoint -> ux_slave_endpoint_next_endpoint;

                
                transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
                
                
                _ux_device_stack_transfer_abort(transfer_request, UX_ABORTED);



                
                _ux_device_thread_suspend(&cdc_acm -> ux_slave_class_cdc_acm_bulkin_thread);
                _ux_device_thread_suspend(&cdc_acm -> ux_slave_class_cdc_acm_bulkout_thread);


                
                cdc_acm -> ux_slave_class_cdc_acm_scheduled_write = UX_FALSE;

                
                cdc_acm -> ux_slave_class_cdc_acm_transmission_status = UX_FALSE;
            }
            else   return(UX_ERROR);



            break;                


        default: 

            
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
    
            
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)
    
            
            status =  UX_FUNCTION_NOT_SUPPORTED;
    }   

    
    return(status);
          
}

