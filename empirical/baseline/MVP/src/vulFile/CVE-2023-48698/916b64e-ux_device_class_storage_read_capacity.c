













 
 




















 
 
 
 
 






 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 











UINT  _ux_device_class_storage_read_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)

{

UINT                    status;
ULONG                   media_status;
UX_SLAVE_TRANSFER       *transfer_request;
UCHAR                   *read_capacity_buffer;

    UX_PARAMETER_NOT_USED(cbwcb);
    UX_PARAMETER_NOT_USED(endpoint_out);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ_CAPACITY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun,  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;

    
    if (status != UX_SUCCESS)
    {



        
        _ux_device_stack_endpoint_stall(endpoint_in);


        
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
        status = UX_SUCCESS;
    }
    else {
    
        
        transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;

        
        read_capacity_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
    
        
        _ux_utility_memory_set(read_capacity_buffer, 0, UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH); 
    
        
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LAST_LBA], storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_last_lba);
    
        
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_BLOCK_SIZE], storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length);
    


        
        storage -> ux_device_class_storage_state = UX_DEVICE_CLASS_STORAGE_STATE_TRANS_START;
        storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_READ;

        storage -> ux_device_class_storage_transfer = transfer_request;
        storage -> ux_device_class_storage_device_length = UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH;
        storage -> ux_device_class_storage_data_length = UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH;
        storage -> ux_device_class_storage_data_count = 0;
        UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);



        
        _ux_device_stack_transfer_request(transfer_request,  UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH, UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH);



        
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
        status = UX_SUCCESS;
    }
        
    
    return(status);
}

