

































extern UINT ux_host_class_hid_report_set_buffer_allocate( UX_HOST_CLASS_HID *hid, UX_HOST_CLASS_HID_CLIENT_REPORT *client_report, UCHAR **allocated);





















































UINT  _ux_host_class_hid_report_set_run(UX_HOST_CLASS_HID *hid, UX_HOST_CLASS_HID_CLIENT_REPORT *client_report)
{

UX_INTERRUPT_SAVE_AREA UX_DEVICE                   *device;
UX_ENDPOINT                 *control_endpoint;
UX_TRANSFER                 *transfer_request;
UCHAR                       *report_buffer;
UX_HOST_CLASS_HID_REPORT    *hid_report;
UINT                        status;


    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HID_REPORT_SET, hid, client_report, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    
    hid_report =  client_report -> ux_host_class_hid_client_report;

    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_hid_name, (VOID *) hid) != UX_SUCCESS)
    {

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, hid, 0, 0, UX_TRACE_ERRORS, 0, 0)

        hid -> ux_host_class_hid_status = UX_HOST_CLASS_INSTANCE_UNKNOWN;
        return(UX_STATE_EXIT);
    }

    
    device = hid -> ux_host_class_hid_device;

    
    if (device == UX_NULL || device -> ux_device_handle != (ULONG)(ALIGN_TYPE)device)
    {

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DEVICE_HANDLE_UNKNOWN, device, 0, 0, UX_TRACE_ERRORS, 0, 0)

        hid -> ux_host_class_hid_status = UX_DEVICE_HANDLE_UNKNOWN;
        return(UX_STATE_EXIT);
    }



    
    if (hid -> ux_host_class_hid_interrupt_out_endpoint != UX_NULL)
    {

        
        transfer_request = &hid -> ux_host_class_hid_interrupt_out_endpoint -> ux_endpoint_transfer_request;
    }
    else  {


        
        control_endpoint =  &device -> ux_device_control_endpoint;
        transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;
    }

    
    if (hid -> ux_host_class_hid_cmd_state == UX_STATE_WAIT)
    {

        
        _ux_system_tasks_run();

        
        if (transfer_request -> ux_transfer_request_state < UX_STATE_WAIT)
        {

            
            _ux_utility_memory_free(hid -> ux_host_class_hid_allocated);
            hid -> ux_host_class_hid_allocated = UX_NULL;

            
            hid -> ux_host_class_hid_flags &= ~UX_HOST_CLASS_HID_FLAG_LOCK;
            device -> ux_device_flags &= ~UX_DEVICE_FLAG_LOCK;

            
            hid -> ux_host_class_hid_cmd_state = UX_STATE_IDLE;
            hid -> ux_host_class_hid_status = transfer_request -> ux_transfer_request_completion_code;
            return(UX_STATE_NEXT);
        }

        
        return(UX_STATE_WAIT);
    }

    
    UX_DISABLE if ((hid -> ux_host_class_hid_flags & UX_HOST_CLASS_HID_FLAG_LOCK) || (device -> ux_device_flags & UX_DEVICE_FLAG_LOCK))

    {

        
        UX_RESTORE return(UX_STATE_LOCK);
    }
    hid -> ux_host_class_hid_flags |= UX_HOST_CLASS_HID_FLAG_LOCK;
    device -> ux_device_flags |= UX_DEVICE_FLAG_LOCK;
    hid -> ux_host_class_hid_cmd_state = UX_STATE_WAIT;
    UX_RESTORE   status = ux_host_class_hid_report_set_buffer_allocate(hid, client_report, &report_buffer);


    if (status != UX_SUCCESS)
    {

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, status, hid, client_report, 0, UX_TRACE_ERRORS, 0, 0)

        
        hid -> ux_host_class_hid_status = status;

        
        hid -> ux_host_class_hid_flags &= ~UX_HOST_CLASS_HID_FLAG_LOCK;
        device -> ux_device_flags &= ~UX_DEVICE_FLAG_LOCK;

        
        hid -> ux_host_class_hid_cmd_state = UX_STATE_ERROR;
        return(UX_STATE_ERROR);
    }
    hid -> ux_host_class_hid_allocated = report_buffer;

    
    transfer_request -> ux_transfer_request_data_pointer =     report_buffer;
    transfer_request -> ux_transfer_request_requested_length = hid_report -> ux_host_class_hid_report_byte_length;
    transfer_request -> ux_transfer_request_function =         UX_HOST_CLASS_HID_SET_REPORT;
    transfer_request -> ux_transfer_request_type =             UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
    transfer_request -> ux_transfer_request_value =            (UINT)((USHORT) hid_report -> ux_host_class_hid_report_id | (USHORT) hid_report -> ux_host_class_hid_report_type << 8);
    transfer_request -> ux_transfer_request_index =            hid -> ux_host_class_hid_interface -> ux_interface_descriptor.bInterfaceNumber;
    UX_TRANSFER_STATE_RESET(transfer_request);

    
    status =  _ux_host_stack_transfer_run(transfer_request);
    if (status != UX_STATE_WAIT)
    {
        _ux_utility_memory_free(hid -> ux_host_class_hid_allocated);
        hid -> ux_host_class_hid_allocated = UX_NULL;

        hid -> ux_host_class_hid_status = transfer_request -> ux_transfer_request_completion_code;

        
        hid -> ux_host_class_hid_flags &= ~UX_HOST_CLASS_HID_FLAG_LOCK;
        device -> ux_device_flags &= ~UX_DEVICE_FLAG_LOCK;

        hid -> ux_host_class_hid_cmd_state = (UCHAR)status;
    }

    
    return(status);
}

