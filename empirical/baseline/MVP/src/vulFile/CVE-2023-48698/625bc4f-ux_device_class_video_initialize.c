









































































UINT  _ux_device_class_video_initialize(UX_SLAVE_CLASS_COMMAND *command)
{

UINT                                    status = UX_SUCCESS;
UX_DEVICE_CLASS_VIDEO                   *video;
UX_DEVICE_CLASS_VIDEO_PARAMETER         *video_parameter;
UX_DEVICE_CLASS_VIDEO_STREAM            *stream;
UX_DEVICE_CLASS_VIDEO_STREAM_PARAMETER  *stream_parameter;
UX_SLAVE_CLASS                          *class_inst;
ULONG                                   memory_size;
ULONG                                   streams_size;
ULONG                                   i;


    
    class_inst =  command -> ux_slave_class_command_class_ptr;

    
    video_parameter = (UX_DEVICE_CLASS_VIDEO_PARAMETER *)command -> ux_slave_class_command_parameter;

    
    memory_size  = sizeof(UX_DEVICE_CLASS_VIDEO);

    
    streams_size = 0;

    
    UX_UTILITY_MULC_SAFE(video_parameter -> ux_device_class_video_parameter_streams_nb, (ULONG)sizeof(UX_DEVICE_CLASS_VIDEO_STREAM), streams_size, status);
    if (status != UX_SUCCESS)
        return(status);

    
    UX_UTILITY_ADD_SAFE(memory_size, streams_size, memory_size, status);
    if (status != UX_SUCCESS)
        return(status);

    
    video = (UX_DEVICE_CLASS_VIDEO *)_ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, memory_size);

    
    if (video == UX_NULL)
        return(UX_MEMORY_INSUFFICIENT);

    
    if (streams_size)
    {
        video -> ux_device_class_video_streams = (UX_DEVICE_CLASS_VIDEO_STREAM *)((UCHAR *)video + sizeof(UX_DEVICE_CLASS_VIDEO));
        video -> ux_device_class_video_streams_nb = video_parameter -> ux_device_class_video_parameter_streams_nb;
    }

    
    stream = video -> ux_device_class_video_streams;
    stream_parameter = video_parameter -> ux_device_class_video_parameter_streams;
    for (i = 0; i < video -> ux_device_class_video_streams_nb; i ++)
    {

        
        stream -> ux_device_class_video_stream_payload_buffer_size = stream_parameter -> ux_device_class_video_stream_parameter_max_payload_buffer_size;

        if (UX_OVERFLOW_CHECK_ADD_USHORT(stream -> ux_device_class_video_stream_payload_buffer_size, 4))
        {
            status = UX_ERROR;
            break;
        }
        stream -> ux_device_class_video_stream_payload_buffer_size += 4;

        if (UX_OVERFLOW_CHECK_MULV_ULONG(stream -> ux_device_class_video_stream_payload_buffer_size, stream_parameter -> ux_device_class_video_stream_parameter_max_payload_buffer_nb))
        {
            status = UX_ERROR;
            break;
        }
        memory_size = stream -> ux_device_class_video_stream_payload_buffer_size * stream_parameter -> ux_device_class_video_stream_parameter_max_payload_buffer_nb;

        
        stream -> ux_device_class_video_stream_buffer = (UCHAR *)_ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, memory_size);

        
        if (stream -> ux_device_class_video_stream_buffer == UX_NULL)
        {
            status = UX_MEMORY_INSUFFICIENT;
            break;
        }

        stream -> ux_device_class_video_stream_buffer_size = memory_size;
        stream -> ux_device_class_video_stream_transfer_pos = (UX_DEVICE_CLASS_VIDEO_PAYLOAD *)stream -> ux_device_class_video_stream_buffer;
        stream -> ux_device_class_video_stream_access_pos = stream -> ux_device_class_video_stream_transfer_pos;




        
        if (stream_parameter -> ux_device_class_video_stream_parameter_thread_stack_size == 0)
            memory_size = UX_DEVICE_CLASS_VIDEO_THREAD_STACK_SIZE;
        else memory_size = stream_parameter -> ux_device_class_video_stream_parameter_thread_stack_size;
        stream -> ux_device_class_video_stream_thread_stack = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, memory_size);

        
        if (stream -> ux_device_class_video_stream_thread_stack == UX_NULL)
        {
            status = UX_MEMORY_INSUFFICIENT;
            break;
        }

        
        status =  _ux_utility_thread_create(&stream -> ux_device_class_video_stream_thread , "ux_device_class_video_stream_thread", stream_parameter -> ux_device_class_video_stream_parameter_thread_entry, (ULONG)(ALIGN_TYPE)stream, (VOID *) stream -> ux_device_class_video_stream_thread_stack, memory_size, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);




        
        if (status != UX_SUCCESS)
            break;

        UX_THREAD_EXTENSION_PTR_SET(&(stream -> ux_device_class_video_stream_thread), stream)


        
        stream -> ux_device_class_video_stream_task_function = stream_parameter -> ux_device_class_video_stream_parameter_task_function;


        
        _ux_utility_memory_copy(&stream -> ux_device_class_video_stream_callbacks, &stream_parameter -> ux_device_class_video_stream_parameter_callbacks, sizeof(UX_DEVICE_CLASS_VIDEO_STREAM_CALLBACKS));


        
        stream -> ux_device_class_video_stream_video = video;

        stream ++;
        stream_parameter ++;
    }

    
    if (status == UX_SUCCESS)
    {

        
        class_inst -> ux_slave_class_instance = (VOID *) video;

        
        video -> ux_device_class_video_class = class_inst;

        
        _ux_utility_memory_copy(&video -> ux_device_class_video_callbacks, &video_parameter -> ux_device_class_video_parameter_callbacks, sizeof(UX_DEVICE_CLASS_VIDEO_CALLBACKS));




        
        class_inst -> ux_slave_class_task_function = _ux_device_class_video_tasks_run;


        
        return(UX_SUCCESS);
    }

    
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);

    
    stream = video -> ux_device_class_video_streams;
    for (i = 0; i < video -> ux_device_class_video_streams_nb; i ++)
    {


        if (stream -> ux_device_class_video_stream_thread.tx_thread_id)
            _ux_utility_thread_delete(&stream -> ux_device_class_video_stream_thread);
        if (stream -> ux_device_class_video_stream_thread_stack)
            _ux_utility_memory_free(stream -> ux_device_class_video_stream_thread_stack);


        if (stream -> ux_device_class_video_stream_buffer)
            _ux_utility_memory_free(stream -> ux_device_class_video_stream_buffer);
        stream ++;
    }
    _ux_utility_memory_free(video);

    return(status);
}
