











 
 















UX_DEVICE_CLASS_RNDIS_NX_ETHERNET_POOL_ALLOCSIZE_ASSERT   ULONG ux_device_class_rndis_oid_supported_list[UX_DEVICE_CLASS_RNDIS_OID_SUPPORTED_LIST_LENGTH + 1] = {



    
    UX_DEVICE_CLASS_RNDIS_OID_GEN_SUPPORTED_LIST, UX_DEVICE_CLASS_RNDIS_OID_GEN_HARDWARE_STATUS, UX_DEVICE_CLASS_RNDIS_OID_GEN_MEDIA_SUPPORTED, UX_DEVICE_CLASS_RNDIS_OID_GEN_MEDIA_IN_USE, UX_DEVICE_CLASS_RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE, UX_DEVICE_CLASS_RNDIS_OID_GEN_LINK_SPEED, UX_DEVICE_CLASS_RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE, UX_DEVICE_CLASS_RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE, UX_DEVICE_CLASS_RNDIS_OID_GEN_VENDOR_ID, UX_DEVICE_CLASS_RNDIS_OID_GEN_VENDOR_DESCRIPTION, UX_DEVICE_CLASS_RNDIS_OID_GEN_VENDOR_DRIVER_VERSION, UX_DEVICE_CLASS_RNDIS_OID_GEN_CURRENT_PACKET_FILTER, UX_DEVICE_CLASS_RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE, UX_DEVICE_CLASS_RNDIS_OID_GEN_MAC_OPTIONS, UX_DEVICE_CLASS_RNDIS_OID_GEN_MEDIA_CONNECT_STATUS, UX_DEVICE_CLASS_RNDIS_OID_GEN_PHYSICAL_MEDIUM, UX_DEVICE_CLASS_RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER,   UX_DEVICE_CLASS_RNDIS_OID_GEN_XMIT_OK, UX_DEVICE_CLASS_RNDIS_OID_GEN_RCV_OK, UX_DEVICE_CLASS_RNDIS_OID_GEN_XMIT_ERROR, UX_DEVICE_CLASS_RNDIS_OID_GEN_RCV_ERROR, UX_DEVICE_CLASS_RNDIS_OID_GEN_RCV_NO_BUFFER,   UX_DEVICE_CLASS_RNDIS_OID_802_3_PERMANENT_ADDRESS, UX_DEVICE_CLASS_RNDIS_OID_802_3_CURRENT_ADDRESS, UX_DEVICE_CLASS_RNDIS_OID_802_3_MULTICAST_LIST, UX_DEVICE_CLASS_RNDIS_OID_802_3_MAC_OPTIONS, UX_DEVICE_CLASS_RNDIS_OID_802_3_MAXIMUM_LIST_SIZE,   UX_DEVICE_CLASS_RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT, UX_DEVICE_CLASS_RNDIS_OID_802_3_XMIT_ONE_COLLISION, UX_DEVICE_CLASS_RNDIS_OID_802_3_XMIT_MORE_COLLISIONS,  0, };






































 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 
 


 
 








 
 
 
 
 
 
 
 
 






















UINT  _ux_device_class_rndis_initialize(UX_SLAVE_CLASS_COMMAND *command)
{

    UX_PARAMETER_NOT_USED(command);
    return(UX_FUNCTION_NOT_SUPPORTED);


UX_SLAVE_CLASS_RNDIS                        *rndis;
UX_SLAVE_CLASS_RNDIS_PARAMETER              *rndis_parameter;
UX_SLAVE_CLASS                              *class_ptr;
UINT                                        status;

    
    class_ptr =  command -> ux_slave_class_command_class_ptr;

    
    rndis =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_RNDIS));

    
    if (rndis == UX_NULL)
        return(UX_MEMORY_INSUFFICIENT);

    
    class_ptr -> ux_slave_class_instance = (VOID *) rndis;

    
    rndis_parameter =  command -> ux_slave_class_command_parameter;

    
    rndis -> ux_slave_class_rndis_parameter.ux_slave_class_rndis_instance_activate = rndis_parameter -> ux_slave_class_rndis_instance_activate;
    rndis -> ux_slave_class_rndis_parameter.ux_slave_class_rndis_instance_deactivate = rndis_parameter -> ux_slave_class_rndis_instance_deactivate;
    
    
    rndis -> ux_slave_class_rndis_nx_ip = rndis_parameter -> ux_slave_class_rndis_parameter_nx_ip; 
    
    
    rndis -> ux_slave_class_rndis_nx_ip_address = rndis_parameter -> ux_slave_class_rndis_parameter_nx_ip_address; 
    
    
    rndis -> ux_slave_class_rndis_nx_ip_network_mask = rndis_parameter -> ux_slave_class_rndis_parameter_nx_ip_network_mask; 
    
    
    _ux_utility_memory_copy(rndis -> ux_slave_class_rndis_local_node_id, rndis_parameter -> ux_slave_class_rndis_parameter_local_node_id, UX_DEVICE_CLASS_RNDIS_NODE_ID_LENGTH);

    
    _ux_utility_memory_copy(rndis -> ux_slave_class_rndis_remote_node_id, rndis_parameter -> ux_slave_class_rndis_parameter_remote_node_id, UX_DEVICE_CLASS_RNDIS_NODE_ID_LENGTH);

    
    _ux_utility_memory_copy(&rndis -> ux_slave_class_rndis_parameter, rndis_parameter, sizeof (UX_SLAVE_CLASS_RNDIS_PARAMETER)); 

    
    status =  _ux_utility_mutex_create(&rndis -> ux_slave_class_rndis_mutex, "ux_slave_class_rndis_mutex");
    if (status != UX_SUCCESS)
        status = UX_MUTEX_ERROR;

    
    if (status == UX_SUCCESS)
    {
        rndis -> ux_slave_class_rndis_interrupt_thread_stack =   _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
        
        
        if (rndis -> ux_slave_class_rndis_interrupt_thread_stack  == UX_NULL)

            
            status = UX_MEMORY_INSUFFICIENT;
    }

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_device_thread_create(&rndis -> ux_slave_class_rndis_interrupt_thread , "ux_slave_class_rndis_interrupt_thread",  _ux_device_class_rndis_interrupt_thread, (ULONG) (ALIGN_TYPE) class_ptr, (VOID *) rndis -> ux_slave_class_rndis_interrupt_thread_stack , UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);



                    
        
        if (status != UX_SUCCESS)
            status = UX_THREAD_ERROR;
    }

    UX_THREAD_EXTENSION_PTR_SET(&(rndis -> ux_slave_class_rndis_interrupt_thread), class_ptr)

    
    if (status == UX_SUCCESS)
    {
        rndis -> ux_slave_class_rndis_bulkout_thread_stack =   _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
        
        
        if (rndis -> ux_slave_class_rndis_bulkout_thread_stack  == UX_NULL)
            status = UX_MEMORY_INSUFFICIENT;
    }

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_device_thread_create(&rndis -> ux_slave_class_rndis_bulkout_thread , "ux_slave_class_rndis_bulkout_thread",  _ux_device_class_rndis_bulkout_thread, (ULONG) (ALIGN_TYPE) class_ptr, (VOID *) rndis -> ux_slave_class_rndis_bulkout_thread_stack , UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);



                    
        
        if (status != UX_SUCCESS)
            status = UX_THREAD_ERROR;
    }

    UX_THREAD_EXTENSION_PTR_SET(&(rndis -> ux_slave_class_rndis_bulkout_thread), class_ptr)

    
    if (status == UX_SUCCESS)
    {
        rndis -> ux_slave_class_rndis_bulkin_thread_stack =   _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
        
        
        if (rndis -> ux_slave_class_rndis_bulkin_thread_stack  == UX_NULL)
            status = UX_MEMORY_INSUFFICIENT;
    }

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_device_thread_create(&rndis -> ux_slave_class_rndis_bulkin_thread , "ux_slave_class_rndis_bulkin_thread",  _ux_device_class_rndis_bulkin_thread, (ULONG) (ALIGN_TYPE) class_ptr, (VOID *) rndis -> ux_slave_class_rndis_bulkin_thread_stack , UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);




        
        if (status != UX_SUCCESS)
            status = UX_THREAD_ERROR;
    }

    UX_THREAD_EXTENSION_PTR_SET(&(rndis -> ux_slave_class_rndis_bulkin_thread), class_ptr)

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_utility_event_flags_create(&rndis -> ux_slave_class_rndis_event_flags_group, "ux_device_class_rndis_event_flag");

        
        if (status != UX_SUCCESS)
            status = UX_EVENT_ERROR;
    }

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_device_semaphore_create(&rndis -> ux_slave_class_rndis_semaphore, "ux_device_class_rndis_semaphore", 1);
        if (status == UX_SUCCESS)

            
            return(UX_SUCCESS);

        
        status = UX_SEMAPHORE_ERROR;
    }

    

    
    if (rndis -> ux_slave_class_rndis_semaphore.tx_semaphore_id != 0)
        _ux_device_semaphore_delete(&rndis -> ux_slave_class_rndis_semaphore);

    
    if (rndis -> ux_slave_class_rndis_event_flags_group.tx_event_flags_group_id != 0)
        _ux_utility_event_flags_delete(&rndis -> ux_slave_class_rndis_event_flags_group);

    
    if (rndis -> ux_slave_class_rndis_bulkin_thread.tx_thread_id != 0)
        _ux_device_thread_delete(&rndis -> ux_slave_class_rndis_bulkin_thread);

    
    if (rndis -> ux_slave_class_rndis_bulkin_thread_stack)
        _ux_utility_memory_free(rndis -> ux_slave_class_rndis_bulkin_thread_stack);

    
    if (rndis -> ux_slave_class_rndis_bulkout_thread.tx_thread_id != 0)
        _ux_device_thread_delete(&rndis -> ux_slave_class_rndis_bulkout_thread);

    
    if (rndis -> ux_slave_class_rndis_bulkout_thread_stack)
        _ux_utility_memory_free(rndis -> ux_slave_class_rndis_bulkout_thread_stack);
    
    
    if (rndis -> ux_slave_class_rndis_interrupt_thread.tx_thread_id != 0)
        _ux_device_thread_delete(&rndis -> ux_slave_class_rndis_interrupt_thread);
    
    
    if (rndis -> ux_slave_class_rndis_interrupt_thread_stack)
        _ux_utility_memory_free(rndis -> ux_slave_class_rndis_interrupt_thread_stack);

    
    if (rndis -> ux_slave_class_rndis_mutex.tx_mutex_id != 0)
        _ux_device_mutex_delete(&rndis -> ux_slave_class_rndis_mutex);

    
    _ux_utility_memory_free(rndis);

    
    return(status);

}
