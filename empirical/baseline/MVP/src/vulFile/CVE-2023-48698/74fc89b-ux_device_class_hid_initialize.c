











 
 
















 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 
 
 
 
 
 
 
 
 






















UINT  _ux_device_class_hid_initialize(UX_SLAVE_CLASS_COMMAND *command)
{
                                          
UX_SLAVE_CLASS_HID                      *hid;
UX_SLAVE_CLASS_HID_PARAMETER            *hid_parameter;
UX_SLAVE_CLASS                          *class_ptr;
UINT                                    status = UX_SUCCESS;


    
    class_ptr =  command -> ux_slave_class_command_class_ptr;

    
    hid =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_HID));

    
    if (hid == UX_NULL)
        return(UX_MEMORY_INSUFFICIENT);

    
    class_ptr -> ux_slave_class_instance = (VOID *) hid;



    
    class_ptr -> ux_slave_class_thread_stack =   _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_DEVICE_CLASS_HID_THREAD_STACK_SIZE);
    
    
    if (class_ptr -> ux_slave_class_thread_stack == UX_NULL)
        status = UX_MEMORY_INSUFFICIENT;

    
    if (status == UX_SUCCESS)
        status =  _ux_device_thread_create(&class_ptr -> ux_slave_class_thread, "ux_slave_hid_thread",  _ux_device_class_hid_interrupt_thread, (ULONG) (ALIGN_TYPE) class_ptr, (VOID *) class_ptr -> ux_slave_class_thread_stack, UX_DEVICE_CLASS_HID_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);





    
    class_ptr -> ux_slave_class_task_function = _ux_device_class_hid_tasks_run;


    
    if (status == UX_SUCCESS)
    {


        UX_THREAD_EXTENSION_PTR_SET(&(class_ptr -> ux_slave_class_thread), class_ptr)


        
        hid_parameter =  command -> ux_slave_class_command_parameter;

        
        hid -> ux_device_class_hid_report_address             = hid_parameter -> ux_device_class_hid_parameter_report_address;
        hid -> ux_device_class_hid_report_length              = hid_parameter -> ux_device_class_hid_parameter_report_length;
        hid -> ux_device_class_hid_report_id                  = hid_parameter -> ux_device_class_hid_parameter_report_id;

        
        hid -> ux_device_class_hid_callback                   = hid_parameter -> ux_device_class_hid_parameter_callback;
        hid -> ux_device_class_hid_get_callback               = hid_parameter -> ux_device_class_hid_parameter_get_callback;

        
        hid -> ux_device_class_hid_event_array =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_HID_EVENT), UX_DEVICE_CLASS_HID_MAX_EVENTS_QUEUE);

        
        if (hid -> ux_device_class_hid_event_array != UX_NULL)
        {

            
            hid -> ux_device_class_hid_event_array_head =  hid -> ux_device_class_hid_event_array;
            hid -> ux_device_class_hid_event_array_tail =  hid -> ux_device_class_hid_event_array;
            hid -> ux_device_class_hid_event_array_end  =  hid -> ux_device_class_hid_event_array + UX_DEVICE_CLASS_HID_MAX_EVENTS_QUEUE;

            
            hid -> ux_slave_class_hid_instance_activate = hid_parameter -> ux_slave_class_hid_instance_activate;
            hid -> ux_slave_class_hid_instance_deactivate = hid_parameter -> ux_slave_class_hid_instance_deactivate;

            
            hid -> ux_device_class_hid_event_wait_timeout = UX_WAIT_FOREVER;



            
            status =  _ux_utility_event_flags_create(&hid -> ux_device_class_hid_event_flags_group, "ux_device_class_hid_event_flag");

            
            if (status != UX_SUCCESS)
                status = UX_EVENT_ERROR;
            else  {





                
                status = _ux_utility_mutex_create(&hid -> ux_device_class_hid_read_mutex, "ux_device_class_hid_read_mutex");
                if (status == UX_SUCCESS)
                {


                    
                    if (hid_parameter -> ux_device_class_hid_parameter_receiver_initialize)
                    {

                        
                        status = hid_parameter -> ux_device_class_hid_parameter_receiver_initialize(hid, hid_parameter, &hid -> ux_device_class_hid_receiver);


                    }

                    
                    if (status == UX_SUCCESS)
                        return(status);



                    
                    _ux_device_mutex_delete(&hid -> ux_device_class_hid_read_mutex);
                }
                else status = UX_MUTEX_ERROR;

                
                _ux_utility_event_flags_delete(&hid -> ux_device_class_hid_event_flags_group);


                return(status);


            }



            
            
            _ux_utility_memory_free(hid -> ux_device_class_hid_event_array);


        }
        else status =  UX_MEMORY_INSUFFICIENT;



        
        _ux_device_thread_delete(&class_ptr -> ux_slave_class_thread);

    }
    else status = (UX_THREAD_ERROR);



    
    if (class_ptr -> ux_slave_class_thread_stack)
        _ux_utility_memory_free(class_ptr -> ux_slave_class_thread_stack);


    
    class_ptr -> ux_slave_class_instance =  UX_NULL;

    
    _ux_utility_memory_free(hid);

    
    return(status);
}

