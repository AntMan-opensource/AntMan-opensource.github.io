










































































UINT _ux_host_class_hid_idle_set_run(UX_HOST_CLASS_HID *hid, USHORT idle_time, USHORT report_id)
{

UX_INTERRUPT_SAVE_AREA UX_DEVICE       *device;
UX_ENDPOINT     *control_endpoint;
UX_TRANSFER     *transfer_request;
UINT            status;

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HID_IDLE_SET, hid, 0, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    
    if (_ux_host_stack_class_instance_verify(_ux_system_host_class_hid_name, (VOID *) hid) != UX_SUCCESS)
    {

        
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, hid, 0, 0, UX_TRACE_ERRORS, 0, 0)

        hid -> ux_host_class_hid_status = UX_HOST_CLASS_INSTANCE_UNKNOWN;
        return(UX_STATE_EXIT);
    }

    
    device = hid -> ux_host_class_hid_device;

    
    if (device == UX_NULL || device -> ux_device_handle != (ULONG)(ALIGN_TYPE)device)
    {
        hid -> ux_host_class_hid_status = UX_DEVICE_HANDLE_UNKNOWN;
        return(UX_STATE_EXIT);
    }

    
    control_endpoint =  &device -> ux_device_control_endpoint;
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    
    if (hid -> ux_host_class_hid_cmd_state == UX_STATE_WAIT)
    {

        
        _ux_system_tasks_run();

        
        if (transfer_request -> ux_transfer_request_state < UX_STATE_WAIT)
        {

            
            hid -> ux_host_class_hid_flags &= ~UX_HOST_CLASS_HID_FLAG_LOCK;
            device -> ux_device_flags &= ~UX_DEVICE_FLAG_LOCK;

            
            hid -> ux_host_class_hid_cmd_state = UX_STATE_IDLE;
            hid -> ux_host_class_hid_status = transfer_request -> ux_transfer_request_completion_code;
            return(UX_STATE_NEXT);
        }

        
        return(UX_STATE_WAIT);
    }

    
    UX_DISABLE if ((hid -> ux_host_class_hid_flags & UX_HOST_CLASS_HID_FLAG_LOCK) || (device -> ux_device_flags & UX_DEVICE_FLAG_LOCK))

    {

        
        UX_RESTORE return(UX_STATE_LOCK);
    }
    hid -> ux_host_class_hid_flags |= UX_HOST_CLASS_HID_FLAG_LOCK;
    device -> ux_device_flags |= UX_DEVICE_FLAG_LOCK;
    hid -> ux_host_class_hid_cmd_state = UX_STATE_WAIT;
    UX_RESTORE   transfer_request -> ux_transfer_request_data_pointer =     UX_NULL;


    transfer_request -> ux_transfer_request_requested_length = 0;
    transfer_request -> ux_transfer_request_function =         UX_HOST_CLASS_HID_SET_IDLE;
    transfer_request -> ux_transfer_request_type =             UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
    transfer_request -> ux_transfer_request_value =            (UINT)((idle_time << 8) | report_id);
    transfer_request -> ux_transfer_request_index =            hid -> ux_host_class_hid_interface -> ux_interface_descriptor.bInterfaceNumber;
    UX_TRANSFER_STATE_RESET(transfer_request);

    
    status =  _ux_host_stack_transfer_run(transfer_request);
    if (status != UX_STATE_WAIT)
    {
        hid -> ux_host_class_hid_status = transfer_request -> ux_transfer_request_completion_code;

        
        hid -> ux_host_class_hid_flags &= ~UX_HOST_CLASS_HID_FLAG_LOCK;
        device -> ux_device_flags &= ~UX_DEVICE_FLAG_LOCK;

        hid -> ux_host_class_hid_cmd_state = (UCHAR)status;
    }

    
    return(status);
}

