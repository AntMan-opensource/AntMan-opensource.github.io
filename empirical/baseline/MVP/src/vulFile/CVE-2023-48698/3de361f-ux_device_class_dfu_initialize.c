











 
 
















 
 
 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 






 
 
 
 
 
 
 
 
 






















UINT  _ux_device_class_dfu_initialize(UX_SLAVE_CLASS_COMMAND *command)
{
                                          
UX_SLAVE_CLASS_DFU                      *dfu;
UX_SLAVE_CLASS_DFU_PARAMETER            *dfu_parameter;
UX_SLAVE_CLASS                          *class_ptr;
UINT                                    status = UX_DESCRIPTOR_CORRUPTED;
UX_DFU_FUNCTIONAL_DESCRIPTOR            dfu_functional_descriptor;
UCHAR                                   *dfu_framework; 
ULONG                                   dfu_framework_length;
UCHAR                                   descriptor_type;
ULONG                                   descriptor_length;

    
    class_ptr =  command -> ux_slave_class_command_class_ptr;

    
    dfu =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_DFU));

    
    if (dfu == UX_NULL)
        return(UX_MEMORY_INSUFFICIENT);

    
    class_ptr -> ux_slave_class_instance = (VOID *) dfu;

    
    dfu_parameter =  command -> ux_slave_class_command_parameter;

    
    dfu -> ux_slave_class_dfu_instance_activate                 =  dfu_parameter -> ux_slave_class_dfu_parameter_instance_activate;
    dfu -> ux_slave_class_dfu_instance_deactivate               =  dfu_parameter -> ux_slave_class_dfu_parameter_instance_deactivate;
    dfu -> ux_slave_class_dfu_read                              =  dfu_parameter -> ux_slave_class_dfu_parameter_read;
    dfu -> ux_slave_class_dfu_write                             =  dfu_parameter -> ux_slave_class_dfu_parameter_write;
    dfu -> ux_slave_class_dfu_get_status                        =  dfu_parameter -> ux_slave_class_dfu_parameter_get_status;
    dfu -> ux_slave_class_dfu_notify                            =  dfu_parameter -> ux_slave_class_dfu_parameter_notify;

    dfu -> ux_device_class_dfu_custom_request                   =  dfu_parameter -> ux_device_class_dfu_parameter_custom_request;


    
    _ux_system_slave -> ux_system_slave_dfu_framework           =  dfu_parameter -> ux_slave_class_dfu_parameter_framework;
    _ux_system_slave -> ux_system_slave_dfu_framework_length    =  dfu_parameter -> ux_slave_class_dfu_parameter_framework_length;

    
    dfu_framework        =  _ux_system_slave -> ux_system_slave_dfu_framework;
    dfu_framework_length =  _ux_system_slave -> ux_system_slave_dfu_framework_length;
    
    
    while (dfu_framework_length != 0)
    {

        
        descriptor_length =  (ULONG) *dfu_framework;

        
        if (descriptor_length < 2 || descriptor_length > dfu_framework_length)
            break;

        
        descriptor_type =  *(dfu_framework + 1);

        
        if (descriptor_type == UX_DFU_FUNCTIONAL_DESCRIPTOR_ITEM)
        {

            
            _ux_utility_descriptor_parse(dfu_framework, _ux_system_dfu_functional_descriptor_structure, UX_DFU_FUNCTIONAL_DESCRIPTOR_ENTRIES, (UCHAR *) &dfu_functional_descriptor);



            
            if (dfu_functional_descriptor.wTransferSize > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
                break;

            
            _ux_system_slave -> ux_system_slave_device_dfu_capabilities = dfu_functional_descriptor.bmAttributes;
            
            
            _ux_system_slave -> ux_system_slave_device_dfu_detach_timeout = dfu_functional_descriptor.wDetachTimeOut;
            
            
            _ux_system_slave -> ux_system_slave_device_dfu_transfer_size = dfu_functional_descriptor.wTransferSize;

            
            _ux_system_slave -> ux_system_slave_device_dfu_state_machine = UX_SYSTEM_DFU_STATE_APP_IDLE;

            
            status = UX_SUCCESS;
            break;
        }

        
        dfu_framework_length -=  descriptor_length;

        
        dfu_framework +=  descriptor_length;

    }



    
    status =  _ux_utility_event_flags_create(&dfu -> ux_slave_class_dfu_event_flags_group, "ux_device_class_dfu_event_flag");

    
    if (status != UX_SUCCESS)
        status = UX_EVENT_ERROR;

    
    if (status == UX_SUCCESS)
    {
        dfu -> ux_slave_class_dfu_thread_stack =   _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
        
        
        if (dfu -> ux_slave_class_dfu_thread_stack  == UX_NULL)
            status = UX_MEMORY_INSUFFICIENT;
    }

    
    if (status == UX_SUCCESS)
    {
        status =  _ux_device_thread_create(&dfu -> ux_slave_class_dfu_thread , "ux_slave_class_dfu_thread",  _ux_device_class_dfu_thread, (ULONG) (ALIGN_TYPE) class_ptr, (VOID *) dfu -> ux_slave_class_dfu_thread_stack, UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS, UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_AUTO_START);




        
        if (status != UX_SUCCESS)
            status = UX_THREAD_ERROR;
    }

    UX_THREAD_EXTENSION_PTR_SET(&(dfu -> ux_slave_class_dfu_thread), class_ptr)


    
    class_ptr -> ux_slave_class_task_function = _ux_device_class_dfu_tasks_run;


    
    if (status == UX_SUCCESS)
        return(UX_SUCCESS);
    
    



    
    if (dfu -> ux_slave_class_dfu_thread_stack)
        _ux_utility_memory_free(dfu -> ux_slave_class_dfu_thread_stack);
    if (dfu -> ux_slave_class_dfu_event_flags_group.tx_event_flags_group_id != 0)
        _ux_utility_event_flags_delete(&dfu -> ux_slave_class_dfu_event_flags_group);


    
    class_ptr -> ux_slave_class_instance = UX_NULL;
    _ux_utility_memory_free(dfu);

    return(status);
}

