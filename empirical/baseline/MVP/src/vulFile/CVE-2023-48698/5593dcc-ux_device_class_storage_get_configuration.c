













 
 




















UCHAR usbx_device_class_storage_configuration_profile[] = { 

    
        0x00, 0x00,                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x00, 0x00, 0x1c,  0x00, 0x12, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,    0x00, 0x01, 0x0b, 0x08,  0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,   0x00, 0x02, 0x07, 0x04,  0x02, 0x00, 0x00, 0x00,   0x00, 0x03, 0x0b, 0x04,  0x2b, 0x00, 0x00, 0x00,   0x00, 0x10, 0x00, 0x08,  0x00, 0x00, 0x08, 0x00, 0x00, 0x01, 0x01, 0x00,   0x00, 0x1d, 0x00, 0x00,    0x00, 0x1e, 0x08, 0x04,  0x03, 0x00, 0x00, 0x00,   0x00, 0x1f, 0x08, 0x04,  0x01, 0x00, 0x01, 0x00,   0x00, 0x20, 0x04, 0x0c,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00,    0x00, 0x21, 0x0C, 0x08,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x23, 0x08, 0x08,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   0x00, 0x24, 0x04, 0x04,  0x80, 0x00, 0x00, 0x00,   0x00, 0x26, 0x00, 0x00,    0x00, 0x2d, 0x08, 0x04,  0x46, 0x00, 0x3f, 0x0f,   0x00, 0x2e, 0x04, 0x04,  0x7f, 0x00, 0x0d, 0x00,   0x00, 0x2f, 0x08, 0x04,  0x4e, 0x00, 0x00, 0x00,   0x01, 0x00, 0x07, 0x04,  0x00, 0x00, 0x00, 0x00,   0x01, 0x01, 0x00, 0x04,  0x00, 0x00, 0x00, 0x00,  0x01, 0x08, 0x03, 0x10,  0x53, 0x31, 0x33, 0x36, 0x36, 0x59, 0x42, 0x46, 0x37, 0x30, 0x30, 0x39, 0x45, 0x48, 0x20, 0x20,  0x01, 0x0a, 0x00, 0x0c,  0x46, 0x44, 0x43, 0x00, 0x53, 0x54, 0x43, 0x00, 0x54, 0x4F, 0x43, 0x00, };





































































































































































UCHAR usbx_device_class_storage_configuration_active_profile[] = { 

    
        0x00, 0x00,                      0x00, 0x00, 0x00, 0x00, 0x00, 0x08,   0x00, 0x00, 0x00, 0x1c,  0x00, 0x12, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00,    0x00, 0x01, 0x0b, 0x08,  0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00,   0x00, 0x02, 0x07, 0x04,  0x02, 0x00, 0x00, 0x00,   0x00, 0x03, 0x0b, 0x04,  0x2b, 0x00, 0x00, 0x00,   0x00, 0x10, 0x01, 0x08,  0x00, 0x00, 0x08, 0x00, 0x00, 0x01, 0x01, 0x00,   0x00, 0x1d, 0x01, 0x00,    0x00, 0x1e, 0x09, 0x04,  0x03, 0x00, 0x00, 0x00,   0x01, 0x08, 0x03, 0x10,  0x53, 0x31, 0x33, 0x36, 0x36, 0x59, 0x42, 0x46, 0x37, 0x30, 0x30, 0x39, 0x45, 0x48, 0x20, 0x20,  };













































































 
 
 
 
 






 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 











UINT  _ux_device_class_storage_get_configuration(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in, UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)

{

UINT                    status = 0;
UX_SLAVE_TRANSFER       *transfer_request;
ULONG                   starting_feature;
ULONG                   allocation_length;
ULONG                   additional_length;
ULONG                   profile_counter;
UCHAR                   *profile_pointer;
ULONG                   feature;

    UX_PARAMETER_NOT_USED(endpoint_out);

    
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_GET_CONFIGURATION, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)
    
    
    _ux_utility_long_put_big_endian(usbx_device_class_storage_configuration_profile, (USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_PROFILE_LENGTH - 4));
    
    
    _ux_utility_long_put_big_endian(usbx_device_class_storage_configuration_active_profile, (USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_ACTIVE_PROFILE_LENGTH - 4));
    
    
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
    
    
    starting_feature =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_GET_CONFIGURATION_STARTING_FEATURE);

    
    allocation_length =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_GET_CONFIGURATION_ALLOCATION_LENGTH);

    
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;

    
    if (starting_feature == 0)
    {

        
        if ((*(cbwcb + UX_SLAVE_CLASS_STORAGE_GET_CONFIGURATION_RT) & 3) == 1)
        {

            
            
            if (allocation_length >= USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_ACTIVE_PROFILE_LENGTH)

                
                allocation_length = USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_ACTIVE_PROFILE_LENGTH;
                            
            
            _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,  usbx_device_class_storage_configuration_active_profile, allocation_length);

        }
        else {

            
            
            if (allocation_length >= USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_PROFILE_LENGTH)

                
                allocation_length = USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_PROFILE_LENGTH;
                            
            
            _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,  usbx_device_class_storage_configuration_profile, allocation_length);

            
        }

        
        status = UX_SUCCESS;
    }
    else {

        
        profile_pointer = usbx_device_class_storage_configuration_profile + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_HEADER_LENGTH + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_DESCRIPTOR_LENGTH;
        profile_counter = USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_LENGTH;
        
        
        while (profile_counter != 0)
        {

            
            feature =  _ux_utility_short_get_big_endian(profile_pointer + USBX_DEVICE_CLASS_STORAGE_FEATURE_DESCRIPTOR_FEATURE_CODE);
            
            
            additional_length =  (ULONG ) *(profile_pointer + USBX_DEVICE_CLASS_STORAGE_FEATURE_DESCRIPTOR_FEATURE_ADD_LENGTH);

            
            if (feature == starting_feature)
            {
            
                
                if (allocation_length >= (additional_length + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_HEADER_LENGTH +  USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_HEADER_LENGTH))

                    
                    allocation_length = additional_length + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_HEADER_LENGTH + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_HEADER_LENGTH;

                
                _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer,  profile_pointer, allocation_length);


                
                status = UX_SUCCESS;

                
                break;                    
            }
            else             {
                
                
                if (profile_counter - additional_length - USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_HEADER_LENGTH <= 0)
                {

                    

                    
                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(UX_SLAVE_CLASS_STORAGE_SENSE_KEY_ILLEGAL_REQUEST,0x26,0x02);

                    
                    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;

                    
                    status = UX_ERROR;

                    
                    break;                    

                }
                else {

                    
                    profile_pointer += additional_length + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_HEADER_LENGTH;

                    
                    profile_counter -= additional_length + USBX_DEVICE_CLASS_STORAGE_CONFIGURATION_FEATURE_HEADER_LENGTH;
                }
            }
        }        
    }

    
    if (status == UX_SUCCESS)
    {



        
        storage -> ux_device_class_storage_state = UX_DEVICE_CLASS_STORAGE_STATE_TRANS_START;
        storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_READ;

        storage -> ux_device_class_storage_transfer = transfer_request;
        storage -> ux_device_class_storage_device_length = allocation_length;
        storage -> ux_device_class_storage_data_length = allocation_length;
        storage -> ux_device_class_storage_data_count = 0;
        UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);


        
        _ux_device_stack_transfer_request(transfer_request,  allocation_length, allocation_length);



    }
    else {

        

        _ux_device_stack_endpoint_stall(endpoint_in);

    }

    
    return(status);
}

