












char *combine_strings(const char *string_one, const char *string_two, const char delimiter) {
  size_t combined_len = strlen(string_one) + strlen(string_two) + 2;
  char *combined = malloc(combined_len);
  snprintf(combined, combined_len, "%s%c%s", string_one, delimiter, string_two);
  return combined;
}


void initialize(econf_file *key_file, size_t num) {
  key_file->file_entry[num].group = strdup(KEY_FILE_NULL_VALUE);
  key_file->file_entry[num].key = strdup(KEY_FILE_NULL_VALUE);
  key_file->file_entry[num].value = strdup(KEY_FILE_NULL_VALUE);
  key_file->file_entry[num].comment_before_key = NULL;
  key_file->file_entry[num].comment_after_value = NULL;
}


char *clearblank(size_t *vlen, char *string) {
  if (!*vlen) return string;

  char *buffer = string, *ptr = string;
  string[*vlen] = 0;

  while (*string != 0) {
    if (ptr == buffer && (*string == ' ' || *string == '\t')) {
      (*vlen)--;
    } else {
      *ptr++ = *string;
    }
    string++;
  }
  while (buffer[*vlen - 1] == ' ' || buffer[*vlen - 1] == '\t')
    (*vlen)--;

  buffer[*vlen] = 0;
  return buffer;
}

char *get_absolute_path(const char *path, econf_err *error) {
  char *absolute_path;
  if(*path != '/') {
    char buffer[PATH_MAX];
    if(!realpath(path, buffer)) {
      if (error)
	*error = ECONF_NOFILE;
      return NULL;
    }
    absolute_path = strdup(buffer);
  } else {
    absolute_path = strdup(path);
  }
  if (absolute_path == NULL && error)
    *error = ECONF_NOMEM;

  return absolute_path;
}


char *stripbrackets(char *string) {
  if (!string)
    return NULL;
  char *ptr = string, *buffer = string;
  size_t length = strlen(string) - 1;
  if (*string == '[' && string[length] == ']') {
    while (*(++string) != ']') { *buffer++ = *string; }
    *buffer = 0;
  }
  return ptr;
}


char *addbrackets(const char *string) {
  if (string == NULL)
    return NULL;
  size_t length = strlen(string);
  if (!(*string == '[' && string[length - 1] == ']')) {
    char *buffer = malloc(length + 3);
    if (buffer == NULL)
      return NULL;
    char *cp = buffer;
    *cp++ = '[';
    cp = stpcpy (cp, string);
    *cp++ = ']';
    *cp = '\0';
    return buffer;
  }
  return strdup(string);
}


char *toLowerCase(char *string) {
  char *ptr = string;
  while (*string)
    {
      *string = tolower(*string);
      string++;
    }
  return ptr;
}



size_t hashstring(const char *string) {
  size_t hash = 5381;
  char c;
  while ((c = *string++)) { hash = ((hash << 5) + hash) + c; }
  return hash;
}


econf_err find_key(econf_file key_file, const char *group, const char *key, size_t *num) {
	char *grp = (!group || !*group) ? strdup(KEY_FILE_NULL_VALUE) : strdup(group);
  if (grp == NULL)
    return  ECONF_NOMEM;
  if (!key || !*key) {
    free(grp);
    return ECONF_ERROR;
  }
  for (size_t i = 0; i < key_file.length; i++) {
    if (!strcmp(key_file.file_entry[i].group, grp) && !strcmp(key_file.file_entry[i].key, key)) {
      free(grp);
      *num = i;
      return ECONF_SUCCESS;
    }
  }
  
  free(grp);
  return ECONF_NOKEY;
}




static econf_err new_key (econf_file *key_file, const char *group, const char *key) {
  econf_err error;
  char *grp = (!group || !*group) ? strdup(KEY_FILE_NULL_VALUE) : strdup(group);
  if (grp == NULL)
    return ECONF_NOMEM;
  if (key_file == NULL || key == NULL)
    {
      free(grp);
      return ECONF_ERROR;
    }
  if ((error = key_file_append(key_file))) {
    free(grp);
    return error;
  }
  if ((error = setGroup(key_file, key_file->length - 1, grp))) {
    free(grp);
    return error;
  }
  free(grp);
  return setKey(key_file, key_file->length - 1, key);
}





econf_err setKeyValue(econf_err (*function) (econf_file*, size_t, const void*), econf_file *kf, const char *group, const char *key, const void *value)

{
  size_t num;
  econf_err error = find_key(*kf, group, key, &num);
  if (error) {
    if (error != ECONF_NOKEY) {
      return error;
    }
    if ((error = new_key(kf, group, key))) {
      return error;
    }
    num = kf->length - 1;
  }
  return function(kf, num, value);
}

struct file_entry cpy_file_entry(struct file_entry fe) {
  struct file_entry copied_fe;
  copied_fe.group = strdup(fe.group);
  copied_fe.key = strdup(fe.key);
  if (fe.value)
    copied_fe.value = strdup(fe.value);
  else copied_fe.value = NULL;
  if (fe.comment_before_key)
    copied_fe.comment_before_key = strdup(fe.comment_before_key);
  else copied_fe.comment_before_key = NULL;
  if (fe.comment_after_value)
    copied_fe.comment_after_value = strdup(fe.comment_after_value);
  else copied_fe.comment_after_value = NULL;
  copied_fe.line_number = fe.line_number;
  return copied_fe;
}
