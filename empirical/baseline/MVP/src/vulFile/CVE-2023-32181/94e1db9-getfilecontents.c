














static uint64_t last_scanned_line_nr = 0;
static char last_scanned_filename[PATH_MAX];

static econf_err join_same_entries(econf_file *ef)
{
  for(size_t i = 0; i < ef->length; i++)
  {
    for(size_t j = i+1; j < ef->length; j++)
    {
      if (strcmp(ef->file_entry[i].group, ef->file_entry[j].group) == 0 && strcmp(ef->file_entry[i].key, ef->file_entry[j].key) == 0)
      {
	char *post, *pre;
	if (ef->file_entry[j].value == NULL || strlen(ef->file_entry[j].value) == 0)
	{
	  
	  free(ef->file_entry[i].value);
	  ef->file_entry[i].value = strdup("");
	} else {
	  
	  post = ef->file_entry[j].value;
	  pre = ef->file_entry[i].value;
	  int ret = 0;
	  if (post != NULL && strlen(post) > 0)
	  {
	    
	    while(isspace(*post)) post++;
	    ret = asprintf(&(ef->file_entry[i].value), "%s\n%s", pre, post);
	    if(ret<0)
	      return ECONF_NOMEM;
	    free(pre);
	  }
	}

	
	if (ef->file_entry[j].comment_before_key != NULL && strlen(ef->file_entry[j].comment_before_key) > 0)
	{
	  post = ef->file_entry[j].comment_before_key;
          pre = ef->file_entry[i].comment_before_key;
	  int ret = asprintf(&(ef->file_entry[i].comment_before_key), "%s\n%s", pre, post);
	  if(ret<0)
	    return ECONF_NOMEM;
	  free(pre);
	}

	if (ef->file_entry[j].value == NULL || strlen(ef->file_entry[j].value) == 0)
	{
	  
	  free(ef->file_entry[i].comment_after_value);
	  ef->file_entry[i].comment_after_value = NULL;
	} else {
	  
	  if (ef->file_entry[j].comment_after_value != NULL && strlen(ef->file_entry[j].comment_after_value) > 0)
	  {
	    post = ef->file_entry[j].comment_after_value;
	    pre = ef->file_entry[i].comment_after_value;
	    
            while(isspace(*post)) post++;
            if (pre == NULL)
	    {
	      ef->file_entry[i].comment_after_value = strdup(post);
	    } else {
	      int ret = asprintf(&(ef->file_entry[i].comment_after_value), "%s\n%s", pre, post);
	      if(ret<0)
		return ECONF_NOMEM;
	      free(pre);
	    }
	  }
	}
      }
    }
  }
  return ECONF_SUCCESS;
}

static econf_err store (econf_file *ef, const char *group, const char *key, const char *value, const uint64_t line_number, const char *comment_before_key, const char *comment_after_value, const bool quotes, const bool append_entry)




{
  if (append_entry)
  {
    
    if (ef->length<=0)
    {
      return ECONF_MISSING_DELIMITER;
    }
    char *content = ef->file_entry[ef->length-1].value;
    int ret = asprintf(&(ef->file_entry[ef->length-1].value), "%s\n%s", content, value);
    if(ret<0)
      return ECONF_NOMEM;
    free(content);
    
    ef->file_entry[ef->length-1].line_number = line_number;

    if (ef->file_entry[ef->length-1].comment_after_value && !comment_after_value)
    { 
      comment_after_value = "";
    }

    if (comment_after_value)
    {
      ret = -1;
      if (ef->file_entry[ef->length-1].comment_after_value)
      {
	content = ef->file_entry[ef->length-1].comment_after_value;
	ret = asprintf(&(ef->file_entry[ef->length-1].comment_after_value), "%s\n%s", content, comment_after_value);
	free(content);
      } else {
	ret = asprintf(&(ef->file_entry[ef->length-1].comment_after_value), "\n%s", comment_after_value);
      }
      if(ret<0)
	return ECONF_NOMEM;
    }      

    return ECONF_SUCCESS;
  }

  
  if (ef->alloc_length == ef->length) {
    struct file_entry *tmp;

    tmp = realloc(ef->file_entry, (ef->length + 1) * sizeof(struct file_entry));
    if (!tmp)
      return ECONF_NOMEM;
    ef->file_entry = tmp;
    ef->length++;
    ef->alloc_length = ef->length;
  }

  ef->file_entry[ef->length-1].line_number = line_number;

  ef->file_entry[ef->length-1].quotes |= quotes;

  if (group)
    ef->file_entry[ef->length-1].group = strdup(group);
  else ef->file_entry[ef->length-1].group = strdup(KEY_FILE_NULL_VALUE);

  if (key) {
    
    const char *p = key + strlen(key);
    if (p > key)
      p--;
    while (p > key && (isspace((unsigned)*p)))
      p--;
    ef->file_entry[ef->length-1].key = strndup(key, (size_t)(p+1-key));
  }
  else ef->file_entry[ef->length-1].key = strdup(KEY_FILE_NULL_VALUE);

  if (value)
    ef->file_entry[ef->length-1].value = strdup(value);
  else ef->file_entry[ef->length-1].value = NULL;

  if (comment_before_key)
    ef->file_entry[ef->length-1].comment_before_key = strdup(comment_before_key);
  else ef->file_entry[ef->length-1].comment_before_key = NULL;
  if (comment_after_value)
    ef->file_entry[ef->length-1].comment_after_value = strdup(comment_after_value);
  else ef->file_entry[ef->length-1].comment_after_value = NULL;

  return ECONF_SUCCESS;
}

static void check_delim(const char *str, bool *has_wsp, bool *has_nonwsp)
{
  const char *p;
  *has_wsp = *has_nonwsp = false;

  if (str == NULL)
    return;
  for (p = str; *p && !(*has_wsp && *has_nonwsp); p++) {
    if (isspace((unsigned)*p))
      *has_wsp = true;
    else *has_nonwsp = true;
  }
}

static void free_buffer(char **buffer)
{
    free(*buffer);
}


econf_err read_file(econf_file *ef, const char *file, const char *delim, const char *comment)

{
  char buf[BUFSIZ];
  char *current_group = NULL;
  char *current_comment_before_key = NULL;
  char *current_comment_after_value = NULL;
  econf_err retval = ECONF_SUCCESS;
  uint64_t line = 0;
  bool has_wsp, has_nonwsp;
  FILE *kf = fopen(file, "rbe");

  if (kf == NULL)
    return ECONF_NOFILE;

  snprintf(last_scanned_filename, sizeof(last_scanned_filename), "%s", file);

  check_delim(delim, &has_wsp, &has_nonwsp);

  ef->path = strdup (file);
  if (ef->path == NULL) {
    fclose (kf);
    return ECONF_NOMEM;
  }
  ef->delimiter = *delim;

  while (fgets(buf, sizeof(buf), kf)) {
    char *p, *name, *data = NULL;
    bool quote_seen = false, delim_seen = false;
    char *org_buf __attribute__ ((__cleanup__(free_buffer))) = strdup(buf);

    line++;
    last_scanned_line_nr = line;

    
    size_t n = strlen(buf);
    if (n && *(buf + n - 1) == '\n')
      *(buf + n - 1) = '\0';

    if (!*buf)
      continue; 

    
    name = buf;
    while (*name && isspace((unsigned)*name))
      name++;

    
    for (size_t i = 0; i < strlen(comment); i++) {
      p = strchr(name, comment[i]);
      if (p)
      {
	if(p==name)
	{
	  
	  if (current_comment_before_key)
          {
	    
	    char *content = current_comment_before_key;
	    int ret = asprintf(&current_comment_before_key, "%s\n%s", content, p+1);
	    if(ret<0)
	      return ECONF_NOMEM;
	    free(content);
	  } else {
	    current_comment_before_key = strdup(p+1);
	  }
	} else {
	  
	  if (current_comment_after_value)
	  {
	    
	    char *content = current_comment_after_value;
	    int ret = asprintf(&current_comment_after_value, "%s\n%s", content, p+1);
	    if(ret<0)
	      return ECONF_NOMEM;
	    free(content);
	  } else {
	    current_comment_after_value = strdup(p+1);
	  }
	}
	*p = '\0';
      }
    }

    if (!*buf)
      continue; 

    
    if (name[0] == '[') {
      name++; 
      p = name + strlen(name) -1;
      while (isspace (*p)) p--;
      if (*p != ']') {
	if (strchr(name,']') == NULL)
	  retval = ECONF_MISSING_BRACKET;
	else retval = ECONF_TEXT_AFTER_SECTION;
	goto out;
      }
      *p = '\0'; 
      if(strlen(name) <= 0)
      {
	retval = ECONF_EMPTY_SECTION_NAME;
	goto out;
      }
      if (current_group)
	free (current_group);
      current_group = strdup (name);
      continue;
    }

    if (delim == NULL || strlen(delim) == 0 || strcmp(delim, "\n") == 0) {
      
      retval = store(ef, current_group, name, data, line, current_comment_before_key, current_comment_after_value, false, false );


      free(current_comment_before_key);
      current_comment_before_key = NULL;
      free(current_comment_after_value);
      current_comment_after_value = NULL;
      continue;
    }

    
    
    data = name;
    while (*data && !(isspace((unsigned)*data) || strchr(delim, *data) != NULL))
      data++;
    if (data > name && *data) {
      if (has_wsp && has_nonwsp)
      {
	
	delim_seen = !isspace((unsigned)*data) && strchr(delim, *data) != NULL;
      }
      else {
	delim_seen = strchr(delim, *data) != NULL;
      }
      *data++ = '\0';
    }

    if (!has_wsp || !has_nonwsp) {
      

      
      bool found_delim = delim_seen;
      if (!found_delim)
      {
        
	char *c = data;
	while (*c && !(strchr(delim, *c) != NULL))
	  c++;
        if (*c)
	  found_delim = true;
      }
      if (!found_delim &&  ef->length > 0 &&  ef->file_entry[ef->length-1].value != NULL &&  ef->file_entry[ef->length-1].line_number+1 == line)





      {
        
        for (size_t i = 0; i < strlen(comment); i++) {
	  char *pt = strchr(org_buf, comment[i]);
	  if (pt)
	    *pt = '\0';
	}
	
	if( org_buf[strlen(org_buf)-1] == '\n' )
	  org_buf[strlen(org_buf)-1] = 0;
	retval = store(ef, current_group, name, org_buf, line, current_comment_before_key, current_comment_after_value, false, true );


	free(current_comment_before_key);
	current_comment_before_key = NULL;
	free(current_comment_after_value);
	current_comment_after_value = NULL;
	if (retval)
	  goto out;
	continue;
      }
    }
    
    
    
    if (!*name || data == name)
      continue;

    if (*data == '\0')
      
      data = NULL;
    else {
      
      while (*data && isspace((unsigned)*data))
	data++;
      if (!has_wsp && !delim_seen) {
	
	if (!*data || strchr(delim, *data) == NULL) {
	  retval = ECONF_MISSING_DELIMITER;
	  goto out;
	}
	data++;
	while (*data && isspace((unsigned)*data))
	  data++;
      } else if (has_wsp && has_nonwsp && !delim_seen && *data && strchr(delim, *data) != NULL) {
	
	data++;
	while (*data && isspace((unsigned)*data))
	  data++;
      }
      if (*data == '"') {
	quote_seen = true;
	data++;
      }

      
      p = data + strlen(data);
      if (p > data)
	p--;
      while (p > data && (isspace((unsigned)*p)))
	p--;
      
      if (p >= data && quote_seen) {
	if (*p == '"')
	  p--;
	else data--;
      }
      if (*(p + 1) != '\0')
	*(p + 1) = '\0';
    }

    retval = store(ef, current_group, name, data, line, current_comment_before_key, current_comment_after_value, quote_seen, false );


    free(current_comment_before_key);
    current_comment_before_key = NULL;
    free(current_comment_after_value);
    current_comment_after_value = NULL;    
    if (retval)
      goto out;
  }

 out:
  fclose (kf);
  if (current_group)
    free (current_group);
  if (current_comment_before_key)
    free(current_comment_before_key);
  if (current_comment_after_value)
    free(current_comment_after_value);

  if(getenv("ECONF_JOIN_SAME_ENTRIES"))
  {
    join_same_entries(ef);
  }

  return retval;
}

void last_scanned_file(char **filename, uint64_t *line_nr)
{
  *line_nr = last_scanned_line_nr;
  *filename = strdup(last_scanned_filename);
}
