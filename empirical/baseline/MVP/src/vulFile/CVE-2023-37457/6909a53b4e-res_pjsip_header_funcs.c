



















struct hdr_list_entry {
	pjsip_hdr *hdr;
	AST_LIST_ENTRY(hdr_list_entry) nextptr;
};
AST_LIST_HEAD_NOLOCK(hdr_list, hdr_list_entry);


static const struct ast_datastore_info header_datastore = {
	.type = "header_datastore", };

static const struct ast_datastore_info response_header_datastore = {
	.type = "response_header_datastore", };


struct header_data {
	struct ast_sip_channel_pvt *channel;
	char *header_name;
	const char *header_value;
	char *buf;
	int header_number;
	size_t len;
	const struct ast_datastore_info *header_datastore;
};


static int insert_headers(pj_pool_t * pool, struct hdr_list *list, pjsip_msg * msg)
{
	pjsip_hdr *hdr = msg->hdr.next;
	struct hdr_list_entry *le;

	while (hdr && hdr != &msg->hdr) {
		le = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));
		le->hdr = pjsip_hdr_clone(pool, hdr);
		AST_LIST_INSERT_TAIL(list, le, nextptr);
		hdr = hdr->next;
	}

	return 0;
}


static int incoming_request(struct ast_sip_session *session, pjsip_rx_data * rdata)
{
	pj_pool_t *pool = session->inv_session->dlg->pool;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);

	if (!datastore) {
		if (!(datastore = ast_sip_session_alloc_datastore(&header_datastore, header_datastore.type))
			|| !(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) || ast_sip_session_add_datastore(session, datastore)) {

			ast_log(AST_LOG_ERROR, "Unable to create datastore for header functions.\n");
			return 0;
		}
		AST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);
	}
	insert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);

	return 0;
}


static void incoming_response(struct ast_sip_session *session, pjsip_rx_data * rdata)
{
	pj_pool_t *pool = session->inv_session->dlg->pool;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(session, response_header_datastore.type), ao2_cleanup);
	pjsip_status_line status = rdata->msg_info.msg->line.status;

	
	if (session->inv_session->state != PJSIP_INV_STATE_CONNECTING || status.code!=200) {
		return;
	}

	if (!datastore) {
		if (!(datastore = ast_sip_session_alloc_datastore(&response_header_datastore, response_header_datastore.type))
			|| !(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list))) || ast_sip_session_add_datastore(session, datastore)) {

			ast_log(AST_LOG_ERROR, "Unable to create datastore for header functions.\n");
			return;
		}
		AST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);
	}
	insert_headers(pool, (struct hdr_list *) datastore->data, rdata->msg_info.msg);

	return;
}


static pjsip_hdr *find_header(struct hdr_list *list, const char *header_name, int header_number)
{
	struct hdr_list_entry *le;
	pjsip_hdr *hdr = NULL;
	int i = 1;

	if (!list || ast_strlen_zero(header_name) || header_number < 1) {
		return NULL;
	}

	AST_LIST_TRAVERSE(list, le, nextptr) {
		if (pj_stricmp2(&le->hdr->name, header_name) == 0 && i++ == header_number) {
			hdr = le->hdr;
			break;
		}
	}

	return hdr;
}


static int read_headers(void *obj)
{
	struct header_data *data = obj;
	size_t len = !ast_strlen_zero(data->header_name) ? strlen(data->header_name) : 0;
	pjsip_hdr *hdr = NULL;
	char *pj_hdr_string;
	int pj_hdr_string_len;
	char *p;
	char *pos;
	size_t plen, wlen = 0;
	struct hdr_list_entry *le;
	struct hdr_list *list;

	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type), ao2_cleanup);


	if (!datastore || !datastore->data) {
		ast_debug(1, "There was no datastore from which to read headers.\n");
		return -1;
	}

	list = datastore->data;
	pj_hdr_string = ast_alloca(data->len);
	AST_LIST_TRAVERSE(list, le, nextptr) {
		if (!len || pj_strnicmp2(&le->hdr->name, data->header_name, len) == 0) {
			
			hdr = le->hdr;

			pj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);
			if (pj_hdr_string_len == -1) {
				ast_log(AST_LOG_ERROR, "Not enough buffer space in pjsip_hdr_print_on\n");
				return -1;
			}
			pj_hdr_string[pj_hdr_string_len] = '\0';
			p = strchr(pj_hdr_string, ':');
			if (!p) {
				ast_log(AST_LOG_WARNING, "A malformed header was returned from pjsip_hdr_print_on\n");
				continue;
			}

			pj_hdr_string[p - pj_hdr_string] = '\0';
			p = ast_strip(pj_hdr_string);
			plen = strlen(p);
			if (wlen + plen + 1 > data->len) {
				ast_log(AST_LOG_ERROR, "Buffer isn't big enough to hold header value.  %zu > %zu\n", plen + 1, data->len);

				return -1;
			}
			pos = strstr(data->buf, p);
			if (pos && pos[1] == ',') {
				if (pos == data->buf) {
					continue;
				} else if (pos[-1] == ',') {
					continue;
				}
			}
			ast_copy_string(data->buf + wlen, p, data->len - wlen);
			wlen += plen;
			ast_copy_string(data->buf + wlen, ",", data->len - wlen);
			wlen++;
		}
	}

	if (wlen == 0) {
		if (!len) {
			
			return 0;
		} else {
			ast_debug(1, "There was no header beginning with %s.\n", data->header_name);
			return -1;
		}
	} else {
		data->buf[wlen-1] = '\0';
	}
	return 0;
}


static int read_header(void *obj)
{
	struct header_data *data = obj;
	size_t len = strlen(data->header_name);
	pjsip_hdr *hdr = NULL;
	char *pj_hdr_string;
	int pj_hdr_string_len;
	char *p;
	size_t plen;
	struct hdr_list_entry *le;
	struct hdr_list *list;
	int i = 1;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type), ao2_cleanup);


	if (!datastore || !datastore->data) {
		ast_debug(1, "There was no datastore from which to read headers.\n");
		return -1;
	}

	list = datastore->data;
	AST_LIST_TRAVERSE(list, le, nextptr) {
		if (data->header_name[len - 1] == '*') {
			if (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0 && i++ == data->header_number) {
				hdr = le->hdr;
				break;
			}
		} else {
			if (pj_stricmp2(&le->hdr->name, data->header_name) == 0 && i++ == data->header_number) {
				hdr = le->hdr;
				break;
			}
		}
	}

	if (!hdr) {
		ast_debug(1, "There was no header named %s.\n", data->header_name);
		return -1;
	}

	pj_hdr_string = ast_alloca(data->len);
	pj_hdr_string_len = pjsip_hdr_print_on(hdr, pj_hdr_string, data->len - 1);
	if (pj_hdr_string_len == -1) {
		ast_log(AST_LOG_ERROR, "Not enough buffer space in pjsip_hdr_print_on\n");
		return -1;
	}

	pj_hdr_string[pj_hdr_string_len] = '\0';

	p = strchr(pj_hdr_string, ':');
	if (!p) {
		ast_log(AST_LOG_ERROR, "A malformed header was returned from pjsip_hdr_print_on.\n");
		return -1;
	}

	++p;
	p = ast_strip(p);
	plen = strlen(p);
	if (plen + 1 > data->len) {
		ast_log(AST_LOG_ERROR, "Buffer isn't big enough to hold header value.  %zu > %zu\n", plen + 1, data->len);

		return -1;
	}

	ast_copy_string(data->buf, p, data->len);

	return 0;
}


static int add_header(void *obj)
{
	struct header_data *data = obj;
	struct ast_sip_session *session = data->channel->session;
	pj_pool_t *pool = session->inv_session->dlg->pool;
	pj_str_t pj_header_name;
	pj_str_t pj_header_value;
	struct hdr_list_entry *le;
	struct hdr_list *list;

	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(session, data->header_datastore->type), ao2_cleanup);

	if (!datastore) {
		if (!(datastore = ast_sip_session_alloc_datastore(data->header_datastore, data->header_datastore->type))
			|| !(datastore->data = pj_pool_alloc(pool, sizeof(struct hdr_list)))
			|| ast_sip_session_add_datastore(session, datastore)) {
			ast_log(AST_LOG_ERROR, "Unable to create datastore for header functions.\n");
			return -1;
		}
		AST_LIST_HEAD_INIT_NOLOCK((struct hdr_list *) datastore->data);
	}

	ast_debug(1, "Adding header %s with value %s\n", data->header_name, data->header_value);

	pj_cstr(&pj_header_name, data->header_name);
	pj_cstr(&pj_header_value, data->header_value);
	le = pj_pool_zalloc(pool, sizeof(struct hdr_list_entry));
	le->hdr = (pjsip_hdr *) pjsip_generic_string_hdr_create(pool, &pj_header_name, &pj_header_value);
	list = datastore->data;

	AST_LIST_INSERT_TAIL(list, le, nextptr);

	return 0;
}


static int update_header(void *obj)
{
	struct header_data *data = obj;
	pjsip_hdr *hdr = NULL;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type), ao2_cleanup);


	if (!datastore || !datastore->data) {
		ast_log(AST_LOG_ERROR, "No headers had been previously added to this session.\n");
		return -1;
	}

	hdr = find_header((struct hdr_list *) datastore->data, data->header_name, data->header_number);

	if (!hdr) {
		ast_log(AST_LOG_ERROR, "There was no header named %s.\n", data->header_name);
		return -1;
	}

	pj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);

	return 0;
}


static int remove_header(void *obj)
{
	struct header_data *data = obj;
	size_t len = strlen(data->header_name);
	struct hdr_list *list;
	struct hdr_list_entry *le;
	int removed_count = 0;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type), ao2_cleanup);


	if (!datastore || !datastore->data) {
		ast_log(AST_LOG_ERROR, "No headers had been previously added to this session.\n");
		return -1;
	}

	list = datastore->data;
	AST_LIST_TRAVERSE_SAFE_BEGIN(list, le, nextptr) {
		if (data->header_name[len - 1] == '*') {
			if (pj_strnicmp2(&le->hdr->name, data->header_name, len - 1) == 0) {
				AST_LIST_REMOVE_CURRENT(nextptr);
				removed_count++;
			}
		} else {
			if (pj_stricmp2(&le->hdr->name, data->header_name) == 0) {
				AST_LIST_REMOVE_CURRENT(nextptr);
				removed_count++;
			}
		}
	}
	AST_LIST_TRAVERSE_SAFE_END;

	if (data->buf && data->len) {
		snprintf(data->buf, data->len, "%d", removed_count);
	}

	return 0;
}


static int func_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct header_data header_data;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(header_pattern);
	);
	AST_STANDARD_APP_ARGS(args, data);

	if (!chan || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}

	header_data.channel = channel;
	header_data.header_name = args.header_pattern;
	header_data.header_value = NULL;
	header_data.buf = buf;
	header_data.len = len;
	header_data.header_datastore = &header_datastore;

	return ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);

}


static int func_response_read_headers(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct header_data header_data;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(header_pattern);
	);
	AST_STANDARD_APP_ARGS(args, data);

	if (!chan || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}

	if (ast_strlen_zero(args.header_pattern)) {
		ast_log(AST_LOG_ERROR, "This function requires a pattern.\n");
		return -1;
	}

	header_data.channel = channel;
	header_data.header_name = args.header_pattern;
	header_data.header_value = NULL;
	header_data.buf = buf;
	header_data.len = len;
	header_data.header_datastore = &response_header_datastore;

	return ast_sip_push_task_wait_serializer(channel->session->serializer, read_headers, &header_data);

}


static int func_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct header_data header_data;
	int number;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(action);
						 AST_APP_ARG(header_name); AST_APP_ARG(header_number););
	AST_STANDARD_APP_ARGS(args, data);

	if (!channel || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}

	if (ast_strlen_zero(args.action)) {
		ast_log(AST_LOG_ERROR, "This function requires an action.\n");
		return -1;
	}
	if (ast_strlen_zero(args.header_name)) {
		ast_log(AST_LOG_ERROR, "This function requires a header name.\n");
		return -1;
	}
	if (!args.header_number) {
		number = 1;
	} else {
		sscanf(args.header_number, "%30d", &number);
		if (number < 1) {
			number = 1;
		}
	}

	header_data.channel = channel;
	header_data.header_name = args.header_name;
	header_data.header_number = number;
	header_data.header_value = NULL;
	header_data.buf = buf;
	header_data.len = len;
	header_data.header_datastore = &header_datastore;

	if (!strcasecmp(args.action, "read")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);
	} else if (!strcasecmp(args.action, "remove")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, remove_header, &header_data);
	} else {
		ast_log(AST_LOG_ERROR, "Unknown action '%s' is not valid, must be 'read' or 'remove'.\n", args.action);

		return -1;
	}
}


static int func_response_read_header(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct header_data header_data;
	int number;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(action);
						 AST_APP_ARG(header_name); AST_APP_ARG(header_number););
	AST_STANDARD_APP_ARGS(args, data);

	if (!channel || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}

	if (ast_strlen_zero(args.action)) {
		ast_log(AST_LOG_ERROR, "This function requires an action.\n");
		return -1;
	}
	if (ast_strlen_zero(args.header_name)) {
		ast_log(AST_LOG_ERROR, "This function requires a header name.\n");
		return -1;
	}
	if (!args.header_number) {
		number = 1;
	} else {
		sscanf(args.header_number, "%30d", &number);
		if (number < 1) {
			number = 1;
		}
	}

	header_data.channel = channel;
	header_data.header_name = args.header_name;
	header_data.header_number = number;
	header_data.header_value = NULL;
	header_data.buf = buf;
	header_data.len = len;
	header_data.header_datastore = &response_header_datastore;

	if (!strcasecmp(args.action, "read")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, read_header, &header_data);
	} else {
		ast_log(AST_LOG_ERROR, "Unknown action '%s' is not valid, must be 'read'.\n", args.action);

		return -1;
	}
}


static int func_write_header(struct ast_channel *chan, const char *cmd, char *data, const char *value)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct header_data header_data;
	int header_number;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(action);
						 AST_APP_ARG(header_name); AST_APP_ARG(header_number););
	AST_STANDARD_APP_ARGS(args, data);

	if (!channel || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}

	if (ast_strlen_zero(args.action)) {
		ast_log(AST_LOG_ERROR, "This function requires an action.\n");
		return -1;
	}
	if (ast_strlen_zero(args.header_name)) {
		ast_log(AST_LOG_ERROR, "This function requires a header name.\n");
		return -1;
	}
	if (!args.header_number) {
		header_number = 1;
	} else {
		sscanf(args.header_number, "%30d", &header_number);
		if (header_number < 1) {
			header_number = 1;
		}
	}

	header_data.channel = channel;
	header_data.header_name = args.header_name;
	header_data.header_number = header_number;
	header_data.header_value = value;
	header_data.buf = NULL;
	header_data.len = 0;
	header_data.header_datastore = &header_datastore;

	if (!strcasecmp(args.action, "add")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, add_header, &header_data);
	} else if (!strcasecmp(args.action, "update")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, update_header, &header_data);
	} else if (!strcasecmp(args.action, "remove")) {
		return ast_sip_push_task_wait_serializer(channel->session->serializer, remove_header, &header_data);
	} else {
		ast_log(AST_LOG_ERROR, "Unknown action '%s' is not valid, must be 'add', 'update', or 'remove'.\n", args.action);

		return -1;
	}
}

static struct ast_custom_function pjsip_header_function = {
	.name = "PJSIP_HEADER", .read = func_read_header, .write = func_write_header, };



static struct ast_custom_function pjsip_headers_function = {
	.name = "PJSIP_HEADERS", .read = func_read_headers };


static struct ast_custom_function pjsip_response_header_function = {
	.name = "PJSIP_RESPONSE_HEADER", .read = func_response_read_header };


static struct ast_custom_function pjsip_response_headers_function = {
	.name = "PJSIP_RESPONSE_HEADERS", .read = func_response_read_headers };



static void outgoing_request(struct ast_sip_session *session, pjsip_tx_data * tdata)
{
	struct hdr_list *list;
	struct hdr_list_entry *le;
	RAII_VAR(struct ast_datastore *, datastore, ast_sip_session_get_datastore(session, header_datastore.type), ao2_cleanup);

	if (!datastore || !datastore->data || (session->inv_session->state >= PJSIP_INV_STATE_CONFIRMED)) {
		return;
	}

	list = datastore->data;
	AST_LIST_TRAVERSE(list, le, nextptr) {
		pjsip_msg_add_hdr(tdata->msg, (pjsip_hdr *) pjsip_hdr_clone(tdata->pool, le->hdr));
	}
	ast_sip_session_remove_datastore(session, datastore->uid);
}

static struct ast_sip_session_supplement header_funcs_supplement = {
	.method = "INVITE", .priority = AST_SIP_SUPPLEMENT_PRIORITY_CHANNEL - 1000, .incoming_request = incoming_request, .outgoing_request = outgoing_request, .incoming_response = incoming_response, };





enum param_type {
	PARAMETER_HEADER, PARAMETER_URI, };


struct param_data {
	struct ast_sip_channel_pvt *channel;
	char *header_name;
	char *param_name;
	const char *param_value; 
	enum param_type paramtype;
	
	char *buf;
	size_t len;
};

static int read_param(void *obj)
{
	struct param_data *data = obj;
	struct ast_sip_session *session = data->channel->session;
	pj_str_t param_name;

	pjsip_fromto_hdr *dlg_info;
	pjsip_name_addr *dlg_info_name_addr;
	pjsip_sip_uri *dlg_info_uri;
	pjsip_param *param;
	size_t param_len;

	dlg_info = session->inv_session->dlg->remote.info; 
	dlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;
	dlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);

	pj_cstr(&param_name, data->param_name);

	if (data->paramtype == PARAMETER_URI) { 
		param = pjsip_param_find(&dlg_info_uri->other_param, &param_name);
	} else { 
		param = pjsip_param_find(&dlg_info->other_param, &param_name);
	}

	if (!param) {
		ast_debug(1, "No %s parameter found named %s\n", data->paramtype == PARAMETER_URI ? "URI" : "header", data->param_name);
		return -1;
	}

	param_len = pj_strlen(&param->value);
	if (param_len >= data->len) {
		ast_log(LOG_ERROR, "Buffer is too small for parameter value (%zu > %zu)\n", param_len, data->len);
		return -1;
	}

	ast_debug(2, "Successfully read %s parameter %s (length %zu)\n", data->paramtype == PARAMETER_URI ? "URI" : "header", data->param_name, param_len);
	if (param_len) {
		ast_copy_string(data->buf, pj_strbuf(&param->value), data->len);
	}
	data->buf[param_len] = '\0';

	return 0;
}


static int add_param(void *obj)
{
	struct param_data *data = obj;
	struct ast_sip_session *session = data->channel->session;
	pj_pool_t *pool = session->inv_session->dlg->pool;

	pjsip_fromto_hdr *dlg_info;
	pjsip_name_addr *dlg_info_name_addr;
	pjsip_sip_uri *dlg_info_uri;

	dlg_info = session->inv_session->dlg->local.info; 
	dlg_info_name_addr = (pjsip_name_addr *) dlg_info->uri;
	dlg_info_uri = pjsip_uri_get_uri(dlg_info_name_addr);
	if (!PJSIP_URI_SCHEME_IS_SIP(dlg_info_uri) && !PJSIP_URI_SCHEME_IS_SIPS(dlg_info_uri)) {
		ast_log(LOG_WARNING, "Non SIP/SIPS URI\n");
		return -1;
	}

	ast_debug(1, "Adding custom %s param %s = %s\n", data->paramtype == PARAMETER_URI ? "URI" : "header", data->param_name, data->param_value);

	








	if (data->paramtype == PARAMETER_URI) { 
		param_add(pool, &dlg_info_uri->other_param, data->param_name, S_OR(data->param_value, ""));
	} else { 
		param_add(pool, &dlg_info->other_param, data->param_name, S_OR(data->param_value, ""));
	}

	return 0;
}

static int func_read_param(struct ast_channel *chan, const char *function, char *data, char *buf, size_t len)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct param_data param_data;

	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(header_name);
		AST_APP_ARG(param_type);
		AST_APP_ARG(param_name);
	);

	AST_STANDARD_APP_ARGS(args, data);

	param_data.channel = channel;

	if (!channel || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}
	if (ast_strlen_zero(args.param_type)) {
		ast_log(AST_LOG_ERROR, "This function requires a parameter type.\n");
		return -1;
	}
	if (ast_strlen_zero(args.param_name)) {
		ast_log(AST_LOG_ERROR, "This function requires a parameter name.\n");
		return -1;
	}

	
	if (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, "From")) {
		ast_log(LOG_WARNING, "Only the From header is currently supported\n");
		return -1;
	}

	param_data.param_name = args.param_name;
	if (!strcasecmp(args.param_type, "header")) {
		param_data.paramtype = PARAMETER_HEADER;
	} else if (!strcasecmp(args.param_type, "uri")) {
		param_data.paramtype = PARAMETER_URI;
	} else {
		ast_log(LOG_WARNING, "Parameter type '%s' is invalid: must be 'header' or 'uri'\n", args.param_type);
		return -1;
	}

	param_data.buf = buf;
	param_data.len = len;

	return ast_sip_push_task_wait_serializer(channel->session->serializer, read_param, &param_data);
}

static int func_write_param(struct ast_channel *chan, const char *cmd, char *data, const char *value)
{
	struct ast_sip_channel_pvt *channel = chan ? ast_channel_tech_pvt(chan) : NULL;
	struct param_data param_data;
	AST_DECLARE_APP_ARGS(args, AST_APP_ARG(header_name);
		AST_APP_ARG(param_type);
		AST_APP_ARG(param_name);
	);

	AST_STANDARD_APP_ARGS(args, data);

	param_data.channel = channel;

	if (!channel || strncmp(ast_channel_name(chan), "PJSIP/", 6)) {
		ast_log(LOG_ERROR, "This function requires a PJSIP channel.\n");
		return -1;
	}
	if (ast_strlen_zero(args.param_type)) {
		ast_log(AST_LOG_ERROR, "This function requires a parameter type.\n");
		return -1;
	}
	if (ast_strlen_zero(args.param_name)) {
		ast_log(AST_LOG_ERROR, "This function requires a parameter name.\n");
		return -1;
	}

	
	if (ast_strlen_zero(args.header_name) || strcasecmp(args.header_name, "From")) {
		ast_log(LOG_WARNING, "Only the From header is currently supported\n");
		return -1;
	}

	param_data.param_name = args.param_name;
	if (!strcasecmp(args.param_type, "header")) {
		param_data.paramtype = PARAMETER_HEADER;
	} else if (!strcasecmp(args.param_type, "uri")) {
		param_data.paramtype = PARAMETER_URI;
	} else {
		ast_log(LOG_WARNING, "Parameter type '%s' is invalid: must be 'header' or 'uri'\n", args.param_type);
		return -1;
	}
	param_data.param_value = value;

	return ast_sip_push_task_wait_serializer(channel->session->serializer, add_param, &param_data);
}

static struct ast_custom_function pjsip_header_param_function = {
	.name = "PJSIP_HEADER_PARAM", .read = func_read_param, .write = func_write_param, };



static int load_module(void)
{
	ast_sip_session_register_supplement(&header_funcs_supplement);
	ast_custom_function_register(&pjsip_header_function);
	ast_custom_function_register(&pjsip_headers_function);
	ast_custom_function_register(&pjsip_response_header_function);
	ast_custom_function_register(&pjsip_response_headers_function);
	ast_custom_function_register(&pjsip_header_param_function);

	return AST_MODULE_LOAD_SUCCESS;
}

static int unload_module(void)
{
	ast_custom_function_unregister(&pjsip_header_function);
	ast_custom_function_unregister(&pjsip_headers_function);
	ast_custom_function_unregister(&pjsip_response_header_function);
	ast_custom_function_unregister(&pjsip_response_headers_function);
	ast_custom_function_unregister(&pjsip_header_param_function);
	ast_sip_session_unregister_supplement(&header_funcs_supplement);
	return 0;
}

AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_LOAD_ORDER, "PJSIP Header Functions", .support_level = AST_MODULE_SUPPORT_CORE, .load = load_module, .unload = unload_module, .load_pri = AST_MODPRI_APP_DEPEND, .requires = "res_pjsip,res_pjsip_session", );





