










namespace hermes {
namespace vm {















class StringView {
  friend class StringPrimitive;
  friend class IdentifierTable;

  union {
    
    
    
    const void *nonManagedStringPtr_;

    
    
    
    
    
    
    
    
    llvh::AlignedCharArrayUnion<Handle<StringPrimitive>> strPrim_;
  };

  
  uint32_t startIndex_ : 30;

  
  uint32_t isHandle_ : 1;

  
  uint32_t isASCII_ : 1;

  
  uint32_t length_;

 public:
  
  
  
  class const_iterator : public std::iterator<std::random_access_iterator_tag, char16_t> {
    friend class StringView;

    
    const char *charPtr_{nullptr};

    
    const char16_t *char16Ptr_{nullptr};

    const_iterator(const char *charPtr, const char16_t *char16Ptr)
        : charPtr_(charPtr), char16Ptr_(char16Ptr) {
      assert( ((!charPtr_) ^ (!char16Ptr_)) && "Must provide one of char or char16 pointer");

    }

    explicit const_iterator(const char *ptr) : const_iterator(ptr, nullptr) {}

    explicit const_iterator(const char16_t *ptr)
        : const_iterator(nullptr, ptr) {}

   public:
    using difference_type = std::ptrdiff_t;
    using reference = char16_t;

    const_iterator() = default;

    
    const_iterator(const const_iterator &other) = default;

    const_iterator &operator++() {
      if (charPtr_) {
        ++charPtr_;
      } else {
        ++char16Ptr_;
      }
      return *this;
    }
    const_iterator &operator--() {
      if (charPtr_) {
        --charPtr_;
      } else {
        --char16Ptr_;
      }
      return *this;
    }
    const_iterator &operator+=(difference_type rhs) {
      if (charPtr_) {
        charPtr_ += rhs;
      } else {
        char16Ptr_ += rhs;
      }
      return *this;
    }
    const_iterator &operator-=(difference_type rhs) {
      if (charPtr_) {
        charPtr_ -= rhs;
      } else {
        char16Ptr_ -= rhs;
      }
      return *this;
    }
    const_iterator operator++(int) {
      const_iterator tmp(charPtr_, char16Ptr_);
      if (charPtr_) {
        ++charPtr_;
      } else {
        ++char16Ptr_;
      }
      return tmp;
    }
    const_iterator operator--(int) {
      const_iterator tmp(charPtr_, char16Ptr_);
      if (charPtr_) {
        --charPtr_;
      } else {
        --char16Ptr_;
      }
      return tmp;
    }

    difference_type operator-(const const_iterator &rhs) const {
      if (charPtr_) {
        return charPtr_ - rhs.charPtr_;
      }
      return char16Ptr_ - rhs.char16Ptr_;
    }

    const_iterator operator-(difference_type rhs) const {
      if (charPtr_) {
        return const_iterator(charPtr_ - rhs, char16Ptr_);
      }
      return const_iterator(charPtr_, char16Ptr_ - rhs);
    }
    const_iterator operator+(difference_type rhs) const {
      if (charPtr_) {
        return const_iterator(charPtr_ + rhs, char16Ptr_);
      }
      return const_iterator(charPtr_, char16Ptr_ + rhs);
    }

    
    
    char16_t operator*() const {
      return charPtr_ ? *charPtr_ : *char16Ptr_;
    }

    
    bool operator==(const const_iterator &rhs) const {
      if (charPtr_) {
        return charPtr_ == rhs.charPtr_;
      }
      return char16Ptr_ == rhs.char16Ptr_;
    }
    bool operator!=(const const_iterator &rhs) const {
      return !(*this == rhs);
    }
    bool operator>(const const_iterator &rhs) const {
      if (charPtr_) {
        return charPtr_ > rhs.charPtr_;
      }
      return char16Ptr_ > rhs.char16Ptr_;
    }
    bool operator<(const const_iterator &rhs) const {
      if (charPtr_) {
        return charPtr_ < rhs.charPtr_;
      }
      return char16Ptr_ < rhs.char16Ptr_;
    }
    bool operator>=(const const_iterator &rhs) const {
      return !(*this < rhs);
    }
    bool operator<=(const const_iterator &rhs) const {
      return !(*this > rhs);
    }
  };

  
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;







  StringView(const StringView &other) {
    ::memcpy(this, &other, sizeof(*this));
    if (isHandle_)
      new (strPrim_.buffer) Handle<StringPrimitive>(other.strPrim());
  }

  StringView &operator=(const StringView &other) {
    if (this != &other) {
      if (isHandle_)
        strPrim().~Handle<StringPrimitive>();
      ::memcpy(this, &other, sizeof(*this));
      if (isHandle_)
        new (strPrim_.buffer) Handle<StringPrimitive>(other.strPrim());
    }
    return *this;
  }

  ~StringView() {
    if (isHandle_)
      strPrim().~Handle<StringPrimitive>();
  }

  StringView(const StringView &other) = default;
  ~StringView() = default;


  StringView(const char *ptr) : StringView(ASCIIRef(ptr, strlen(ptr))) {}

  
  const_iterator begin() const {
    if (isASCII()) {
      return const_iterator(castToCharPtr());
    }
    return const_iterator(castToChar16Ptr());
  }

  
  const_iterator end() const {
    if (isASCII()) {
      return const_iterator(castToCharPtr() + length_);
    }
    return const_iterator(castToChar16Ptr() + length_);
  }

  
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }

  
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  
  size_t length() const {
    return length_;
  }

  
  bool empty() const {
    return !length_;
  }

  
  bool isASCII() const {
    return isASCII_;
  }

  
  char16_t operator[](uint32_t index) const {
    assert(index < length_ && "Out of bound indexing");
    if (isASCII()) {
      return castToCharPtr()[index];
    }
    return castToChar16Ptr()[index];
  }

  
  
  StringView slice(uint32_t start, uint32_t length) const {
    assert(start + length <= length_ && "Out of bound slicing");
    auto newStringView = *this;
    newStringView.startIndex_ += start;
    newStringView.length_ = length;
    return newStringView;
  }

  
  
  StringView slice(uint32_t start) const {
    assert(start <= length_ && "Out of bound slicing");
    return slice(start, length_ - start);
  }

  
  StringView slice(const_iterator first, const_iterator last) const {
    return slice(first - begin(), last - first);
  }

  
  
  
  
  
  
  UTF16Ref getUTF16Ref(llvh::SmallVectorImpl<char16_t> &allocator) const {
    return getUTF16Ref(allocator, false);
  }

  
  
  void copyUTF16String(llvh::SmallVectorImpl<char16_t> &allocator) const {
    (void)getUTF16Ref(allocator, true);
  }

  
  const char *castToCharPtr() const {
    assert(isASCII() && "Cannot cast char16_t pointer to char pointer");
    if (!isHandle_) {
      return static_cast<const char *>(nonManagedStringPtr_) + startIndex_;
    }
    assert(isHandle_ && "StringView does not contain a valid string");
    return (*strPrim())->castToASCIIPointer() + startIndex_;
  }

  
  const char16_t *castToChar16Ptr() const {
    assert(!isASCII() && "Cannot cast char pointer to char16 pointer");
    if (!isHandle_) {
      return static_cast<const char16_t *>(nonManagedStringPtr_) + startIndex_;
    }
    assert(isHandle_ && "StringView does not contain a valid string");
    return (*strPrim())->castToUTF16Pointer() + startIndex_;
  }

  
  bool equals(const StringView &other) const {
    if (other.isASCII()) {
      return equals(ASCIIRef(other.castToCharPtr(), other.length()));
    }
    return equals(UTF16Ref(other.castToChar16Ptr(), other.length()));
  }

  
  template <typename T> bool equals(const llvh::ArrayRef<T> &other) const {
    if (isASCII()) {
      return stringRefEquals(ASCIIRef(castToCharPtr(), length()), other);
    }
    return stringRefEquals(UTF16Ref(castToChar16Ptr(), length()), other);
  }

  TwineChar16 toTwine() const {
    if (isASCII()) {
      return TwineChar16(llvh::StringRef(castToCharPtr(), length()));
    }
    return TwineChar16(UTF16Ref(castToChar16Ptr(), length()));
  }

  operator TwineChar16() const {
    return toTwine();
  }

 private:
  
  

  
  explicit StringView(Handle<StringPrimitive> str)
      : startIndex_(0), isHandle_(true), isASCII_(str->isASCII()), length_(str->getStringLength()) {


    new (strPrim_.buffer) Handle<StringPrimitive>(str);
  }

  
  explicit StringView(ASCIIRef asciiRef)
      : nonManagedStringPtr_(asciiRef.data()), startIndex_(0), isHandle_(false), isASCII_(true), length_(asciiRef.size()) {}



  explicit StringView(UTF16Ref utf16Ref)
      : nonManagedStringPtr_(utf16Ref.data()), startIndex_(0), isHandle_(false), isASCII_(false), length_(utf16Ref.size()) {}




  
  UTF16Ref getUTF16Ref( llvh::SmallVectorImpl<char16_t> &allocator, bool alwaysCopy) const;


  Handle<StringPrimitive> &strPrim() {
    assert(isHandle_ && "must be a handle");
    
    char *buffer = strPrim_.buffer;
    return *reinterpret_cast<Handle<StringPrimitive> *>(buffer);
  }
  const Handle<StringPrimitive> &strPrim() const {
    assert(isHandle_ && "must be a handle");
    
    const char *buffer = strPrim_.buffer;
    return *reinterpret_cast<const Handle<StringPrimitive> *>(buffer);
  }
};

llvh::raw_ostream &operator<<(llvh::raw_ostream &os, const StringView &sv);

} 
} 


