












namespace tensorflow {
namespace grappler {

bool GetTensorShapeProtoFromTensorProto(const TensorProto& tensor_proto, TensorShapeProto* tensor_shape_proto);
TensorShapeProto MaybeGetMinimumShape(const TensorShapeProto& original_shape, int rank, bool* found_unknown_shapes);


struct NodeCosts {
  
  
  
  
  bool minimum_cost_op = false;

  
  int64_t num_compute_ops = 0;

  
  
  std::vector<int64_t> num_input_bytes_accessed;   
  std::vector<int64_t> num_output_bytes_accessed;  
  int64_t internal_read_bytes = 0;
  int64_t internal_write_bytes = 0;

  
  int64_t num_total_input_bytes() const {
    return std::accumulate(num_input_bytes_accessed.begin(), num_input_bytes_accessed.end(), 0LL);
  }
  int64_t num_total_read_bytes() const {
    return num_total_input_bytes() + internal_read_bytes;
  }
  int64_t num_total_output_bytes() const {
    return std::accumulate(num_output_bytes_accessed.begin(), num_output_bytes_accessed.end(), 0LL);
  }
  int64_t num_total_write_bytes() const {
    return num_total_output_bytes() + internal_write_bytes;
  }
  int64_t num_bytes_accessed() const {
    return num_total_read_bytes() + num_total_write_bytes();
  }

  
  int64_t max_memory = 0;
  int64_t persistent_memory = 0;
  int64_t temporary_memory = 0;

  
  int64_t num_nodes = 1;
  int64_t num_nodes_with_unknown_shapes = 0;
  int64_t num_nodes_with_unknown_op_type = 0;
  int64_t num_nodes_with_pure_memory_op = 0;
  bool inaccurate = false;

  
  
  
  bool has_costs = false;
  Costs costs;
};

class OpLevelCostEstimator {
 public:
  OpLevelCostEstimator();
  virtual ~OpLevelCostEstimator() {}

  virtual Costs PredictCosts(const OpContext& op_context) const;

  
  virtual DeviceInfo GetDeviceInfo(const DeviceProperties& device) const;

 protected:
  
  
  
  Costs PredictOpCountBasedCost(double operations, const OpInfo& op_info) const;

  
  
  
  Costs PredictOpCountBasedCost(double operations, double input_io_bytes, double output_io_bytes, const OpInfo& op_info) const;


  
  
  
  Status PredictNodeCosts(const OpContext& op_context, NodeCosts* node_costs) const;

  
  Status PredictCostOfAnUnknownOp(const OpContext& op_context, NodeCosts* node_costs) const;

  
  
  
  
  
  
  
  
  
  
  Status PredictNaryOp(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictConv2D(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictCwiseOp(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictConv2DBackpropInput(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictConv2DBackpropFilter(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictFusedConv2DBiasActivation(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictMatMul(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictSparseTensorDenseMatMul(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictNoOp(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictIdentity(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictVariable(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictBatchMatMul(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictMetadata(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictGatherOrSlice(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictScatter(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictMaxPool(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictMaxPoolGrad(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictAvgPool(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictAvgPoolGrad(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictFusedBatchNorm(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictFusedBatchNormGrad(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictEinsum(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictAssignVariableOps(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictPureMemoryOp(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictSoftmax(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictResizeBilinear(const OpContext& op_context, NodeCosts* node_costs) const;
  Status PredictCropAndResize(const OpContext& op_context, NodeCosts* node_costs) const;

  
  Status PredictFusedOp(const OpContext& op_context, const std::vector<OpContext>& fused_op_contexts, NodeCosts* node_costs) const;


  
  
  static double SafeDiv(const double lhs, const double rhs) {
    if (rhs > 0) {
      return lhs / rhs;
    } else {
      return 0.0;
    }
  }

  
  
  struct MatMulDimensions {
    int m;
    int n;
    int k;
  };
  struct BatchMatMulDimensions {
    std::vector<int> batch_dims;
    MatMulDimensions matmul_dims;
  };
  struct ConvolutionDimensions {
    int64_t batch;  
    int64_t ix;     
    int64_t iy;     
    int64_t iz;     
    int64_t kx;     
    int64_t ky;     
    int64_t kz;     
                    
    int64_t oz;     
    int64_t ox;     
    int64_t oy;     
    int64_t sx;     
    int64_t sy;     
    Padding padding;  
  };
  static int64_t CountConv2DOperations(const OpInfo& op_info, bool* found_unknown_shapes);
  static int64_t CountConv2DOperations(const OpInfo& op_info, ConvolutionDimensions* conv_info, bool* found_unknown_shapes);

  static int64_t CountMatMulOperations(const OpInfo& op_info, bool* found_unknown_shapes);
  static int64_t CountMatMulOperations(const OpInfo& op_info, MatMulDimensions* mat_mul, bool* found_unknown_shapes);

  bool GenerateBatchMatmulContextFromEinsum(const OpContext& einsum_context, OpContext* batch_matmul_context, bool* found_unknown_shapes) const;

  static int64_t CountBatchMatMulOperations(const OpInfo& op_info, bool* found_unknown_shapes);
  static int64_t CountBatchMatMulOperations( const OpInfo& op_info, BatchMatMulDimensions* batch_mat_mul, bool* found_unknown_shapes);

  static int64_t CountConv2DBackpropInputOperations( const OpInfo& op_info, ConvolutionDimensions* returned_conv_dims, bool* found_unknown_shapes);

  static int64_t CountConv2DBackpropFilterOperations( const OpInfo& op_info, ConvolutionDimensions* returned_conv_dims, bool* found_unknown_shapes);


  
  static int64_t CalculateTensorElementCount( const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes);

  
  static int64_t CalculateTensorSize(const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes);

  
  
  static int64_t CalculateLargestInputCount(const OpInfo& op_info, bool* found_unknown_shapes);

  
  
  static int64_t CalculateInputSize(const OpInfo& op_info, bool* found_unknown_shapes);

  
  static std::vector<int64_t> CalculateInputTensorSize( const OpInfo& op_info, bool* found_unknown_shapes);

  
  
  static int64_t CalculateOutputSize(const OpInfo& op_info, bool* found_unknown_shapes);

  
  static std::vector<int64_t> CalculateOutputTensorSize( const OpInfo& op_info, bool* found_unknown_shapes);

  
  static ConvolutionDimensions ConvolutionDimensionsFromInputs( const TensorShapeProto& original_image_shape, const TensorShapeProto& original_filter_shape, const OpInfo& op_info, bool* found_unknown_shapes);



  
  static ConvolutionDimensions OpDimensionsFromInputs( const TensorShapeProto& original_image_shape, const OpInfo& op_info, bool* found_unknown_shapes);


  
  
  static OpContext FusedChildContext( const OpContext& parent, const string& op_name, const OpInfo::TensorProperties& output, const std::vector<OpInfo::TensorProperties>& inputs);



  
  static OpInfo::TensorProperties DescribeTensor( DataType type, const std::vector<int64_t>& dims);

  
  static Status PredictDefaultNodeCosts(const int64_t num_compute_ops, const OpContext& op_context, bool* found_unknown_shapes, NodeCosts* node_costs);



 protected:
  std::map<string, int> elementwise_ops_;
  typedef std::function<Status(const OpContext& op_context, NodeCosts*)> CostImpl;
  std::map<string, CostImpl> device_cost_impl_;
  
  
  bool compute_memory_overlap_;
  std::set<string> persistent_ops_;

 private:
  friend class OpLevelCostEstimatorTest;
};

}  
}  


