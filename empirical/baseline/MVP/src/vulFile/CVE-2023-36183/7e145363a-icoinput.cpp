

















OIIO_PLUGIN_NAMESPACE_BEGIN  using namespace ICO_pvt;


class ICOInput final : public ImageInput {
public:
    ICOInput() { init(); }
    ~ICOInput() override { close(); }
    const char* format_name(void) const override { return "ico"; }
    bool open(const std::string& name, ImageSpec& newspec) override;
    bool close() override;
    int current_subimage(void) const override {
        lock_guard lock(*this);
        return m_subimage;
    }
    bool seek_subimage(int subimage, int miplevel) override;
    bool read_native_scanline(int subimage, int miplevel, int y, int z, void* data) override;

private:
    std::string m_filename;            
    FILE* m_file;                      
    ico_header m_ico;                  
    std::vector<unsigned char> m_buf;  
    int m_subimage;                    
    int m_bpp;                         
    int m_offset;                      
    int m_subimage_size;               
    int m_palette_size;  

    png_structp m_png;     
    png_infop m_info;      
    int m_color_type;      
    int m_interlace_type;  
    Imath::Color3f m_bg;   

    
    
    void init()
    {
        m_subimage = -1;
        m_file     = NULL;
        m_png      = NULL;
        m_info     = NULL;
        memset(&m_ico, 0, sizeof(m_ico));
        m_buf.clear();
    }

    
    
    bool readimg();

    
    
    bool fread(void* buf, size_t itemsize, size_t nitems)
    {
        size_t n = ::fread(buf, itemsize, nitems, m_file);
        if (n != nitems)
            errorf("Read error");
        return n == nitems;
    }
};




OIIO_PLUGIN_EXPORTS_BEGIN  OIIO_EXPORT ImageInput* ico_input_imageio_create()


{
    return new ICOInput;
}

OIIO_EXPORT int ico_imageio_version = OIIO_PLUGIN_VERSION;

OIIO_EXPORT const char* ico_imageio_library_version()
{
    return nullptr;
}

OIIO_EXPORT const char* ico_input_extensions[] = { "ico", nullptr };

OIIO_PLUGIN_EXPORTS_END    bool ICOInput::open(const std::string& name, ImageSpec& newspec)




{
    m_filename = name;

    m_file = Filesystem::fopen(name, "rb");
    if (!m_file) {
        errorf("Could not open file \"%s\"", name);
        return false;
    }

    if (!fread(&m_ico, 1, sizeof(m_ico)))
        return false;

    if (bigendian()) {
        
        
        swap_endian(&m_ico.type);
        swap_endian(&m_ico.count);
    }
    if (m_ico.reserved != 0 || m_ico.type != 1) {
        errorf("File failed ICO header check");
        return false;
    }

    
    bool ok = seek_subimage(0, 0);
    if (ok)
        newspec = spec();
    else close();
    return ok;
}



bool ICOInput::seek_subimage(int subimage, int miplevel)
{
    
    if (miplevel != 0 || subimage < 0 || subimage >= m_ico.count)
        return false;

    if (subimage == m_subimage) {
        return true;
    }

    
    m_buf.clear();

    
    if (m_png && m_info)
        PNG_pvt::destroy_read_struct(m_png, m_info);

    m_subimage = subimage;

    
    fseek(m_file, sizeof(ico_header) + m_subimage * sizeof(ico_subimage), SEEK_SET);
    ico_subimage subimg;
    if (!fread(&subimg, 1, sizeof(subimg)))
        return false;

    if (bigendian()) {
        
        swap_endian(&subimg.bpp);
        swap_endian(&subimg.width);
        swap_endian(&subimg.height);
        swap_endian(&subimg.len);
        swap_endian(&subimg.ofs);
        swap_endian(&subimg.numColours);
    }

    fseek(m_file, subimg.ofs, SEEK_SET);

    
    char temp[8];
    if (!fread(temp, 1, sizeof(temp)))
        return false;
    if (temp[1] == 'P' && temp[2] == 'N' && temp[3] == 'G') {
        
        if (png_sig_cmp((png_bytep)temp, 0, 7)) {
            errorf("Subimage failed PNG signature check");
            return false;
        }

        

        std::string s = PNG_pvt::create_read_struct(m_png, m_info, this);
        if (s.length()) {
            errorf("%s", s);
            return false;
        }

        

        png_init_io(m_png, m_file);
        png_set_sig_bytes(m_png, 8);  

        PNG_pvt::read_info(m_png, m_info, m_bpp, m_color_type, m_interlace_type, m_bg, m_spec, true);

        m_spec.attribute("oiio:BitsPerSample", m_bpp / m_spec.nchannels);

        return true;
    }

    
    
    fseek(m_file, subimg.ofs, SEEK_SET);

    ico_bitmapinfo bmi;
    if (!fread(&bmi, 1, sizeof(bmi)))
        return false;
    if (bigendian()) {
        
        
        swap_endian(&bmi.size);
        swap_endian(&bmi.bpp);
        swap_endian(&bmi.width);
        swap_endian(&bmi.height);
        swap_endian(&bmi.len);
    }

    

    
    m_bpp = bmi.bpp;
    
    if (m_bpp != 1 && m_bpp != 4 && m_bpp != 8  && m_bpp != 24 && m_bpp != 32) {


        errorf("Unsupported image color depth, probably corrupt file");
        return false;
    }
    m_offset        = subimg.ofs;
    m_subimage_size = subimg.len;
    
    m_palette_size = (subimg.numColours == 0 && m_bpp < 16)
                         ? 256 : (int)subimg.numColours;

    m_spec = ImageSpec((int)subimg.width, (int)subimg.height, 4, TypeDesc::UINT8);

    m_spec.default_channel_names();
    
    m_spec.attribute("oiio:BitsPerSample", m_bpp / m_spec.nchannels + (m_bpp == 32 ? 0 : 1));

    

    return true;
}



bool ICOInput::readimg()
{
    if (m_png) {
        
        std::string s = PNG_pvt::read_into_buffer(m_png, m_info, m_spec, m_buf);

        

        if (s.length()) {
            errorf("%s", s);
            return false;
        }

        return true;
    }

    
    OIIO_DASSERT(m_spec.scanline_bytes() == ((size_t)m_spec.width * 4));
    m_buf.resize(m_spec.image_bytes());

    

    
    
    std::vector<ico_palette_entry> palette(m_palette_size);
    if (m_bpp < 16) {  
        for (int i = 0; i < m_palette_size; i++)
            if (!fread(&palette[i], 1, sizeof(ico_palette_entry)))
                return false;
    }

    
    
    int slb = (m_spec.width * m_bpp + 7) / 8   + (4 - ((m_spec.width * m_bpp + 7) / 8) % 4) % 4;
    std::vector<unsigned char> scanline(slb);
    ico_palette_entry* pe;
    int k;
    for (int y = m_spec.height - 1; y >= 0; y--) {
        if (!fread(&scanline[0], 1, slb))
            return false;
        for (int x = 0; x < m_spec.width; x++) {
            k = y * m_spec.width * 4 + x * 4;
            
            switch (m_bpp) {
            case 1:
                pe = &palette[(scanline[x / 8] & (1 << (7 - x % 8))) != 0];
                m_buf[k + 0] = pe->r;
                m_buf[k + 1] = pe->g;
                m_buf[k + 2] = pe->b;
                break;
            case 4:
                pe           = &palette[(scanline[x / 2] & 0xF0) >> 4];
                m_buf[k + 0] = pe->r;
                m_buf[k + 1] = pe->g;
                m_buf[k + 2] = pe->b;
                
                pe = &palette[scanline[x / 2] & 0x0F];
                if (x == m_spec.width - 1)
                    break;  
                x++;
                m_buf[k + 4] = pe->r;
                m_buf[k + 5] = pe->g;
                m_buf[k + 6] = pe->b;
                
                break;
            case 8:
                pe           = &palette[scanline[x]];
                m_buf[k + 0] = pe->r;
                m_buf[k + 1] = pe->g;
                m_buf[k + 2] = pe->b;
                break;
                

            
            
            case 16:
                
                
                
                m_buf[k + 0] = (scanline[x * 2 + 1] & 0x1F) << 3;
                m_buf[k + 1] = ((scanline[x * 2 + 1] & 0xE0) >> 3)
                               | ((scanline[x * 2 + 0] & 0x07) << 5);
                m_buf[k + 2] = scanline[x * 2 + 0] & 0xF8;
                break;

            case 24:
                m_buf[k + 0] = scanline[x * 3 + 2];
                m_buf[k + 1] = scanline[x * 3 + 1];
                m_buf[k + 2] = scanline[x * 3 + 0];
                break;
            case 32:
                m_buf[k + 0] = scanline[x * 4 + 2];
                m_buf[k + 1] = scanline[x * 4 + 1];
                m_buf[k + 2] = scanline[x * 4 + 0];
                m_buf[k + 3] = scanline[x * 4 + 3];
                break;
            }
        }
    }

    
    if (m_bpp < 32) {
        
        slb = (m_spec.width + 7) / 8                      + (4 - ((m_spec.width + 7) / 8) % 4) % 4;
        scanline.resize(slb);
        for (int y = m_spec.height - 1; y >= 0; y--) {
            if (!fread(&scanline[0], 1, slb))
                return false;
            for (int x = 0; x < m_spec.width; x += 8) {
                for (int b = 0; b < 8; b++) {  
                    k = y * m_spec.width * 4 + (x + 7 - b) * 4;
                    if (scanline[x / 8] & (1 << b))
                        m_buf[k + 3] = 0;
                    else m_buf[k + 3] = 255;
                }
            }
        }
    }

    return true;
}



bool ICOInput::close()
{
    if (m_png && m_info)
        PNG_pvt::destroy_read_struct(m_png, m_info);
    if (m_file) {
        fclose(m_file);
        m_file = NULL;
    }

    init();  
    return true;
}



bool ICOInput::read_native_scanline(int subimage, int miplevel, int y, int , void* data)

{
    lock_guard lock(*this);
    if (!seek_subimage(subimage, miplevel))
        return false;

    if (m_buf.empty()) {
        if (!readimg())
            return false;
    }

    size_t size = spec().scanline_bytes();
    
    memcpy(data, &m_buf[y * size], size);
    return true;
}

OIIO_PLUGIN_NAMESPACE_END