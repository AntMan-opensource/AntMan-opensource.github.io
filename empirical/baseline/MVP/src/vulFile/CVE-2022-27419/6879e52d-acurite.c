


































































int const acurite_5n1_winddirections[] = {
    14,  11, 13, 12, 15, 10, 0, 9, 3, 6, 4, 5, 2, 7, 1, 8, };




















static char const *acurite_getChannel(uint8_t byte)
{
    static char const *channel_strs[] = {"C", "E", "B", "A"; 

    int channel = (byte & 0xC0) >> 6;
    return channel_strs[channel];
}

static char const *acurite_getChannelAndType(uint8_t byte, uint8_t mtype)
{
    static char const *channel_strs[] = {"CR", "ER", "BR", "AR", "CF", "EF", "BF", "AF"; 

    int channel = ((mtype & 0x01) << 2) | ((byte & 0xC0) >> 6);
    return channel_strs[channel];
}

static int acurite_rain_896_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    uint8_t *b = bitbuffer->bb[0];
    int id;
    float total_rain;
    data_t *data;

    
    if (bitbuffer->bits_per_row[0] < 24)
        return DECODE_ABORT_LENGTH;

    if ((b[0] == 0) || (b[1] == 0) || (b[2] == 0) || (b[3] != 0) || (b[4] != 0))
        return DECODE_ABORT_EARLY;

    id = b[0];
    total_rain = ((b[1] & 0xf) << 8) | b[2];
    total_rain *= 0.5; 

    decoder_logf(decoder, 2, __func__, "Total Rain is %2.1fmm", total_rain);
    decoder_log_bitrow(decoder, 2, __func__, b, bitbuffer->bits_per_row[0], "Raw Message ");

    
    data = data_make( "model",                "",             DATA_STRING, "Acurite-Rain", "id",                   "",             DATA_INT,    id, "rain_mm",              "Total Rain",   DATA_FORMAT, "%.1f mm", DATA_DOUBLE, total_rain, NULL);



    

    decoder_output_data(decoder, data);
    return 1;
}


static int acurite_th_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    uint8_t *bb = NULL;
    int cksum, battery_low, valid = 0;
    float tempc;
    uint8_t humidity, id, status;
    data_t *data;
    int result = 0;

    for (uint16_t brow = 0; brow < bitbuffer->num_rows; ++brow) {
        if (bitbuffer->bits_per_row[brow] != 40) {
            result = DECODE_ABORT_LENGTH;
            continue; 
        }

        bb = bitbuffer->bb[brow];

        cksum = (bb[0] + bb[1] + bb[2] + bb[3]);

        if (cksum == 0 || ((cksum & 0xff) != bb[4])) {
            result = DECODE_FAIL_MIC;
            continue; 
        }

        
        
        
        int temp_raw = (int16_t)(((bb[1] & 0x0f) << 12) | (bb[2] << 4));
        tempc        = (temp_raw >> 4) * 0.1f;
        id           = bb[0];
        status       = (bb[1] & 0xf0) >> 4;
        battery_low  = status & 0x8;
        humidity     = bb[3];

        
        data = data_make( "model",            "",             DATA_STRING, "Acurite-609TXC", "id",               "",             DATA_INT,    id, "battery_ok",       "Battery",      DATA_INT,    !battery_low, "temperature_C",    "Temperature",  DATA_FORMAT, "%.1f C", DATA_DOUBLE, tempc, "humidity",         "Humidity",     DATA_FORMAT, "%u %%", DATA_INT,    humidity, "status",           "",             DATA_INT,    status, "mic",              "Integrity",    DATA_STRING, "CHECKSUM", NULL);







        

        decoder_output_data(decoder, data);
        valid++;
    }

    if (valid)
        return 1;

    
    return result;
}



static int acurite_6045_decode(r_device *decoder, bitbuffer_t *bitbuffer, unsigned row)
{
    float tempf;
    uint8_t humidity;
    
    char raw_str[31], *rawp;
    uint16_t sensor_id;
    uint8_t strike_count, strike_distance;
    int battery_low, active, rfi_detect;
    int exception = 0;
    data_t *data;

    int browlen = (bitbuffer->bits_per_row[row] + 7) / 8;
    uint8_t *bb = bitbuffer->bb[row];

    char const *channel_str = acurite_getChannel(bb[0]); 

    
    
    sensor_id = ((bb[0] & 0x3f) << 8) | bb[1]; 
    battery_low = (bb[2] & 0x40) == 0;
    humidity = (bb[3] & 0x7f); 
    active = (bb[4] & 0x40) == 0x40;    
    

    
    
    
    
    int temp_raw = ((bb[4] & 0x1F) << 7) | (bb[5] & 0x7F);
    tempf = (temp_raw - 1480) * 0.1f;

    
    strike_count = ((bb[6] & 0x7f) << 1) | ((bb[7] & 0x40) >> 6);
    strike_distance = bb[7] & 0x1f;
    rfi_detect = (bb[7] & 0x20) == 0x20;
    

    
    rawp = (char *)raw_str;
    for (int i=0; i < MIN(browlen, 15); i++) {
        sprintf(rawp,"%02x",bb[i]);
        rawp += 2;
    }
    *rawp = '\0';

    
    if (((bb[4] & 0x20) != 0) ||   (humidity > 100) || (tempf > 158) || (tempf < -40)) {


        exception++;
    }

    
    data = data_make( "model",            "",                 DATA_STRING, "Acurite-6045M", "id",               NULL,               DATA_INT,    sensor_id, "channel",          NULL,               DATA_STRING, channel_str, "battery_ok",       "Battery",          DATA_INT,    !battery_low, "temperature_F",    "temperature",      DATA_FORMAT, "%.1f F",     DATA_DOUBLE,     tempf, "humidity",         "humidity",         DATA_FORMAT, "%u %%", DATA_INT,    humidity, "strike_count",     "strike_count",     DATA_INT,    strike_count, "storm_dist",       "storm_distance",   DATA_INT,    strike_distance, "active",           "active_mode",      DATA_INT,    active, "rfi",              "rfi_detect",       DATA_INT,    rfi_detect, "exception",        "data_exception",   DATA_INT,    exception, "raw_msg",          "raw_message",      DATA_STRING, raw_str, NULL);












    

    decoder_output_data(decoder, data);
    return 1;
}


static int acurite_atlas_decode(r_device *decoder, bitbuffer_t *bitbuffer, unsigned row)
{
    uint8_t humidity, sequence_num, message_type;
    char raw_str[31], *rawp;
    uint16_t sensor_id;
    int raincounter, battery_low;
    int exception = 0;
    float tempf, wind_dir, wind_speed_mph;
    data_t *data;

    int browlen = (bitbuffer->bits_per_row[row] + 7) / 8;
    uint8_t *bb = bitbuffer->bb[row];

    
    
    
    
    
    

    
    message_type = bb[2] & 0x3f;
    sensor_id = ((bb[0] & 0x03) << 8) | bb[1];
    char const *channel_str = acurite_getChannel(bb[0]);

    
    
    
    
    rawp = (char *)raw_str;
    for (int i=0; i < MIN(browlen, 15); i++) {
        sprintf(rawp,"%02x",bb[i]);
        rawp += 2;
    }
    *rawp = '\0';

    
    
    
    
    
    
    
    sequence_num = (bb[0] & 0x0c) >> 2;
    
    battery_low = (bb[2] & 0x40) == 0;

    
    wind_speed_mph = ((bb[3] & 0x7F) << 1) | ((bb[4] & 0x40) >> 6);

    
    data = data_make( "model",                "",             DATA_STRING, "Acurite-Atlas", "id",                   NULL,           DATA_INT,    sensor_id, "channel",              NULL,           DATA_STRING, channel_str, "sequence_num",         NULL,           DATA_INT,    sequence_num, "battery_ok",           "Battery",      DATA_INT,    !battery_low, "message_type",         NULL,           DATA_INT,    message_type, "wind_avg_mi_h",        "Wind Speed",   DATA_FORMAT, "%.1f mi/h", DATA_DOUBLE, wind_speed_mph, NULL);







    

    if (message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_TEMP_HUM || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_TEMP_HUM_LTNG) {
        

        
        
        int temp_raw = (bb[4] & 0x0F) << 7 | (bb[5] & 0x7F);
        tempf = (temp_raw - 400) * 0.1;

        humidity = (bb[6] & 0x7f); 

        
        data = data_append(data, "temperature_F",    "temperature",  DATA_FORMAT,    "%.1f F",       DATA_DOUBLE, tempf, "humidity",         NULL,           DATA_FORMAT,    "%u %%",        DATA_INT,    humidity, NULL);


        
    }

    if (message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_RAIN || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_RAIN_LTNG) {
        
        wind_dir = ((bb[4] & 0x1f) << 5) | ((bb[5] & 0x7c) >> 2);

        
        
        raincounter = ((bb[5] & 0x03) << 7) | (bb[6] & 0x7F);

        
        data = data_append(data, "wind_dir_deg",     NULL,           DATA_FORMAT,    "%.1f",         DATA_DOUBLE, wind_dir, "rain_in",          "Rainfall Accumulation", DATA_FORMAT, "%.2f in", DATA_DOUBLE, raincounter * 0.01f, NULL);


        
    }

    if (message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_UV_LUX || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_UV_LUX_LTNG) {
        
        int uv  = (bb[4] & 0x0f);
        int lux = ((bb[5] & 0x7f) << 7) | (bb[6] & 0x7F);

        
        data = data_append(data, "uv",               NULL,           DATA_INT, uv, "lux",              NULL,           DATA_INT, lux * 10, NULL);


        
    }

    if ((message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_TEMP_HUM_LTNG || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_RAIN_LTNG || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_UV_LUX_LTNG)) {


        
        int strike_count    = ((bb[7] & 0x7f) << 2) | ((bb[8] & 0x60) >> 5);
        int strike_distance = bb[8] & 0x1f;

        
        data = data_append(data, "strike_count",         NULL,           DATA_INT, strike_count, "strike_distance",      NULL,           DATA_INT, strike_distance, NULL);


        
    }

    data = data_append(data, "exception",        "data_exception",   DATA_INT,    exception, "raw_msg",          "raw_message",      DATA_STRING, raw_str, NULL);



    decoder_output_data(decoder, data);

    return 1; 
}

static int acurite_tower_decode(r_device* decoder, uint8_t* bb)
{
    

    
    
    int parity = parity_bytes(&bb[2], 4);
    if (parity) {
        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, "bad parity");
        return DECODE_FAIL_MIC;
    }

    
    
    char const* channel_str = acurite_getChannel(bb[0]);
    if (*channel_str == 'E') {
        decoder_logf(decoder, 1, __func__, "bad channel Ch %s", channel_str);
        return DECODE_FAIL_SANITY;
    }

    
    
    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];

    
    
    int battery_low = (bb[2] & 0x40) == 0;

    
    
    
    
    
    int humidity = (bb[3] & 0x7f);
    if (humidity < 0 || humidity > 100) {
        decoder_logf(decoder, 1, __func__, "0x%04X Ch %s : Impossible humidity: %d %%rH", sensor_id, channel_str, humidity);
        return DECODE_FAIL_SANITY;
    }

    
    
    
    
    
    
    int temp_raw = ((bb[4] & 0x7F) << 7) | (bb[5] & 0x7F);
    float tempc = temp_raw * 0.1 - 100;
    if (tempc < -40 || tempc > 70) {
        decoder_logf(decoder, 1, __func__, "0x%04X Ch %s : Impossible temperature: %0.2f C", sensor_id, channel_str, tempc);
        return DECODE_FAIL_SANITY;
    }

    data_t* data;
    
    data = data_make( "model",                "",             DATA_STRING, "Acurite-Tower", "id",                   "",             DATA_INT,    sensor_id, "channel",              NULL,           DATA_STRING, channel_str, "battery_ok",           "Battery",      DATA_INT,    !battery_low, "temperature_C",        "Temperature",  DATA_FORMAT, "%.1f C", DATA_DOUBLE, tempc, "humidity",             "Humidity",     DATA_FORMAT, "%u %%", DATA_INT,    humidity, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);







    

    decoder_output_data(decoder, data);

    return 1;
}

static int acurite_leak_detector_decode(r_device* decoder, uint8_t* bb)
{
    

    
    
    int parity = parity_bytes(&bb[2], 4);
    if (parity) {
        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, "bad parity");
        return DECODE_FAIL_MIC;
    }

    
    
    char const* channel_str = acurite_getChannel(bb[0]);
    if (*channel_str == 'E') {
        decoder_logf(decoder, 1, __func__, "Acurite TXR sensor : bad channel Ch %s", channel_str);
        return DECODE_FAIL_SANITY;
    }

    
    
    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];

    
    int battery_low = (bb[2] & 0x40) == 0;

    
    int is_wet = (bb[3] & 0x10) >> 4;

    data_t* data;
    
    data = data_make( "model",                "",             DATA_STRING, "Acurite-Leak", "id",                   "",             DATA_INT,    sensor_id, "channel",              NULL,           DATA_STRING, channel_str, "battery_ok",           "Battery",      DATA_INT,    !battery_low, "leak_detected",        "Leak",         DATA_INT,    is_wet, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);






    

    decoder_output_data(decoder, data);

    return 1;
}


static int acurite_txr_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    int browlen, valid = 0;
    uint8_t *bb;
    float tempf, wind_dir, wind_speed_kph, wind_speed_mph;
    uint8_t humidity, sequence_num, message_type;
    
    uint16_t sensor_id;
    int raincounter, battery_low;
    data_t *data;

    bitbuffer_invert(bitbuffer);

    for (uint16_t brow = 0; brow < bitbuffer->num_rows; ++brow) {
        browlen = (bitbuffer->bits_per_row[brow] + 7)/8;
        bb = bitbuffer->bb[brow];

        decoder_logf(decoder, 2, __func__, "row %u bits %u, bytes %d", brow, bitbuffer->bits_per_row[brow], browlen);

        if ((bitbuffer->bits_per_row[brow] < ACURITE_TXR_BITLEN || bitbuffer->bits_per_row[brow] > ACURITE_5N1_BITLEN + 1)
                && bitbuffer->bits_per_row[brow] != ACURITE_6045_BITLEN && bitbuffer->bits_per_row[brow] != ACURITE_ATLAS_BITLEN && bitbuffer->bits_per_row[brow] != ACURITE_515_BITLEN) {

            if (bitbuffer->bits_per_row[brow] > 16)
                decoder_log(decoder, 2, __func__, "skipping wrong len");
            continue; 
        }

        
        
        if (bb[browlen - 1] == 0)
            browlen--;

        
        
        int sum = add_bytes(bb, browlen - 1);
        if (sum == 0 || (sum & 0xff) != bb[browlen - 1]) {
            decoder_log_bitrow(decoder, 1, __func__, bb, bitbuffer->bits_per_row[brow], "bad checksum");
            continue; 
        }

        
        
        
        
        
        
        message_type = bb[2] & 0x3f;

        
        
        
        if (browlen == ACURITE_TXR_BITLEN / 8) {
            int decoded = 0;

            if (message_type == ACURITE_MSGTYPE_LEAK_DETECTOR) {
                decoded = acurite_leak_detector_decode(decoder, bb);
            } else if (message_type == ACURITE_MSGTYPE_TOWER_SENSOR) {
                decoded = acurite_tower_decode(decoder, bb);
            }

            
            
            if (decoded > 0) {
                valid++;
            }
        }

        
        if (browlen == ACURITE_515_BITLEN / 8) {
            char const *channel_str = acurite_getChannelAndType(bb[0], message_type);

            
            
            
            sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];

            
            if (message_type != ACURITE_MSGTYPE_515_REFRIGERATOR && message_type != ACURITE_MSGTYPE_515_FREEZER) {
                decoder_logf(decoder, 2, __func__, "Acurite 515 sensor 0x%04X Ch %s, Unknown message type 0x%02x", sensor_id, channel_str, message_type);
                continue; 
            }

            
            
            int temp_raw = ((bb[3] & 0x7F) << 7) | (bb[4] & 0x7F);
            tempf = (temp_raw - 1480) * 0.1f;
            
            battery_low = (bb[2] & 0x40) == 0;

            
            data = data_make( "model",                "",             DATA_STRING, "Acurite-515", "id",                   "",             DATA_INT,    sensor_id, "channel",              NULL,           DATA_STRING, channel_str, "battery_ok",           "Battery",      DATA_INT,    !battery_low, "temperature_F",        "Temperature",  DATA_FORMAT, "%.1f F", DATA_DOUBLE, tempf, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);






            

            decoder_output_data(decoder, data);
            valid++;
        }

        
        else if (message_type == ACURITE_MSGTYPE_5N1_WINDSPEED_WINDDIR_RAINFALL || message_type == ACURITE_MSGTYPE_5N1_WINDSPEED_TEMP_HUMIDITY || message_type == ACURITE_MSGTYPE_3N1_WINDSPEED_TEMP_HUMIDITY || message_type == ACURITE_MSGTYPE_RAINFALL) {


            decoder_log_bitrow(decoder, 1, __func__, bb, bitbuffer->bits_per_row[brow], "Acurite 5n1 raw msg");
            char const *channel_str = acurite_getChannel(bb[0]);

            
            
            
            sensor_id    = ((bb[0] & 0x0f) << 8) | bb[1];
            
            
            
            
            
            
            
            
            
            
            sequence_num = (bb[0] & 0x30) >> 4;
            battery_low = (bb[2] & 0x40) == 0;

            
            
            
            int speed_raw = ((bb[3] & 0x1F) << 3)| ((bb[4] & 0x70) >> 4);
            wind_speed_kph = 0;
            if (speed_raw > 0) {
                wind_speed_kph = speed_raw * 0.8278 + 1.0;
            }

            if (message_type == ACURITE_MSGTYPE_5N1_WINDSPEED_WINDDIR_RAINFALL) {
                
                wind_dir = acurite_5n1_winddirections[bb[4] & 0x0f] * 22.5f;

                
                raincounter = ((bb[5] & 0x7f) << 7) | (bb[6] & 0x7F);

                
                data = data_make( "model",        "",   DATA_STRING,    "Acurite-5n1", "message_type", NULL,   DATA_INT,       message_type, "id",           NULL, DATA_INT,       sensor_id, "channel",      NULL,   DATA_STRING,    channel_str, "sequence_num",  NULL,   DATA_INT,      sequence_num, "battery_ok",       "Battery",      DATA_INT,    !battery_low, "wind_avg_km_h",   "wind_speed",   DATA_FORMAT,    "%.1f km/h", DATA_DOUBLE,     wind_speed_kph, "wind_dir_deg", NULL,   DATA_FORMAT,    "%.1f", DATA_DOUBLE,    wind_dir, "rain_in",      "Rainfall Accumulation",   DATA_FORMAT, "%.2f in", DATA_DOUBLE, raincounter * 0.01f, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);










                

                decoder_output_data(decoder, data);
                valid++;
            }
            else if (message_type == ACURITE_MSGTYPE_5N1_WINDSPEED_TEMP_HUMIDITY) {
                

                
                int temp_raw = (bb[4] & 0x0F) << 7 | (bb[5] & 0x7F);
                tempf = (temp_raw - 400) * 0.1f;

                humidity = (bb[6] & 0x7f); 

                
                data = data_make( "model",        "",   DATA_STRING,    "Acurite-5n1", "message_type", NULL,   DATA_INT,       message_type, "id",           NULL, DATA_INT,  sensor_id, "channel",      NULL,   DATA_STRING,    channel_str, "sequence_num",  NULL,   DATA_INT,      sequence_num, "battery_ok",       "Battery",      DATA_INT,    !battery_low, "wind_avg_km_h",   "wind_speed",   DATA_FORMAT,    "%.1f km/h", DATA_DOUBLE,     wind_speed_kph, "temperature_F",     "temperature",    DATA_FORMAT,    "%.1f F", DATA_DOUBLE,    tempf, "humidity",     NULL,    DATA_FORMAT,    "%u %%",   DATA_INT,   humidity, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);










                

                decoder_output_data(decoder, data);
                valid++;
            }
            else if (message_type == ACURITE_MSGTYPE_3N1_WINDSPEED_TEMP_HUMIDITY) {
                
                sensor_id = ((bb[0] & 0x3f) << 8) | bb[1]; 
                humidity = (bb[3] & 0x7f); 

                
                int temp_raw = (bb[4] & 0x1F) << 7 | (bb[5] & 0x7F);
                tempf        = (temp_raw - 1480) * 0.1f; 

                wind_speed_mph = bb[6] & 0x7f; 

                
                data = data_make( "model",        "",   DATA_STRING,    "Acurite-3n1", "message_type", NULL,   DATA_INT,       message_type, "id",    NULL,   DATA_FORMAT,    "0x%02X",   DATA_INT,       sensor_id, "channel",      NULL,   DATA_STRING,    channel_str, "sequence_num",  NULL,   DATA_INT,      sequence_num, "battery_ok",       "Battery",      DATA_INT,    !battery_low, "wind_avg_mi_h",   "wind_speed",   DATA_FORMAT,    "%.1f mi/h", DATA_DOUBLE,     wind_speed_mph, "temperature_F",     "temperature",    DATA_FORMAT,    "%.1f F", DATA_DOUBLE,    tempf, "humidity",     NULL,    DATA_FORMAT,    "%u %%",   DATA_INT,   humidity, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);










                

                decoder_output_data(decoder, data);
                valid++;
            }
            else if (message_type == ACURITE_MSGTYPE_RAINFALL) {
                
                
                int channel = bb[0] >> 6;
                raincounter = ((bb[5] & 0x7f) << 7) | (bb[6] & 0x7f); 

                
                data = data_make( "model",            "",                         DATA_STRING, "Acurite-Rain899", "id",               "",                         DATA_INT,    sensor_id, "channel",          "",                         DATA_INT,    channel, "battery_ok",       "Battery",                  DATA_INT,    !battery_low, "rain_mm",          "Rainfall Accumulation",    DATA_FORMAT, "%.2f mm", DATA_DOUBLE, raincounter * 0.254, "mic",                  "Integrity",    DATA_STRING, "CHECKSUM", NULL);






                

                decoder_output_data(decoder, data);
                valid++;
            }
            else {
                decoder_logf(decoder, 2, __func__, "Acurite 5n1 sensor 0x%04X Ch %s, Status %02X, Unknown message type 0x%02x", sensor_id, channel_str, bb[3], message_type);
            }
        }

        else if (message_type == ACURITE_MSGTYPE_6045M) {
            
            valid += acurite_6045_decode(decoder, bitbuffer, brow);
        }

        else if ((message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_TEMP_HUM || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_RAIN || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_UV_LUX || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_TEMP_HUM_LTNG || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_RAIN_LTNG || message_type == ACURITE_MSGTYPE_ATLAS_WNDSPD_UV_LUX_LTNG)) {




            valid += acurite_atlas_decode(decoder, bitbuffer, brow);
        }
    }

    return valid;
}


static int acurite_986_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    int const browlen = 5;
    uint8_t *bb, sensor_num, status, crc, crcc;
    uint8_t br[8];
    int8_t tempf; 
    uint16_t sensor_id, valid_cnt = 0;
    char sensor_type;
    char *channel_str;
    int battery_low;
    data_t *data;

    int result = 0;

    for (uint16_t brow = 0; brow < bitbuffer->num_rows; ++brow) {

        decoder_logf(decoder, 2, __func__, "row %u bits %u, bytes %d", brow, bitbuffer->bits_per_row[brow], browlen);

        if (bitbuffer->bits_per_row[brow] < 39 || bitbuffer->bits_per_row[brow] > 43 ) {
            if (bitbuffer->bits_per_row[brow] > 16)
                decoder_log(decoder, 2, __func__,"skipping wrong len");
            result = DECODE_ABORT_LENGTH;
            continue; 
        }
        bb = bitbuffer->bb[brow];

        
        
        if ((bb[0] == 0xff && bb[1] == 0xff && bb[2] == 0xff) || (bb[0] == 0x00 && bb[1] == 0x00 && bb[2] == 0x00)) {
            result = DECODE_ABORT_EARLY;
            continue; 
        }

        
        for (int i = 0; i < browlen; i++)
            br[i] = reverse8(bb[i]);

        decoder_log_bitrow(decoder, 1, __func__, br, browlen * 8, "reversed");

        tempf = br[0];
        sensor_id = (br[1] << 8) + br[2];
        status = br[3];
        sensor_num = (status & 0x01) + 1;
        status = status >> 1;
        battery_low = ((status & 1) == 1);

        
        sensor_type = sensor_num == 2 ? 'F' : 'R';
        channel_str = sensor_num == 2 ? "2F" : "1R";

        crc = br[4];
        crcc = crc8le(br, 4, 0x07, 0);

        if (crcc != crc) {
            decoder_logf_bitrow(decoder, 2, __func__, br, browlen * 8, "bad CRC: %02x -", crc8le(br, 4, 0x07, 0));
            
            
            
            
            if (crcc == (crc | 0x80)) {
                decoder_logf(decoder, 2, __func__, "CRC fix %02x - %02x", crc, crcc);
            }
            else {
                continue; 
            }
        }

        if (tempf & 0x80) {
            tempf = (tempf & 0x7f) * -1;
        }

        decoder_logf(decoder, 1, __func__, "sensor 0x%04x - %d%c: %d F", sensor_id, sensor_num, sensor_type, tempf);

        
        data = data_make( "model",            "",             DATA_STRING, "Acurite-986", "id",               NULL,           DATA_INT,    sensor_id, "channel",          NULL,           DATA_STRING, channel_str, "battery_ok",       "Battery",      DATA_INT,    !battery_low, "temperature_F",    "temperature",  DATA_FORMAT, "%f F", DATA_DOUBLE,    (float)tempf, "status",           "status",       DATA_INT,    status, "mic",              "Integrity",    DATA_STRING, "CRC", NULL);







        

        decoder_output_data(decoder, data);

        valid_cnt++;
    }

    if (valid_cnt)
        return 1;

    return result;
}

static int acurite_606_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    data_t *data;
    uint8_t *b;
    int row;
    int16_t temp_raw; 
    float temp_c;     
    int battery_ok;   
    int sensor_id;    

    row = bitbuffer_find_repeated_row(bitbuffer, 3, 32); 
    if (row < 0)
        return DECODE_ABORT_EARLY;

    if (bitbuffer->bits_per_row[row] > 33)
        return DECODE_ABORT_LENGTH;

    b = bitbuffer->bb[row];

    if (b[4] != 0)
        return DECODE_FAIL_SANITY;

    
    if (b[0] == 0 && b[1] == 0 && b[2] == 0 && b[3] == 0)
        return DECODE_FAIL_SANITY;

    
    uint8_t chk = lfsr_digest8(b, 3, 0x98, 0xf1);
    if (chk != b[3])
        return DECODE_FAIL_MIC;

    
    
    
    sensor_id  = b[0];
    battery_ok = (b[1] & 0x80) >> 7;
    temp_raw   = (int16_t)((b[1] << 12) | (b[2] << 4));
    temp_raw   = temp_raw >> 4;
    temp_c     = temp_raw * 0.1f;

    
    data = data_make( "model",            "",             DATA_STRING, "Acurite-606TX", "id",               "",             DATA_INT, sensor_id, "battery_ok",       "Battery",      DATA_INT,    battery_ok, "temperature_C",    "Temperature",  DATA_FORMAT, "%.1f C", DATA_DOUBLE, temp_c, "mic",              "Integrity",    DATA_STRING, "CHECKSUM", NULL);





    

    decoder_output_data(decoder, data);
    return 1;
}

static int acurite_590tx_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    data_t *data;
    uint8_t *b;
    int row;
    int sensor_id;  
    int battery_ok; 
    int channel;
    int humidity;
    int temp_raw; 
    float temp_c; 

    row = bitbuffer_find_repeated_row(bitbuffer, 3, 25); 
    if (row < 0)
        return DECODE_ABORT_EARLY;

    if (bitbuffer->bits_per_row[row] > 25)
        return DECODE_ABORT_LENGTH;

    b = bitbuffer->bb[row];

    if (b[4] != 0) 
        return DECODE_FAIL_SANITY;

    
    if (b[0] == 0 && b[1] == 0 && b[2] == 0 && b[3] == 0)
        return DECODE_FAIL_SANITY;

    
    
    uint8_t parity = b[0]; 
    parity = (parity >> 4) ^ (parity & 0xF); 
    parity = (parity >> 2) ^ (parity & 0x3); 
    parity ^= b[1] >> 6; 
    parity = (parity >> 1) ^ (parity & 0x1); 

    if (!parity) {
        decoder_log(decoder, 1, __func__, "parity check failed");
        return DECODE_FAIL_MIC;
    }

    
    
    
    sensor_id = b[0] & 0xFE; 
    battery_ok = (b[0] & 0x01); 
    
    
    channel = (b[1] >> 4) & 0x03;

    temp_raw = (int16_t)(((b[1] & 0x0F) << 12) | (b[2] << 4));
    temp_raw = temp_raw >> 4;
    temp_c   = (temp_raw - 500) * 0.1f; 

    if (temp_raw >= 0 && temp_raw <= 100) 
        humidity = temp_raw;
    else humidity = -1;

    
     data = data_make( "model",            "",             DATA_STRING, "Acurite-590TX", "id",               "",             DATA_INT,    sensor_id, "battery_ok",       "Battery",      DATA_INT,    battery_ok, "channel",          "Channel",      DATA_INT,    channel, "humidity",         "Humidity",     DATA_COND,   humidity != -1,    DATA_INT,    humidity, "temperature_C",    "Temperature",  DATA_COND,   humidity == -1,    DATA_FORMAT, "%.1f C", DATA_DOUBLE, temp_c, "mic",              "Integrity",    DATA_STRING, "PARITY", NULL);







    

    decoder_output_data(decoder, data);
    return 1;
}

static int acurite_00275rm_decode(r_device *decoder, bitbuffer_t *bitbuffer)
{
    int result = 0;
    bitbuffer_invert(bitbuffer);

    
    uint8_t *b_rows[3] = {0};
    int n_rows         = 0;
    for (int row = 0; row < bitbuffer->num_rows; ++row) {
        if (n_rows < 3 && bitbuffer->bits_per_row[row] == 88) {
            b_rows[n_rows] = bitbuffer->bb[row];
            n_rows++;
        }
    }

    
    if (n_rows == 3) {
        uint8_t *b = bitbuffer->bb[bitbuffer->num_rows];
        for (int i = 0; i < 11; ++i) {
            
            b[i] = (b_rows[0][i] & b_rows[1][i]) | (b_rows[1][i] & b_rows[2][i]) | (b_rows[2][i] & b_rows[0][i]);

        }
        bitbuffer->bits_per_row[bitbuffer->num_rows] = 88;
        bitbuffer->num_rows += 1;
    }

    
    for (int row = 0; row < bitbuffer->num_rows; ++row) {
        if (bitbuffer->bits_per_row[row] != 88) {
            result = DECODE_ABORT_LENGTH;
            continue; 
        }
        uint8_t *b = bitbuffer->bb[row];

        
        if (crc16lsb(b, 11, 0x00b2, 0x00d0) != 0) {
            decoder_log_bitrow(decoder, 1, __func__, b, 11 * 8, "sensor bad CRC");
            result = DECODE_FAIL_MIC;
            continue; 
        }

        
        int id          = (b[0] << 16) | (b[1] << 8) | b[3];
        int battery_low = (b[2] & 0x40) == 0;
        int model_flag  = (b[2] & 1);
        float tempc     = ((b[4] << 4) | (b[5] >> 4)) * 0.1 - 100;
        int probe       = b[5] & 3;
        int humidity    = ((b[6] & 0x1f) << 2) | (b[7] >> 6);

        
        int water = (b[7] & 0x0f) == 15; 
        
        float ptempc = (((b[7] & 0x0f) << 8) | b[8]) * 0.1 - 100; 
        
        int phumidity = b[9] & 0x7f; 

        
        data_t *data = data_make( "model",            "",             DATA_STRING,    model_flag ? "Acurite-00275rm" : "Acurite-00276rm", "subtype",          "Probe",        DATA_INT,       probe, "id",               "",             DATA_INT,       id, "battery_ok",       "Battery",      DATA_INT,       !battery_low, "temperature_C",    "Celsius",      DATA_FORMAT,    "%.1f C",  DATA_DOUBLE, tempc, "humidity",         "Humidity",     DATA_FORMAT,    "%u %%", DATA_INT,      humidity, "water",            "",             DATA_COND, probe == 1, DATA_INT,        water, "temperature_1_C",  "Celsius",      DATA_COND, probe == 2, DATA_FORMAT, "%.1f C",   DATA_DOUBLE, ptempc, "temperature_1_C",  "Celsius",      DATA_COND, probe == 3, DATA_FORMAT, "%.1f C",   DATA_DOUBLE, ptempc, "humidity_1",       "Humidity",     DATA_COND, probe == 3, DATA_FORMAT, "%u %%",    DATA_INT,    phumidity, "mic",              "Integrity",    DATA_STRING,    "CRC", NULL);











        

        decoder_output_data(decoder, data);

        return 1;
    }
    
    return result;
}

static char *acurite_rain_gauge_output_fields[] = {
        "model", "id", "rain_mm", NULL, };




r_device acurite_rain_896 = {
        .name        = "Acurite 896 Rain Gauge", .modulation  = OOK_PULSE_PPM, .short_width = 1000, .long_width  = 2000, .gap_limit   = 3500, .reset_limit = 5000, .decode_fn   = &acurite_rain_896_decode, .disabled    = 1, .fields      = acurite_rain_gauge_output_fields, };









static char *acurite_th_output_fields[] = {
        "model", "id", "battery_ok", "temperature_C", "humidity", "status", "mic", NULL, };








r_device acurite_th = {
        .name        = "Acurite 609TXC Temperature and Humidity Sensor", .modulation  = OOK_PULSE_PPM, .short_width = 1000, .long_width  = 2000, .gap_limit   = 3000, .reset_limit = 10000, .decode_fn   = &acurite_th_decode, .fields      = acurite_th_output_fields, };









static char *acurite_txr_output_fields[] = {
        "model", "message_type", "id", "channel", "sequence_num", "battery_ok", "leak_detected", "temperature_C", "temperature_F", "humidity", "wind_avg_mi_h", "wind_avg_km_h", "wind_dir_deg", "rain_in", "rain_mm", "storm_dist", "strike_count", "strike_distance", "uv", "lux", "active", "exception", "raw_msg", "rfi", "mic", NULL, };


























r_device acurite_txr = {
        .name        = "Acurite 592TXR Temp/Humidity, 5n1 Weather Station, 6045 Lightning, 3N1, Atlas", .modulation  = OOK_PULSE_PWM, .short_width = 220, .long_width  = 408, .sync_width  = 620, .gap_limit   = 500, .reset_limit = 4000, .decode_fn   = &acurite_txr_decode, .fields      = acurite_txr_output_fields, };










static char *acurite_986_output_fields[] = {
        "model", "id", "channel", "battery_ok", "temperature_F", "status", "mic", NULL, };








r_device acurite_986 = {
        .name        = "Acurite 986 Refrigerator / Freezer Thermometer", .modulation  = OOK_PULSE_PPM, .short_width = 520, .long_width  = 880, .gap_limit   = 1280, .reset_limit = 4000, .decode_fn   = &acurite_986_decode, .fields      = acurite_986_output_fields, };










static char *acurite_606_output_fields[] = {
        "model", "id", "battery_ok", "temperature_C", "mic", NULL, };






static char *acurite_590_output_fields[] = {
        "model", "id", "battery_ok", "channel", "temperature_C", "humidity", "mic", NULL, };














r_device acurite_606 = {
        .name        = "Acurite 606TX Temperature Sensor", .modulation  = OOK_PULSE_PPM, .short_width = 2000, .long_width  = 4000, .gap_limit   = 7000, .reset_limit = 10000, .decode_fn   = &acurite_606_decode, .fields      = acurite_606_output_fields, };








static char *acurite_00275rm_output_fields[] = {
        "model", "subtype", "id", "battery_ok", "temperature_C", "humidity", "water", "temperature_1_C", "humidity_1", "mic", NULL, };











r_device acurite_00275rm = {
        .name        = "Acurite 00275rm,00276rm Temp/Humidity with optional probe", .modulation  = OOK_PULSE_PWM, .short_width = 232, .long_width  = 420, .gap_limit   = 520, .reset_limit = 708, .sync_width  = 632, .decode_fn   = &acurite_00275rm_decode, .fields      = acurite_00275rm_output_fields, };









r_device acurite_590tx = {
        .name        = "Acurite 590TX Temperature with optional Humidity", .modulation  = OOK_PULSE_PPM, .short_width = 500, .long_width  = 1500, .gap_limit   = 1484, .reset_limit = 3000, .sync_width  = 500, .decode_fn   = &acurite_590tx_decode, .fields      = acurite_590_output_fields, };








