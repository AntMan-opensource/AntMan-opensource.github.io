




namespace HPHP { namespace serialize {



enum class Type {
  NULLT, BOOL, DOUBLE, INT64, VECTOR, MAP, STRING, OBJECT, LIST, SET, };










struct FBSerializeBase {
  enum Code {
    FB_SERIALIZE_STOP    = 1, FB_SERIALIZE_BYTE    = 2, FB_SERIALIZE_I16     = 4, FB_SERIALIZE_I32     = 6, FB_SERIALIZE_I64     = 8, FB_SERIALIZE_STRING  = 9, FB_SERIALIZE_STRUCT  = 10, FB_SERIALIZE_NULL    = 14, FB_SERIALIZE_VARCHAR = 15, FB_SERIALIZE_DOUBLE  = 16, FB_SERIALIZE_BOOLEAN = 17, FB_SERIALIZE_VECTOR  = 18, FB_SERIALIZE_LIST    = 19, FB_SERIALIZE_SET     = 20, };














  static const size_t CODE_SIZE = 1;
  static const size_t BOOLEAN_SIZE = 1;
  static const size_t INT8_SIZE = 1;
  static const size_t INT16_SIZE = 2;
  static const size_t INT32_SIZE = 4;
  static const size_t INT64_SIZE = 8;
  static const size_t DOUBLE_SIZE = 8;
};

template <class V> struct FBSerializer : private FBSerializeBase {
  template <typename Variant> static size_t serializedSize(const Variant& thing);
  template <typename Variant> static void serialize(const Variant& thing, char* out);
 private:
  char* out_;
  explicit FBSerializer(char* out);

  void write(const char* src, size_t size);
  template <typename Variant> void doSerialize(const Variant& thing);
  void writeCode(Code code);
  void serializeBoolean(bool val);
  void serializeInt64(int64_t val);
  void serializeDouble(double val);
  template <typename String> void serializeString(const String& str);
  template <typename Map> void serializeMap(const Map& map, size_t depth);
  template <typename Vector> void serializeVector(const Vector& vec, size_t depth);
  template <typename Vector> void serializeList(const Vector& vec, size_t depth);
  template <typename Set> void serializeSet(const Set& set, size_t depth);
  template <typename Variant> void serializeThing(const Variant& thing, size_t depth);

  static size_t serializedSizeInt64(int64_t v);
  template <typename String> static size_t serializedSizeString(const String& v);
  template <typename Map> static size_t serializedSizeMap(const Map& v, size_t depth);
  template <typename Vector> static size_t serializedSizeVector(const Vector& v, size_t depth);
  template <typename Vector> static size_t serializedSizeList(const Vector& v, size_t depth);
  template <typename Set> static size_t serializedSizeSet(const Set& v, size_t depth);
  template <typename Variant> static size_t serializedSizeThing(const Variant& v, size_t depth);
};

template <class V> struct FBUnserializer : private FBSerializeBase {
  static typename V::VariantType unserialize(folly::StringPiece serialized);

  explicit FBUnserializer(folly::StringPiece serialized);

  bool unserializeBoolean();
  int64_t unserializeInt64();
  double unserializeDouble();
  typename V::StringType unserializeString();
  folly::StringPiece unserializeStringPiece();
  typename V::MapType unserializeMap();
  typename V::VectorType unserializeVector();
  typename V::VectorType unserializeList();
  typename V::SetType unserializeSet();
  
  
  folly::StringPiece getSerializedMap();
  typename V::VariantType unserializeThing();

  void advance(size_t delta);
  Code nextCode() const;
  bool done() const {
    return p_ == end_;
  }
 private:
  void need(size_t n) const;

  const char* p_;
  const char* end_;
};

}}




