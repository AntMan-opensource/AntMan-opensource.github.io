















static int _init(uev_ctx_t *ctx, int close_old)
{
	int fd;

	fd = epoll_create1(EPOLL_CLOEXEC);
	if (fd < 0)
		return -1;

	if (close_old)
		close(ctx->fd);

	ctx->fd = fd;

	return 0;
}


static int has_data(int fd)
{
	struct timeval timeout = { 0, 0 };
	fd_set fds;
	int n = 0;

	FD_ZERO(&fds);
	FD_SET(fd, &fds);

	if (select(1, &fds, NULL, NULL, &timeout) > 0)
		return ioctl(0, FIONREAD, &n) == 0 && n > 0;

	return 0;
}


int _uev_watcher_init(uev_ctx_t *ctx, uev_t *w, uev_type_t type, uev_cb_t *cb, void *arg, int fd, int events)
{
	if (!ctx || !w) {
		errno = EINVAL;
		return -1;
	}

	w->ctx    = ctx;
	w->type   = type;
	w->active = 0;
	w->fd     = fd;
	w->cb     = cb;
	w->arg    = arg;
	w->events = events;

	return 0;
}


int _uev_watcher_start(uev_t *w)
{
	struct epoll_event ev;

	if (!w || w->fd < 0 || !w->ctx) {
		errno = EINVAL;
		return -1;
	}

	if (_uev_watcher_active(w))
		return 0;

	ev.events   = w->events | EPOLLRDHUP;
	ev.data.ptr = w;
	if (epoll_ctl(w->ctx->fd, EPOLL_CTL_ADD, w->fd, &ev) < 0) {
		if (errno != EPERM)
			return -1;

		
		if (w->type != UEV_IO_TYPE || w->events != UEV_READ)
			return -1;

		
		if (w->fd != STDIN_FILENO)
			return -1;

		w->ctx->workaround = 1;
		w->active = -1;
	} else {
		w->active = 1;
	}

	
	_UEV_INSERT(w, w->ctx->watchers);

	return 0;
}


int _uev_watcher_stop(uev_t *w)
{
	if (!w) {
		errno = EINVAL;
		return -1;
	}

	if (!_uev_watcher_active(w))
		return 0;

	w->active = 0;

	
	_UEV_REMOVE(w, w->ctx->watchers);

	
	if (epoll_ctl(w->ctx->fd, EPOLL_CTL_DEL, w->fd, NULL) < 0)
		return -1;

	return 0;
}


int _uev_watcher_active(uev_t *w)
{
	if (!w)
		return 0;

	return w->active > 0;
}


int _uev_watcher_rearm(uev_t *w)
{
	struct epoll_event ev;

	if (!w || w->fd < 0) {
		errno = EINVAL;
		return -1;
	}

	ev.events   = w->events | EPOLLRDHUP;
	ev.data.ptr = w;
	if (epoll_ctl(w->ctx->fd, EPOLL_CTL_MOD, w->fd, &ev) < 0)
		return -1;

	return 0;
}


int uev_init(uev_ctx_t *ctx)
{
	return uev_init1(ctx, UEV_MAX_EVENTS);
}


int uev_init1(uev_ctx_t *ctx, int maxevents)
{
	if (!ctx || maxevents < 1) {
		errno = EINVAL;
		return -1;
	}

	memset(ctx, 0, sizeof(*ctx));
	ctx->maxevents = maxevents;

	return _init(ctx, 0);
}


int uev_exit(uev_ctx_t *ctx)
{
	uev_t *w;

	if (!ctx) {
		errno = EINVAL;
		return -1;
	}

	_UEV_FOREACH(w, ctx->watchers) {
		
		_UEV_REMOVE(w, ctx->watchers);

		if (!_uev_watcher_active(w))
			continue;

		switch (w->type) {
		case UEV_IO_TYPE:
			uev_io_stop(w);
			break;

		case UEV_SIGNAL_TYPE:
			uev_signal_stop(w);
			break;

		case UEV_TIMER_TYPE:
		case UEV_CRON_TYPE:
			uev_timer_stop(w);
			break;

		case UEV_EVENT_TYPE:
			uev_event_stop(w);
			break;
		}
	}

	ctx->watchers = NULL;
	ctx->running = 0;
	if (ctx->fd > -1)
		close(ctx->fd);
	ctx->fd = -1;

	return 0;
}


int uev_run(uev_ctx_t *ctx, int flags)
{
	int timeout = -1;
	uev_t *w;

        if (!ctx || ctx->fd < 0) {
		errno = EINVAL;
                return -1;
	}

	if (flags & UEV_NONBLOCK)
		timeout = 0;

	
	ctx->running = 1;

	
	_UEV_FOREACH(w, ctx->watchers) {
		if (UEV_CRON_TYPE == w->type)
			uev_cron_set(w, w->u.c.when, w->u.c.interval);
		if (UEV_TIMER_TYPE == w->type)
			uev_timer_set(w, w->u.t.timeout, w->u.t.period);
	}

	while (ctx->running && ctx->watchers) {
		struct epoll_event ee[UEV_MAX_EVENTS];
		int i, nfds, rerun = 0;

		
		if (ctx->workaround) {
			_UEV_FOREACH(w, ctx->watchers) {
				if (w->active != -1 || !w->cb)
					continue;

				if (!has_data(w->fd)) {
					w->active = 0;
					_UEV_REMOVE(w, ctx->watchers);
				}

				rerun++;
				w->cb(w, w->arg, UEV_READ);
			}
		}

		if (rerun)
			continue;
		ctx->workaround = 0;

		while ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents, timeout)) < 0) {
			if (!ctx->running)
				break;

			if (EINTR == errno)
				continue; 

			
			uev_exit(ctx);

			return -2;
		}

		for (i = 0; ctx->running && i < nfds; i++) {
			struct signalfd_siginfo fdsi;
			ssize_t sz = sizeof(fdsi);
			uint32_t events;
			uint64_t exp;

			w = (uev_t *)ee[i].data.ptr;
			events = ee[i].events;

			switch (w->type) {
			case UEV_IO_TYPE:
				if (events & (EPOLLHUP | EPOLLERR))
					uev_io_stop(w);
				break;

			case UEV_SIGNAL_TYPE:
				if (read(w->fd, &fdsi, sz) != sz) {
					if (uev_signal_start(w)) {
						uev_signal_stop(w);
						events = UEV_ERROR;
					}
					memset(&w->siginfo, 0, sizeof(w->siginfo));
				} else w->siginfo = fdsi;
				break;

			case UEV_TIMER_TYPE:
				if (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {
					uev_timer_stop(w);
					events = UEV_ERROR;
				}

				if (!w->u.t.period)
					w->u.t.timeout = 0;
				if (!w->u.t.timeout)
					uev_timer_stop(w);
				break;

			case UEV_CRON_TYPE:
				if (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {
					events = UEV_HUP;
					if (errno != ECANCELED) {
						uev_cron_stop(w);
						events = UEV_ERROR;
					}
				}

				if (!w->u.c.interval)
					w->u.c.when = 0;
				else w->u.c.when += w->u.c.interval;
				if (!w->u.c.when)
					uev_timer_stop(w);
				break;

			case UEV_EVENT_TYPE:
				if (read(w->fd, &exp, sizeof(exp)) != sizeof(exp))
					events = UEV_HUP;
				break;
			}

			
			if (w->cb)
				w->cb(w, w->arg, events & UEV_EVENT_MASK);
		}

		if (flags & UEV_ONCE)
			break;
	}

	return 0;
}


