


static char sccsid[] = "@(#)syslog.c	8.4 (Berkeley) 3/18/94";













static int LogType = SOCK_DGRAM;	
static int LogFile = -1;		
static bool connected;			
static int LogStat;			
static const char *LogTag;		
static int LogFacility = LOG_USER;	
static int LogMask = 0xff;		
extern char *__progname;		


__libc_lock_define_initialized (static, syslog_lock)
static void openlog_internal (const char *, int, int);
static void closelog_internal (void);

struct cleanup_arg {
  void *buf;
  struct sigaction *oldaction;
};

static void cancel_handler (void *ptr)
{
  
  struct cleanup_arg *clarg = (struct cleanup_arg *) ptr;

  if (clarg != NULL)
    
    free (clarg->buf);

  
  __libc_lock_unlock (syslog_lock);
}



void __syslog (int pri, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  __vsyslog_internal (pri, fmt, ap, 0);
  va_end (ap);
}
ldbl_hidden_def (__syslog, syslog)
ldbl_strong_alias (__syslog, syslog)

void __vsyslog (int pri, const char *fmt, va_list ap)
{
  __vsyslog_internal (pri, fmt, ap, 0);
}
ldbl_weak_alias (__vsyslog, vsyslog)

void ___syslog_chk (int pri, int flag, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  __vsyslog_internal (pri, fmt, ap, (flag > 0) ? PRINTF_FORTIFY : 0);
  va_end (ap);
}
ldbl_hidden_def (___syslog_chk, __syslog_chk)
ldbl_strong_alias (___syslog_chk, __syslog_chk)

void __vsyslog_chk (int pri, int flag, const char *fmt, va_list ap)
{
  __vsyslog_internal (pri, fmt, ap, (flag > 0) ? PRINTF_FORTIFY : 0);
}

void __vsyslog_internal (int pri, const char *fmt, va_list ap, unsigned int mode_flags)

{
  
  char bufs[1024];
  char *buf = bufs;
  size_t bufsize;

  int msgoff;
  int saved_errno = errno;


  
  if (pri & ~(LOG_PRIMASK | LOG_FACMASK))
    {
      syslog (INTERNALLOG, "syslog: unknown facility/priority: %x", pri);
      pri &= LOG_PRIMASK | LOG_FACMASK;
    }

  
  struct cleanup_arg clarg = { NULL, NULL };
  __libc_cleanup_push (cancel_handler, &clarg);
  __libc_lock_lock (syslog_lock);

  
  if ((LOG_MASK (LOG_PRI (pri)) & LogMask) == 0)
    goto out;

  
  if ((pri & LOG_FACMASK) == 0)
    pri |= LogFacility;

  pid_t pid = LogStat & LOG_PID ? __getpid () : 0;

  
  char timestamp[sizeof "MMM DD hh:mm:ss "];
  __time64_t now = time64_now ();
  struct tm now_tm;
  struct tm *now_tmp = __localtime64_r (&now, &now_tm);
  bool has_ts = now_tmp != NULL;

  
  if (has_ts)
    __strftime_l (timestamp, sizeof timestamp, "%h %e %T ", now_tmp, _nl_C_locobj_ptr);








  int l, vl;
  if (has_ts)
    l = __snprintf (bufs, sizeof bufs, SYSLOG_HEADER (pri, timestamp, &msgoff, pid));
  else l = __snprintf (bufs, sizeof bufs, SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));


  char *pos;
  size_t len;

  if (0 <= l && l < sizeof bufs)
    {
      
      pos = bufs + l;
      len = sizeof (bufs) - l;
    }
  else {
      buf = NULL;
      
      pos = bufs;
      len = sizeof (bufs);
    }

  {
    va_list apc;
    va_copy (apc, ap);

    
    __set_errno (saved_errno);

    vl = __vsnprintf_internal (pos, len, fmt, apc, mode_flags);

    if (!(0 <= vl && vl < len))
      buf = NULL;

    bufsize = l + vl;
    va_end (apc);
  }

  if (buf == NULL)
    {
      buf = malloc ((bufsize + 1) * sizeof (char));
      if (buf != NULL)
	{
	  
	  clarg.buf = buf;

	  if (has_ts)
	    __snprintf (buf, l + 1, SYSLOG_HEADER (pri, timestamp, &msgoff, pid));
	  else __snprintf (buf, l + 1, SYSLOG_HEADER_WITHOUT_TS (pri, &msgoff));


	  va_list apc;
	  va_copy (apc, ap);
	  __vsnprintf_internal (buf + l, bufsize - l + 1, fmt, apc, mode_flags);
	  va_end (apc);
	}
      else {
	  
          bufsize = __snprintf (bufs, sizeof bufs, "out of memory[%d]", __getpid ());
          buf = bufs;
        }
    }

  
  if (LogStat & LOG_PERROR)
    __dprintf (STDERR_FILENO, "%s%s", buf + msgoff, "\n" + (buf[bufsize - 1] == '\n'));

  
  if (!connected)
    openlog_internal (NULL, LogStat | LOG_NDELAY, LogFacility);

  
  if (LogType == SOCK_STREAM)
    ++bufsize;

  if (!connected || __send (LogFile, buf, bufsize, MSG_NOSIGNAL) < 0)
    {
      if (connected)
	{
	  
	  closelog_internal ();
	  openlog_internal (NULL, LogStat | LOG_NDELAY, LogFacility);
	}

      if (!connected || __send (LogFile, buf, bufsize, MSG_NOSIGNAL) < 0)
	{
	  closelog_internal ();	
	  
	  int fd;
	  if (LogStat & LOG_CONS && (fd = __open (_PATH_CONSOLE, O_WRONLY | O_NOCTTY | O_CLOEXEC, 0)) >= 0)

	    {
	      __dprintf (fd, "%s\r\n", buf + msgoff);
	      __close (fd);
	    }
	}
    }

out:
  
  __libc_cleanup_pop (0);
  __libc_lock_unlock (syslog_lock);

  if (buf != bufs)
    free (buf);
}


static const struct sockaddr_un SyslogAddr = {
    .sun_family = AF_UNIX, .sun_path = _PATH_LOG };


static void openlog_internal (const char *ident, int logstat, int logfac)
{
  if (ident != NULL)
    LogTag = ident;
  LogStat = logstat;
  if ((logfac & ~LOG_FACMASK) == 0)
    LogFacility = logfac;

  int retry = 0;
  while (retry < 2)
    {
      if (LogFile == -1)
	{
	  if (LogStat & LOG_NDELAY)
	    {
	      LogFile = __socket (AF_UNIX, LogType | SOCK_CLOEXEC, 0);
	      if (LogFile == -1)
		return;
	    }
	}
      if (LogFile != -1 && !connected)
	{
	  int old_errno = errno;
	  if (__connect (LogFile, &SyslogAddr, sizeof (SyslogAddr)) == -1)
	    {
	      int saved_errno = errno;
	      int fd = LogFile;
	      LogFile = -1;
	      __close (fd);
	      __set_errno (old_errno);
	      if (saved_errno == EPROTOTYPE)
		{
		  
		  LogType = LogType == SOCK_DGRAM ? SOCK_STREAM : SOCK_DGRAM;
		  ++retry;
		  continue;
		}
	    }
	  else connected = true;
	}
      break;
    }
}

void openlog (const char *ident, int logstat, int logfac)
{
  
  __libc_cleanup_push (cancel_handler, NULL);
  __libc_lock_lock (syslog_lock);

  openlog_internal (ident, logstat, logfac);

  __libc_cleanup_pop (1);
}

static void closelog_internal (void)
{
  if (!connected)
    return;

  __close (LogFile);
  LogFile = -1;
  connected = false;
}

void closelog (void)
{
  
  __libc_cleanup_push (cancel_handler, NULL);
  __libc_lock_lock (syslog_lock);

  closelog_internal ();
  LogTag = NULL;
  LogType = SOCK_DGRAM; 

  
  __libc_cleanup_pop (1);
}


int setlogmask (int pmask)
{
  int omask;

  
  __libc_lock_lock (syslog_lock);

  omask = LogMask;
  if (pmask != 0)
    LogMask = pmask;

  __libc_lock_unlock (syslog_lock);

  return (omask);
}
