





















extern struct uip_fallback_interface UIP_FALLBACK_INTERFACE;


process_event_t tcpip_event;

process_event_t tcpip_icmp6_event;



static struct etimer periodic;



extern struct etimer uip_reass_timer;




struct listenport {
  uint16_t port;
  struct process *p;
};

static struct internal_state {
  struct listenport listenports[UIP_LISTENPORTS];
  struct process *p;
} s;


enum {
  TCP_POLL, UDP_POLL, PACKET_INPUT };




static void init_appstate(uip_tcp_appstate_t *as, void *state)
{
  as->p = PROCESS_CURRENT();
  as->state = state;
}


uint8_t tcpip_output(const uip_lladdr_t *a)
{
  int ret;

  

  if(uipbuf_get_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS) != UIP_MAX_MAC_TRANSMISSIONS_UNDEFINED) {
    LOG_INFO("Tagging TC with retrans: %d\n", uipbuf_get_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS));
    
    UIP_IP_BUF->vtc = 0x60 | (UIP_TC_MAC_TRANSMISSION_COUNTER_BIT >> 4);
    UIP_IP_BUF->tcflow = uipbuf_get_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS) << 4;
  }


  if(netstack_process_ip_callback(NETSTACK_IP_OUTPUT, (const linkaddr_t *)a) == NETSTACK_IP_PROCESS) {
    ret = NETSTACK_NETWORK.output((const linkaddr_t *) a);
    return ret;
  } else {
    
    uipbuf_clear();
    return 0;
  }
}

PROCESS(tcpip_process, "TCP/IP stack");



static void start_periodic_tcp_timer(void)
{
  if(etimer_expired(&periodic)) {
    etimer_restart(&periodic);
  }
}


static void check_for_tcp_syn(void)
{

  

  if(UIP_IP_BUF->proto == UIP_PROTO_TCP && (UIP_TCP_BUF->flags & TCP_SYN) == TCP_SYN) {
    start_periodic_tcp_timer();
  }

}

static void packet_input(void)
{
  if(uip_len > 0) {
    LOG_INFO("input: received %u bytes\n", uip_len);

    check_for_tcp_syn();


    {
      uint8_t traffic_class = (UIP_IP_BUF->vtc << 4) | (UIP_IP_BUF->tcflow >> 4);
      if(traffic_class & UIP_TC_MAC_TRANSMISSION_COUNTER_BIT) {
        uint8_t max_mac_transmissions = traffic_class & UIP_TC_MAC_TRANSMISSION_COUNTER_MASK;
        uipbuf_set_attr(UIPBUF_ATTR_MAX_MAC_TRANSMISSIONS, max_mac_transmissions);
        LOG_INFO("Received packet tagged with TC retrans: %d (%x)", max_mac_transmissions, traffic_class);
      }
    }


    uip_input();
    if(uip_len > 0) {
      tcpip_ipv6_output();
    }
  }
}



struct uip_conn * tcp_connect(const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
  struct uip_conn *c;

  c = uip_connect(ripaddr, port);
  if(c == NULL) {
    return NULL;
  }

  init_appstate(&c->appstate, appstate);

  tcpip_poll_tcp(c);

  return c;
}


void tcp_unlisten(uint16_t port)
{
  unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    if(l->port == port && l->p == PROCESS_CURRENT()) {
      l->port = 0;
      uip_unlisten(port);
      break;
    }
    ++l;
  }
}

void tcp_listen(uint16_t port)
{
  unsigned char i;
  struct listenport *l;

  l = s.listenports;
  for(i = 0; i < UIP_LISTENPORTS; ++i) {
    if(l->port == 0) {
      l->port = port;
      l->p = PROCESS_CURRENT();
      uip_listen(port);
      break;
    }
    ++l;
  }
}

void tcp_attach(struct uip_conn *conn, void *appstate)
{
  init_appstate(&conn->appstate, appstate);
}



void udp_attach(struct uip_udp_conn *conn, void *appstate)
{
  init_appstate(&conn->appstate, appstate);
}

struct uip_udp_conn * udp_new(const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)
{
  struct uip_udp_conn *c = uip_udp_new(ripaddr, port);

  if(c == NULL) {
    return NULL;
  }

  init_appstate(&c->appstate, appstate);

  return c;
}

struct uip_udp_conn * udp_broadcast_new(uint16_t port, void *appstate)
{
  uip_ipaddr_t addr;
  struct uip_udp_conn *conn;

  uip_create_linklocal_allnodes_mcast(&addr);

  conn = udp_new(&addr, port, appstate);
  if(conn != NULL) {
    udp_bind(conn, port);
  }
  return conn;
}



uint8_t icmp6_new(void *appstate) {
  if(uip_icmp6_conns.appstate.p == PROCESS_NONE) {
    init_appstate(&uip_icmp6_conns.appstate, appstate);
    return 0;
  }
  return 1;
}

void tcpip_icmp6_call(uint8_t type)
{
  if(uip_icmp6_conns.appstate.p != PROCESS_NONE) {
    
    process_post_synch(uip_icmp6_conns.appstate.p, tcpip_icmp6_event, &type);
  }
  return;
}


static void eventhandler(process_event_t ev, process_data_t data)
{

  unsigned char i;
  register struct listenport *l;

  struct process *p;

  switch(ev) {
  case PROCESS_EVENT_EXITED:
    

    p = (struct process *)data;

    l = s.listenports;
    for(i = 0; i < UIP_LISTENPORTS; ++i) {
      if(l->p == p) {
        uip_unlisten(l->port);
        l->port = 0;
        l->p = PROCESS_NONE;
      }
      ++l;
    }

    {
      struct uip_conn *cptr;

      for(cptr = &uip_conns[0]; cptr < &uip_conns[UIP_TCP_CONNS]; ++cptr) {
        if(cptr->appstate.p == p) {
          cptr->appstate.p = PROCESS_NONE;
          cptr->tcpstateflags = UIP_CLOSED;
        }
      }
    }


    {
      struct uip_udp_conn *cptr;

      for(cptr = &uip_udp_conns[0];
          cptr < &uip_udp_conns[UIP_UDP_CONNS]; ++cptr) {
        if(cptr->appstate.p == p) {
          cptr->lport = 0;
        }
      }
    }

    break;

  case PROCESS_EVENT_TIMER:
    
  {
    
    if(data == &periodic && etimer_expired(&periodic)) {

      for(i = 0; i < UIP_TCP_CONNS; ++i) {
        if(uip_conn_active(i)) {
          
          etimer_restart(&periodic);
          uip_periodic(i);
          tcpip_ipv6_output();
        }
      }

    }


    
    if(data == &uip_reass_timer && etimer_expired(&uip_reass_timer)) {
      uip_reass_over();
      tcpip_ipv6_output();
    }

    
    

    if(data == &uip_ds6_timer_rs && etimer_expired(&uip_ds6_timer_rs)) {
      uip_ds6_send_rs();
      tcpip_ipv6_output();
    }

    if(data == &uip_ds6_timer_periodic && etimer_expired(&uip_ds6_timer_periodic)) {
      uip_ds6_periodic();
      tcpip_ipv6_output();
    }
  }
  break;


  case TCP_POLL:
    if(data != NULL) {
      uip_poll_conn(data);
      tcpip_ipv6_output();
      
      start_periodic_tcp_timer();
    }
    break;


  case UDP_POLL:
    if(data != NULL) {
      uip_udp_periodic_conn(data);
      tcpip_ipv6_output();
    }
    break;


  case PACKET_INPUT:
    packet_input();
    break;
  };
}

void tcpip_input(void)
{
  if(netstack_process_ip_callback(NETSTACK_IP_INPUT, NULL) == NETSTACK_IP_PROCESS) {
    process_post_synch(&tcpip_process, PACKET_INPUT, NULL);
  } 
  uipbuf_clear();
}

static void output_fallback(void)
{

  uip_last_proto = *((uint8_t *)UIP_IP_BUF + 40);
  LOG_INFO("fallback: removing ext hdrs & setting proto %d %d\n", uip_ext_len, uip_last_proto);
  uip_remove_ext_hdr();
  
  if(UIP_FALLBACK_INTERFACE.output() < 0) {
    LOG_ERR("fallback: output error. Reporting DST UNREACH\n");
    uip_icmp6_error_output(ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADDR, 0);
    uip_flags = 0;
    tcpip_ipv6_output();
    return;
  }

  LOG_ERR("output: destination off-link and no default route\n");

}

static void annotate_transmission(const uip_ipaddr_t *nexthop)
{

  static uint8_t annotate_last;
  static uint8_t annotate_has_last = 0;

  if(annotate_has_last) {
    printf("#L %u 0; red\n", annotate_last);
  }
  printf("#L %u 1; red\n", nexthop->u8[sizeof(uip_ipaddr_t) - 1]);
  annotate_last = nexthop->u8[sizeof(uip_ipaddr_t) - 1];
  annotate_has_last = 1;

}

static const uip_ipaddr_t* get_nexthop(uip_ipaddr_t *addr)
{
  const uip_ipaddr_t *nexthop;
  uip_ds6_route_t *route;

  LOG_INFO("output: processing %u bytes packet from ", uip_len);
  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
  LOG_INFO_(" to ");
  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
  LOG_INFO_("\n");

  if(NETSTACK_ROUTING.ext_header_srh_get_next_hop(addr)) {
    LOG_INFO("output: selected next hop from SRH: ");
    LOG_INFO_6ADDR(addr);
    LOG_INFO_("\n");
    return addr;
  }

  
  if(uip_ds6_is_addr_onlink(&UIP_IP_BUF->destipaddr)) {
    LOG_INFO("output: destination is on link\n");
    return &UIP_IP_BUF->destipaddr;
  }

  
  route = uip_ds6_route_lookup(&UIP_IP_BUF->destipaddr);

  
  if(route == NULL) {
    nexthop = uip_ds6_defrt_choose();
    if(nexthop == NULL) {
      output_fallback();
    } else {
      LOG_INFO("output: no route found, using default route: ");
      LOG_INFO_6ADDR(nexthop);
      LOG_INFO_("\n");
    }

  } else {
    
    nexthop = uip_ds6_route_nexthop(route);

    
    if(nexthop == NULL) {
      LOG_ERR("output: found dead route\n");
      
      NETSTACK_ROUTING.drop_route(route);
      
      uip_ds6_route_rm(route);
      
    } else {
      LOG_INFO("output: found next hop from routing table: ");
      LOG_INFO_6ADDR(nexthop);
      LOG_INFO_("\n");
    }
  }

  return nexthop;
}


static int queue_packet(uip_ds6_nbr_t *nbr)
{
  

  if(uip_packetqueue_alloc(&nbr->packethandle, UIP_DS6_NBR_PACKET_LIFETIME) != NULL) {
    memcpy(uip_packetqueue_buf(&nbr->packethandle), UIP_IP_BUF, uip_len);
    uip_packetqueue_set_buflen(&nbr->packethandle, uip_len);
    return 0;
  }


  return 1;
}


static void send_queued(uip_ds6_nbr_t *nbr)
{

  
  if(uip_packetqueue_buflen(&nbr->packethandle) != 0) {
    uip_len = uip_packetqueue_buflen(&nbr->packethandle);
    memcpy(UIP_IP_BUF, uip_packetqueue_buf(&nbr->packethandle), uip_len);
    uip_packetqueue_free(&nbr->packethandle);
    tcpip_output(uip_ds6_nbr_get_ll(nbr));
  }

}

static int send_nd6_ns(const uip_ipaddr_t *nexthop)
{
  int err = 1;


   uip_ds6_nbr_t *nbr = NULL;
  if((nbr = uip_ds6_nbr_add(nexthop, NULL, 0, NBR_INCOMPLETE, NBR_TABLE_REASON_IPV6_ND, NULL)) != NULL) {
    err = 0;

    queue_packet(nbr);
  
   if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)){
      uip_nd6_ns_output(&UIP_IP_BUF->srcipaddr, NULL, &nbr->ipaddr);
    } else {
      uip_nd6_ns_output(NULL, NULL, &nbr->ipaddr);
    }

    stimer_set(&nbr->sendns, uip_ds6_if.retrans_timer / 1000);
    nbr->nscount = 1;
    
  }

  LOG_ERR("output: neighbor not in cache: ");
  LOG_ERR_6ADDR(nexthop);
  LOG_ERR_("\n");


  return err;
}

void tcpip_ipv6_output(void)
{
  uip_ipaddr_t ipaddr;
  uip_ds6_nbr_t *nbr = NULL;
  const uip_lladdr_t *linkaddr;
  const uip_ipaddr_t *nexthop;

  if(uip_len == 0) {
    return;
  }

  if(uip_len > UIP_LINK_MTU) {
    LOG_ERR("output: Packet too big");
    goto exit;
  }

  if(uip_is_addr_unspecified(&UIP_IP_BUF->destipaddr)){
    LOG_ERR("output: Destination address unspecified");
    goto exit;
  }


  if(!NETSTACK_ROUTING.ext_header_update()) {
    
    LOG_ERR("output: routing protocol extension header update error\n");
    uipbuf_clear();
    return;
  }

  if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    linkaddr = NULL;
    goto send_packet;
  }

  
  if(uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr)) {
    LOG_INFO("output: sending to ourself\n");
    packet_input();
    return;
  }

  
  if((nexthop = get_nexthop(&ipaddr)) == NULL) {
    LOG_WARN("output: No next-hop found, dropping packet\n");
    goto exit;
  }
  annotate_transmission(nexthop);

  nbr = uip_ds6_nbr_lookup(nexthop);


  if(nbr == NULL) {
    
    uip_lladdr_t lladdr;
    uip_ds6_set_lladdr_from_iid(&lladdr, nexthop);
    if((nbr = uip_ds6_nbr_add(nexthop, &lladdr, 0, NBR_REACHABLE, NBR_TABLE_REASON_IPV6_ND_AUTOFILL, NULL)) == NULL) {
      LOG_ERR("output: failed to autofill neighbor cache for host ");
      LOG_ERR_6ADDR(nexthop);
      LOG_ERR_(", link-layer addr ");
      LOG_ERR_LLADDR((linkaddr_t*)&lladdr);
      LOG_ERR_("\n");
      goto exit;
    }
   }


  if(nbr == NULL) {
    if(send_nd6_ns(nexthop)) {
      LOG_ERR("output: failed to add neighbor to cache\n");
      goto exit;
    } else {
      
      goto send_packet;
    }
  }


  if(nbr->state == NBR_INCOMPLETE) {
    LOG_ERR("output: nbr cache entry incomplete\n");
    queue_packet(nbr);
    goto exit;
  }
  
  if(nbr->state == NBR_STALE) {
    nbr->state = NBR_DELAY;
    stimer_set(&nbr->reachable, UIP_ND6_DELAY_FIRST_PROBE_TIME);
    nbr->nscount = 0;
    LOG_INFO("output: nbr cache entry stale moving to delay\n");
  }


send_packet:
  if(nbr) {
    linkaddr = uip_ds6_nbr_get_ll(nbr);
  } else {
    linkaddr = NULL;
  }

  LOG_INFO("output: sending to ");
  LOG_INFO_LLADDR((linkaddr_t *)linkaddr);
  LOG_INFO_("\n");
  tcpip_output(linkaddr);

  if(nbr) {
    send_queued(nbr);
  }

exit:
  uipbuf_clear();
  return;
}


void tcpip_poll_udp(struct uip_udp_conn *conn)
{
  process_post(&tcpip_process, UDP_POLL, conn);
}



void tcpip_poll_tcp(struct uip_conn *conn)
{
  process_post(&tcpip_process, TCP_POLL, conn);
}


void tcpip_uipcall(void)
{
  uip_udp_appstate_t *ts;


  if(uip_conn != NULL) {
    ts = &uip_conn->appstate;
  } else {
    ts = &uip_udp_conn->appstate;
  }

  ts = &uip_conn->appstate;



  {
    unsigned char i;
    struct listenport *l;

    
    if(uip_connected()) {
      l = &s.listenports[0];
      for(i = 0; i < UIP_LISTENPORTS; ++i) {
        if(l->port == uip_conn->lport && l->p != PROCESS_NONE) {
          ts->p = l->p;
          ts->state = NULL;
          break;
        }
        ++l;
      }

      
      start_periodic_tcp_timer();
    }
  }


  if(ts->p != NULL) {
    process_post_synch(ts->p, tcpip_event, ts->state);
  }
}

PROCESS_THREAD(tcpip_process, ev, data)
{
  PROCESS_BEGIN();


  memset(s.listenports, 0, UIP_LISTENPORTS*sizeof(*(s.listenports)));
  s.p = PROCESS_CURRENT();


  tcpip_event = process_alloc_event();

  tcpip_icmp6_event = process_alloc_event();

  etimer_set(&periodic, CLOCK_SECOND / 2);

  uip_init();

  UIP_FALLBACK_INTERFACE.init();

  
  NETSTACK_ROUTING.init();

  while(1) {
    PROCESS_YIELD();
    eventhandler(ev, data);
  }

  PROCESS_END();
}

