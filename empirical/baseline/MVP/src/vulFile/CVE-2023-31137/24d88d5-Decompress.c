













rrdesc **rr_formats;


int dlog_level = -1; 



int decomp_message(char *message, int min_log_level) {
    if(dlog_level >= min_log_level) {
        show_timestamp();
        printf("%s\n",message);
        }
    return JS_SUCCESS;
    }



js_string *decomp_get_label(js_string *compressed, unsigned int compressed_offset) {
    js_string *ret; 
    int counter, cplace, cplace_save, dplace, limit;

    decomp_message("Performing sanity checks on compressed string...",5);

    
    if(compressed == 0)
        return 0;
    if(compressed->unit_size != 1)
        return 0;
    if(compressed->unit_count > compressed->max_count)
        return 0;
    if(compressed_offset > compressed->unit_count)
        return 0;

    decomp_message("Compressed string is sane.  Initializing variables...",5);

    
    cplace = compressed_offset;
    cplace_save = cplace;
    dplace = 0;
    counter = 0;
    limit = 0;
    if((ret = js_create(MAX_DLABEL_LEN + 3,1)) == 0)
        return 0;

    decomp_message("Variables initalized.",5);

    
    do {
        if(cplace >= compressed->unit_count) {
            js_destroy(ret);
            return 0;
        }
        limit++;
        counter = *(compressed->string + cplace);
        
        if(counter > 63 && counter < 0xC0) {
            decomp_message("Invalid length value in compressed string",4);
            js_destroy(ret);
            return 0;
            }
        else if(counter >= 0xC0) { 
            
            if(cplace + 1 >= compressed->unit_count) {
                decomp_message("Compression pointer isn't fitting",4);
                js_destroy(ret);
                return 0;
                }
            
            cplace_save = cplace;
            cplace = ((counter & 0x3F) << 8);
            cplace |= *(compressed->string + cplace_save + 1);
            
            if(cplace >= cplace_save) {
                decomp_message("Compressed pointer goes forward",4);
                js_destroy(ret);
                return 0;
                }
            
            if(cplace < 12) {
                decomp_message("Compressed pointer points to header",4);
                js_destroy(ret);
                return 0;
                }
            }
        
        else if(counter > 0 && counter <= 63) {
            counter++;
            if(dplace + counter >= ret->max_count) {
                decomp_message("Pointing past end of ret string",4);
                js_destroy(ret);
                return 0;
                }
            if(cplace + counter >= compressed->unit_count) {
                decomp_message("Pointing past end of compressed string",4);
                js_destroy(ret);
                return 0;
                }
            while(counter > 0) {
                *(ret->string + dplace) = *(compressed->string + cplace);
                ret->unit_count++;
                dplace++;
                cplace++;
                counter--;
                }
            counter = 100; 
            }
        else if(counter == 0) {
            if(dplace + counter >= ret->max_count) {
                decomp_message("Pointing past end of the compressed string",4);
                js_destroy(ret);
                return 0;
                }
            *(ret->string + dplace) = 0;
            ret->unit_count++;
            }
        else { 
            decomp_message("This, folks, should never happen",4);
            js_destroy(ret);
            return 0;
            }
        } while(counter > 0 && limit < 256);

    if(limit >= 256) {
        decomp_message("Limit exceeded when decompressing dlabel",4);
        js_destroy(ret);
        return 0;
        }

    
    
    return ret;
    }



int decomp_append_dlabel(js_string *compressed, js_string *uncompressed, unsigned int compressed_offset) {

    js_string *dlabel;
    int length = 0;

    
    if(js_has_sanity(compressed) != JS_SUCCESS) {
        return JS_ERROR;
        }
    if(js_has_sanity(uncompressed) != JS_SUCCESS) {
        return JS_ERROR;
        }
     if(compressed->unit_size != 1) {
        return JS_ERROR;
        }
     if(uncompressed->unit_size != 1) {
        return JS_ERROR;
        }
     if(compressed_offset >= compressed->unit_count) {
        return JS_ERROR;
        }

    
    dlabel = decomp_get_label(compressed, compressed_offset);
    if(dlabel == 0) {
        return JS_ERROR;
        }
    length = dlabel_length(compressed,compressed_offset);
    if(length == JS_ERROR) {
        js_destroy(dlabel);
        return JS_ERROR;
        }

    
    if(js_append(dlabel,uncompressed) == JS_ERROR) {
        js_destroy(dlabel);
        return JS_ERROR;
        }

    
    js_destroy(dlabel);
    return length;
    }



int decomp_append_bytes(js_string *compressed, js_string *uncompressed, unsigned int compressed_offset, int length) {

    js_string *temp;
    if((temp = js_create(length + 2,1)) == 0) {
        return JS_ERROR;
        }

    if(compressed->unit_count < compressed_offset + length) {
        js_destroy(temp);
        return JS_ERROR;
        }

    if(js_substr(compressed,temp,compressed_offset,length) != JS_SUCCESS) {
        js_destroy(temp);
        return JS_ERROR;
        }

    if(js_append(temp,uncompressed) == JS_ERROR) {
        js_destroy(temp);
        return JS_ERROR;
        }

    js_destroy(temp);
    return JS_SUCCESS;
    }



int decomp_get_type_etc(js_string *compressed, js_string *uncompressed, unsigned int compressed_offset) {

    int type;

    type = js_readuint16(compressed,compressed_offset);

    if(decomp_append_bytes(compressed,uncompressed,compressed_offset,8) != JS_SUCCESS) {
        return JS_ERROR;
        }

    return type;

    }



int decomp_get_rdlength(js_string *compressed, unsigned int compressed_offset) {

    int rdlength;

    rdlength = js_readuint16(compressed,compressed_offset);

    return rdlength;

    }



int decomp_get_header(js_string *compressed, js_string *uncompressed) {
    int qdcount, ancount, nscount, arcount, total;

    
    if(js_has_sanity(compressed) == JS_ERROR) {
        return JS_ERROR;
        }
    if(js_has_sanity(uncompressed) == JS_ERROR) {
        return JS_ERROR;
        }
    if(compressed->unit_count < 12) {
        return JS_ERROR;
        }
    if(uncompressed->unit_count != 0) {
        return JS_ERROR;
        }

    
    qdcount = js_readuint16(compressed,4);
    if(qdcount < 0 || qdcount > 1)
        return JS_ERROR;

    
    ancount = js_readuint16(compressed,6);
    if(ancount < 0 || ancount > 65535)
        return JS_ERROR;
    nscount = js_readuint16(compressed,8);
    if(nscount < 0 || nscount > 65535)
        return JS_ERROR;
    arcount = js_readuint16(compressed,10);
    if(arcount < 0 || arcount > 65535)
        return JS_ERROR;

    total = ancount + nscount + arcount;

    
    if(decomp_append_bytes(compressed,uncompressed,0,12) != JS_SUCCESS)
        return JS_ERROR;

    
    if(qdcount == 0 && total >= 1)
        return -2 - total;

    
    if(qdcount == 0)
        return -2;

    return total;

    }



int decomp_get_question(js_string *compressed, js_string *uncompressed) {
    int length;

    
    if(compressed->unit_count < 12) {
        return JS_ERROR;
        }

    if(uncompressed->unit_count != 12) {
        return JS_ERROR;
        }

    
    length = decomp_append_dlabel(compressed,uncompressed,12);
    if(length < 1) {
        return JS_ERROR;
        }

    
    if(decomp_append_bytes(compressed,uncompressed,12 + length,4)
       != JS_SUCCESS) {
        return JS_ERROR;
        }

    length += 4;

    return length;

    }



int decomp_init_rrdesc() {
    int counter;

    if((rr_formats = js_alloc(RR_HASH_SIZE,sizeof(rrdesc *))) == 0)
        return JS_ERROR;

    
    for(counter = 0; counter < RR_HASH_SIZE; counter++)
        rr_formats[counter] = 0;

    return JS_SUCCESS;

    }



int decomp_add_rrdesc(js_string *desc) {
    int rtype, place, counter, fieldnum, subfieldnum;
    unsigned char c;
    rrdesc *new, *point;

    
    if(js_has_sanity(desc) != JS_SUCCESS)
        return JS_ERROR;
    js_set_encode(desc,JS_US_ASCII); 

    
    if((new = js_alloc(1,sizeof(rrdesc))) == 0) {
        return JS_ERROR;
        }

    
    if((new->description = js_alloc(MAX_RR_SECTIONS,1)) == 0) {
        js_dealloc(new);
        return JS_ERROR;
        }
    
    for(counter = 0; counter < MAX_RR_SECTIONS - 1; counter++) {
        new->description[counter] = 0;
        }

    
    new->tocompress = 79;

    
    fieldnum = subfieldnum = 1;
    rtype = -1;
    for(counter = 0; counter < desc->unit_count ; counter++) {
        c = *(desc->string + counter);
        if(fieldnum == 1) { 
            if(subfieldnum == 1)  {
                if(c == ':') {
                    subfieldnum++;
                    }
                }
            else if(subfieldnum == 2)  {
                if(rtype == -1) {
                    rtype = js_atoi(desc,counter);
                    if(rtype <= 0 || rtype > 65535) {
                        js_dealloc(new->description);
                        js_dealloc(new);
                        return JS_ERROR;
                        }
                    new->rr_num = rtype;
                    }
                if(c == '|') {
                    subfieldnum = 1;
                    fieldnum = 2;
                    }
                }
            }
        else if(fieldnum == 2) { 
            if(c == '|') {
                subfieldnum = 1;
                fieldnum = 3;
                }
            }
        else if(fieldnum == 3) { 
            
            if(subfieldnum > MAX_RR_SECTIONS - 2) {
                js_dealloc(new->description);
                js_dealloc(new);
                return JS_ERROR;
                }
            
            if(new->description[subfieldnum - 1] == 0) {
                if(c >= '1' && c <= '9') {
                    new->description[subfieldnum - 1] = c - '0';
                    }
                else if(c == 'D') {
                    new->description[subfieldnum - 1] = RRSUB_DLABEL;
                    }
                else if(c == 'T') {
                    new->description[subfieldnum - 1] = RRSUB_TEXT;
                    }
                else if(c == 'V') {
                    new->description[subfieldnum - 1] = RRSUB_VARIABLE;
                    }
                else { 
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                }
             else if(c != ';' && c != '|') { 
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             else if(c == ';') {
                 
                 if(new->description[subfieldnum - 1] == RRSUB_VARIABLE) {
                    js_dealloc(new->description);
                    js_dealloc(new);
                    return JS_ERROR;
                    }
                 subfieldnum++;
                 }
             else if(c == '|') {
                 subfieldnum = 1;
                 fieldnum = 4;
                 }
             else { 
                 js_dealloc(new->description);
                 js_dealloc(new);
                 return JS_ERROR;
                 }
             }
         else if(fieldnum == 4) { 
             if(c == 'C' && new->tocompress == 79) {
                new->tocompress = 1;
                }
             else if(c == 'N' && new->tocompress == 79) {
                new->tocompress = 0;
                }
             else if(c == '|' && new->tocompress != 79) {
                subfieldnum = 1;
                fieldnum = 5;
                }
             else { 
                js_dealloc(new->description);
                js_dealloc(new);
                return -4;
                }
             }
         else if(fieldnum == 5) { 
             
             break;
             }
         }

     

     place = rtype % RR_HASH_SIZE;
     if(rr_formats == 0) {
        js_dealloc(new->description);
        js_dealloc(new);
        return JS_ERROR;
        }
     point = rr_formats[place];
     if(point == 0) {
         rr_formats[place] = new;
         }
     else {
         while(point->next != 0)
             point = point->next;
         point->next = new;
         }

     new->next = 0;

     
     return JS_SUCCESS;
     }



int decomp_init(int alog_level) {
    js_string *temp; 
    int counter;

    
    if((temp = js_create(256,1)) == 0) {
        return JS_ERROR;
        }

    
    decomp_init_rrdesc();
    for(counter = 0 ; counter < RR_COUNT ; counter++) {
        if(js_qstr2js(temp,rr_descs[counter]) != JS_SUCCESS) {
            js_destroy(temp);
            return JS_ERROR;
            }
        if(decomp_add_rrdesc(temp) != JS_SUCCESS) {
            js_destroy(temp);
            return JS_ERROR;
            }
        }

    
    dlog_level = alog_level;

    js_destroy(temp);
    return JS_SUCCESS;

    }



char *decomp_get_rrdesc(int rr_num) {
    rrdesc *point;

    if(rr_formats == 0)
        return 0;

    point = rr_formats[rr_num % RR_HASH_SIZE];
    if(point == 0)
        return 0;

    while(point->rr_num != rr_num) {
        point = point->next;
        if(point == 0)
            return 0;
        }

    return point->description;

    }



int decomp_get_rddata(js_string *compressed, js_string *out, unsigned int compressed_offset, int type, int rdlength) {

    char *desc;
    int subtype, total, len;

    desc = decomp_get_rrdesc(type);

    if(desc == 0) { 
        if(rdlength == 0) {
            return JS_SUCCESS;
            }
        if(decomp_append_bytes(compressed,out,compressed_offset, rdlength) != JS_SUCCESS) {
            return JS_ERROR;
            }
        else {
            return JS_SUCCESS;
            }
        }
    else {
        subtype = *desc;
        total = 0;
        
        while(subtype != 0) {
            
            if(subtype > 0 && subtype < 64) {
                if(decomp_append_bytes(compressed,out, compressed_offset,subtype) != JS_SUCCESS) {
                       return JS_ERROR;
                       }
                total += subtype;
                compressed_offset += subtype;
                }
            
            else if(subtype == RRSUB_DLABEL) {
                len = decomp_append_dlabel(compressed,out, compressed_offset);
                if(len == JS_ERROR) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            
            else if(subtype == RRSUB_TEXT) {
                
                len = *(compressed->string + compressed_offset);
                len += 1; 
                if(len < 0 || len > 256) {
                    return JS_ERROR;
                    }
                if(decomp_append_bytes(compressed,out, compressed_offset,len) != JS_SUCCESS) {

                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            
            else if(subtype == RRSUB_VARIABLE) {
                len = rdlength - total;
                if(len == 0) {
                    break;
                    }
                if(decomp_append_bytes(compressed,out, compressed_offset,len) != JS_SUCCESS) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            else { 
                return JS_ERROR;
                }
            desc++;
            
            if(subtype != RRSUB_VARIABLE)
                subtype = *desc;
            else subtype = 0;
            }
        
        if(rdlength != total) {
            return JS_ERROR;
            }
        }

    
    return JS_SUCCESS;
    }



int decomp_decompress_packet(js_string *compressed, js_string *uncompressed) {

    int answers; 
    int type, rdlength; 
    int offset,length;
    js_string *rddata;

    

    if(js_has_sanity(compressed) == JS_ERROR)
        return JS_ERROR;
    if(js_has_sanity(uncompressed) == JS_ERROR)
        return JS_ERROR;
    if(compressed->unit_size != 1 || uncompressed->unit_size != 1)
        return JS_ERROR;
    if(uncompressed->unit_count != 0)
        return JS_ERROR;

    

    if((rddata = js_create(512,1)) == 0) {
        return JS_ERROR;
        }

    if((rddata = js_create(4512,1)) == 0) {
        return JS_ERROR;
        }

    

    answers = decomp_get_header(compressed,uncompressed);
    if(answers == -2) { 
        js_destroy(rddata);
        return JS_SUCCESS;
        }
    else if(answers == JS_ERROR) {
        js_destroy(rddata);
        return JS_ERROR;
        }

    
    if(answers <= -3) {
        answers = -2 - answers; 
        length = 0;
        }
    else {
        length = decomp_get_question(compressed,uncompressed);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        }

    offset = 12 + length;

    
    while(answers > 0) {
        length = decomp_append_dlabel(compressed,uncompressed,offset);
        if(length < 1) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += length;
        type = decomp_get_type_etc(compressed,uncompressed,offset);
        if(type == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 8;
        rdlength = decomp_get_rdlength(compressed,offset);
        if(rdlength == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += 2;
        
        rddata->unit_count = 0;
        if(decomp_get_rddata(compressed,rddata,offset,type,rdlength)
           != JS_SUCCESS) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        
        if(js_adduint16(uncompressed,rddata->unit_count) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        
        if(js_append(rddata,uncompressed) == JS_ERROR) {
            js_destroy(rddata);
            return JS_ERROR;
            }
        offset += rdlength; 
        answers--;
        }

    js_destroy(rddata);
    return JS_SUCCESS;
    }



int decompress_data(js_string *compressed, js_string *uncompressed) {
    
    uncompressed->unit_count = 0;

    if(dlog_level >= 5) {
       printf("About to decompress packet: ");
       show_esc_stdout(compressed);
       printf("\n");
       }

    if(dlog_level == -1) { 
        return JS_ERROR;
        }
    else {
        return decomp_decompress_packet(compressed,uncompressed);
        }

    
    return JS_ERROR;
    }



rrdesc **decomp_export_rrformats() {
    return rr_formats;
    }

