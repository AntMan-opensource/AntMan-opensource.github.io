






































































static TPM_RC CryptHmacSign( TPMT_SIGNATURE      *signature, OBJECT              *signKey, TPM2B_DIGEST        *hashData )




{
    HMAC_STATE       hmacState;
    UINT32           digestSize;
    digestSize = CryptHmacStart2B(&hmacState, signature->signature.any.hashAlg, &signKey->sensitive.sensitive.bits.b);
    CryptDigestUpdate2B(&hmacState.hashState, &hashData->b);
    CryptHmacEnd(&hmacState, digestSize, (BYTE *)&signature->signature.hmac.digest);
    return TPM_RC_SUCCESS;
}





static TPM_RC CryptHMACVerifySignature( OBJECT              *signKey, TPM2B_DIGEST        *hashData, TPMT_SIGNATURE      *signature )




{
    TPMT_SIGNATURE           test;
    TPMT_KEYEDHASH_SCHEME   *keyScheme = &signKey->publicArea.parameters.keyedHashDetail.scheme;
    
    if((signature->sigAlg != TPM_ALG_HMAC)
       || (signature->signature.hmac.hashAlg == TPM_ALG_NULL))
	return TPM_RC_SCHEME;
    
    
    
    
    
    if((keyScheme->scheme != TPM_ALG_NULL)
       && ((keyScheme->scheme != signature->sigAlg)
	   || (keyScheme->details.hmac.hashAlg != signature->signature.any.hashAlg)))
	return TPM_RC_SIGNATURE;
    test.sigAlg = signature->sigAlg;
    test.signature.hmac.hashAlg = signature->signature.hmac.hashAlg;
    CryptHmacSign(&test, signKey, hashData);
    
    if(!MemoryEqual(&test.signature.hmac.digest, &signature->signature.hmac.digest, CryptHashGetDigestSize(signature->signature.any.hashAlg)))

	return TPM_RC_SIGNATURE;
    return TPM_RC_SUCCESS;
}





static TPM_RC CryptGenerateKeyedHash( TPMT_PUBLIC             *publicArea,  TPMT_SENSITIVE          *sensitive, TPMS_SENSITIVE_CREATE   *sensitiveCreate, RAND_STATE              *rand )






{
    TPMT_KEYEDHASH_SCHEME   *scheme;
    TPM_ALG_ID               hashAlg;
    UINT16                   digestSize;
    
    scheme = &publicArea->parameters.keyedHashDetail.scheme;
    
    if(publicArea->type != TPM_ALG_KEYEDHASH)
	return TPM_RC_FAILURE;
    
    if(scheme->scheme == TPM_ALG_NULL)
	hashAlg = publicArea->nameAlg;
    else if(scheme->scheme == TPM_ALG_XOR)
	hashAlg = scheme->details.xorr.hashAlg;
    else hashAlg = scheme->details.hmac.hashAlg;
    
    digestSize = CryptHashGetDigestSize(hashAlg);
    
    
    
    
    
    
    
    if(sensitiveCreate->data.t.size != 0)
	{
	    if(IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, decrypt)
	       || IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, sign))
		{
		    if(sensitiveCreate->data.t.size > CryptHashGetBlockSize(hashAlg))
			return TPM_RC_SIZE;

		    if(sensitiveCreate->data.t.size < (digestSize / 2))
			return TPM_RC_SIZE;

		}
	    
	    
	    MemoryCopy2B(&sensitive->sensitive.bits.b, &sensitiveCreate->data.b, sizeof(sensitive->sensitive.bits.t.buffer));
	}
    else {
	    
	    
	    sensitive->sensitive.bits.t.size = DRBG_Generate(rand, sensitive->sensitive.bits.t.buffer, digestSize);
	    if(sensitive->sensitive.bits.t.size == 0)
		return (g_inFailureMode) ? TPM_RC_FAILURE : TPM_RC_NO_RESULT;
	}
    return TPM_RC_SUCCESS;
}


BOOL CryptIsSchemeAnonymous( TPM_ALG_ID       scheme )


{
    return scheme == TPM_ALG_ECDAA;
}



void ParmDecryptSym( TPM_ALG_ID       symAlg, TPM_ALG_ID       hash, UINT16           keySizeInBits, TPM2B           *key, TPM2B           *nonceCaller, TPM2B           *nonceTpm, UINT32           dataSize, BYTE            *data )









{
    
    
    
    BYTE             symParmString[MAX_SYM_KEY_BYTES + MAX_SYM_BLOCK_SIZE];
    
    UINT16           keySize = (keySizeInBits + 7) / 8;
    TPM2B_IV         iv;
    iv.t.size = CryptGetSymmetricBlockSize(symAlg, keySizeInBits);
    
    if(iv.t.size > 0)
	{
	    
	    CryptKDFa(hash, key, CFB_KEY, nonceCaller, nonceTpm, keySizeInBits + (iv.t.size * 8), symParmString, NULL, FALSE);
	    MemoryCopy(iv.t.buffer, &symParmString[keySize], iv.t.size);
	    CryptSymmetricDecrypt(data, symAlg, keySizeInBits, symParmString, &iv, TPM_ALG_CFB, dataSize, data);
	}
    return;
}


void ParmEncryptSym( TPM_ALG_ID       symAlg, TPM_ALG_ID       hash, UINT16           keySizeInBits, TPM2B           *key, TPM2B           *nonceCaller, TPM2B           *nonceTpm, UINT32           dataSize, BYTE            *data )









{
    
    
    BYTE             symParmString[MAX_SYM_KEY_BYTES + MAX_SYM_BLOCK_SIZE];
    
    UINT16           keySize = (keySizeInBits + 7) / 8;
    TPM2B_IV         iv;
    iv.t.size = CryptGetSymmetricBlockSize(symAlg, keySizeInBits);
    
    if(iv.t.size > 0)
	{
	    
	    CryptKDFa(hash, key, CFB_KEY, nonceTpm, nonceCaller, keySizeInBits + (iv.t.size * 8), symParmString, NULL, FALSE);
	    MemoryCopy(iv.t.buffer, &symParmString[keySize], iv.t.size);
	    CryptSymmetricEncrypt(data, symAlg, keySizeInBits, symParmString, &iv, TPM_ALG_CFB, dataSize, data);
	}
    return;
}






static TPM_RC CryptGenerateKeySymmetric( TPMT_PUBLIC             *publicArea,  TPMT_SENSITIVE          *sensitive, TPMS_SENSITIVE_CREATE   *sensitiveCreate, RAND_STATE              *rand )






{
    UINT16           keyBits = publicArea->parameters.symDetail.sym.keyBits.sym;
    TPM_RC           result;
    
    
    if((keyBits % RADIX_BITS) != 0)
	return TPM_RC_KEY_SIZE;
    
    if(sensitiveCreate->data.t.size != 0)
	{
	    result = CryptSymKeyValidate(&publicArea->parameters.symDetail.sym, (TPM2B_SYM_KEY *)&sensitiveCreate->data);
	    if(result == TPM_RC_SUCCESS)
		MemoryCopy2B(&sensitive->sensitive.sym.b, &sensitiveCreate->data.b, sizeof(sensitive->sensitive.sym.t.buffer));
	}

    else if(publicArea->parameters.symDetail.sym.algorithm == TPM_ALG_TDES)
	{
	    sensitive->sensitive.sym.t.size = keyBits / 8;
	    result = CryptGenerateKeyDes(publicArea, sensitive, rand);
	}

    else {
	sensitive->sensitive.sym.t.size = DRBG_Generate(rand, sensitive->sensitive.sym.t.buffer, BITS_TO_BYTES(keyBits));

	if(g_inFailureMode)
	    result = TPM_RC_FAILURE;
	else if(sensitive->sensitive.sym.t.size == 0)
	    result = TPM_RC_NO_RESULT;
	else result = TPM_RC_SUCCESS;
    }
    return result;
}


void CryptXORObfuscation( TPM_ALG_ID       hash, TPM2B           *key, TPM2B           *contextU, TPM2B           *contextV, UINT32           dataSize, BYTE            *data )







{
    BYTE             mask[MAX_DIGEST_SIZE]; 
    BYTE            *pm;
    UINT32           i;
    UINT32           counter = 0;
    UINT16           hLen = CryptHashGetDigestSize(hash);
    UINT32           requestSize = dataSize * 8;
    INT32            remainBytes = (INT32)dataSize;
    pAssert((key != NULL) && (data != NULL) && (hLen != 0));
    
    for(; remainBytes > 0; remainBytes -= hLen)
	{
	    
	    CryptKDFa(hash, key, XOR_KEY, contextU, contextV, requestSize, mask, &counter, TRUE);
	    
	    pm = mask;
	    for(i = hLen < remainBytes ? hLen : remainBytes; i > 0; i--)
		*data++ ^= *pm++;
	}
    return;
}







BOOL CryptInit( void )


{
    BOOL         ok;
    
    AlgorithmGetImplementedVector(&g_implementedAlgorithms);
    
    CryptInitializeToTest();
    
    
    ok = SupportLibInit();
    ok = ok && CryptSymInit();
    ok = ok && CryptRandInit();
    ok = ok && CryptHashInit();

    ok = ok && CryptRsaInit();


    ok = ok && CryptEccInit();

    return ok;
}





BOOL CryptStartup( STARTUP_TYPE     type )


{
    BOOL            OK;
    NOT_REFERENCED(type);
    OK = CryptSymStartup();
    OK = OK && CryptRandStartup();
    OK = OK && CryptHashStartup();

    OK = OK && CryptRsaStartup();


    OK = OK && CryptEccStartup();

	 ;

    
    if(OK && (type != SU_RESTART) && (type != SU_RESUME))
	{
	    
	    
	    
	    gr.commitNonce.t.size = sizeof(gr.commitNonce.t.buffer);
	    CryptRandomGenerate(gr.commitNonce.t.size, gr.commitNonce.t.buffer);
	    
	    gr.commitCounter = 0;
	    MemorySet(gr.commitArray, 0, sizeof(gr.commitArray));
	}

    return OK;
}








BOOL CryptIsAsymAlgorithm( TPM_ALG_ID       algID )


{
    switch(algID)
	{

	  case TPM_ALG_RSA:


	  case TPM_ALG_ECC:

	    return TRUE;
	    break;
	  default:
	    break;
	}
    return FALSE;
}








TPM_RC CryptSecretEncrypt( OBJECT                  *encryptKey, const TPM2B             *label, TPM2B_DATA              *data, TPM2B_ENCRYPTED_SECRET  *secret )





{
    TPMT_RSA_DECRYPT         scheme;
    TPM_RC                   result = TPM_RC_SUCCESS;
    
    if(data == NULL || secret == NULL)
	return TPM_RC_FAILURE;
    
    data->t.size = CryptHashGetDigestSize(encryptKey->publicArea.nameAlg);
    
    scheme.scheme = TPM_ALG_OAEP;
    scheme.details.anySig.hashAlg = encryptKey->publicArea.nameAlg;
    if(!IS_ATTRIBUTE(encryptKey->publicArea.objectAttributes, TPMA_OBJECT, decrypt))
	return TPM_RC_ATTRIBUTES;
    switch(encryptKey->publicArea.type)
	{

	  case TPM_ALG_RSA:
	      {
		  
		  CryptRandomGenerate(data->t.size, data->t.buffer);
		  
		  result = CryptRsaEncrypt((TPM2B_PUBLIC_KEY_RSA *)secret, &data->b, encryptKey, &scheme, label, NULL);
	      }
	      break;


	  case TPM_ALG_ECC:
	      {
		  TPMS_ECC_POINT      eccPublic;
		  TPM2B_ECC_PARAMETER eccPrivate;
		  TPMS_ECC_POINT      eccSecret;
		  BYTE                *buffer = secret->t.secret;
		  
		  
		  if(!CryptEccIsPointOnCurve( encryptKey->publicArea.parameters.eccDetail.curveID, &encryptKey->publicArea.unique.ecc))

		      result = TPM_RC_KEY;
		  else {
			  
			  
			  
			  CryptEccNewKeyPair(&eccPublic, &eccPrivate, encryptKey->publicArea.parameters.eccDetail.curveID);
			  
			  
			  secret->t.size = TPMS_ECC_POINT_Marshal(&eccPublic, &buffer, NULL);
			  
			  
			  
			  
			  
			  if(CryptEccPointMultiply(&eccSecret, encryptKey->publicArea.parameters.eccDetail.curveID, &encryptKey->publicArea.unique.ecc, &eccPrivate, NULL, NULL) != TPM_RC_SUCCESS)


			      result = TPM_RC_KEY;
			  else {
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  CryptKDFe(encryptKey->publicArea.nameAlg, &eccSecret.x.b, label, &eccPublic.x.b, &encryptKey->publicArea.unique.ecc.x.b, data->t.size * 8, data->t.buffer);


			      }
		      }
	      }
	      break;

	  default:
	    FAIL(FATAL_ERROR_INTERNAL);
	    break;
	}
    return result;
}











TPM_RC CryptSecretDecrypt( OBJECT                 *decryptKey, TPM2B_NONCE             *nonceCaller,    const TPM2B             *label, TPM2B_ENCRYPTED_SECRET  *secret, TPM2B_DATA              *data )









{
    TPM_RC      result = TPM_RC_SUCCESS;
    
    switch(decryptKey->publicArea.type)
	{

	  case TPM_ALG_RSA:
	      {
		  TPMT_RSA_DECRYPT        scheme;
		  TPMT_RSA_SCHEME         *keyScheme = &decryptKey->publicArea.parameters.rsaDetail.scheme;
		  UINT16                   digestSize;
		  scheme = *(TPMT_RSA_DECRYPT *)keyScheme;
		  
		  
		  if(scheme.scheme == TPM_ALG_NULL)
		      {
			  
			  scheme.scheme = TPM_ALG_OAEP;
			  scheme.details.oaep.hashAlg = decryptKey->publicArea.nameAlg;
		      }
		  
		  
		  
		  
		  
		  
		  
		  
		  digestSize = CryptHashGetDigestSize(scheme.details.oaep.hashAlg);
		  if(scheme.scheme != TPM_ALG_OAEP || digestSize == 0)
		      return TPM_RC_SCHEME;
		  
		  data->t.size = sizeof(data->t.buffer);
		  
		  result = CryptRsaDecrypt(&data->b, &secret->b, decryptKey, &scheme, label);
		  if((result == TPM_RC_SUCCESS) && (data->t.size > digestSize))
		      result = TPM_RC_VALUE;
	      }
	      break;


	  case TPM_ALG_ECC:
	      {
		  TPMS_ECC_POINT       eccPublic;
		  TPMS_ECC_POINT       eccSecret;
		  BYTE                *buffer = secret->t.secret;
		  INT32                size = secret->t.size;
		  
		  result = TPMS_ECC_POINT_Unmarshal(&eccPublic, &buffer, &size);
		  if(result == TPM_RC_SUCCESS)
		      {
			  result = CryptEccPointMultiply(&eccSecret, decryptKey->publicArea.parameters.eccDetail.curveID, &eccPublic, &decryptKey->sensitive.sensitive.ecc, NULL, NULL);


			  if(result == TPM_RC_SUCCESS)
			      {
				  
				  
				  data->t.size = CryptHashGetDigestSize(decryptKey->publicArea.nameAlg);
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  
				  CryptKDFe(decryptKey->publicArea.nameAlg, &eccSecret.x.b, label, &eccPublic.x.b, &decryptKey->publicArea.unique.ecc.x.b, data->t.size * 8, data->t.buffer);


			      }
		      }
	      }
	      break;




	  case TPM_ALG_KEYEDHASH:
	    
	    if(secret->t.size > CryptHashGetDigestSize(decryptKey->publicArea.nameAlg))
		result = TPM_RC_VALUE;
	    else {
		    
		    
		    
		    
		    
		    
		    
		    
		    
		    
		    
		    CryptXORObfuscation(decryptKey->publicArea.nameAlg, &decryptKey->sensitive.sensitive.bits.b, &nonceCaller->b, NULL, secret->t.size, secret->t.secret);


		    
		    MemoryCopy2B(&data->b, &secret->b, sizeof(data->t.buffer));
		}
	    break;
	  case TPM_ALG_SYMCIPHER:
	      {
		  TPM2B_IV                iv = {{0}};
		  TPMT_SYM_DEF_OBJECT     *symDef;
		  
		  if(secret->t.size > CryptHashGetDigestSize(decryptKey->publicArea.nameAlg))
		      result = TPM_RC_VALUE;
		  else {
			  symDef = &decryptKey->publicArea.parameters.symDetail.sym;
			  iv.t.size = CryptGetSymmetricBlockSize(symDef->algorithm, symDef->keyBits.sym);
			  if(iv.t.size == 0)
			      return TPM_RC_FAILURE;
			  if(nonceCaller->t.size >= iv.t.size)
			      {
				  MemoryCopy(iv.t.buffer, nonceCaller->t.buffer, iv.t.size);
			      }
			  else {
				  if(nonceCaller->t.size > sizeof(iv.t.buffer))
				      return TPM_RC_FAILURE;
				  MemoryCopy(iv.t.buffer, nonceCaller->t.buffer,   nonceCaller->t.size);
			      }
			  
			  if(secret->t.size > sizeof(data->t.buffer))
			      return TPM_RC_FAILURE;
			  data->t.size = secret->t.size;
			  
			  CryptSymmetricDecrypt(data->t.buffer, symDef->algorithm, symDef->keyBits.sym, decryptKey->sensitive.sensitive.sym.t.buffer, &iv, TPM_ALG_CFB, secret->t.size, secret->t.secret);



		      }
	      }
	      break;
	  default:
	    FAIL(FATAL_ERROR_INTERNAL);
	    break;
	}
    return result;
}


void CryptParameterEncryption( TPM_HANDLE       handle, TPM2B           *nonceCaller, UINT16           leadingSizeInByte,  TPM2B_AUTH      *extraKey,  BYTE            *buffer )








{
    SESSION     *session = SessionGet(handle);  
    TPM2B_TYPE(TEMP_KEY, (sizeof(extraKey->t.buffer)
			  + sizeof(session->sessionKey.t.buffer)));
    TPM2B_TEMP_KEY        key;               
    UINT32               cipherSize = 0;    
    
    if(leadingSizeInByte == 2)
	{
	    
	    
	    cipherSize = (UINT32)BYTE_ARRAY_TO_UINT16(buffer);
	    
	    buffer = &buffer[2];
	}

    else if(leadingSizeInByte == 4)
	{
	    
	    cipherSize = BYTE_ARRAY_TO_UINT32(buffer);
	    
	    buffer = &buffer[4];
	}

    else {
	    FAIL(FATAL_ERROR_INTERNAL);
	}
    
    MemoryCopy2B(&key.b, &session->sessionKey.b, sizeof(key.t.buffer));
    MemoryConcat2B(&key.b, &extraKey->b, sizeof(key.t.buffer));
    if(session->symmetric.algorithm == TPM_ALG_XOR)
	
	
	CryptXORObfuscation(session->authHashAlg, &(key.b), &(session->nonceTPM.b), nonceCaller, cipherSize, buffer);

    else ParmEncryptSym(session->symmetric.algorithm, session->authHashAlg, session->symmetric.keyBits.aes, &(key.b), nonceCaller, &(session->nonceTPM.b), cipherSize, buffer);



    return;
}




TPM_RC CryptParameterDecryption( TPM_HANDLE       handle, TPM2B           *nonceCaller, UINT32           bufferSize, UINT16           leadingSizeInByte,  TPM2B_AUTH      *extraKey, BYTE            *buffer )








{
    SESSION         *session = SessionGet(handle);  
    
    
    
    TPM2B_TYPE(HMAC_KEY, (sizeof(extraKey->t.buffer)
			  + sizeof(session->sessionKey.t.buffer)));
    TPM2B_HMAC_KEY          key;            
    UINT32                  cipherSize = 0; 
    
    if(leadingSizeInByte == 2)
	{
	    
	    
	    cipherSize = (UINT32)BYTE_ARRAY_TO_UINT16(buffer);
	    buffer = &buffer[2];   
	}

    else if(leadingSizeInByte == 4)
	{
	    
	    cipherSize = BYTE_ARRAY_TO_UINT32(buffer);
	    buffer = &buffer[4];   
	}

    else {
	    FAIL(FATAL_ERROR_INTERNAL);
	}
    if(cipherSize > bufferSize)
	return TPM_RC_SIZE;
    
    MemoryCopy2B(&key.b, &session->sessionKey.b, sizeof(key.t.buffer));
    MemoryConcat2B(&key.b, &extraKey->b, sizeof(key.t.buffer));
    if(session->symmetric.algorithm == TPM_ALG_XOR)
	
	
	
	CryptXORObfuscation(session->authHashAlg, &key.b, nonceCaller, &(session->nonceTPM.b), cipherSize, buffer);
    else  ParmDecryptSym(session->symmetric.algorithm, session->authHashAlg, session->symmetric.keyBits.sym, &key.b, nonceCaller, &session->nonceTPM.b, cipherSize, buffer);




    return TPM_RC_SUCCESS;
}


void CryptComputeSymmetricUnique( TPMT_PUBLIC     *publicArea, TPMT_SENSITIVE  *sensitive, TPM2B_DIGEST    *unique )




{
    
    
    if(IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, restricted)
       && IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, decrypt))
	{
	    
	    HMAC_STATE      hmacState;
	    unique->b.size = CryptHmacStart2B(&hmacState, publicArea->nameAlg, &sensitive->seedValue.b);
	    CryptDigestUpdate2B(&hmacState.hashState, &sensitive->sensitive.any.b);
	    CryptHmacEnd2B(&hmacState, &unique->b);
	}
    else {
	    HASH_STATE  hashState;
	    
	    unique->t.size = CryptHashStart(&hashState, publicArea->nameAlg);
	    CryptDigestUpdate2B(&hashState, &sensitive->seedValue.b);
	    CryptDigestUpdate2B(&hashState, &sensitive->sensitive.any.b);
	    CryptHashEnd2B(&hashState, &unique->b);
	}
    return;
}













TPM_RC CryptCreateObject( OBJECT                  *object, TPMS_SENSITIVE_CREATE   *sensitiveCreate, RAND_STATE              *rand  )





{
    TPMT_PUBLIC             *publicArea = &object->publicArea;
    TPMT_SENSITIVE          *sensitive = &object->sensitive;
    TPM_RC                   result = TPM_RC_SUCCESS;
    
    
    sensitive->sensitiveType = publicArea->type;
    
    sensitive->authValue = sensitiveCreate->userAuth;
    
    
    if(IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, sensitiveDataOrigin))
	sensitiveCreate->data.t.size = 0;
    
    
    switch(publicArea->type)
	{

	    
	  case TPM_ALG_RSA:
	    
	    
	    result = CryptRsaGenerateKey(object, rand);
	    break;


	    
	  case TPM_ALG_ECC:
	    result = CryptEccGenerateKey(publicArea, sensitive, rand);
	    break;

	  case TPM_ALG_SYMCIPHER:
	    result = CryptGenerateKeySymmetric(publicArea, sensitive, sensitiveCreate, rand);
	    break;
	  case TPM_ALG_KEYEDHASH:
	    result = CryptGenerateKeyedHash(publicArea, sensitive, sensitiveCreate, rand);
	    break;
	  default:
	    FAIL(FATAL_ERROR_INTERNAL);
	    break;
	}
    if(result != TPM_RC_SUCCESS)
	return result;
    
    
    
    
    if(object->attributes.primary && object->attributes.epsHierarchy)
	{
	    DRBG_AdditionalData((DRBG_STATE *)rand, &gp.shProof.b);
	    DRBG_AdditionalData((DRBG_STATE *)rand, &gp.ehProof.b);
	}
    
    sensitive->seedValue.t.size = DRBG_Generate(rand, object->sensitive.seedValue.t.buffer, CryptHashGetDigestSize(publicArea->nameAlg));

    if(g_inFailureMode)
	return TPM_RC_FAILURE;
    else if(sensitive->seedValue.t.size == 0)
	return TPM_RC_NO_RESULT;
    
    if(publicArea->type == TPM_ALG_SYMCIPHER || publicArea->type == TPM_ALG_KEYEDHASH)
	{
	    CryptComputeSymmetricUnique(publicArea, sensitive, &publicArea->unique.sym);
	}
    else {
	    
	    
	    if(IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, sign)
	       || !IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, restricted))
		memset(&sensitive->seedValue, 0, sizeof(sensitive->seedValue));
	}
    
    PublicMarshalAndComputeName(publicArea, &object->name);
    return result;
}


TPMI_ALG_HASH CryptGetSignHashAlg( TPMT_SIGNATURE  *auth )


{
    if(auth->sigAlg == TPM_ALG_NULL)
	FAIL(FATAL_ERROR_INTERNAL);
    
    switch(auth->sigAlg)
	{

	    



	  case TPM_ALG_RSASSA:
	    return auth->signature.rsassa.hash;
	  case TPM_ALG_RSAPSS:
	    return auth->signature.rsapss.hash;


	    



	  case TPM_ALG_ECDSA:
	    

	  case TPM_ALG_SM2:


	  case TPM_ALG_ECSCHNORR:

	    
	    return auth->signature.ecdsa.hash;

	    
	  case TPM_ALG_ECDAA:
	    break;


	  case TPM_ALG_HMAC:
	    return auth->signature.hmac.hashAlg;
	  default:
	    break;
	}
    return TPM_ALG_NULL;
}


BOOL CryptIsSplitSign( TPM_ALG_ID       scheme )


{
    switch(scheme)
	{

	  case TPM_ALG_ECDAA:
	    return TRUE;
	    break;

	  default:
	    return FALSE;
	    break;
	}
}


BOOL CryptIsAsymSignScheme( TPMI_ALG_PUBLIC          publicType, TPMI_ALG_ASYM_SCHEME     scheme )



{
    BOOL            isSignScheme = TRUE;
    switch(publicType)
	{

	  case TPM_ALG_RSA:
	    switch(scheme)
		{



		  case TPM_ALG_RSASSA:
		  case TPM_ALG_RSAPSS:
		    break;
		  default:
		    isSignScheme = FALSE;
		    break;
		}
	    break;


	    
	  case TPM_ALG_ECC:
	    switch(scheme)
		{
		    
		  case TPM_ALG_ECDSA:

		  case TPM_ALG_ECDAA:


		  case TPM_ALG_ECSCHNORR:


		  case TPM_ALG_SM2:

		    break;
		  default:
		    isSignScheme = FALSE;
		    break;
		}
	    break;

	  default:
	    isSignScheme = FALSE;
	    break;
	}
    return isSignScheme;
}


BOOL CryptIsAsymDecryptScheme( TPMI_ALG_PUBLIC          publicType, TPMI_ALG_ASYM_SCHEME     scheme )



{
    BOOL        isDecryptScheme = TRUE;
    switch(publicType)
	{

	  case TPM_ALG_RSA:
	    switch(scheme)
		{
		  case TPM_ALG_RSAES:
		  case TPM_ALG_OAEP:
		    break;
		  default:
		    isDecryptScheme = FALSE;
		    break;
		}
	    break;


	    
	  case TPM_ALG_ECC:
	    switch(scheme)
		{



		  case TPM_ALG_ECDH:

		  case TPM_ALG_SM2:


		  case TPM_ALG_ECMQV:

		    break;
		  default:
		    isDecryptScheme = FALSE;
		    break;
		}
	    break;

	  default:
	    isDecryptScheme = FALSE;
	    break;
	}
    return isDecryptScheme;
}







BOOL CryptSelectSignScheme( OBJECT              *signObject, TPMT_SIG_SCHEME     *scheme )



{
    TPMT_SIG_SCHEME     *objectScheme;
    TPMT_PUBLIC         *publicArea;
    BOOL                 OK;
    
    
    if(signObject == NULL)
	{
	    OK = TRUE;
	    scheme->scheme = TPM_ALG_NULL;
	    scheme->details.any.hashAlg = TPM_ALG_NULL;
	}
    else {
	    
	    publicArea = &signObject->publicArea;
	    
	    
	    if(publicArea->type == TPM_ALG_SYMCIPHER)
		return FALSE;
	    
	    if(CryptIsAsymAlgorithm(publicArea->type))
		objectScheme = (TPMT_SIG_SCHEME *)&publicArea->parameters.asymDetail.scheme;
	    else objectScheme = (TPMT_SIG_SCHEME *)&publicArea->parameters.keyedHashDetail.scheme;

	    
	    
	    if(objectScheme->scheme == TPM_ALG_NULL)
		{
		    
		    OK = (scheme->scheme != TPM_ALG_NULL);
		    
		    
		}
	    else if(scheme->scheme == TPM_ALG_NULL)
		{
		    
		    
		    
		    OK = !CryptIsSplitSign(objectScheme->scheme);
		    if(OK)
			{
			    
			    
			    
			    *scheme = *objectScheme;
			}
		}
	    else {
		    
		    
		    
		    
		    
		    OK = (objectScheme->scheme == scheme->scheme)
			 && (objectScheme->details.any.hashAlg == scheme->details.any.hashAlg);
		}
	}
    return OK;
}





TPM_RC CryptSign( OBJECT              *signKey, TPMT_SIG_SCHEME     *signScheme, TPM2B_DIGEST        *digest, TPMT_SIGNATURE      *signature )





{
    TPM_RC               result = TPM_RC_SCHEME;
    
    signature->sigAlg = signScheme->scheme;
    
    
    if((signature->sigAlg == TPM_ALG_NULL) || (signKey == NULL))
	return TPM_RC_SUCCESS;
    
    
    
    signature->signature.any.hashAlg = signScheme->details.any.hashAlg;
    
    switch(signKey->publicArea.type)
	{

	  case TPM_ALG_RSA:
	    result = CryptRsaSign(signature, signKey, digest, NULL);
	    break;


	  case TPM_ALG_ECC:
	    
	    
	    
	    result = CryptEccSign(signature, signKey, digest, (TPMT_ECC_SCHEME *)signScheme, NULL);
	    break;

	  case TPM_ALG_KEYEDHASH:
	    result = CryptHmacSign(signature, signKey, digest);
	    break;
	  default:
	    FAIL(FATAL_ERROR_INTERNAL);
	    break;
	}
    return result;
}







TPM_RC CryptValidateSignature( TPMI_DH_OBJECT   keyHandle, TPM2B_DIGEST    *digest, TPMT_SIGNATURE  *signature )




{
    
    
    
    
    OBJECT              *signObject = HandleToObject(keyHandle);
    TPMT_PUBLIC         *publicArea = &signObject->publicArea;
    TPM_RC               result = TPM_RC_SCHEME;
    
    
    if(signature->sigAlg == TPM_ALG_NULL)
	return TPM_RC_SIGNATURE;
    switch(publicArea->type)
	{

	  case TPM_ALG_RSA:
	      {
		  
		  
		  result = CryptRsaValidateSignature(signature, signObject, digest);
		  break;
	      }


	  case TPM_ALG_ECC:
	    result = CryptEccValidateSignature(signature, signObject, digest);
	    break;

	  case TPM_ALG_KEYEDHASH:
	    if(signObject->attributes.publicOnly)
		result = TPM_RCS_HANDLE;
	    else result = CryptHMACVerifySignature(signObject, digest, signature);
	    break;
	  default:
	    break;
	}
    return result;
}



TPM_RC CryptGetTestResult( TPM2B_MAX_BUFFER    *outData )


{
    outData->t.size = 0;
    return TPM_RC_SUCCESS;
}








TPM_RC CryptValidateKeys( TPMT_PUBLIC      *publicArea, TPMT_SENSITIVE   *sensitive, TPM_RC            blamePublic, TPM_RC            blameSensitive )





{
    TPM_RC               result;
    UINT16               keySizeInBytes;
    UINT16               digestSize = CryptHashGetDigestSize(publicArea->nameAlg);
    TPMU_PUBLIC_PARMS   *params = &publicArea->parameters;
    TPMU_PUBLIC_ID      *unique = &publicArea->unique;
    if(sensitive != NULL)
	{
	    
	    if(publicArea->type != sensitive->sensitiveType)
		return TPM_RCS_TYPE + blameSensitive;
	    
	    
	    
	    
	    if((sensitive->authValue.t.size) > digestSize && (digestSize > 0))
		return TPM_RCS_SIZE + blameSensitive;
	}
    switch(publicArea->type)
	{

	  case TPM_ALG_RSA:
	    keySizeInBytes = BITS_TO_BYTES(params->rsaDetail.keyBits);
	    
	    
	    
	    
	    
	    
	    
	    if((unique->rsa.t.size != keySizeInBytes)
	       || (unique->rsa.t.buffer[0] < 0x80))
		return TPM_RCS_KEY + blamePublic;
	    if(params->rsaDetail.exponent != 0 && params->rsaDetail.exponent < 7)
		return TPM_RCS_VALUE + blamePublic;
	    if(sensitive != NULL)
		{
		    
		    
		    if(((sensitive->sensitive.rsa.t.size * 2) != keySizeInBytes)
		       || (sensitive->sensitive.rsa.t.buffer[0] < 0x80))
			return TPM_RCS_KEY_SIZE + blameSensitive;
		}
	    break;


	  case TPM_ALG_ECC:
	      {
		  TPMI_ECC_CURVE      curveId;
		  curveId = params->eccDetail.curveID;
		  keySizeInBytes = BITS_TO_BYTES(CryptEccGetKeySizeForCurve(curveId));
		  if(sensitive == NULL)
		      {
			  
			  if(unique->ecc.x.t.size != keySizeInBytes || unique->ecc.y.t.size != keySizeInBytes)
			      return TPM_RCS_KEY + blamePublic;
			  if(publicArea->nameAlg != TPM_ALG_NULL)
			      {
				  if(!CryptEccIsPointOnCurve(curveId, &unique->ecc))
				      return TPM_RCS_ECC_POINT + blamePublic;
			      }
		      }
		  else {
			  
			  
			  if(!CryptEccIsValidPrivateKey(&sensitive->sensitive.ecc, curveId))
			      return TPM_RCS_KEY_SIZE;
			  if(publicArea->nameAlg != TPM_ALG_NULL)
			      {
				  
				  
				  TPMS_ECC_POINT          toCompare;
				  result = CryptEccPointMultiply(&toCompare, curveId, NULL, &sensitive->sensitive.ecc, NULL, NULL);

				  if(result != TPM_RC_SUCCESS)
				      return TPM_RCS_BINDING;
				  else {
					  
					  
					  
					  
					  
					  AdjustNumberB(&toCompare.x.b, unique->ecc.x.t.size);
					  AdjustNumberB(&toCompare.y.b, unique->ecc.y.t.size);
					  if(!MemoryEqual2B(&unique->ecc.x.b, &toCompare.x.b)
					     || !MemoryEqual2B(&unique->ecc.y.b, &toCompare.y.b))
					      return TPM_RCS_BINDING;
				      }
			      }
		      }
		  break;
	      }

	  default:
	    
	    
	    
	    
	    
	    if(sensitive == NULL)
		{
		    if(unique->sym.t.size != digestSize)
			return TPM_RCS_KEY + blamePublic;
		}
	    else {
		    
		    if(publicArea->type == TPM_ALG_SYMCIPHER)
			{
			    result = CryptSymKeyValidate(&params->symDetail.sym, &sensitive->sensitive.sym);
			    if(result != TPM_RC_SUCCESS)
				return result + blameSensitive;
			}
		    else {
			    
			    
			    
			    
			    
			    
			    TPMT_KEYEDHASH_SCHEME       *scheme;
			    UINT16                       maxSize;
			    scheme = &params->keyedHashDetail.scheme;
			    if(scheme->scheme == TPM_ALG_XOR)
				{
				    maxSize = CryptHashGetBlockSize(scheme->details.xorr.hashAlg);
				}
			    else if(scheme->scheme == TPM_ALG_HMAC)
				{
				    maxSize = CryptHashGetBlockSize(scheme->details.hmac.hashAlg);
				}
			    else if(scheme->scheme == TPM_ALG_NULL)
				{
				    
				    maxSize = 128;
				}
			    else return TPM_RCS_SCHEME + blamePublic;
			    if(sensitive->sensitive.bits.t.size > maxSize)
				return TPM_RCS_KEY_SIZE + blameSensitive;
			}
		    
		    if(publicArea->nameAlg != TPM_ALG_NULL)
			{
			    TPM2B_DIGEST            compare;
			    if(sensitive->seedValue.t.size != digestSize)
				return TPM_RCS_KEY_SIZE + blameSensitive;
			    CryptComputeSymmetricUnique(publicArea, sensitive, &compare);
			    if(!MemoryEqual2B(&unique->sym.b, &compare.b))
				return TPM_RC_BINDING;
			}
		}
	    break;
	}
    
    
    if(IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, restricted)
       && IS_ATTRIBUTE(publicArea->objectAttributes, TPMA_OBJECT, decrypt)
       && sensitive != NULL && publicArea->nameAlg != TPM_ALG_NULL)
	{
	    if((sensitive->seedValue.t.size < (digestSize / 2))
	       || (sensitive->seedValue.t.size > digestSize))
		return TPM_RCS_SIZE + blameSensitive;
	}
    return TPM_RC_SUCCESS;
}






TPM_RC CryptSelectMac( TPMT_PUBLIC             *publicArea, TPMI_ALG_MAC_SCHEME     *inMac )



{
    TPM_ALG_ID              macAlg = TPM_ALG_NULL;
    switch(publicArea->type)
	{
	  case TPM_ALG_KEYEDHASH:
	      {
		  
		  TPMT_KEYEDHASH_SCHEME   *scheme;
		  scheme = &publicArea->parameters.keyedHashDetail.scheme;
		  
		  if(scheme->scheme != TPM_ALG_NULL)
		      macAlg = scheme->details.hmac.hashAlg;
		  break;
	      }
	  case TPM_ALG_SYMCIPHER:
	      {
		  TPMT_SYM_DEF_OBJECT     *scheme;
		  scheme = &publicArea->parameters.symDetail.sym;
		  
		  if(scheme->algorithm != TPM_ALG_NULL)
		      macAlg = scheme->mode.sym;
		  break;
	      }
	  default:
	    return TPM_RCS_TYPE;
	}
    
    if(*inMac != TPM_ALG_NULL)
	{
	    
	    
	    if((macAlg != TPM_ALG_NULL) && (*inMac != macAlg))
		return TPM_RCS_VALUE;
	}
    else {
	    
	    
	    if(macAlg == TPM_ALG_NULL)
		return TPM_RCS_VALUE;
	    *inMac = macAlg;
	}
    if(!CryptMacIsValidForKey(publicArea->type, *inMac, FALSE))
	return TPM_RCS_SCHEME;
    return TPM_RC_SUCCESS;
}


BOOL CryptMacIsValidForKey( TPM_ALG_ID          keyType, TPM_ALG_ID          macAlg, BOOL                flag )




{
    switch(keyType)
	{
	  case TPM_ALG_KEYEDHASH:
	    return CryptHashIsValidAlg(macAlg, flag);
	    break;
	  case TPM_ALG_SYMCIPHER:
	    return CryptSmacIsValidAlg(macAlg, flag);
	    break;
	  default:
	    break;
	}
    return FALSE;
}


BOOL CryptSmacIsValidAlg( TPM_ALG_ID      alg, BOOL            FLAG )



{
    switch (alg)
	{

	  case TPM_ALG_CMAC:
	    return TRUE;
	    break;

	  case TPM_ALG_NULL:
	    return FLAG;
	    break;
	  default:
	    return FALSE;
	}
}


BOOL CryptSymModeIsValid( TPM_ALG_ID          mode, BOOL                flag )



{
    switch(mode)
	{

	  case TPM_ALG_CTR:


	  case TPM_ALG_OFB:


	  case TPM_ALG_CBC:


	  case TPM_ALG_CFB:


	  case TPM_ALG_ECB:

	    return TRUE;
	  case TPM_ALG_NULL:
	    return flag;
	    break;
	  default:
	    break;
	}
    return FALSE;
}
