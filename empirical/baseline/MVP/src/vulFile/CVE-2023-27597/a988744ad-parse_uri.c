











static const str uri_type_names[7] = {
	{NULL, 0},  str_init("sip"), str_init("sips"), str_init("tel"), str_init("tels"), str_init("urn:service"), str_init("urn:nena:service")





};

char* uri_type2str(const uri_type type, char *result)
{
	if (type == ERROR_URI_T)
		return NULL;

	memcpy(result, uri_type_names[type].s, uri_type_names[type].len);
	return result + uri_type_names[type].len;
}

int uri_typestrlen(const uri_type type)
{
	return uri_type_names[type].len;
}

uri_type str2uri_type(char * buf)
{
	int scheme = 0;
	uri_type type = ERROR_URI_T;
	scheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);
	scheme|=0x20202020;
	if (scheme==SIP_SCH){
		type=SIP_URI_T;
	}else if(scheme==SIPS_SCH){
		if(buf[4]==':')
			type=SIPS_URI_T;
		else type = ERROR_URI_T;
	}else if (scheme==TEL_SCH){
		type=TEL_URI_T;
	}else if (scheme==URN_SERVICE_SCH){
		if (memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {
			type=URN_SERVICE_URI_T;
		}
		else if (memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {
			type=URN_NENA_SERVICE_URI_T;
		}
	}
	return type;
}

int parse_uri_headers(str headers, str h_name[], str h_val[], int h_size)
{
	enum states {URI_H_HEADER, URI_H_VALUE};
	register enum states state;
	char* h; 
	char* v; 
	str* header;		
	str* header_val;	
	register char* p;
	char* end;
	unsigned int i = 0;

	
	end = headers.s + headers.len;
	p = h = headers.s;
	v = NULL;
	header = &h_name[0];
	header_val = &h_val[0];
	state = URI_H_HEADER;
	memset(h_name, 0, h_size * sizeof(str));
	memset(h_val, 0, h_size * sizeof(str));

	for(;p<end; p++){
		switch((unsigned char)state){
		case URI_H_HEADER:
			switch(*p){
			case '=':
				v = p+1;
				header->s = h;
				header->len = p-h;
				state = URI_H_VALUE;
				break;
			case '?':
				LM_ERR("Header without value\n");
				h = p+1;
				header->s = h;
				header->len = p-h;
				header_val->s = NULL;
				header_val->len = 0;

				
				i++;
				if(i<h_size){
					header = &h_name[i];
					header_val = &h_val[i];
				} else {
					LM_ERR("To many URI headers\n");
					return -1;
				}
				break;
			}
			break;
		case URI_H_VALUE:
			switch(*p){
			case '=':
				LM_ERR("Ignoring unexpected '=' inside URI header value\n");
				break;
			case '?':
				h = p+1;
				header_val->s = v;
				header_val->len = p-v;
				state = URI_H_HEADER;

				
				i++;
				if(i<h_size){
					header = &h_name[i];
					header_val = &h_val[i];
				} else {
					LM_ERR("To many URI headers\n");
					return -1;
				}
				break;
			}
			break;
		default:
			LM_ERR("Unexpected state [%d]\n", state);
			return -1;
		}
	}

	switch(state){
	case URI_H_HEADER:
		LM_ERR("Header without value\n");
		header->s = h;
		header->len = p-h;
		header_val->s = NULL;
		header_val->len = 0;
		break;
	case URI_H_VALUE:
		header_val->s = v;
		header_val->len = p-v;
		break;
	}


	for(i=0; i<h_size && h_name[i].s; i++)
		LM_DBG("header=[%p]-><%.*s> val=[%p]-><%.*s>\n", h_name[i].s, h_name[i].len, h_name[i].s, h_val[i].s, h_val[i].len, h_val[i].s);



	return 0;
}

int print_uri(struct sip_uri *uri, str *out_buf)
{



















































	int bytes = 0;
	int i;

	memcpy(out_buf->s, uri_type_names[uri->type].s, uri_type_names[uri->type].len);
	bytes += uri_type_names[uri->type].len;
	append_char(':');
	append_str_chunk(user);
	if (uri->passwd.s) {
		append_char(':');
		append_str_chunk(passwd);
	}
	if (uri->host.s) {
		append_char('@');
		append_str_chunk(host);
	}
	if (uri->port.s) {
		append_char(':');
		append_str_chunk(port);
	}

	append_param(transport);
	append_param(ttl);
	append_param(user_param);
	append_param(maddr);
	append_param(method);
	append_param(lr);
	append_param(r2);
	append_param(gr);
	append_param(pn_provider);
	append_param(pn_prid);
	append_param(pn_param);
	append_param(pn_purr);

	for (i = 0; i < uri->u_params_no; i++)
		append_uk_param(i);

	out_buf->len = bytes;

	return 0;





}


int parse_uri(char* buf, int len, struct sip_uri* uri)
{
	enum states  {	URI_INIT, URI_USER, URI_PASSWORD, URI_PASSWORD_ALPHA, URI_HOST, URI_HOST_P, URI_HOST6_P, URI_HOST6_END, URI_PORT, URI_PARAM, URI_PARAM_P, URI_PARAM_VAL_P, URI_VAL_P, URI_HEADERS,   PT_T, PT_R, PT_A, PT_N, PT_S, PT_P, PT_O, PT_R2, PT_T2, PT_eq,  PTTL_T2, PTTL_L, PTTL_eq,  PU_U, PU_S, PU_E, PU_R, PU_eq,  PM_M, PM_E, PM_T, PM_H, PM_O, PM_D, PM_eq,  PMA_A, PMA_D, PMA_D2, PMA_R, PMA_eq,  PLR_L, PLR_R_FIN, PLR_eq,  PG_G, PG_G_FIN, PG_eq,  PR2_R, PR2_2_FIN, PR2_eq,   VU_U, VU_D, VU_P_FIN,  VT_T, VT_C, VT_P_FIN,  VTLS_L, VTLS_S_FIN,  VS_S, VS_C, VS_T, VS_P_FIN,  VW_W, VW_S, VW_S_FIN, VWS_S_FIN,   PN_P, PN_N, PN_dash, PN_P2, PN_PR, PN1_O, PN1_V, PN1_I, PN1_D, PN1_E, PN1_FIN, PN1_eq, PN2_I, PN2_D, PN2_eq, PN3_A, PN3_R, PN3_A2, PN3_M, PN3_eq, PN4_U, PN4_R, PN4_R2, PN4_eq,  };









































	register enum states state;
	char* s;
	char* b; 
	char *v; 
	str* param; 
	str* param_val; 
	str user;
	str password;
	int port_no;
	register char* p;
	char* end;
	char* pass;
	int found_user;
	int error_headers;
	unsigned int scheme;
	uri_type backup;

	int i;































































































































































































































































	
	end=buf+len;
	p=buf+4;
	found_user=0;
	error_headers=0;
	b=v=0;
	param=param_val=0;
	pass=0;
	password.s = 0;
	password.len = 0;
	port_no=0;
	state=URI_INIT;
	memset(uri, 0, sizeof(struct sip_uri)); 
	
	if (len<5) goto error_too_short;
	scheme=buf[0]+(buf[1]<<8)+(buf[2]<<16)+(buf[3]<<24);
	scheme|=0x20202020;
	if (scheme==SIP_SCH){
		uri->type=SIP_URI_T;
	}else if(scheme==SIPS_SCH){
		if(buf[4]==':'){ p++; uri->type=SIPS_URI_T;}
		else goto error_bad_uri;
	}else if (scheme==TEL_SCH){
		uri->type=TEL_URI_T;
	}else if (scheme==URN_SERVICE_SCH){
		if ((end-(buf+3)) >= URN_SERVICE_STR_LEN && memcmp(buf+3,URN_SERVICE_STR,URN_SERVICE_STR_LEN) == 0) {
			p+= URN_SERVICE_STR_LEN-1;
			uri->type=URN_SERVICE_URI_T;
		}
		else if ((end-(buf+3)) >= URN_NENA_SERVICE_STR_LEN && memcmp(buf+3,URN_NENA_SERVICE_STR,URN_NENA_SERVICE_STR_LEN) == 0) {
			p+= URN_NENA_SERVICE_STR_LEN-1;
			uri->type=URN_NENA_SERVICE_URI_T;
		}else goto error_bad_uri;
	}else goto error_bad_uri;

	s=p;
	for(;p<end; p++){
		switch((unsigned char)state){
			case URI_INIT:
				switch(*p){
					case '[':
						
						state=URI_HOST6_P;
						s=p;
						break;
					case ']':
						
					case ':':
						
						goto error_bad_char;
					case '@': 
						goto error_bad_char;
					default:
						state=URI_USER;
				}
				break;
			case URI_USER:
				switch(*p){
					case '@':
						
						uri->user.s=s;
						uri->user.len=p-s;
						state=URI_HOST;
						found_user=1;
						s=p+1; 
						break;
					case ':':
						
						uri->user.s=s;
						uri->user.len=p-s;
						state=URI_PASSWORD;
						s=p+1; 
						break;
					case ';':
						
						uri->host.s=s;
						uri->host.len=p-s;
						state=URI_PARAM;
						s=p+1;
						break;
					case '?': 
						uri->host.s=s;
						uri->host.len=p-s;
						state=URI_HEADERS;
						s=p+1;
						break;
						
					case '[':
					case ']': 
						goto error_bad_char;
				}
				break;
			case URI_PASSWORD: 
				switch(*p){
					case '@':
						
						uri->passwd.s=s;
						uri->passwd.len=p-s;
						port_no=0;
						state=URI_HOST;
						found_user=1;
						s=p+1; 
						break;
					case ';':
						
						uri->port.s=s;
						uri->port.len=p-s;
						uri->port_no=port_no;
						
						uri->host.s=uri->user.s;
						uri->host.len=uri->user.len;
						uri->user.s=0;
						uri->user.len=0;
						state=URI_PARAM;
						found_user=1; 
						s=p+1;
						break;
					case '?':
						
						uri->port.s=s;
						uri->port.len=p-s;
						uri->port_no=port_no;
						
						uri->host.s=uri->user.s;
						uri->host.len=uri->user.len;
						uri->user.s=0;
						uri->user.len=0;
						state=URI_HEADERS;
						found_user=1; 
						s=p+1;
						break;
					case_port('0', port_no);
					case_port('1', port_no);
					case_port('2', port_no);
					case_port('3', port_no);
					case_port('4', port_no);
					case_port('5', port_no);
					case_port('6', port_no);
					case_port('7', port_no);
					case_port('8', port_no);
					case_port('9', port_no);
					case '[':
					case ']':
					case ':':
						goto error_bad_char;
					default:
						
						port_no=0;
						state=URI_PASSWORD_ALPHA;
				}
				break;
			case URI_PASSWORD_ALPHA:
				switch(*p){
					case '@':
						
						uri->passwd.s=s;
						uri->passwd.len=p-s;
						state=URI_HOST;
						found_user=1;
						s=p+1; 
						break;
					case ';': 
					case '?':
						goto error_bad_port;
					case '[':
					case ']':
					case ':':
						goto error_bad_char;
				}
				break;
			case URI_HOST:
				switch(*p){
					case '[':
						state=URI_HOST6_P;
						break;
					case ':':
					case ';':
					case '?': 
					case '&':
					case '@': 
						goto error_bad_host;
					default:
						state=URI_HOST_P;
				}
				break;
			case URI_HOST_P:
				switch(*p){
					check_host_end;
				}
				break;
			case URI_HOST6_END:
				switch(*p){
					check_host_end;
					default: 
						goto error_bad_host;
				}
				break;
			case URI_HOST6_P:
				switch(*p){
					case ']':
						state=URI_HOST6_END;
						break;
					case '[':
					case '&':
					case '@':
					case ';':
					case '?':
						goto error_bad_host;
				}
				break;
			case URI_PORT:
				switch(*p){
					case ';':
						uri->port.s=s;
						uri->port.len=p-s;
						uri->port_no=port_no;
						state=URI_PARAM;
						s=p+1;
						break;
					case '?':
						uri->port.s=s;
						uri->port.len=p-s;
						uri->port_no=port_no;
						state=URI_HEADERS;
						s=p+1;
						break;
					case_port('0', port_no);
					case_port('1', port_no);
					case_port('2', port_no);
					case_port('3', port_no);
					case_port('4', port_no);
					case_port('5', port_no);
					case_port('6', port_no);
					case_port('7', port_no);
					case_port('8', port_no);
					case_port('9', port_no);
					case '&':
					case '@':
					case ':':
					default:
						goto error_bad_port;
				}
				break;
			case URI_PARAM: 
				switch(*p){
					param_common_cases;
					
					case 't':
					case 'T':
						b=p;
						state=PT_T;
						break;
					case 'u':
					case 'U':
						b=p;
						state=PU_U;
						break;
					case 'm':
					case 'M':
						b=p;
						state=PM_M;
						break;
					case 'l':
					case 'L':
						b=p;
						state=PLR_L;
						break;
					case 'g':
					case 'G':
						b=p;
						state=PG_G;
						break;
					case 'r':
					case 'R':
						b=p;
						state=PR2_R;
						break;
					case 'p':
					case 'P':
						b=p;
						state=PN_P;
						break;
					default:
						b=p;
						state=URI_PARAM_P;
				}
				break;
			case URI_PARAM_P: 
				
				switch(*p){
					u_param_common_cases;
					case '=':
						v=p + 1;
						state=URI_PARAM_VAL_P;
						break;
				};
				break;
			case URI_PARAM_VAL_P: 
				switch(*p){
					u_param_common_cases;
				};
				break;
			
			
			param_switch_big(PT_T,  'r', 'R', 't', 'T', PT_R, PTTL_T2);
			param_switch(PT_R,  'a', 'A', PT_A);
			param_switch(PT_A,  'n', 'N', PT_N);
			param_switch(PT_N,  's', 'S', PT_S);
			param_switch(PT_S,  'p', 'P', PT_P);
			param_switch(PT_P,  'o', 'O', PT_O);
			param_switch(PT_O,  'r', 'R', PT_R2);
			param_switch(PT_R2, 't', 'T', PT_T2);
			param_switch1(PT_T2, '=',  PT_eq);
			
			case PT_eq:
				param=&uri->transport;
				param_val=&uri->transport_val;
				uri->proto = PROTO_OTHER;
				switch (*p){
					param_common_cases;
					case 'u':
					case 'U':
						v=p;
						state=VU_U;
						break;
					case 't':
					case 'T':
						v=p;
						state=VT_T;
						break;
					case 's':
					case 'S':
						v=p;
						state=VS_S;
						break;
					case 'w':
					case 'W':
						v=p;
						state=VW_W;
						break;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;
				
			case URI_VAL_P:
				switch(*p){
					value_common_cases;
				}
				break;
			
			value_switch(VU_U,  'd', 'D', VU_D);
			value_switch(VU_D,  'p', 'P', VU_P_FIN);
			transport_fin(VU_P_FIN, PROTO_UDP);
			
			value_switch_big(VT_T,  'c', 'C', 'l', 'L', VT_C, VTLS_L);
			value_switch(VT_C,  'p', 'P', VT_P_FIN);
			transport_fin(VT_P_FIN, PROTO_TCP);
			
			value_switch(VTLS_L, 's', 'S', VTLS_S_FIN);
			transport_fin(VTLS_S_FIN, PROTO_TLS);
			
			value_switch(VS_S, 'c', 'C', VS_C);
			value_switch(VS_C, 't', 'T', VS_T);
			value_switch(VS_T, 'p', 'P', VS_P_FIN);
			transport_fin(VS_P_FIN, PROTO_SCTP);
			
			value_switch(VW_W, 's', 'S', VW_S);
			case VW_S:
				if (*p == 's' || *p == 'S') {
					state=(VWS_S_FIN);
					break;
				}
				
				state=(VW_S_FIN);
			transport_fin(VW_S_FIN, PROTO_WS);
			transport_fin(VWS_S_FIN, PROTO_WSS);

			
			param_switch(PTTL_T2,  'l', 'L', PTTL_L);
			param_switch1(PTTL_L,  '=', PTTL_eq);
			case PTTL_eq:
				param=&uri->ttl;
				param_val=&uri->ttl_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PU_U, 's', 'S', PU_S);
			param_switch(PU_S, 'e', 'E', PU_E);
			param_switch(PU_E, 'r', 'R', PU_R);
			param_switch1(PU_R, '=', PU_eq);
			case PU_eq:
				param=&uri->user_param;
				param_val=&uri->user_param_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch_big(PM_M, 'e', 'E', 'a', 'A', PM_E, PMA_A);
			param_switch(PM_E, 't', 'T', PM_T);
			param_switch(PM_T, 'h', 'H', PM_H);
			param_switch(PM_H, 'o', 'O', PM_O);
			param_switch(PM_O, 'd', 'D', PM_D);
			param_switch1(PM_D, '=', PM_eq);
			case PM_eq:
				param=&uri->method;
				param_val=&uri->method_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PMA_A,  'd', 'D', PMA_D);
			param_switch(PMA_D,  'd', 'D', PMA_D2);
			param_switch(PMA_D2, 'r', 'R', PMA_R);
			param_switch1(PMA_R, '=', PMA_eq);
			case PMA_eq:
				param=&uri->maddr;
				param_val=&uri->maddr_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PLR_L,  'r', 'R', PLR_R_FIN);
			case PLR_R_FIN:
				switch(*p){
					case '@':
						still_at_user;
						break;
					case '=':
						state=PLR_eq;
						break;
					semicolon_case;
						uri->lr.s=b;
						uri->lr.len=(p-b);
						break;
					question_case;
						uri->lr.s=b;
						uri->lr.len=(p-b);
						break;
					colon_case;
						break;
					default:
						state=URI_PARAM_P;
				}
				break;
				
			case PLR_eq:
				param=&uri->lr;
				param_val=&uri->lr_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch1(PR2_R,  '2', PR2_2_FIN);
			case PR2_2_FIN:
				switch(*p){
					case '@':
						still_at_user;
						break;
					case '=':
						state=PR2_eq;
						break;
					semicolon_case;
						uri->r2.s=b;
						uri->r2.len=(p-b);
						break;
					question_case;
						uri->r2.s=b;
						uri->r2.len=(p-b);
						break;
					colon_case;
						break;
					default:
						state=URI_PARAM_P;
				}
				break;
				
			case PR2_eq:
				param=&uri->r2;
				param_val=&uri->r2_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;


			
			param_switch(PG_G,  'r', 'R', PG_G_FIN);
			case PG_G_FIN:
				switch(*p){
					case '@':
						still_at_user;
						break;
					case '=':
						state=PG_eq;
						break;
					semicolon_case;
						uri->gr.s=b;
						uri->gr.len=(p-b);
						break;
					question_case;
						uri->gr.s=b;
						uri->gr.len=(p-b);
						break;
					colon_case;
						break;
					default:
						state=URI_PARAM_P;
				}
				break;
				
			case PG_eq:
				param=&uri->gr;
				param_val=&uri->gr_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;


			
			param_switch(PN_P, 'n', 'N', PN_N);
			param_switch1(PN_N, '-', PN_dash);
			param_switch(PN_dash, 'p', 'P', PN_P2);

			param_switch_bigger(PN_P2, 'r', 'R', 'a', 'A', 'u', 'U', PN_PR, PN3_A, PN4_U);
			param_switch_big(PN_PR, 'o', 'O', 'i', 'I', PN1_O, PN2_I);

			
			param_switch(PN1_O, 'v', 'V', PN1_V);
			param_switch(PN1_V, 'i', 'I', PN1_I);
			param_switch(PN1_I, 'd', 'D', PN1_D);
			param_switch(PN1_D, 'e', 'E', PN1_E);
			param_switch(PN1_E, 'r', 'R', PN1_FIN);
			case PN1_FIN:
				param=&uri->pn_provider;
				switch(*p){
					case '@':
						still_at_user;
						break;
					case '=':
						state=PN1_eq;
						break;
					semicolon_case;
						uri->pn_provider.s=b;
						uri->pn_provider.len=(p-b);
						break;
					question_case;
						uri->pn_provider.s=b;
						uri->pn_provider.len=(p-b);
						break;
					colon_case;
						break;
					default:
						state=URI_PARAM_P;
				}
				break;
				
			case PN1_eq:
				param=&uri->pn_provider;
				param_val=&uri->pn_provider_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PN2_I, 'd', 'D', PN2_D);
			param_xswitch1(PN2_D, '=', PN2_eq);
			case PN2_eq:
				param=&uri->pn_prid;
				param_val=&uri->pn_prid_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PN3_A, 'r', 'R', PN3_R);
			param_switch(PN3_R, 'a', 'A', PN3_A2);
			param_switch(PN3_A2, 'm', 'M', PN3_M);
			param_xswitch1(PN3_M, '=', PN3_eq);
			case PN3_eq:
				param=&uri->pn_param;
				param_val=&uri->pn_param_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;

			
			param_switch(PN4_U, 'r', 'R', PN4_R);
			param_switch(PN4_R, 'r', 'R', PN4_R2);
			param_xswitch1(PN4_R2, '=', PN4_eq);
			case PN4_eq:
				param=&uri->pn_purr;
				param_val=&uri->pn_purr_val;
				switch(*p){
					param_common_cases;
					default:
						v=p;
						state=URI_VAL_P;
				}
				break;


			case URI_HEADERS:
				
				switch(*p){
					case '@':
						
						still_at_user;
						break;
					case ';':
						
						if (found_user) goto error_bad_char;
						error_headers=1; 
						
						if (pass) goto error_headers;
						break;
					case ':':
						if (found_user==0){
							
							if (pass){
								found_user=1; 
								pass=0;
							}else{
								pass=p;
							}
						}
						break;
					case '?':
						if (pass){
							found_user=1; 
							pass=0;
						}
						break;
				}
				break;
			default:
				goto error_bug;
		}
	}

	
	switch (state){
		case URI_INIT: 
			goto error_too_short;
		case URI_USER:
			
			if (found_user) goto error_bad_uri;
			uri->host.s=s;
			uri->host.len=p-s;
			state=URI_HOST;
			break;
		case URI_PASSWORD:
			
			if (found_user) goto error_bad_port;
			uri->port.s=s;
			uri->port.len=p-s;
			uri->port_no=port_no;
			uri->host=uri->user;
			uri->user.s=0;
			uri->user.len=0;
			break;
		case URI_PASSWORD_ALPHA:
			
			goto error_bad_port;
		case URI_HOST_P:
		case URI_HOST6_END:
			uri->host.s=s;
			uri->host.len=p-s;
			break;
		case URI_HOST: 
		case URI_HOST6_P: 
			goto error_bad_host;
		case URI_PORT:
			uri->port.s=s;
			uri->port.len=p-s;
			uri->port_no=port_no;
			break;
		case URI_PARAM:
		case URI_PARAM_P:
		case URI_PARAM_VAL_P:
			u_param_set(b, v);
		
		case PT_T: 
		case PT_R:
		case PT_A:
		case PT_N:
		case PT_S:
		case PT_P:
		case PT_O:
		case PT_R2:
		case PT_T2:
		case PT_eq: 
		case PTTL_T2: 
		case PTTL_L:
		case PTTL_eq:
		case PU_U:  
		case PU_S:
		case PU_E:
		case PU_R:
		case PU_eq:
		case PM_M: 
		case PM_E:
		case PM_T:
		case PM_H:
		case PM_O:
		case PM_D:
		case PM_eq:
		case PLR_L: 
		case PR2_R:  
		case PG_G: 
			uri->params.s=s;
			uri->params.len=p-s;
			break;
		
		case PLR_R_FIN:
		case PLR_eq:
			uri->params.s=s;
			uri->params.len=p-s;
			uri->lr.s=b;
			uri->lr.len=p-b;
			break;
		case PR2_2_FIN:
		case PR2_eq:
			uri->params.s=s;
			uri->params.len=p-s;
			uri->r2.s=b;
			uri->r2.len=p-b;
			break;
		case PG_G_FIN:
		case PG_eq:
			uri->params.s=s;
			uri->params.len=p-s;
			uri->gr.s=b;
			uri->gr.len=p-b;
			break;
		case PN1_FIN:
		case PN1_eq:
			uri->params.s=s;
			uri->params.len=p-s;
			uri->pn_provider.s=b;
			uri->pn_provider.len=p-b;
			break;
		case URI_VAL_P:
		
		case VU_U:
		case VU_D:
		case VT_T:
		case VT_C:
		case VTLS_L:
		case VS_S:
		case VS_C:
		case VW_W:
		case VS_T:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			break;
		
		case VU_P_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_UDP;
			break;
		case VT_P_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_TCP;
			break;
		case VTLS_S_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_TLS;
			break;
		case VS_P_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_SCTP;
			break;
		case VW_S:
		case VW_S_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_WS;
			break;
		case VWS_S_FIN:
			uri->params.s=s;
			uri->params.len=p-s;
			param_set(b, v);
			uri->proto=PROTO_WSS;
			break;
		
		case URI_HEADERS:
			uri->headers.s=s;
			uri->headers.len=p-s;
			if (error_headers) goto error_headers;
			break;
		
		case PN_P:
		case PN_N:
		case PN_dash:
		case PN_P2:
		case PN_PR:
		case PN1_O:
		case PN1_V:
		case PN1_I:
		case PN1_D:
		case PN1_E:
		case PN2_I:
		case PN3_A:
		case PN3_R:
		case PN3_A2:
		case PN4_U:
		case PN4_R:
			uri->params.s=s;
			uri->params.len=p-s;
			break;
		case PN2_D:
		case PN2_eq:
		case PN3_M:
		case PN3_eq:
		case PN4_R2:
		case PN4_eq:
			goto error_bad_uri;
		default:
			goto error_bug;
	}
	switch(uri->type){
		case TEL_URI_T:
		case TELS_URI_T:
			
			uri->user=uri->host;
			uri->host.s="";
			uri->host.len=0;
			break;
		case SIP_URI_T:
		case SIPS_URI_T:
		case URN_SERVICE_URI_T:
			
			break;
		case URN_NENA_SERVICE_URI_T:
			uri->user.s=0;
			uri->user.len=0;
			uri->host.s="";
			uri->host.len=0;
			break;
		case ERROR_URI_T:
			LM_ERR("unexpected error (BUG?)\n");
			goto error_bad_uri;
			break; 
	}

	
	LM_DBG("parsed uri:\n type=%d user=<%.*s>(%d)\n passwd=<%.*s>(%d)\n" " host=<%.*s>(%d)\n port=<%.*s>(%d): %d\n params=<%.*s>(%d)\n" " headers=<%.*s>(%d)\n", uri->type, uri->user.len, ZSW(uri->user.s), uri->user.len, uri->passwd.len, ZSW(uri->passwd.s), uri->passwd.len, uri->host.len, ZSW(uri->host.s), uri->host.len, uri->port.len, ZSW(uri->port.s), uri->port.len, uri->port_no, uri->params.len, ZSW(uri->params.s), uri->params.len, uri->headers.len, ZSW(uri->headers.s), uri->headers.len );









	LM_DBG(" uri params:\n   transport=<%.*s>, val=<%.*s>, proto=%d\n", uri->transport.len, ZSW(uri->transport.s), uri->transport_val.len, ZSW(uri->transport_val.s), uri->proto);

	LM_DBG("   user-param=<%.*s>, val=<%.*s>\n", uri->user_param.len, ZSW(uri->user_param.s), uri->user_param_val.len, ZSW(uri->user_param_val.s));

	LM_DBG("   method=<%.*s>, val=<%.*s>\n", uri->method.len, ZSW(uri->method.s), uri->method_val.len, ZSW(uri->method_val.s));

	LM_DBG("   ttl=<%.*s>, val=<%.*s>\n", uri->ttl.len, ZSW(uri->ttl.s), uri->ttl_val.len, ZSW(uri->ttl_val.s));

	LM_DBG("   maddr=<%.*s>, val=<%.*s>\n", uri->maddr.len, ZSW(uri->maddr.s), uri->maddr_val.len, ZSW(uri->maddr_val.s));

	LM_DBG("   lr=<%.*s>, val=<%.*s>\n", uri->lr.len, ZSW(uri->lr.s), uri->lr_val.len, ZSW(uri->lr_val.s));
	LM_DBG("   r2=<%.*s>, val=<%.*s>\n", uri->r2.len, ZSW(uri->r2.s), uri->r2_val.len, ZSW(uri->r2_val.s));
	for(i=0; i<URI_MAX_U_PARAMS && uri->u_name[i].s; i++)
		LM_DBG("uname=[%p]-><%.*s> uval=[%p]-><%.*s>\n", uri->u_name[i].s, uri->u_name[i].len, uri->u_name[i].s, uri->u_val[i].s, uri->u_val[i].len, uri->u_val[i].s);

	if (i!=uri->u_params_no)
		LM_ERR("inconsisten # of u_name:[%d]!=[%d]\n", i, uri->u_params_no);

	return 0;

error_too_short:
	LM_ERR("uri too short: <%.*s> (%d)\n", len, ZSW(buf), len);
	goto error_exit;
error_bad_char:
	LM_ERR("bad char '%c' in state %d" " parsed: <%.*s> (%d) / <%.*s> (%d)\n", *p, state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);


	goto error_exit;
error_bad_host:
	LM_ERR("bad host in uri (error at char %c in" " state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\n", *p, state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);


	goto error_exit;
error_bad_port:
	LM_ERR("bad port in uri (error at char %c in" " state %d) parsed: <%.*s>(%d) /<%.*s> (%d)\n", *p, state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);


	goto error_exit;
error_bad_uri:
	LM_ERR("bad uri, state %d parsed: <%.*s> (%d) / <%.*s> (%d)\n", state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);

	goto error_exit;
error_headers:
	LM_ERR("bad uri headers: <%.*s>(%d) / <%.*s>(%d)\n", uri->headers.len, ZSW(uri->headers.s), uri->headers.len, len, ZSW(buf), len);

	goto error_exit;
error_bug:
	LM_CRIT("bad state %d parsed: <%.*s> (%d) / <%.*s> (%d)\n", state, (int)(p-buf), ZSW(buf), (int)(p-buf), len, ZSW(buf), len);
error_exit:
	ser_error=E_BAD_URI;
	uri->type=ERROR_URI_T;
	update_stat(bad_URIs, 1);
	return E_BAD_URI;
}


int parse_sip_msg_uri(struct sip_msg* msg)
{
	char* tmp;
	int tmp_len;
	if (msg->parsed_uri_ok) return 1;

	if (msg->new_uri.s){
		tmp=msg->new_uri.s;
		tmp_len=msg->new_uri.len;
	}else{
		tmp=msg->first_line.u.request.uri.s;
		tmp_len=msg->first_line.u.request.uri.len;
	}
	if (parse_uri(tmp, tmp_len, &msg->parsed_uri)<0){
		LM_ERR("bad uri <%.*s>\n", tmp_len, tmp);
		msg->parsed_uri_ok=0;
		set_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, "error parsing r-uri");
		set_err_reply(400, "bad r-uri");
		return -1;
	}
	msg->parsed_uri_ok=1;
	return 0;
}


int parse_orig_ruri(struct sip_msg* msg)
{
	str *uri;

	if (msg->parsed_orig_ruri_ok)
		return 1;

	uri = &REQ_LINE(msg).uri;

	if (parse_uri(uri->s, uri->len, &msg->parsed_orig_ruri)<0) {
		LM_ERR("bad uri <%.*s>\n", uri->len, ZSW(uri->s));
		msg->parsed_orig_ruri_ok = 0;
		set_err_info(OSER_EC_PARSER, OSER_EL_MEDIUM, "error parsing incoming uri");
		set_err_reply(400, "bad i-uri");
		return -1;
	}

	msg->parsed_orig_ruri_ok = 1;
	return 0;
}



















int compare_uris(str *raw_uri_a,struct sip_uri* parsed_uri_a, str *raw_uri_b,struct sip_uri *parsed_uri_b)
{
	#define UNESCAPED_BUF_LEN 1024
	char unescaped_a[UNESCAPED_BUF_LEN], unescaped_b[UNESCAPED_BUF_LEN];

	str unescaped_userA={unescaped_a, UNESCAPED_BUF_LEN};
	str unescaped_userB={unescaped_b, UNESCAPED_BUF_LEN};

	struct sip_uri first;
	struct sip_uri second;
	char matched[URI_MAX_U_PARAMS];
	int i,j;

	if ( (!raw_uri_a && !parsed_uri_a) || (!raw_uri_b && !parsed_uri_b) )
	{
		LM_ERR("Provide either a raw or parsed form of a SIP URI\n");
		return -1;
	}

	if (raw_uri_a && raw_uri_b)
	{

		
		if (raw_uri_a->len == raw_uri_b->len)
			if (strncasecmp(raw_uri_a->s,raw_uri_b->s,raw_uri_a->len) == 0)
			{
				LM_DBG("straight-forward URI match\n");
				return 0;
			}
	}

	

	if (parsed_uri_a)
		first = *parsed_uri_a;
	else {
		if (parse_uri(raw_uri_a->s,raw_uri_a->len,&first) < 0)
		{
			LM_ERR("Failed to parse first URI\n");
			return -1;
		}
	}

	if (parsed_uri_b)
		second = *parsed_uri_b;
	else {
		if (parse_uri(raw_uri_b->s,raw_uri_b->len,&second) < 0)
		{
			LM_ERR("Failed to parse second URI\n");
			return -1;
		}
	}

	if (first.type != second.type)
	{
		LM_DBG("Different uri types\n");
		return 1;
	}

	if (unescape_user(&first.user, &unescaped_userA) < 0 || unescape_user(&second.user, &unescaped_userB) < 0) {
		LM_ERR("Failed to unescape user!\n");
		return -1;
	}

	first.user = unescaped_userA;
	second.user = unescaped_userB;

	compare_uri_val(user,strncmp);
	compare_uri_val(passwd,strncmp);
	compare_uri_val(host,strncasecmp);
	compare_uri_val(port,strncmp);

	compare_uri_val(transport_val,strncasecmp);
	compare_uri_val(ttl_val,strncasecmp);
	compare_uri_val(user_param_val,strncasecmp);
	compare_uri_val(maddr_val,strncasecmp);
	compare_uri_val(method_val,strncasecmp);
	compare_uri_val(lr_val,strncasecmp);
	compare_uri_val(r2_val,strncasecmp);

	if (first.u_params_no == 0 || second.u_params_no == 0)
		
		goto headers_check;

	memset(matched,0,URI_MAX_U_PARAMS);

	for (i=0;i<first.u_params_no;i++)
		for (j=0;j<second.u_params_no;j++)
			if (matched[j] == 0 && (first.u_name[i].len == second.u_name[j].len && strncasecmp(first.u_name[i].s,second.u_name[j].s, first.u_name[i].len) == 0))


				{
                    
					if (first.u_val[i].len != second.u_val[j].len)
					{
						LM_DBG("Different URI param value for param %.*s\n", first.u_name[i].len,first.u_name[i].s);
						return 1;
					}
					else {
						if (first.u_val[i].len == 0)
						{
							
							matched[j] = 1;
							break;
						}

						if (strncasecmp(first.u_val[i].s,second.u_val[j].s, second.u_val[j].len))
						{
							LM_DBG("Different URI param value for param %.*s\n", first.u_name[i].len,first.u_name[i].s);
							return 1;
						}
						else {
							matched[j] = 1;
							break;
						}
					}
				}

	

headers_check:
	 
	compare_uri_val(headers,strncasecmp);
	return 0;
}
