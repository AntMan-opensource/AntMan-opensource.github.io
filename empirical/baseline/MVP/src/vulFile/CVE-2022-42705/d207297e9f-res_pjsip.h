




































































struct pjsip_rx_data;
struct pjsip_module;
struct pjsip_tx_data;
struct pjsip_dialog;
struct pjsip_transport;
struct pjsip_tpfactory;
struct pjsip_tls_setting;
struct pjsip_tpselector;







AST_VECTOR(ast_sip_service_route_vector, char *);

static const pj_str_t AST_PJ_STR_EMPTY = { "", 0 };


struct ast_sip_transport_state {
	
	struct pjsip_transport *transport;
	
	struct pjsip_tpfactory *factory;
	
	char *id;
	
	enum ast_transport type;
	
	pj_sockaddr host;
	
	pjsip_tls_setting tls;
	
	pj_ssl_cipher ciphers[SIP_TLS_MAX_CIPHERS];
	
	struct ast_ha *localnet;
	
	struct ast_dnsmgr_entry *external_signaling_address_refresher;
	
	struct ast_sockaddr external_signaling_address;
	
	struct ast_dnsmgr_entry *external_media_address_refresher;
	
	struct ast_sockaddr external_media_address;
	
	int flow;
	
	char *preferred_identity;
	
	struct ast_sip_service_route_vector *service_routes;
	
	int allow_wildcard_certs;
	
	int verify_server;

	
	struct stat cert_file_stat;
	
	struct stat privkey_file_stat;

};






struct ast_sip_transport {
	
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(ca_list_file);

		
		AST_STRING_FIELD(ca_list_path);
		
		AST_STRING_FIELD(cert_file);
		
		AST_STRING_FIELD(privkey_file);
		
		AST_STRING_FIELD(password);
		
		AST_STRING_FIELD(external_signaling_address);
		
		AST_STRING_FIELD(external_media_address);
		
		AST_STRING_FIELD(domain);
		);
	
	enum ast_transport type;
	
	pj_sockaddr host;
	
	unsigned int async_operations;
	
	unsigned int external_signaling_port;
	
	pjsip_tls_setting tls;
	
	pj_ssl_cipher ciphers[SIP_TLS_MAX_CIPHERS];
	
	struct ast_ha *localnet;
	
	struct ast_dnsmgr_entry *external_address_refresher;
	
	struct ast_sockaddr external_address;
	
	struct ast_sip_transport_state *state;
	
	unsigned int tos;
	
	unsigned int cos;
	
	int write_timeout;
	
	int allow_reload;
	
	int symmetric_transport;
	
	int flow;
};




struct ast_sip_domain_alias {
	
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(domain);

	);
};


struct ast_sip_nat_hook {
	
	SORCERY_OBJECT(details);
	
	void (*outgoing_external_message)(struct pjsip_tx_data *tdata, struct ast_sip_transport *transport);
};


enum ast_sip_security_negotiation {
	
	AST_SIP_SECURITY_NEG_NONE = 0,  AST_SIP_SECURITY_NEG_MEDIASEC,  };





enum ast_sip_security_mechanism_type {
	AST_SIP_SECURITY_MECH_NONE = 0,  AST_SIP_SECURITY_MECH_MSRP_TLS,  AST_SIP_SECURITY_MECH_SDES_SRTP,  AST_SIP_SECURITY_MECH_DTLS_SRTP,  };









struct ast_sip_security_mechanism {
	
	enum ast_sip_security_mechanism_type type;
	
	float qvalue;
	
	struct ast_vector_string mechanism_parameters;
};

AST_VECTOR(ast_sip_security_mechanism_vector, struct ast_sip_security_mechanism *);


struct ast_sip_contact {
	
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(uri);

		
		AST_STRING_FIELD(outbound_proxy);
		
		AST_STRING_FIELD(path);
		
		AST_STRING_FIELD(user_agent);
		
		AST_STRING_FIELD(aor);
		
		AST_STRING_FIELD(reg_server);
		
		AST_STRING_FIELD(via_addr);
		
		AST_STRING_FIELD(call_id);
		
		AST_STRING_FIELD(endpoint_name);
	);
	
	struct timeval expiration_time;
	
	unsigned int qualify_frequency;
	
	int authenticate_qualify;
	
	double qualify_timeout;
	
	struct ast_sip_endpoint *endpoint;
	
	int via_port;
	
	int prune_on_boot;
};


enum ast_sip_contact_status_type {
	
	UNAVAILABLE,  AVAILABLE,  UNKNOWN,  CREATED, REMOVED, };









struct ast_sip_contact_status {
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(uri);

		
		AST_STRING_FIELD(aor);
	);
	
	int64_t rtt;
	
	struct ast_sip_security_mechanism_vector security_mechanisms;
	
	enum ast_sip_contact_status_type status;
	
	enum ast_sip_contact_status_type last_status;
	
	char name[0];
};


struct ast_sip_aor {
	
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(mailboxes);

		
		AST_STRING_FIELD(outbound_proxy);
	);
	
	unsigned int minimum_expiration;
	
	unsigned int maximum_expiration;
	
	unsigned int default_expiration;
	
	unsigned int qualify_frequency;
	
	int authenticate_qualify;
	
	unsigned int max_contacts;
	
	unsigned int remove_existing;
	
	struct ao2_container *permanent_contacts;
	
	unsigned int support_path;
	
	double qualify_timeout;
	
	char *voicemail_extension;
	
	unsigned int remove_unavailable;
};


struct ast_sip_contact_wrapper {
	
	char *aor_id;
	
	char *contact_id;
	
	struct ast_sip_contact *contact;
};


enum ast_sip_100rel_mode {
	
	AST_SIP_100REL_UNSUPPORTED = 0,  AST_SIP_100REL_SUPPORTED,  AST_SIP_100REL_PEER_SUPPORTED,  AST_SIP_100REL_REQUIRED, };








enum ast_sip_dtmf_mode {
	
	AST_SIP_DTMF_NONE,   AST_SIP_DTMF_RFC_4733,  AST_SIP_DTMF_INBAND,  AST_SIP_DTMF_INFO,  AST_SIP_DTMF_AUTO,  AST_SIP_DTMF_AUTO_INFO, };













enum ast_sip_auth_type {
	
	AST_SIP_AUTH_TYPE_USER_PASS,  AST_SIP_AUTH_TYPE_MD5,  AST_SIP_AUTH_TYPE_GOOGLE_OAUTH,  AST_SIP_AUTH_TYPE_ARTIFICIAL };









struct ast_sip_auth {
	
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(realm);

		
		AST_STRING_FIELD(auth_user);
		
		AST_STRING_FIELD(auth_pass);
		
		AST_STRING_FIELD(md5_creds);
		
		AST_STRING_FIELD(refresh_token);
		
		AST_STRING_FIELD(oauth_clientid);
		
		AST_STRING_FIELD(oauth_secret);
	);
	
	unsigned int nonce_lifetime;
	
	enum ast_sip_auth_type type;
};

AST_VECTOR(ast_sip_auth_vector, const char *);


enum ast_sip_endpoint_identifier_type {
	
	AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME = (1 << 0),  AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME = (1 << 1),  AST_SIP_ENDPOINT_IDENTIFY_BY_IP = (1 << 2),  AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER = (1 << 3), };






AST_VECTOR(ast_sip_identify_by_vector, enum ast_sip_endpoint_identifier_type);

enum ast_sip_session_refresh_method {
	
	AST_SIP_SESSION_REFRESH_METHOD_INVITE,  AST_SIP_SESSION_REFRESH_METHOD_UPDATE, };



enum ast_sip_direct_media_glare_mitigation {
	
	AST_SIP_DIRECT_MEDIA_GLARE_MITIGATION_NONE,  AST_SIP_DIRECT_MEDIA_GLARE_MITIGATION_OUTGOING,  AST_SIP_DIRECT_MEDIA_GLARE_MITIGATION_INCOMING, };





enum ast_sip_session_media_encryption {
	
	AST_SIP_MEDIA_TRANSPORT_INVALID = 0,  AST_SIP_MEDIA_ENCRYPT_NONE,  AST_SIP_MEDIA_ENCRYPT_SDES,  AST_SIP_MEDIA_ENCRYPT_DTLS, };







enum ast_sip_session_redirect {
	
	AST_SIP_REDIRECT_USER = 0,  AST_SIP_REDIRECT_URI_CORE,  AST_SIP_REDIRECT_URI_PJSIP, };





enum ast_sip_stir_shaken_behavior {
	
	AST_SIP_STIR_SHAKEN_OFF = 0,  AST_SIP_STIR_SHAKEN_ATTEST = 1,  AST_SIP_STIR_SHAKEN_VERIFY = 2,  AST_SIP_STIR_SHAKEN_ON = 3, };








enum ast_sip_call_codec_pref {
	
	
	AST_SIP_CALL_CODEC_PREF_INTERSECT =	1 << 0,  AST_SIP_CALL_CODEC_PREF_UNION =		1 << 1,    AST_SIP_CALL_CODEC_PREF_ALL =	 	1 << 2,  AST_SIP_CALL_CODEC_PREF_FIRST = 	1 << 3,    AST_SIP_CALL_CODEC_PREF_LOCAL = 	1 << 4,  AST_SIP_CALL_CODEC_PREF_REMOTE = 	1 << 5, };



















struct ast_sip_timer_options {
	
	unsigned int min_se;
	
	unsigned int sess_expires;
};


struct ast_sip_endpoint_extensions {
	
	unsigned int flags;
	
	struct ast_sip_timer_options timer;
};


struct ast_sip_mwi_configuration {
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(mailboxes);

		
		AST_STRING_FIELD(fromuser);
	);
	
	unsigned int aggregate;
	
	unsigned int subscribe_replaces_unsolicited;
	
	char *voicemail_extension;
};


struct ast_sip_endpoint_subscription_configuration {
	
	unsigned int allow;
	
	unsigned int minexpiry;
	
	struct ast_sip_mwi_configuration mwi;
	
	char context[AST_MAX_CONTEXT];
};


struct ast_sip_endpoint_nat_configuration {
	
	unsigned int force_rport;
	
	unsigned int rewrite_contact;
};


struct ast_sip_endpoint_id_configuration {
	struct ast_party_id self;
	
	unsigned int trust_inbound;
	
	unsigned int trust_outbound;
	
	unsigned int send_pai;
	
	unsigned int send_rpid;
	
	unsigned int rpid_immediate;
	
	unsigned int send_diversion;
	
	unsigned int trust_connected_line;
	
	unsigned int send_connected_line;
	
	enum ast_sip_session_refresh_method refresh_method;
	
	unsigned int send_history_info;
};


struct ast_sip_endpoint_pickup_configuration {
	
	ast_group_t callgroup;
	
	ast_group_t pickupgroup;
	
	struct ast_namedgroups *named_callgroups;
	
	struct ast_namedgroups *named_pickupgroups;
};


struct ast_sip_info_recording_configuration {
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(onfeature);

		
		AST_STRING_FIELD(offfeature);
	);
	
	unsigned int enabled;
};


struct ast_sip_endpoint_info_configuration {
	
	struct ast_sip_info_recording_configuration recording;
};


struct ast_sip_media_rtp_configuration {
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(engine);

	);
	
	unsigned int ipv6;
	
	unsigned int symmetric;
	
	unsigned int ice_support;
	
	unsigned int use_ptime;
	
	unsigned int use_avpf;
	
	unsigned int force_avp;
	
	unsigned int use_received_transport;
	
	struct ast_rtp_dtls_cfg dtls_cfg;
	
	unsigned int srtp_tag_32;
	
	enum ast_sip_session_media_encryption encryption;
	
	unsigned int encryption_optimistic;
	
	unsigned int keepalive;
	
	unsigned int timeout;
	
	unsigned int timeout_hold;
	
	unsigned int follow_early_media_fork;
	
	unsigned int accept_multiple_sdp_answers;
};


struct ast_sip_direct_media_configuration {
	
	unsigned int enabled;
	
	enum ast_sip_session_refresh_method method;
	
	enum ast_sip_direct_media_glare_mitigation glare_mitigation;
	
	unsigned int disable_on_nat;
};

struct ast_sip_t38_configuration {
	
	unsigned int enabled;
	
	enum ast_t38_ec_modes error_correction;
	
	unsigned int maxdatagram;
	
	unsigned int nat;
	
	unsigned int ipv6;
	
	unsigned int bind_udptl_to_media_address;
};


struct ast_sip_endpoint_media_configuration {
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(address);

		
		AST_STRING_FIELD(sdpowner);
		
		AST_STRING_FIELD(sdpsession);
	);
	
	struct ast_sip_media_rtp_configuration rtp;
	
	struct ast_sip_direct_media_configuration direct_media;
	
	struct ast_sip_t38_configuration t38;
	
	struct ast_format_cap *codecs;
	
	struct ast_stream_topology *topology;
	
	unsigned int tos_audio;
	
	unsigned int cos_audio;
	
	unsigned int tos_video;
	
	unsigned int cos_video;
	
	unsigned int g726_non_standard;
	
	unsigned int bind_rtp_to_media_address;
	
	unsigned int rtcp_mux;
	
	unsigned int max_audio_streams;
	
	unsigned int max_video_streams;
	
	unsigned int bundle;
	
	unsigned int webrtc;
	
	struct ast_flags incoming_call_offer_pref;
	
	struct ast_flags outgoing_call_offer_pref;
	
	struct ast_stream_codec_negotiation_prefs codec_prefs_incoming_offer;
	
	struct ast_stream_codec_negotiation_prefs codec_prefs_outgoing_offer;
	
	struct ast_stream_codec_negotiation_prefs codec_prefs_incoming_answer;
	
	struct ast_stream_codec_negotiation_prefs codec_prefs_outgoing_answer;
};


struct ast_sip_endpoint {
	SORCERY_OBJECT(details);
	AST_DECLARE_STRING_FIELDS(  AST_STRING_FIELD(context);

		
		AST_STRING_FIELD(transport);
		
		AST_STRING_FIELD(outbound_proxy);
		
		AST_STRING_FIELD(aors);
		
		AST_STRING_FIELD(mohsuggest);
		
		AST_STRING_FIELD(zone);
		
		AST_STRING_FIELD(language);
		
		AST_STRING_FIELD(fromuser);
		
		AST_STRING_FIELD(fromdomain);
		
		AST_STRING_FIELD(message_context);
		
		AST_STRING_FIELD(accountcode);
		
		AST_STRING_FIELD(incoming_mwi_mailbox);
		
		AST_STRING_FIELD(stir_shaken_profile);
	);
	
	struct ast_sip_endpoint_extensions extensions;
	
	struct ast_sip_endpoint_media_configuration media;
	
	struct ast_sip_endpoint_subscription_configuration subscription;
	
	struct ast_sip_endpoint_nat_configuration nat;
	
	struct ast_sip_endpoint_id_configuration id;
	
	struct ast_sip_endpoint_info_configuration info;
	
	struct ast_sip_endpoint_pickup_configuration pickup;
	
	struct ast_sip_auth_vector inbound_auths;
	
	struct ast_sip_auth_vector outbound_auths;
	
	enum ast_sip_dtmf_mode dtmf;
	
	enum ast_sip_endpoint_identifier_type ident_method;
	
	struct ast_sip_identify_by_vector ident_method_order;
	
	unsigned int inband_progress;
	
	struct ast_endpoint *persistent;
	
	unsigned int devicestate_busy_at;
	
	unsigned int faxdetect;
	
	unsigned int allowtransfer;
	
	enum ast_sip_session_redirect redirect_method;
	
	struct ast_variable *channel_vars;
	
	unsigned int usereqphone;
	
	unsigned int moh_passthrough;
	
	struct ast_acl_list *acl;
	
	struct ast_acl_list *contact_acl;
	
	unsigned int faxdetect_timeout;
	
	char *contact_user;
	
	unsigned int preferred_codec_only;
	
	unsigned int asymmetric_rtp_codec;
	
	unsigned int allow_overlap;
	
	unsigned int refer_blind_progress;
	
	unsigned int notify_early_inuse_ringing;
	
	unsigned int suppress_q850_reason_headers;
	
	unsigned int ignore_183_without_sdp;
	
	enum ast_sip_security_negotiation security_negotiation;
	
	struct ast_sip_security_mechanism_vector security_mechanisms;
	
	unsigned int stir_shaken;
	
	unsigned int allow_unauthenticated_options;
	
	AST_STRING_FIELD_EXTENDED(geoloc_incoming_call_profile);
	
	AST_STRING_FIELD_EXTENDED(geoloc_outgoing_call_profile);
	
	enum ast_sip_100rel_mode rel100;
};






extern pjsip_media_type pjsip_media_type_application_json;
extern pjsip_media_type pjsip_media_type_application_media_control_xml;
extern pjsip_media_type pjsip_media_type_application_pidf_xml;
extern pjsip_media_type pjsip_media_type_application_xpidf_xml;
extern pjsip_media_type pjsip_media_type_application_cpim_xpidf_xml;
extern pjsip_media_type pjsip_media_type_application_rlmi_xml;
extern pjsip_media_type pjsip_media_type_application_simple_message_summary;
extern pjsip_media_type pjsip_media_type_application_sdp;
extern pjsip_media_type pjsip_media_type_multipart_alternative;
extern pjsip_media_type pjsip_media_type_multipart_mixed;
extern pjsip_media_type pjsip_media_type_multipart_related;
extern pjsip_media_type pjsip_media_type_text_plain;


int ast_sip_are_media_types_equal(pjsip_media_type *a, pjsip_media_type *b);


int ast_sip_is_media_type_in(pjsip_media_type *a, ...) attribute_sentinel;


int ast_sip_add_security_headers(struct ast_sip_security_mechanism_vector *security_mechanisms, const char *header_name, int add_qval, pjsip_tx_data *tdata);


void ast_sip_header_to_security_mechanism(const pjsip_generic_string_hdr *hdr, struct ast_sip_security_mechanism_vector *security_mechanisms);


int ast_sip_security_mechanism_vector_init(struct ast_sip_security_mechanism_vector *security_mechanism, const char *value);


void ast_sip_remove_headers_by_name_and_value(pjsip_msg *msg, const pj_str_t *hdr_name, const char* value);


void ast_sip_security_mechanisms_vector_copy(struct ast_sip_security_mechanism_vector *dst, const struct ast_sip_security_mechanism_vector *src);


void ast_sip_security_mechanisms_vector_destroy(struct ast_sip_security_mechanism_vector *security_mechanisms);


int ast_sip_str_to_security_mechanism(struct ast_sip_security_mechanism **security_mechanism, const char *value);


int ast_sip_set_security_negotiation(enum ast_sip_security_negotiation *security_negotiation, const char *val);


int ast_sip_auth_vector_init(struct ast_sip_auth_vector *vector, const char *auth_names);


void ast_sip_auth_vector_destroy(struct ast_sip_auth_vector *vector);


enum ast_sip_check_auth_result {
    
    AST_SIP_AUTHENTICATION_CHALLENGE,  AST_SIP_AUTHENTICATION_SUCCESS,  AST_SIP_AUTHENTICATION_FAILED,  AST_SIP_AUTHENTICATION_ERROR, };








struct ast_sip_authenticator {
    
    int (*requires_authentication)(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata);
	
	enum ast_sip_check_auth_result (*check_authentication)(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pjsip_tx_data *tdata);
};


struct ast_sip_outbound_authenticator {
	
	int (*create_request_with_auth)(const struct ast_sip_auth_vector *auths, struct pjsip_rx_data *challenge, struct pjsip_tx_data *old_request, struct pjsip_tx_data **new_request);
};


struct ast_sip_endpoint_identifier {
    
    struct ast_sip_endpoint *(*identify_endpoint)(pjsip_rx_data *rdata);
};


enum ast_sip_contact_filter {
	
	AST_SIP_CONTACT_FILTER_DEFAULT = 0,   AST_SIP_CONTACT_FILTER_REACHABLE = (1 << 0), };





void ast_sip_add_date_header(pjsip_tx_data *tdata);


int ast_sip_register_service(pjsip_module *module);


void ast_sip_unregister_service(pjsip_module *module);


int ast_sip_register_authenticator(struct ast_sip_authenticator *auth);


void ast_sip_unregister_authenticator(struct ast_sip_authenticator *auth);

 
int ast_sip_register_outbound_authenticator(struct ast_sip_outbound_authenticator *outbound_auth);


void ast_sip_unregister_outbound_authenticator(struct ast_sip_outbound_authenticator *auth);


int ast_sip_register_endpoint_identifier_with_name(struct ast_sip_endpoint_identifier *identifier, const char *name);


int ast_sip_register_endpoint_identifier(struct ast_sip_endpoint_identifier *identifier);


void ast_sip_unregister_endpoint_identifier(struct ast_sip_endpoint_identifier *identifier);


void *ast_sip_endpoint_alloc(const char *name);


int ast_sip_persistent_endpoint_update_state(const char *endpoint_name, enum ast_endpoint_state state);


void ast_sip_persistent_endpoint_publish_contact_state(const char *endpoint_name, const struct ast_sip_contact_status *contact_status);


struct ast_sip_contact_status *ast_sip_get_contact_status(const struct ast_sip_contact *contact);


pjsip_endpoint *ast_sip_get_pjsip_endpoint(void);


struct ast_sorcery *ast_sip_get_sorcery(void);


struct ast_sip_aor *ast_sip_location_retrieve_aor(const char *aor_name);


struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact(const struct ast_sip_aor *aor);


struct ast_sip_contact *ast_sip_location_retrieve_first_aor_contact_filtered(const struct ast_sip_aor *aor, unsigned int flags);


struct ao2_container *ast_sip_location_retrieve_aor_contacts(const struct ast_sip_aor *aor);


struct ao2_container *ast_sip_location_retrieve_aor_contacts_filtered(const struct ast_sip_aor *aor, unsigned int flags);


struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock(const struct ast_sip_aor *aor);


struct ao2_container *ast_sip_location_retrieve_aor_contacts_nolock_filtered(const struct ast_sip_aor *aor, unsigned int flags);


struct ast_sip_contact *ast_sip_location_retrieve_contact_from_aor_list(const char *aor_list);


struct ao2_container *ast_sip_location_retrieve_contacts_from_aor_list(const char *aor_list);


 void ast_sip_location_retrieve_contact_and_aor_from_list(const char *aor_list, struct ast_sip_aor **aor, struct ast_sip_contact **contact);


void ast_sip_location_retrieve_contact_and_aor_from_list_filtered(const char *aor_list, unsigned int flags, struct ast_sip_aor **aor, struct ast_sip_contact **contact);


struct ast_sip_contact *ast_sip_location_retrieve_contact(const char *contact_name);


int ast_sip_location_add_contact(struct ast_sip_aor *aor, const char *uri, struct timeval expiration_time, const char *path_info, const char *user_agent, const char *via_addr, int via_port, const char *call_id, struct ast_sip_endpoint *endpoint);




int ast_sip_location_add_contact_nolock(struct ast_sip_aor *aor, const char *uri, struct timeval expiration_time, const char *path_info, const char *user_agent, const char *via_addr, int via_port, const char *call_id, struct ast_sip_endpoint *endpoint);




struct ast_sip_contact *ast_sip_location_create_contact(struct ast_sip_aor *aor, const char *uri, struct timeval expiration_time, const char *path_info, const char *user_agent, const char *via_addr, int via_port, const char *call_id, int prune_on_boot, struct ast_sip_endpoint *endpoint);




int ast_sip_location_update_contact(struct ast_sip_contact *contact);


int ast_sip_location_delete_contact(struct ast_sip_contact *contact);


void ast_sip_location_prune_boot_contacts(void);


typedef int (*ast_sip_dialog_outbound_auth_cb)(pjsip_dialog *dlg, pjsip_tx_data *tdata, void *user_data);


int ast_sip_dialog_setup_outbound_authentication(pjsip_dialog *dlg, const struct ast_sip_endpoint *endpoint, ast_sip_dialog_outbound_auth_cb cb, void *user_data);


struct ast_sip_auth *ast_sip_get_artificial_auth(void);


struct ast_sip_endpoint *ast_sip_get_artificial_endpoint(void);



typedef int (*ast_sip_task)(void *user_data);


struct ast_taskprocessor *ast_sip_create_serializer(const char *name);

struct ast_serializer_shutdown_group;


struct ast_taskprocessor *ast_sip_create_serializer_group(const char *name, struct ast_serializer_shutdown_group *shutdown_group);


struct ast_taskprocessor *ast_sip_get_distributor_serializer(pjsip_rx_data *rdata);


void ast_sip_dialog_set_serializer(pjsip_dialog *dlg, struct ast_taskprocessor *serializer);


void ast_sip_dialog_set_endpoint(pjsip_dialog *dlg, struct ast_sip_endpoint *endpoint);


struct ast_sip_endpoint *ast_sip_dialog_get_endpoint(pjsip_dialog *dlg);


int ast_sip_push_task(struct ast_taskprocessor *serializer, int (*sip_task)(void *), void *task_data);


int ast_sip_push_task_wait_servant(struct ast_taskprocessor *serializer, int (*sip_task)(void *), void *task_data);


int ast_sip_push_task_synchronous(struct ast_taskprocessor *serializer, int (*sip_task)(void *), void *task_data);


int ast_sip_push_task_wait_serializer(struct ast_taskprocessor *serializer, int (*sip_task)(void *), void *task_data);


int ast_sip_thread_is_servant(void);


enum ast_sip_scheduler_task_flags {
	
	AST_SIP_SCHED_TASK_DEFAULTS = (0 << 0),   AST_SIP_SCHED_TASK_FIXED = (0 << 0),  AST_SIP_SCHED_TASK_VARIABLE = (1 << 0),   AST_SIP_SCHED_TASK_ONESHOT = (1 << 6),   AST_SIP_SCHED_TASK_DATA_NOT_AO2 = (0 << 1),  AST_SIP_SCHED_TASK_DATA_AO2 = (1 << 1),   AST_SIP_SCHED_TASK_DATA_NO_CLEANUP = (0 << 3),  AST_SIP_SCHED_TASK_DATA_FREE = ( 1 << 3 ),   AST_SIP_SCHED_TASK_PERIODIC = (0 << 4),  AST_SIP_SCHED_TASK_DELAY = (1 << 4),  AST_SIP_SCHED_TASK_TRACK = (1 << 5), };



























struct ast_sip_sched_task;


struct ast_sip_sched_task *ast_sip_schedule_task(struct ast_taskprocessor *serializer, int interval, ast_sip_task sip_task, const char *name, void *task_data, enum ast_sip_scheduler_task_flags flags);



int ast_sip_sched_task_cancel(struct ast_sip_sched_task *schtd);


int ast_sip_sched_task_cancel_by_name(const char *name);


int ast_sip_sched_task_get_times(struct ast_sip_sched_task *schtd, struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end);


int ast_sip_sched_task_get_times2(struct ast_sip_sched_task *schtd, struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end, int *interval, int *time_left, struct timeval *next_start);



int ast_sip_sched_task_get_times_by_name(const char *name, struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end);


int ast_sip_sched_task_get_times_by_name2(const char *name, struct timeval *when_queued, struct timeval *last_start, struct timeval *last_end, int *interval, int *time_left, struct timeval *next_start);



int ast_sip_sched_task_get_next_run(struct ast_sip_sched_task *schtd);


int ast_sip_sched_task_get_next_run_by_name(const char *name);


int ast_sip_sched_is_task_running(struct ast_sip_sched_task *schtd);


int ast_sip_sched_is_task_running_by_name(const char *name);


int ast_sip_sched_task_get_name(struct ast_sip_sched_task *schtd, char *name, size_t maxlen);




struct ast_sip_body {
	
	const char *type;
	
	const char *subtype;
	
	const char *body_text;
};


pjsip_dialog *ast_sip_create_dialog_uac(const struct ast_sip_endpoint *endpoint, const char *aor_name, const char *request_user);


pjsip_dialog *ast_sip_create_dialog_uas(const struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pj_status_t *status);


pjsip_dialog *ast_sip_create_dialog_uas_locked(const struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pj_status_t *status);


int ast_sip_create_rdata_with_contact(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port, char *transport_type, const char *local_name, int local_port, const char *contact_uri);



int ast_sip_create_rdata(pjsip_rx_data *rdata, char *packet, const char *src_name, int src_port, char *transport_type, const char *local_name, int local_port);


int ast_sip_create_request(const char *method, struct pjsip_dialog *dlg, struct ast_sip_endpoint *endpoint, const char *uri, struct ast_sip_contact *contact, pjsip_tx_data **tdata);



int ast_sip_send_request(pjsip_tx_data *tdata, struct pjsip_dialog *dlg, struct ast_sip_endpoint *endpoint, void *token, void (*callback)(void *token, pjsip_event *e));



int ast_sip_send_out_of_dialog_request(pjsip_tx_data *tdata, struct ast_sip_endpoint *endpoint, int timeout, void *token, void (*callback)(void *token, pjsip_event *e));



int ast_sip_create_response(const pjsip_rx_data *rdata, int st_code, struct ast_sip_contact *contact, pjsip_tx_data **p_tdata);


int ast_sip_send_response(pjsip_response_addr *res_addr, pjsip_tx_data *tdata, struct ast_sip_endpoint *sip_endpoint);


int ast_sip_send_stateful_response(pjsip_rx_data *rdata, pjsip_tx_data *tdata, struct ast_sip_endpoint *sip_endpoint);


int ast_sip_requires_authentication(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata);


enum ast_sip_check_auth_result ast_sip_check_authentication(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pjsip_tx_data *tdata);


int ast_sip_create_request_with_auth(const struct ast_sip_auth_vector *auths, pjsip_rx_data *challenge, pjsip_tx_data *tdata, pjsip_tx_data **new_request);


struct ast_sip_endpoint *ast_sip_identify_endpoint(pjsip_rx_data *rdata);


char *ast_sip_rdata_get_header_value(pjsip_rx_data *rdata, const pj_str_t str);


int ast_sip_set_outbound_proxy(pjsip_tx_data *tdata, const char *proxy);


int ast_sip_add_header(pjsip_tx_data *tdata, const char *name, const char *value);


pjsip_generic_string_hdr *ast_sip_add_header2(pjsip_tx_data *tdata, const char *name, const char *value);


int ast_sip_add_body(pjsip_tx_data *tdata, const struct ast_sip_body *body);


int ast_sip_add_body_multipart(pjsip_tx_data *tdata, const struct ast_sip_body *bodies[], int num_bodies);


int ast_sip_append_body(pjsip_tx_data *tdata, const char *body_text);


void ast_copy_pj_str(char *dest, const pj_str_t *src, size_t size);


int ast_copy_pj_str2(char **dest, const pj_str_t *src);


struct ast_sip_endpoint *ast_pjsip_rdata_get_endpoint(pjsip_rx_data *rdata);


void ast_sip_add_usereqphone(const struct ast_sip_endpoint *endpoint, pj_pool_t *pool, pjsip_uri *uri);


struct ao2_container *ast_sip_get_endpoints(void);


struct ast_sip_endpoint *ast_sip_default_outbound_endpoint(void);


int ast_sip_retrieve_auths(const struct ast_sip_auth_vector *auths, struct ast_sip_auth **out);


void ast_sip_cleanup_auths(struct ast_sip_auth *auths[], size_t num_auths);

AST_VECTOR(ast_sip_auth_objects_vector, struct ast_sip_auth *);

int ast_sip_retrieve_auths_vector(const struct ast_sip_auth_vector *auth_ids, struct ast_sip_auth_objects_vector *auth_objects);





int ast_sip_is_content_type(pjsip_media_type *content_type, char *type, char *subtype);


void ast_sip_report_invalid_endpoint(const char *name, pjsip_rx_data *rdata);


void ast_sip_report_failed_acl(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, const char *name);


void ast_sip_report_auth_failed_challenge_response(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata);


void ast_sip_report_auth_success(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata);


void ast_sip_report_auth_challenge_sent(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, pjsip_tx_data *tdata);


void ast_sip_report_req_no_support(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, const char* req_type);


void ast_sip_report_mem_limit(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata);

int ast_sip_add_global_request_header(const char *name, const char *value, int replace);
int ast_sip_add_global_response_header(const char *name, const char *value, int replace);


void *ast_sip_dict_get(void *ht, const char *key);





void *ast_sip_dict_set(pj_pool_t* pool, void *ht, const char *key, void *val);





int ast_sip_for_each_contact(const struct ast_sip_aor *aor, ao2_callback_fn on_contact, void *arg);


int ast_sip_contact_to_str(void *object, void *arg, int flags);


int ast_sip_for_each_aor(const char *aors, ao2_callback_fn on_aor, void *arg);


int ast_sip_for_each_auth(const struct ast_sip_auth_vector *array, ao2_callback_fn on_auth, void *arg);


const char *ast_sip_auth_type_to_str(enum ast_sip_auth_type type);


int ast_sip_auths_to_str(const struct ast_sip_auth_vector *auths, char **buf);


struct ast_sip_ami {
	
	struct mansession *s;
	
	const struct message *m;
	
	const char *action_id;
	
	void *arg;
	
	int count;
};


struct ast_str *ast_sip_create_ami_event(const char *event, struct ast_sip_ami *ami);


struct ast_sip_endpoint_formatter {
	
	int (*format_ami)(const struct ast_sip_endpoint *endpoint, struct ast_sip_ami *ami);
	AST_RWLIST_ENTRY(ast_sip_endpoint_formatter) next;
};


void ast_sip_register_endpoint_formatter(struct ast_sip_endpoint_formatter *obj);


void ast_sip_unregister_endpoint_formatter(struct ast_sip_endpoint_formatter *obj);


int ast_sip_sorcery_object_to_ami(const void *obj, struct ast_str **buf);


int ast_sip_format_endpoint_ami(struct ast_sip_endpoint *endpoint, struct ast_sip_ami *ami, int *count);


int ast_sip_format_contact_ami(void *obj, void *arg, int flags);


int ast_sip_format_auths_ami(const struct ast_sip_auth_vector *auths, struct ast_sip_ami *ami);


struct ast_endpoint_snapshot *ast_sip_get_endpoint_snapshot( const struct ast_sip_endpoint *endpoint);


const char *ast_sip_get_device_state(const struct ast_sip_endpoint *endpoint);


int ast_sip_for_each_channel_snapshot(const struct ast_endpoint_snapshot *endpoint_snapshot, ao2_callback_fn on_channel_snapshot, void *arg);



int ast_sip_for_each_channel(const struct ast_sip_endpoint *endpoint, ao2_callback_fn on_channel_snapshot, void *arg);


enum ast_sip_supplement_priority {
	
	AST_SIP_SUPPLEMENT_PRIORITY_FIRST = 0,  AST_SIP_SUPPLEMENT_PRIORITY_CHANNEL = 1000000,  AST_SIP_SUPPLEMENT_PRIORITY_LAST = INT_MAX, };






struct ast_sip_supplement {
	
	const char *method;
	
	enum ast_sip_supplement_priority priority;
	
	int (*incoming_request)(struct ast_sip_endpoint *endpoint, struct pjsip_rx_data *rdata);
	
	void (*incoming_response)(struct ast_sip_endpoint *endpoint, struct pjsip_rx_data *rdata);
	
	void (*outgoing_request)(struct ast_sip_endpoint *endpoint, struct ast_sip_contact *contact, struct pjsip_tx_data *tdata);
	
	void (*outgoing_response)(struct ast_sip_endpoint *endpoint, struct ast_sip_contact *contact, struct pjsip_tx_data *tdata);
	
	AST_LIST_ENTRY(ast_sip_supplement) next;
};


void ast_sip_register_supplement(struct ast_sip_supplement *supplement);


void ast_sip_unregister_supplement(struct ast_sip_supplement *supplement);


unsigned int ast_sip_get_mwi_tps_queue_high(void);


int ast_sip_get_mwi_tps_queue_low(void);


unsigned int ast_sip_get_mwi_disable_initial_unsolicited(void);


unsigned int ast_sip_get_allow_sending_180_after_183(void);


unsigned int ast_sip_get_use_callerid_contact(void);


unsigned int ast_sip_get_norefersub(void);


unsigned int ast_sip_get_ignore_uri_user_options(void);


unsigned int ast_sip_get_send_contact_status_on_update_registration(void);











char *ast_sip_get_debug(void);


char *ast_sip_get_regcontext(void);


char *ast_sip_get_endpoint_identifier_order(void);


char *ast_sip_get_default_voicemail_extension(void);


void ast_sip_get_default_realm(char *realm, size_t size);


void ast_sip_get_default_from_user(char *from_user, size_t size);


unsigned int ast_sip_get_keep_alive_interval(void);


unsigned int ast_sip_get_contact_expiration_check_interval(void);


unsigned int ast_sip_get_disable_multi_domain(void);


unsigned int ast_sip_get_max_initial_qualify_time(void);



const char *ast_sip_get_contact_status_label(const enum ast_sip_contact_status_type status);
const char *ast_sip_get_contact_short_status_label(const enum ast_sip_contact_status_type status);


int ast_sip_failover_request(pjsip_tx_data *tdata);


int ast_sip_get_host_ip(int af, pj_sockaddr *addr);


const char *ast_sip_get_host_ip_string(int af);


long ast_sip_threadpool_queue_size(void);


struct ast_threadpool *ast_sip_threadpool(void);


struct ast_sip_transport_state *ast_sip_get_transport_state(const char *transport_id);


struct ao2_container *ast_sip_get_transport_states(void);


int ast_sip_set_tpselector_from_transport(const struct ast_sip_transport *transport, pjsip_tpselector *selector);


int ast_sip_set_tpselector_from_transport_name(const char *transport_name, pjsip_tpselector *selector);


void ast_sip_tpselector_unref(pjsip_tpselector *selector);


int ast_sip_transport_state_set_transport(const char *transport_name, pjsip_transport *transport);


int ast_sip_transport_state_set_preferred_identity(const char *transport_name, const char *identity);


int ast_sip_transport_state_set_service_routes(const char *transport_name, struct ast_sip_service_route_vector *service_routes);


void ast_sip_message_apply_transport(const char *transport_name, pjsip_tx_data *tdata);


struct ast_sip_service_route_vector *ast_sip_service_route_vector_alloc(void);


void ast_sip_service_route_vector_destroy(struct ast_sip_service_route_vector *service_routes);


void ast_sip_modify_id_header(pj_pool_t *pool, pjsip_fromto_hdr *id_hdr, const struct ast_party_id *id);


void ast_sip_get_unidentified_request_thresholds(unsigned int *count, unsigned int *period, unsigned int *prune_interval);


int ast_sip_get_transport_name(const struct ast_sip_endpoint *endpoint, pjsip_sip_uri *sip_uri, char *buf, size_t buf_len);


int ast_sip_set_tpselector_from_ep_or_uri(const struct ast_sip_endpoint *endpoint, pjsip_sip_uri *sip_uri, pjsip_tpselector *selector);


int ast_sip_dlg_set_transport(const struct ast_sip_endpoint *endpoint, pjsip_dialog *dlg, pjsip_tpselector *selector);


int ast_sip_dtmf_to_str(const enum ast_sip_dtmf_mode dtmf, char *buf, size_t buf_len);


int ast_sip_str_to_dtmf(const char *dtmf_mode);


const char *ast_sip_call_codec_pref_to_str(struct ast_flags pref);


int ast_sip_call_codec_str_to_pref(struct ast_flags *pref, const char *pref_str, int is_outgoing);


typedef void (*ast_transport_monitor_shutdown_cb)(void *data);


typedef int (*ast_transport_monitor_data_matcher)(void *a, void *b);

enum ast_transport_monitor_reg {
	
	AST_TRANSPORT_MONITOR_REG_SUCCESS,  AST_TRANSPORT_MONITOR_REG_REPLACED,  AST_TRANSPORT_MONITOR_REG_NOT_FOUND,  AST_TRANSPORT_MONITOR_REG_FAILED, };








enum ast_transport_monitor_reg ast_sip_transport_monitor_register(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *ao2_data);


enum ast_transport_monitor_reg ast_sip_transport_monitor_register_replace(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *ao2_data, ast_transport_monitor_data_matcher matches);


void ast_sip_transport_monitor_unregister(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *data, ast_transport_monitor_data_matcher matches);


void ast_sip_transport_monitor_unregister_all(ast_transport_monitor_shutdown_cb cb, void *data, ast_transport_monitor_data_matcher matches);


struct ast_sip_tpmgr_state_callback {
	
	pjsip_tp_state_callback cb;
	AST_LIST_ENTRY(ast_sip_tpmgr_state_callback) node;
};


void ast_sip_transport_state_register(struct ast_sip_tpmgr_state_callback *element);


void ast_sip_transport_state_unregister(struct ast_sip_tpmgr_state_callback *element);


int ast_sip_is_uri_sip_sips(pjsip_uri *uri);


int ast_sip_is_allowed_uri(pjsip_uri *uri);


const pj_str_t *ast_sip_pjsip_uri_get_username(pjsip_uri *uri);


const pj_str_t *ast_sip_pjsip_uri_get_hostname(pjsip_uri *uri);


struct pjsip_param *ast_sip_pjsip_uri_get_other_param(pjsip_uri *uri, const pj_str_t *param_str);


unsigned int ast_sip_get_all_codecs_on_empty_reinvite(void);


