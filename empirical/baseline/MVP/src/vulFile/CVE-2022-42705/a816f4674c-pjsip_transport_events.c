

















struct transport_monitor_notifier {
	
	ast_transport_monitor_shutdown_cb cb;
	
	void *data;
};


struct transport_monitor {
	
	pjsip_transport *transport;
	
	AST_VECTOR(, struct transport_monitor_notifier) monitors;
};


static AO2_GLOBAL_OBJ_STATIC(active_transports);


static pjsip_tp_state_callback tpmgr_state_callback;


static AST_RWLIST_HEAD(, ast_sip_tpmgr_state_callback) transport_state_list;



AO2_STRING_FIELD_HASH_FN(transport_monitor, transport->obj_name);


AO2_STRING_FIELD_CMP_FN(transport_monitor, transport->obj_name);

static const char *transport_state2str(pjsip_transport_state state)
{
	const char *name;

	switch (state) {
	case PJSIP_TP_STATE_CONNECTED:
		name = "CONNECTED";
		break;
	case PJSIP_TP_STATE_DISCONNECTED:
		name = "DISCONNECTED";
		break;
	case PJSIP_TP_STATE_SHUTDOWN:
		name = "SHUTDOWN";
		break;
	case PJSIP_TP_STATE_DESTROY:
		name = "DESTROY";
		break;
	default:
		
		ast_assert(0);
		name = "<unknown>";
		break;
	}
	return name;
}

static void transport_monitor_dtor(void *vdoomed)
{
	struct transport_monitor *monitored = vdoomed;
	int idx;

	for (idx = AST_VECTOR_SIZE(&monitored->monitors); idx--;) {
		struct transport_monitor_notifier *notifier;

		notifier = AST_VECTOR_GET_ADDR(&monitored->monitors, idx);
		ao2_cleanup(notifier->data);
	}
	AST_VECTOR_FREE(&monitored->monitors);
}


static void transport_state_do_reg_callbacks(struct ao2_container *transports, pjsip_transport *transport)
{
	struct transport_monitor *monitored;

	monitored = ao2_find(transports, transport->obj_name, OBJ_SEARCH_KEY | OBJ_UNLINK);
	if (monitored) {
		int idx;

		for (idx = AST_VECTOR_SIZE(&monitored->monitors); idx--;) {
			struct transport_monitor_notifier *notifier;

			notifier = AST_VECTOR_GET_ADDR(&monitored->monitors, idx);
			ast_debug(3, "running callback %p(%p) for transport %s\n", notifier->cb, notifier->data, transport->obj_name);
			notifier->cb(notifier->data);
		}
		ao2_ref(monitored, -1);
	}
}

static void verify_log_result(int log_level, const pjsip_transport *transport, pj_uint32_t verify_status)
{
	const char *status[32];
	unsigned int count;
	unsigned int i;

	count = ARRAY_LEN(status);

	if (pj_ssl_cert_get_verify_status_strings(verify_status, status, &count) != PJ_SUCCESS) {
		ast_log(LOG_ERROR, "Error retrieving certificate verification result(s)\n");
		return;
	}

	for (i = 0; i < count; ++i) {
		ast_log(log_level, _A_, "Transport '%s' to remote '%.*s' - %s\n", transport->factory->info, (int)pj_strlen(&transport->remote_name.host), pj_strbuf(&transport->remote_name.host), status[i]);

	}
}

static int verify_cert_name(const pj_str_t *local, const pj_str_t *remote)
{
	const char *p;
	pj_ssize_t size;

	ast_debug(3, "Verify certificate name: local = %.*s, remote = %.*s\n", (unsigned int)pj_strlen(local), pj_strbuf(local), (unsigned int)pj_strlen(remote), pj_strbuf(remote));


	if (!pj_stricmp(remote, local)) {
		return 1;
	}

	if (pj_strnicmp2(remote, "*.", 2)) {
		return 0;
	}

	p = pj_strchr(local, '.');
	if (!p) {
		return 0;
	}

	size = pj_strbuf(local) + pj_strlen(local) - ++p;

	return size == pj_strlen(remote) - 2 ? !pj_memcmp(pj_strbuf(remote) + 2,  p, size) : 0;
}

static int verify_cert_names(const pj_str_t *host, const pj_ssl_cert_info *remote)
{
	unsigned int i;

	for (i = 0; i < remote->subj_alt_name.cnt; ++i) {
		
		if (remote->subj_alt_name.entry[i].type == PJ_SSL_CERT_NAME_DNS && verify_cert_name(host, &remote->subj_alt_name.entry[i].name)) {
			return 1;
		}
	}

	return verify_cert_name(host, &remote->subject.cn);
}

static int transport_tls_verify(const pjsip_transport *transport, const pjsip_tls_state_info *state_info)
{
	pj_uint32_t verify_status;
	const struct ast_sip_transport_state *state;

	if (transport->dir == PJSIP_TP_DIR_INCOMING) {
		return 1;
	}

	
	ast_assert(!ast_strlen_zero(transport->factory->info));

	state = ast_sip_get_transport_state(transport->factory->info);
	if (!state) {
		
		ast_log(LOG_ERROR, "Transport state not found for '%s'\n", transport->factory->info);
		return 0;
	}

	verify_status = state_info->ssl_sock_info->verify_status;

	
	if (state->allow_wildcard_certs && (verify_status & PJ_SSL_CERT_EIDENTITY_NOT_MATCH)) {
		if (verify_cert_names(&transport->remote_name.host, state_info->ssl_sock_info->remote_cert_info)) {
			
			verify_status &= ~PJ_SSL_CERT_EIDENTITY_NOT_MATCH;
		}
	}

	if (state->verify_server && verify_status != PJ_SSL_CERT_ESUCCESS) {
		verify_log_result(__LOG_ERROR, transport, verify_status);
		return 0;
	}

	verify_log_result(__LOG_NOTICE, transport, verify_status);
	return 1;
}


static void transport_state_callback(pjsip_transport *transport, pjsip_transport_state state, const pjsip_transport_state_info *info)
{
	struct ao2_container *transports;

	
	if (PJSIP_TRANSPORT_IS_RELIABLE(transport)
		&& (transports = ao2_global_obj_ref(active_transports))) {
		struct transport_monitor *monitored;

		ast_debug(3, "Reliable transport '%s' state:%s\n", transport->obj_name, transport_state2str(state));
		switch (state) {
		case PJSIP_TP_STATE_CONNECTED:
			if (PJSIP_TRANSPORT_IS_SECURE(transport) && !transport_tls_verify(transport, info->ext_info)) {
				pjsip_transport_shutdown(transport);
				return;
			}

			monitored = ao2_alloc_options(sizeof(*monitored), transport_monitor_dtor, AO2_ALLOC_OPT_LOCK_NOLOCK);
			if (!monitored) {
				break;
			}
			monitored->transport = transport;
			if (AST_VECTOR_INIT(&monitored->monitors, 5)) {
				ao2_ref(monitored, -1);
				break;
			}

			ao2_link(transports, monitored);
			ao2_ref(monitored, -1);
			break;
		case PJSIP_TP_STATE_DISCONNECTED:
			if (!transport->is_shutdown) {
				pjsip_transport_shutdown(transport);
			}
			transport_state_do_reg_callbacks(transports, transport);
			break;
		case PJSIP_TP_STATE_SHUTDOWN:
			
			transport->is_shutdown = PJ_TRUE;

			transport_state_do_reg_callbacks(transports, transport);
			break;
		case PJSIP_TP_STATE_DESTROY:
			transport_state_do_reg_callbacks(transports, transport);
			break;
		default:
			
			ast_assert(0);
			break;
		}

		ao2_ref(transports, -1);
	}

	
	if (!AST_LIST_EMPTY(&transport_state_list)) {
		struct ast_sip_tpmgr_state_callback *tpmgr_notifier;

		AST_RWLIST_RDLOCK(&transport_state_list);
		AST_LIST_TRAVERSE(&transport_state_list, tpmgr_notifier, node) {
			tpmgr_notifier->cb(transport, state, info);
		}
		AST_RWLIST_UNLOCK(&transport_state_list);
	}

	
	if (tpmgr_state_callback) {
		tpmgr_state_callback(transport, state, info);
	}
}

struct callback_data {
	ast_transport_monitor_shutdown_cb cb;
	void *data;
	ast_transport_monitor_data_matcher matches;
};

static int transport_monitor_unregister_cb(void *obj, void *arg, int flags)
{
	struct transport_monitor *monitored = obj;
	struct callback_data *cb_data = arg;
	int idx;

	for (idx = AST_VECTOR_SIZE(&monitored->monitors); idx--;) {
		struct transport_monitor_notifier *notifier;

		notifier = AST_VECTOR_GET_ADDR(&monitored->monitors, idx);
		if (notifier->cb == cb_data->cb && (!cb_data->data || cb_data->matches(cb_data->data, notifier->data))) {
			ao2_cleanup(notifier->data);
			AST_VECTOR_REMOVE_UNORDERED(&monitored->monitors, idx);
			ast_debug(3, "Unregistered monitor %p(%p) from transport %s\n", notifier->cb, notifier->data, monitored->transport->obj_name);
		}
	}
	return 0;
}

static int ptr_matcher(void *a, void *b)
{
	return a == b;
}

void ast_sip_transport_monitor_unregister_all(ast_transport_monitor_shutdown_cb cb, void *data, ast_transport_monitor_data_matcher matches)
{
	struct ao2_container *transports;
	struct callback_data cb_data = {
		.cb = cb, .data = data, .matches = matches ?: ptr_matcher, };



	ast_assert(cb != NULL);

	transports = ao2_global_obj_ref(active_transports);
	if (!transports) {
		return;
	}
	ao2_callback(transports, OBJ_MULTIPLE | OBJ_NODATA, transport_monitor_unregister_cb, &cb_data);
	ao2_ref(transports, -1);
}

void ast_sip_transport_monitor_unregister(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *data, ast_transport_monitor_data_matcher matches)
{
	struct ao2_container *transports;
	struct transport_monitor *monitored;

	ast_assert(transport != NULL && cb != NULL);

	transports = ao2_global_obj_ref(active_transports);
	if (!transports) {
		return;
	}

	ao2_lock(transports);
	monitored = ao2_find(transports, transport->obj_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
	if (monitored) {
		struct callback_data cb_data = {
			.cb = cb, .data = data, .matches = matches ?: ptr_matcher, };



		transport_monitor_unregister_cb(monitored, &cb_data, 0);
		ao2_ref(monitored, -1);
	}
	ao2_unlock(transports);
	ao2_ref(transports, -1);
}

enum ast_transport_monitor_reg ast_sip_transport_monitor_register(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *ao2_data)
{
	return ast_sip_transport_monitor_register_replace(transport, cb, ao2_data, NULL);
}

enum ast_transport_monitor_reg ast_sip_transport_monitor_register_replace(pjsip_transport *transport, ast_transport_monitor_shutdown_cb cb, void *ao2_data, ast_transport_monitor_data_matcher matches)
{
	struct ao2_container *transports;
	struct transport_monitor *monitored;
	enum ast_transport_monitor_reg res = AST_TRANSPORT_MONITOR_REG_NOT_FOUND;

	ast_assert(transport != NULL && cb != NULL);

	transports = ao2_global_obj_ref(active_transports);
	if (!transports) {
		return res;
	}

	ao2_lock(transports);
	monitored = ao2_find(transports, transport->obj_name, OBJ_SEARCH_KEY | OBJ_NOLOCK);
	if (monitored) {
		struct transport_monitor_notifier new_monitor;
		struct callback_data cb_data = {
			.cb = cb, .data = ao2_data, .matches = matches ?: ptr_matcher, };



		transport_monitor_unregister_cb(monitored, &cb_data, 0);

		
		new_monitor.cb = cb;
		new_monitor.data = ao2_bump(ao2_data);
		if (AST_VECTOR_APPEND(&monitored->monitors, new_monitor)) {
			ao2_cleanup(ao2_data);
			res = AST_TRANSPORT_MONITOR_REG_FAILED;
			ast_debug(3, "Register monitor %p(%p) to transport %s FAILED\n", cb, ao2_data, transport->obj_name);
		} else {
			res = AST_TRANSPORT_MONITOR_REG_SUCCESS;
			ast_debug(3, "Registered monitor %p(%p) to transport %s\n", cb, ao2_data, transport->obj_name);
		}

		ao2_ref(monitored, -1);
	}
	ao2_unlock(transports);
	ao2_ref(transports, -1);
	return res;
}

void ast_sip_transport_state_unregister(struct ast_sip_tpmgr_state_callback *element)
{
	AST_RWLIST_WRLOCK(&transport_state_list);
	AST_LIST_REMOVE(&transport_state_list, element, node);
	AST_RWLIST_UNLOCK(&transport_state_list);
}

void ast_sip_transport_state_register(struct ast_sip_tpmgr_state_callback *element)
{
	struct ast_sip_tpmgr_state_callback *tpmgr_notifier;

	AST_RWLIST_WRLOCK(&transport_state_list);
	AST_LIST_TRAVERSE(&transport_state_list, tpmgr_notifier, node) {
		if (element == tpmgr_notifier) {
			
			AST_RWLIST_UNLOCK(&transport_state_list);
			return;
		}
	}
	AST_LIST_INSERT_HEAD(&transport_state_list, element, node);
	AST_RWLIST_UNLOCK(&transport_state_list);
}

void ast_sip_destroy_transport_events(void)
{
	pjsip_tpmgr *tpmgr;

	tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
	if (tpmgr) {
		pjsip_tpmgr_set_state_cb(tpmgr, tpmgr_state_callback);
	}

	ao2_global_obj_release(active_transports);
}

int ast_sip_initialize_transport_events(void)
{
	pjsip_tpmgr *tpmgr;
	struct ao2_container *transports;

	tpmgr = pjsip_endpt_get_tpmgr(ast_sip_get_pjsip_endpoint());
	if (!tpmgr) {
		return -1;
	}

	transports = ao2_container_alloc_hash(AO2_ALLOC_OPT_LOCK_MUTEX, 0, ACTIVE_TRANSPORTS_BUCKETS, transport_monitor_hash_fn, NULL, transport_monitor_cmp_fn);

	if (!transports) {
		return -1;
	}
	ao2_global_obj_replace_unref(active_transports, transports);
	ao2_ref(transports, -1);

	tpmgr_state_callback = pjsip_tpmgr_get_state_cb(tpmgr);
	pjsip_tpmgr_set_state_cb(tpmgr, &transport_state_callback);

	return 0;
}
