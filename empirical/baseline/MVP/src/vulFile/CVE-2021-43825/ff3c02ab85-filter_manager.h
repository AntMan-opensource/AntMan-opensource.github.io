





























namespace Envoy {
namespace Http {

class FilterManager;

class SkipAction : public Matcher::ActionBase< envoy::extensions::filters::common::matcher::action::v3::SkipFilter> {};

struct ActiveStreamFilterBase;

using MatchDataUpdateFunc = std::function<void(Matching::HttpMatchingDataImpl&)>;

class FilterMatchState {
public:
  FilterMatchState(Matcher::MatchTreeSharedPtr<HttpMatchingData> match_tree, Matching::HttpMatchingDataImplSharedPtr matching_data)
      : match_tree_(std::move(match_tree)), matching_data_(std::move(matching_data)), match_tree_evaluated_(false), skip_filter_(false) {}

  void evaluateMatchTreeWithNewData(MatchDataUpdateFunc update_func);

  StreamFilterBase* filter_{};

  bool skipFilter() const { return skip_filter_; }

private:
  Matcher::MatchTreeSharedPtr<HttpMatchingData> match_tree_;
  Matching::HttpMatchingDataImplSharedPtr matching_data_;
  bool match_tree_evaluated_ : 1;
  bool skip_filter_ : 1;
};

using FilterMatchStateSharedPtr = std::shared_ptr<FilterMatchState>;

class SkipActionFactory : public Matcher::ActionFactory<Matching::HttpFilterActionContext> {
public:
  std::string name() const override { return "skip"; }
  Matcher::ActionFactoryCb createActionFactoryCb(const Protobuf::Message&, Matching::HttpFilterActionContext&, ProtobufMessage::ValidationVisitor&) override {

    return []() { return std::make_unique<SkipAction>(); };
  }
  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
    return std::make_unique<envoy::extensions::filters::common::matcher::action::v3::SkipFilter>();
  }
};


struct ActiveStreamFilterBase : public virtual StreamFilterCallbacks, Logger::Loggable<Logger::Id::http> {
  ActiveStreamFilterBase(FilterManager& parent, bool dual_filter, FilterMatchStateSharedPtr match_state)
      : parent_(parent), iteration_state_(IterationState::Continue), filter_match_state_(std::move(match_state)), iterate_from_current_filter_(false), headers_continued_(false), continued_1xx_headers_(false), end_stream_(false), dual_filter_(dual_filter), decode_headers_called_(false), encode_headers_called_(false) {}



  
  
  
  bool commonHandleAfter1xxHeadersCallback(FilterHeadersStatus status);
  bool commonHandleAfterHeadersCallback(FilterHeadersStatus status, bool& end_stream);
  bool commonHandleAfterDataCallback(FilterDataStatus status, Buffer::Instance& provided_data, bool& buffer_was_streaming);
  bool commonHandleAfterTrailersCallback(FilterTrailersStatus status);

  
  void commonHandleBufferData(Buffer::Instance& provided_data);

  
  
  void commonBufferDataIfStopAll(Buffer::Instance& provided_data, bool& buffer_was_streaming);

  void commonContinue();
  virtual bool canContinue() PURE;
  virtual Buffer::InstancePtr createBuffer() PURE;
  virtual Buffer::InstancePtr& bufferedData() PURE;
  virtual bool complete() PURE;
  virtual bool has1xxheaders() PURE;
  virtual void do1xxHeaders() PURE;
  virtual void doHeaders(bool end_stream) PURE;
  virtual void doData(bool end_stream) PURE;
  virtual void doTrailers() PURE;
  virtual bool hasTrailers() PURE;
  virtual void doMetadata() PURE;
  
  virtual void handleMetadataAfterHeadersCallback() PURE;

  virtual void onMatchCallback(const Matcher::Action& action) PURE;

  
  const Network::Connection* connection() override;
  Event::Dispatcher& dispatcher() override;
  void resetStream() override;
  Router::RouteConstSharedPtr route() override;
  Router::RouteConstSharedPtr route(const Router::RouteCallback& cb) override;
  void setRoute(Router::RouteConstSharedPtr route) override;
  Upstream::ClusterInfoConstSharedPtr clusterInfo() override;
  void clearRouteCache() override;
  uint64_t streamId() const override;
  StreamInfo::StreamInfo& streamInfo() override;
  Tracing::Span& activeSpan() override;
  Tracing::Config& tracingConfig() override;
  const ScopeTrackedObject& scope() override;
  void restoreContextOnContinue(ScopeTrackedObjectStack& tracked_object_stack) override;
  void resetIdleTimer() override;

  
  bool canIterate() { return iteration_state_ == IterationState::Continue; }
  bool stoppedAll() {
    return iteration_state_ == IterationState::StopAllBuffer || iteration_state_ == IterationState::StopAllWatermark;
  }
  void allowIteration() {
    ASSERT(iteration_state_ != IterationState::Continue);
    iteration_state_ = IterationState::Continue;
  }
  MetadataMapVector* getSavedRequestMetadata() {
    if (saved_request_metadata_ == nullptr) {
      saved_request_metadata_ = std::make_unique<MetadataMapVector>();
    }
    return saved_request_metadata_.get();
  }
  MetadataMapVector* getSavedResponseMetadata() {
    if (saved_response_metadata_ == nullptr) {
      saved_response_metadata_ = std::make_unique<MetadataMapVector>();
    }
    return saved_response_metadata_.get();
  }
  bool skipFilter() const { return filter_match_state_ && filter_match_state_->skipFilter(); }
  void maybeEvaluateMatchTreeWithNewData(MatchDataUpdateFunc update_func) {
    if (filter_match_state_) {
      filter_match_state_->evaluateMatchTreeWithNewData(update_func);
    }
  }

  
  
  
  
  std::unique_ptr<MetadataMapVector> saved_request_metadata_{nullptr};
  std::unique_ptr<MetadataMapVector> saved_response_metadata_{nullptr};
  
  enum class IterationState {
    Continue,             StopSingleIteration, StopAllBuffer,  StopAllWatermark,  };





  FilterManager& parent_;
  IterationState iteration_state_;

  FilterMatchStateSharedPtr filter_match_state_;
  
  
  
  
  bool iterate_from_current_filter_ : 1;
  bool headers_continued_ : 1;
  bool continued_1xx_headers_ : 1;
  
  bool end_stream_ : 1;
  const bool dual_filter_ : 1;
  bool decode_headers_called_ : 1;
  bool encode_headers_called_ : 1;

  friend FilterMatchState;
};


struct ActiveStreamDecoderFilter : public ActiveStreamFilterBase, public StreamDecoderFilterCallbacks, LinkedObject<ActiveStreamDecoderFilter> {

  ActiveStreamDecoderFilter(FilterManager& parent, StreamDecoderFilterSharedPtr filter, FilterMatchStateSharedPtr match_state, bool dual_filter)
      : ActiveStreamFilterBase(parent, dual_filter, std::move(match_state)), handle_(filter) {}

  
  bool canContinue() override;
  Buffer::InstancePtr createBuffer() override;
  Buffer::InstancePtr& bufferedData() override;
  bool complete() override;
  bool has1xxheaders() override { return false; }
  void do1xxHeaders() override { IS_ENVOY_BUG("unexpected 1xx headers"); }
  void doHeaders(bool end_stream) override;
  void doData(bool end_stream) override;
  void doMetadata() override {
    if (saved_request_metadata_ != nullptr) {
      drainSavedRequestMetadata();
    }
  }
  void doTrailers() override;
  bool hasTrailers() override;

  void drainSavedRequestMetadata();
  
  void handleMetadataAfterHeadersCallback() override;
  void onMatchCallback(const Matcher::Action& action) override {
    handle_->onMatchCallback(std::move(action));
  }

  
  void addDecodedData(Buffer::Instance& data, bool streaming) override;
  void injectDecodedDataToFilterChain(Buffer::Instance& data, bool end_stream) override;
  RequestTrailerMap& addDecodedTrailers() override;
  MetadataMapVector& addDecodedMetadata() override;
  void continueDecoding() override;
  const Buffer::Instance* decodingBuffer() override;

  void modifyDecodingBuffer(std::function<void(Buffer::Instance&)> callback) override;

  void sendLocalReply(Code code, absl::string_view body, std::function<void(ResponseHeaderMap& headers)> modify_headers, const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) override;


  void encode1xxHeaders(ResponseHeaderMapPtr&& headers) override;
  ResponseHeaderMapOptRef informationalHeaders() const override;
  void encodeHeaders(ResponseHeaderMapPtr&& headers, bool end_stream, absl::string_view details) override;
  ResponseHeaderMapOptRef responseHeaders() const override;
  void encodeData(Buffer::Instance& data, bool end_stream) override;
  void encodeTrailers(ResponseTrailerMapPtr&& trailers) override;
  ResponseTrailerMapOptRef responseTrailers() const override;
  void encodeMetadata(MetadataMapPtr&& metadata_map_ptr) override;
  void onDecoderFilterAboveWriteBufferHighWatermark() override;
  void onDecoderFilterBelowWriteBufferLowWatermark() override;
  void addDownstreamWatermarkCallbacks(DownstreamWatermarkCallbacks& watermark_callbacks) override;
  void removeDownstreamWatermarkCallbacks(DownstreamWatermarkCallbacks& watermark_callbacks) override;
  void setDecoderBufferLimit(uint32_t limit) override;
  uint32_t decoderBufferLimit() override;
  bool recreateStream(const Http::ResponseHeaderMap* original_response_headers) override;

  void addUpstreamSocketOptions(const Network::Socket::OptionsSharedPtr& options) override;

  Network::Socket::OptionsSharedPtr getUpstreamSocketOptions() const override;
  Buffer::BufferMemoryAccountSharedPtr account() const override;
  void setUpstreamOverrideHost(absl::string_view host) override;
  absl::optional<absl::string_view> upstreamOverrideHost() const override;

  
  
  
  FilterHeadersStatus decodeHeaders(RequestHeaderMap& headers, bool end_stream) {
    is_grpc_request_ = Grpc::Common::isGrpcRequestHeaders(headers);
    FilterHeadersStatus status = handle_->decodeHeaders(headers, end_stream);
    return status;
  }

  void requestDataTooLarge();
  void requestDataDrained();

  void requestRouteConfigUpdate( Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) override;
  absl::optional<Router::ConfigConstSharedPtr> routeConfig();

  StreamDecoderFilterSharedPtr handle_;
  bool is_grpc_request_{};
};

using ActiveStreamDecoderFilterPtr = std::unique_ptr<ActiveStreamDecoderFilter>;


struct ActiveStreamEncoderFilter : public ActiveStreamFilterBase, public StreamEncoderFilterCallbacks, LinkedObject<ActiveStreamEncoderFilter> {

  ActiveStreamEncoderFilter(FilterManager& parent, StreamEncoderFilterSharedPtr filter, FilterMatchStateSharedPtr match_state, bool dual_filter)
      : ActiveStreamFilterBase(parent, dual_filter, std::move(match_state)), handle_(filter) {}

  
  bool canContinue() override { return true; }
  Buffer::InstancePtr createBuffer() override;
  Buffer::InstancePtr& bufferedData() override;
  bool complete() override;
  bool has1xxheaders() override;
  void do1xxHeaders() override;
  void doHeaders(bool end_stream) override;
  void doData(bool end_stream) override;
  void drainSavedResponseMetadata();
  void handleMetadataAfterHeadersCallback() override;
  void onMatchCallback(const Matcher::Action& action) override { handle_->onMatchCallback(action); }

  void doMetadata() override {
    if (saved_response_metadata_ != nullptr) {
      drainSavedResponseMetadata();
    }
  }
  void doTrailers() override;
  bool hasTrailers() override;

  
  void addEncodedData(Buffer::Instance& data, bool streaming) override;
  void injectEncodedDataToFilterChain(Buffer::Instance& data, bool end_stream) override;
  ResponseTrailerMap& addEncodedTrailers() override;
  void addEncodedMetadata(MetadataMapPtr&& metadata_map) override;
  void onEncoderFilterAboveWriteBufferHighWatermark() override;
  void onEncoderFilterBelowWriteBufferLowWatermark() override;
  void setEncoderBufferLimit(uint32_t limit) override;
  uint32_t encoderBufferLimit() override;
  void continueEncoding() override;
  const Buffer::Instance* encodingBuffer() override;
  void modifyEncodingBuffer(std::function<void(Buffer::Instance&)> callback) override;
  void sendLocalReply(Code code, absl::string_view body, std::function<void(ResponseHeaderMap& headers)> modify_headers, const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) override;


  Http1StreamEncoderOptionsOptRef http1StreamEncoderOptions() override;

  void responseDataTooLarge();
  void responseDataDrained();

  StreamEncoderFilterSharedPtr handle_;
};

using ActiveStreamEncoderFilterPtr = std::unique_ptr<ActiveStreamEncoderFilter>;


class FilterManagerCallbacks {
public:
  virtual ~FilterManagerCallbacks() = default;

  
  virtual void encodeHeaders(ResponseHeaderMap& response_headers, bool end_stream) PURE;

  
  virtual void encode1xxHeaders(ResponseHeaderMap& response_headers) PURE;

  
  virtual void encodeData(Buffer::Instance& data, bool end_stream) PURE;

  
  virtual void encodeTrailers(ResponseTrailerMap& trailers) PURE;

  
  virtual void encodeMetadata(MetadataMapVector& metadata) PURE;

  
  virtual void setRequestTrailers(RequestTrailerMapPtr&& request_trailers) PURE;

  
  virtual void setInformationalHeaders(ResponseHeaderMapPtr&& response_headers) PURE;

  
  virtual void setResponseHeaders(ResponseHeaderMapPtr&& response_headers) PURE;

  
  virtual void setResponseTrailers(ResponseTrailerMapPtr&& response_trailers) PURE;

  
  virtual void chargeStats(const ResponseHeaderMap& headers) PURE;

  
  

  
  virtual RequestHeaderMapOptRef requestHeaders() PURE;

  
  virtual RequestTrailerMapOptRef requestTrailers() PURE;

  
  virtual ResponseHeaderMapOptRef informationalHeaders() PURE;

  
  virtual ResponseHeaderMapOptRef responseHeaders() PURE;

  
  virtual ResponseTrailerMapOptRef responseTrailers() PURE;

  
  virtual void endStream() PURE;

  
  virtual void onDecoderFilterBelowWriteBufferLowWatermark() PURE;

  
  virtual void onDecoderFilterAboveWriteBufferHighWatermark() PURE;

  
  virtual void upgradeFilterChainCreated() PURE;

  
  virtual void disarmRequestTimeout() PURE;

  
  virtual void resetIdleTimer() PURE;

  
  virtual void recreateStream(StreamInfo::FilterStateSharedPtr filter_state) PURE;

  
  virtual void resetStream() PURE;

  
  virtual const Router::RouteEntry::UpgradeMap* upgradeMap() PURE;

  
  virtual Upstream::ClusterInfoConstSharedPtr clusterInfo() PURE;

  
  virtual Router::RouteConstSharedPtr route(const Router::RouteCallback& cb) PURE;

  
  virtual void setRoute(Router::RouteConstSharedPtr route) PURE;

  
  virtual void clearRouteCache() PURE;

  
  virtual absl::optional<Router::ConfigConstSharedPtr> routeConfig() PURE;

  
  virtual void requestRouteConfigUpdate(Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) PURE;

  
  virtual Tracing::Span& activeSpan() PURE;

  
  
  
  virtual void onResponseDataTooLarge() PURE;

  
  virtual void onRequestDataTooLarge() PURE;

  
  virtual Http1StreamEncoderOptionsOptRef http1StreamEncoderOptions() PURE;

  
  virtual void onLocalReply(Code code) PURE;

  
  virtual Tracing::Config& tracingConfig() PURE;

  
  virtual const ScopeTrackedObject& scope() PURE;
};


class OverridableRemoteConnectionInfoSetterStreamInfo : public StreamInfo::StreamInfoImpl, private Network::ConnectionInfoProvider {
public:
  using StreamInfoImpl::StreamInfoImpl;

  void setDownstreamRemoteAddress( const Network::Address::InstanceConstSharedPtr& downstream_remote_address) {
    
    
    
    
    overridden_downstream_remote_address_ = downstream_remote_address;
  }

  
  const Network::ConnectionInfoProvider& downstreamAddressProvider() const override {
    return *this;
  }

  
  const Network::Address::InstanceConstSharedPtr& localAddress() const override {
    return StreamInfoImpl::downstreamAddressProvider().localAddress();
  }
  bool localAddressRestored() const override {
    return StreamInfoImpl::downstreamAddressProvider().localAddressRestored();
  }
  const Network::Address::InstanceConstSharedPtr& remoteAddress() const override {
    return overridden_downstream_remote_address_ != nullptr ? overridden_downstream_remote_address_ : StreamInfoImpl::downstreamAddressProvider().remoteAddress();

  }
  const Network::Address::InstanceConstSharedPtr& directRemoteAddress() const override {
    return StreamInfoImpl::downstreamAddressProvider().directRemoteAddress();
  }
  absl::string_view requestedServerName() const override {
    return StreamInfoImpl::downstreamAddressProvider().requestedServerName();
  }
  absl::optional<uint64_t> connectionID() const override {
    return StreamInfoImpl::downstreamAddressProvider().connectionID();
  }
  absl::optional<absl::string_view> interfaceName() const override {
    return StreamInfoImpl::downstreamAddressProvider().interfaceName();
  }
  Ssl::ConnectionInfoConstSharedPtr sslConnection() const override {
    return StreamInfoImpl::downstreamAddressProvider().sslConnection();
  }
  void dumpState(std::ostream& os, int indent_level) const override {
    StreamInfoImpl::dumpState(os, indent_level);

    const char* spaces = spacesForLevel(indent_level);
    os << spaces << "OverridableRemoteConnectionInfoSetterStreamInfo " << this << DUMP_MEMBER_AS(remoteAddress(), remoteAddress()->asStringView())
       << DUMP_MEMBER_AS(directRemoteAddress(), directRemoteAddress()->asStringView())
       << DUMP_MEMBER_AS(localAddress(), localAddress()->asStringView()) << "\n";
  }
  absl::string_view ja3Hash() const override {
    return StreamInfoImpl::downstreamAddressProvider().ja3Hash();
  }

private:
  Network::Address::InstanceConstSharedPtr overridden_downstream_remote_address_;
};


class FilterManager : public ScopeTrackedObject, FilterChainFactoryCallbacks, Logger::Loggable<Logger::Id::http> {

public:
  FilterManager(FilterManagerCallbacks& filter_manager_callbacks, Event::Dispatcher& dispatcher, const Network::Connection& connection, uint64_t stream_id, Buffer::BufferMemoryAccountSharedPtr account, bool proxy_100_continue, uint32_t buffer_limit, FilterChainFactory& filter_chain_factory, const LocalReply::LocalReply& local_reply, Http::Protocol protocol, TimeSource& time_source, StreamInfo::FilterStateSharedPtr parent_filter_state, StreamInfo::FilterState::LifeSpan filter_state_life_span)





      : filter_manager_callbacks_(filter_manager_callbacks), dispatcher_(dispatcher), connection_(connection), stream_id_(stream_id), account_(std::move(account)), proxy_100_continue_(proxy_100_continue), buffer_limit_(buffer_limit), filter_chain_factory_(filter_chain_factory), local_reply_(local_reply), stream_info_(protocol, time_source, connection.connectionInfoProviderSharedPtr(), parent_filter_state, filter_state_life_span) {}




  ~FilterManager() override {
    ASSERT(state_.destroyed_);
    ASSERT(state_.filter_call_state_ == 0);
  }

  
  void dumpState(std::ostream& os, int indent_level = 0) const override {
    const char* spaces = spacesForLevel(indent_level);
    os << spaces << "FilterManager " << this << DUMP_MEMBER(state_.has_1xx_headers_) << "\n";

    DUMP_DETAILS(filter_manager_callbacks_.requestHeaders());
    DUMP_DETAILS(filter_manager_callbacks_.requestTrailers());
    DUMP_DETAILS(filter_manager_callbacks_.responseHeaders());
    DUMP_DETAILS(filter_manager_callbacks_.responseTrailers());
    DUMP_DETAILS(&stream_info_);
  }

  
  Event::Dispatcher& dispatcher() override { return dispatcher_; }
  void addStreamDecoderFilter(StreamDecoderFilterSharedPtr filter) override {
    addStreamDecoderFilterWorker(filter, nullptr, false);
    filters_.push_back(filter.get());
  }
  void addStreamDecoderFilter(StreamDecoderFilterSharedPtr filter, Matcher::MatchTreeSharedPtr<HttpMatchingData> match_tree) override {
    if (match_tree) {
      addStreamDecoderFilterWorker( filter, std::make_shared<FilterMatchState>(std::move(match_tree), std::make_shared<Matching::HttpMatchingDataImpl>()), false);



      return;
    }

    addStreamDecoderFilterWorker(filter, nullptr, false);
  }
  void addStreamEncoderFilter(StreamEncoderFilterSharedPtr filter) override {
    addStreamEncoderFilterWorker(filter, nullptr, false);
    filters_.push_back(filter.get());
  }
  void addStreamEncoderFilter(StreamEncoderFilterSharedPtr filter, Matcher::MatchTreeSharedPtr<HttpMatchingData> match_tree) override {
    if (match_tree) {
      addStreamEncoderFilterWorker( filter, std::make_shared<FilterMatchState>(std::move(match_tree), std::make_shared<Matching::HttpMatchingDataImpl>()), false);



      return;
    }

    addStreamEncoderFilterWorker(filter, nullptr, false);
  }
  void addStreamFilter(StreamFilterSharedPtr filter) override {
    addStreamDecoderFilterWorker(filter, nullptr, true);
    addStreamEncoderFilterWorker(filter, nullptr, true);
    StreamDecoderFilter* decoder_filter = filter.get();
    filters_.push_back(decoder_filter);
  }
  void addStreamFilter(StreamFilterSharedPtr filter, Matcher::MatchTreeSharedPtr<HttpMatchingData> match_tree) override {
    
    
    
    
    if (match_tree) {
      auto matching_state = std::make_shared<FilterMatchState>( std::move(match_tree), std::make_shared<Matching::HttpMatchingDataImpl>());
      addStreamDecoderFilterWorker(filter, matching_state, true);
      addStreamEncoderFilterWorker(filter, std::move(matching_state), true);
      return;
    }

    addStreamDecoderFilterWorker(filter, nullptr, true);
    addStreamEncoderFilterWorker(filter, nullptr, true);
  }
  void addAccessLogHandler(AccessLog::InstanceSharedPtr handler) override;

  void log() {
    RequestHeaderMap* request_headers = nullptr;
    if (filter_manager_callbacks_.requestHeaders()) {
      request_headers = filter_manager_callbacks_.requestHeaders().ptr();
    }
    ResponseHeaderMap* response_headers = nullptr;
    if (filter_manager_callbacks_.responseHeaders()) {
      response_headers = filter_manager_callbacks_.responseHeaders().ptr();
    }
    ResponseTrailerMap* response_trailers = nullptr;
    if (filter_manager_callbacks_.responseTrailers()) {
      response_trailers = filter_manager_callbacks_.responseTrailers().ptr();
    }

    for (const auto& log_handler : access_log_handlers_) {
      log_handler->log(request_headers, response_headers, response_trailers, stream_info_);
    }
  }

  void onStreamComplete() {
    for (auto& filter : decoder_filters_) {
      filter->handle_->onStreamComplete();
    }

    for (auto& filter : encoder_filters_) {
      
      if (!filter->dual_filter_) {
        filter->handle_->onStreamComplete();
      }
    }
  }

  void destroyFilters() {
    state_.destroyed_ = true;

    for (auto& filter : decoder_filters_) {
      filter->handle_->onDestroy();
    }

    for (auto& filter : encoder_filters_) {
      
      if (!filter->dual_filter_) {
        filter->handle_->onDestroy();
      }
    }
  }

  
  void decodeHeaders(RequestHeaderMap& headers, bool end_stream) {
    decodeHeaders(nullptr, headers, end_stream);
  }

  
  void decodeData(Buffer::Instance& data, bool end_stream) {
    decodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);
  }

  
  void decodeTrailers(RequestTrailerMap& trailers) { decodeTrailers(nullptr, trailers); }

  
  void decodeMetadata(MetadataMap& metadata_map) { decodeMetadata(nullptr, metadata_map); }

  
  void addStreamDecoderFilterWorker(StreamDecoderFilterSharedPtr filter, FilterMatchStateSharedPtr match_state, bool dual_filter);
  void addStreamEncoderFilterWorker(StreamEncoderFilterSharedPtr filter, FilterMatchStateSharedPtr match_state, bool dual_filter);

  void disarmRequestTimeout();

  
  void maybeEndDecode(bool end_stream);

  
  void maybeEndEncode(bool end_stream);

  
  void onLocalReply(StreamFilterBase::LocalReplyData& data);

  void sendLocalReply(Code code, absl::string_view body, const std::function<void(ResponseHeaderMap& headers)>& modify_headers, const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details);


  
  void sendLocalReplyViaFilterChain( bool is_grpc_request, Code code, absl::string_view body, const std::function<void(ResponseHeaderMap& headers)>& modify_headers, bool is_head_request, const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details);



  
  void sendDirectLocalReply(Code code, absl::string_view body, const std::function<void(ResponseHeaderMap& headers)>& modify_headers, bool is_head_request, const absl::optional<Grpc::Status::GrpcStatus> grpc_status);



  
  void setBufferLimit(uint32_t limit);

  
  bool aboveHighWatermark() { return high_watermark_count_ != 0; }

  
  
  void callHighWatermarkCallbacks();
  void callLowWatermarkCallbacks();

  void requestHeadersInitialized() {
    if (Http::Headers::get().MethodValues.Head == filter_manager_callbacks_.requestHeaders()->getMethodValue()) {
      state_.is_head_request_ = true;
    }
    state_.is_grpc_request_ = Grpc::Common::isGrpcRequestHeaders(filter_manager_callbacks_.requestHeaders().ref());
  }

  
  void setLocalComplete() { state_.local_complete_ = true; }

  
  bool destroyed() const { return state_.destroyed_; }

  
  bool remoteComplete() const { return state_.remote_complete_; }

  
  void skipFilterChainCreation() {
    ASSERT(!state_.created_filter_chain_);
    state_.created_filter_chain_ = true;
  }

  
  StreamInfo::StreamInfoImpl& streamInfo() { return stream_info_; }
  const StreamInfo::StreamInfoImpl& streamInfo() const { return stream_info_; }
  void setDownstreamRemoteAddress( const Network::Address::InstanceConstSharedPtr& downstream_remote_address) {
    stream_info_.setDownstreamRemoteAddress(downstream_remote_address);
  }

  
  bool createFilterChain();

  const Network::Connection* connection() const { return &connection_; }

  uint64_t streamId() const { return stream_id_; }
  Buffer::BufferMemoryAccountSharedPtr account() const { return account_; }

  Buffer::InstancePtr& bufferedRequestData() { return buffered_request_data_; }

  void contextOnContinue(ScopeTrackedObjectStack& tracked_object_stack);

  void onDownstreamReset() { state_.saw_downstream_reset_ = true; }

private:
  
  enum class FilterIterationStartState { AlwaysStartFromNext, CanStartFromCurrent };

  
  std::list<ActiveStreamEncoderFilterPtr>::iterator commonEncodePrefix(ActiveStreamEncoderFilter* filter, bool end_stream, FilterIterationStartState filter_iteration_start_state);

  
  std::list<ActiveStreamDecoderFilterPtr>::iterator commonDecodePrefix(ActiveStreamDecoderFilter* filter, FilterIterationStartState filter_iteration_start_state);

  void addDecodedData(ActiveStreamDecoderFilter& filter, Buffer::Instance& data, bool streaming);
  RequestTrailerMap& addDecodedTrailers();
  MetadataMapVector& addDecodedMetadata();
  
  
  void maybeContinueDecoding( const std::list<ActiveStreamDecoderFilterPtr>::iterator& maybe_continue_data_entry);
  void decodeHeaders(ActiveStreamDecoderFilter* filter, RequestHeaderMap& headers, bool end_stream);
  
  
  void decodeData(ActiveStreamDecoderFilter* filter, Buffer::Instance& data, bool end_stream, FilterIterationStartState filter_iteration_start_state);
  void decodeTrailers(ActiveStreamDecoderFilter* filter, RequestTrailerMap& trailers);
  void decodeMetadata(ActiveStreamDecoderFilter* filter, MetadataMap& metadata_map);
  void addEncodedData(ActiveStreamEncoderFilter& filter, Buffer::Instance& data, bool streaming);
  ResponseTrailerMap& addEncodedTrailers();
  void encode1xxHeaders(ActiveStreamEncoderFilter* filter, ResponseHeaderMap& headers);
  
  
  
  void maybeContinueEncoding( const std::list<ActiveStreamEncoderFilterPtr>::iterator& maybe_continue_data_entry);
  void encodeHeaders(ActiveStreamEncoderFilter* filter, ResponseHeaderMap& headers, bool end_stream);
  
  
  
  void encodeData(ActiveStreamEncoderFilter* filter, Buffer::Instance& data, bool end_stream, FilterIterationStartState filter_iteration_start_state);
  void encodeTrailers(ActiveStreamEncoderFilter* filter, ResponseTrailerMap& trailers);
  void encodeMetadata(ActiveStreamEncoderFilter* filter, MetadataMapPtr&& metadata_map_ptr);

  
  bool processNewlyAddedMetadata();

  
  
  
  bool handleDataIfStopAll(ActiveStreamFilterBase& filter, Buffer::Instance& data, bool& filter_streaming);

  MetadataMapVector* getRequestMetadataMapVector() {
    if (request_metadata_map_vector_ == nullptr) {
      request_metadata_map_vector_ = std::make_unique<MetadataMapVector>();
    }
    return request_metadata_map_vector_.get();
  }

  FilterManagerCallbacks& filter_manager_callbacks_;
  Event::Dispatcher& dispatcher_;
  const Network::Connection& connection_;
  const uint64_t stream_id_;
  Buffer::BufferMemoryAccountSharedPtr account_;
  const bool proxy_100_continue_;

  std::list<ActiveStreamDecoderFilterPtr> decoder_filters_;
  std::list<ActiveStreamEncoderFilterPtr> encoder_filters_;
  std::list<StreamFilterBase*> filters_;
  std::list<AccessLog::InstanceSharedPtr> access_log_handlers_;

  
  
  
  std::unique_ptr<MetadataMapVector> request_metadata_map_vector_;
  Buffer::InstancePtr buffered_response_data_;
  Buffer::InstancePtr buffered_request_data_;
  uint32_t buffer_limit_{0};
  uint32_t high_watermark_count_{0};
  std::list<DownstreamWatermarkCallbacks*> watermark_callbacks_;
  Network::Socket::OptionsSharedPtr upstream_options_ = std::make_shared<Network::Socket::Options>();
  absl::optional<absl::string_view> upstream_override_host_;

  FilterChainFactory& filter_chain_factory_;
  const LocalReply::LocalReply& local_reply_;
  OverridableRemoteConnectionInfoSetterStreamInfo stream_info_;
  
  
  friend ActiveStreamFilterBase;
  friend ActiveStreamDecoderFilter;
  friend ActiveStreamEncoderFilter;

  
  
    struct FilterCallState {
      static constexpr uint32_t DecodeHeaders   = 0x01;
      static constexpr uint32_t DecodeData      = 0x02;
      static constexpr uint32_t DecodeTrailers  = 0x04;
      static constexpr uint32_t EncodeHeaders   = 0x08;
      static constexpr uint32_t EncodeData      = 0x10;
      static constexpr uint32_t EncodeTrailers  = 0x20;
      
      
      
      
      static constexpr uint32_t Encode1xxHeaders  = 0x40;
      
      
      static constexpr uint32_t LastDataFrame = 0x80;
    };
  

  struct State {
    State()
        : remote_complete_(false), local_complete_(false), has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false), is_grpc_request_(false), non_100_response_headers_encoded_(false), under_on_local_reply_(false), decoder_filter_chain_aborted_(false), encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}




    uint32_t filter_call_state_{0};

    bool remote_complete_ : 1;
    bool local_complete_ : 1; 
                              
                              
    
    
    bool has_1xx_headers_ : 1;
    bool created_filter_chain_ : 1;
    
    
    bool is_head_request_ : 1;
    bool is_grpc_request_ : 1;
    
    bool non_100_response_headers_encoded_ : 1;
    
    bool under_on_local_reply_ : 1;
    
    bool decoder_filter_chain_aborted_ : 1;
    bool encoder_filter_chain_aborted_ : 1;
    bool saw_downstream_reset_ : 1;

    
    
    
    bool encoder_filters_streaming_{true};
    bool decoder_filters_streaming_{true};
    bool destroyed_{false};

    
    ActiveStreamEncoderFilter* latest_data_encoding_filter_{};
    ActiveStreamDecoderFilter* latest_data_decoding_filter_{};
  };

  State state_;
};

} 
} 
