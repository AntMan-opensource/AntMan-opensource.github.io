




































int user_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member *m)

{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int matched = UNSPEC;
    struct alias *a;
    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    matched = m->negated ? DENY : ALLOW;
	    break;
	case NETGROUP:
	    if (netgr_matches(parse_tree->nss, m->name, def_netgroup_tuple ? lhost : NULL, def_netgroup_tuple ? shost : NULL, pw->pw_name))

		matched = m->negated ? DENY : ALLOW;
	    break;
	case USERGROUP:
	    if (usergr_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
		
		const int rc = userlist_matches(parse_tree, pw, &a->members);
		if (rc != UNSPEC) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
		break;
	    }
	    FALLTHROUGH;
	case WORD:
	    if (userpw_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
    }
    debug_return_int(matched);
}


int userlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list)

{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	if ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)
	    break;
    }
    debug_return_int(matched);
}

struct gid_list * runas_getgroups(const struct sudoers_context *ctx)
{
    const struct passwd *pw;
    debug_decl(runas_getgroups, SUDOERS_DEBUG_MATCH);

    if (def_preserve_groups) {
	sudo_gidlist_addref(ctx->user.gid_list);
	debug_return_ptr(ctx->user.gid_list);
    }

    
    pw = ctx->runas.pw ? ctx->runas.pw : ctx->user.pw;
    debug_return_ptr(sudo_get_gidlist(pw, ENTRY_TYPE_QUERIED));
}


static int runas_userlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *user_list, struct member **matching_user)

{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int user_matched = UNSPEC;
    struct member *m;
    struct alias *a;
    debug_decl(runas_userlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, user_list, member_list, entries) {
	switch (m->type) {
	    case ALL:
		user_matched = m->negated ? DENY : ALLOW;
		break;
	    case NETGROUP:
		if (netgr_matches(parse_tree->nss, m->name, def_netgroup_tuple ? lhost : NULL, def_netgroup_tuple ? shost : NULL, ctx->runas.pw->pw_name))


		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case USERGROUP:
		if (usergr_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case ALIAS:
		a = alias_get(parse_tree, m->name, RUNASALIAS);
		if (a != NULL) {
		    const int rc = runas_userlist_matches(parse_tree, &a->members, matching_user);
		    if (rc != UNSPEC) {
			if (m->negated) {
			    user_matched = rc == ALLOW ? DENY : ALLOW;
			} else {
			    user_matched = rc;
			}
		    }
		    alias_put(a);
		    break;
		}
		FALLTHROUGH;
	    case WORD:
		if (userpw_matches(m->name, ctx->runas.pw->pw_name, ctx->runas.pw))
		    user_matched = m->negated ? DENY : ALLOW;
		break;
	    case MYSELF:
		
		if ((!ISSET(ctx->settings.flags, RUNAS_USER_SPECIFIED) && ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) || strcmp(ctx->user.name, ctx->runas.pw->pw_name) == 0)

		    user_matched = m->negated ? DENY : ALLOW;
		break;
	}
	if (user_matched != UNSPEC) {
	    if (matching_user != NULL && m->type != ALIAS)
		*matching_user = m;
	    break;
	}
    }
    debug_return_int(user_matched);
}


static int runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *group_list, struct member **matching_group)

{
    const struct sudoers_context *ctx = parse_tree->ctx;
    int group_matched = UNSPEC;
    struct member *m;
    struct alias *a;
    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);

    if (group_list != NULL) {
	TAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {
	    switch (m->type) {
		case ALL:
		    group_matched = m->negated ? DENY : ALLOW;
		    break;
		case ALIAS:
		    a = alias_get(parse_tree, m->name, RUNASALIAS);
		    if (a != NULL) {
			const int rc = runas_grouplist_matches(parse_tree, &a->members, matching_group);
			if (rc != UNSPEC) {
			    if (m->negated) {
				group_matched = rc == ALLOW ? DENY : ALLOW;
			    } else {
				group_matched = rc;
			    }
			}
			alias_put(a);
			break;
		    }
		    FALLTHROUGH;
		case WORD:
		    if (group_matches(m->name, ctx->runas.gr))
			group_matched = m->negated ? DENY : ALLOW;
		    break;
	    }
	    if (group_matched != UNSPEC) {
		if (matching_group != NULL && m->type != ALIAS)
		    *matching_group = m;
		break;
	    }
	}
    }
    if (group_matched == UNSPEC) {
	struct gid_list *runas_groups;
	
	if (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {
	    group_matched = ALLOW;	
	} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {
	    int i;

	    for (i = 0; i < runas_groups->ngids; i++) {
		if (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {
		    group_matched = ALLOW;	
		    break;
		}
	    }
	    sudo_gidlist_delref(runas_groups);
	}
    }

    debug_return_int(group_matched);
}


int runaslist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *user_list, const struct member_list *group_list, struct member **matching_user, struct member **matching_group)


{
    const struct sudoers_context *ctx = parse_tree->ctx;
    struct member_list _user_list = TAILQ_HEAD_INITIALIZER(_user_list);
    int user_matched, group_matched = UNSPEC;
    struct member m_user;
    debug_decl(runaslist_matches, SUDOERS_DEBUG_MATCH);

    
    if (user_list == NULL) {
	m_user.name = def_runas_default;
	m_user.type = WORD;
	m_user.negated = false;
	TAILQ_INSERT_HEAD(&_user_list, &m_user, entries);
	user_list = &_user_list;
	matching_user = NULL;
    }

    user_matched = runas_userlist_matches(parse_tree, user_list, matching_user);
    if (ISSET(ctx->settings.flags, RUNAS_GROUP_SPECIFIED)) {
	group_matched = runas_grouplist_matches(parse_tree, group_list, matching_group);
    }

    if (user_matched == DENY || group_matched == DENY)
	debug_return_int(DENY);
    if (user_matched == group_matched || ctx->runas.gr == NULL)
	debug_return_int(user_matched);
    debug_return_int(UNSPEC);
}


static int hostlist_matches_int(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *lhost, const char *shost, const struct member_list *list)


{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = host_matches(parse_tree, pw, lhost, shost, m);
	if (matched != UNSPEC)
	    break;
    }
    debug_return_int(matched);
}


int hostlist_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const struct member_list *list)

{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;

    return hostlist_matches_int(parse_tree, pw, lhost, shost, list);
}


int host_matches(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *lhost, const char *shost, const struct member *m)


{
    struct alias *a;
    int matched = UNSPEC;
    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    matched = m->negated ? DENY : ALLOW;
	    break;
	case NETGROUP:
	    if (netgr_matches(parse_tree->nss, m->name, lhost, shost, def_netgroup_tuple ? pw->pw_name : NULL))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case NTWKADDR:
	    if (addr_matches(m->name))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, HOSTALIAS);
	    if (a != NULL) {
		
		const int rc = hostlist_matches_int(parse_tree, pw, lhost, shost, &a->members);
		if (rc != UNSPEC) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
		break;
	    }
	    FALLTHROUGH;
	case WORD:
	    if (hostname_matches(shost, lhost, m->name))
		matched = m->negated ? DENY : ALLOW;
	    break;
    }
    sudo_debug_printf(SUDO_DEBUG_DEBUG, "host %s (%s) matches sudoers host %s%s: %s", lhost, shost, m->negated ? "!" : "", m->name ? m->name : "ALL", matched == true ? "true" : "false");


    debug_return_int(matched);
}


int cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info)


{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = cmnd_matches(parse_tree, m, runchroot, info);
	if (matched != UNSPEC)
	    break;
    }
    debug_return_int(matched);
}


int cmnd_matches(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info)

{
    struct alias *a;
    struct sudo_command *c;
    int rc, matched = UNSPEC;
    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	case COMMAND:
	    c = (struct sudo_command *)m->name;
	    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, CMNDALIAS);
	    if (a != NULL) {
		rc = cmndlist_matches(parse_tree, &a->members, runchroot, info);
		if (rc != UNSPEC) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
	    }
	    break;
    }
    debug_return_int(matched);
}


int cmnd_matches_all(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info)

{
    const bool negated = m->negated;
    struct sudo_command *c;
    int matched = UNSPEC;
    struct alias *a;
    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    c = (struct sudo_command *)m->name;
	    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests))
		matched = negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    a = alias_get(parse_tree, m->name, CMNDALIAS);
	    if (a != NULL) {
		TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {
		    matched = cmnd_matches_all(parse_tree, m, runchroot, info);
		    if (matched != UNSPEC) {
			if (negated)
			    matched = matched == ALLOW ? DENY : ALLOW;
			break;
		    }
		}
		alias_put(a);
	    }
	    break;
    }
    debug_return_int(matched);
}


bool hostname_matches(const char *shost, const char *lhost, const char *pattern)
{
    const char *host;
    bool rc;
    debug_decl(hostname_matches, SUDOERS_DEBUG_MATCH);

    host = strchr(pattern, '.') != NULL ? lhost : shost;
    if (has_meta(pattern)) {
	rc = !fnmatch(pattern, host, FNM_CASEFOLD);
    } else {
	rc = !strcasecmp(host, pattern);
    }
    debug_return_bool(rc);
}


bool userpw_matches(const char *sudoers_user, const char *user, const struct passwd *pw)
{
    const char *errstr;
    uid_t uid;
    bool rc;
    debug_decl(userpw_matches, SUDOERS_DEBUG_MATCH);

    if (pw != NULL && *sudoers_user == '#') {
	uid = (uid_t) sudo_strtoid(sudoers_user + 1, &errstr);
	if (errstr == NULL && uid == pw->pw_uid) {
	    rc = true;
	    goto done;
	}
    }
    if (def_case_insensitive_user)
	rc = strcasecmp(sudoers_user, user) == 0;
    else rc = strcmp(sudoers_user, user) == 0;
done:
    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, "user %s matches sudoers user %s: %s", user, sudoers_user, rc ? "true" : "false");

    debug_return_bool(rc);
}


bool group_matches(const char *sudoers_group, const struct group *gr)
{
    const char *errstr;
    gid_t gid;
    bool rc;
    debug_decl(group_matches, SUDOERS_DEBUG_MATCH);

    if (*sudoers_group == '#') {
	gid = (gid_t) sudo_strtoid(sudoers_group + 1, &errstr);
	if (errstr == NULL && gid == gr->gr_gid) {
	    rc = true;
	    goto done;
	}
    }
    if (def_case_insensitive_group)
	rc = strcasecmp(sudoers_group, gr->gr_name) == 0;
    else rc = strcmp(sudoers_group, gr->gr_name) == 0;
done:
    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, "group %s matches sudoers group %s: %s", gr->gr_name, sudoers_group, rc ? "true" : "false");

    debug_return_bool(rc);
}


bool usergr_matches(const char *group, const char *user, const struct passwd *pw)
{
    bool matched = false;
    struct passwd *pw0 = NULL;
    debug_decl(usergr_matches, SUDOERS_DEBUG_MATCH);

    
    if (*group++ != '%') {
	sudo_debug_printf(SUDO_DEBUG_DIAG, "user group %s has no leading '%%'", group);
	goto done;
    }

    
    if (*group == ':' && def_group_plugin) {
	if (group_plugin_query(user, group + 1, pw) == true)
	    matched = true;
	goto done;
    }

    
    if (pw == NULL) {
	if ((pw0 = sudo_getpwnam(user)) == NULL) {
	    sudo_debug_printf(SUDO_DEBUG_DIAG, "unable to find %s in passwd db", user);
	    goto done;
	}
	pw = pw0;
    }

    if (user_in_group(pw, group)) {
	matched = true;
	goto done;
    }

    
    if (def_group_plugin && def_always_query_group_plugin) {
	if (group_plugin_query(user, group, pw) == true) {
	    matched = true;
	    goto done;
	}
    }

done:
    if (pw0 != NULL)
	sudo_pw_delref(pw0);

    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, "user %s matches group %s: %s", user, group, matched ? "true" : "false");
    debug_return_bool(matched);
}



static bool valid_domain(const char *domain)
{
    const char *cp;
    debug_decl(valid_domain, SUDOERS_DEBUG_MATCH);

    for (cp = domain; *cp != '\0'; cp++) {
	
	if (*cp == '(' || *cp == ')' || *cp == ',' || *cp == ' ')
	    break;
    }
    if (cp == domain || *cp != '\0')
	debug_return_bool(false);
    debug_return_bool(true);
}


const char * sudo_getdomainname(void)
{
    static char *domain;
    static bool initialized;
    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);

    if (!initialized) {
	size_t host_name_max;
	int rc;


	host_name_max = (size_t)sysconf(_SC_HOST_NAME_MAX);
	if (host_name_max == (size_t)-1)

	    host_name_max = 255;    

	domain = malloc(host_name_max + 1);
	if (domain != NULL) {
	    domain[0] = '\0';

	    rc = sysinfo(SI_SRPC_DOMAIN, domain, host_name_max + 1);

	    rc = getdomainname(domain, host_name_max + 1);

	    if (rc == -1 || !valid_domain(domain)) {
		
		free(domain);
		domain = NULL;
	    }
	} else {
	    
	    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO, "unable to allocate memory");
	}
	initialized = true;
    }
    debug_return_str(domain);
}

const char * sudo_getdomainname(void)
{
    debug_decl(sudo_getdomainname, SUDOERS_DEBUG_MATCH);
    debug_return_ptr(NULL);
}



bool netgr_matches(const struct sudo_nss *nss, const char *netgr, const char *lhost, const char *shost, const char *user)

{
    const char *domain;
    bool rc = false;
    debug_decl(netgr_matches, SUDOERS_DEBUG_MATCH);

    if (!def_use_netgroups) {
	sudo_debug_printf(SUDO_DEBUG_INFO, "netgroups are disabled");
	debug_return_bool(false);
    }

    
    if (*netgr++ != '+') {
	sudo_debug_printf(SUDO_DEBUG_DIAG, "netgroup %s has no leading '+'", netgr);
	debug_return_bool(false);
    }

    
    domain = sudo_getdomainname();

    
    if (nss != NULL && nss->innetgr != NULL) {
	switch (nss->innetgr(nss, netgr, lhost, user, domain)) {
	case 0:
	    if (lhost != shost) {
		if (nss->innetgr(nss, netgr, shost, user, domain) == 1)
		    rc = true;
	    }
	    goto done;
	case 1:
	    rc = true;
	    goto done;
	default:
	    
	    break;
	}
    }


    
    if (innetgr(netgr, lhost, user, domain) == 1) {
	rc = true;
    } else if (lhost != shost) {
	if (innetgr(netgr, shost, user, domain) == 1)
	    rc = true;
    }

    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO, "%s: no system netgroup support", __func__);


done:
    sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, "netgroup %s matches (%s|%s, %s, %s): %s", netgr, lhost ? lhost : "", shost ? shost : "", user ? user : "", domain ? domain : "", rc ? "true" : "false");



    debug_return_bool(rc);
}
