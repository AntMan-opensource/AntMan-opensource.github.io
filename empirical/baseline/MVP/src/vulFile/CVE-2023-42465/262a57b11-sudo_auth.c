
























static sudo_auth auth_switch[] = {


    AUTH_ENTRY("aixauth", FLAG_STANDALONE, sudo_aix_init, NULL, sudo_aix_verify, NULL, sudo_aix_cleanup, NULL, NULL)


    AUTH_ENTRY("pam", FLAG_STANDALONE, sudo_pam_init, NULL, sudo_pam_verify, sudo_pam_approval, sudo_pam_cleanup, sudo_pam_begin_session, sudo_pam_end_session)


    AUTH_ENTRY("SecurId", FLAG_STANDALONE, sudo_securid_init, sudo_securid_setup, sudo_securid_verify, NULL, NULL, NULL, NULL)


    AUTH_ENTRY("sia", FLAG_STANDALONE, NULL, sudo_sia_setup, sudo_sia_verify, NULL, sudo_sia_cleanup, sudo_sia_begin_session, NULL)


    AUTH_ENTRY("fwtk", FLAG_STANDALONE, sudo_fwtk_init, NULL, sudo_fwtk_verify, NULL, sudo_fwtk_cleanup, NULL, NULL)


    AUTH_ENTRY("bsdauth", FLAG_STANDALONE, bsdauth_init, NULL, bsdauth_verify, bsdauth_approval, bsdauth_cleanup, NULL, NULL)




    AUTH_ENTRY("passwd", 0, sudo_passwd_init, NULL, sudo_passwd_verify, NULL, sudo_passwd_cleanup, NULL, NULL)


    AUTH_ENTRY("secureware", 0, sudo_secureware_init, NULL, sudo_secureware_verify, NULL, sudo_secureware_cleanup, NULL, NULL)


    AUTH_ENTRY("afs", 0, NULL, NULL, sudo_afs_verify, NULL, NULL, NULL, NULL)


    AUTH_ENTRY("dce", 0, NULL, NULL, sudo_dce_verify, NULL, NULL, NULL, NULL)


    AUTH_ENTRY("kerb5", 0, sudo_krb5_init, sudo_krb5_setup, sudo_krb5_verify, NULL, sudo_krb5_cleanup, NULL, NULL)


    AUTH_ENTRY("S/Key", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)


    AUTH_ENTRY("OPIE", 0, NULL, sudo_rfc1938_setup, sudo_rfc1938_verify, NULL, NULL, NULL, NULL)

    AUTH_ENTRY(NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
};

static bool standalone;


int sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw, unsigned int mode)

{
    sudo_auth *auth;
    int status = AUTH_SUCCESS;
    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);

    if (auth_switch[0].name == NULL)
	debug_return_int(0);

    
    for (auth = auth_switch; auth->name; auth++) {
	if (ISSET(mode, MODE_NONINTERACTIVE))
	    SET(auth->flags, FLAG_NONINTERACTIVE);
	if (auth->init && !IS_DISABLED(auth)) {
	    
	    status = (auth->init)(ctx, pw, auth);
	    if (status == AUTH_FAILURE)
		SET(auth->flags, FLAG_DISABLED);
	    else if (status == AUTH_ERROR)
		break;		
	}
    }

    
    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {
	bool found = false;
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;
	    if (!IS_STANDALONE(auth)) {
		audit_failure(ctx, ctx->runas.argv, N_("invalid authentication methods"));
		log_warningx(ctx, SLOG_SEND_MAIL, N_("Invalid authentication methods compiled into sudo!  " "You may not mix standalone and non-standalone authentication."));

		debug_return_int(-1);
	    }
	    if (!found) {
		
		found = true;
		continue;
	    }
	    
	    SET(auth->flags, FLAG_DISABLED);
	}
    }

    
    for (auth = auth_switch; auth->name; auth++) {
	
	if (!IS_DISABLED(auth)) {
	    sudo_auth *first = auth;
	    
	    for (; auth->name; auth++) {
		if (!IS_DISABLED(auth))
		    break;
	    }
	    if (auth->name == NULL)
		SET(first->flags, FLAG_ONEANDONLY);
	    break;
	}
    }

    debug_return_int(status == AUTH_ERROR ? -1 : 0);
}


int sudo_auth_approval(const struct sudoers_context *ctx, struct passwd *pw, unsigned int validated, bool exempt)

{
    sudo_auth *auth;
    debug_decl(sudo_auth_approval, SUDOERS_DEBUG_AUTH);

    
    for (auth = auth_switch; auth->name; auth++) {
	if (auth->approval && !IS_DISABLED(auth)) {
	    int status = (auth->approval)(ctx, pw, auth, exempt);
	    if (status != AUTH_SUCCESS) {
		
		log_auth_failure(ctx, validated, 0);
		debug_return_int(status == AUTH_FAILURE ? false : -1);
	    }
	}
    }
    debug_return_int(true);
}


int sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw, bool force)

{
    sudo_auth *auth;
    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);

    
    for (auth = auth_switch; auth->name; auth++) {
	if (auth->cleanup && !IS_DISABLED(auth)) {
	    int status = (auth->cleanup)(ctx, pw, auth, force);
	    if (status == AUTH_ERROR) {
		
		debug_return_int(-1);
	    }
	}
    }
    debug_return_int(0);
}

static void pass_warn(void)
{
    const char *warning = def_badpass_message;
    debug_decl(pass_warn, SUDOERS_DEBUG_AUTH);


    if (def_insults)
	warning = INSULT;

    sudo_printf(SUDO_CONV_ERROR_MSG|SUDO_CONV_PREFER_TTY, "%s\n", warning);

    debug_return;
}

static bool user_interrupted(void)
{
    sigset_t mask;

    return (sigpending(&mask) == 0 && (sigismember(&mask, SIGINT) || sigismember(&mask, SIGQUIT)));
}


int verify_user(const struct sudoers_context *ctx, struct passwd *pw, char *prompt, unsigned int validated, struct sudo_conv_callback *callback)

{
    unsigned int ntries;
    int ret, status, success = AUTH_FAILURE;
    sudo_auth *auth;
    sigset_t mask, omask;
    struct sigaction sa, saved_sigtstp;
    debug_decl(verify_user, SUDOERS_DEBUG_AUTH);

    
    if (auth_switch[0].name == NULL) {
	audit_failure(ctx, ctx->runas.argv, N_("no authentication methods"));
    	log_warningx(ctx, SLOG_SEND_MAIL, N_("There are no authentication methods compiled into sudo!  " "If you want to turn off authentication, use the " "--disable-authentication configure option."));


	debug_return_int(-1);
    }

    
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &saved_sigtstp);

    
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    (void) sigprocmask(SIG_BLOCK, &mask, &omask);

    for (ntries = 0; ntries < def_passwd_tries; ntries++) {
	int num_methods = 0;
	char *pass = NULL;

	
	if (user_interrupted())
	    goto done;

	if (ntries != 0)
	    pass_warn();

	
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;
	    num_methods++;
	    if (auth->setup != NULL) {
		status = (auth->setup)(ctx, pw, &prompt, auth);
		if (status == AUTH_FAILURE)
		    SET(auth->flags, FLAG_DISABLED);
		else if (status == AUTH_NONINTERACTIVE)
		    goto done;
		else if (status == AUTH_ERROR || user_interrupted())
		    goto done;		
	    }
	}
	if (num_methods == 0) {
	    audit_failure(ctx, ctx->runas.argv, N_("no authentication methods"));
	    log_warningx(ctx, SLOG_SEND_MAIL, N_("Unable to initialize authentication methods."));
	    debug_return_int(-1);
	}

	
	if (!standalone) {
	    if (IS_NONINTERACTIVE(&auth_switch[0])) {
		success = AUTH_NONINTERACTIVE;
		goto done;
	    }
	    pass = auth_getpass(prompt, SUDO_CONV_PROMPT_ECHO_OFF, callback);
	    if (pass == NULL)
		break;
	}

	
	for (auth = auth_switch; auth->name; auth++) {
	    if (IS_DISABLED(auth))
		continue;

	    success = auth->status = (auth->verify)(ctx, pw, standalone ? prompt : pass, auth, callback);
	    if (success != AUTH_FAILURE)
		break;
	}
	if (pass != NULL)
	    freezero(pass, strlen(pass));

	if (success != AUTH_FAILURE)
	    goto done;
    }

done:
    
    (void) sigaction(SIGTSTP, &saved_sigtstp, NULL);
    (void) sigprocmask(SIG_SETMASK, &omask, NULL);

    switch (success) {
	case AUTH_SUCCESS:
	    ret = true;
	    break;
	case AUTH_INTR:
	case AUTH_FAILURE:
	    if (ntries != 0)
		SET(validated, FLAG_BAD_PASSWORD);
	    log_auth_failure(ctx, validated, ntries);
	    ret = false;
	    break;
	case AUTH_NONINTERACTIVE:
	    SET(validated, FLAG_NO_USER_INPUT);
	    FALLTHROUGH;
	case AUTH_ERROR:
	default:
	    log_auth_failure(ctx, validated, 0);
	    ret = -1;
	    break;
    }

    debug_return_int(ret);
}


int sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[])

{
    sudo_auth *auth;
    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->begin_session && !IS_DISABLED(auth)) {
	    int status = (auth->begin_session)(ctx, pw, user_env, auth);
	    if (status != AUTH_SUCCESS) {
		
		debug_return_int(-1);
	    }
	}
    }
    debug_return_int(1);
}

bool sudo_auth_needs_end_session(void)
{
    sudo_auth *auth;
    bool needed = false;
    debug_decl(sudo_auth_needs_end_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->end_session && !IS_DISABLED(auth)) {
	    needed = true;
	    break;
	}
    }
    debug_return_bool(needed);
}


int sudo_auth_end_session(void)
{
    sudo_auth *auth;
    int status;
    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->end_session && !IS_DISABLED(auth)) {
	    status = (auth->end_session)(auth);
	    if (status == AUTH_ERROR) {
		
		debug_return_int(-1);
	    }
	}
    }
    debug_return_int(1);
}


char * auth_getpass(const char *prompt, int type, struct sudo_conv_callback *callback)
{
    struct sudo_conv_message msg;
    struct sudo_conv_reply repl;
    sigset_t mask, omask;
    debug_decl(auth_getpass, SUDOERS_DEBUG_AUTH);

    
    display_lecture(callback);

    
    if (type == SUDO_CONV_PROMPT_ECHO_OFF && def_pwfeedback)
	type = SUDO_CONV_PROMPT_MASK;

    
    if (def_visiblepw)
	type |= SUDO_CONV_PROMPT_ECHO_OK;

    
    
    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);
    (void) sigprocmask(SIG_UNBLOCK, &mask, &omask);

    
    memset(&msg, 0, sizeof(msg));
    msg.msg_type = type;
    msg.timeout = (int)def_passwd_timeout.tv_sec;
    msg.msg = prompt;
    memset(&repl, 0, sizeof(repl));
    sudo_conv(1, &msg, &repl, callback);
    

    
    (void) sigprocmask(SIG_SETMASK, &omask, NULL);

    debug_return_str_masked(repl.reply);
}

void dump_auth_methods(void)
{
    sudo_auth *auth;
    debug_decl(dump_auth_methods, SUDOERS_DEBUG_AUTH);

    sudo_printf(SUDO_CONV_INFO_MSG, _("Authentication methods:"));
    for (auth = auth_switch; auth->name; auth++)
	sudo_printf(SUDO_CONV_INFO_MSG, " '%s'", auth->name);
    sudo_printf(SUDO_CONV_INFO_MSG, "\n");

    debug_return;
}
