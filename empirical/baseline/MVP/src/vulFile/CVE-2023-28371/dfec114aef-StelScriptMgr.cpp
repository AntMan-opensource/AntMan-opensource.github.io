








































void StelScriptMgr::defVecClasses(QJSEngine *engine)
{
	qRegisterMetaType<V3d>();
	QMetaType::registerConverter<V3d,QString>(&V3d::toString);
	QMetaType::registerConverter<V3d, Vec3d>(&V3d::toVec3d);
	
	QJSValue v3dMetaObject = engine->newQMetaObject(&V3d::staticMetaObject);
	engine->globalObject().setProperty("V3d", v3dMetaObject);

	qRegisterMetaType<V3f>();
	QMetaType::registerConverter<V3f,QString>(&V3f::toString);
	QMetaType::registerConverter<V3f, Vec3f>(&V3f::toVec3f);
	
	QJSValue v3fMetaObject = engine->newQMetaObject(&V3f::staticMetaObject);
	engine->globalObject().setProperty("V3f", v3fMetaObject);

	qRegisterMetaType<Color>();
	QMetaType::registerConverter<Color,QString>(&Color::toRGBString);
	QMetaType::registerConverter<Color, Vec3f>(&Color::toVec3f);
	
	QJSValue colorMetaObject = engine->newQMetaObject(&Color::staticMetaObject);
	engine->globalObject().setProperty("Color", colorMetaObject);
}







static QScriptValue vec3fToString(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue rVal = that.property( "r", QScriptValue::ResolveLocal );
	QScriptValue gVal = that.property( "g", QScriptValue::ResolveLocal );
	QScriptValue bVal = that.property( "b", QScriptValue::ResolveLocal );
	return "[r:" + rVal.toString() + ", " + "g:" + gVal.toString() + ", " + "b:" + bVal.toString() + "]";
}

static QScriptValue vec3fToHex(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue rVal = that.property( "r", QScriptValue::ResolveLocal );
	QScriptValue gVal = that.property( "g", QScriptValue::ResolveLocal );
	QScriptValue bVal = that.property( "b", QScriptValue::ResolveLocal );
	return QString("#%1%2%3")
		.arg(qMin(255, int(rVal.toNumber() * 255)), 2, 16, QChar('0'))
		.arg(qMin(255, int(gVal.toNumber() * 255)), 2, 16, QChar('0'))
		.arg(qMin(255, int(bVal.toNumber() * 255)), 2, 16, QChar('0'));
}


static QScriptValue vec3fNop(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	return context->thisObject();
}

static QScriptValue vec3fGetR(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue rVal = that.property( "r", QScriptValue::ResolveLocal );
	return rVal;
}

static QScriptValue vec3fGetG(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue rVal = that.property( "g", QScriptValue::ResolveLocal );
	return rVal;
}

static QScriptValue vec3fGetB(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue rVal = that.property( "b", QScriptValue::ResolveLocal );
	return rVal;
}


static QScriptValue vec3fSetR(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	qDebug() << "setR() does not work. Create a new Color.";
	QScriptValue callee = context->callee();
	if (context->argumentCount() == 1) 
		callee.setProperty("r", context->argument(0));
	return callee.property("r");
}

static QScriptValue vec3fSetG(QScriptContext* context, QScriptEngine *engine)
{
	qDebug() << "setG() does not work. Create a new Color.";
	
	
	QScriptValue callee = context->callee();
	if (context->argumentCount() == 1) 
		callee.setProperty("g", QScriptValue(engine, static_cast<qsreal>(context->argument(0).toNumber())));
	return callee.property("g");
}

static QScriptValue vec3fSetB(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	qDebug() << "setB() does not work. Create a new Color.";
	QScriptValue callee = context->callee();
	if (context->argumentCount() == 1) 
		callee.setProperty("b", context->argument(0));
	return callee.property("b");
}

static void vec3fFromScriptValue(const QScriptValue& obj, Vec3f& c)
{
	c[0] = static_cast<float>(obj.property("r").toNumber());
	c[1] = static_cast<float>(obj.property("g").toNumber());
	c[2] = static_cast<float>(obj.property("b").toNumber());
}

static QScriptValue vec3fToScriptValue(QScriptEngine *engine, const Vec3f& c)
{
	QScriptValue obj = engine->newObject();
	obj.setProperty("r", QScriptValue(engine, static_cast<qsreal>(c[0])));
	obj.setProperty("g", QScriptValue(engine, static_cast<qsreal>(c[1])));
	obj.setProperty("b", QScriptValue(engine, static_cast<qsreal>(c[2])));
	obj.setProperty("toString", engine->newFunction( vec3fToString ));
	obj.setProperty("toRGBString", engine->newFunction( vec3fToString ));  
	obj.setProperty("toHex",    engine->newFunction( vec3fToHex ));
	obj.setProperty("toVec3f",  engine->newFunction( vec3fNop )); 
	obj.setProperty("getR",     engine->newFunction( vec3fGetR ));
	obj.setProperty("getG",     engine->newFunction( vec3fGetG ));
	obj.setProperty("getB",     engine->newFunction( vec3fGetB ));
	obj.setProperty("setR",     engine->newFunction( vec3fSetR, 1 )); 
	obj.setProperty("setG",     engine->newFunction( vec3fSetG, 1 )); 
	obj.setProperty("setB",     engine->newFunction( vec3fSetB, 1 )); 
	return obj;
}



static QScriptValue createVec3f(QScriptContext* context, QScriptEngine *engine)
{
	Vec3f c;
	switch( context->argumentCount() )
	{
		case 0:
			
			c.set( 1, 1, 1 );
			break;
		case 1:
			
			if( context->argument(0).isString() )
			{
				QColor qcol = QColor( context->argument(0).toString() );
				if( qcol.isValid() )
				{
					c.set( static_cast<float>(qcol.redF()), static_cast<float>(qcol.greenF()), static_cast<float>(qcol.blueF()) );
					break;
				}
				else context->throwError( QString("Color: invalid color name") );
			}
			else {
				
				return context->argument(0);
			}
			break;
		case 3:
			
			if( context->argument(0).isNumber() && context->argument(1).isNumber() && context->argument(2).isNumber() )

			{
				c[0] = static_cast<float>(context->argument(0).toNumber());
				c[1] = static_cast<float>(context->argument(1).toNumber());
				c[2] = static_cast<float>(context->argument(2).toNumber());
				if( c[0] < 0 || 1 < c[0] || c[1] < 0 || 1 < c[1] || c[2] < 0 || 1 < c[2] )

				{
					context->throwError( QString("Color: RGB value out of range [0,1]") );
				}
			}
			break;
		default:
			context->throwError( QString("Color: invalid number of arguments") );
	}
	return vec3fToScriptValue(engine, c);
}

static QScriptValue createColor(QScriptContext* context, QScriptEngine *engine)
{
	return engine->globalObject().property("Vec3f").construct(context->argumentsObject());
}






QScriptValue vec3dToString(QScriptContext* context, QScriptEngine *engine)
{
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	QScriptValue xVal = that.property( "r", QScriptValue::ResolveLocal );
	QScriptValue yVal = that.property( "g", QScriptValue::ResolveLocal );
	QScriptValue zVal = that.property( "b", QScriptValue::ResolveLocal );
	return "[" + xVal.toString() + ", " + yVal.toString() + ", " + zVal.toString() + "]";
}

QScriptValue getX(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	return that.property( "r", QScriptValue::ResolveLocal );
}
QScriptValue getY(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	return that.property( "g", QScriptValue::ResolveLocal );
}
QScriptValue getZ(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	return that.property( "b", QScriptValue::ResolveLocal );
}

QScriptValue setX(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	that.setProperty("r", context->argument(0).toNumber());
	return QScriptValue();
}
QScriptValue setY(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	that.setProperty("g", context->argument(0).toNumber());
	return QScriptValue();
}
QScriptValue setZ(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	Q_UNUSED(engine)
	QScriptValue that = context->thisObject();
	that.setProperty("b", context->argument(0).toNumber());
	return QScriptValue();
}

void vec3dFromScriptValue(const QScriptValue& obj, Vec3d& c)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	c[0] = obj.property("r").toNumber();
	c[1] = obj.property("g").toNumber();
	c[2] = obj.property("b").toNumber();
}

QScriptValue vec3dToScriptValue(QScriptEngine *engine, const Vec3d& v)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use V3d.";
	QScriptValue obj = engine->newObject();
	obj.setProperty("r", QScriptValue(engine, static_cast<qsreal>(v[0])));
	obj.setProperty("g", QScriptValue(engine, static_cast<qsreal>(v[1])));
	obj.setProperty("b", QScriptValue(engine, static_cast<qsreal>(v[2])));
	obj.setProperty("toString", engine->newFunction( vec3dToString ) );
	obj.setProperty("x", engine->newFunction(getX), QScriptValue::PropertyGetter);
	obj.setProperty("x", engine->newFunction(setX), QScriptValue::PropertySetter);
	obj.setProperty("y", engine->newFunction(getY), QScriptValue::PropertyGetter);
	obj.setProperty("y", engine->newFunction(setY), QScriptValue::PropertySetter);
	obj.setProperty("z", engine->newFunction(getZ), QScriptValue::PropertyGetter);
	obj.setProperty("z", engine->newFunction(setZ), QScriptValue::PropertySetter);	
	return obj;
}

QScriptValue createVec3d(QScriptContext* context, QScriptEngine *engine)
{
	qWarning() << "The Vec3d script object is deprecated and will not work in future versions of Stellarium. Use core.vec3d() or a V3d object.";
	Vec3d c;
	switch( context->argumentCount() )
	{
		case 0:
			c.set( 0, 0, 0 );
			break;
		case 2:
			
			double lng;
			if( context->argument(0).isString() )
				lng = StelUtils::getDecAngle( context->argument(0).toString() );
			else lng = static_cast<double>(context->argument(0).toNumber())*M_PI_180;

			double lat;
			if ( context->argument(1).isString())
				lat = StelUtils::getDecAngle( context->argument(1).toString() );
			else lat = static_cast<double>(context->argument(1).toNumber())*M_PI_180;

			StelUtils::spheToRect( lng, lat, c );
			break;
		case 3:
			c[0] = static_cast<double>(context->argument(0).toNumber());
			c[1] = static_cast<double>(context->argument(1).toNumber());
			c[2] = static_cast<double>(context->argument(2).toNumber());
			break;
		default:
			context->throwError( QString("Vec3d: invalid number of arguments") );
	}
	return vec3dToScriptValue(engine, c);
}

class StelScriptEngineAgent : public QScriptEngineAgent {
public:
	explicit StelScriptEngineAgent(QScriptEngine *engine);
	virtual ~StelScriptEngineAgent() Q_DECL_OVERRIDE {}

	void setPauseScript(bool pause) { qWarning() << "setPauseScript() is deprecated and will no longer be available in future versions of Stellarium."; isPaused=pause; }
	bool getPauseScript() { qWarning() << "getPauseScript() is deprecated and will no longer be available in future versions of Stellarium."; return isPaused; }

	void positionChange(qint64 scriptId, int lineNumber, int columnNumber) Q_DECL_OVERRIDE;

private:
	bool isPaused;
};

void StelScriptMgr::defVecClasses(QScriptEngine *engine)
{
	
	qScriptRegisterMetaType(engine, vec3fToScriptValue, vec3fFromScriptValue);
	QScriptValue ctorVec3f = engine->newFunction(createVec3f);
	engine->globalObject().setProperty("Vec3f", ctorVec3f);
	engine->globalObject().setProperty("Color", engine->newFunction(createColor));

	
	qScriptRegisterMetaType(engine, vec3dToScriptValue, vec3dFromScriptValue);
	QScriptValue ctorVec3d = engine->newFunction(createVec3d);
	engine->globalObject().setProperty("Vec3d", ctorVec3d);

	

	qRegisterMetaType<V3d>();
	QMetaType::registerConverter<V3d,QString>(&V3d::toString);
	QMetaType::registerConverter<V3d, Vec3d>(&V3d::toVec3d);
	
	QScriptValue v3dMetaObject = engine->newQMetaObject(&V3d::staticMetaObject);
	engine->globalObject().setProperty("V3d", v3dMetaObject);

	qRegisterMetaType<V3f>();
	QMetaType::registerConverter<V3f,QString>(&V3f::toString);
	QMetaType::registerConverter<V3f, Vec3f>(&V3f::toVec3f);
	
	QScriptValue v3fMetaObject = engine->newQMetaObject(&V3f::staticMetaObject);
	engine->globalObject().setProperty("V3f", v3fMetaObject);
}


StelScriptMgr::StelScriptMgr(QObject *parent): QObject(parent)
{
	waitEventLoop = new QEventLoop();

	engine = new QJSEngine(this);
	engine->installExtensions(QJSEngine::ConsoleExtension); 

	engine = new QScriptEngine(this);
	
	qScriptRegisterSequenceMetaType<QVector<int>>(engine); 

	connect(&StelApp::getInstance(), SIGNAL(aboutToQuit()), this, SLOT(stopScript()), Qt::DirectConnection);

	
	ScreenImageMgr* scriptImages = new ScreenImageMgr();
	scriptImages->init();
	StelApp::getInstance().getModuleMgr().registerModule(scriptImages);

	defVecClasses(engine); 

	
	mainAPI = new StelMainScriptAPI(this);

	QJSValue objectValue = engine->newQObject(mainAPI);
	mainAPI->setEngine(engine);

	QScriptValue objectValue = engine->newQObject(mainAPI);

	engine->globalObject().setProperty("core", objectValue);

	
	if(StelSkyLayerMgr* smgr = GETSTELMODULE(StelSkyLayerMgr))
		objectValue = engine->newQObject(smgr);

	
	objectValue = engine->newQObject(StelApp::getInstance().getCore()->getSkyDrawer());
	engine->globalObject().setProperty("StelSkyDrawer", objectValue);

	setScriptRate(1.0);


	engine->setProcessEventsInterval(1); 

	agent = new StelScriptEngineAgent(engine);
	engine->setAgent(agent);

	initActions();
}

void StelScriptMgr::initActions()
{
	StelActionMgr* actionMgr = StelApp::getInstance().getStelActionManager();
	const QStringList scriptList = getScriptList();
	for (const auto& script : scriptList)
	{
		QString shortcut = getShortcut(script);
		QString actionId = "actionScript/" + script;
		actionMgr->addAction(actionId, N_("Scripts"), q_(getName(script).trimmed()), this, [this, script] { runScript(script); }, shortcut);
	}
}

StelScriptMgr::~StelScriptMgr()
{

	engine->collectGarbage();
	delete engine;

	delete engine; 

}

void StelScriptMgr::addModules() 
{
	
	StelModuleMgr* mmgr = &StelApp::getInstance().getModuleMgr();
	const QList allModules = mmgr->getAllModules();
	for (auto* m : allModules)
	{
		#ifdef ENABLE_SCRIPT_QML
			QJSValue objectValue = engine->newQObject(m);
		#else
			QScriptValue objectValue = engine->newQObject(m);
		#endif
		engine->globalObject().setProperty(m->objectName(), objectValue);
	}
}

void StelScriptMgr::addObject(QObject *obj)
{
	#ifdef ENABLE_SCRIPT_QML
		QJSValue objectValue = engine->newQObject(obj);
	#else
		QScriptValue objectValue = engine->newQObject(obj);
	#endif
	engine->globalObject().setProperty(obj->objectName(), objectValue);
}

QStringList StelScriptMgr::getScriptList() const {
	QStringList scriptFiles;

	QSet<QString> files = StelFileMgr::listContents("scripts", StelFileMgr::File, true);
	static const QRegularExpression fileRE("^.*\\.ssc$");
	for (const auto& f : files)
	{
		if (fileRE.match(f).hasMatch())
			scriptFiles << f;
	}
	return scriptFiles;
}


bool StelScriptMgr::scriptIsRunning()
{
	if (mutex.tryLock())
	{
		mutex.unlock();
		return false;
	}
	else return true;

bool StelScriptMgr::scriptIsRunning() const {
	return engine->isEvaluating();

}

QString StelScriptMgr::runningScriptId() const {
	return scriptFileName;
}

QString StelScriptMgr::getHeaderSingleLineCommentText(const QString& s, const QString& id, const QString& notFoundText)
{
	QFile file(StelFileMgr::findFile("scripts/" + s, StelFileMgr::File));
	if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
	{
		QString msg = QString("WARNING: script file %1 could not be opened for reading").arg(QDir::toNativeSeparators(s));
		emit scriptDebug(msg);
		qWarning() << msg;
		return QString();
	}

	
	QTextStream textStream(&file);

	textStream.setEncoding(QStringConverter::Utf8);

	textStream.setCodec("UTF-8");

	QRegularExpression nameExp("^\\s*//\\s*" + id + ":\\s*(.+)$");
	while (!textStream.atEnd())
	{
		QString line = textStream.readLine();
		QRegularExpressionMatch nameMatch=nameExp.match(line);
		if (nameMatch.hasMatch())
		{
			file.close();
			return nameMatch.captured(1).trimmed();
		}
	}
	file.close();
	return notFoundText;
}

QString StelScriptMgr::getHtmlDescription(const QString &s, bool generateDocumentTags)
{
	QString html;
	if (generateDocumentTags)
		html += "<html><body>";
	html += "<h2>" + q_(getName(s).trimmed()) + "</h2>";
	QString d = getDescription(s).trimmed();
	d.replace("\n", "<br />");
	static const QRegularExpression spaceExp("\\s{2,}");
	d.replace(spaceExp, " ");
	html += "<p>" + q_(d) + "</p>";
	html += "<p>";

	QString author = getAuthor(s).trimmed();
	if (!author.isEmpty())
	{
		html += "<strong>" + q_("Author") + "</strong>: " + author + "<br />";
	}
	QString license = getLicense(s).trimmed();
	if (!license.isEmpty())
	{
		html += "<strong>" + q_("License") + "</strong>: " + license + "<br />";
	}
	QString version = getVersion(s).trimmed();
	if (!version.isEmpty())
	{
		html += "<strong>" + q_("Version") + "</strong>: " + version + "<br />";
	}
	QString shortcut = getShortcut(s).trimmed();
	if (!shortcut.isEmpty())
	{
		html += "<strong>" + q_("Shortcut") + "</strong>: " + shortcut;
	}
	html += "</p>";

	if (generateDocumentTags)
		html += "</body></html>";

	return html;
}

QString StelScriptMgr::getName(const QString& s)
{
	return getHeaderSingleLineCommentText(s, "Name", s);
}

QString StelScriptMgr::getAuthor(const QString& s)
{
	return getHeaderSingleLineCommentText(s, "Author");
}

QString StelScriptMgr::getLicense(const QString& s)
{
	return getHeaderSingleLineCommentText(s, "License", "");
}

QString StelScriptMgr::getVersion(const QString& s)
{
	return getHeaderSingleLineCommentText(s, "Version", "");
}


QString StelScriptMgr::getShortcut(const QString& s)
{
	return getHeaderSingleLineCommentText(s, "Shortcut", "");
}

QString StelScriptMgr::getDescription(const QString& s)
{
	QFile file(StelFileMgr::findFile("scripts/" + s, StelFileMgr::File));
	if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
	{
		QString msg = QString("WARNING: script file %1 could not be opened for reading").arg(QDir::toNativeSeparators(s));
		emit scriptDebug(msg);
		qWarning() << msg;
		return QString();
	}

	
	QTextStream textStream(&file);

	textStream.setEncoding(QStringConverter::Utf8);

	textStream.setCodec("UTF-8");

	QString desc = "";
	bool inDesc = false;
	static const QRegularExpression descExp("^\\s*//\\s*Description:\\s*([^\\s].+)\\s*$");
	static const QRegularExpression descNewlineExp("^\\s*//\\s*$");
	static const QRegularExpression descContExp("^\\s*//\\s*([^\\s].*)\\s*$");
	while (!textStream.atEnd())
	{
		QString line = textStream.readLine();
		QRegularExpressionMatch descMatch=descExp.match(line);
		if (!inDesc && descMatch.hasMatch())
		{
			inDesc = true;
			desc = descMatch.captured(1) + " ";
			desc.replace("\n","");
		}
		else if (inDesc)
		{
			QString d("");
			QRegularExpressionMatch descContMatch=descContExp.match(line);
			if (descNewlineExp.match(line).hasMatch())
				d = "\n";
			else if (descContMatch.hasMatch())
			{
				d = descContMatch.captured(1) + " ";
				d.replace("\n","");
			}
			else {
				file.close();
				return desc;
			}
			desc += d;
		}
	}
	file.close();
	return desc.trimmed();
}

bool StelScriptMgr::runPreprocessedScript(const QString &preprocessedScript, const QString& scriptId)
{

	if (!mutex.tryLock())

	if (engine->isEvaluating())

	{
		QString msg = QString("ERROR: there is already a script running, please wait until it's over.");
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	
	Q_ASSERT(StelApp::getInstance().getGui());

	engine->globalObject().setProperty("scriptRateReadOnly", 1.0);

	scriptFileName = scriptId;

	
	emit scriptRunning();
	emit runningScriptIdChanged(scriptId);


	engine->setInterrupted(false);
	
	
	result=engine->evaluate(preprocessedScript, QString(), 1);
	scriptEnded();

	
	QScriptContext *context = engine->pushContext();
	engine->evaluate(preprocessedScript);
	engine->popContext();
	scriptEnded();
	Q_UNUSED(context)

	return true;
}


bool StelScriptMgr::runScript(const QString& fileName, const QString& includePath)
{
	QString preprocessedScript;
	prepareScript(preprocessedScript,fileName,includePath);
	return runPreprocessedScript(preprocessedScript,fileName);
}

bool StelScriptMgr::runScriptDirect(const QString scriptId, const QString &scriptCode, int &errLoc, const QString& includePath)
{
	QString path = includePath.isNull() ? QString(".") : includePath;
	if( path.isEmpty() )
		path = QStringLiteral("scripts");
	QString processed;
	bool ok = preprocessScript( scriptId, scriptCode, processed, path, errLoc );
	if(ok)
		return runPreprocessedScript(processed, "<Direct script input>");
	return false;
}

bool StelScriptMgr::runScriptDirect(const QString& scriptCode, const QString &includePath)
{
	QString dummyId("directScript");
	int dummyErrLoc;
	return runScriptDirect(dummyId, scriptCode, dummyErrLoc, includePath);
}

bool StelScriptMgr::prepareScript( QString &script, const QString &fileName, const QString &includePath)
{
	QString absPath;

	if (QFileInfo(fileName).isAbsolute())
		absPath = fileName;
	else absPath = StelFileMgr::findFile("scripts/" + fileName);

	if (absPath.isEmpty())
	{
		QString msg = QString("WARNING: could not find script file %1").arg(QDir::toNativeSeparators(fileName));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	QString scriptDir = QFileInfo(absPath).dir().path();

	QFile fic(absPath);
	if (!fic.open(QIODevice::ReadOnly))
	{
		QString msg = QString("WARNING: cannot open script: %1").arg(QDir::toNativeSeparators(fileName));
		emit scriptDebug(msg);
		qWarning() << msg;
		return false;
	}

	if (!includePath.isEmpty())
		scriptDir = includePath;

	bool ok = false;
	if (fileName.endsWith(".ssc"))
		ok = preprocessFile(absPath, fic, script, scriptDir);
	if (!ok)
	{
		return false;
	}

	return true;
}

void StelScriptMgr::stopScript()
{
	
	
	
	if( waitEventLoop->isRunning() )
	{
		waitEventLoop->exit( 1 );
		return;
	}
	

	if (!mutex.tryLock())
	{
		engine->setInterrupted(true);
		GETSTELMODULE(LabelMgr)->deleteAllLabels();
		GETSTELMODULE(MarkerMgr)->deleteAllMarkers();
		GETSTELMODULE(ScreenImageMgr)->deleteAllImages();
		QString msg = QString("INFO: asking running script to exit");
		emit scriptDebug(msg);
		
	}
	else mutex.unlock();

	if (engine->isEvaluating())
	{
		GETSTELMODULE(LabelMgr)->deleteAllLabels();
		GETSTELMODULE(MarkerMgr)->deleteAllMarkers();
		GETSTELMODULE(ScreenImageMgr)->deleteAllImages();
		if (agent->getPauseScript()) {
			agent->setPauseScript(false);
		}
		QString msg = QString("INFO: asking running script to exit");
		emit scriptDebug(msg);
		
		engine->abortEvaluation();
	}
	

}

void StelScriptMgr::setScriptRate(double r)
{
	

	if (mutex.tryLock())
	{
		engine->globalObject().setProperty("scriptRateReadOnly", r);
		mutex.unlock();
		return;
	}

	if (!engine->isEvaluating())
	{
		engine->globalObject().setProperty("scriptRateReadOnly", r);
		return;
	}

	qreal currentScriptRate = engine->globalObject().property("scriptRateReadOnly").toNumber();
	
	
	
	qreal factor = r / currentScriptRate;
	
	StelCore* core = StelApp::getInstance().getCore();
	core->setTimeRate(core->getTimeRate() * factor);
	
	GETSTELMODULE(StelMovementMgr)->setMovementSpeedFactor(static_cast<float>(core->getTimeRate()));
	engine->globalObject().setProperty("scriptRateReadOnly", r);
}

void StelScriptMgr::pauseScript()
{

	qWarning() << "pauseScript() is no longer available and does nothing.";

	qWarning() << "pauseScript() is deprecated and will no longer be available in future versions of Stellarium.";
	emit scriptPaused();
	agent->setPauseScript(true);

}

void StelScriptMgr::resumeScript()
{

	qWarning() << "resumeScript() is no longer available and does nothing.";

	qWarning() << "resumeScript() is deprecated and will no longer be available in future versions of Stellarium.";
	agent->setPauseScript(false);

}

double StelScriptMgr::getScriptRate()
{
	return engine->globalObject().property("scriptRateReadOnly").toNumber();
}

void StelScriptMgr::debug(const QString& msg)
{
	emit scriptDebug(msg);
}

void StelScriptMgr::output(const QString &msg)
{
	StelScriptOutput::writeLog(msg);
	emit scriptOutput(msg);
}

void StelScriptMgr::resetOutput(void)
{
	StelScriptOutput::reset();
	emit scriptOutput("");
}

void StelScriptMgr::saveOutputAs(const QString &filename)
{
	StelScriptOutput::saveOutputAs(filename);
}

void StelScriptMgr::scriptEnded()
{

	if (result.isError())
	{
		static const QMap<QJSValue::ErrorType, QString>errorMap={
			{QJSValue::GenericError, "Generic", {QJSValue::RangeError, "Range", {QJSValue::ReferenceError, "Reference", {QJSValue::SyntaxError, "Syntax", {QJSValue::TypeError, "Type", {QJSValue::URIError, "URI";




		QString msg = QString("script error: '%1'  @ line %2: %3").arg(errorMap.value(result.errorType()), result.property("lineNumber").toString(), result.toString());
		emit scriptDebug(msg);
		qWarning() << msg;
		qWarning() << "Error name:" << result.property("name").toString() << "message" << result.property("message").toString()
			   << "fileName" << result.property("fileName").toString() << "lineNumber" << result.property("lineNumber").toString() << "stack" << result.property("stack").toString();
	}
	mutex.unlock();

	if (engine->hasUncaughtException())
	{
		int outputPos = engine->uncaughtExceptionLineNumber();
		QString realPos = lookup( outputPos );
		QString msg = QString("script error: \"%1\" @ line %2").arg(engine->uncaughtException().toString(), realPos);
		emit scriptDebug(msg);
		qWarning() << msg;
	}

	GETSTELMODULE(StelMovementMgr)->setMovementSpeedFactor(1.0);
	scriptFileName = QString();
	emit runningScriptIdChanged(scriptFileName);
	emit scriptStopped();
}












bool StelScriptMgr::strToBool(const QString& str)
{
	if (str.toLower() == "off" || str.toLower() == "no")
		return false;
	else if (str.toLower() == "on" || str.toLower() == "yes")
		return true;
	return QVariant(str).toBool();
}


bool StelScriptMgr::preprocessFile(const QString fileName, QFile &input, QString& output, const QString& scriptDir)
{
	QString aText = QString::fromUtf8(input.readAll());
	int errLoc;
	return preprocessScript( fileName, aText, output, scriptDir, errLoc );
}

bool StelScriptMgr::preprocessScript(const QString fileName, const QString &input, QString &output, const QString &scriptDir, int &errLoc )
{
	
	scriptFileName = fileName;
	num2loc = QMap<int,QPair<QString,int>>();
	outline = 0;
	includeSet.clear();
	errLoc = -1;
	expand( fileName, input, output, scriptDir, errLoc );
	if( errLoc != -1 ){
		return false;
	} else {
		return true;
	}
}
	
void StelScriptMgr::expand(const QString fileName, const QString &input, QString &output, const QString &scriptDir, int &errLoc){
	QStringList lines = input.split("\n");
	static const QRegularExpression includeRe("^include\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\\s*;\\s*(//.*)?$");
	int curline = 0;
	for (const auto& line : lines)
	{
		curline++;
		QRegularExpressionMatch includeMatch=includeRe.match(line);
		if (includeMatch.hasMatch())
		{
			QString incName = includeMatch.captured(1);
			QString incPath;

			
			
			
			
			if (QFileInfo(incName).isAbsolute())
				incPath = incName;
			else {
				incPath = StelFileMgr::findFile(scriptDir + "/" + incName);
				if (incPath.isEmpty())
				{
					QString fail = scriptDir + "/" + incName;
					qWarning() << "WARNING: file not found! Let's check standard scripts directory...";

					
					incPath = StelFileMgr::findFile("scripts/" + incName);

					if (incPath.isEmpty())
					{
						fail += " or scripts/" + incName;
						emit scriptDebug(QString("WARNING: could not find script include file: %1").arg(QDir::toNativeSeparators(incName)));
						qWarning() << "WARNING: could not find script include file: " << QDir::toNativeSeparators(incName);
						if( errLoc == -1 ) errLoc = output.length();
						output += line + " // <<< " + fail + " not found\n";
						outline++;
						continue;
					}
				}
			}
			
			output += "// " + line + "\n";
			outline++;

			if( ! includeSet.contains(incPath) )
			{
				includeSet.insert(incPath);
				num2loc.insert( outline, QPair<QString,int>(fileName, curline) );
				QFile fic(incPath);
				bool ok = fic.open(QIODevice::ReadOnly);
				if (ok)
				{
					qWarning() << "script include: " << QDir::toNativeSeparators(incPath);
					QString aText = QString::fromUtf8(fic.readAll());
					expand( incPath, aText, output, scriptDir, errLoc );
					fic.close();
				}
				else {
					emit scriptDebug(QString("WARNING: could not open script include file for reading: %1").arg(QDir::toNativeSeparators(incPath)));
					qWarning() << "WARNING: could not open script include file for reading: " << QDir::toNativeSeparators(incPath);
				   	if( errLoc == -1 ) errLoc = output.length();
					output += line + " // <<< " + incPath + ": cannot open\n";
					outline++;
					continue;
				}
			}
		}
		else {
			output += line + '\n';
			outline++;
		}
	}
	num2loc.insert( outline, QPair<QString,int>(fileName, curline) );

	
	if (qApp->property("verbose")==true)
	{
		
		QStringList outputList=output.split('\n');
		qDebug() << "Script after preprocessing:";
		int lineIdx=0;
		for (const auto& line : outputList)
		{
			qDebug() << lineIdx << ":" << line;
			lineIdx++;
		}
	}
	return;
}

QString StelScriptMgr::lookup( int outputPos )
{
	
	if (outputPos > outline)
		outputPos = outline;

	QMap<int,QPair<QString,int>>::const_iterator i = num2loc.lowerBound( outputPos );
	int outputEnd = i.key();
	QString path = i.value().first;
	int inputEnd = i.value().second;
	int inputPos = outputPos - outputEnd + inputEnd;
	
	QString msg;
	if (path.isEmpty())
		msg = QString( "%1" ).arg(inputPos);
	else msg = QString( "%1:%2" ).arg(path).arg(inputPos);

	return msg;
}


StelScriptEngineAgent::StelScriptEngineAgent(QScriptEngine *engine) 
	: QScriptEngineAgent(engine)
	, isPaused(false)
	{}

void StelScriptEngineAgent::positionChange(qint64 scriptId, int lineNumber, int columnNumber)
{
	Q_UNUSED(scriptId)
	Q_UNUSED(lineNumber)
	Q_UNUSED(columnNumber)

	while (isPaused) {
		
		QCoreApplication::processEvents();
	}
}

