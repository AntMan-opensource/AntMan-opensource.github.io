


__FBSDID("$FreeBSD$");


































static void AliasHandleFtpOut(struct libalias *, struct ip *, struct alias_link *, int maxpacketsize);

static void AliasHandleFtpIn(struct libalias *, struct ip *, struct alias_link *);

static int fingerprint_out(struct libalias *la, struct alias_data *ah)
{

	if (ah->dport == NULL || ah->sport == NULL || ah->lnk == NULL || ah->maxpktsize == 0)
		return (-1);
	if (ntohs(*ah->dport) == FTP_CONTROL_PORT_NUMBER || ntohs(*ah->sport) == FTP_CONTROL_PORT_NUMBER)
		return (0);
	return (-1);
}

static int fingerprint_in(struct libalias *la, struct alias_data *ah)
{

	if (ah->dport == NULL || ah->sport == NULL || ah->lnk == NULL)
		return (-1);
	if (ntohs(*ah->dport) == FTP_CONTROL_PORT_NUMBER || ntohs(*ah->sport) == FTP_CONTROL_PORT_NUMBER)
		return (0);
	return (-1);
}

static int protohandler_out(struct libalias *la, struct ip *pip, struct alias_data *ah)
{

	AliasHandleFtpOut(la, pip, ah->lnk, ah->maxpktsize);
	return (0);
}


static int protohandler_in(struct libalias *la, struct ip *pip, struct alias_data *ah)
{

	AliasHandleFtpIn(la, pip, ah->lnk);
	return (0);
}

struct proto_handler handlers[] = {
	{
	  .pri = 80, .dir = OUT, .proto = TCP, .fingerprint = &fingerprint_out, .protohandler = &protohandler_out }, {





	  .pri = 80, .dir = IN, .proto = TCP, .fingerprint = &fingerprint_in, .protohandler = &protohandler_in }, { EOH }





};

static int mod_handler(module_t mod, int type, void *data)
{
	int error;

	switch (type) {	  
	case MOD_LOAD:
		error = 0;
		LibAliasAttachHandlers(handlers);
		break;
	case MOD_UNLOAD:
		error = 0;
		LibAliasDetachHandlers(handlers);
		break;
	default:
		error = EINVAL;
	}
	return (error);
}


static  moduledata_t alias_mod = {

       "alias_ftp", mod_handler, NULL };


DECLARE_MODULE(alias_ftp, alias_mod, SI_SUB_DRIVERS, SI_ORDER_SECOND);
MODULE_VERSION(alias_ftp, 1);
MODULE_DEPEND(alias_ftp, libalias, 1, 1, 1);








enum ftp_message_type {
	FTP_PORT_COMMAND, FTP_EPRT_COMMAND, FTP_227_REPLY, FTP_229_REPLY, FTP_UNKNOWN_MESSAGE };





static int	ParseFtpPortCommand(struct libalias *la, char *, int);
static int	ParseFtpEprtCommand(struct libalias *la, char *, int);
static int	ParseFtp227Reply(struct libalias *la, char *, int);
static int	ParseFtp229Reply(struct libalias *la, char *, int);
static void	NewFtpMessage(struct libalias *la, struct ip *, struct alias_link *, int, int);

static void AliasHandleFtpOut( struct libalias *la, struct ip *pip, struct alias_link *lnk, int maxpacketsize		 )




{
	int hlen, tlen, dlen, pflags;
	char *sptr;
	struct tcphdr *tc;
	int ftp_message_type;


	tc = (struct tcphdr *)ip_next(pip);
	hlen = (pip->ip_hl + tc->th_off) << 2;
	tlen = ntohs(pip->ip_len);
	dlen = tlen - hlen;


	sptr = (char *)pip;
	sptr += hlen;


	pflags = GetProtocolFlags(lnk);
	if (dlen <= MAX_MESSAGE_SIZE && !(pflags & WAIT_CRLF)) {
		ftp_message_type = FTP_UNKNOWN_MESSAGE;

		if (ntohs(tc->th_dport) == FTP_CONTROL_PORT_NUMBER) {

			if (ParseFtpPortCommand(la, sptr, dlen))
				ftp_message_type = FTP_PORT_COMMAND;
			else if (ParseFtpEprtCommand(la, sptr, dlen))
				ftp_message_type = FTP_EPRT_COMMAND;
		} else {

			if (ParseFtp227Reply(la, sptr, dlen))
				ftp_message_type = FTP_227_REPLY;
			else if (ParseFtp229Reply(la, sptr, dlen)) {
				ftp_message_type = FTP_229_REPLY;
				la->true_addr.s_addr = pip->ip_src.s_addr;
			}
		}

		if (ftp_message_type != FTP_UNKNOWN_MESSAGE)
			NewFtpMessage(la, pip, lnk, maxpacketsize, ftp_message_type);
	}


	if (dlen) {		
		sptr = (char *)pip;	
		tlen = ntohs(pip->ip_len);	
		if (sptr[tlen - 2] == '\r' && sptr[tlen - 1] == '\n')
			pflags &= ~WAIT_CRLF;
		else pflags |= WAIT_CRLF;
		SetProtocolFlags(lnk, pflags);
	}
}

static void AliasHandleFtpIn(struct libalias *la, struct ip *pip, struct alias_link *lnk)


{
	int hlen, tlen, dlen, pflags;
	char *sptr;
	struct tcphdr *tc;

	
	tc = (struct tcphdr *)ip_next(pip);
	hlen = (pip->ip_hl + tc->th_off) << 2;
	tlen = ntohs(pip->ip_len);
	dlen = tlen - hlen;

	
	sptr = (char *)pip;
	sptr += hlen;

	
	pflags = GetProtocolFlags(lnk);
	if (dlen <= MAX_MESSAGE_SIZE && (pflags & WAIT_CRLF) == 0 && ntohs(tc->th_dport) == FTP_CONTROL_PORT_NUMBER && (ParseFtpPortCommand(la, sptr, dlen) != 0 || ParseFtpEprtCommand(la, sptr, dlen) != 0)) {


		
		AddLink(la, GetOriginalAddress(lnk), la->true_addr, GetAliasAddress(lnk), htons(FTP_CONTROL_PORT_NUMBER - 1), htons(la->true_port), GET_ALIAS_PORT, IPPROTO_TCP);

	}
	
	if (dlen) {
		sptr = (char *)pip;		
		tlen = ntohs(pip->ip_len);	
		if (sptr[tlen - 2] == '\r' && sptr[tlen - 1] == '\n')
			pflags &= ~WAIT_CRLF;
		else pflags |= WAIT_CRLF;
		SetProtocolFlags(lnk, pflags);
       }
}

static int ParseFtpPortCommand(struct libalias *la, char *sptr, int dlen)
{
	char ch;
	int i, state;
	u_int32_t addr;
	u_short port;
	u_int8_t octet;

	

	
	if (dlen < 18)
		return (0);

	if (strncasecmp("PORT ", sptr, 5))
		return (0);

	addr = port = octet = 0;
	state = 0;
	for (i = 5; i < dlen; i++) {
		ch = sptr[i];
		switch (state) {
		case 0:
			if (isspace(ch))
				break;
			else state++;
		case 1:
		case 3:
		case 5:
		case 7:
		case 9:
		case 11:
			if (isdigit(ch)) {
				octet = ch - '0';
				state++;
			} else return (0);
			break;
		case 2:
		case 4:
		case 6:
		case 8:
			if (isdigit(ch))
				octet = 10 * octet + ch - '0';
			else if (ch == ',') {
				addr = (addr << 8) + octet;
				state++;
			} else return (0);
			break;
		case 10:
		case 12:
			if (isdigit(ch))
				octet = 10 * octet + ch - '0';
			else if (ch == ',' || state == 12) {
				port = (port << 8) + octet;
				state++;
			} else return (0);
			break;
		}
	}

	if (state == 13) {
		la->true_addr.s_addr = htonl(addr);
		la->true_port = port;
		return (1);
	} else return (0);
}

static int ParseFtpEprtCommand(struct libalias *la, char *sptr, int dlen)
{
	char ch, delim;
	int i, state;
	u_int32_t addr;
	u_short port;
	u_int8_t octet;

	

	
	if (dlen < 18)
		return (0);

	if (strncasecmp("EPRT ", sptr, 5))
		return (0);

	addr = port = octet = 0;
	delim = '|';		
	state = 0;
	for (i = 5; i < dlen; i++) {
		ch = sptr[i];
		switch (state) {
		case 0:
			if (!isspace(ch)) {
				delim = ch;
				state++;
			}
			break;
		case 1:
			if (ch == '1')	
				state++;
			else return (0);
			break;
		case 2:
			if (ch == delim)
				state++;
			else return (0);
			break;
		case 3:
		case 5:
		case 7:
		case 9:
			if (isdigit(ch)) {
				octet = ch - '0';
				state++;
			} else return (0);
			break;
		case 4:
		case 6:
		case 8:
		case 10:
			if (isdigit(ch))
				octet = 10 * octet + ch - '0';
			else if (ch == '.' || state == 10) {
				addr = (addr << 8) + octet;
				state++;
			} else return (0);
			break;
		case 11:
			if (isdigit(ch)) {
				port = ch - '0';
				state++;
			} else return (0);
			break;
		case 12:
			if (isdigit(ch))
				port = 10 * port + ch - '0';
			else if (ch == delim)
				state++;
			else return (0);
			break;
		}
	}

	if (state == 13) {
		la->true_addr.s_addr = htonl(addr);
		la->true_port = port;
		return (1);
	} else return (0);
}

static int ParseFtp227Reply(struct libalias *la, char *sptr, int dlen)
{
	char ch;
	int i, state;
	u_int32_t addr;
	u_short port;
	u_int8_t octet;

	

	
	if (dlen < 17)
		return (0);

	if (strncmp("227 ", sptr, 4))
		return (0);

	addr = port = octet = 0;

	state = 0;
	for (i = 4; i < dlen; i++) {
		ch = sptr[i];
		switch (state) {
		case 0:
			if (ch == '(')
				state++;
			break;
		case 1:
		case 3:
		case 5:
		case 7:
		case 9:
		case 11:
			if (isdigit(ch)) {
				octet = ch - '0';
				state++;
			} else return (0);
			break;
		case 2:
		case 4:
		case 6:
		case 8:
			if (isdigit(ch))
				octet = 10 * octet + ch - '0';
			else if (ch == ',') {
				addr = (addr << 8) + octet;
				state++;
			} else return (0);
			break;
		case 10:
		case 12:
			if (isdigit(ch))
				octet = 10 * octet + ch - '0';
			else if (ch == ',' || (state == 12 && ch == ')')) {
				port = (port << 8) + octet;
				state++;
			} else return (0);
			break;
		}
	}

	if (state == 13) {
		la->true_port = port;
		la->true_addr.s_addr = htonl(addr);
		return (1);
	} else return (0);
}

static int ParseFtp229Reply(struct libalias *la, char *sptr, int dlen)
{
	char ch, delim;
	int i, state;
	u_short port;

	

	
	if (dlen < 11)
		return (0);

	if (strncmp("229 ", sptr, 4))
		return (0);

	port = 0;
	delim = '|';		

	state = 0;
	for (i = 4; i < dlen; i++) {
		ch = sptr[i];
		switch (state) {
		case 0:
			if (ch == '(')
				state++;
			break;
		case 1:
			delim = ch;
			state++;
			break;
		case 2:
		case 3:
			if (ch == delim)
				state++;
			else return (0);
			break;
		case 4:
			if (isdigit(ch)) {
				port = ch - '0';
				state++;
			} else return (0);
			break;
		case 5:
			if (isdigit(ch))
				port = 10 * port + ch - '0';
			else if (ch == delim)
				state++;
			else return (0);
			break;
		case 6:
			if (ch == ')')
				state++;
			else return (0);
			break;
		}
	}

	if (state == 7) {
		la->true_port = port;
		return (1);
	} else return (0);
}

static void NewFtpMessage(struct libalias *la, struct ip *pip, struct alias_link *lnk, int maxpacketsize, int ftp_message_type)



{
	struct alias_link *ftp_lnk;


	if (pip->ip_src.s_addr != la->true_addr.s_addr)
		return;

	if (la->true_port < IPPORT_RESERVED)
		return;

	
	ftp_lnk = AddLink(la, la->true_addr, GetDestAddress(lnk), GetAliasAddress(lnk), htons(la->true_port), 0, GET_ALIAS_PORT, IPPROTO_TCP);


	if (ftp_lnk != NULL) {
		int slen, hlen, tlen, dlen;
		struct tcphdr *tc;


		
		PunchFWHole(ftp_lnk);



		tc = (struct tcphdr *)ip_next(pip);
		hlen = (pip->ip_hl + tc->th_off) << 2;
		tlen = ntohs(pip->ip_len);
		dlen = tlen - hlen;


		{
			char stemp[MAX_MESSAGE_SIZE + 1];
			char *sptr;
			u_short alias_port;
			u_char *ptr;
			int a1, a2, a3, a4, p1, p2;
			struct in_addr alias_address;


			alias_address = GetAliasAddress(lnk);
			ptr = (u_char *) & alias_address.s_addr;
			a1 = *ptr++;
			a2 = *ptr++;
			a3 = *ptr++;
			a4 = *ptr;

			alias_port = GetAliasPort(ftp_lnk);


			switch (ftp_message_type) {
			case FTP_PORT_COMMAND:
			case FTP_227_REPLY:
				
				ptr = (char *)&alias_port;
				p1 = *ptr++;
				p2 = *ptr;

				if (ftp_message_type == FTP_PORT_COMMAND) {
					
					sprintf(stemp, "PORT %d,%d,%d,%d,%d,%d\r\n", a1, a2, a3, a4, p1, p2);
				} else {
					
					sprintf(stemp, "227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n", a1, a2, a3, a4, p1, p2);

				}
				break;
			case FTP_EPRT_COMMAND:
				
				sprintf(stemp, "EPRT |1|%d.%d.%d.%d|%d|\r\n", a1, a2, a3, a4, ntohs(alias_port));
				break;
			case FTP_229_REPLY:
				
				sprintf(stemp, "229 Entering Extended Passive Mode (|||%d|)\r\n", ntohs(alias_port));
				break;
			}


			slen = strlen(stemp);


			sptr = (char *)pip;
			sptr += hlen;
			strncpy(sptr, stemp, maxpacketsize - hlen);
		}


		{
			int delta;

			SetAckModified(lnk);
			tc = (struct tcphdr *)ip_next(pip);				
			delta = GetDeltaSeqOut(tc->th_seq, lnk);
			AddSeq(lnk, delta + slen - dlen, pip->ip_hl,  pip->ip_len, tc->th_seq, tc->th_off);
		}


		{
			u_short new_len;

			new_len = htons(hlen + slen);
			DifferentialChecksum(&pip->ip_sum, &new_len, &pip->ip_len, 1);


			pip->ip_len = new_len;
		}


		tc->th_sum = 0;

		tc->th_x2 = 1;

		tc->th_sum = TcpChecksum(pip);

	} else {

		fprintf(stderr, "PacketAlias/HandleFtpOut: Cannot allocate FTP data port\n");

	}
}
