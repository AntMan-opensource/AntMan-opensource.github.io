






























namespace Envoy {
namespace Extensions {
namespace HttpFilters {
namespace Oauth2 {

class OAuth2Client;


class SecretReader {
public:
  virtual ~SecretReader() = default;
  virtual const std::string& clientSecret() const PURE;
  virtual const std::string& tokenSecret() const PURE;
};

class SDSSecretReader : public SecretReader {
public:
  SDSSecretReader(Secret::GenericSecretConfigProviderSharedPtr client_secret_provider, Secret::GenericSecretConfigProviderSharedPtr token_secret_provider, Api::Api& api)
      : update_callback_client_(readAndWatchSecret(client_secret_, client_secret_provider, api)), update_callback_token_(readAndWatchSecret(token_secret_, token_secret_provider, api)) {}

  const std::string& clientSecret() const override { return client_secret_; }

  const std::string& tokenSecret() const override { return token_secret_; }

private:
  Envoy::Common::CallbackHandlePtr readAndWatchSecret(std::string& value, Secret::GenericSecretConfigProviderSharedPtr& secret_provider, Api::Api& api) {

    const auto* secret = secret_provider->secret();
    if (secret != nullptr) {
      value = Config::DataSource::read(secret->secret(), true, api);
    }

    return secret_provider->addUpdateCallback([secret_provider, &api, &value]() {
      const auto* secret = secret_provider->secret();
      if (secret != nullptr) {
        value = Config::DataSource::read(secret->secret(), true, api);
      }
    });
  }

  std::string client_secret_;
  std::string token_secret_;

  Envoy::Common::CallbackHandlePtr update_callback_client_;
  Envoy::Common::CallbackHandlePtr update_callback_token_;
};







struct FilterStats {
  ALL_OAUTH_FILTER_STATS(GENERATE_COUNTER_STRUCT)
};


struct CookieNames {
  CookieNames(const envoy::extensions::filters::http::oauth2::v3::OAuth2Credentials::CookieNames& cookie_names)
      : CookieNames(cookie_names.bearer_token(), cookie_names.oauth_hmac(), cookie_names.oauth_expires()) {}

  CookieNames(const std::string& bearer_token, const std::string& oauth_hmac, const std::string& oauth_expires)
      : bearer_token_(bearer_token.empty() ? "BearerToken" : bearer_token), oauth_hmac_(oauth_hmac.empty() ? "OauthHMAC" : oauth_hmac), oauth_expires_(oauth_expires.empty() ? "OauthExpires" : oauth_expires) {}


  const std::string bearer_token_;
  const std::string oauth_hmac_;
  const std::string oauth_expires_;
};


class FilterConfig {
public:
  FilterConfig(const envoy::extensions::filters::http::oauth2::v3::OAuth2Config& proto_config, Upstream::ClusterManager& cluster_manager, std::shared_ptr<SecretReader> secret_reader, Stats::Scope& scope, const std::string& stats_prefix);


  const std::string& clusterName() const { return oauth_token_endpoint_.cluster(); }
  const std::string& clientId() const { return client_id_; }
  bool forwardBearerToken() const { return forward_bearer_token_; }
  const std::vector<Http::HeaderUtility::HeaderData>& passThroughMatchers() const {
    return pass_through_header_matchers_;
  }

  const envoy::config::core::v3::HttpUri& oauthTokenEndpoint() const {
    return oauth_token_endpoint_;
  }
  const std::string& authorizationEndpoint() const { return authorization_endpoint_; }
  const std::string& redirectUri() const { return redirect_uri_; }
  const Matchers::PathMatcher& redirectPathMatcher() const { return redirect_matcher_; }
  const Matchers::PathMatcher& signoutPath() const { return signout_path_; }
  std::string clientSecret() const { return secret_reader_->clientSecret(); }
  std::string tokenSecret() const { return secret_reader_->tokenSecret(); }
  FilterStats& stats() { return stats_; }
  const std::string& encodedAuthScopes() const { return encoded_auth_scopes_; }
  const std::string& encodedResourceQueryParams() const { return encoded_resource_query_params_; }
  const CookieNames& cookieNames() const { return cookie_names_; }

private:
  static FilterStats generateStats(const std::string& prefix, Stats::Scope& scope);

  const envoy::config::core::v3::HttpUri oauth_token_endpoint_;
  const std::string authorization_endpoint_;
  const std::string client_id_;
  const std::string redirect_uri_;
  const Matchers::PathMatcher redirect_matcher_;
  const Matchers::PathMatcher signout_path_;
  std::shared_ptr<SecretReader> secret_reader_;
  FilterStats stats_;
  const std::string encoded_auth_scopes_;
  const std::string encoded_resource_query_params_;
  const bool forward_bearer_token_ : 1;
  const std::vector<Http::HeaderUtility::HeaderData> pass_through_header_matchers_;
  const CookieNames cookie_names_;
};

using FilterConfigSharedPtr = std::shared_ptr<FilterConfig>;


class CookieValidator {
public:
  virtual ~CookieValidator() = default;
  virtual const std::string& token() const PURE;
  virtual void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) PURE;
  virtual bool isValid() const PURE;
};

class OAuth2CookieValidator : public CookieValidator {
public:
  explicit OAuth2CookieValidator(TimeSource& time_source, const CookieNames& cookie_names)
      : time_source_(time_source), cookie_names_(cookie_names) {}

  const std::string& token() const override { return token_; }
  void setParams(const Http::RequestHeaderMap& headers, const std::string& secret) override;
  bool isValid() const override;
  bool hmacIsValid() const;
  bool timestampIsValid() const;

private:
  std::string token_;
  std::string id_token_;
  std::string refresh_token_;
  std::string expires_;
  std::string hmac_;
  std::vector<uint8_t> secret_;
  absl::string_view host_;
  TimeSource& time_source_;
  const CookieNames cookie_names_;
};


class OAuth2Filter : public Http::PassThroughDecoderFilter, public FilterCallbacks {
public:
  OAuth2Filter(FilterConfigSharedPtr config, std::unique_ptr<OAuth2Client>&& oauth_client, TimeSource& time_source);

  
  Http::FilterHeadersStatus decodeHeaders(Http::RequestHeaderMap& headers, bool) override;

  
  void onGetAccessTokenSuccess(const std::string& access_code, const std::string& id_token, const std::string& refresh_token, std::chrono::seconds expires_in) override;

  
  
  void sendUnauthorizedResponse() override;

  void finishFlow();

private:
  friend class OAuth2Test;

  std::shared_ptr<CookieValidator> validator_;

  
  std::string auth_code_;
  std::string access_token_; 
  std::string id_token_;
  std::string refresh_token_;
  std::string new_expires_;
  absl::string_view host_;
  std::string state_;
  bool found_bearer_token_{false};
  Http::RequestHeaderMap* request_headers_{nullptr};

  std::unique_ptr<OAuth2Client> oauth_client_;
  FilterConfigSharedPtr config_;
  TimeSource& time_source_;

  
  
  bool canSkipOAuth(Http::RequestHeaderMap& headers) const;

  Http::FilterHeadersStatus signOutUser(const Http::RequestHeaderMap& headers);

  const std::string& bearerPrefix() const;
  std::string extractAccessToken(const Http::RequestHeaderMap& headers) const;
};

} 
} 
} 
} 
