












gboolean ephy_string_to_int (const char *string, gulong     *integer)

{
  gulong result;
  char *parse_end;

  
  if (string == NULL || *string == '\0')
    return FALSE;

  
  errno = 0;
  result = strtol (string, &parse_end, 0);

  
  if (errno == ERANGE)
    return FALSE;

  
  while (*parse_end != '\0') {
    if (!g_ascii_isspace (*parse_end++))
      return FALSE;
  }

  
  *integer = result;
  return TRUE;
}

char * ephy_string_blank_chr (char *source)
{
  char *p;

  if (source == NULL)
    return NULL;

  p = source;
  while (*p != '\0') {
    if ((guchar) * p < 0x20)
      *p = ' ';

    p++;
  }

  return source;
}


char * ephy_string_shorten (char  *str, gsize  target_length)

{
  char *new_str;
  glong actual_length;
  gulong bytes;

  g_assert (target_length > 0);

  if (!str)
    return NULL;

  
  actual_length = g_utf8_strlen (str, -1);

  
  if ((gsize)actual_length <= target_length)
    return str;

  
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);

  
  new_str = g_new (gchar, bytes + 1 + 1);

  strncpy (new_str, str, bytes);
  strcat (new_str, "â€¦");

  g_free (str);

  return new_str;
}





char * ephy_string_collate_key_for_domain (const char *str, gssize      len)

{
  GString *result;
  const char *dot;
  gssize newlen;

  if (len < 0)
    len = strlen (str);

  result = g_string_sized_new (len + 6 * strlen (COLLATION_SENTINEL));

  
  while ((dot = g_strrstr_len (str, len, ".")) != NULL) {
    newlen = dot - str;

    g_string_append_len (result, dot + 1, len - newlen - 1);
    g_string_append (result, COLLATION_SENTINEL);

    len = newlen;
  }

  if (len > 0)
    g_string_append_len (result, str, len);

  return g_string_free (result, FALSE);
}

char * ephy_string_get_host_name (const char *url)
{
  g_autoptr (GUri) uri = NULL;

  if (url == NULL || g_str_has_prefix (url, "file://") || g_str_has_prefix (url, "about:") || g_str_has_prefix (url, "ephy-about:"))


    return NULL;

  uri = g_uri_parse (url, G_URI_FLAGS_NONE, NULL);
  
  if (uri == NULL) {
    char *effective_url = g_strconcat ("http://", url, NULL);
    uri = g_uri_parse (effective_url, G_URI_FLAGS_NONE, NULL);
    g_free (effective_url);
  }

  if (uri == NULL)
    return NULL;

  return g_strdup (g_uri_get_host (uri));
}


char ** ephy_string_commandline_args_to_uris (char   **arguments, GError **error)

{
  gchar **args;
  GFile *file;
  guint i;

  if (arguments == NULL)
    return NULL;

  args = g_malloc0 (sizeof (gchar *) * (g_strv_length (arguments) + 1));

  for (i = 0; arguments[i] != NULL; ++i) {
    file = g_file_new_for_commandline_arg (arguments [i]);
    if (g_file_is_native (file) && g_file_query_exists (file, NULL)) {
      args[i] = g_file_get_uri (file);
    } else {
      args[i] = g_locale_to_utf8 (arguments [i], -1, NULL, NULL, error);
      if (error && *error) {
        g_strfreev (args);
        return NULL;
      }
    }
    g_object_unref (file);
  }

  return args;
}

char * ephy_string_find_and_replace (const char *haystack, const char *to_find, const char *to_repl)


{
  GString *str;

  g_assert (haystack);
  g_assert (to_find);
  g_assert (to_repl);

  str = g_string_new (haystack);
  g_string_replace (str, to_find, to_repl, 0);
  return g_string_free (str, FALSE);
}


char * ephy_string_remove_leading (char *string, char  ch)

{
  char *start;

  g_assert (string);

  for (start = string; *start && *start == ch; start++)
    ;

  memmove (string, start, strlen (start) + 1);

  return string;
}


char * ephy_string_remove_trailing (char *string, char  ch)

{
  g_assert (string);

  for (gssize i = strlen (string) - 1; i >= 0 && string[i] == ch; i--)
    string[i] = '\0';

  return string;
}

char ** ephy_strv_remove (const char * const *strv, const char         *str)

{
  char **new_strv;
  char **n;
  const char * const *s;
  guint len;

  if (!g_strv_contains (strv, str))
    return g_strdupv ((char **)strv);

  
  len = g_strv_length ((char **)strv);
  new_strv = g_malloc ((len - 1 + 1) * sizeof (char *));
  n = new_strv;
  s = strv;

  while (*s != NULL) {
    if (strcmp (*s, str) != 0) {
      *n = g_strdup (*s);
      n++;
    }
    s++;
  }
  new_strv[len - 1] = NULL;

  return new_strv;
}
