





















namespace osquery {

class SQLiteDBManager;


class SQLiteDBInstance : private boost::noncopyable {
 public:
  SQLiteDBInstance() {
    init();
  }
  SQLiteDBInstance(sqlite3*& db, Mutex& mtx);
  ~SQLiteDBInstance();

  
  bool isPrimary() const {
    return primary_;
  }

  
  void init();

  
  sqlite3* db() const {
    return db_;
  }

  
  void addAffectedTable(std::shared_ptr<VirtualTableContent> table);

  
  void clearAffectedTables();

  
  bool tableCalled(VirtualTableContent const& table);

  
  void useCache(bool use_cache);

  
  bool useCache() const;

  
  RecursiveLock attachLock() const;

 private:
  
  TableAttributes getAttributes() const;

 private:
  
  explicit SQLiteDBInstance(sqlite3* db)
      : primary_(true), managed_(true), db_(db) {}

 private:
  
  bool primary_{false};

  
  bool managed_{false};

  
  bool use_cache_{false};

  
  sqlite3* db_{nullptr};

  
  WriteLock lock_;

  
  mutable RecursiveMutex attach_mutex_;

  
  static RecursiveMutex kPrimaryAttachMutex;

  
  std::map<std::string, std::shared_ptr<VirtualTableContent>> affected_tables_;

 private:
  friend class SQLiteDBManager;
  friend class SQLInternal;

 private:
  FRIEND_TEST(SQLiteUtilTests, test_affected_tables);
};

using SQLiteDBInstanceRef = std::shared_ptr<SQLiteDBInstance>;


class SQLiteDBManager : private boost::noncopyable {
 public:
  static SQLiteDBManager& instance() {
    static SQLiteDBManager instance;
    return instance;
  }

  
  static SQLiteDBInstanceRef get() {
    return getConnection();
  }

  
  static SQLiteDBInstanceRef getUnique();

  
  static void resetPrimary();

  
  static bool isDisabled(const std::string& table_name);

 protected:
  SQLiteDBManager();
  virtual ~SQLiteDBManager();

 public:
  SQLiteDBManager(SQLiteDBManager const&) = delete;
  SQLiteDBManager& operator=(SQLiteDBManager const&) = delete;

 private:
  
  sqlite3* db_{nullptr};

  
  SQLiteDBInstanceRef connection_{nullptr};

  
  Mutex mutex_;

  
  Mutex create_mutex_;

  
  std::unordered_set<std::string> disabled_tables_;

  
  std::unordered_set<std::string> enabled_tables_;

  
  void setDisabledTables(const std::string& s);

  
  void setEnabledTables(const std::string& s);

  
  static SQLiteDBInstanceRef getConnection(bool primary = false);

 private:
  friend class SQLiteDBInstance;
  friend class SQLiteSQLPlugin;
};


class QueryPlanner : private boost::noncopyable {
 public:
  explicit QueryPlanner(const std::string& query)
      : QueryPlanner(query, SQLiteDBManager::get()) {}
  QueryPlanner(const std::string& query, const SQLiteDBInstanceRef& instance);
  ~QueryPlanner() {}

 public:
  
  Status applyTypes(TableColumns& columns);

  
  std::vector<std::string> tables() const {
    return tables_;
  }

  
  struct Opcode {
    enum Register {
      P1 = 0, P2, P3, };



    Register reg;
    ColumnType type;

   public:
    Opcode(Register r, ColumnType t) : reg(r), type(t) {}

    
    static std::string regString(Register r) {
      static std::vector<std::string> regs = {"p1", "p2", "p3";
      return regs[r];
    }
  };

 private:
  
  QueryData program_;
  
  std::vector<std::string> tables_;
};


extern const std::map<std::string, QueryPlanner::Opcode> kSQLOpcodes;


Status queryInternal(const std::string& q, QueryDataTyped& results, const SQLiteDBInstanceRef& instance);



Status queryInternal(const std::string& q, QueryData& results, const SQLiteDBInstanceRef& instance);



Status getQueryColumnsInternal(const std::string& q, TableColumns& columns, const SQLiteDBInstanceRef& instance);



class SQLInternal : private only_movable {
 public:
  
  explicit SQLInternal(const std::string& query, bool use_cache = false);

 public:
  
  QueryDataTyped& rowsTyped();

  const Status& getStatus() const;

  
  bool eventBased() const;

  
  void escapeResults();

 private:
  
  QueryDataTyped resultsTyped_;

  
  Status status_;
  
  bool event_based_{false};
};


std::string getStringForSQLiteReturnCode(int code);


int queryDataCallback(void* argument, int argc, char* argv[], char* column[]);


void registerMathExtensions(sqlite3* db);


void registerStringExtensions(sqlite3* db);


void registerHashingExtensions(sqlite3* db);


void registerOperationExtensions(sqlite3* db);


void registerEncodingExtensions(sqlite3* db);


void registerFilesystemExtensions(sqlite3* db);


Status genTableRowsForSqliteTable(const boost::filesystem::path& sqlite_db, const std::string& sqlite_query, TableRows& results, bool respect_locking = true);




Status getSqliteJournalMode(const boost::filesystem::path& sqlite_db);
} 
