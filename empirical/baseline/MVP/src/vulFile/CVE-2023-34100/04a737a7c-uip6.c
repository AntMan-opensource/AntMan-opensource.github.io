



























struct uip_stats uip_stat;







uip_lladdr_t uip_lladdr;

uip_lladdr_t uip_lladdr = {{0x00,0x06,0x98,0x00,0x02,0x32}};







uint8_t uip_ext_bitmap = 0;

uint16_t uip_ext_len = 0;

uint8_t uip_last_proto = 0;












uip_buf_t uip_aligned_buf;



void *uip_appdata;

void *uip_sappdata;



void *uip_urgdata;
uint16_t uip_urglen, uip_surglen;



uint16_t uip_len, uip_slen;







uint8_t uip_flags;


struct uip_conn *uip_conn;



static uint16_t lastport;

























struct uip_conn uip_conns[UIP_TCP_CONNS];


uint16_t uip_listenports[UIP_LISTENPORTS];


static uint8_t iss[4];


uint8_t uip_acc32[4];







struct uip_udp_conn *uip_udp_conn;
struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];








struct uip_icmp6_conn uip_icmp6_conns;







void uip_add32(uint8_t *op32, uint16_t op16)
{
  uip_acc32[3] = op32[3] + (op16 & 0xff);
  uip_acc32[2] = op32[2] + (op16 >> 8);
  uip_acc32[1] = op32[1];
  uip_acc32[0] = op32[0];

  if(uip_acc32[2] < (op16 >> 8)) {
    ++uip_acc32[1];
    if(uip_acc32[1] == 0) {
      ++uip_acc32[0];
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    ++uip_acc32[2];
    if(uip_acc32[2] == 0) {
      ++uip_acc32[1];
      if(uip_acc32[1] == 0) {
        ++uip_acc32[0];
      }
    }
  }
}




static uint16_t chksum(uint16_t sum, const uint8_t *data, uint16_t len)
{
  uint16_t t;
  const uint8_t *dataptr;
  const uint8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;

  while(dataptr < last_byte) {   
    t = (dataptr[0] << 8) + dataptr[1];
    sum += t;
    if(sum < t) {
      sum++;      
    }
    dataptr += 2;
  }

  if(dataptr == last_byte) {
    t = (dataptr[0] << 8) + 0;
    sum += t;
    if(sum < t) {
      sum++;      
    }
  }

  
  return sum;
}

uint16_t uip_chksum(uint16_t *data, uint16_t len)
{
  return uip_htons(chksum(0, (uint8_t *)data, len));
}


uint16_t uip_ipchksum(void)
{
  uint16_t sum;

  sum = chksum(0, uip_buf, UIP_IPH_LEN);
  LOG_DBG("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : uip_htons(sum);
}


static uint16_t upper_layer_chksum(uint8_t proto)
{

  volatile uint16_t upper_layer_len;
  uint16_t sum;

  upper_layer_len = uipbuf_get_len_field(UIP_IP_BUF) - uip_ext_len;

  LOG_DBG("Upper layer checksum len: %d from: %d\n", upper_layer_len, (int)(UIP_IP_PAYLOAD(uip_ext_len) - uip_buf));

  
  
  sum = upper_layer_len + proto;
  
  sum = chksum(sum, (uint8_t *)&UIP_IP_BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));

  
  sum = chksum(sum, UIP_IP_PAYLOAD(uip_ext_len), upper_layer_len);

  return (sum == 0) ? 0xffff : uip_htons(sum);
}

uint16_t uip_icmp6chksum(void)
{
  return upper_layer_chksum(UIP_PROTO_ICMP6);

}


uint16_t uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}



uint16_t uip_udpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_UDP);
}



void uip_init(void)
{
  int c;

  uipbuf_init();
  uip_ds6_init();
  uip_icmp6_init();
  uip_nd6_init();


  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_TCP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }



  lastport = 1024;



  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    uip_udp_conns[c].lport = 0;
  }



  UIP_MCAST6.init();

}


struct uip_conn * uip_connect(const uip_ipaddr_t *ripaddr, uint16_t rport)
{
  register struct uip_conn *conn, *cconn;
  int c;

  
  again:
  ++lastport;

  if(lastport >= 32000) {
    lastport = 4096;
  }

  
  for(c = 0; c < UIP_TCP_CONNS; ++c) {
    conn = &uip_conns[c];
    if(conn->tcpstateflags != UIP_CLOSED && conn->lport == uip_htons(lastport)) {
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_TCP_CONNS; ++c) {
    cconn = &uip_conns[c];
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
      if(conn == 0 || cconn->timer > conn->timer) {
        conn = cconn;
      }
    }
  }

  if(conn == 0) {
    return 0;
  }

  conn->tcpstateflags = UIP_SYN_SENT;

  conn->snd_nxt[0] = iss[0];
  conn->snd_nxt[1] = iss[1];
  conn->snd_nxt[2] = iss[2];
  conn->snd_nxt[3] = iss[3];

  conn->rcv_nxt[0] = 0;
  conn->rcv_nxt[1] = 0;
  conn->rcv_nxt[2] = 0;
  conn->rcv_nxt[3] = 0;

  conn->initialmss = conn->mss = UIP_TCP_MSS;

  conn->len = 1;   
  conn->nrtx = 0;
  conn->timer = 1; 
  conn->rto = UIP_RTO;
  conn->sa = 0;
  conn->sv = 16;   
  conn->lport = uip_htons(lastport);
  conn->rport = rport;
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);

  return conn;
}


bool uip_remove_ext_hdr(void)
{
  
  if(uip_ext_len > 0) {
    LOG_DBG("Removing IPv6 extension headers (extlen: %d, uiplen: %d)\n", uip_ext_len, uip_len);
    if(uip_len < UIP_IPH_LEN + uip_ext_len) {
      LOG_ERR("uip_len too short compared to ext len\n");
      uipbuf_clear();
      return false;
    }

    
    UIP_IP_BUF->proto = uip_last_proto;
    
    memmove(UIP_IP_PAYLOAD(0), UIP_IP_PAYLOAD(uip_ext_len), uip_len - UIP_IPH_LEN - uip_ext_len);

    
    if(uipbuf_add_ext_hdr(-uip_ext_len) == false) {
      return false;
    }
    uipbuf_set_len_field(UIP_IP_BUF, uip_len - UIP_IPH_LEN);
  }
  return true;
}


struct uip_udp_conn * uip_udp_new(const uip_ipaddr_t *ripaddr, uint16_t rport)
{
  int c;
  register struct uip_udp_conn *conn;

  
  again:
  ++lastport;

  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == uip_htons(lastport)) {
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
      conn = &uip_udp_conns[c];
      break;
    }
  }

  if(conn == 0) {
    return 0;
  }

  conn->lport = UIP_HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  }
  conn->ttl = uip_ds6_if.cur_hop_limit;

  return conn;
}



void uip_unlisten(uint16_t port)
{
  int c;
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == port) {
      uip_listenports[c] = 0;
      return;
    }
  }
}

void uip_listen(uint16_t port)
{
  int c;
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
      uip_listenports[c] = port;
      return;
    }
  }
}






static uint8_t uip_reassbuf[UIP_REASS_BUFSIZE];

static uint8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];


static const uint8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};
static uint16_t uip_reasslen;
static uint8_t uip_reassflags;









struct etimer uip_reass_timer; 
uint8_t uip_reass_on; 

static uint32_t uip_id; 


static uint16_t uip_reass(uint8_t *prev_proto_ptr)
{
  uint16_t offset=0;
  uint16_t len;
  uint16_t i;
  struct uip_frag_hdr *frag_buf = (struct uip_frag_hdr *)UIP_IP_PAYLOAD(uip_ext_len);

  
  
  if(uip_reass_on == 0) {
    LOG_INFO("Starting reassembly\n");
    memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
    
    etimer_set(&uip_reass_timer, UIP_REASS_MAXAGE*CLOCK_SECOND);
    uip_reass_on = 1;
    uip_reassflags = 0;
    uip_id = frag_buf->id;
    
    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
  }
  
  if(uip_ipaddr_cmp(&FBUF->srcipaddr, &UIP_IP_BUF->srcipaddr) && uip_ipaddr_cmp(&FBUF->destipaddr, &UIP_IP_BUF->destipaddr) && frag_buf->id == uip_id) {

    len = uip_len - uip_ext_len - UIP_IPH_LEN - UIP_FRAGH_LEN;
    offset = (uip_ntohs(frag_buf->offsetresmore) & 0xfff8);
    
    LOG_INFO("len %d\n", len);
    LOG_INFO("offset %d\n", offset);
    if(offset == 0){
      uip_reassflags |= UIP_REASS_FLAG_FIRSTFRAG;
      
      *prev_proto_ptr = frag_buf->next;
      memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
      LOG_INFO("src ");
      LOG_INFO_6ADDR(&FBUF->srcipaddr);
      LOG_INFO_("dest ");
      LOG_INFO_6ADDR(&FBUF->destipaddr);
      LOG_INFO_("next %d\n", UIP_IP_BUF->proto);

    }

    
    if(offset > UIP_REASS_BUFSIZE || offset + len > UIP_REASS_BUFSIZE) {
      uip_reass_on = 0;
      etimer_stop(&uip_reass_timer);
      return 0;
    }

    
    if((uip_ntohs(frag_buf->offsetresmore) & IP_MF) == 0) {
      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
      
      uip_reasslen = offset + len;
      LOG_INFO("last fragment reasslen %d\n", uip_reasslen);
    } else {
      
      if(len % 8 != 0){
        uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, 4);
        uip_reassflags |= UIP_REASS_FLAG_ERROR_MSG;
        
        uip_reass_on = 0;
        etimer_stop(&uip_reass_timer);
        return uip_len;
      }
    }

    
    memcpy((uint8_t *)FBUF + UIP_IPH_LEN + uip_ext_len + offset, (uint8_t *)frag_buf + UIP_FRAGH_LEN, len);

    
    if(offset >> 6 == (offset + len) >> 6) {
      uip_reassbitmap[offset >> 6] |= bitmap_bits[(offset >> 3) & 7] & ~bitmap_bits[((offset + len) >> 3)  & 7];

    } else {
      
      uip_reassbitmap[offset >> 6] |= bitmap_bits[(offset >> 3) & 7];

      for(i = (1 + (offset >> 6)); i < ((offset + len) >> 6); ++i) {
        uip_reassbitmap[i] = 0xff;
      }
      uip_reassbitmap[(offset + len) >> 6] |= ~bitmap_bits[((offset + len) >> 3) & 7];
    }

    

    if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
      
      for(i = 0; i < (uip_reasslen >> 6); ++i) {
        if(uip_reassbitmap[i] != 0xff) {
          return 0;
        }
      }
      
      if(uip_reassbitmap[uip_reasslen >> 6] != (uint8_t)~bitmap_bits[(uip_reasslen >> 3) & 7]) {
        return 0;
      }

      
      uip_reass_on = 0;
      etimer_stop(&uip_reass_timer);

      uip_reasslen += UIP_IPH_LEN + uip_ext_len;
      memcpy(UIP_IP_BUF, FBUF, uip_reasslen);
      uipbuf_set_len_field(UIP_IP_BUF, uip_reasslen - UIP_IPH_LEN);
      LOG_INFO("reassembled packet %d (%d)\n", uip_reasslen, uipbuf_get_len_field(UIP_IP_BUF));

      return uip_reasslen;

    }
  } else {
    LOG_WARN("Already reassembling another paquet\n");
  }
  return 0;
}

void uip_reass_over(void)
{
  

  uip_reass_on = 0;
  etimer_stop(&uip_reass_timer);

  if(uip_reassflags & UIP_REASS_FLAG_FIRSTFRAG){
    LOG_ERR("fragmentation timeout\n");
    
    
    uipbuf_clear();
    memcpy(UIP_IP_BUF, FBUF, UIP_IPH_LEN); 
    uip_icmp6_error_output(ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY, 0);

    UIP_STAT(++uip_stat.ip.sent);
    uip_flags = 0;
  }
}





static void uip_add_rcv_nxt(uint16_t n)
{
  uip_add32(uip_conn->rcv_nxt, n);
  uip_conn->rcv_nxt[0] = uip_acc32[0];
  uip_conn->rcv_nxt[1] = uip_acc32[1];
  uip_conn->rcv_nxt[2] = uip_acc32[2];
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}




static uint8_t ext_hdr_options_process(uint8_t *ext_buf)
{
  
  uint16_t opt_offset = 2; 
  struct uip_hbho_hdr *ext_hdr = (struct uip_hbho_hdr *)ext_buf;
  uint16_t ext_hdr_len = (ext_hdr->len << 3) + 8;

  while(opt_offset + 2 <= ext_hdr_len) { 
    struct uip_ext_hdr_opt *opt_hdr = (struct uip_ext_hdr_opt *)(ext_buf + opt_offset);
    uint16_t opt_len = opt_hdr->len + 2;

    if(opt_offset + opt_len > ext_hdr_len) {
      LOG_ERR("Extension header option too long: dropping packet\n");
      uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, (ext_buf + opt_offset) - uip_buf);
      return 2;
    }

    switch(opt_hdr->type) {
    
    case UIP_EXT_HDR_OPT_PAD1:
      LOG_DBG("Processing PAD1 option\n");
      opt_offset += 1;
      break;
    case UIP_EXT_HDR_OPT_PADN:
      LOG_DBG("Processing PADN option\n");
      opt_offset += opt_len;
      break;
    case UIP_EXT_HDR_OPT_RPL:
      
      LOG_DBG("Processing RPL option\n");
      if(!NETSTACK_ROUTING.ext_header_hbh_update(ext_buf, opt_offset)) {
        LOG_ERR("RPL Option Error: Dropping Packet\n");
        return 1;
      }
      opt_offset += opt_len;
      break;

    case UIP_EXT_HDR_OPT_MPL:
      
      LOG_DBG("Processing MPL option\n");
      opt_offset += opt_len + opt_len;
      break;

    default:
      
      LOG_DBG("Unrecognized option, MSB 0x%x\n", opt_hdr->type);
      switch(opt_hdr->type & 0xC0) {
      case 0:
        break;
      case 0x40:
        return 1;
      case 0xC0:
        if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
          return 1;
        }
      case 0x80:
        uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, (ext_buf + opt_offset) - uip_buf);
        return 2;
      }
      
      opt_offset += opt_len;
      break;
    }
  }
  return 0;
}

static bool uip_check_mtu(void)
{
  if(uip_len > UIP_LINK_MTU) {
    uip_icmp6_error_output(ICMP6_PACKET_TOO_BIG, 0, UIP_LINK_MTU);
    UIP_STAT(++uip_stat.ip.drop);
    return false;
  } else {
    return true;
  }
}

static bool uip_update_ttl(void)
{
  if(UIP_IP_BUF->ttl <= 1) {
    uip_icmp6_error_output(ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_TRANSIT, 0);
    UIP_STAT(++uip_stat.ip.drop);
    return false;
  } else {
    UIP_IP_BUF->ttl = UIP_IP_BUF->ttl - 1;
    return true;
  }
}

void uip_process(uint8_t flag)
{
  uint8_t *last_header;
  uint8_t protocol;
  uint8_t *next_header;
  struct uip_ext_hdr *ext_ptr;

  int c;
  uint16_t tmp16;
  uint8_t opt;
  register struct uip_conn *uip_connr = uip_conn;


  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
  }

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN];

  
  if(flag == UIP_POLL_REQUEST) {

    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED && !uip_outstanding(uip_connr)) {
      uip_flags = UIP_POLL;
      UIP_APPCALL();
      goto appsend;

    } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) {
      
      UIP_TCP_BUF->flags = 0;
      goto tcp_send_syn;

    }
    goto drop;

    
  } else if(flag == UIP_TIMER) {
    

    uipbuf_clear();
    uip_slen = 0;

    
    if(++iss[3] == 0) {
      if(++iss[2] == 0) {
        if(++iss[1] == 0) {
          ++iss[0];
        }
      }
    }

    
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT || uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
        uip_connr->tcpstateflags = UIP_CLOSED;
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
      
      if(uip_outstanding(uip_connr)) {
        if(uip_connr->timer-- == 0) {
          if(uip_connr->nrtx == UIP_MAXRTX || ((uip_connr->tcpstateflags == UIP_SYN_SENT || uip_connr->tcpstateflags == UIP_SYN_RCVD) && uip_connr->nrtx == UIP_MAXSYNRTX)) {


            uip_connr->tcpstateflags = UIP_CLOSED;

            
            uip_flags = UIP_TIMEDOUT;
            UIP_APPCALL();

            
            UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
            goto tcp_send_nodata;
          }

          
          uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4? 4:
                                         uip_connr->nrtx);
          ++(uip_connr->nrtx);

          
          UIP_STAT(++uip_stat.tcp.rexmit);
          switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
          case UIP_SYN_RCVD:
            
            goto tcp_send_synack;


          case UIP_SYN_SENT:
            
            UIP_TCP_BUF->flags = 0;
            goto tcp_send_syn;


          case UIP_ESTABLISHED:
            
            uip_flags = UIP_REXMIT;
            UIP_APPCALL();
            goto apprexmit;

          case UIP_FIN_WAIT_1:
          case UIP_CLOSING:
          case UIP_LAST_ACK:
            
            goto tcp_send_finack;
          }
        }
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
        
        uip_flags = UIP_POLL;
        UIP_APPCALL();
        goto appsend;
      }
    }
    goto drop;

  }

  if(flag == UIP_UDP_TIMER) {
    if(uip_udp_conn->lport != 0) {
      uip_conn = NULL;
      uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN];
      uip_len = uip_slen = 0;
      uip_flags = UIP_POLL;
      UIP_UDP_APPCALL();
      goto udp_send;
    } else {
      goto drop;
    }
  }



  
  UIP_STAT(++uip_stat.ip.recv);

  

  
  if(uip_len < UIP_IPH_LEN) {
    UIP_STAT(++uip_stat.ip.drop);
    LOG_WARN("incomplete IPv6 header received (%d bytes)\n", (int)uip_len);
    goto drop;
  }

  
  if((UIP_IP_BUF->vtc & 0xf0) != 0x60)  { 
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.vhlerr);
    LOG_ERR("invalid version\n");
    goto drop;
  }

  
  if(uip_len < uipbuf_get_len_field(UIP_IP_BUF)) {
    UIP_STAT(++uip_stat.ip.drop);
    LOG_ERR("packet shorter than reported in IP header\n");
    goto drop;
  }

  
  uip_len = uipbuf_get_len_field(UIP_IP_BUF) + UIP_IPH_LEN;

  
  if(uip_len > sizeof(uip_buf)) {
    UIP_STAT(++uip_stat.ip.drop);
    LOG_WARN("dropping packet with length %d > %d\n", (int)uip_len, (int)sizeof(uip_buf));
    goto drop;
  }

  
  uip_last_proto = 0;
  last_header = uipbuf_get_last_header(uip_buf, uip_len, &uip_last_proto);
  if(last_header == NULL) {
    LOG_ERR("invalid extension header chain\n");
    goto drop;
  }
  
  uip_ext_len = last_header - UIP_IP_PAYLOAD(0);

  LOG_INFO("packet received from ");
  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
  LOG_INFO_(" to ");
  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
  LOG_INFO_("\n");

  if(uip_is_addr_mcast(&UIP_IP_BUF->srcipaddr)){
    UIP_STAT(++uip_stat.ip.drop);
    LOG_ERR("Dropping packet, src is mcast\n");
    goto drop;
  }

  

  if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    uip_ds6_nbr_refresh_reachable_state(&UIP_IP_BUF->srcipaddr);
  }



  

  next_header = uipbuf_get_next_header(uip_buf, uip_len, &protocol, true);
  if(next_header != NULL && protocol == UIP_PROTO_HBHO) {
    switch(ext_hdr_options_process(next_header)) {
    case 0:
      break; 
    case 1:
      goto drop; 
    case 2:
      goto send; 
    }
  }

  

  if(uip_is_addr_mcast_routable(&UIP_IP_BUF->destipaddr)) {
    if(UIP_MCAST6.in() == UIP_MCAST6_ACCEPT) {
      
      goto process;
    } else {
      
      goto drop;
    }
  }


  
  if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) && !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr)) {
    if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr) && !uip_is_addr_linklocal(&UIP_IP_BUF->destipaddr) && !uip_is_addr_linklocal(&UIP_IP_BUF->srcipaddr) && !uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr) && !uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) {




      if(!uip_check_mtu() || !uip_update_ttl()) {
        
        goto send;
      }

      LOG_INFO("Forwarding packet to next hop, dest: ");
      LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
      LOG_INFO_("\n");
      UIP_STAT(++uip_stat.ip.forwarded);
      goto send;
    } else {
      if((uip_is_addr_linklocal(&UIP_IP_BUF->srcipaddr)) && (!uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) && (!uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) && (!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) && (!uip_ds6_is_addr_onlink((&UIP_IP_BUF->destipaddr)))) {



        LOG_ERR("LL source address with off link destination, dropping\n");
        uip_icmp6_error_output(ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOTNEIGHBOR, 0);
        goto send;
      }
      LOG_ERR("Dropping packet, not for me and link local or multicast\n");
      UIP_STAT(++uip_stat.ip.drop);
      goto drop;
    }
  }

  if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) && !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr) && !uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {

    LOG_ERR("Dropping packet, not for me\n");
    UIP_STAT(++uip_stat.ip.drop);
    goto drop;
  }



  process:


  
  uip_ext_bitmap = 0;
  for(next_header = uipbuf_get_next_header(uip_buf, uip_len, &protocol, true);
      next_header != NULL && uip_is_proto_ext_hdr(protocol);
      next_header = uipbuf_get_next_header(next_header, uip_len - (next_header - uip_buf), &protocol, false)) {

    ext_ptr = (struct uip_ext_hdr *)next_header;
    switch(protocol) {
    case UIP_PROTO_HBHO:
      LOG_DBG("Processing hbh header\n");
      

      
      if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_HBHO) {
        goto bad_hdr;
      } else {
        uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;
      }

      switch(ext_hdr_options_process(next_header)) {
      case 0:
        break; 
      case 1:
        goto drop; 
      case 2:
        goto send; 
      }
      break;
    case UIP_PROTO_DESTO:

      
      LOG_DBG("Processing desto header\n");
      if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO1) {
        if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO2) {
          goto bad_hdr;
        } else{
          uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO2;
        }
      } else {
        uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO1;
      }

      switch(ext_hdr_options_process(next_header)) {
      case 0:
        break; 
      case 1:
        goto drop; 
      case 2:
        goto send; 
      }
      break;
    case UIP_PROTO_ROUTING:

      
      if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_ROUTING) {
        goto bad_hdr;
      } else {
        uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_ROUTING;
      }

      

      LOG_DBG("Processing Routing header\n");
      if(((struct uip_routing_hdr *)ext_ptr)->seg_left > 0) {
        
        if(NETSTACK_ROUTING.ext_header_srh_update()) {

          
          if(!uip_check_mtu() || !uip_update_ttl()) {
            
            goto send;
          }

          LOG_INFO("Forwarding packet to next hop, dest: ");
          LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
          LOG_INFO_("\n");
          UIP_STAT(++uip_stat.ip.forwarded);

          goto send; 
        } else {
          LOG_ERR("Unrecognized routing type\n");
          goto bad_hdr;
        }
      }
      break;
    case UIP_PROTO_FRAG:
      

      LOG_INFO("Processing fragmentation header\n");
      uip_len = uip_reass(&ext_ptr->next);
      if(uip_len == 0) {
        goto drop;
      }
      if(uip_reassflags & UIP_REASS_FLAG_ERROR_MSG) {
        
        goto send;
      }
      
      LOG_INFO("Processing reassembled packet\n");
      uip_ext_bitmap = 0;
      next_header = uipbuf_get_next_header(uip_buf, uip_len, &protocol, true);
      break;

      UIP_STAT(++uip_stat.ip.drop);
      UIP_STAT(++uip_stat.ip.fragerr);
      LOG_ERR("fragment dropped.");
      goto drop;

    case UIP_PROTO_NONE:
      goto drop;
    default:
      goto bad_hdr;
    }
  }

  
  if(next_header != NULL) {
    switch(protocol) {

    case UIP_PROTO_TCP:
      
      goto tcp_input;


    case UIP_PROTO_UDP:
      
      goto udp_input;

    case UIP_PROTO_ICMP6:
      
      goto icmp6_input;
    }
  }

  bad_hdr:
  
  uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER, (uint32_t)(next_header - uip_buf));
  UIP_STAT(++uip_stat.ip.drop);
  UIP_STAT(++uip_stat.ip.protoerr);
  LOG_ERR("unrecognized header\n");
  goto send;
  

  icmp6_input:
  
  LOG_INFO("icmpv6 input length %d type: %d \n", uip_len, UIP_ICMP_BUF->type);


  
  if(uip_icmp6chksum() != 0xffff) {
    UIP_STAT(++uip_stat.icmp.drop);
    UIP_STAT(++uip_stat.icmp.chkerr);
    LOG_ERR("icmpv6 bad checksum\n");
    goto drop;
  }


  UIP_STAT(++uip_stat.icmp.recv);
  

  UIP_ICMP6_APPCALL(UIP_ICMP_BUF->type);


  
  if(uip_icmp6_input(UIP_ICMP_BUF->type, UIP_ICMP_BUF->icode) == UIP_ICMP6_INPUT_ERROR) {
    LOG_ERR("Unknown ICMPv6 message type/code %d\n", UIP_ICMP_BUF->type);
    UIP_STAT(++uip_stat.icmp.drop);
    UIP_STAT(++uip_stat.icmp.typeerr);
    uipbuf_clear();
  }

  if(uip_len > 0) {
    goto send;
  } else {
    goto drop;
  }
  



  
  udp_input:

  uip_remove_ext_hdr();

  LOG_INFO("Receiving UDP packet\n");

  

  
  if(UIP_UDP_BUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
    UIP_STAT(++uip_stat.udp.drop);
    UIP_STAT(++uip_stat.udp.chkerr);
    LOG_ERR("udp: bad checksum 0x%04x 0x%04x\n", UIP_UDP_BUF->udpchksum, uip_udpchksum());
    goto drop;
  }


  
  if(UIP_UDP_BUF->destport == 0) {
    LOG_ERR("udp: zero port.\n");
    goto drop;
  }

  
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    
    if(uip_udp_conn->lport != 0 && UIP_UDP_BUF->destport == uip_udp_conn->lport && (uip_udp_conn->rport == 0 || UIP_UDP_BUF->srcport == uip_udp_conn->rport) && (uip_is_addr_unspecified(&uip_udp_conn->ripaddr) || uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_udp_conn->ripaddr))) {




      goto udp_found;
    }
  }
  LOG_ERR("udp: no matching connection found\n");
  UIP_STAT(++uip_stat.udp.drop);

  uip_icmp6_error_output(ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT, 0);
  goto send;

  udp_found:
  LOG_DBG("In udp_found\n");
  UIP_STAT(++uip_stat.udp.recv);

  uip_len = uip_len - UIP_IPUDPH_LEN;
  uip_appdata = &uip_buf[UIP_IPUDPH_LEN];
  uip_conn = NULL;
  uip_flags = UIP_NEWDATA;
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN];
  uip_slen = 0;
  UIP_UDP_APPCALL();

  udp_send:
  LOG_DBG("In udp_send\n");

  if(uip_slen == 0) {
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;

  
  uipbuf_set_len_field(UIP_IP_BUF, uip_len - UIP_IPH_LEN);

  UIP_IP_BUF->vtc = 0x60;
  UIP_IP_BUF->tcflow = 0x00;
  UIP_IP_BUF->ttl = uip_udp_conn->ttl;
  UIP_IP_BUF->proto = UIP_PROTO_UDP;

  UIP_UDP_BUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
  UIP_UDP_BUF->udpchksum = 0;

  UIP_UDP_BUF->srcport  = uip_udp_conn->lport;
  UIP_UDP_BUF->destport = uip_udp_conn->rport;

  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_udp_conn->ripaddr);
  uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);

  uip_appdata = &uip_buf[UIP_IPTCPH_LEN];


  
  UIP_UDP_BUF->udpchksum = ~(uip_udpchksum());
  if(UIP_UDP_BUF->udpchksum == 0) {
    UIP_UDP_BUF->udpchksum = 0xffff;
  }


  UIP_STAT(++uip_stat.udp.sent);
  goto ip_send_nolen;



  
  tcp_input:

  uip_remove_ext_hdr();

  UIP_STAT(++uip_stat.tcp.recv);
  LOG_INFO("Receiving TCP packet\n");
  

  if(uip_tcpchksum() != 0xffff) {   
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    LOG_ERR("tcp: bad checksum 0x%04x 0x%04x\n", UIP_TCP_BUF->tcpchksum, uip_tcpchksum());
    goto drop;
  }

  
  if(UIP_TCP_BUF->destport == 0 || UIP_TCP_BUF->srcport == 0) {
    LOG_ERR("tcp: zero port\n");
    goto drop;
  }

  
  
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_TCP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED && UIP_TCP_BUF->destport == uip_connr->lport && UIP_TCP_BUF->srcport == uip_connr->rport && uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_connr->ripaddr)) {


      goto found;
    }
  }

  
  if((UIP_TCP_BUF->flags & TCP_CTL) != TCP_SYN) {
    goto reset;
  }

  tmp16 = UIP_TCP_BUF->destport;
  
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(tmp16 == uip_listenports[c]) {
      goto found_listen;
    }
  }

  
  UIP_STAT(++uip_stat.tcp.synrst);

  reset:
  LOG_WARN("In reset\n");
  
  if(UIP_TCP_BUF->flags & TCP_RST) {
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
  uip_len = UIP_IPTCPH_LEN;
  UIP_TCP_BUF->tcpoffset = 5 << 4;

  
  c = UIP_TCP_BUF->seqno[3];
  UIP_TCP_BUF->seqno[3] = UIP_TCP_BUF->ackno[3];
  UIP_TCP_BUF->ackno[3] = c;

  c = UIP_TCP_BUF->seqno[2];
  UIP_TCP_BUF->seqno[2] = UIP_TCP_BUF->ackno[2];
  UIP_TCP_BUF->ackno[2] = c;

  c = UIP_TCP_BUF->seqno[1];
  UIP_TCP_BUF->seqno[1] = UIP_TCP_BUF->ackno[1];
  UIP_TCP_BUF->ackno[1] = c;

  c = UIP_TCP_BUF->seqno[0];
  UIP_TCP_BUF->seqno[0] = UIP_TCP_BUF->ackno[0];
  UIP_TCP_BUF->ackno[0] = c;

  
  if(++UIP_TCP_BUF->ackno[3] == 0) {
    if(++UIP_TCP_BUF->ackno[2] == 0) {
      if(++UIP_TCP_BUF->ackno[1] == 0) {
        ++UIP_TCP_BUF->ackno[0];
      }
    }
  }

  
  tmp16 = UIP_TCP_BUF->srcport;
  UIP_TCP_BUF->srcport = UIP_TCP_BUF->destport;
  UIP_TCP_BUF->destport = tmp16;

  
  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);
  uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
  
  goto tcp_send_noconn;

  
  found_listen:
  LOG_DBG("In found listen\n");
  
  uip_connr = 0;
  for(c = 0; c < UIP_TCP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
      uip_connr = &uip_conns[c];
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 || uip_conns[c].timer > uip_connr->timer) {
        uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    
    UIP_STAT(++uip_stat.tcp.syndrop);
    LOG_ERR("tcp: found no unused connections\n");
    goto drop;
  }
  uip_conn = uip_connr;

  
  uip_connr->rto = uip_connr->timer = UIP_RTO;
  uip_connr->sa = 0;
  uip_connr->sv = 4;
  uip_connr->nrtx = 0;
  uip_connr->lport = UIP_TCP_BUF->destport;
  uip_connr->rport = UIP_TCP_BUF->srcport;
  uip_ipaddr_copy(&uip_connr->ripaddr, &UIP_IP_BUF->srcipaddr);
  uip_connr->tcpstateflags = UIP_SYN_RCVD;

  uip_connr->snd_nxt[0] = iss[0];
  uip_connr->snd_nxt[1] = iss[1];
  uip_connr->snd_nxt[2] = iss[2];
  uip_connr->snd_nxt[3] = iss[3];
  uip_connr->len = 1;

  
  uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
  uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
  uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
  uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
  uip_add_rcv_nxt(1);

  
  if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
      opt = uip_buf[UIP_IPTCPH_LEN + c];
      if(opt == TCP_OPT_END) {
        
        break;
      } else if(opt == TCP_OPT_NOOP) {
        ++c;
        
      } else if(opt == TCP_OPT_MSS && uip_buf[UIP_IPTCPH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
        
        tmp16 = ((uint16_t)uip_buf[UIP_IPTCPH_LEN + 2 + c] << 8) | (uint16_t)uip_buf[UIP_IPTCPH_LEN + 3 + c];
        uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

        
        break;
      } else {
        
        if(uip_buf[UIP_IPTCPH_LEN + 1 + c] == 0) {
          
          break;
        }
        c += uip_buf[UIP_IPTCPH_LEN + 1 + c];
      }
    }
  }

  

  tcp_send_synack:
  UIP_TCP_BUF->flags = TCP_ACK;

  tcp_send_syn:
  UIP_TCP_BUF->flags |= TCP_SYN;

  tcp_send_synack:
  UIP_TCP_BUF->flags = TCP_SYN | TCP_ACK;


  
  UIP_TCP_BUF->optdata[0] = TCP_OPT_MSS;
  UIP_TCP_BUF->optdata[1] = TCP_OPT_MSS_LEN;
  UIP_TCP_BUF->optdata[2] = (UIP_TCP_MSS) / 256;
  UIP_TCP_BUF->optdata[3] = (UIP_TCP_MSS) & 255;
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
  UIP_TCP_BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
  goto tcp_send;

  
  found:
  LOG_DBG("In found\n");
  uip_conn = uip_connr;
  uip_flags = 0;
  
  if(UIP_TCP_BUF->flags & TCP_RST) {
    uip_connr->tcpstateflags = UIP_CLOSED;
    LOG_WARN("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    UIP_APPCALL();
    goto drop;
  }
  
  c = (UIP_TCP_BUF->tcpoffset >> 4) << 2;

  
  if(uip_len < c + UIP_IPH_LEN) {
    LOG_WARN("Dropping TCP packet with too large data offset (%u bytes)\n", (unsigned)c);
    goto drop;
  }

  
  uip_len = uip_len - c - UIP_IPH_LEN;

  
  if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) && ((UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) || (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) && ((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN)))) {


    if((uip_len > 0 || ((UIP_TCP_BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) && (UIP_TCP_BUF->seqno[0] != uip_connr->rcv_nxt[0] || UIP_TCP_BUF->seqno[1] != uip_connr->rcv_nxt[1] || UIP_TCP_BUF->seqno[2] != uip_connr->rcv_nxt[2] || UIP_TCP_BUF->seqno[3] != uip_connr->rcv_nxt[3])) {




      if((UIP_TCP_BUF->flags & TCP_SYN)) {
        if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) {
          goto tcp_send_synack;

        } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) {
          goto tcp_send_syn;

        }
      }
      goto tcp_send_ack;
    }
  }

  
  if((UIP_TCP_BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(UIP_TCP_BUF->ackno[0] == uip_acc32[0] && UIP_TCP_BUF->ackno[1] == uip_acc32[1] && UIP_TCP_BUF->ackno[2] == uip_acc32[2] && UIP_TCP_BUF->ackno[3] == uip_acc32[3]) {


      
      uip_connr->snd_nxt[0] = uip_acc32[0];
      uip_connr->snd_nxt[1] = uip_acc32[1];
      uip_connr->snd_nxt[2] = uip_acc32[2];
      uip_connr->snd_nxt[3] = uip_acc32[3];

      
      if(uip_connr->nrtx == 0) {
        signed char m;
        m = uip_connr->rto - uip_connr->timer;
        
        m = m - (uip_connr->sa >> 3);
        uip_connr->sa += m;
        if(m < 0) {
          m = -m;
        }
        m = m - (uip_connr->sv >> 2);
        uip_connr->sv += m;
        uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;

      }
      
      uip_flags = UIP_ACKDATA;
      
      uip_connr->timer = uip_connr->rto;

      
      uip_connr->len = 0;
    }

  }

  
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
  
  case UIP_SYN_RCVD:
    
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
      uip_flags = UIP_CONNECTED;
      uip_connr->len = 0;
      if(uip_len > 0) {
        uip_flags |= UIP_NEWDATA;
        uip_add_rcv_nxt(uip_len);
      }
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    
    if((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN) {
      goto tcp_send_synack;
    }
    goto drop;

  case UIP_SYN_SENT:
    
    if((uip_flags & UIP_ACKDATA) && (UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      
      if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
        for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
          opt = uip_buf[UIP_IPTCPH_LEN + c];
          if(opt == TCP_OPT_END) {
            
            break;
          } else if(opt == TCP_OPT_NOOP) {
            ++c;
            
          } else if(opt == TCP_OPT_MSS && uip_buf[UIP_IPTCPH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
            
            tmp16 = (uip_buf[UIP_IPTCPH_LEN + 2 + c] << 8) | uip_buf[UIP_IPTCPH_LEN + 3 + c];
            uip_connr->initialmss = uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

            
            break;
          } else {
            
            if(uip_buf[UIP_IPTCPH_LEN + 1 + c] == 0) {
              
              break;
            }
            c += uip_buf[UIP_IPTCPH_LEN + 1 + c];
          }
        }
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
      uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
      uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
      uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
      uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
      uip_connr->len = 0;
      uipbuf_clear();
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    
    uip_flags = UIP_ABORT;
    UIP_APPCALL();
    
    uip_conn->tcpstateflags = UIP_CLOSED;
    goto reset;


  case UIP_ESTABLISHED:
    

    if(UIP_TCP_BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
      if(uip_outstanding(uip_connr)) {
        goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
      uip_flags |= UIP_CLOSE;
      if(uip_len > 0) {
        uip_flags |= UIP_NEWDATA;
      }
      UIP_APPCALL();
      uip_connr->len = 1;
      uip_connr->tcpstateflags = UIP_LAST_ACK;
      uip_connr->nrtx = 0;
      tcp_send_finack:
      UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
      goto tcp_send_nodata;
    }

    
    if((UIP_TCP_BUF->flags & TCP_URG) != 0) {
      tmp16 = (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];
      if(tmp16 > uip_len) {
        
        tmp16 = uip_len;
      }

      uip_urglen = tmp16;
      uip_add_rcv_nxt(uip_urglen);
      uip_len -= uip_urglen;
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;

      
      uip_appdata = ((char *)uip_appdata) + tmp16;
      uip_len -= tmp16;

    }

    
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
      uip_flags |= UIP_NEWDATA;
      uip_add_rcv_nxt(uip_len);
    }

    
    tmp16 = ((uint16_t)UIP_TCP_BUF->wnd[0] << 8) + (uint16_t)UIP_TCP_BUF->wnd[1];
    if(tmp16 > uip_connr->initialmss || tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    }
    uip_connr->mss = tmp16;

    
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
      uip_slen = 0;
      UIP_APPCALL();

      appsend:

      if(uip_flags & UIP_ABORT) {
        uip_slen = 0;
        uip_connr->tcpstateflags = UIP_CLOSED;
        UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
        goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
        uip_slen = 0;
        uip_connr->len = 1;
        uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
        uip_connr->nrtx = 0;
        UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
        goto tcp_send_nodata;
      }

      
      if(uip_slen > 0) {

        
        if((uip_flags & UIP_ACKDATA) != 0) {
          uip_connr->len = 0;
        }

        
        if(uip_connr->len == 0) {

          
          if(uip_slen > uip_connr->mss) {
            uip_slen = uip_connr->mss;
          }

          
          uip_connr->len = uip_slen;
        } else {

          
          uip_slen = uip_connr->len;
        }
      }
      uip_connr->nrtx = 0;
      apprexmit:
      uip_appdata = uip_sappdata;

      
      if(uip_slen > 0 && uip_connr->len > 0) {
        
        uip_len = uip_connr->len + UIP_IPTCPH_LEN;
        
        UIP_TCP_BUF->flags = TCP_ACK | TCP_PSH;
        
        goto tcp_send_noopts;
      }
      
      if(uip_flags & UIP_NEWDATA) {
        uip_len = UIP_IPTCPH_LEN;
        UIP_TCP_BUF->flags = TCP_ACK;
        goto tcp_send_noopts;
      }
    }
    goto drop;
  case UIP_LAST_ACK:
    
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_CLOSED;
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
    }
    break;

  case UIP_FIN_WAIT_1:
    
    if(uip_len > 0) {
      uip_add_rcv_nxt(uip_len);
    }
    if(UIP_TCP_BUF->flags & TCP_FIN) {
      if(uip_flags & UIP_ACKDATA) {
        uip_connr->tcpstateflags = UIP_TIME_WAIT;
        uip_connr->timer = 0;
        uip_connr->len = 0;
      } else {
        uip_connr->tcpstateflags = UIP_CLOSING;
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
      uip_connr->len = 0;
      goto drop;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
      uip_add_rcv_nxt(uip_len);
    }
    if(UIP_TCP_BUF->flags & TCP_FIN) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
    }
  }
  goto drop;

  
  tcp_send_ack:
  UIP_TCP_BUF->flags = TCP_ACK;

  tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;

  tcp_send_noopts:
  UIP_TCP_BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;

  
  tcp_send:
  LOG_DBG("In tcp_send\n");

  UIP_TCP_BUF->ackno[0] = uip_connr->rcv_nxt[0];
  UIP_TCP_BUF->ackno[1] = uip_connr->rcv_nxt[1];
  UIP_TCP_BUF->ackno[2] = uip_connr->rcv_nxt[2];
  UIP_TCP_BUF->ackno[3] = uip_connr->rcv_nxt[3];

  UIP_TCP_BUF->seqno[0] = uip_connr->snd_nxt[0];
  UIP_TCP_BUF->seqno[1] = uip_connr->snd_nxt[1];
  UIP_TCP_BUF->seqno[2] = uip_connr->snd_nxt[2];
  UIP_TCP_BUF->seqno[3] = uip_connr->snd_nxt[3];

  UIP_TCP_BUF->srcport  = uip_connr->lport;
  UIP_TCP_BUF->destport = uip_connr->rport;

  UIP_IP_BUF->vtc = 0x60;
  UIP_IP_BUF->tcflow = 0x00;

  uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_connr->ripaddr);
  uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
  LOG_INFO("Sending TCP packet to ");
  LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr);
  LOG_INFO_(" from ");
  LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
  LOG_INFO_("\n");

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    
    UIP_TCP_BUF->wnd[0] = UIP_TCP_BUF->wnd[1] = 0;
  } else {
    UIP_TCP_BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    UIP_TCP_BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
  }

  tcp_send_noconn:
  UIP_IP_BUF->proto = UIP_PROTO_TCP;

  UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
  uipbuf_set_len_field(UIP_IP_BUF, uip_len - UIP_IPH_LEN);

  UIP_TCP_BUF->urgp[0] = UIP_TCP_BUF->urgp[1] = 0;

  
  UIP_TCP_BUF->tcpchksum = 0;
  UIP_TCP_BUF->tcpchksum = ~(uip_tcpchksum());
  UIP_STAT(++uip_stat.tcp.sent);



  ip_send_nolen:

  UIP_IP_BUF->flow = 0x00;
  send:
  LOG_INFO("Sending packet with length %d (%d)\n", uip_len, uipbuf_get_len_field(UIP_IP_BUF));

  UIP_STAT(++uip_stat.ip.sent);
  
  uip_flags = 0;
  return;

  drop:
  uipbuf_clear();
  uip_ext_bitmap = 0;
  uip_flags = 0;
  return;
}

uint16_t uip_htons(uint16_t val)
{
  return UIP_HTONS(val);
}

uint32_t uip_htonl(uint32_t val)
{
  return UIP_HTONL(val);
}

void uip_send(const void *data, int len)
{
  int copylen;

  if(uip_sappdata != NULL) {
    copylen = MIN(len, UIP_BUFSIZE - UIP_IPTCPH_LEN - (int)((char *)uip_sappdata - (char *)UIP_TCP_PAYLOAD));
  } else {
    copylen = MIN(len, UIP_BUFSIZE - UIP_IPTCPH_LEN);
  }
  if(copylen > 0) {
    uip_slen = copylen;
    if(data != uip_sappdata) {
      if(uip_sappdata == NULL) {
        memcpy(UIP_TCP_PAYLOAD, (data), uip_slen);
      } else {
        memcpy(uip_sappdata, (data), uip_slen);
      }
    }
  }
}


