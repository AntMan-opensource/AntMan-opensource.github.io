
































































using base::Time;
using base::TimeTicks;
using favicon::FaviconBitmap;
using favicon::FaviconBitmapID;
using favicon::FaviconBitmapIDSize;
using favicon::FaviconBitmapType;
using favicon::IconMapping;
using syncer::ClientTagBasedModelTypeProcessor;



namespace history {

namespace {





class HistoryPathsTracker {
 public:
  HistoryPathsTracker(const HistoryPathsTracker&) = delete;
  HistoryPathsTracker& operator=(const HistoryPathsTracker&) = delete;

  static HistoryPathsTracker* GetInstance() {
    static base::NoDestructor<HistoryPathsTracker> instance;
    return instance.get();
  }

  void AddPath(const base::FilePath& file_path) {
    base::AutoLock auto_lock(lock_);
    paths_.insert(file_path);
  }

  void RemovePath(const base::FilePath& file_path) {
    base::AutoLock auto_lock(lock_);
    auto it = paths_.find(file_path);

    
    if (it != paths_.end())
      paths_.erase(it);
  }

  bool HasPath(const base::FilePath& file_path) {
    base::AutoLock auto_lock(lock_);
    return paths_.find(file_path) != paths_.end();
  }

 private:
  friend class base::NoDestructor<HistoryPathsTracker>;

  HistoryPathsTracker() = default;
  ~HistoryPathsTracker() = default;

  base::Lock lock_;
  base::flat_set<base::FilePath> paths_ GUARDED_BY(lock_);
};


void RunUnlessCanceled( base::OnceClosure closure, const base::CancelableTaskTracker::IsCanceledCallback& is_canceled) {

  if (!is_canceled.Run())
    std::move(closure).Run();
}


const int kCommitIntervalSeconds = 10;



const int kMaxRedirectCount = 32;



const int kExpireDaysThreshold = 90;



constexpr int kDomainDiversityMaxBacktrackedDays = 7;








constexpr int kDSTRoundingOffsetHours = 4;



void MergeUpdateIntoExistingModelAnnotations( const VisitContentModelAnnotations& update, VisitContentModelAnnotations& existing) {

  if (update.visibility_score != VisitContentModelAnnotations::kDefaultVisibilityScore) {
    existing.visibility_score = update.visibility_score;
  }

  if (!update.categories.empty()) {
    existing.categories = update.categories;
  }

  if (update.page_topics_model_version != VisitContentModelAnnotations::kDefaultPageTopicsModelVersion) {
    existing.page_topics_model_version = update.page_topics_model_version;
  }

  if (!update.entities.empty()) {
    existing.entities = update.entities;
  }
}

}  

std::u16string FormatUrlForRedirectComparison(const GURL& url) {
  GURL::Replacements remove_port;
  remove_port.ClearPort();
  return url_formatter::FormatUrl( url.ReplaceComponents(remove_port), url_formatter::kFormatUrlOmitHTTP | url_formatter::kFormatUrlOmitHTTPS | url_formatter::kFormatUrlOmitUsernamePassword | url_formatter::kFormatUrlOmitTrivialSubdomains, net::UnescapeRule::NONE, nullptr, nullptr, nullptr);




}

base::Time MidnightNDaysLater(base::Time time, int days) {
  return (time.LocalMidnight() + base::Days(days) + base::Hours(kDSTRoundingOffsetHours))
      .LocalMidnight();
}

QueuedHistoryDBTask::QueuedHistoryDBTask( std::unique_ptr<HistoryDBTask> task, scoped_refptr<base::SingleThreadTaskRunner> origin_loop, const base::CancelableTaskTracker::IsCanceledCallback& is_canceled)


    : task_(std::move(task)), origin_loop_(origin_loop), is_canceled_(is_canceled) {

  DCHECK(task_);
  DCHECK(origin_loop_);
  DCHECK(!is_canceled_.is_null());
}

QueuedHistoryDBTask::~QueuedHistoryDBTask() {
  
  origin_loop_->PostTask(FROM_HERE, base::BindOnce(&base::DeletePointer<HistoryDBTask>, base::Unretained(task_.release())));

}

bool QueuedHistoryDBTask::is_canceled() {
  return is_canceled_.Run();
}

bool QueuedHistoryDBTask::Run(HistoryBackend* backend, HistoryDatabase* db) {
  return task_->RunOnDBThread(backend, db);
}

void QueuedHistoryDBTask::DoneRun() {
  origin_loop_->PostTask( FROM_HERE, base::BindOnce(&RunUnlessCanceled, base::BindOnce(&HistoryDBTask::DoneRunOnMainThread, base::Unretained(task_.get())), is_canceled_));




}




class HistoryBackendHelper : public base::SupportsUserData {
 public:
  HistoryBackendHelper();
  ~HistoryBackendHelper() override;
};

HistoryBackendHelper::HistoryBackendHelper() = default;

HistoryBackendHelper::~HistoryBackendHelper() = default;




bool HistoryBackend::IsTypedIncrement(ui::PageTransition transition) {
  if (ui::PageTransitionIsNewNavigation(transition) && ((ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_TYPED) && !ui::PageTransitionIsRedirect(transition)) || ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_KEYWORD_GENERATED))) {



    return true;
  }
  return false;
}

HistoryBackend::HistoryBackend( std::unique_ptr<Delegate> delegate, std::unique_ptr<HistoryBackendClient> backend_client, scoped_refptr<base::SequencedTaskRunner> task_runner)


    : delegate_(std::move(delegate)), scheduled_kill_db_(false), expirer_(this, backend_client.get(), task_runner), recent_redirects_(kMaxRedirectCount), backend_client_(std::move(backend_client)), task_runner_(task_runner) {




  DCHECK(delegate_);
}

HistoryBackend::~HistoryBackend() {
  DCHECK(scheduled_commit_.IsCancelled()) << "Deleting without cleanup";
  queued_history_db_tasks_.clear();

  
  supports_user_data_helper_.reset();

  
  CloseAllDatabases();

  if (!backend_destroy_task_.is_null()) {
    
    DCHECK(backend_destroy_task_runner_);
    backend_destroy_task_runner_->PostTask(FROM_HERE, std::move(backend_destroy_task_));
  }


  HistoryPathsTracker::GetInstance()->RemovePath(history_dir_);

}

void HistoryBackend::Init( bool force_fail, const HistoryDatabaseParams& history_database_params) {

  TRACE_EVENT0("browser", "HistoryBackend::Init");

  DCHECK(base::PathExists(history_database_params.history_dir))
      << "History directory does not exist. If you are in a test make sure " "that ~TestingProfile() has not been called or that the " "ScopedTempDirectory used outlives this task.";


  
  
  
  supports_user_data_helper_ = std::make_unique<HistoryBackendHelper>();

  if (!force_fail)
    InitImpl(history_database_params);
  delegate_->DBLoaded();

  typed_url_sync_bridge_ = std::make_unique<TypedURLSyncBridge>( this, db_.get(), std::make_unique<ClientTagBasedModelTypeProcessor>( syncer::TYPED_URLS, base::RepeatingClosure()));


  typed_url_sync_bridge_->Init();

  memory_pressure_listener_ = std::make_unique<base::MemoryPressureListener>( FROM_HERE, base::BindRepeating(&HistoryBackend::OnMemoryPressure, base::Unretained(this)));

}

void HistoryBackend::SetOnBackendDestroyTask( scoped_refptr<base::SingleThreadTaskRunner> task_runner, base::OnceClosure task) {

  TRACE_EVENT0("browser", "HistoryBackend::SetOnBackendDestroyTask");
  if (!backend_destroy_task_.is_null())
    DLOG(WARNING) << "Setting more than one destroy task, overriding";
  backend_destroy_task_runner_ = std::move(task_runner);
  backend_destroy_task_ = std::move(task);
}

void HistoryBackend::Closing() {
  TRACE_EVENT0("browser", "HistoryBackend::Closing");
  
  
  CancelScheduledCommit();
}


void HistoryBackend::PersistState() {
  TRACE_EVENT0("browser", "HistoryBackend::PersistState");
  Commit();
}


void HistoryBackend::ClearCachedDataForContextID(ContextID context_id) {
  TRACE_EVENT0("browser", "HistoryBackend::ClearCachedDataForContextID");
  tracker_.ClearCachedDataForContextID(context_id);
}

base::FilePath HistoryBackend::GetFaviconsFileName() const {
  return history_dir_.Append(kFaviconsFilename);
}

SegmentID HistoryBackend::GetLastSegmentID(VisitID from_visit) {
  
  
  std::set<VisitID> visit_set;
  VisitID visit_id = from_visit;
  while (visit_id) {
    VisitRow row;
    if (!db_->GetRowForVisit(visit_id, &row))
      return 0;
    if (row.segment_id)
      return row.segment_id;  

    
    visit_id = row.referring_visit;

    if (visit_set.find(visit_id) != visit_set.end()) {
      NOTREACHED() << "Loop in referer chain, giving up";
      break;
    }
    visit_set.insert(visit_id);
  }
  return 0;
}

SegmentID HistoryBackend::UpdateSegments(const GURL& url, VisitID from_visit, VisitID visit_id, ui::PageTransition transition_type, const Time ts) {



  if (!db_)
    return 0;

  
  if (!ui::PageTransitionIsMainFrame(transition_type))
    return 0;

  SegmentID segment_id = 0;

  
  
  
  
  
  
  
  
  
  
  
  
  
  if ((ui::PageTransitionCoreTypeIs(transition_type, ui::PAGE_TRANSITION_TYPED) || ui::PageTransitionCoreTypeIs(transition_type, ui::PAGE_TRANSITION_AUTO_BOOKMARK)) && (transition_type & ui::PAGE_TRANSITION_FORWARD_BACK) == 0) {



    
    std::string segment_name = db_->ComputeSegmentName(url);
    URLID url_id = db_->GetRowForURL(url, nullptr);
    if (!url_id)
      return 0;

    segment_id = db_->GetSegmentNamed(segment_name);
    if (!segment_id) {
      segment_id = db_->CreateSegment(url_id, segment_name);
      if (!segment_id) {
        NOTREACHED();
        return 0;
      }
    } else {
      
      
      
      db_->UpdateSegmentRepresentationURL(segment_id, url_id);
    }
  } else {
    
    
    
    
    segment_id = GetLastSegmentID(from_visit);
    if (!segment_id)
      return 0;
  }

  
  if (!db_->SetSegmentID(visit_id, segment_id)) {
    NOTREACHED();
    return 0;
  }

  
  if (!db_->IncreaseSegmentVisitCount(segment_id, ts, 1)) {
    NOTREACHED();
    return 0;
  }
  return segment_id;
}

void HistoryBackend::UpdateWithPageEndTime(ContextID context_id, int nav_entry_id, const GURL& url, Time end_ts) {


  TRACE_EVENT0("browser", "HistoryBackend::UpdateWithPageEndTime");
  
  VisitID visit_id = tracker_.GetLastVisit(context_id, nav_entry_id, url);
  UpdateVisitDuration(visit_id, end_ts);
}

void HistoryBackend::SetBrowsingTopicsAllowed(ContextID context_id, int nav_entry_id, const GURL& url) {

  TRACE_EVENT0("browser", "HistoryBackend::SetBrowsingTopicsAllowed");

  if (!db_)
    return;

  VisitID visit_id = tracker_.GetLastVisit(context_id, nav_entry_id, url);
  if (!visit_id)
    return;

  
  
  VisitContentAnnotations annotations;
  if (db_->GetContentAnnotationsForVisit(visit_id, &annotations)) {
    annotations.annotation_flags |= VisitContentAnnotationFlag::kBrowsingTopicsEligible;
    db_->UpdateContentAnnotationsForVisit(visit_id, annotations);
  } else {
    annotations.annotation_flags |= VisitContentAnnotationFlag::kBrowsingTopicsEligible;
    db_->AddContentAnnotationsForVisit(visit_id, annotations);
  }
  ScheduleCommit();
}

void HistoryBackend::AddContentModelAnnotationsForVisit( VisitID visit_id, const VisitContentModelAnnotations& model_annotations) {

  TRACE_EVENT0("browser", "HistoryBackend::AddContentModelAnnotationsForVisit");

  if (!db_)
    return;

  
  
  VisitRow visit_row;
  if (db_->GetRowForVisit(visit_id, &visit_row)) {
    VisitContentAnnotations annotations;
    if (db_->GetContentAnnotationsForVisit(visit_id, &annotations)) {
      MergeUpdateIntoExistingModelAnnotations(model_annotations, annotations.model_annotations);
      db_->UpdateContentAnnotationsForVisit(visit_id, annotations);
    } else {
      annotations.model_annotations = model_annotations;
      db_->AddContentAnnotationsForVisit(visit_id, annotations);
    }
    URLRow url_row;
    if (db_->GetURLRow(visit_row.url_id, &url_row)) {
      delegate_->NotifyContentModelAnnotationModified(url_row, model_annotations);
    }
    ScheduleCommit();
  }
}

void HistoryBackend::AddRelatedSearchesForVisit( VisitID visit_id, const std::vector<std::string>& related_searches) {

  TRACE_EVENT0("browser", "HistoryBackend::AddRelatedSearchesForVisit");

  if (!db_)
    return;

  
  
  VisitRow visit_row;
  if (db_->GetRowForVisit(visit_id, &visit_row)) {
    VisitContentAnnotations annotations;
    if (db_->GetContentAnnotationsForVisit(visit_id, &annotations)) {
      annotations.related_searches = related_searches;
      db_->UpdateContentAnnotationsForVisit(visit_id, annotations);
    } else {
      annotations.related_searches = related_searches;
      db_->AddContentAnnotationsForVisit(visit_id, annotations);
    }
    ScheduleCommit();
  }
}

void HistoryBackend::AddSearchMetadataForVisit( VisitID visit_id, const GURL& search_normalized_url, const std::u16string& search_terms) {


  TRACE_EVENT0("browser", "HistoryBackend::AddSearchMetadataForVisit");

  if (!db_)
    return;

  
  
  VisitRow visit_row;
  if (db_->GetRowForVisit(visit_id, &visit_row)) {
    VisitContentAnnotations annotations;
    if (db_->GetContentAnnotationsForVisit(visit_id, &annotations)) {
      annotations.search_normalized_url = search_normalized_url;
      annotations.search_terms = search_terms;
      db_->UpdateContentAnnotationsForVisit(visit_id, annotations);
    } else {
      annotations.search_normalized_url = search_normalized_url;
      annotations.search_terms = search_terms;
      db_->AddContentAnnotationsForVisit(visit_id, annotations);
    }
    ScheduleCommit();
  }
}

void HistoryBackend::UpdateVisitDuration(VisitID visit_id, const Time end_ts) {
  if (!db_)
    return;

  
  VisitRow visit_row;
  if (db_->GetRowForVisit(visit_id, &visit_row)) {
    
    visit_row.visit_duration = end_ts > visit_row.visit_time ? end_ts - visit_row.visit_time : base::Microseconds(0);

    db_->UpdateVisitRow(visit_row);
  }
}

bool HistoryBackend::IsUntypedIntranetHost(const GURL& url) {
  if (!url.SchemeIs(url::kHttpScheme) && !url.SchemeIs(url::kHttpsScheme) && !url.SchemeIs(url::kFtpScheme))
    return false;

  const std::string host = url.host();
  const size_t registry_length = net::registry_controlled_domains::GetCanonicalHostRegistryLength( host, net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES, net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);


  return (registry_length == 0) && !db_->IsTypedHost(host, nullptr);
}

OriginCountAndLastVisitMap HistoryBackend::GetCountsAndLastVisitForOrigins( const std::set<GURL>& origins) const {
  if (!db_)
    return OriginCountAndLastVisitMap();
  if (origins.empty())
    return OriginCountAndLastVisitMap();

  URLDatabase::URLEnumerator it;
  if (!db_->InitURLEnumeratorForEverything(&it))
    return OriginCountAndLastVisitMap();

  OriginCountAndLastVisitMap origin_count_map;
  for (const GURL& origin : origins)
    origin_count_map[origin] = std::make_pair(0, base::Time());

  URLRow row;
  while (it.GetNextURL(&row)) {
    GURL origin = row.url().DeprecatedGetOriginAsURL();
    auto iter = origin_count_map.find(origin);
    if (iter != origin_count_map.end()) {
      std::pair<int, base::Time>& value = iter->second;
      ++(value.first);
      if (value.second.is_null() || value.second < row.last_visit())
        value.second = row.last_visit();
    }
  }

  return origin_count_map;
}

void HistoryBackend::AddPage(const HistoryAddPageArgs& request) {
  TRACE_EVENT0("browser", "HistoryBackend::AddPage");

  if (!db_)
    return;

  
  std::pair<URLID, VisitID> last_ids( 0, tracker_.GetLastVisit(request.context_id, request.nav_entry_id, request.referrer));


  VisitID from_visit_id = last_ids.second;

  
  
  DCHECK(request.redirects.empty() || request.redirects.back() == request.url);

  
  
  if (request.time < first_recorded_time_)
    first_recorded_time_ = request.time;

  ui::PageTransition request_transition = request.transition;
  bool is_keyword_generated = ui::PageTransitionCoreTypeIs( request_transition, ui::PAGE_TRANSITION_KEYWORD_GENERATED);

  
  
  
  bool has_redirects = request.redirects.size() > 1;
  if (ui::PageTransitionIsMainFrame(request_transition) && !ui::PageTransitionCoreTypeIs(request_transition, ui::PAGE_TRANSITION_TYPED) && !is_keyword_generated) {


    
    
    if (IsUntypedIntranetHost(request.url) || (has_redirects && IsUntypedIntranetHost(request.redirects[0]))) {
      request_transition = ui::PageTransitionFromInt( ui::PAGE_TRANSITION_TYPED | ui::PageTransitionGetQualifier(request_transition));

    }
  }

  VisitID opener_visit = 0;
  if (request.opener) {
    opener_visit = tracker_.GetLastVisit(request.opener->context_id, request.opener->nav_entry_id, request.opener->url);

  }

  if (!has_redirects) {
    
    ui::PageTransition t = ui::PageTransitionFromInt( request_transition | ui::PAGE_TRANSITION_CHAIN_START | ui::PAGE_TRANSITION_CHAIN_END);


    
    last_ids = AddPageVisit(request.url, request.time, last_ids.second, t, request.hidden, request.visit_source, IsTypedIncrement(t), opener_visit, request.title);


    
    
    
    if (!is_keyword_generated && request.consider_for_ntp_most_visited) {
      UpdateSegments(request.url, from_visit_id, last_ids.second, t, request.time);

      
      UpdateVisitDuration(from_visit_id, request.time);
    }
  } else {
    

    ui::PageTransition redirect_info = ui::PAGE_TRANSITION_CHAIN_START;

    RedirectList redirects = request.redirects;
    
    
    
    
    
    
    
    RedirectList extended_redirect_chain;

    if (redirects[0].SchemeIs(url::kAboutScheme)) {
      
      
      
      
      
      
      
      
      
      redirects.erase(redirects.begin());
    } else if (request_transition & ui::PAGE_TRANSITION_CLIENT_REDIRECT) {
      redirect_info = ui::PAGE_TRANSITION_CLIENT_REDIRECT;
      
      
      
      
      
      
      
      
      
      if (request.referrer.is_valid()) {
        DCHECK_EQ(request.referrer, redirects[0]);
        redirects.erase(redirects.begin());

        
        
        
        
        VisitRow visit_row;
        if (request.did_replace_entry) {
          if (db_->GetRowForVisit(last_ids.second, &visit_row) && visit_row.transition & ui::PAGE_TRANSITION_CHAIN_END) {
            visit_row.transition = ui::PageTransitionFromInt( visit_row.transition & ~ui::PAGE_TRANSITION_CHAIN_END);
            db_->UpdateVisitRow(visit_row);
          }

          extended_redirect_chain = GetCachedRecentRedirects(request.referrer);
        }
      }
    }

    bool transfer_typed_credit_from_first_to_second_url = false;
    if (redirects.size() > 1) {
      
      
      
      
      if (IsTypedIncrement(request_transition) && redirects[0].SchemeIs(url::kHttpScheme) && redirects[1].SchemeIs(url::kHttpsScheme) && FormatUrlForRedirectComparison(redirects[0]) == FormatUrlForRedirectComparison(redirects[1])) {



        transfer_typed_credit_from_first_to_second_url = true;
      } else if (ui::PageTransitionCoreTypeIs( request_transition, ui::PAGE_TRANSITION_FORM_SUBMIT)) {
        
        
        
        
        
        redirects.erase(redirects.begin());
      }
    }

    for (size_t redirect_index = 0; redirect_index < redirects.size();
         redirect_index++) {
      ui::PageTransition t = ui::PageTransitionFromInt( ui::PageTransitionStripQualifier(request_transition) | redirect_info);

      
      if (redirect_index == (redirects.size() - 1)) {
        t = ui::PageTransitionFromInt(t | ui::PAGE_TRANSITION_CHAIN_END);
      }

      bool should_increment_typed_count = IsTypedIncrement(t);
      if (transfer_typed_credit_from_first_to_second_url) {
        if (redirect_index == 0)
          should_increment_typed_count = false;
        else if (redirect_index == 1)
          should_increment_typed_count = true;
      }

      
      
      
      
      last_ids = AddPageVisit( redirects[redirect_index], request.time, last_ids.second, t, request.hidden, request.visit_source, should_increment_typed_count, redirect_index == 0 ? opener_visit : 0, request.title);



      if (t & ui::PAGE_TRANSITION_CHAIN_START) {
        if (request.consider_for_ntp_most_visited) {
          UpdateSegments(redirects[redirect_index], from_visit_id, last_ids.second, t, request.time);
        }

        
        UpdateVisitDuration(from_visit_id, request.time);
      }

      
      
      redirect_info = ui::PAGE_TRANSITION_SERVER_REDIRECT;
    }

    
    
    
    extended_redirect_chain.insert(extended_redirect_chain.end(), std::make_move_iterator(redirects.begin()), std::make_move_iterator(redirects.end()));

    recent_redirects_.Put(request.url, extended_redirect_chain);
  }

  
  

  
  
  
  
  if (!ui::PageTransitionCoreTypeIs(request_transition, ui::PAGE_TRANSITION_AUTO_SUBFRAME) && !ui::PageTransitionCoreTypeIs(request_transition, ui::PAGE_TRANSITION_MANUAL_SUBFRAME) && !is_keyword_generated) {



    tracker_.AddVisit(request.context_id, request.nav_entry_id, request.url, last_ids.second);
  }

  ScheduleCommit();
}

void HistoryBackend::InitImpl( const HistoryDatabaseParams& history_database_params) {
  DCHECK(!db_) << "Initializing HistoryBackend twice";
  
  
  
  

  TimeTicks beginning_time = TimeTicks::Now();

  
  history_dir_ = history_database_params.history_dir;


  DCHECK(!HistoryPathsTracker::GetInstance()->HasPath(history_dir_))
      << "There already is a HistoryBackend running using the file at: " << history_database_params.history_dir << ". Tests have to make sure that HistoryBackend destruction is " "complete using SetOnBackendDestroyTask() or other flush mechanisms " "before creating a new HistoryBackend that uses the same directory.";




  HistoryPathsTracker::GetInstance()->AddPath(history_dir_);


  base::FilePath history_name = history_dir_.Append(kHistoryFilename);
  base::FilePath favicon_name = GetFaviconsFileName();

  
  DeleteFTSIndexDatabases();

  
  db_ = std::make_unique<HistoryDatabase>( history_database_params.download_interrupt_reason_none, history_database_params.download_interrupt_reason_crash);


  
  db_->set_error_callback(base::BindRepeating( &HistoryBackend::DatabaseErrorCallback, base::Unretained(this)));

  db_diagnostics_.clear();
  sql::InitStatus status = db_->Init(history_name);
  switch (status) {
    case sql::INIT_OK:
      break;
    case sql::INIT_FAILURE: {
      
      
      
      
      bool kill_db = scheduled_kill_db_;
      if (kill_db)
        KillHistoryDatabase();

      
      
      UMA_HISTOGRAM_BOOLEAN("History.AttemptedToFixProfileError", kill_db);
      [[fallthrough]];
    }
    case sql::INIT_TOO_NEW: {
      db_diagnostics_ += sql::GetCorruptFileDiagnosticsInfo(history_name);
      delegate_->NotifyProfileError(status, db_diagnostics_);
      db_.reset();
      return;
    }
    default:
      NOTREACHED();
  }

  
  
  {
    std::unique_ptr<InMemoryHistoryBackend> mem_backend( new InMemoryHistoryBackend);
    if (mem_backend->Init(history_name))
      delegate_->SetInMemoryBackend(std::move(mem_backend));
  }
  db_->BeginExclusiveMode();  

  
  favicon_backend_ = favicon::FaviconBackend::Create(favicon_name, this);
  
  
  
  

  
  
  if (base::RandInt(1, 100) == 50) {
    
    db_->ComputeDatabaseMetrics(history_name);
  }

  favicon::FaviconDatabase* favicon_db_ptr = favicon_backend_ ? favicon_backend_->db() : nullptr;

  expirer_.SetDatabases(db_.get(), favicon_db_ptr);

  
  db_->BeginTransaction();

  
  db_->GetStartDate(&first_recorded_time_);

  
  expirer_.StartExpiringOldStuff(base::Days(kExpireDaysThreshold));

  LOCAL_HISTOGRAM_TIMES("History.InitTime", TimeTicks::Now() - beginning_time);
}

void HistoryBackend::OnMemoryPressure( base::MemoryPressureListener::MemoryPressureLevel memory_pressure_level) {
  
  
  if (memory_pressure_level == base::MemoryPressureListener::MEMORY_PRESSURE_LEVEL_NONE) {
    return;
  }
  if (db_)
    db_->TrimMemory();
  if (favicon_backend_)
    favicon_backend_->TrimMemory();
}

void HistoryBackend::CloseAllDatabases() {
  if (db_) {
    
    db_->CommitTransaction();
    db_.reset();
    
    first_recorded_time_ = base::Time();
  }
  favicon_backend_.reset();
}

std::pair<URLID, VisitID> HistoryBackend::AddPageVisit( const GURL& url, Time time, VisitID referring_visit, ui::PageTransition transition, bool hidden, VisitSource visit_source, bool should_increment_typed_count, VisitID opener_visit, absl::optional<std::u16string> title) {








  
  URLRow url_info(url);
  URLID url_id = db_->GetRowForURL(url, &url_info);
  if (url_id) {
    
    if (!ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_RELOAD))
      url_info.set_visit_count(url_info.visit_count() + 1);
    if (should_increment_typed_count)
      url_info.set_typed_count(url_info.typed_count() + 1);
    if (url_info.last_visit() < time)
      url_info.set_last_visit(time);
    if (title)
      url_info.set_title(title.value());

    
    if (!hidden)
      url_info.set_hidden(false);

    db_->UpdateURLRow(url_id, url_info);
  } else {
    
    url_info.set_visit_count(1);
    url_info.set_typed_count(should_increment_typed_count ? 1 : 0);
    url_info.set_last_visit(time);
    if (title)
      url_info.set_title(title.value());
    url_info.set_hidden(hidden);

    url_id = db_->AddURL(url_info);
    if (!url_id) {
      NOTREACHED() << "Adding URL failed.";
      return std::make_pair(0, 0);
    }
    url_info.set_id(url_id);
  }

  
  VisitRow visit_info(url_id, time, referring_visit, transition, 0, should_increment_typed_count, opener_visit);
  VisitID visit_id = db_->AddVisit(&visit_info, visit_source);

  if (visit_info.visit_time < first_recorded_time_)
    first_recorded_time_ = visit_info.visit_time;

  
  if (visit_id) {
    RedirectList redirects;
    
    
    
    NotifyURLVisited(transition, url_info, redirects, time);
  } else {
    DVLOG(0) << "Failed to build visit insert statement:  " << "url_id = " << url_id;
  }

  return std::make_pair(url_id, visit_id);
}

void HistoryBackend::AddPagesWithDetails(const URLRows& urls, VisitSource visit_source) {
  TRACE_EVENT0("browser", "HistoryBackend::AddPagesWithDetails");

  if (!db_)
    return;

  URLRows changed_urls;
  for (auto i = urls.begin(); i != urls.end(); ++i) {
    DCHECK(!i->last_visit().is_null());

    
    if (IsExpiredVisitTime(i->last_visit()))
      continue;

    URLRow existing_url;
    URLID url_id = db_->GetRowForURL(i->url(), &existing_url);
    if (!url_id) {
      
      url_id = db_->AddURL(*i);
      if (!url_id) {
        NOTREACHED() << "Could not add row to DB";
        return;
      }

      changed_urls.push_back(*i);
      changed_urls.back().set_id(url_id);  
    }

    
    if (visit_source != SOURCE_SYNCED) {
      
      VisitRow visit_info( url_id, i->last_visit(), 0, ui::PageTransitionFromInt(ui::PAGE_TRANSITION_LINK | ui::PAGE_TRANSITION_CHAIN_START | ui::PAGE_TRANSITION_CHAIN_END), 0, false, 0);





      if (!db_->AddVisit(&visit_info, visit_source)) {
        NOTREACHED() << "Adding visit failed.";
        return;
      }

      if (visit_info.visit_time < first_recorded_time_)
        first_recorded_time_ = visit_info.visit_time;
    }
  }

  
  
  
  
  
  NotifyURLsModified(changed_urls, false);
  ScheduleCommit();
}

void HistoryBackend::SetTypedURLSyncBridgeForTest( std::unique_ptr<TypedURLSyncBridge> bridge) {
  typed_url_sync_bridge_ = std::move(bridge);
}

bool HistoryBackend::IsExpiredVisitTime(const base::Time& time) {
  return time < expirer_.GetCurrentExpirationTime();
}

void HistoryBackend::SetPageTitle(const GURL& url, const std::u16string& title) {
  TRACE_EVENT0("browser", "HistoryBackend::SetPageTitle");

  if (!db_)
    return;

  
  
  
  RedirectList dummy_list;
  RedirectList* redirects;
  auto iter = recent_redirects_.Get(url);
  if (iter != recent_redirects_.end()) {
    redirects = &iter->second;

    
    DCHECK(!redirects->empty());
    DCHECK_EQ(redirects->back(), url);
  } else {
    
    
    dummy_list.push_back(url);
    redirects = &dummy_list;
  }

  URLRows changed_urls;
  for (const auto& redirect : *redirects) {
    URLRow row;
    URLID row_id = db_->GetRowForURL(redirect, &row);
    if (row_id && row.title() != title) {
      row.set_title(title);
      db_->UpdateURLRow(row_id, row);
      changed_urls.push_back(row);
    }
  }

  
  
  if (!changed_urls.empty()) {
    NotifyURLsModified(changed_urls, false);
    ScheduleCommit();
  }
}

void HistoryBackend::AddPageNoVisitForBookmark(const GURL& url, const std::u16string& title) {
  TRACE_EVENT0("browser", "HistoryBackend::AddPageNoVisitForBookmark");

  if (!db_)
    return;

  URLRow url_info(url);
  URLID url_id = db_->GetRowForURL(url, &url_info);
  if (url_id) {
    
    return;
  }

  if (!title.empty()) {
    url_info.set_title(title);
  } else {
    url_info.set_title(base::UTF8ToUTF16(url.spec()));
  }

  url_info.set_last_visit(Time::Now());
  
  url_info.set_hidden(true);

  db_->AddURL(url_info);
}

bool HistoryBackend::GetAllTypedURLs(URLRows* urls) {
  DCHECK(urls);
  if (!db_)
    return false;
  std::vector<URLID> url_ids;
  if (!db_->GetAllURLIDsForTransition(ui::PAGE_TRANSITION_TYPED, &url_ids))
    return false;
  urls->reserve(url_ids.size());
  for (const auto& url_id : url_ids) {
    URLRow url;
    if (!db_->GetURLRow(url_id, &url))
      return false;
    urls->push_back(url);
  }
  return true;
}

bool HistoryBackend::GetVisitsForURL(URLID id, VisitVector* visits) {
  if (db_)
    return db_->GetVisitsForURL(id, visits);
  return false;
}

bool HistoryBackend::GetMostRecentVisitsForURL(URLID id, int max_visits, VisitVector* visits) {

  if (db_)
    return db_->GetMostRecentVisitsForURL(id, max_visits, visits);
  return false;
}

size_t HistoryBackend::UpdateURLs(const URLRows& urls) {
  if (!db_)
    return 0;

  URLRows changed_urls;
  for (auto it = urls.begin(); it != urls.end(); ++it) {
    DCHECK(it->id());
    if (db_->UpdateURLRow(it->id(), *it))
      changed_urls.push_back(*it);
  }

  
  
  size_t num_updated_records = changed_urls.size();
  if (num_updated_records) {
    NotifyURLsModified(changed_urls, false);
    ScheduleCommit();
  }
  return num_updated_records;
}

bool HistoryBackend::AddVisits(const GURL& url, const std::vector<VisitInfo>& visits, VisitSource visit_source) {

  if (db_) {
    for (const auto& visit : visits) {
      if (!AddPageVisit(url, visit.first, 0, visit.second, !ui::PageTransitionIsMainFrame(visit.second), visit_source, IsTypedIncrement(visit.second), 0)


               .first) {
        return false;
      }
    }
    ScheduleCommit();
    return true;
  }
  return false;
}

bool HistoryBackend::RemoveVisits(const VisitVector& visits) {
  if (!db_)
    return false;

  expirer_.ExpireVisits(visits);
  ScheduleCommit();
  return true;
}

bool HistoryBackend::GetVisitsSource(const VisitVector& visits, VisitSourceMap* sources) {
  if (!db_)
    return false;

  db_->GetVisitsSource(visits, sources);
  return true;
}

bool HistoryBackend::GetVisitSource(const VisitID visit_id, VisitSource* source) {
  if (!db_)
    return false;

  *source = db_->GetVisitSource(visit_id);
  return true;
}

bool HistoryBackend::GetURL(const GURL& url, URLRow* url_row) {
  if (db_)
    return db_->GetRowForURL(url, url_row) != 0;
  return false;
}

bool HistoryBackend::GetURLByID(URLID url_id, URLRow* url_row) {
  if (db_)
    return db_->GetURLRow(url_id, url_row);
  return false;
}

QueryURLResult HistoryBackend::QueryURL(const GURL& url, bool want_visits) {
  QueryURLResult result;
  result.success = db_ && db_->GetRowForURL(url, &result.row);
  
  if (result.success && want_visits)
    db_->GetVisitsForURL(result.row.id(), &result.visits);
  return result;
}

base::WeakPtr<syncer::ModelTypeControllerDelegate> HistoryBackend::GetTypedURLSyncControllerDelegate() {
  DCHECK(typed_url_sync_bridge_);
  return typed_url_sync_bridge_->change_processor()->GetControllerDelegate();
}



HistoryCountResult HistoryBackend::GetHistoryCount(const Time& begin_time, const Time& end_time) {
  int count = 0;
  return {db_ && db_->GetHistoryCount(begin_time, end_time, &count), count};
}

HistoryCountResult HistoryBackend::CountUniqueHostsVisitedLastMonth() {
  return {!!db_, db_ ? db_->CountUniqueHostsVisitedLastMonth() : 0};
}

DomainDiversityResults HistoryBackend::GetDomainDiversity( base::Time report_time, int number_of_days_to_report, DomainMetricBitmaskType metric_type_bitmask) {


  DCHECK_GE(number_of_days_to_report, 0);
  DomainDiversityResults result;

  if (!db_)
    return result;

  number_of_days_to_report = std::min(number_of_days_to_report, kDomainDiversityMaxBacktrackedDays);

  base::Time current_midnight = report_time.LocalMidnight();
  SCOPED_UMA_HISTOGRAM_TIMER("History.DomainCountQueryTime_V2");

  for (int days_back = 0; days_back < number_of_days_to_report; ++days_back) {
    DomainMetricSet single_metric_set;
    single_metric_set.end_time = current_midnight;

    if (metric_type_bitmask & kEnableLast1DayMetric) {
      base::Time last_midnight = MidnightNDaysLater(current_midnight, -1);
      single_metric_set.one_day_metric = DomainMetricCountType( db_->CountUniqueDomainsVisited(last_midnight, current_midnight), last_midnight);

    }

    if (metric_type_bitmask & kEnableLast7DayMetric) {
      base::Time seven_midnights_ago = MidnightNDaysLater(current_midnight, -7);
      single_metric_set.seven_day_metric = DomainMetricCountType( db_->CountUniqueDomainsVisited(seven_midnights_ago, current_midnight), seven_midnights_ago);

    }

    if (metric_type_bitmask & kEnableLast28DayMetric) {
      base::Time twenty_eight_midnights_ago = MidnightNDaysLater(current_midnight, -28);
      single_metric_set.twenty_eight_day_metric = DomainMetricCountType( db_->CountUniqueDomainsVisited(twenty_eight_midnights_ago, current_midnight), twenty_eight_midnights_ago);


    }
    result.push_back(single_metric_set);

    current_midnight = MidnightNDaysLater(current_midnight, -1);
  }

  return result;
}

HistoryLastVisitResult HistoryBackend::GetLastVisitToHost( const std::string& host, base::Time begin_time, base::Time end_time) {


  base::Time last_visit;
  return {
      db_ && db_->GetLastVisitToHost(host, begin_time, end_time, &last_visit), last_visit};
}

HistoryLastVisitResult HistoryBackend::GetLastVisitToOrigin( const url::Origin& origin, base::Time begin_time, base::Time end_time) {


  base::Time last_visit;
  return {db_ && db_->GetLastVisitToOrigin(origin, begin_time, end_time, &last_visit), last_visit};

}

HistoryLastVisitResult HistoryBackend::GetLastVisitToURL(const GURL& url, base::Time end_time) {
  base::Time last_visit;
  return {
      db_ && db_->GetLastVisitToURL(url, end_time, &last_visit), last_visit, };

}

DailyVisitsResult HistoryBackend::GetDailyVisitsToHost(const GURL& host, base::Time begin_time, base::Time end_time) {

  return db_->GetDailyVisitsToHost(host, begin_time, end_time);
}



void HistoryBackend::SetKeywordSearchTermsForURL(const GURL& url, KeywordID keyword_id, const std::u16string& term) {

  TRACE_EVENT0("browser", "HistoryBackend::SetKeywordSearchTermsForURL");

  if (!db_)
    return;

  
  URLRow row;
  if (!db_->GetRowForURL(url, &row)) {
    
    
    return;
  }

  db_->SetKeywordSearchTermsForURL(row.id(), keyword_id, term);
  delegate_->NotifyKeywordSearchTermUpdated(row, keyword_id, term);

  ScheduleCommit();
}

void HistoryBackend::DeleteAllSearchTermsForKeyword(KeywordID keyword_id) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteAllSearchTermsForKeyword");

  if (!db_)
    return;

  db_->DeleteAllSearchTermsForKeyword(keyword_id);
  ScheduleCommit();
}

void HistoryBackend::DeleteKeywordSearchTermForURL(const GURL& url) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteKeywordSearchTermForURL");

  if (!db_)
    return;

  URLID url_id = db_->GetRowForURL(url, nullptr);
  if (!url_id)
    return;
  db_->DeleteKeywordSearchTermForURL(url_id);
  delegate_->NotifyKeywordSearchTermDeleted(url_id);

  ScheduleCommit();
}

void HistoryBackend::DeleteMatchingURLsForKeyword(KeywordID keyword_id, const std::u16string& term) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteMatchingURLsForKeyword");

  if (!db_)
    return;

  std::vector<KeywordSearchTermRow> rows;
  if (db_->GetKeywordSearchTermRows(term, &rows)) {
    std::vector<GURL> items_to_delete;
    URLRow url_row;
    for (const auto& row : rows) {
      if (row.keyword_id == keyword_id && db_->GetURLRow(row.url_id, &url_row))
        items_to_delete.push_back(url_row.url());
    }
    DeleteURLs(items_to_delete);
  }
}



void HistoryBackend::AddContextAnnotationsForVisit( VisitID visit_id, const VisitContextAnnotations& visit_context_annotations) {

  TRACE_EVENT0("browser", "HistoryBackend::AddContextAnnotationsForVisit");
  DCHECK(visit_id);
  VisitRow visit_row;
  if (!db_ || !db_->GetRowForVisit(visit_id, &visit_row))
    return;
  db_->AddContextAnnotationsForVisit(visit_id, visit_context_annotations);
  ScheduleCommit();
}

std::vector<AnnotatedVisit> HistoryBackend::GetAnnotatedVisits( const QueryOptions& options, bool* limited_by_max_count) {

  
  
  

  TRACE_EVENT0("browser", "HistoryBackend::GetAnnotatedVisits");
  if (!db_)
    return {};

  
  
  
  
  VisitVector visit_rows;

  
  bool limited = db_->GetVisibleVisitsInRange(options, &visit_rows);
  if (limited_by_max_count) {
    *limited_by_max_count = limited;
  }

  DCHECK_LE(static_cast<int>(visit_rows.size()), options.EffectiveMaxCount());

  VisitSourceMap sources;
  GetVisitsSource(visit_rows, &sources);

  std::vector<AnnotatedVisit> annotated_visits;
  for (const auto& visit_row : visit_rows) {
    
    URLRow url_row;
    if (!db_->GetURLRow(visit_row.url_id, &url_row)) {
      DVLOG(0) << "Failed to get id " << visit_row.url_id << " from history.urls.";
      continue;  
    }

    
    
    
    
    
    VisitContextAnnotations context_annotations;
    db_->GetContextAnnotationsForVisit(visit_row.visit_id, &context_annotations);
    VisitContentAnnotations content_annotations;
    db_->GetContentAnnotationsForVisit(visit_row.visit_id, &content_annotations);

    VisitRow redirect_start = GetRedirectChainStart(visit_row);
    VisitID referring_visit_of_redirect_chain_start = redirect_start.referring_visit;
    VisitID opener_visit_of_redirect_chain_start = redirect_start.opener_visit;

    const auto source = sources.count(visit_row.visit_id) == 0 ? VisitSource::SOURCE_BROWSED : sources[visit_row.visit_id];


    annotated_visits.emplace_back(url_row, visit_row, context_annotations, content_annotations, referring_visit_of_redirect_chain_start, opener_visit_of_redirect_chain_start, source);


  }

  return annotated_visits;
}

ClusterIdsAndAnnotatedVisitsResult HistoryBackend::GetRecentClusterIdsAndAnnotatedVisits(base::Time minimum_time, int max_results) {

  TRACE_EVENT0("browser", "HistoryBackend::GetRecentClusterIdsAndAnnotatedVisits");
  if (!db_)
    return {};

  
  std::set<VisitID> recent_visit_ids;
  const auto add_visit_ids = [&](std::vector<VisitID> visit_ids) {
    for (const auto visit_id : visit_ids) {
      if (recent_visit_ids.size() >= static_cast<size_t>(max_results))
        break;
      recent_visit_ids.insert(visit_id);
    }
  };

  
  add_visit_ids(db_->GetRecentAnnotatedVisitIds(minimum_time, max_results));

  
  std::vector<int64_t> recent_cluster_ids = db_->GetRecentClusterIds(minimum_time);
  for (const auto cluster_id : recent_cluster_ids) {
    if (recent_visit_ids.size() >= static_cast<size_t>(max_results))
      break;
    
    
    
    add_visit_ids(db_->GetVisitIdsInCluster(cluster_id, max_results));
  }

  
  std::vector<AnnotatedVisitRow> recent_annotated_visit_rows;
  base::ranges::transform( recent_visit_ids, std::back_inserter(recent_annotated_visit_rows), [&](const VisitID& visit_id) {

        AnnotatedVisitRow row;
        row.visit_id = visit_id;
        
        
        db_->GetContentAnnotationsForVisit(visit_id, &row.content_annotations);
        db_->GetContextAnnotationsForVisit(visit_id, &row.context_annotations);
        return row;
      });

  return {recent_cluster_ids, AnnotatedVisitsFromRows(recent_annotated_visit_rows)};
}

std::vector<Cluster> HistoryBackend::GetClusters(int max_results) {
  TRACE_EVENT0("browser", "HistoryBackend::GetClusters");
  if (!db_)
    return {};

  std::vector<ClusterRow> cluster_rows = db_->GetClusters(max_results);
  std::vector<AnnotatedVisitRow> annotated_visit_rows = db_->GetClusteredAnnotatedVisits(max_results);
  std::vector<AnnotatedVisit> annotated_visits = AnnotatedVisitsFromRows(annotated_visit_rows);

  std::vector<Cluster> clusters;

  for (const auto& cluster_row : cluster_rows) {
    std::vector<ClusterVisit> current_cluster_visits;
    for (VisitID annotated_visit_id : cluster_row.visit_ids) {
      const auto annotated_visits_it = base::ranges::find(annotated_visits, annotated_visit_id, [](const auto& annotated_visit) {

                               return annotated_visit.visit_row.visit_id;
                             });
      
      if (annotated_visits_it != annotated_visits.end()) {
        ClusterVisit cluster_visit;
        cluster_visit.annotated_visit = *annotated_visits_it;
        current_cluster_visits.push_back(cluster_visit);
      }
    }
    if (!current_cluster_visits.empty()) {
      clusters.push_back({cluster_row.cluster_id, current_cluster_visits, {}});
    }
  }
  return clusters;
}

std::vector<AnnotatedVisit> HistoryBackend::AnnotatedVisitsFromRows( const std::vector<AnnotatedVisitRow>& rows) {
  std::vector<AnnotatedVisit> annotated_visits;
  for (const auto& annotated_visit_row : rows) {
    URLRow url_row;
    VisitRow visit_row;
    if (db_->GetRowForVisit(annotated_visit_row.visit_id, &visit_row) && db_->GetURLRow(visit_row.url_id, &url_row)) {
      VisitSource source;
      GetVisitSource(annotated_visit_row.visit_id, &source);
      VisitRow redirect_start = GetRedirectChainStart(visit_row);
      annotated_visits.push_back({url_row, visit_row, annotated_visit_row.context_annotations, {}, redirect_start.referring_visit, redirect_start.opener_visit, source});





    } else {
      
      DVLOG(0) << "HistoryBackend: AnnotatedVisit found with missing associated" "URL or visit. visit_id = " << annotated_visit_row.visit_id;

    }
  }
  return annotated_visits;
}

VisitRow HistoryBackend::GetRedirectChainStart(VisitRow visit) {
  
  if (db_) {
    base::flat_set<VisitID> visit_set;
    while (!(visit.transition & ui::PAGE_TRANSITION_CHAIN_START)) {
      visit_set.insert(visit.visit_id);
      
      if (!db_->GetRowForVisit(visit.referring_visit, &visit))
        return {};
      if (visit_set.count(visit.visit_id)) {
        NOTREACHED() << "Loop in visit redirect chain, giving up";
        break;
      }
    }
  }
  return visit;
}



void HistoryBackend::AddObserver(HistoryBackendObserver* observer) {
  observers_.AddObserver(observer);
}

void HistoryBackend::RemoveObserver(HistoryBackendObserver* observer) {
  observers_.RemoveObserver(observer);
}



uint32_t HistoryBackend::GetNextDownloadId() {
  return db_ ? db_->GetNextDownloadId() : kInvalidDownloadId;
}


std::vector<DownloadRow> HistoryBackend::QueryDownloads() {
  std::vector<DownloadRow> rows;
  if (db_)
    db_->QueryDownloads(&rows);
  return rows;
}


void HistoryBackend::UpdateDownload(const DownloadRow& data, bool should_commit_immediately) {
  TRACE_EVENT0("browser", "HistoryBackend::UpdateDownload");
  if (!db_)
    return;
  db_->UpdateDownload(data);
  if (should_commit_immediately)
    Commit();
  else ScheduleCommit();
}

bool HistoryBackend::CreateDownload(const DownloadRow& history_info) {
  TRACE_EVENT0("browser", "HistoryBackend::CreateDownload");
  if (!db_)
    return false;
  bool success = db_->CreateDownload(history_info);

  
  
  
  
  Commit();

  ScheduleCommit();

  return success;
}

void HistoryBackend::RemoveDownloads(const std::set<uint32_t>& ids) {
  TRACE_EVENT0("browser", "HistoryBackend::RemoveDownloads");
  if (!db_)
    return;
  size_t downloads_count_before = db_->CountDownloads();
  
  
  for (uint32_t id : ids)
    db_->RemoveDownload(id);
  ScheduleCommit();
  size_t downloads_count_after = db_->CountDownloads();

  DCHECK_LE(downloads_count_after, downloads_count_before);
  if (downloads_count_after > downloads_count_before)
    return;
  size_t num_downloads_deleted = downloads_count_before - downloads_count_after;
  DCHECK_GE(ids.size(), num_downloads_deleted);
}

QueryResults HistoryBackend::QueryHistory(const std::u16string& text_query, const QueryOptions& options) {
  QueryResults query_results;
  base::TimeTicks beginning_time = base::TimeTicks::Now();
  if (db_) {
    if (text_query.empty()) {
      
      QueryHistoryBasic(options, &query_results);
    } else {
      
      QueryHistoryText(text_query, options, &query_results);
    }
  }
  UMA_HISTOGRAM_TIMES("History.QueryHistory", TimeTicks::Now() - beginning_time);
  return query_results;
}


void HistoryBackend::QueryHistoryBasic(const QueryOptions& options, QueryResults* result) {
  
  VisitVector visits;
  bool has_more_results = db_->GetVisibleVisitsInRange(options, &visits);
  DCHECK_LE(static_cast<int>(visits.size()), options.EffectiveMaxCount());

  
  std::vector<URLResult> matching_results;
  URLResult url_result;
  for (const auto& visit : visits) {
    
    if (!db_->GetURLRow(visit.url_id, &url_result)) {
      DVLOG(0) << "Failed to get id " << visit.url_id << " from history.urls.";
      continue;  
    }

    if (!url_result.url().is_valid()) {
      DVLOG(0) << "Got invalid URL from history.urls with id " << visit.url_id << ":  " << url_result.url().possibly_invalid_spec();
      continue;  
    }

    url_result.set_visit_time(visit.visit_time);

    VisitContentAnnotations content_annotations;
    db_->GetContentAnnotationsForVisit(visit.visit_id, &content_annotations);
    url_result.set_content_annotations(content_annotations);

    
    
    url_result.set_blocked_visit( (visit.transition & ui::PAGE_TRANSITION_BLOCKED) != 0);

    
    
    matching_results.push_back(std::move(url_result));
  }
  result->SetURLResults(std::move(matching_results));

  if (!has_more_results && options.begin_time <= first_recorded_time_)
    result->set_reached_beginning(true);
}


void HistoryBackend::QueryHistoryText(const std::u16string& text_query, const QueryOptions& options, QueryResults* result) {

  URLRows text_matches = options.host_only ? GetMatchesForHost(text_query)

          : db_->GetTextMatchesWithAlgorithm( text_query, options.matching_algorithm.value_or( query_parser::MatchingAlgorithm::DEFAULT));


  std::vector<URLResult> matching_visits;
  VisitVector visits;  
  for (const auto& text_match : text_matches) {
    
    db_->GetVisibleVisitsForURL(text_match.id(), options, &visits);
    for (const auto& visit : visits) {
      URLResult url_result(text_match);
      url_result.set_visit_time(visit.visit_time);

      VisitContentAnnotations content_annotations;
      db_->GetContentAnnotationsForVisit(visit.visit_id, &content_annotations);
      url_result.set_content_annotations(content_annotations);

      matching_visits.push_back(url_result);
    }
  }

  std::sort(matching_visits.begin(), matching_visits.end(), URLResult::CompareVisitTime);

  size_t max_results = options.max_count == 0 ? std::numeric_limits<size_t>::max()
                           : static_cast<int>(options.max_count);
  bool has_more_results = false;
  if (matching_visits.size() > max_results) {
    has_more_results = true;
    matching_visits.resize(max_results);
  }
  result->SetURLResults(std::move(matching_visits));

  if (!has_more_results && options.begin_time <= first_recorded_time_)
    result->set_reached_beginning(true);
}

URLRows HistoryBackend::GetMatchesForHost(const std::u16string& host_name) {
  URLRows results;
  URLDatabase::URLEnumerator iter;

  if (db_ && db_->InitURLEnumeratorForEverything(&iter)) {
    URLRow row;
    std::string host_name_utf8 = base::UTF16ToUTF8(host_name);
    while (iter.GetNextURL(&row)) {
      if (row.url().is_valid() && row.url().host() == host_name_utf8) {
        results.push_back(std::move(row));
      }
    }
  }

  return results;
}

RedirectList HistoryBackend::QueryRedirectsFrom(const GURL& from_url) {
  if (!db_)
    return {};

  URLID from_url_id = db_->GetRowForURL(from_url, nullptr);
  VisitID cur_visit = db_->GetMostRecentVisitForURL(from_url_id, nullptr);
  if (!cur_visit)
    return {};  

  RedirectList redirects;
  GetRedirectsFromSpecificVisit(cur_visit, &redirects);
  return redirects;
}

RedirectList HistoryBackend::QueryRedirectsTo(const GURL& to_url) {
  if (!db_)
    return {};

  URLID to_url_id = db_->GetRowForURL(to_url, nullptr);
  VisitID cur_visit = db_->GetMostRecentVisitForURL(to_url_id, nullptr);
  if (!cur_visit)
    return {};  

  RedirectList redirects;
  GetRedirectsToSpecificVisit(cur_visit, &redirects);
  return redirects;
}

VisibleVisitCountToHostResult HistoryBackend::GetVisibleVisitCountToHost( const GURL& url) {
  VisibleVisitCountToHostResult result;
  result.success = db_ && db_->GetVisibleVisitCountToHost(url, &result.count, &result.first_visit);
  return result;
}

MostVisitedURLList HistoryBackend::QueryMostVisitedURLs(int result_count, int days_back) {
  if (!db_)
    return {};

  base::TimeTicks begin_time = base::TimeTicks::Now();

  auto url_filter = backend_client_ ? base::BindRepeating(&HistoryBackendClient::IsWebSafe, base::Unretained(backend_client_.get()))


          : base::NullCallback();
  std::vector<std::unique_ptr<PageUsageData>> data = db_->QuerySegmentUsage( base::Time::Now() - base::Days(days_back), result_count, url_filter);

  MostVisitedURLList result;
  for (const std::unique_ptr<PageUsageData>& current_data : data)
    result.emplace_back(current_data->GetURL(), current_data->GetTitle());

  UMA_HISTOGRAM_TIMES("History.QueryMostVisitedURLsTime", base::TimeTicks::Now() - begin_time);

  return result;
}

void HistoryBackend::GetRedirectsFromSpecificVisit(VisitID cur_visit, RedirectList* redirects) {
  
  
  
  GURL cur_url;
  std::set<VisitID> visit_set;
  visit_set.insert(cur_visit);
  while (db_->GetRedirectFromVisit(cur_visit, &cur_visit, &cur_url)) {
    if (visit_set.find(cur_visit) != visit_set.end()) {
      NOTREACHED() << "Loop in visit chain, giving up";
      return;
    }
    visit_set.insert(cur_visit);
    redirects->push_back(cur_url);
  }
}

void HistoryBackend::GetRedirectsToSpecificVisit(VisitID cur_visit, RedirectList* redirects) {
  
  
  
  if (!db_)
    return;

  GURL cur_url;
  std::set<VisitID> visit_set;
  visit_set.insert(cur_visit);
  while (db_->GetRedirectToVisit(cur_visit, &cur_visit, &cur_url)) {
    if (visit_set.find(cur_visit) != visit_set.end()) {
      NOTREACHED() << "Loop in visit chain, giving up";
      return;
    }
    visit_set.insert(cur_visit);
    redirects->push_back(cur_url);
  }
}

void HistoryBackend::ScheduleAutocomplete( base::OnceCallback<void(HistoryBackend*, URLDatabase*)> callback) {
  std::move(callback).Run(this, db_.get());
}

void HistoryBackend::DeleteFTSIndexDatabases() {
  
  
  base::FilePath::StringType filepattern = FILE_PATH_LITERAL("History Index *");
  base::FileEnumerator enumerator(history_dir_, false, base::FileEnumerator::FILES, filepattern);
  int num_databases_deleted = 0;
  base::FilePath current_file;
  while (!(current_file = enumerator.Next()).empty()) {
    if (sql::Database::Delete(current_file))
      num_databases_deleted++;
  }
  UMA_HISTOGRAM_COUNTS_1M("History.DeleteFTSIndexDatabases", num_databases_deleted);
}

std::vector<favicon_base::FaviconRawBitmapResult> HistoryBackend::GetFavicon( const GURL& icon_url, favicon_base::IconType icon_type, const std::vector<int>& desired_sizes) {


  return UpdateFaviconMappingsAndFetch({}, icon_url, icon_type, desired_sizes);
}

favicon_base::FaviconRawBitmapResult HistoryBackend::GetLargestFaviconForURL( const GURL& page_url, const std::vector<favicon_base::IconTypeSet>& icon_types_list, int minimum_size_in_pixels) {


  if (!db_ || !favicon_backend_)
    return {};

  return favicon_backend_->GetLargestFaviconForUrl(page_url, icon_types_list, minimum_size_in_pixels);
}

std::vector<favicon_base::FaviconRawBitmapResult> HistoryBackend::GetFaviconsForURL(const GURL& page_url, const favicon_base::IconTypeSet& icon_types, const std::vector<int>& desired_sizes, bool fallback_to_host) {



  if (!favicon_backend_)
    return {};
  return favicon_backend_->GetFaviconsForUrl(page_url, icon_types, desired_sizes, fallback_to_host);
}

std::vector<favicon_base::FaviconRawBitmapResult> HistoryBackend::GetFaviconForID(favicon_base::FaviconID favicon_id, int desired_size) {

  if (!favicon_backend_)
    return {};
  return favicon_backend_->GetFaviconForId(favicon_id, desired_size);
}

std::vector<favicon_base::FaviconRawBitmapResult> HistoryBackend::UpdateFaviconMappingsAndFetch( const base::flat_set<GURL>& page_urls, const GURL& icon_url, favicon_base::IconType icon_type, const std::vector<int>& desired_sizes) {




  if (!favicon_backend_)
    return {};
  auto result = favicon_backend_->UpdateFaviconMappingsAndFetch( page_urls, icon_url, icon_type, desired_sizes);
  if (!result.updated_page_urls.empty()) {
    for (auto& page_url : result.updated_page_urls)
      SendFaviconChangedNotificationForPageAndRedirects(page_url);
    ScheduleCommit();
  }
  return result.bitmap_results;
}

void HistoryBackend::DeleteFaviconMappings( const base::flat_set<GURL>& page_urls, favicon_base::IconType icon_type) {

  if (!favicon_backend_ || !db_)
    return;

  auto deleted_page_urls = favicon_backend_->DeleteFaviconMappings(page_urls, icon_type);
  for (auto& deleted_page_url : deleted_page_urls)
    SendFaviconChangedNotificationForPageAndRedirects(deleted_page_url);
  if (!deleted_page_urls.empty())
    ScheduleCommit();
}

void HistoryBackend::MergeFavicon( const GURL& page_url, const GURL& icon_url, favicon_base::IconType icon_type, scoped_refptr<base::RefCountedMemory> bitmap_data, const gfx::Size& pixel_size) {




  if (!favicon_backend_ || !db_)
    return;

  favicon::MergeFaviconResult result = favicon_backend_->MergeFavicon( page_url, icon_url, icon_type, bitmap_data, pixel_size);
  if (result.did_page_to_icon_mapping_change)
    SendFaviconChangedNotificationForPageAndRedirects(page_url);
  if (result.did_icon_change)
    SendFaviconChangedNotificationForIconURL(icon_url);
  ScheduleCommit();
}

void HistoryBackend::SetFavicons(const base::flat_set<GURL>& page_urls, favicon_base::IconType icon_type, const GURL& icon_url, const std::vector<SkBitmap>& bitmaps) {


  if (!favicon_backend_)
    return;

  ProcessSetFaviconsResult( favicon_backend_->SetFavicons(page_urls, icon_type, icon_url, bitmaps, FaviconBitmapType::ON_VISIT), icon_url);


}

void HistoryBackend::CloneFaviconMappingsForPages( const GURL& page_url_to_read, const favicon_base::IconTypeSet& icon_types, const base::flat_set<GURL>& page_urls_to_write) {


  TRACE_EVENT0("browser", "HistoryBackend::CloneFaviconMappingsForPages");

  if (!db_ || !favicon_backend_)
    return;

  std::set<GURL> changed_urls = favicon_backend_->CloneFaviconMappingsForPages( page_url_to_read, icon_types, page_urls_to_write);
  if (changed_urls.empty())
    return;

  ScheduleCommit();
  NotifyFaviconsChanged(changed_urls, GURL());
}

bool HistoryBackend::CanSetOnDemandFavicons(const GURL& page_url, favicon_base::IconType icon_type) {
  return favicon_backend_ && db_ && favicon_backend_->CanSetOnDemandFavicons(page_url, icon_type);
}

bool HistoryBackend::SetOnDemandFavicons(const GURL& page_url, favicon_base::IconType icon_type, const GURL& icon_url, const std::vector<SkBitmap>& bitmaps) {


  if (!favicon_backend_ || !db_)
    return false;

  return ProcessSetFaviconsResult(favicon_backend_->SetOnDemandFavicons( page_url, icon_type, icon_url, bitmaps), icon_url);

}

void HistoryBackend::SetFaviconsOutOfDateForPage(const GURL& page_url) {
  if (favicon_backend_ && favicon_backend_->SetFaviconsOutOfDateForPage(page_url)) {
    ScheduleCommit();
  }
}

void HistoryBackend::SetFaviconsOutOfDateBetween(base::Time begin, base::Time end) {
  if (favicon_backend_ && favicon_backend_->SetFaviconsOutOfDateBetween(begin, end)) {
    ScheduleCommit();
  }
}

void HistoryBackend::TouchOnDemandFavicon(const GURL& icon_url) {
  TRACE_EVENT0("browser", "HistoryBackend::TouchOnDemandFavicon");

  if (!favicon_backend_)
    return;
  favicon_backend_->TouchOnDemandFavicon(icon_url);
  ScheduleCommit();
}

void HistoryBackend::SetImportedFavicons( const favicon_base::FaviconUsageDataList& favicon_usage) {
  TRACE_EVENT0("browser", "HistoryBackend::SetImportedFavicons");

  if (!db_ || !favicon_backend_)
    return;

  Time now = Time::Now();

  
  std::set<GURL> favicons_changed;

  favicon::FaviconDatabase* favicon_db = favicon_backend_->db();
  for (const auto& favicon_usage_data : favicon_usage) {
    favicon_base::FaviconID favicon_id = favicon_db->GetFaviconIDForFaviconURL( favicon_usage_data.favicon_url, favicon_base::IconType::kFavicon);
    if (!favicon_id) {
      
      
      favicon_id = favicon_db->AddFavicon( favicon_usage_data.favicon_url, favicon_base::IconType::kFavicon, new base::RefCountedBytes(favicon_usage_data.png_data), FaviconBitmapType::ON_VISIT, now, gfx::Size());


    }

    
    for (const auto& url : favicon_usage_data.urls) {
      URLRow url_row;
      if (!db_->GetRowForURL(url, &url_row)) {
        
        
        
        
        
        
        if (backend_client_ && backend_client_->IsPinnedURL(url)) {
          URLRow url_info(url);
          url_info.set_visit_count(0);
          url_info.set_typed_count(0);
          url_info.set_last_visit(base::Time());
          url_info.set_hidden(false);
          db_->AddURL(url_info);
          favicon_db->AddIconMapping(url, favicon_id);
          favicons_changed.insert(url);
        }
      } else {
        if (!favicon_db->GetIconMappingsForPageURL( url, {favicon_base::IconType::kFavicon}, nullptr)) {

          
          
          favicon_db->AddIconMapping(url, favicon_id);
          favicons_changed.insert(url);
        }
      }
    }
  }

  if (!favicons_changed.empty()) {
    
    NotifyFaviconsChanged(favicons_changed, GURL());
  }
}

RedirectList HistoryBackend::GetCachedRecentRedirects(const GURL& page_url) {
  auto iter = recent_redirects_.Get(page_url);
  if (iter != recent_redirects_.end()) {
    
    DCHECK(!iter->second.empty());
    DCHECK_EQ(iter->second.back(), page_url);
    return iter->second;
  }
  
  return RedirectList{page_url};
}

void HistoryBackend::SendFaviconChangedNotificationForPageAndRedirects( const GURL& page_url) {
  RedirectList redirect_list = GetCachedRecentRedirects(page_url);
  if (!redirect_list.empty()) {
    std::set<GURL> favicons_changed(redirect_list.begin(), redirect_list.end());
    NotifyFaviconsChanged(favicons_changed, GURL());
  }
}

void HistoryBackend::SendFaviconChangedNotificationForIconURL( const GURL& icon_url) {
  NotifyFaviconsChanged(std::set<GURL>(), icon_url);
}

void HistoryBackend::Commit() {
  if (!db_)
    return;


  
  
  base::ios::ScopedCriticalAction scoped_critical_action( "HistoryBackend::Commit");


  
  
  
  
  
  
  CancelScheduledCommit();

  db_->CommitTransaction();
  DCHECK_EQ(db_->transaction_nesting(), 0)
      << "Somebody left a transaction open";
  db_->BeginTransaction();

  if (favicon_backend_)
    favicon_backend_->Commit();
}

void HistoryBackend::ScheduleCommit() {
  
  
  if (!scheduled_commit_.IsCancelled())
    return;

  scheduled_commit_.Reset( base::BindOnce(&HistoryBackend::Commit, base::Unretained(this)));

  task_runner_->PostDelayedTask(FROM_HERE, scheduled_commit_.callback(), base::Seconds(kCommitIntervalSeconds));
}

void HistoryBackend::CancelScheduledCommit() {
  scheduled_commit_.Cancel();
}

void HistoryBackend::ProcessDBTaskImpl() {
  if (!db_) {
    
    queued_history_db_tasks_.clear();
    return;
  }

  
  while (!queued_history_db_tasks_.empty()) {
    QueuedHistoryDBTask* task = queued_history_db_tasks_.front().get();
    if (!task->is_canceled())
      break;

    queued_history_db_tasks_.pop_front();
  }
  if (queued_history_db_tasks_.empty())
    return;

  
  std::unique_ptr<QueuedHistoryDBTask> task = std::move(queued_history_db_tasks_.front());
  queued_history_db_tasks_.pop_front();
  if (task->Run(this, db_.get())) {
    
    task->DoneRun();
  } else {
    
    
    queued_history_db_tasks_.push_back(std::move(task));
    task_runner_->PostTask( FROM_HERE, base::BindOnce(&HistoryBackend::ProcessDBTaskImpl, this));
  }
}







void HistoryBackend::DeleteURLs(const std::vector<GURL>& urls) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteURLs");

  expirer_.DeleteURLs(urls, base::Time::Max());

  db_->GetStartDate(&first_recorded_time_);
  
  
  Commit();
}

void HistoryBackend::DeleteURL(const GURL& url) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteURL");

  expirer_.DeleteURL(url, base::Time::Max());

  db_->GetStartDate(&first_recorded_time_);
  
  
  Commit();
}

void HistoryBackend::DeleteURLsUntil( const std::vector<std::pair<GURL, base::Time>>& urls_and_timestamps) {
  TRACE_EVENT0("browser", "HistoryBackend::DeleteURLsUntil");

  for (const auto& pair : urls_and_timestamps) {
    expirer_.DeleteURL(pair.first, pair.second);
  }
  db_->GetStartDate(&first_recorded_time_);
  
  
  Commit();
}

void HistoryBackend::ExpireHistoryBetween(const std::set<GURL>& restrict_urls, Time begin_time, Time end_time, bool user_initiated) {


  if (!db_)
    return;

  if (begin_time.is_null() && (end_time.is_null() || end_time.is_max()) && restrict_urls.empty()) {
    
    
    DeleteAllHistory();
  } else {
    
    expirer_.ExpireHistoryBetween(restrict_urls, begin_time, end_time, user_initiated);

    
    
    Commit();
  }

  if (begin_time <= first_recorded_time_)
    db_->GetStartDate(&first_recorded_time_);
}

void HistoryBackend::ExpireHistoryForTimes(const std::set<base::Time>& times, base::Time begin_time, base::Time end_time) {

  if (times.empty() || !db_)
    return;

  QueryOptions options;
  options.begin_time = begin_time;
  options.end_time = end_time;
  options.duplicate_policy = QueryOptions::KEEP_ALL_DUPLICATES;
  QueryResults results;
  QueryHistoryBasic(options, &results);

  
  std::set<GURL> urls;
  for (const auto& result : results) {
    if (times.count(result.visit_time()) > 0)
      urls.insert(result.url());
  }
  if (urls.empty())
    return;

  
  std::vector<base::Time> times_to_expire;
  for (const auto& result : results) {
    if (urls.count(result.url()))
      times_to_expire.push_back(result.visit_time());
  }

  
  
  std::sort(times_to_expire.begin(), times_to_expire.end(), std::greater<base::Time>());
  times_to_expire.erase( std::unique(times_to_expire.begin(), times_to_expire.end()), times_to_expire.end());


  
  DCHECK(!times_to_expire.empty());
  expirer_.ExpireHistoryForTimes(times_to_expire);
  Commit();

  DCHECK_GE(times_to_expire.back(), first_recorded_time_);
  
  if (times_to_expire.back() == first_recorded_time_)
    db_->GetStartDate(&first_recorded_time_);
}

void HistoryBackend::ExpireHistory( const std::vector<ExpireHistoryArgs>& expire_list) {
  if (db_) {
    bool update_first_recorded_time = false;

    for (const auto& expire : expire_list) {
      expirer_.ExpireHistoryBetween(expire.urls, expire.begin_time, expire.end_time, true);

      if (expire.begin_time < first_recorded_time_)
        update_first_recorded_time = true;
    }
    Commit();

    
    if (update_first_recorded_time)
      db_->GetStartDate(&first_recorded_time_);
  }
}

void HistoryBackend::ExpireHistoryBeforeForTesting(base::Time end_time) {
  if (!db_)
    return;

  expirer_.ExpireHistoryBeforeForTesting(end_time);
}

void HistoryBackend::URLsNoLongerBookmarked(const std::set<GURL>& urls) {
  TRACE_EVENT0("browser", "HistoryBackend::URLsNoLongerBookmarked");

  if (!db_)
    return;

  for (const auto& url : urls) {
    VisitVector visits;
    URLRow url_row;
    if (db_->GetRowForURL(url, &url_row))
      db_->GetVisitsForURL(url_row.id(), &visits);
    
    
    
    if (visits.empty())
      expirer_.DeleteURL(url, base::Time::Max());
  }
}

void HistoryBackend::DatabaseErrorCallback(int error, sql::Statement* stmt) {
  if (!scheduled_kill_db_ && sql::IsErrorCatastrophic(error)) {
    scheduled_kill_db_ = true;

    db_diagnostics_ = db_->GetDiagnosticInfo(error, stmt);

    
    
    
    
    
    
    
    task_runner_->PostTask( FROM_HERE, base::BindOnce(&HistoryBackend::KillHistoryDatabase, this));
  }
}

void HistoryBackend::KillHistoryDatabase() {
  scheduled_kill_db_ = false;
  if (!db_)
    return;

  
  
  if (typed_url_sync_bridge_)
    typed_url_sync_bridge_->OnDatabaseError();

  
  
  db_->RollbackTransaction();
  bool success = db_->Raze();
  UMA_HISTOGRAM_BOOLEAN("History.KillHistoryDatabaseResult", success);

  
  supports_user_data_helper_.reset();

  
  
  expirer_.SetDatabases(nullptr, nullptr);

  
  db_->BeginTransaction();
  CloseAllDatabases();
}

base::SupportsUserData::Data* HistoryBackend::GetUserData( const void* key) const {
  DCHECK(supports_user_data_helper_);
  return supports_user_data_helper_->GetUserData(key);
}

void HistoryBackend::SetUserData( const void* key, std::unique_ptr<base::SupportsUserData::Data> data) {

  DCHECK(supports_user_data_helper_);
  supports_user_data_helper_->SetUserData(key, std::move(data));
}

void HistoryBackend::ProcessDBTask( std::unique_ptr<HistoryDBTask> task, scoped_refptr<base::SingleThreadTaskRunner> origin_loop, const base::CancelableTaskTracker::IsCanceledCallback& is_canceled) {


  TRACE_EVENT0("browser", "HistoryBackend::ProcessDBTask");
  bool scheduled = !queued_history_db_tasks_.empty();
  queued_history_db_tasks_.push_back(std::make_unique<QueuedHistoryDBTask>( std::move(task), origin_loop, is_canceled));
  if (!scheduled)
    ProcessDBTaskImpl();
}

void HistoryBackend::NotifyFaviconsChanged(const std::set<GURL>& page_urls, const GURL& icon_url) {
  delegate_->NotifyFaviconsChanged(page_urls, icon_url);
}

void HistoryBackend::NotifyURLVisited(ui::PageTransition transition, const URLRow& row, const RedirectList& redirects, base::Time visit_time) {


  for (HistoryBackendObserver& observer : observers_)
    observer.OnURLVisited(this, transition, row, redirects, visit_time);

  delegate_->NotifyURLVisited(transition, row, redirects, visit_time);
}

void HistoryBackend::NotifyURLsModified(const URLRows& changed_urls, bool is_from_expiration) {
  for (HistoryBackendObserver& observer : observers_)
    observer.OnURLsModified(this, changed_urls, is_from_expiration);

  delegate_->NotifyURLsModified(changed_urls);
}

void HistoryBackend::NotifyURLsDeleted(DeletionInfo deletion_info) {
  std::set<GURL> origins;
  for (const history::URLRow& row : deletion_info.deleted_rows())
    origins.insert(row.url().DeprecatedGetOriginAsURL());

  deletion_info.set_deleted_urls_origin_map( GetCountsAndLastVisitForOrigins(origins));

  for (HistoryBackendObserver& observer : observers_) {
    observer.OnURLsDeleted( this, deletion_info.IsAllHistory(), deletion_info.is_from_expiration(), deletion_info.deleted_rows(), deletion_info.favicon_urls());

  }

  delegate_->NotifyURLsDeleted(std::move(deletion_info));
}

void HistoryBackend::NotifyVisitDeleted(const VisitRow& visit) {
  tracker_.RemoveVisitById(visit.visit_id);
}



void HistoryBackend::DeleteAllHistory() {
  
  
  
  
  
  
  
  
  
  
  

  
  std::vector<URLAndTitle> pinned_url;
  if (backend_client_)
    pinned_url = backend_client_->GetPinnedURLs();

  URLRows kept_url_rows;
  std::vector<GURL> starred_urls;
  for (URLAndTitle& url_and_title : pinned_url) {
    URLRow row;
    if (db_->GetRowForURL(url_and_title.url, &row)) {
      
      row.set_last_visit(Time());
      row.set_visit_count(0);
      row.set_typed_count(0);
      kept_url_rows.push_back(row);
    }

    starred_urls.push_back(std::move(url_and_title.url));
  }

  
  if (!ClearAllFaviconHistory(starred_urls)) {
    LOG(ERROR) << "Favicon history could not be cleared";
    
    
  }

  
  
  
  if (!ClearAllMainHistory(kept_url_rows))
    LOG(ERROR) << "Main history could not be cleared";
  kept_url_rows.clear();

  db_->GetStartDate(&first_recorded_time_);

  tracker_.Clear();

  
  
  NotifyURLsDeleted(DeletionInfo::ForAllHistory());
}

bool HistoryBackend::ClearAllFaviconHistory( const std::vector<GURL>& kept_urls) {
  if (!favicon_backend_) {
    
    
    
    
    sql::Database::Delete(GetFaviconsFileName());
    return true;
  }
  if (!favicon_backend_->ClearAllExcept(kept_urls))
    return false;


  
  
  db_->ClearAndroidURLRows();

  return true;
}

void HistoryBackend::ClearAllOnDemandFavicons() {
  expirer_.ClearOldOnDemandFaviconsIfPossible(base::Time::Now());
}

bool HistoryBackend::ClearAllMainHistory(const URLRows& kept_urls) {
  
  if (!db_->CreateTemporaryURLTable())
    return false;

  
  for (const auto& url : kept_urls)
    db_->AddTemporaryURL(url);

  
  if (!db_->CommitTemporaryURLTable())
    return false;

  
  db_->RecreateAllTablesButURL();

  
  
  
  db_->CommitTransaction();
  db_->Vacuum();
  db_->BeginTransaction();
  db_->GetStartDate(&first_recorded_time_);

  return true;
}

std::vector<GURL> HistoryBackend::GetCachedRecentRedirectsForPage( const GURL& page_url) {
  return GetCachedRecentRedirects(page_url);
}

bool HistoryBackend::ProcessSetFaviconsResult( const favicon::SetFaviconsResult& result, const GURL& icon_url) {

  if (!result.did_change_database())
    return false;

  ScheduleCommit();
  if (result.did_update_bitmap)
    SendFaviconChangedNotificationForIconURL(icon_url);
  for (const GURL& page_url : result.updated_page_urls)
    SendFaviconChangedNotificationForPageAndRedirects(page_url);
  return true;
}

}  
