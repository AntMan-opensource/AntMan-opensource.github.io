







































































































































































































































typedef unsigned int uint;


typedef unsigned char uchar;














typedef enum {
    JSI_SIG_ITEROBJ=0xdeadbaa0, JSI_SIG_FUNCOBJ, JSI_SIG_SCOPE, JSI_SIG_VALUE, JSI_SIG_OBJ, JSI_SIG_USERDATA, JSI_SIG_INTERP, JSI_SIG_PARSER, JSI_SIG_FILEOBJ, JSI_SIG_INTERPOBJ, JSI_SIG_FUNC, JSI_SIG_CMDSPECITEM, JSI_SIG_HASH, JSI_SIG_HASHENTRY, JSI_SIG_TREE, JSI_SIG_TREEENTRY, JSI_SIG_LIST, JSI_SIG_LISTENTRY, JSI_SIG_USER_REG, JSI_SIG_EVENT, JSI_SIG_MAP, JSI_SIG_REGEXP, JSI_SIG_ARGTYPE, JSI_SIG_FORINVAR, JSI_SIG_CASELIST, JSI_SIG_CASESTAT, JSI_SIG_FASTVAR, JSI_SIG_INTERPSTREVENT, JSI_SIG_ALIASCMD, JSI_SIG_SOCKET, JSI_SIG_SOCKETPSS, JSI_SIG_NAMEDATA } jsi_Sig;










struct jsi_OpCode;


extern void jsi_VALCHK(Jsi_Value *v);
extern void jsi_OBJCHK(Jsi_Obj *o);







enum {  jsi_callTraceFuncs = 1, jsi_callTraceCmds = 2, jsi_callTraceNew = 4, jsi_callTraceReturn = 8, jsi_callTraceArgs = 16, jsi_callTraceNoTrunc = 32,  jsi_callTraceNoParent = 64, jsi_callTraceFullPath = 128, jsi_callTraceBefore = 256 };





typedef struct jsi_ScopeChain_ {

    jsi_Sig sig;

    Jsi_Interp *interp;
    Jsi_Value **chains;  
    int chains_cnt;         
} jsi_ScopeChain;



struct Jsi_FuncObj {

    jsi_Sig sig;

    Jsi_Interp *interp;
    Jsi_Func *func;
    jsi_ScopeChain *scope;
    Jsi_Value *bindArgs;
    Jsi_Value *bindFunc;
};


typedef struct UserObjReg_ { 

    jsi_Sig sig;

    Jsi_UserObjReg *reg;
    Jsi_Hash* hashPtr;
    int idx;
} UserObjReg;


typedef struct Jsi_UserObj {

    jsi_Sig sig;

    Jsi_Interp *interp;
    Jsi_Hash *id;
    void *data;
    const char *prefix;
    Jsi_UserObjReg *reg;
    struct UserObjReg_ *ureg;
    uintptr_t idx;
    Jsi_HashEntry* hPtr;
} Jsi_UserObj;

typedef struct {
    int valueCnt;
    int objCnt;
    int valueAllocCnt;
    int objAllocCnt;

    Jsi_Hash *valueDebugTbl;
    Jsi_Hash *objDebugTbl;
    uint memDebugCallIdx;

} Jsi_InterpDebug;






typedef enum {      
    OP_NOP,          OP_PUSHNUM, OP_PUSHSTR, OP_PUSHVSTR, OP_PUSHVAR, OP_PUSHUND, OP_PUSHNULL, OP_PUSHBOO, OP_PUSHFUN, OP_PUSHREG, OP_PUSHARG, OP_PUSHTHS, OP_PUSHTOP, OP_PUSHTOP2, OP_UNREF, OP_POP, OP_LOCAL, OP_NEG, OP_POS, OP_NOT, OP_BNOT, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_MOD, OP_LESS, OP_GREATER, OP_LESSEQU, OP_GREATEREQU, OP_EQUAL, OP_NOTEQUAL, OP_STRICTEQU, OP_STRICTNEQ, OP_BAND, OP_BOR, OP_BXOR, OP_SHF, OP_INSTANCEOF, OP_ASSIGN,  OP_SUBSCRIPT, OP_INC, OP_TYPEOF, OP_IN, OP_DEC, OP_KEY, OP_NEXT, OP_JTRUE, OP_JFALSE, OP_JTRUE_NP, OP_JFALSE_NP, OP_JMP, OP_JMPPOP, OP_FCALL, OP_NEWFCALL, OP_RET, OP_DELETE, OP_CHTHIS, OP_OBJECT, OP_ARRAY, OP_EVAL, OP_STRY, OP_ETRY, OP_SCATCH, OP_ECATCH, OP_SFINAL, OP_EFINAL, OP_THROW, OP_WITH, OP_EWITH, OP_RESERVED, OP_DEBUG, OP_LASTOP } jsi_Eopcode;










































































typedef enum { jsi_Oplf_none=0, jsi_Oplf_assert=1, jsi_Oplf_debug=2, jsi_Oplf_trace=3, jsi_Oplf_test=4 } jsi_OpLogFlags;

typedef struct jsi_OpCode {
    jsi_Eopcode op;
    void *data;
    unsigned int Line:16;
    unsigned int Lofs:8;
    unsigned char alloc:1;
    unsigned char nodebug:1;
    unsigned char hit:1;
    unsigned char isof:1;
    unsigned char local:1;
    jsi_OpLogFlags logflag:3;
    const char *fname;
} jsi_OpCode;


typedef struct Jsi_OpCodes {
    jsi_OpCode *codes;
    int code_len;
    int code_size;          
    
    int expr_counter;           
    int lvalue_flag;            
    const char *lvalue_name; 
    int line;  

    Jsi_HashEntry *hPtr;
    int id;

} Jsi_OpCodes;


typedef struct jsi_TryInfo {
    int trylen;
    int catchlen;
    int finallen;
} jsi_TryInfo;

typedef struct jsi_ReservedInfo {
    int type;
    const char *label;
    int topop;
} jsi_ReservedInfo;

typedef struct jsi_JmpPopInfo {
    int off;
    int topop;
} jsi_JmpPopInfo;



typedef struct YYLTYPE jsi_Pline;


void jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz);
const char* jsi_opcode_string(uint opCode);


typedef struct  {
    const char *fname;
    int line;
    const char *func;
    const char *label;
    const char *label2;
    const char *label3;
    uint Idx;
    uint flags;
    struct jsi_OpCode *ip;
    int ipLine;
    jsi_Eopcode ipOp;
    const char* ipFname;
    Jsi_HashEntry *hPtr;
    Jsi_Interp *interp;
} jsi_ValueDebug;


struct Jsi_Obj {

    jsi_Sig sig;

    int refcnt;                 
    Jsi_otype ot:8;             
    uint isarrlist:1;           
    uint isstrkey:1;            
    uint isJSONstr:1;
    uint clearProto:1;          
    uint isNoOp:1;
    uint isBlob:1;
    uint unused2:16;
    union {                     
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Regex *robj;
        Jsi_FuncObj *fobj;
        Jsi_IterObj *iobj;
        Jsi_UserObj *uobj;
    } d;
    uint arrMaxSize;                 
    uint arrCnt;                     
    Jsi_Value **arr;     
    Jsi_Tree *tree;                 
    Jsi_Value *__proto__;           
    struct Jsi_Obj *constructor;
    struct Jsi_Obj *next, *prev;    
    int gc_refs;

    jsi_ValueDebug VD;

};




struct Jsi_Value {

    jsi_Sig sig;

    int32_t refCnt;
    Jsi_vtype vt:8;             
    union {
        uint flag:8;
        struct vflagbit {
            uint readonly:1;
            uint dontenum:1;  
            uint dontdel:1;
            uint innershared:1; 
            uint isarrlist:1;
            uint isstrkey:1;    
            uint local:1;       
            uint lookupfailed:1;
        } bits;
    } f;
    union {                     
        int val;
        Jsi_Number num;
        Jsi_String s;
        Jsi_Obj *obj;
        struct Jsi_Value *lval;
        const char *lookupFail;
    } d;
    struct Jsi_Value *next, *prev;

    jsi_ValueDebug VD;

};





typedef uintptr_t jsi_Hash;

typedef union jsi_HashKey {
    char string[sizeof(jsi_Hash)];  
    void *oneWordValue;             
} jsi_HashKey;

typedef struct Jsi_HashEntry {
    jsi_Sig sig;
    int typ; 
    struct Jsi_HashEntry *nextPtr;
    Jsi_Hash *tablePtr;
    jsi_Hash hval;
    void* clientData;
    jsi_HashKey key;
} Jsi_HashEntry;


typedef struct Jsi_Hash {

    jsi_Sig sig;

    int typ; 
    Jsi_HashEntry **buckets;
    Jsi_HashEntry *staticBuckets[JSI_SMALL_HASH_TABLE];
    int numBuckets;
    int numEntries;
    int rebuildSize;
    jsi_Hash mask;
    unsigned int downShift;
    int keyType;
    Jsi_HashEntry *(*createProc) (Jsi_Hash *tablePtr, const void *key, bool *newPtr);
    Jsi_HashEntry *(*findProc) (Jsi_Hash *tablePtr, const void *key);
    Jsi_MapOpts opts;
} Jsi_Hash;

struct Jsi_Tree {

    jsi_Sig sig;

    int typ; 
    
    Jsi_TreeEntry *root;
    uint numEntries, keyType, epoch;
    struct {
        uint  inserting:1, destroyed:1, nonredblack:1, internstr:1, valuesonly:1, unused:28;




    } flags;
    Jsi_Hash* strHash;  
    Jsi_TreeEntry* (*createProc)(Jsi_Tree *treePtr, const void *key, bool *newPtr);
    Jsi_MapOpts opts;
};

typedef struct Jsi_TreeEntry {

    jsi_Sig sig;

    int typ; 
    Jsi_Tree *treePtr;
    struct Jsi_TreeEntry* left;
    struct Jsi_TreeEntry* right;
    struct Jsi_TreeEntry* parent;
    union { 
        struct { 
            unsigned int readonly:1, dontenum:1, dontdel:1, innershared:1, isarrlist:1, isstrkey:1, unused:1, color:1, reserve:8, user0:8, user1:1, user2:1, user3:1, user4:1, user5:1, user6:1, user7:1, user8:1;



        } bits;
        int flags;
    } f;
    void* value;
    jsi_HashKey key;
} Jsi_TreeEntry;

typedef struct Jsi_Map {  
    uint sig;
    Jsi_Map_Type typ;
    union {
        Jsi_Hash *hash;
        Jsi_Tree *tree;
        Jsi_List *list;
    } v;
} Jsi_Map;

typedef struct jsi_ArgValue_ {
    char *name;
    uint type;  
    Jsi_Value *defValue;
} jsi_ArgValue;

typedef struct Jsi_ScopeStrs {
    jsi_ArgValue *args;
    int count;
    int _size;  
    int varargs;
    int typeCnt;
    int firstDef;
    int argCnt;
    int retType;
} Jsi_ScopeStrs;


typedef struct jsi_Frame {
    int level;
    const char *fileName;
    const char *funcName;
    const char *dirName;
    int line;
    jsi_OpCode *ip;
    int Sp;
    int tryDepth;
    int withDepth;
    jsi_ScopeChain* ingsc;
    Jsi_Value *incsc;
    Jsi_Value *inthis;
    Jsi_OpCodes *opcodes;
    struct jsi_Pstate *ps;
    int logflag;
    Jsi_Func *evalFuncPtr;
    struct jsi_Frame *parent, *child;
    Jsi_Value *arguments; 
} jsi_Frame;


typedef struct jsi_Pstate {

    jsi_Sig sig;

    int err_count;              
    int eval_flag;              
    int funcDefs;               
    Jsi_OpCodes *opcodes;       
    struct jsi_Lexer *lexer;        

    int _context_id;            
    Jsi_Value *last_exception;
    Jsi_Interp *interp;
    Jsi_HashEntry *hPtr;
    Jsi_Hash *argsTbl;
    Jsi_Hash *fastVarTbl;
    Jsi_Hash *strTbl;
    int argType;                
    Jsi_ScopeStrs *args;        
} jsi_Pstate;


Jsi_ScopeStrs *jsi_ScopeStrsNew(void);
void jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType);
void jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss);
const char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i);

void jsi_PstatePush(jsi_Pstate *ps);
void jsi_PstatePop(jsi_Pstate *ps);
void jsi_PstateAddVar(jsi_Pstate *ps, jsi_Pline *line, const char *str);
Jsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps);

void jsi_PstateFree(jsi_Pstate *ps);
jsi_Pstate *jsi_PstateNew(Jsi_Interp *interp);
void jsi_PstateClear(jsi_Pstate *ps);
const char * jsi_PstateGetFilename(jsi_Pstate *ps);
int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang);
int jsi_PstateSetString(jsi_Pstate *ps, const char *str);

extern int yyparse(jsi_Pstate *ps);





typedef struct jsi_ForinVar {
    jsi_Sig sig;
    const char *varname;
    Jsi_OpCodes *local;
    Jsi_OpCodes *lval;
} jsi_ForinVar;


typedef struct jsi_CaseExprStat {
    jsi_Sig sig;
    Jsi_OpCodes *expr;
    Jsi_OpCodes *stat;
    int isdefault;
} jsi_CaseExprStat;


typedef struct jsi_CaseList {
    jsi_Sig sig;
    jsi_CaseExprStat *es;
    int off;
    struct jsi_CaseList *tail;
    struct jsi_CaseList *next;
} jsi_CaseList;


typedef enum {
    LT_NONE, LT_FILE, LT_STRING } Jsi_Lexer_Type;




typedef struct jsi_Lexer {
    Jsi_Lexer_Type ltype;
    union {
        Jsi_Channel fp;           
        char *str;          
    } d;
    int last_token;         
    int ungot, unch[100];
    int cur;                
    int cur_line;           
    int cur_char;           
    int inStr;
    jsi_Pstate *pstate;
} jsi_Lexer;

int yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate);
void yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg);

typedef struct {
    jsi_Sig sig;
    int context_id:31;
    unsigned int local:1;
    jsi_Pstate *ps;
    char *varname;
    struct Jsi_Value *lval;
} jsi_FastVar;

typedef enum { FC_NORMAL, FC_BUILDIN } Jsi_Func_Type;
struct jsi_PkgInfo;


struct Jsi_Func {

    jsi_Sig sig;

    Jsi_Func_Type type;                         
    struct Jsi_OpCodes *opcodes;    
    Jsi_CmdProc *callback;            

    Jsi_ScopeStrs *argnames;                 
    Jsi_ScopeStrs *localnames;               
    union {
        uint flags;
        struct {
            uint res:8, hasattr:1, isobj:1 , iscons:1, res2:4;
        } bits;
    } f;
    union {
        uint i;
        struct {
            uint addargs:1 , iscons:1, isdiscard:1, res:5;
        } bits;
    } callflags;
    int refCnt;
    void *privData;                 
    Jsi_CmdSpec *cmdSpec;
    const char *name, *parentName;  
    Jsi_CmdSpec *parentSpec;
    uint retType;  
    int callCnt;
    const char *script, *scriptFile;  
    jsi_Pline bodyline; 
    const char *bodyStr; 
    int endPos, startPos;
    Jsi_HashEntry *hPtr;
    double subTime, allTime;
    Jsi_FuncObj *fobj;
    struct jsi_PkgInfo *pkg;
    bool isArrow;
};

typedef struct {
    char *origFile; 
    char *fileName; 
    char *dirName;  
    const char *str; 
    int useCnt;
} jsi_FileInfo;

enum {
    STACK_INIT_SIZE=1024, STACK_INCR_SIZE=1024, STACK_MIN_PAD=100, JSI_MAX_EVAL_DEPTH=200, JSI_MAX_INCLUDE_DEPTH=50,  JSI_MAX_SUBINTERP_DEPTH=10, JSI_IS_UTF=1, JSI_UTF_CHECKED=2  };






typedef struct InterpStrEvent_ {

    jsi_Sig sig;

    int rc, isExec, tryDepth, errLine;
    const char *errFile;

    Jsi_DString func;
    Jsi_DString data;
    struct InterpStrEvent_ *next;
    void *acdata;
    Jsi_Value *acfunc;
    void *mutex;
} InterpStrEvent;

typedef void (*jsiCallTraceProc)(Jsi_Interp *interp, const char *funcName, const char *file,  int line, Jsi_CmdSpec* spec, Jsi_Value* _this, Jsi_Value* args, Jsi_Value *ret);

typedef struct {
    const char *file;
    const char *func;
    int line;
    int id;
    int hits;
    bool enabled;
    bool temp;
} jsi_BreakPoint;

typedef struct jsi_PkgInfo {
    Jsi_Number version, lastReq;
    const char *loadFile;  
    Jsi_InitProc *initProc; 
    bool needInit;  
    Jsi_Value *info;
    Jsi_PkgOpts popts;
} jsi_PkgInfo;

typedef struct {
    bool isDebugger; 
    bool noFilter;
    bool doContinue;
    bool forceBreak;
    bool bpLast; 
    bool includeOnce;
    bool includeTrace;
    int bpOpCnt;
    int minLevel;
    Jsi_Value *putsCallback;
    Jsi_Value *msgCallback;
    Jsi_Value *traceCallback;
    Jsi_Value *debugCallback;
    Jsi_Value *testFmtCallback;
    int lastLine;
    int lastLevel;
    const char *lastFile;
    bool pkgTrace;
    int breakIdx;
    Jsi_RC (*hook)(struct Jsi_Interp* interp, const char *curFile, int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *msg);
} Jsi_DebugInterp;

typedef union jsi_numUnion {
    bool       BOOL;
    int            INT;
    uint           UINT;
    int8_t         INT8;
    uint8_t        UINT8;
    int16_t        INT16;
    uint16_t       UINT16;
    int32_t        INT32;
    uint32_t       UINT32;
    int64_t        INT64;
    uint64_t       UINT64;
    Jsi_Number     DOUBLE;
    time_t         TIME_T;
    time_w         TIME_W;
    time_d         TIME_D;
} jsi_numUnion;

typedef struct {
    uint parse:1;
    uint run:1;
    uint all:1;     
    uint error:1;
    uint strict:1;
    uint noundef:1;
    uint nowith:1;
    uint funcsig:1;
    uint unused:24;
} Jsi_TypeCheck;

typedef enum {
    jsi_AssertModeThrow, jsi_AssertModeLog, jsi_AssertModePuts } jsi_AssertMode;



typedef struct {
    uint isSpecified:1; 
    uint initOnly:1;    
    uint readOnly:1;    
    uint noDupValue:1;  
    uint noClear:1;     
    uint dbDirty:1;     
    uint dbIgnore:1;    
    uint dbRowid:1 ;    
    uint custNoCase:1;  
    uint forceInt:1;    
    uint bitsetBool:1;  
    uint timeDateOnly:1;
    uint timeTimeOnly:1;
    uint isBits:1;      
    uint fmtString:1;   
    uint fmtNumber:1;   
    uint fmtHext:1;     
    uint strict:1;      
    uint fieldSetup:1;  
    uint coerce:1;      
    uint noSig:1;       
    uint enumSpec:1;    
    uint enumUnsigned:1;
    uint enumExact:1;   
    uint required:1;    
    uint prefix:1;      
    uint isUpdate:1;    
    uint ignoreExtra:1; 
    uint forceStrict:1; 
    uint verbose:1;     
    uint userBits:32;
} jsi_OptionFlags;

typedef struct {
    bool file;    
    bool full;    
    bool ftail;   
    bool func;    
    bool Debug;
    bool Trace;
    bool Test;
    bool Info;
    bool Warn;
    bool Error;
    bool time;    
    bool date;    
    bool before;  
    bool isUTC;
    const char* timeFmt;
    Jsi_Value *chan;
} jsi_LogOptions;

typedef struct {
    bool istty;
    bool noRegex;
    bool noReadline;
    bool noproto;
    bool outUndef;
    bool logAllowDups;
    bool logColNums;
    bool privKeys;
    bool compat;
    bool mutexUnlock;
    bool noFuncString;
    int dblPrec;
    const char *blacklist;
    const char *prompt, *prompt2;
} jsi_SubOptions;

extern Jsi_OptionSpec jsi_InterpLogOptions[];

typedef enum {
        jsi_TL_TRY, jsi_TL_WITH, } jsi_try_op_type;


typedef enum { jsi_LOP_NOOP, jsi_LOP_THROW, jsi_LOP_JMP } jsi_last_try_op_t; 

typedef struct jsi_TryList {
    jsi_try_op_type type;
    union {
        struct {                    
            jsi_OpCode *tstart;         
            jsi_OpCode *tend;           
            jsi_OpCode *cstart;         
            jsi_OpCode *cend;
            jsi_OpCode *fstart;
            jsi_OpCode *fend;
            int tsp;
            jsi_last_try_op_t last_op;              
                                    
            union {
                jsi_OpCode *tojmp;
            } ld;                   
        } td;
        struct {                    
            jsi_OpCode *wstart;         
            jsi_OpCode *wend;           
        } wd;
    } d;
    
    jsi_ScopeChain *scope_save;         
    Jsi_Value *curscope_save;           
    struct jsi_TryList *next;
    bool inCatch;
    bool inFinal;
} jsi_TryList;

typedef enum {
    jsi_safe_None, jsi_safe_Read, jsi_safe_Write, jsi_safe_WriteRead, jsi_safe_Lockdown } jsi_safe_mode;





struct Jsi_Interp {

    jsi_Sig sig;

    bool isSafe, startSafe;
    jsi_safe_mode safeMode;
    int iskips;
    Jsi_Value *safeReadDirs;
    Jsi_Value *safeWriteDirs;
    const char *safeExecPattern;
    Jsi_DebugInterp debugOpts;
    struct jsi_TryList *tryList;
    bool deleting;
    bool destroying;
    uint EventHdlId;
    uint autoLoaded;
    int exited;
    int exitCode;
    int interrupted;
    int refCount;
    int traceCall;
    int traceOp;
    int memDebug;
    int coverAll, coverHit;
    bool coverage;
    bool profile;
    int profileCnt;
    bool asserts;
    bool noNetwork;
    bool noInput;
    jsi_AssertMode assertMode;
    uint unitTest;
    const char *jsppChars;
    Jsi_Value *jsppCallback;
    bool noConfig;
    bool noLoad;
    bool noAutoLoad;
    bool noStderr;
    bool noSubInterps;
    bool tracePuts;
    bool isMain;
    bool hasCallee;
    bool subthread;
    bool strict;
    bool protoInit;
    bool hasOpenSSL;
    bool isHelp;
    bool callerErr;
    bool interactive;
    jsi_SubOptions subOpts;
    bool isInteractive;
    const char *confArgs;
    Jsi_Value *stdinStr;
    Jsi_Value *stdoutStr;
    Jsi_TypeCheck typeCheck;
    jsi_LogOptions logOpts;
    int typeWarnMax;
    int typeMismatchCnt;
    Jsi_InterpOpts opts;
    Jsi_Value *inopts;
    int evalFlags;
    Jsi_InterpDebug dbStatic;
    Jsi_InterpDebug *dbPtr;
    jsiCallTraceProc traceHook;
    int opCnt;  
    int maxOpCnt;
    int maxUserObjs;
    int userObjCnt;
    int funcCnt;
    int level;  
    int maxDepth;
    int callDepth;
    int maxIncDepth;
    int includeDepth;
    int includeCnt;
    int maxInterpDepth;
    int interpDepth;
    int pkgReqDepth;
    int didReturn;
    uint codeCacheHit;
    uint funcCallCnt;
    uint cmdCallCnt;
    uintptr_t eventIdx;

    uint valueDebugIdx;
    Jsi_Hash *codesTbl;

    jsi_ScopeChain *gsc;
    Jsi_Value *csc;
    struct Jsi_Interp *parent, *topInterp, *mainInterp;
    Jsi_Value *onComplete;
    Jsi_Value *onEval;
    Jsi_Value *onExit;
    Jsi_Value *execZip;
    void (*logHook)(char *buf, va_list va);
    const char *name;
    Jsi_Value *pkgDirs;
    bool selfZvfs;
    int inParse;
    Jsi_Value *retValue;       
    jsi_Pstate *ps, *parsePs;
    Jsi_Value *argv0;
    Jsi_Value *args;
    Jsi_Value *console;
    Jsi_Value *scriptFile;  
    const char *scriptStr;
    const char *curFile;
    const char *curFunction;
    const char *homeDir;
    const char *historyFile;
    char *curDir;
    int maxStack;
    double timesStart;

    Jsi_Map *strKeyTbl;  
    Jsi_Map *cmdSpecTbl; 
    Jsi_Hash *onDeleteTbl;  
    Jsi_Hash *assocTbl;
    Jsi_Hash *codeTbl; 
    Jsi_Hash *eventTbl;
    Jsi_Hash *genValueTbl;
    Jsi_Hash *genObjTbl;
    Jsi_Hash *funcObjTbl;
    Jsi_Hash *funcsTbl;
    Jsi_Hash *bindTbl;
    Jsi_Hash *fileTbl;    
    Jsi_Hash *lexkeyTbl;
    Jsi_Hash *protoTbl;
    Jsi_Hash *regexpTbl;    
    Jsi_Hash *thisTbl;
    Jsi_Hash *userdataTbl;
    Jsi_Hash *varTbl;
    Jsi_Hash *preserveTbl;
    Jsi_Hash *loadTbl;
    Jsi_Hash *staticFuncsTbl; 
    Jsi_Hash *breakpointHash;
    Jsi_Hash *packageHash;
    Jsi_Hash *aliasHash;
    Jsi_Hash* vfsMountHash;
    Jsi_Hash* vfsDefHash;

    Jsi_Value **Stack;
    Jsi_Value **Obj_this;

    Jsi_Value *Stack;
    Jsi_Value *Obj_this;

            
    Jsi_Value *Object_prototype;
    Jsi_Value *Function_prototype_prototype;
    Jsi_Value *Function_prototype;
    Jsi_Value *String_prototype;
    Jsi_Value *Number_prototype;
    Jsi_Value *Boolean_prototype;
    Jsi_Value *Array_prototype;
    Jsi_Value *RegExp_prototype;
    Jsi_Value *Date_prototype;
    
    Jsi_Value *NaNValue;
    Jsi_Value *InfValue;
    Jsi_Value *NullValue;
    Jsi_Value *nullFuncArg; 
    Jsi_Value *nullFuncRet;
    Jsi_Value *autoFiles;
    Jsi_Obj* cleanObjs[4];
    Jsi_Obj* allObjs;
    Jsi_Value* allValues, *udata;

    Jsi_Value *busyCallback;
    const char *confFile;
    int busyInterval;
    int isInCallback;
    int cleanup;
    int objId;
    Jsi_Value *Top_object;
    Jsi_ScopeStrs *scopes[JSI_MAX_SCOPE];
    int cur_scope;
    int maxArrayList;
    int delRBCnt;
    Jsi_Func *activeFunc;  
    Jsi_Func *prevActiveFunc;  
    jsi_OpCode *curIp;  
    
    char *lastPushStr;  
    Jsi_Value* lastParseOpt;
    Jsi_Value* lastSubscriptFail;
    const char* lastSubscriptFailStr;
    int logErrorCnt;
    Jsi_OptionSpec *parseMsgSpec;


    Jsi_Wide sigmask;
    char errMsgBuf[JSI_BUFSIZ];  
    int errLine;
    int errCol;
    const char *errFile;
    Jsi_Mutex* Mutex;
    Jsi_Mutex* QMutex; 
    void* threadId;
    int threadCnt;
    int threadShrCnt;
    int lockTimeout; 
    uint lockRefCnt;
    int psEpoch;
    int mountCnt;
    Jsi_DString interpEvalQ;
    InterpStrEvent *interpStrEvents;

    bool typeInit;
    Jsi_Number cdataIncrVal;
    Jsi_CData_Static *statics;
    Jsi_VarSpec *cdataNewVal;
    Jsi_Hash *StructHash;
    Jsi_Hash *SigHash;
    Jsi_Hash *EnumHash;
    Jsi_Hash *EnumItemHash;
    Jsi_Hash *CTypeHash;
    Jsi_Hash *TYPEHash;

    uint threadErrCnt;  
    uint threadEvalCnt;
    uint threadMsgCnt;
    void *sleepData;
    jsi_PkgInfo *pkgRequiring, *pkgProviding;
    jsi_Pline *parseLine;
    jsi_Frame *framePtr;
    struct jsi_DbVfs **dbVfsPtrPtr;
    double subTime, startTime, funcSelfTime, cmdSelfTime;
};


enum { JSI_REG_GLOB=0x1, JSI_REG_NEWLINE=0x2, JSI_REG_DOT_NEWLINE=0x4, JSI_REG_STATIC=0x100 };

struct Jsi_Regex_ {

    jsi_Sig sig;

    regex_t reg;
    int eflags;
    int flags;
    char *pattern;
    int lastIndex;
};



typedef struct Jsi_CmdSpecItem_ {

    jsi_Sig sig;

    const char *name;  
    Jsi_CmdSpec *spec;
    Jsi_Value *proto;
    int flags;
    void *privData;
    Jsi_MapEntry *hPtr;
    struct Jsi_CmdSpecItem_ *next; 
    const char *help;
    const char *info;
    int isCons;
} Jsi_CmdSpecItem;


extern const char* jsi_OptionTypeStr(Jsi_OptionId typ, bool cname);
extern const Jsi_OptionTypedef* Jsi_OptionsStr2Type(const char *str, bool cname);




extern jsi_ScopeChain* jsi_ScopeChainNew(Jsi_Interp *interp, int cnt); 
extern Jsi_Value* jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key); 
extern jsi_ScopeChain* jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next); 
extern void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc); 

extern void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr);

Jsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitLexer(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitLoad(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitCmds(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitInterp(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitFileCmds(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitString(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitValue(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitNumber(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitArray(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitBoolean(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitMath(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitProto(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitJSON(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release);
Jsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitTree(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitSocket(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitSignal(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitOptions(Jsi_Interp *interp, int release);
Jsi_RC Jsi_InitZvfs(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitCData(Jsi_Interp *interp, int release);
Jsi_RC jsi_InitVfs(Jsi_Interp *interp, int release);
Jsi_RC jsi_execCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr, Jsi_DString *cStr, int *code);

void jsi_SignalClear(Jsi_Interp *interp, int sigNum);
bool jsi_SignalIsSet(Jsi_Interp *interp, int sigNum);

extern Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes,  jsi_ScopeChain *scope, Jsi_Value *currentScope, Jsi_Value *_this, Jsi_Value **vret);


        
typedef Jsi_RC (*Jsi_Constructor)(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, int flags, void *privData);
extern Jsi_RC jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc);
extern void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall);
extern Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
    
enum {StrKeyAny = 0, StrKeyFunc = 0x1, StrKeyCmd = 0x2, StrKeyVar = 0x2};


extern char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey);
extern void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who);
extern Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp);
extern void jsi_AddEventHandler(Jsi_Interp *interp);
extern Jsi_RC jsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string , void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe);
extern Jsi_RC jsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags);
extern const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp);
extern const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val);
extern const char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp);
extern Jsi_RC jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len);

extern const char *jsi_GetHomeDir(Jsi_Interp *interp);
extern Jsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret);
extern void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec);
extern Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline *line, const char *name, int isArrow);
extern Jsi_Func *jsi_FuncNew(Jsi_Interp *interp);
extern void jsi_FreeOpcodes(Jsi_OpCodes *ops);
extern void jsi_DelAssocData(Jsi_Interp *interp, void *data);

extern void jsi_UserObjFree (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern bool jsi_UserObjIsTrue (Jsi_Interp *interp, Jsi_UserObj *uobj);
extern Jsi_RC jsi_UserObjDump   (Jsi_Interp *interp, const char *argStr, Jsi_Obj *obj);
extern Jsi_RC jsi_UserObjDelete (Jsi_Interp *interp, void *data);
extern void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr);
extern Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name);

extern Jsi_RC Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret);
extern Jsi_Value* jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex);
extern void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey);
extern void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);
extern Jsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret);
extern Jsi_Value* jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value *value, int flag);
extern void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof);
extern Jsi_Value* jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key);
extern Jsi_Value* jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name);
extern Jsi_Value* jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent);
extern Jsi_Value* jsi_ObjValueNew(Jsi_Interp *interp);
extern Jsi_Value* Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v);
extern int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v);
extern Jsi_RC jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *handle);
extern Jsi_Value* jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec);
extern Jsi_Value* jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData);
extern bool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr);
extern bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent);
extern Jsi_RC jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int islstat);
extern Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args,  Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args,  Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr);
extern Jsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);
extern Jsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, const char *str, int flags, int level);
extern Jsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags);
extern Jsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret);
extern Jsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted);

extern Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func);
extern void jsi_FuncObjFree(Jsi_FuncObj *fobj);
extern Jsi_RC jsi_ArglistFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);
extern void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func);
extern void jsi_ToHexStr(const uchar *indata, int dlen, char *out);
extern bool jsi_StrIsBalanced(char *str);












extern char* jsi_SubstrDup(const char *a, int alen, int start, int len, int *olen);
extern int jsi_typeGet(Jsi_Interp *interp , const char *tname);
extern const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr);
extern Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ, Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func, bool isdefault);
extern void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes);
extern Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse);
extern Jsi_RC jsi_FunctionSubCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Value *tocall, int discard);
extern Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a);
extern Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr, bool prepend);
extern Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr);
extern Jsi_Value* jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode);
extern double jsi_GetTimestamp(void);
extern const char *jsi_GetCurFile(Jsi_Interp *interp);
extern void jsi_TypeMismatch(Jsi_Interp* interp);
extern void jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep);
extern const char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str);
extern Jsi_Value* jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec);
extern int jsi_GetDefaultType(const char *cp);
extern Jsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str);
extern Jsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc);
extern Jsi_RC jsi_CDataDataSetCmdSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int flags);
extern Jsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);
extern Jsi_Number jsi_VersionNormalize(Jsi_Number ver, char *obuf, size_t osiz);
extern const char* jsi_FuncGetCode(Jsi_Interp *interp, Jsi_Func *func, int *lenPtr);
extern Jsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret, int *ofs, bool match);
extern int jsi_AllObjOp(Jsi_Interp *interp, Jsi_Obj* obj, int op);

extern Jsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret); 
extern void jsi_SysPutsCmdPrefix(Jsi_Interp *interp, jsi_LogOptions *popts,Jsi_DString *dStr, int* quote, const char **fnPtr);

extern char jsi_toHexChar(char code);
extern char jsi_fromHexChar(char ch);
extern bool Jsi_StrIsAlnum(const char *cp);
extern char *jsi_TrimStr(char *str);
extern bool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod);
extern bool jsi_FuncIsNoop(Jsi_Interp* interp, Jsi_Value *func);

typedef enum {
    _JSI_CDATA_INFO=0, _JSI_CDATA_GET=1, _JSI_CDATA_SET=2, _JSI_CDATA_SIZE=3, _JSI_CDATA_SCHEMA=4, _JSI_CDATA_STRUCT=6 } jsi_cdatasub;










                 











extern Jsi_Value *jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern Jsi_Value *jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func);
extern Jsi_Obj *jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func);
extern void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2);
extern void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func);
extern void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp);
extern void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp);















void jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *func, jsi_OpCode *iPtr,  Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret, int tc);









struct Jsi_Stubs;
extern struct Jsi_Stubs *jsiStubsTblPtr;
extern const char *jsi_AssertModeStrs[];
extern const char *jsi_callTraceStrs[];
extern Jsi_CmdSpec cDataArrayCmds[];


typedef struct {
    Jsi_Interp *mainInterp;
    Jsi_Interp *delInterp;
    Jsi_Hash *interpsTbl;
    bool isInit;
    char *execName;
    Jsi_Value *execValue;
    Jsi_Chan stdChans[3];
    Jsi_Filesystem *cwdFsPtr;
    Jsi_DString pwdStr;
    char *pwd;
    int tolowerZvfs;
    struct {
        Jsi_Hash* fileHash;
        Jsi_Hash *archiveHash;
        int isInit;
        Jsi_Interp *interp;
    } zvfslocal;
} jsi_IntData;

extern jsi_IntData jsiIntData;









