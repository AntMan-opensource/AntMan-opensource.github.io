











QT_BEGIN_NAMESPACE  static bool is_valid_domain_name(const QString &host)

{
    if (!host.size())
        return false;

    
    
    
    
    
    using namespace QIPAddressUtils;

    IPv4Address ipv4Addr = {};
    if (parseIp4(ipv4Addr, host.constBegin(), host.constEnd()))
        return false;

    IPv6Address ipv6Addr = {};
    
    
    if (!parseIp6(ipv6Addr, host.constBegin(), host.constEnd()))
        return false;

    
    
    
    return true;
}

void QHstsCache::updateFromHeaders(const QList<QPair<QByteArray, QByteArray>> &headers, const QUrl &url)
{
    if (!url.isValid())
        return;

    QHstsHeaderParser parser;
    if (parser.parse(headers)) {
        updateKnownHost(url.host(), parser.expirationDate(), parser.includeSubDomains());

        if (hstsStore)
            hstsStore->synchronize();

    }
}

void QHstsCache::updateFromPolicies(const QList<QHstsPolicy> &policies)
{
    for (const auto &policy : policies)
        updateKnownHost(policy.host(), policy.expiry(), policy.includesSubDomains());


    if (hstsStore && policies.size()) {
        
        
        
        hstsStore->synchronize();
    }

}

void QHstsCache::updateKnownHost(const QUrl &url, const QDateTime &expires, bool includeSubDomains)
{
    if (!url.isValid())
        return;

    updateKnownHost(url.host(), expires, includeSubDomains);

    if (hstsStore)
        hstsStore->synchronize();

}

void QHstsCache::updateKnownHost(const QString &host, const QDateTime &expires, bool includeSubDomains)
{
    if (!is_valid_domain_name(host))
        return;

    
    
    
    const HostName hostName(host);
    const auto pos = knownHosts.find(hostName);
    QHstsPolicy::PolicyFlags flags;
    if (includeSubDomains)
        flags = QHstsPolicy::IncludeSubDomains;

    const QHstsPolicy newPolicy(expires, flags, hostName.name);
    if (pos == knownHosts.end()) {
        
        if (newPolicy.isExpired()) {
            
            
            return;
        }

        knownHosts.insert({hostName, newPolicy});

        if (hstsStore)
            hstsStore->addToObserved(newPolicy);

        return;
    }

    if (newPolicy.isExpired())
        knownHosts.erase(pos);
    else  if (pos->second != newPolicy)
        pos->second = newPolicy;
    else return;


    if (hstsStore)
        hstsStore->addToObserved(newPolicy);

}

bool QHstsCache::isKnownHost(const QUrl &url) const {
    if (!url.isValid() || !is_valid_domain_name(url.host()))
        return false;

    

    bool superDomainMatch = false;
    const QString hostNameAsString(url.host());
    HostName nameToTest(QStringView{hostNameAsString});
    while (nameToTest.fragment.size()) {
        auto const pos = knownHosts.find(nameToTest);
        if (pos != knownHosts.end()) {
            if (pos->second.isExpired()) {
                knownHosts.erase(pos);

                if (hstsStore) {
                    
                    hstsStore->addToObserved(pos->second);
                }

            } else if (!superDomainMatch || pos->second.includesSubDomains()) {
                return true;
            }
        }

        const qsizetype dot = nameToTest.fragment.indexOf(u'.');
        if (dot == -1)
            break;

        nameToTest.fragment = nameToTest.fragment.mid(dot + 1);
        superDomainMatch = true;
    }

    return false;
}

void QHstsCache::clear()
{
    knownHosts.clear();
}

QList<QHstsPolicy> QHstsCache::policies() const {
    QList<QHstsPolicy> values;
    values.reserve(int(knownHosts.size()));
    for (const auto &host : knownHosts)
        values << host.second;
    return values;
}


void QHstsCache::setStore(QHstsStore *store)
{
    
    if (store != hstsStore) {
        hstsStore = store;

        if (!hstsStore)
            return;

        
        
        
        if (knownHosts.size()) {
            const QList<QHstsPolicy> observed(policies());
            for (const auto &policy : observed)
                hstsStore->addToObserved(policy);
            hstsStore->synchronize();
        }

        
        
        
        
        const QList<QHstsPolicy> restored(store->readPolicies());
        updateFromPolicies(restored);
    }
}












static bool isCHAR(int c)
{
    
    return c >= 0 && c <= 127;
}

static bool isCTL(int c)
{
    
    
    return (c >= 0 && c <= 31) || c == 127;
}


static bool isLWS(int c)
{
    
    
    
    
    
    
    
    
    
    
    return c == ' '  || c == '\t';
}

static bool isTEXT(char c)
{
    
    
    return !isCTL(c) || isLWS(c);
}

static bool isSeparator(char c)
{
    
    
    
    
    static const char separators[] = "()<>@,;:\\\"/[]?={}";
    static const char *end = separators + sizeof separators - 1;
    return isLWS(c) || std::find(separators, end, c) != end;
}

static QByteArray unescapeMaxAge(const QByteArray &value)
{
    if (value.size() < 2 || value[0] != '"')
        return value;

    Q_ASSERT(value[value.size() - 1] == '"');
    return value.mid(1, value.size() - 2);
}

static bool isTOKEN(char c)
{
    
    return isCHAR(c) && !isCTL(c) && !isSeparator(c);
}



bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)
{
    for (const auto &h : headers) {
        
        if (h.first == "Strict-Transport-Security") {
            header = h.second;
            
            
            
            
            
            
            
            
            
            
            
            if (parseSTSHeader() && maxAgeFound) {
                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);
                return true;
            }
        }
    }

    
    
    subDomainsFound = false;

    return false;
}

bool QHstsHeaderParser::parseSTSHeader()
{
    expiry = QDateTime();
    maxAgeFound = false;
    subDomainsFound = false;
    maxAge = 0;
    tokenPos = 0;
    token.clear();

    while (tokenPos < header.size()) {
        if (!parseDirective())
            return false;

        if (token.size() && token != ";") {
            
            
            return false;
        }
    }

    return true;
}

bool QHstsHeaderParser::parseDirective()
{
    
    
    
    
    


    
    
    

    if (!nextToken())
        return false;

    if (!token.size()) 
        return true;

    if (token == ";") 
        return true;

    if (!isTOKEN(token[0])) 
        return false;

    const QByteArray directiveName = token;
    
    if (!nextToken())
        return false;

    QByteArray directiveValue;
    if (token == ";") 
        return processDirective(directiveName, directiveValue);

    if (token == "=") {
        
        if (!nextToken() || !token.size())
            return false;
        directiveValue = token;
    } else if (token.size()) {
        
        return false;
    }

    if (!processDirective(directiveName, directiveValue))
        return false;

    
    return nextToken();
}

bool QHstsHeaderParser::processDirective(const QByteArray &name, const QByteArray &value)
{
    Q_ASSERT(name.size());
    
    if (name.compare("max-age", Qt::CaseInsensitive) == 0) {
        
        
        
        
        
        if (maxAgeFound) {
            
            
            return false;
        }

        const QByteArray unescapedValue = unescapeMaxAge(value);
        if (!unescapedValue.size())
            return false;

        bool ok = false;
        const qint64 age = unescapedValue.toLongLong(&ok);
        if (!ok || age < 0)
            return false;

        maxAge = age;
        maxAgeFound = true;
    } else if (name.compare("includesubdomains", Qt::CaseInsensitive) == 0) {
        
        

        if (subDomainsFound) {
            
            
            return false;
        }

        subDomainsFound = true;
    } 

    return true;
}

bool QHstsHeaderParser::nextToken()
{
    
    

    token.clear();

    
    
    while (tokenPos < header.size() && isLWS(header[tokenPos]))
        ++tokenPos;

    if (tokenPos == header.size())
        return true;

    const char ch = header[tokenPos];
    if (ch == ';' || ch == '=') {
        token.append(ch);
        ++tokenPos;
        return true;
    }

    
    
    
    
    if (ch == '"') {
        int last = tokenPos + 1;
        while (last < header.size()) {
            if (header[last] == '"') {
                
                break;
            } else if (header[last] == '\\') {
                
                if (last + 1 < header.size() && isCHAR(header[last + 1]))
                    last += 2;
                else return false;
            } else {
                if (!isTEXT(header[last]))
                    return false;
                ++last;
            }
        }

        if (last >= header.size()) 
            return false;

        token = header.mid(tokenPos, last - tokenPos + 1);
        tokenPos = last + 1;
        return true;
    }

    
    
    
    if (!isTOKEN(ch))
        return false;

    int last = tokenPos + 1;
    while (last < header.size() && isTOKEN(header[last]))
        ++last;

    token = header.mid(tokenPos, last - tokenPos);
    tokenPos = last;

    return true;
}

QT_END_NAMESPACE