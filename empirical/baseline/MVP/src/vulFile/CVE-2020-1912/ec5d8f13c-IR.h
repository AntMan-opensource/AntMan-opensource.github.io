





























namespace hermes {

class Module;
class VariableScope;
class Function;
class BasicBlock;
class Parameter;
class Instruction;
class Context;
class TerminatorInst;


class Type {
  
  
  enum TypeKind {
    Undefined, Null, Boolean, String, Number, Object, Closure, RegExp,  LAST_TYPE };










  
  StringRef getKindStr(TypeKind idx) const {
    
    const char *Names[] = {"undefined", "null", "boolean", "string", "number", "object", "closure", "regexp";






    return Names[idx];
  }




  
  static constexpr uint8_t TYPE_ANY_MASK = (1u << TypeKind::LAST_TYPE) - 1;

  static constexpr uint8_t PRIMITIVE_BITS = BIT_TO_VAL(Number) | BIT_TO_VAL(String) | BIT_TO_VAL(Null) | BIT_TO_VAL(Undefined) | BIT_TO_VAL(Boolean);


  static constexpr uint8_t OBJECT_BITS = BIT_TO_VAL(Object) | BIT_TO_VAL(Closure) | BIT_TO_VAL(RegExp);

  static constexpr uint8_t NONPTR_BITS = BIT_TO_VAL(Number) | BIT_TO_VAL(Boolean) | BIT_TO_VAL(Null) | BIT_TO_VAL(Undefined);

  
  
  uint8_t bitmask_{TYPE_ANY_MASK};

  
  constexpr explicit Type(uint8_t mask) : bitmask_(mask) {}

 public:
  constexpr Type() = default;

  static constexpr Type unionTy(Type A, Type B) {
    return Type(A.bitmask_ | B.bitmask_);
  }

  static constexpr Type intersectTy(Type A, Type B) {
    return Type(A.bitmask_ & B.bitmask_);
  }

  constexpr bool isEmptyTy() const {
    return bitmask_ == 0;
  }

  static constexpr Type createEmptyType() {
    return Type(0);
  }
  static constexpr Type createAnyType() {
    return Type(TYPE_ANY_MASK);
  }
  static constexpr Type createUndefined() {
    return Type(BIT_TO_VAL(Undefined));
  }
  static constexpr Type createNull() {
    return Type(BIT_TO_VAL(Null));
  }
  static constexpr Type createBoolean() {
    return Type(BIT_TO_VAL(Boolean));
  }
  static constexpr Type createString() {
    return Type(BIT_TO_VAL(String));
  }
  static constexpr Type createObject() {
    return Type(BIT_TO_VAL(Object));
  }
  static constexpr Type createNumber() {
    return Type(BIT_TO_VAL(Number));
  }
  static constexpr Type createClosure() {
    return Type(BIT_TO_VAL(Closure));
  }
  static constexpr Type createRegExp() {
    return Type(BIT_TO_VAL(RegExp));
  }

  constexpr bool isAnyType() const {
    return bitmask_ == TYPE_ANY_MASK;
  }

  constexpr bool isUndefinedType() const {
    return IS_VAL(Undefined);
  }
  constexpr bool isNullType() const {
    return IS_VAL(Null);
  }
  constexpr bool isBooleanType() const {
    return IS_VAL(Boolean);
  }
  constexpr bool isStringType() const {
    return IS_VAL(String);
  }

  bool isObjectType() const {
    
    return bitmask_ && !(bitmask_ & ~OBJECT_BITS);
  }

  constexpr bool isNumberType() const {
    return IS_VAL(Number);
  }
  constexpr bool isClosureType() const {
    return IS_VAL(Closure);
  }
  constexpr bool isRegExpType() const {
    return IS_VAL(RegExp);
  }

  
  
  constexpr bool isKnownPrimitiveType() const {
    return isPrimitive() && 1 == llvh::countPopulation(bitmask_);
  }

  constexpr bool isPrimitive() const {
    
    return bitmask_ && !(bitmask_ & ~PRIMITIVE_BITS);
  }

  
  constexpr bool isNonPtr() const {
    
    return bitmask_ && !(bitmask_ & ~NONPTR_BITS);
  }



  
  constexpr bool isSubsetOf(Type t) const {
    return !(bitmask_ & ~t.bitmask_);
  }

  
  
  
  constexpr bool canBeType(Type t) const {
    return t.isSubsetOf(*this);
  }

  
  constexpr bool canBeString() const {
    return canBeType(Type::createString());
  }

  
  constexpr bool canBeNumber() const {
    return canBeType(Type::createNumber());
  }

  
  constexpr bool canBeObject() const {
    return canBeType(Type::createObject());
  }

  
  constexpr bool canBeObjectSubtype() const {
    return bitmask_ & OBJECT_BITS;
  }

  
  constexpr bool canBeBoolean() const {
    return canBeType(Type::createBoolean());
  }

  
  constexpr bool canBeUndefined() const {
    return canBeType(Type::createUndefined());
  }

  
  constexpr bool canBeNull() const {
    return canBeType(Type::createNull());
  }

  
  constexpr bool canBeClosure() const {
    return canBeType(Type::createClosure());
  }

  
  constexpr bool canBeRegex() const {
    return canBeType(Type::createRegExp());
  }

  
  
  constexpr bool isProperSubsetOf(Type t) const {
    return bitmask_ != t.bitmask_ && !(bitmask_ & ~t.bitmask_);
  }

  void print(llvh::raw_ostream &OS) const;

  
  llvh::hash_code hash() const {
    return llvh::hash_value(bitmask_);
  }

  constexpr bool operator==(Type RHS) const {
    return bitmask_ == RHS.bitmask_;
  }
  constexpr bool operator!=(Type RHS) const {
    return !(*this == RHS);
  }
};





enum class SideEffectKind {
  
  None,  MayRead,  MayWrite,   Unknown, };








enum class ValueKind : uint8_t {







};


static inline bool kindIsA(ValueKind kind, ValueKind base) {
  switch (base) {
    default:
      return kind == base;






  }
}




class SerializedScope {
 public:
  
  std::shared_ptr<const SerializedScope> parentScope;
  
  Identifier originalName;
  
  
  
  
  
  Identifier closureAlias;
  
  llvh::SmallVector<Identifier, 16> variables;
};



struct LazySource {
  
  ESTree::NodeKind nodeKind{ESTree::NodeKind::Empty};
  
  uint32_t bufferId{0};
  
  
  SMRange functionRange;
};


class Value {
 public:
  using UseListTy = llvh::SmallVector<Instruction *, 2>;
  using Use = std::pair<Value *, unsigned>;

 private:
  
  
  
  
  
  
  
  friend class Module;
  friend class IRBuilder;

  ValueKind Kind;

  
  Type valueType;

  
  UseListTy Users;

  
  
  

  

  void operator delete(void *p, size_t s) {
    ::operator delete(p, s);
  }

  void operator delete(void *p) {
    ::operator delete(p);
  }


 protected:
  explicit Value(ValueKind k) {
    Kind = k;
  }

 public:
  Value(const Value &) = delete;
  void operator=(const Value &) = delete;

  
  static void destroy(Value *V);

  
  const UseListTy &getUsers() const;

  
  unsigned getNumUsers() const;

  
  bool hasUsers() const;

  
  bool hasOneUser() const;

  
  void removeUse(Use U);

  
  
  Value::Use addUser(Instruction *Inst);

  
  void replaceAllUsesWith(Value *Other);

  
  void removeAllUses();

  
  bool hasUser(Value *other);

  
  ValueKind getKind() const {
    return Kind;
  }

  
  StringRef getKindStr() const;

  
  void setType(Type type) {
    valueType = type;
  }

  
  Type getType() const {
    return valueType;
  }

  static bool classof(const Value *) {
    return true;
  }

  using iterator = UseListTy::iterator;
  using const_iterator = UseListTy::const_iterator;

  inline const_iterator users_begin() const {
    return Users.begin();
  }
  inline const_iterator users_end() const {
    return Users.end();
  }
  inline iterator users_begin() {
    return Users.begin();
  }
  inline iterator users_end() {
    return Users.end();
  }
};


class Parameter : public Value {
  Parameter(const Parameter &) = delete;
  void operator=(const Parameter &) = delete;

  
  Function *Parent;

  
  Identifier Name;

 public:
  explicit Parameter(Function *parent, Identifier name);

  void removeFromParent();

  Context &getContext() const;
  Function *getParent() const {
    return Parent;
  }
  void setParent(Function *parent) {
    Parent = parent;
  }

  
  Identifier getName() const;

  
  bool isThisParameter() const;

  
  
  int getIndexInParamList() const;

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::ParameterKind;
  }
};


class EmptySentinel : public Value {
  EmptySentinel(const EmptySentinel &) = delete;
  void operator=(const EmptySentinel &) = delete;

 public:
  explicit EmptySentinel() : Value(ValueKind::EmptySentinelKind) {}

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::EmptySentinelKind;
  }
};


class Label : public Value {
  Label(const Label &) = delete;
  void operator=(const Label &) = delete;

  
  
  

  void *operator new(size_t) {
    llvm_unreachable("Labels cannot be allocated separately");
  }

  
  Identifier text;

 public:
  explicit Label(Identifier txt) : Value(ValueKind::LabelKind), text(txt) {}

  Identifier get() const {
    return text;
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LabelKind;
  }
};

class Literal : public Value {
  Literal(const Literal &) = delete;
  void operator=(const Literal &) = delete;

 public:
  explicit Literal(ValueKind k) : Value(k) {}

  static bool classof(const Value *V) {
    return kindIsA(V->getKind(), ValueKind::LiteralKind);
  }
};

class LiteralNull : public Literal {
  LiteralNull(const LiteralNull &) = delete;
  void operator=(const LiteralNull &) = delete;

 public:
  explicit LiteralNull() : Literal(ValueKind::LiteralNullKind) {
    setType(Type::createNull());
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LiteralNullKind;
  }
};

class LiteralUndefined : public Literal {
  LiteralUndefined(const LiteralUndefined &) = delete;
  void operator=(const LiteralUndefined &) = delete;

 public:
  explicit LiteralUndefined() : Literal(ValueKind::LiteralUndefinedKind) {
    setType(Type::createUndefined());
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LiteralUndefinedKind;
  }
};

class LiteralNumber : public Literal, public llvh::FoldingSetNode {
  LiteralNumber(const LiteralNumber &) = delete;
  void operator=(const LiteralNumber &) = delete;
  double value;

 public:
  double getValue() const {
    return value;
  }

  
  
  
  template <typename T> llvh::Optional<T> isIntTypeRepresentible() const {
    
    
    
    if (value > std::numeric_limits<T>::max() || value < std::numeric_limits<T>::min()) {
      return llvh::None;
    }
    if (std::isnan(value)) {
      return llvh::None;
    }
    
    T valAsInt = static_cast<T>(value);
    if (valAsInt == value && (valAsInt || !std::signbit(value))) {
      return valAsInt;
    }
    return llvh::None;
  }

  
  bool isPositiveZero() const {
    return value == 0.0 && !std::signbit(value);
  }

  
  
  bool isUInt8Representible() const {
    return isIntTypeRepresentible<uint8_t>().hasValue();
  }

  
  
  bool isInt32Representible() const {
    return isIntTypeRepresentible<int32_t>().hasValue();
  }

  
  
  bool isUInt32Representible() const {
    return isIntTypeRepresentible<uint32_t>().hasValue();
  }

  
  
  uint32_t asUInt8() const {
    auto tmp = isIntTypeRepresentible<uint8_t>();
    assert(tmp && "Cannot convert to uint8_t");
    return tmp.getValue();
  }

  
  
  int32_t asInt32() const {
    auto tmp = isIntTypeRepresentible<int32_t>();
    assert(tmp && "Cannot convert to int32_t");
    return tmp.getValue();
  }

  
  
  uint32_t asUInt32() const {
    auto tmp = isIntTypeRepresentible<uint32_t>();
    assert(tmp && "Cannot convert to uint32_t");
    return tmp.getValue();
  }

  
  
  
  int32_t truncateToInt32() const {
    return hermes::truncateToInt32(value);
  }

  uint32_t truncateToUInt32() const {
    return hermes::truncateToUInt32(value);
  }

  
  OptValue<uint32_t> convertToArrayIndex() const {
    return doubleToArrayIndex(value);
  }

  explicit LiteralNumber(double val)
      : Literal(ValueKind::LiteralNumberKind), value(val) {
    setType(Type::createNumber());
  }

  static void Profile(llvh::FoldingSetNodeID &ID, double value) {
    ID.AddInteger(safeTypeCast<double, int64_t>(value));
  }

  void Profile(llvh::FoldingSetNodeID &ID) const {
    LiteralNumber::Profile(ID, value);
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LiteralNumberKind;
  }
};

class LiteralString : public Literal, public llvh::FoldingSetNode {
  LiteralString(const LiteralString &) = delete;
  void operator=(const LiteralString &) = delete;
  Identifier value;

 public:
  Identifier getValue() const {
    return value;
  }

  explicit LiteralString(Identifier val)
      : Literal(ValueKind::LiteralStringKind), value(val) {
    setType(Type::createString());
  }

  static void Profile(llvh::FoldingSetNodeID &ID, Identifier value) {
    ID.AddPointer(value.getUnderlyingPointer());
  }

  void Profile(llvh::FoldingSetNodeID &ID) const {
    LiteralString::Profile(ID, value);
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LiteralStringKind;
  }
};

class LiteralBool : public Literal {
  LiteralBool(const LiteralBool &) = delete;
  void operator=(const LiteralBool &) = delete;
  bool value;

 public:
  bool getValue() const {
    return value;
  }

  explicit LiteralBool(bool val)
      : Literal(ValueKind::LiteralBoolKind), value(val) {
    setType(Type::createBoolean());
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::LiteralBoolKind;
  }
};



class GlobalObject : public Literal {
  GlobalObject(const GlobalObject &) = delete;
  void operator=(const GlobalObject &) = delete;

 public:
  explicit GlobalObject() : Literal(ValueKind::GlobalObjectKind) {
    setType(Type::createObject());
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::GlobalObjectKind;
  }
};


class Variable : public Value {
 public:
  enum class DeclKind {
    Var, Let, Const, };



  
  static bool declKindNeedsTDZ(DeclKind dk) {
    return dk != DeclKind::Var;
  }

 private:
  Variable(const Variable &) = delete;
  void operator=(const Variable &) = delete;

  
  DeclKind declKind;

  
  Identifier text;

  
  VariableScope *parent;

  
  
  
  Variable *relatedVariable_{};

 protected:
  explicit Variable( ValueKind k, VariableScope *scope, DeclKind declKind, Identifier txt);




 public:
  explicit Variable(VariableScope *scope, DeclKind declKind, Identifier txt)
      : Variable(ValueKind::VariableKind, scope, declKind, txt){};

  ~Variable();

  DeclKind getDeclKind() const {
    return declKind;
  }

  Identifier getName() const {
    return text;
  }
  VariableScope *getParent() const {
    return parent;
  }

  Variable *getRelatedVariable() const {
    return relatedVariable_;
  }
  void setRelatedVariable(Variable *relatedVariable) {
    assert( (!relatedVariable || !relatedVariable->relatedVariable_ || relatedVariable->relatedVariable_ == this) && "Related variable should be null or point back to us");


    relatedVariable_ = relatedVariable;
  }

  
  int getIndexInVariableList() const;

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::VariableKind;
  }
};


class GlobalObjectProperty : public Value {
  
  Module *parent_;

  
  LiteralString *name_;

  
  bool declared_;

 public:
  GlobalObjectProperty(Module *parent, LiteralString *name, bool declared)
      : Value(ValueKind::GlobalObjectPropertyKind), parent_(parent), name_(name), declared_(declared) {}



  static bool classof(const Value *v) {
    return v->getKind() == ValueKind::GlobalObjectPropertyKind;
  }

  Module *getParent() const {
    return parent_;
  }

  LiteralString *getName() const {
    return name_;
  }

  bool isDeclared() const {
    return declared_;
  }

  void orDeclared(bool declared) {
    declared_ |= declared;
  }
};


class Instruction : public llvh::ilist_node_with_parent<Instruction, BasicBlock>, public Value {

  friend class Value;
  Instruction(const Instruction &) = delete;
  void operator=(const Instruction &) = delete;

  
  BasicBlock *Parent;
  
  llvh::SmallVector<Value::Use, 2> Operands;

  SMLoc location_{};
  
  
  uint32_t statementIndex_{0};

  
  SideEffectKind getDerivedSideEffect();

 protected:
  explicit Instruction(ValueKind kind) : Value(kind), Parent(nullptr) {}

  
  
  
  
  
  
  explicit Instruction( const Instruction *src, llvh::ArrayRef<Value *> operands);


  
  void pushOperand(Value *Val);

 public:
  void setOperand(Value *Val, unsigned Index);
  Value *getOperand(unsigned Index) const;
  unsigned getNumOperands() const;
  void removeOperand(unsigned index);

  
  
  WordBitSet<> getChangedOperands();

  void setLocation(SMLoc loc) {
    location_ = loc;
  }
  SMLoc getLocation() const {
    return location_;
  }
  bool hasLocation() const {
    return location_.isValid();
  }

  
  
  void setStatementIndex(uint32_t statementIndex) {
    statementIndex_ = statementIndex;
  }

  uint32_t getStatementIndex() const {
    return statementIndex_;
  }

  
  
  void dump(llvh::raw_ostream &os = llvh::outs());

  
  
  
  void replaceFirstOperandWith(Value *OldValue, Value *NewValue);

  
  void eraseOperand(Value *Value);

  void insertBefore(Instruction *InsertPos);
  void insertAfter(Instruction *InsertPos);
  void moveBefore(Instruction *Later);
  void removeFromParent();
  void eraseFromParent();

  
  StringRef getName();

  
  bool hasSideEffect() {
    return getDerivedSideEffect() != SideEffectKind::None;
  }

  
  bool mayReadMemory() {
    return getDerivedSideEffect() >= SideEffectKind::MayRead;
  }
  
  bool mayWriteMemory() {
    return getDerivedSideEffect() >= SideEffectKind::MayWrite;
  }
  
  
  bool mayExecute() {
    return getDerivedSideEffect() > SideEffectKind::MayWrite;
  }

  Context &getContext() const;
  BasicBlock *getParent() const {
    return Parent;
  }
  void setParent(BasicBlock *parent) {
    Parent = parent;
  }

  static bool classof(const Value *V) {
    return kindIsA(V->getKind(), ValueKind::InstructionKind);
  }

  
  
  
  
  
  class Variety {
    friend class Instruction;
    std::pair<unsigned, unsigned> kinds_;
    explicit Variety(std::pair<unsigned, unsigned> kinds) : kinds_(kinds) {}

   public:
    bool operator==(const Variety &other) const {
      return kinds_ == other.kinds_;
    }
    bool operator!=(const Variety &other) const {
      return kinds_ != other.kinds_;
    }
    friend llvh::hash_code hash_value(Variety variety) {
      return llvh::hash_value(variety.kinds_);
    }
  };

  
  Variety getVariety() const;

  
  llvh::hash_code getHashCode() const;

  
  bool isIdenticalTo(const Instruction *RHS) const;
};

} 





namespace llvh {

template <> struct ilist_alloc_traits<::hermes::Instruction> {
  static void deleteNode(::hermes::Instruction *V) {
    ::hermes::Value::destroy(V);
  }
};

} 

namespace hermes {

class BasicBlock : public llvh::ilist_node_with_parent<BasicBlock, Function>, public Value {
  BasicBlock(const BasicBlock &) = delete;
  void operator=(const BasicBlock &) = delete;

 public:
  using InstListType = llvh::iplist<Instruction>;

 private:
  InstListType InstList{};
  Function *Parent;

 public:
  explicit BasicBlock(Function *parent);

  
  void dump();

  
  void printAsOperand(llvh::raw_ostream &OS, bool) const;

  
  
  TerminatorInst *getTerminator();
  const TerminatorInst *getTerminator() const;

  InstListType &getInstList() {
    return InstList;
  }

  void push_back(Instruction *I);
  void removeFromParent();
  void eraseFromParent();
  void remove(Instruction *I);
  void erase(Instruction *I);

  Context &getContext() const;
  Function *getParent() const {
    return Parent;
  }
  void setParent(Function *parent) {
    Parent = parent;
  }

  
  
  static InstListType BasicBlock::*getSublistAccess(Instruction *) {
    return &BasicBlock::InstList;
  }

  using iterator = InstListType::iterator;
  using const_iterator = InstListType::const_iterator;
  using reverse_iterator = InstListType::reverse_iterator;
  using const_reverse_iterator = InstListType::const_reverse_iterator;

  using range = llvh::iterator_range<iterator>;
  using const_range = llvh::iterator_range<const_iterator>;
  using reverse_range = llvh::iterator_range<reverse_iterator>;
  using const_reverse_range = llvh::iterator_range<const_reverse_iterator>;

  inline iterator begin() {
    return InstList.begin();
  }
  inline iterator end() {
    return InstList.end();
  }
  inline reverse_iterator rbegin() {
    return InstList.rbegin();
  }
  inline reverse_iterator rend() {
    return InstList.rend();
  }
  inline const_iterator begin() const {
    return InstList.begin();
  }
  inline const_iterator end() const {
    return InstList.end();
  }
  inline const_reverse_iterator rbegin() const {
    return InstList.rbegin();
  }
  inline const_reverse_iterator rend() const {
    return InstList.rend();
  }
  inline size_t size() const {
    return InstList.size();
  }
  inline bool empty() const {
    return InstList.empty();
  }
  inline Instruction &front() {
    return InstList.front();
  }
  inline const Instruction &front() const {
    return InstList.front();
  }
  inline Instruction &back() {
    return InstList.back();
  }
  inline const Instruction &back() const {
    return InstList.back();
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::BasicBlockKind;
  }
};

} 





namespace llvh {

template <> struct ilist_alloc_traits<::hermes::BasicBlock> {
  static void deleteNode(::hermes::BasicBlock *V) {
    ::hermes::Value::destroy(V);
  }
};

} 

namespace hermes {


class VariableScope : public Value {
  using Value::Value;
  using VariableListType = llvh::SmallVector<Variable *, 8>;

  friend class Function;

  
  Function *function_;

  
  VariableListType variables_;

 protected:
  
  
  VariableScope(ValueKind kind, Function *function)
      : Value(kind), function_(function) {}

  VariableScope(Function *function)
      : VariableScope(ValueKind::VariableScopeKind, function) {}

 public:
  
  Function *getFunction() const {
    return function_;
  }

  
  bool isGlobalScope() const;

  
  VariableListType &getVariables() {
    return variables_;
  }

  
  void addVariable(Variable *V) {
    variables_.push_back(V);
  }

  ~VariableScope() {
    
    for (auto *v : variables_) {
      Value::destroy(v);
    }
  }

  static bool classof(const Value *V) {
    switch (V->getKind()) {
      case ValueKind::VariableScopeKind:
      case ValueKind::ExternalScopeKind:
        return true;
      default:
        return false;
    }
  }
};




class ExternalScope : public VariableScope {
  
  const int32_t depth_ = 0;

 public:
  ExternalScope(Function *function, int32_t depth);

  
  int32_t getDepth() const {
    return depth_;
  }

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::ExternalScopeKind;
  }
};

class Function : public llvh::ilist_node_with_parent<Function, Module>, public Value {
  Function(const Function &) = delete;
  void operator=(const Function &) = delete;

 public:
  using BasicBlockListType = llvh::iplist<BasicBlock>;
  using ParameterListType = llvh::SmallVector<Parameter *, 8>;

  enum class DefinitionKind {
    ES5Function, ES6Constructor, ES6Arrow, ES6Method, };




 private:
  
  Module *parent_;

  
  bool isGlobal_;

  
  llvh::SmallVector<VariableScope *, 4> externalScopes_;

  
  VariableScope functionScope_;

  
  BasicBlockListType BasicBlockList{};
  
  ParameterListType Parameters;
  
  
  
  Identifier originalOrInferredName_;
  
  DefinitionKind const definitionKind_;
  
  const bool strictMode_{};
  
  SMRange SourceRange{};

  
  
  Identifier internalName_;

  
  Parameter *thisParameter{};

  
  
  
  
  uint32_t expectedParamCountIncludingThis_{0};

  
  
  
  
  
  
  OptValue<uint32_t> statementCount_{0};


  
  LazySource lazySource_;

  
  std::shared_ptr<SerializedScope> lazyScope_{};

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Variable *lazyClosureAlias_{};


 protected:
  explicit Function( ValueKind kind, Module *parent, Identifier originalName, DefinitionKind definitionKind, bool strictMode, bool isGlobal, SMRange sourceRange, Function *insertBefore = nullptr);








 public:
  
  
  
  
  
  
  
  explicit Function( Module *parent, Identifier originalName, DefinitionKind definitionKind, bool strictMode, bool isGlobal, SMRange sourceRange, Function *insertBefore = nullptr)






      : Function( ValueKind::FunctionKind, parent, originalName, definitionKind, strictMode, isGlobal, sourceRange, insertBefore) {}








  ~Function();

  Module *getParent() const {
    return parent_;
  }

  
  bool isGlobalScope() const {
    return isGlobal_;
  }

  
  bool isAnonymous() const {
    return originalOrInferredName_.str().empty();
  }

  
  
  
  std::string getDefinitionKindStr(bool isDescriptive) const;

  
  
  
  std::string getDescriptiveDefinitionKindStr() const;

  
  const Identifier getInternalName() const {
    return internalName_;
  }

  
  StringRef getInternalNameStr() const {
    return internalName_.str();
  }

  
  
  const Identifier getOriginalOrInferredName() const {
    return originalOrInferredName_;
  }

  
  Context &getContext() const;

  
  
  void addExternalScope(ExternalScope *scope) {
    externalScopes_.push_back(scope);
  }

  VariableScope *getFunctionScope() {
    return &functionScope_;
  }

  void addBlock(BasicBlock *BB);
  void addParameter(Parameter *A);

  const BasicBlockListType &getBasicBlockList() const {
    return BasicBlockList;
  }
  BasicBlockListType &getBasicBlockList() {
    return BasicBlockList;
  }

  
  
  
  void eraseFromParentNoDestroy();

  
  void dump();

  
  DefinitionKind getDefinitionKind() const {
    return definitionKind_;
  }

  
  bool isStrictMode() const {
    return strictMode_;
  }

  
  SMRange getSourceRange() const {
    return SourceRange;
  }

  OptValue<uint32_t> getStatementCount() const {
    return statementCount_;
  }

  void setStatementCount(uint32_t count) {
    statementCount_ = count;
  }

  
  
  void incrementStatementCount() {
    assert( statementCount_.hasValue() && "cannot incrementStatementCount after clearing it");

    statementCount_ = *statementCount_ + 1;
  }

  void clearStatementCount() {
    statementCount_ = llvh::None;
  }

  ParameterListType &getParameters() {
    return Parameters;
  }

  void setExpectedParamCountIncludingThis(uint32_t count) {
    expectedParamCountIncludingThis_ = count;
  }

  uint32_t getExpectedParamCountIncludingThis() const {
    return expectedParamCountIncludingThis_;
  }

  void setThisParameter(Parameter *thisParam) {
    assert(!thisParameter && "This parameter can only be created once");
    thisParameter = thisParam;
  }
  Parameter *getThisParameter() const {
    return thisParameter;
  }


  LazySource &getLazySource() {
    return lazySource_;
  }

  void setLazyScope(std::shared_ptr<SerializedScope> vars) {
    lazyScope_ = std::move(vars);
  }
  std::shared_ptr<SerializedScope> getLazyScope() const {
    return lazyScope_;
  }

  void setLazyClosureAlias(Variable *var) {
    lazyClosureAlias_ = var;
  }
  Variable *getLazyClosureAlias() const {
    return lazyClosureAlias_;
  }


  
  bool isLazy() const {

    return false;

    return lazySource_.nodeKind != ESTree::NodeKind::Empty;

  }

  using iterator = BasicBlockListType::iterator;
  using const_iterator = BasicBlockListType::const_iterator;
  using reverse_iterator = BasicBlockListType::reverse_iterator;
  using const_reverse_iterator = BasicBlockListType::const_reverse_iterator;

  using arg_iterator = ParameterListType::iterator;
  using const_arg_iterator = ParameterListType::const_iterator;

  inline iterator begin() {
    return BasicBlockList.begin();
  }
  inline iterator end() {
    return BasicBlockList.end();
  }
  inline reverse_iterator rbegin() {
    return BasicBlockList.rbegin();
  }
  inline reverse_iterator rend() {
    return BasicBlockList.rend();
  }
  inline const_iterator begin() const {
    return BasicBlockList.begin();
  }
  inline const_iterator end() const {
    return BasicBlockList.end();
  }
  inline const_reverse_iterator rbegin() const {
    return BasicBlockList.rbegin();
  }
  inline const_reverse_iterator rend() const {
    return BasicBlockList.rend();
  }
  inline arg_iterator arg_begin() {
    return Parameters.begin();
  }
  inline arg_iterator arg_end() {
    return Parameters.end();
  }
  inline const_arg_iterator arg_begin() const {
    return Parameters.begin();
  }
  inline const_arg_iterator arg_end() const {
    return Parameters.end();
  }
  inline size_t size() const {
    return BasicBlockList.size();
  }
  inline bool empty() const {
    return BasicBlockList.empty();
  }
  inline BasicBlock &front() {
    return BasicBlockList.front();
  }
  inline BasicBlock &back() {
    return BasicBlockList.back();
  }

  void viewGraph();

  static bool classof(const Value *V) {
    return kindIsA(V->getKind(), ValueKind::FunctionKind);
  }
};

class GeneratorFunction final : public Function {
 public:
  explicit GeneratorFunction( Module *parent, Identifier originalName, DefinitionKind definitionKind, bool strictMode, bool isGlobal, SMRange sourceRange, Function *insertBefore)






      : Function( ValueKind::GeneratorFunctionKind, parent, originalName, definitionKind, strictMode, isGlobal, sourceRange, insertBefore) {}








  static bool classof(const Value *V) {
    return kindIsA(V->getKind(), ValueKind::GeneratorFunctionKind);
  }
};

class GeneratorInnerFunction final : public Function {
 public:
  explicit GeneratorInnerFunction( Module *parent, Identifier originalName, DefinitionKind definitionKind, bool strictMode, bool isGlobal, SMRange sourceRange, Function *insertBefore)






      : Function( ValueKind::GeneratorInnerFunctionKind, parent, originalName, definitionKind, strictMode, isGlobal, sourceRange, insertBefore) {







    setType(Type::createAnyType());
  }

  static bool classof(const Value *V) {
    return kindIsA(V->getKind(), ValueKind::GeneratorInnerFunctionKind);
  }
};

} 





namespace llvh {

template <> struct ilist_alloc_traits<::hermes::Function> {
  static void deleteNode(::hermes::Function *V) {
    ::hermes::Value::destroy(V);
  }
};

} 

namespace hermes {

class Module : public Value {
  Module(const Module &) = delete;
  void operator=(const Module &) = delete;

 public:
  using FunctionListType = llvh::iplist<Function>;

  using RawStringList = std::vector<LiteralString *>;

  struct CJSModule {
    
    uint32_t id;
    
    Identifier filename;
    
    Function *function;
  };

 private:
  using GlobalObjectPropertyList = std::vector<GlobalObjectProperty *>;

  std::shared_ptr<Context> Ctx;
  
  Function *topLevelFunction_{};

  FunctionListType FunctionList{};

  
  GlobalObjectPropertyList globalPropertyList_{};
  
  llvh::DenseMap<Identifier, GlobalObjectProperty *> globalPropertyMap_{};

  GlobalObject globalObject_{};
  LiteralUndefined literalUndefined{};
  LiteralNull literalNull{};
  LiteralBool literalFalse{false};
  LiteralBool literalTrue{true};
  EmptySentinel emptySentinel_{};

  using LiteralNumberFoldingSet = llvh::FoldingSet<LiteralNumber>;
  using LiteralStringFoldingSet = llvh::FoldingSet<LiteralString>;

  LiteralNumberFoldingSet literalNumbers{};
  LiteralStringFoldingSet literalStrings{};

  
  
  
  llvh::DenseMap<Identifier, unsigned> internalNamesMap_;

  
  
  
  
  std::deque<CJSModule> cjsModules_{};

  using CJSModuleIterator = std::deque<CJSModule>::iterator;

  
  llvh::DenseMap<Function *, CJSModule *> cjsModuleFunctionMap_{};
  
  llvh::DenseMap<Identifier, CJSModule *> cjsModuleFilenameMap_{};

  
  bool cjsModulesResolved_{false};

  using CJSModuleUseGraph = std::unordered_map<Function *, llvh::SmallPtrSet<Function *, 2>>;

  
  
  
  
  
  CJSModuleUseGraph cjsModuleUseGraph_{};

  struct HashRawStrings {
    std::size_t operator()(const RawStringList &rawStrings) const {
      return llvh::hash_combine_range(rawStrings.begin(), rawStrings.end());
    }
  };

  
  std::unordered_map<RawStringList, uint32_t, HashRawStrings> templateObjectIDMap_;

  
  bool isLowered_{false};

 public:
  explicit Module(std::shared_ptr<Context> ctx)
      : Value(ValueKind::ModuleKind), Ctx(std::move(ctx)) {}

  ~Module();

  Context &getContext() const {
    return *Ctx;
  }

  std::shared_ptr<Context> shareContext() const {
    return Ctx;
  }

  
  Identifier deriveUniqueInternalName(Identifier originalName);

  using iterator = FunctionListType::iterator;
  using const_iterator = FunctionListType::const_iterator;
  using reverse_iterator = FunctionListType::reverse_iterator;
  using const_reverse_iterator = FunctionListType::const_reverse_iterator;

  
  void push_back(Function *F);
  
  void insert(iterator position, Function *F);

  const FunctionListType &getFunctionList() const {
    return FunctionList;
  }
  FunctionListType &getFunctionList() {
    return FunctionList;
  }

  
  
  void setTopLevelFunction(Function *topLevelFunction) {
    assert( topLevelFunction->getParent() == this && "topLevelFunction from a different module");

    topLevelFunction_ = topLevelFunction;
  }

  
  Function *getTopLevelFunction() {
    assert( !FunctionList.empty() && "top-level function hasn't been created yet");
    
    
    return !topLevelFunction_ ? &*FunctionList.begin() : topLevelFunction_;
  }

  using GlobalObjectPropertyIterator = GlobalObjectPropertyList::const_iterator;

  llvh::iterator_range<GlobalObjectPropertyIterator> getGlobalProperties() {
    return {globalPropertyList_.begin(), globalPropertyList_.end()};
  }

  
  GlobalObjectProperty *findGlobalProperty(Identifier name);

  
  
  GlobalObjectProperty *addGlobalProperty(Identifier name, bool declared);

  
  void eraseGlobalProperty(GlobalObjectProperty *prop);

  
  LiteralNumber *getLiteralNumber(double value);

  
  LiteralString *getLiteralString(Identifier value);

  
  LiteralBool *getLiteralBool(bool value);

  
  LiteralUndefined *getLiteralUndefined() {
    return &literalUndefined;
  }

  
  LiteralNull *getLiteralNull() {
    return &literalNull;
  }

  
  GlobalObject *getGlobalObject() {
    return &globalObject_;
  }

  
  EmptySentinel *getEmptySentinel() {
    return &emptySentinel_;
  }

  
  void addCJSModule(uint32_t id, Identifier name, Function *function) {
    if (cjsModules_.size() <= id) {
      cjsModules_.resize(id + 1);
    }
    CJSModule &module = cjsModules_[id];
    assert(module.function == nullptr && "duplicate IDs in addCJSModule");
    module.id = id;
    module.filename = name;
    module.function = function;
    {
      auto result = cjsModuleFilenameMap_.try_emplace(name, &module);
      (void)result;
      assert(result.second && "Should only insert CJS module once");
    }
    {
      auto result = cjsModuleFunctionMap_.try_emplace(function, &module);
      (void)result;
      assert(result.second && "Should only insert CJS module once");
    }
  }

  
  
  const CJSModule *findCJSModule(Function *function) const {
    auto it = cjsModuleFunctionMap_.find(function);
    return it == cjsModuleFunctionMap_.end() ? nullptr : it->second;
  }

  
  
  const CJSModule *findCJSModule(Identifier filename) const {
    auto it = cjsModuleFilenameMap_.find(filename);
    return it == cjsModuleFilenameMap_.end() ? nullptr : it->second;
  }

  
  llvh::iterator_range<CJSModuleIterator> getCJSModules() {
    return {cjsModules_.begin(), cjsModules_.end()};
  }

  
  bool getCJSModulesResolved() const {
    return cjsModulesResolved_;
  }

  
  void setCJSModulesResolved(bool cjsModulesResolved) {
    cjsModulesResolved_ = cjsModulesResolved;
  }

  
  
  
  llvh::DenseSet<Function *> getFunctionsInSegment(Context::SegmentRange range);

  
  uint32_t getTemplateObjectID(RawStringList &&rawStrings);

  bool isLowered() const {
    return isLowered_;
  }

  void setLowered(bool isLowered) {
    isLowered_ = isLowered;
  }

  inline iterator begin() {
    return FunctionList.begin();
  }
  inline iterator end() {
    return FunctionList.end();
  }
  inline reverse_iterator rbegin() {
    return FunctionList.rbegin();
  }
  inline reverse_iterator rend() {
    return FunctionList.rend();
  }
  inline const_iterator begin() const {
    return FunctionList.begin();
  }
  inline const_iterator end() const {
    return FunctionList.end();
  }
  inline const_reverse_iterator rbegin() const {
    return FunctionList.rbegin();
  }
  inline const_reverse_iterator rend() const {
    return FunctionList.rend();
  }
  inline size_t size() const {
    return FunctionList.size();
  }
  inline bool empty() const {
    return FunctionList.empty();
  }
  inline Function &front() {
    return FunctionList.front();
  }
  inline Function &back() {
    return FunctionList.back();
  }

  void viewGraph();
  void dump();

  static bool classof(const Value *V) {
    return V->getKind() == ValueKind::ModuleKind;
  }

 private:
  
  
  void populateCJSModuleUseGraph();
};


static inline llvh::hash_code hash_value(Type V) {
  return V.hash();
}

} 

namespace llvh {

raw_ostream &operator<<(raw_ostream &OS, const hermes::Type &T);

} 


