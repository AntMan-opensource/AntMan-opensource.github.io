commit 4bc7408ae2aefac9357c16809541ecbe225b7f3a
Author: Jeffrey Walton <noloader@gmail.com>
Date:   Tue Dec 29 01:49:17 2020 -0500

    Use 8-byte alignment for FixedSizeAllocatorWithCleanup when 16-byte alignment is false (GH #992)

diff --git a/secblock.h b/secblock.h
index 9be03050..39beb677 100644
--- a/secblock.h
+++ b/secblock.h
@@ -547,9 +547,14 @@ private:
 
 #else
 
-	// CRYPTOPP_BOOL_ALIGN16 is 0. Use natural alignment of T.
+	// CRYPTOPP_BOOL_ALIGN16 is 0. Normally we would use the natural
+	// alignment of T. The problem we are having is, some toolchains
+	// are changing the boundary for 64-bit arrays. 64-bit elements
+	// require 8-byte alignment, but the toolchain is laying the array
+	// out on a 4 byte boundary. See GH #992 for mystery alignment:
+	// https://github.com/weidai11/cryptopp/issues/992
 	T* GetAlignedArray() {return m_array;}
-	T m_array[S];
+	CRYPTOPP_ALIGN_DATA(8) T m_array[S];
 
 #endif
 
@@ -700,9 +705,14 @@ public:
 
 private:
 
-	// T_Align16 is false. Use natural alignment of T.
+	// T_Align16 is false. Normally we would use the natural
+	// alignment of T. The problem we are having is, some toolchains
+	// are changing the boundary for 64-bit arrays. 64-bit elements
+	// require 8-byte alignment, but the toolchain is laying the array
+	// out on a 4 byte boundary. See GH #992 for mystery alignment:
+	// https://github.com/weidai11/cryptopp/issues/992
 	T* GetAlignedArray() {return m_array;}
-	T m_array[S];
+	CRYPTOPP_ALIGN_DATA(8) T m_array[S];
 
 	A m_fallbackAllocator;
 	bool m_allocated;
