commit e92ffd9b626833ebdbf2742c8ffddc6cd94b963e
diff --git a/cddl/lib/libicp/Makefile b/cddl/lib/libicp/Makefile
index 253b252bc2d4..1cdb146d0fa1 100644
--- a/cddl/lib/libicp/Makefile
+++ b/cddl/lib/libicp/Makefile
@@ -15,7 +15,6 @@ ASM_SOURCES_AS = \
         asm-x86_64/modes/gcm_pclmulqdq.S \
         asm-x86_64/modes/aesni-gcm-x86_64.S \
         asm-x86_64/modes/ghash-x86_64.S \
-        asm-x86_64/sha1/sha1-x86_64.S \
         asm-x86_64/sha2/sha256_impl.S \
         asm-x86_64/sha2/sha512_impl.S
 
@@ -47,19 +46,15 @@ KERNEL_C = \
         algs/modes/ctr.c \
         algs/modes/ccm.c \
         algs/modes/ecb.c \
-        algs/sha1/sha1.c \
         algs/sha2/sha2.c \
         algs/skein/skein.c \
         algs/skein/skein_block.c \
         algs/skein/skein_iv.c \
         illumos-crypto.c \
         io/aes.c \
-        io/edonr_mod.c \
-        io/sha1_mod.c \
         io/sha2_mod.c \
         io/skein_mod.c \
         os/modhash.c \
-        os/modconf.c \
         core/kcf_sched.c \
         core/kcf_prov_lib.c \
         core/kcf_callprov.c \
@@ -94,7 +89,6 @@ CFLAGS.aes_aesni.S+= -DLOCORE
 CFLAGS.gcm_pclmulqdq.S+= -DLOCORE
 CFLAGS.aesni-gcm-x86_64.S+= -DLOCORE
 CFLAGS.ghash-x86_64.S+= -DLOCORE
-CFLAGS.sha1-x86_64.S+= -DLOCORE
 CFLAGS.sha256_impl.S+= -DLOCORE
 CFLAGS.sha512_impl.S+= -DLOCORE
 
diff --git a/cddl/lib/libicp_rescue/Makefile b/cddl/lib/libicp_rescue/Makefile
index a46fd6db3877..ea1af847d807 100644
--- a/cddl/lib/libicp_rescue/Makefile
+++ b/cddl/lib/libicp_rescue/Makefile
@@ -14,7 +14,6 @@ ASM_SOURCES_AS = \
         asm-x86_64/aes/aes_aesni.S \
         asm-x86_64/modes/gcm_pclmulqdq.S \
         asm-x86_64/modes/aesni-gcm-x86_64.S \
-        asm-x86_64/sha1/sha1-x86_64.S \
         asm-x86_64/sha2/sha256_impl.S \
         asm-x86_64/sha2/sha512_impl.S
 
@@ -46,17 +45,13 @@ KERNEL_C = \
         algs/modes/ctr.c \
         algs/modes/ccm.c \
         algs/modes/ecb.c \
-        algs/sha1/sha1.c \
         algs/sha2/sha2.c \
         algs/skein/skein_block.c \
         illumos-crypto.c \
         io/aes.c \
-        io/edonr_mod.c \
-        io/sha1_mod.c \
         io/sha2_mod.c \
         io/skein_mod.c \
         os/modhash.c \
-        os/modconf.c \
         core/kcf_sched.c \
         core/kcf_prov_lib.c \
         core/kcf_callprov.c \
@@ -64,11 +59,6 @@ KERNEL_C = \
         core/kcf_prov_tabs.c \
         $(ASM_SOURCES_C)
 
-
-
-
-
-
 SRCS= $(ASM_SOURCES_AS) $(KERNEL_C)
 
 WARNS?=	2
@@ -91,7 +81,6 @@ CFLAGS.aes_aesni.S+= -DLOCORE
 CFLAGS.gcm_pclmulqdq.S+= -DLOCORE
 CFLAGS.aesni-gcm-x86_64.S+= -DLOCORE
 CFLAGS.ghash-x86_64.S+= -DLOCORE
-CFLAGS.sha1-x86_64.S+= -DLOCORE
 CFLAGS.sha256_impl.S+= -DLOCORE
 CFLAGS.sha512_impl.S+= -DLOCORE
 CFLAGS.gcm.c+= -UCAN_USE_GCM_ASM
diff --git a/cddl/lib/libzfsbootenv/Makefile b/cddl/lib/libzfsbootenv/Makefile
index f84718a10de7..be39af96124a 100644
--- a/cddl/lib/libzfsbootenv/Makefile
+++ b/cddl/lib/libzfsbootenv/Makefile
@@ -29,5 +29,8 @@ CFLAGS+= -include ${SRCTOP}/sys/contrib/openzfs/include/os/freebsd/spl/sys/ccomp
 CFLAGS+= -DHAVE_ISSETUGID
 CFLAGS+= -include ${SRCTOP}/sys/modules/zfs/zfs_config.h
 CFLAGS+= -I${SRCTOP}/sys/contrib/openzfs/include/os/freebsd/zfs
+CFLAGS.lzbe_device.c=	-Wno-cast-qual
+CFLAGS.lzbe_util.c=	-Wno-cast-qual
+CFLAGS.lzbe_pair.c=	-Wno-cast-qual
 
 .include <bsd.lib.mk>
diff --git a/cddl/lib/libzpool/Makefile b/cddl/lib/libzpool/Makefile
index 6893e31ff20a..1c15cc265d48 100644
--- a/cddl/lib/libzpool/Makefile
+++ b/cddl/lib/libzpool/Makefile
@@ -95,6 +95,7 @@ KERNEL_C = \
 	gzip.c \
 	lzjb.c \
 	lz4.c \
+	lz4_zfs.c \
 	metaslab.c \
 	mmp.c \
 	multilist.c \
diff --git a/lib/libbe/Makefile b/lib/libbe/Makefile
index 50a8f8f56fb2..3c66ea9f1cf0 100644
--- a/lib/libbe/Makefile
+++ b/lib/libbe/Makefile
@@ -63,7 +63,10 @@ CFLAGS+= -I${SRCTOP}/sys
 CFLAGS+= -I${SRCTOP}/cddl/compat/opensolaris/include
 CFLAGS+= -include ${SRCTOP}/sys/contrib/openzfs/include/os/freebsd/spl/sys/ccompile.h
 CFLAGS+= -DHAVE_ISSETUGID
-
+CFLAGS.be.c=		-Wno-cast-qual
+CFLAGS.be_access.c=	-Wno-cast-qual
+CFLAGS.be_error.c=	-Wno-cast-qual
+CFLAGS.be_info.c=	-Wno-cast-qual
 
 HAS_TESTS=	YES
 SUBDIR.${MK_TESTS}+= tests
diff --git a/sys/contrib/openzfs/.github/workflows/checkstyle.yaml b/sys/contrib/openzfs/.github/workflows/checkstyle.yaml
index 553d5df39796..a102b6e8aa1f 100644
--- a/sys/contrib/openzfs/.github/workflows/checkstyle.yaml
+++ b/sys/contrib/openzfs/.github/workflows/checkstyle.yaml
@@ -15,7 +15,7 @@ jobs:
       run: |
         sudo apt-get update
         sudo apt-get install --yes -qq build-essential autoconf libtool gawk alien fakeroot linux-headers-$(uname -r)
-        sudo apt-get install --yes -qq zlib1g-dev uuid-dev libattr1-dev libblkid-dev libselinux-dev libudev-dev libssl-dev python-dev python-setuptools python-cffi python3 python3-dev python3-setuptools python3-cffi
+        sudo apt-get install --yes -qq zlib1g-dev uuid-dev libattr1-dev libblkid-dev libselinux-dev libudev-dev libssl-dev python3 python3-dev python3-setuptools python3-cffi
         # packages for tests
         sudo apt-get install --yes -qq parted lsscsi ksh attr acl nfs-kernel-server fio
         sudo apt-get install --yes -qq mandoc cppcheck pax-utils devscripts
diff --git a/sys/contrib/openzfs/.github/workflows/zfs-tests-functional.yml b/sys/contrib/openzfs/.github/workflows/zfs-tests-functional.yml
index 2987cdac6d64..19d3f57baec9 100644
--- a/sys/contrib/openzfs/.github/workflows/zfs-tests-functional.yml
+++ b/sys/contrib/openzfs/.github/workflows/zfs-tests-functional.yml
@@ -25,9 +25,8 @@ jobs:
           zlib1g-dev uuid-dev libblkid-dev libselinux-dev \
           xfslibs-dev libattr1-dev libacl1-dev libudev-dev libdevmapper-dev \
           libssl-dev libffi-dev libaio-dev libelf-dev libmount-dev \
-          libpam0g-dev pamtester python-dev python-setuptools python-cffi \
-          python-packaging python3 python3-dev python3-setuptools python3-cffi \
-          libcurl4-openssl-dev python3-packaging
+          libpam0g-dev pamtester libcurl4-openssl-dev \
+          python3 python3-dev python3-setuptools python3-cffi python3-packaging
     - name: Autogen.sh
       run: |
         sh autogen.sh
diff --git a/sys/contrib/openzfs/.github/workflows/zfs-tests-sanity.yml b/sys/contrib/openzfs/.github/workflows/zfs-tests-sanity.yml
index 8cba6d78dde2..2b97fd61822f 100644
--- a/sys/contrib/openzfs/.github/workflows/zfs-tests-sanity.yml
+++ b/sys/contrib/openzfs/.github/workflows/zfs-tests-sanity.yml
@@ -21,9 +21,8 @@ jobs:
           zlib1g-dev uuid-dev libblkid-dev libselinux-dev \
           xfslibs-dev libattr1-dev libacl1-dev libudev-dev libdevmapper-dev \
           libssl-dev libffi-dev libaio-dev libelf-dev libmount-dev \
-          libpam0g-dev pamtester python-dev python-setuptools python-cffi \
-          python-packaging python3 python3-dev python3-setuptools python3-cffi \
-          python3-packaging libcurl4-openssl-dev
+          libpam0g-dev pamtester libcurl4-openssl-dev \
+          python3 python3-dev python3-setuptools python3-cffi python3-packaging
     - name: Autogen.sh
       run: |
         sh autogen.sh
diff --git a/sys/contrib/openzfs/.github/workflows/zloop.yml b/sys/contrib/openzfs/.github/workflows/zloop.yml
index cf81ad4bcafc..5c1b9bd1ce22 100644
--- a/sys/contrib/openzfs/.github/workflows/zloop.yml
+++ b/sys/contrib/openzfs/.github/workflows/zloop.yml
@@ -22,7 +22,6 @@ jobs:
           xfslibs-dev libattr1-dev libacl1-dev libudev-dev libdevmapper-dev \
           libssl-dev libffi-dev libaio-dev libelf-dev libmount-dev \
           libpam0g-dev \
-          python-dev python-setuptools python-cffi python-packaging \
           python3 python3-dev python3-setuptools python3-cffi python3-packaging
     - name: Autogen.sh
       run: |
diff --git a/sys/contrib/openzfs/Makefile.am b/sys/contrib/openzfs/Makefile.am
index 34fe16ce4118..37a9bfdf8697 100644
--- a/sys/contrib/openzfs/Makefile.am
+++ b/sys/contrib/openzfs/Makefile.am
@@ -114,6 +114,11 @@ commitcheck:
 		${top_srcdir}/scripts/commitcheck.sh; \
 	fi
 
+if HAVE_PARALLEL
+cstyle_line = -print0 | parallel -X0 ${top_srcdir}/scripts/cstyle.pl -cpP {}
+else
+cstyle_line = -exec ${top_srcdir}/scripts/cstyle.pl -cpP {} +
+endif
 PHONY += cstyle
 cstyle:
 	@find ${top_srcdir} -name build -prune \
@@ -121,7 +126,8 @@ cstyle:
 		! -name 'zfs_config.*' ! -name '*.mod.c' \
 		! -name 'opt_global.h' ! -name '*_if*.h' \
 		! -path './module/zstd/lib/*' \
-		-exec ${top_srcdir}/scripts/cstyle.pl -cpP {} \+
+		! -path './module/zfs/lz4.c' \
+		$(cstyle_line)
 
 filter_executable = -exec test -x '{}' \; -print
 
diff --git a/sys/contrib/openzfs/README.md b/sys/contrib/openzfs/README.md
index d666df7af309..331889560950 100644
--- a/sys/contrib/openzfs/README.md
+++ b/sys/contrib/openzfs/README.md
@@ -12,7 +12,7 @@ This repository contains the code for running OpenZFS on Linux and FreeBSD.
   * [Documentation](https://openzfs.github.io/openzfs-docs/) - for using and developing this repo
   * [ZoL Site](https://zfsonlinux.org) - Linux release info & links
   * [Mailing lists](https://openzfs.github.io/openzfs-docs/Project%20and%20Community/Mailing%20Lists.html)
-  * [OpenZFS site](http://open-zfs.org/) - for conference videos and info on other platforms (illumos, OSX, Windows, etc)
+  * [OpenZFS site](https://openzfs.org/) - for conference videos and info on other platforms (illumos, OSX, Windows, etc)
 
 # Installation
 
diff --git a/sys/contrib/openzfs/cmd/Makefile.am b/sys/contrib/openzfs/cmd/Makefile.am
index 5fc9e83971d8..3994d1434e99 100644
--- a/sys/contrib/openzfs/cmd/Makefile.am
+++ b/sys/contrib/openzfs/cmd/Makefile.am
@@ -7,8 +7,9 @@ SUBDIRS += zpool_influxdb
 CPPCHECKDIRS  = zfs zpool zdb zhack zinject zstream ztest
 CPPCHECKDIRS += raidz_test zfs_ids_to_path zpool_influxdb
 
-# TODO: #12084: SHELLCHECKDIRS = fsck_zfs vdev_id zpool
-SHELLCHECKDIRS = fsck_zfs zpool
+# TODO: #12084: SHELLCHECKDIRS += vdev_id
+SHELLCHECKDIRS = fsck_zfs zed zpool zvol_wait
+SHELLCHECK_OPTS = --enable=all
 
 if USING_PYTHON
 SUBDIRS += arcstat arc_summary dbufstat
diff --git a/sys/contrib/openzfs/cmd/arc_summary/Makefile.am b/sys/contrib/openzfs/cmd/arc_summary/Makefile.am
index 1a26c2c199f8..f419f07e0eda 100644
--- a/sys/contrib/openzfs/cmd/arc_summary/Makefile.am
+++ b/sys/contrib/openzfs/cmd/arc_summary/Makefile.am
@@ -1,13 +1,8 @@
 bin_SCRIPTS = arc_summary
 
 CLEANFILES = arc_summary
-EXTRA_DIST = arc_summary2 arc_summary3
-
-if USING_PYTHON_2
-SCRIPT = arc_summary2
-else
+EXTRA_DIST = arc_summary3
 SCRIPT = arc_summary3
-endif
 
 arc_summary: $(SCRIPT)
 	cp $< $@
diff --git a/sys/contrib/openzfs/cmd/arc_summary/arc_summary2 b/sys/contrib/openzfs/cmd/arc_summary/arc_summary2
deleted file mode 100755
index 3302a802d146..000000000000
--- a/sys/contrib/openzfs/cmd/arc_summary/arc_summary2
+++ /dev/null
@@ -1,1180 +0,0 @@
-#!/usr/bin/env python2
-#
-# $Id: arc_summary.pl,v 388:e27800740aa2 2011-07-08 02:53:29Z jhell $
-#
-# Copyright (c) 2008 Ben Rockwood <benr@cuddletech.com>,
-# Copyright (c) 2010 Martin Matuska <mm@FreeBSD.org>,
-# Copyright (c) 2010-2011 Jason J. Hellenthal <jhell@DataIX.net>,
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-#
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-#
-# If you are having troubles when using this script from cron(8) please try
-# adjusting your PATH before reporting problems.
-#
-# Note some of this code uses older code (eg getopt instead of argparse,
-# subprocess.Popen() instead of subprocess.run()) because we need to support
-# some very old versions of Python.
-#
-
-"""Print statistics on the ZFS Adjustable Replacement Cache (ARC)
-
-Provides basic information on the ARC, its efficiency, the L2ARC (if present),
-the Data Management Unit (DMU), Virtual Devices (VDEVs), and tunables. See the
-in-source documentation and code at
-https://github.com/openzfs/zfs/blob/master/module/zfs/arc.c for details.
-"""
-
-import getopt
-import os
-import sys
-import time
-import errno
-
-from subprocess import Popen, PIPE
-from decimal import Decimal as D
-
-
-if sys.platform.startswith('freebsd'):
-    # Requires py27-sysctl on FreeBSD
-    import sysctl
-
-    def is_value(ctl):
-        return ctl.type != sysctl.CTLTYPE_NODE
-
-    def load_kstats(namespace):
-        """Collect information on a specific subsystem of the ARC"""
-
-        base = 'kstat.zfs.misc.%s.' % namespace
-        fmt = lambda kstat: (kstat.name, D(kstat.value))
-        kstats = sysctl.filter(base)
-        return [fmt(kstat) for kstat in kstats if is_value(kstat)]
-
-    def load_tunables():
-        ctls = sysctl.filter('vfs.zfs')
-        return dict((ctl.name, ctl.value) for ctl in ctls if is_value(ctl))
-
-elif sys.platform.startswith('linux'):
-
-    def load_kstats(namespace):
-        """Collect information on a specific subsystem of the ARC"""
-
-        kstat = 'kstat.zfs.misc.%s.%%s' % namespace
-        path = '/proc/spl/kstat/zfs/%s' % namespace
-        with open(path) as f:
-            entries = [line.strip().split() for line in f][2:] # Skip header
-        return [(kstat % name, D(value)) for name, _, value in entries]
-
-    def load_tunables():
-        basepath = '/sys/module/zfs/parameters'
-        tunables = {}
-        for name in os.listdir(basepath):
-            if not name:
-                continue
-            path = '%s/%s' % (basepath, name)
-            with open(path) as f:
-                value = f.read()
-            tunables[name] = value.strip()
-        return tunables
-
-
-show_tunable_descriptions = False
-alternate_tunable_layout = False
-
-
-def get_Kstat():
-    """Collect information on the ZFS subsystem from the /proc virtual
-    file system. The name "kstat" is a holdover from the Solaris utility
-    of the same name.
-    """
-
-    Kstat = {}
-    Kstat.update(load_kstats('arcstats'))
-    Kstat.update(load_kstats('zfetchstats'))
-    Kstat.update(load_kstats('vdev_cache_stats'))
-    return Kstat
-
-
-def fBytes(b=0):
-    """Return human-readable representation of a byte value in
-    powers of 2 (eg "KiB" for "kibibytes", etc) to two decimal
-    points. Values smaller than one KiB are returned without
-    decimal points.
-    """
-
-    prefixes = [
-        [2**80, "YiB"],   # yobibytes (yotta)
-        [2**70, "ZiB"],   # zebibytes (zetta)
-        [2**60, "EiB"],   # exbibytes (exa)
-        [2**50, "PiB"],   # pebibytes (peta)
-        [2**40, "TiB"],   # tebibytes (tera)
-        [2**30, "GiB"],   # gibibytes (giga)
-        [2**20, "MiB"],   # mebibytes (mega)
-        [2**10, "KiB"]]   # kibibytes (kilo)
-
-    if b >= 2**10:
-
-        for limit, unit in prefixes:
-
-            if b >= limit:
-                value = b / limit
-                break
-
-        result = "%0.2f\t%s" % (value, unit)
-
-    else:
-
-        result = "%d\tBytes" % b
-
-    return result
-
-
-def fHits(hits=0):
-    """Create a human-readable representation of the number of hits.
-    The single-letter symbols used are SI to avoid the confusion caused
-    by the different "short scale" and "long scale" representations in
-    English, which use the same words for different values. See
-    https://en.wikipedia.org/wiki/Names_of_large_numbers and
-    https://physics.nist.gov/cuu/Units/prefixes.html
-    """
-
-    numbers = [
-            [10**24, 'Y'],  # yotta (septillion)
-            [10**21, 'Z'],  # zetta (sextillion)
-            [10**18, 'E'],  # exa   (quintrillion)
-            [10**15, 'P'],  # peta  (quadrillion)
-            [10**12, 'T'],  # tera  (trillion)
-            [10**9, 'G'],   # giga  (billion)
-            [10**6, 'M'],   # mega  (million)
-            [10**3, 'k']]   # kilo  (thousand)
-
-    if hits >= 1000:
-
-        for limit, symbol in numbers:
-
-            if hits >= limit:
-                value = hits/limit
-                break
-
-        result = "%0.2f%s" % (value, symbol)
-
-    else:
-
-        result = "%d" % hits
-
-    return result
-
-
-def fPerc(lVal=0, rVal=0, Decimal=2):
-    """Calculate percentage value and return in human-readable format"""
-
-    if rVal > 0:
-        return str("%0." + str(Decimal) + "f") % (100 * (lVal / rVal)) + "%"
-    else:
-        return str("%0." + str(Decimal) + "f") % 100 + "%"
-
-
-def get_arc_summary(Kstat):
-    """Collect general data on the ARC"""
-
-    output = {}
-    memory_throttle_count = Kstat[
-        "kstat.zfs.misc.arcstats.memory_throttle_count"
-        ]
-
-    if memory_throttle_count > 0:
-        output['health'] = 'THROTTLED'
-    else:
-        output['health'] = 'HEALTHY'
-
-    output['memory_throttle_count'] = fHits(memory_throttle_count)
-
-    # ARC Misc.
-    deleted = Kstat["kstat.zfs.misc.arcstats.deleted"]
-    mutex_miss = Kstat["kstat.zfs.misc.arcstats.mutex_miss"]
-    evict_skip = Kstat["kstat.zfs.misc.arcstats.evict_skip"]
-    evict_l2_cached = Kstat["kstat.zfs.misc.arcstats.evict_l2_cached"]
-    evict_l2_eligible = Kstat["kstat.zfs.misc.arcstats.evict_l2_eligible"]
-    evict_l2_eligible_mfu = Kstat["kstat.zfs.misc.arcstats.evict_l2_eligible_mfu"]
-    evict_l2_eligible_mru = Kstat["kstat.zfs.misc.arcstats.evict_l2_eligible_mru"]
-    evict_l2_ineligible = Kstat["kstat.zfs.misc.arcstats.evict_l2_ineligible"]
-    evict_l2_skip = Kstat["kstat.zfs.misc.arcstats.evict_l2_skip"]
-
-    # ARC Misc.
-    output["arc_misc"] = {}
-    output["arc_misc"]["deleted"] = fHits(deleted)
-    output["arc_misc"]["mutex_miss"] = fHits(mutex_miss)
-    output["arc_misc"]["evict_skips"] = fHits(evict_skip)
-    output["arc_misc"]["evict_l2_skip"] = fHits(evict_l2_skip)
-    output["arc_misc"]["evict_l2_cached"] = fBytes(evict_l2_cached)
-    output["arc_misc"]["evict_l2_eligible"] = fBytes(evict_l2_eligible)
-    output["arc_misc"]["evict_l2_eligible_mfu"] = {
-            'per': fPerc(evict_l2_eligible_mfu, evict_l2_eligible),
-            'num': fBytes(evict_l2_eligible_mfu),
-    }
-    output["arc_misc"]["evict_l2_eligible_mru"] = {
-            'per': fPerc(evict_l2_eligible_mru, evict_l2_eligible),
-            'num': fBytes(evict_l2_eligible_mru),
-    }
-    output["arc_misc"]["evict_l2_ineligible"] = fBytes(evict_l2_ineligible)
-
-    # ARC Sizing
-    arc_size = Kstat["kstat.zfs.misc.arcstats.size"]
-    mru_size = Kstat["kstat.zfs.misc.arcstats.mru_size"]
-    mfu_size = Kstat["kstat.zfs.misc.arcstats.mfu_size"]
-    meta_limit = Kstat["kstat.zfs.misc.arcstats.arc_meta_limit"]
-    meta_size = Kstat["kstat.zfs.misc.arcstats.arc_meta_used"]
-    dnode_limit = Kstat["kstat.zfs.misc.arcstats.arc_dnode_limit"]
-    dnode_size = Kstat["kstat.zfs.misc.arcstats.dnode_size"]
-    target_max_size = Kstat["kstat.zfs.misc.arcstats.c_max"]
-    target_min_size = Kstat["kstat.zfs.misc.arcstats.c_min"]
-    target_size = Kstat["kstat.zfs.misc.arcstats.c"]
-
-    target_size_ratio = (target_max_size / target_min_size)
-
-    # ARC Sizing
-    output['arc_sizing'] = {}
-    output['arc_sizing']['arc_size'] = {
-        'per': fPerc(arc_size, target_max_size),
-        'num': fBytes(arc_size),
-    }
-    output['arc_sizing']['target_max_size'] = {
-        'ratio': target_size_ratio,
-        'num': fBytes(target_max_size),
-    }
-    output['arc_sizing']['target_min_size'] = {
-        'per': fPerc(target_min_size, target_max_size),
-        'num': fBytes(target_min_size),
-    }
-    output['arc_sizing']['target_size'] = {
-        'per': fPerc(target_size, target_max_size),
-        'num': fBytes(target_size),
-    }
-    output['arc_sizing']['meta_limit'] = {
-        'per': fPerc(meta_limit, target_max_size),
-        'num': fBytes(meta_limit),
-    }
-    output['arc_sizing']['meta_size'] = {
-        'per': fPerc(meta_size, meta_limit),
-        'num': fBytes(meta_size),
-    }
-    output['arc_sizing']['dnode_limit'] = {
-        'per': fPerc(dnode_limit, meta_limit),
-        'num': fBytes(dnode_limit),
-    }
-    output['arc_sizing']['dnode_size'] = {
-        'per': fPerc(dnode_size, dnode_limit),
-        'num': fBytes(dnode_size),
-    }
-
-    # ARC Hash Breakdown
-    output['arc_hash_break'] = {}
-    output['arc_hash_break']['hash_chain_max'] = Kstat[
-        "kstat.zfs.misc.arcstats.hash_chain_max"
-        ]
-    output['arc_hash_break']['hash_chains'] = Kstat[
-        "kstat.zfs.misc.arcstats.hash_chains"
-        ]
-    output['arc_hash_break']['hash_collisions'] = Kstat[
-        "kstat.zfs.misc.arcstats.hash_collisions"
-        ]
-    output['arc_hash_break']['hash_elements'] = Kstat[
-        "kstat.zfs.misc.arcstats.hash_elements"
-        ]
-    output['arc_hash_break']['hash_elements_max'] = Kstat[
-        "kstat.zfs.misc.arcstats.hash_elements_max"
-        ]
-
-    output['arc_size_break'] = {}
-    output['arc_size_break']['recently_used_cache_size'] = {
-        'per': fPerc(mru_size, mru_size + mfu_size),
-        'num': fBytes(mru_size),
-    }
-    output['arc_size_break']['frequently_used_cache_size'] = {
-        'per': fPerc(mfu_size, mru_size + mfu_size),
-        'num': fBytes(mfu_size),
-    }
-
-    # ARC Hash Breakdown
-    hash_chain_max = Kstat["kstat.zfs.misc.arcstats.hash_chain_max"]
-    hash_chains = Kstat["kstat.zfs.misc.arcstats.hash_chains"]
-    hash_collisions = Kstat["kstat.zfs.misc.arcstats.hash_collisions"]
-    hash_elements = Kstat["kstat.zfs.misc.arcstats.hash_elements"]
-    hash_elements_max = Kstat["kstat.zfs.misc.arcstats.hash_elements_max"]
-
-    output['arc_hash_break'] = {}
-    output['arc_hash_break']['elements_max'] = fHits(hash_elements_max)
-    output['arc_hash_break']['elements_current'] = {
-        'per': fPerc(hash_elements, hash_elements_max),
-        'num': fHits(hash_elements),
-        }
-    output['arc_hash_break']['collisions'] = fHits(hash_collisions)
-    output['arc_hash_break']['chain_max'] = fHits(hash_chain_max)
-    output['arc_hash_break']['chains'] = fHits(hash_chains)
-
-    return output
-
-
-def _arc_summary(Kstat):
-    """Print information on the ARC"""
-
-    # ARC Sizing
-    arc = get_arc_summary(Kstat)
-
-    sys.stdout.write("ARC Summary: (%s)\n" % arc['health'])
-
-    sys.stdout.write("\tMemory Throttle Count:\t\t\t%s\n" %
-                     arc['memory_throttle_count'])
-    sys.stdout.write("\n")
-
-    # ARC Misc.
-    sys.stdout.write("ARC Misc:\n")
-    sys.stdout.write("\tDeleted:\t\t\t\t%s\n" % arc['arc_misc']['deleted'])
-    sys.stdout.write("\tMutex Misses:\t\t\t\t%s\n" %
-                     arc['arc_misc']['mutex_miss'])
-    sys.stdout.write("\tEviction Skips:\t\t\t\t%s\n" %
-                     arc['arc_misc']['evict_skips'])
-    sys.stdout.write("\tEviction Skips Due to L2 Writes:\t%s\n" %
-                     arc['arc_misc']['evict_l2_skip'])
-    sys.stdout.write("\tL2 Cached Evictions:\t\t\t%s\n" %
-                     arc['arc_misc']['evict_l2_cached'])
-    sys.stdout.write("\tL2 Eligible Evictions:\t\t\t%s\n" %
-                     arc['arc_misc']['evict_l2_eligible'])
-    sys.stdout.write("\tL2 Eligible MFU Evictions:\t%s\t%s\n" % (
-                     arc['arc_misc']['evict_l2_eligible_mfu']['per'],
-                     arc['arc_misc']['evict_l2_eligible_mfu']['num'],
-                     )
-    )
-    sys.stdout.write("\tL2 Eligible MRU Evictions:\t%s\t%s\n" % (
-                     arc['arc_misc']['evict_l2_eligible_mru']['per'],
-                     arc['arc_misc']['evict_l2_eligible_mru']['num'],
-                     )
-    )
-    sys.stdout.write("\tL2 Ineligible Evictions:\t\t%s\n" %
-                     arc['arc_misc']['evict_l2_ineligible'])
-    sys.stdout.write("\n")
-
-    # ARC Sizing
-    sys.stdout.write("ARC Size:\t\t\t\t%s\t%s\n" % (
-        arc['arc_sizing']['arc_size']['per'],
-        arc['arc_sizing']['arc_size']['num']
-        )
-    )
-    sys.stdout.write("\tTarget Size: (Adaptive)\t\t%s\t%s\n" % (
-        arc['arc_sizing']['target_size']['per'],
-        arc['arc_sizing']['target_size']['num'],
-        )
-    )
-
-    sys.stdout.write("\tMin Size (Hard Limit):\t\t%s\t%s\n" % (
-        arc['arc_sizing']['target_min_size']['per'],
-        arc['arc_sizing']['target_min_size']['num'],
-        )
-    )
-
-    sys.stdout.write("\tMax Size (High Water):\t\t%d:1\t%s\n" % (
-        arc['arc_sizing']['target_max_size']['ratio'],
-        arc['arc_sizing']['target_max_size']['num'],
-        )
-    )
-
-    sys.stdout.write("\nARC Size Breakdown:\n")
-    sys.stdout.write("\tRecently Used Cache Size:\t%s\t%s\n" % (
-        arc['arc_size_break']['recently_used_cache_size']['per'],
-        arc['arc_size_break']['recently_used_cache_size']['num'],
-        )
-    )
-    sys.stdout.write("\tFrequently Used Cache Size:\t%s\t%s\n" % (
-        arc['arc_size_break']['frequently_used_cache_size']['per'],
-        arc['arc_size_break']['frequently_used_cache_size']['num'],
-        )
-    )
-    sys.stdout.write("\tMetadata Size (Hard Limit):\t%s\t%s\n" % (
-        arc['arc_sizing']['meta_limit']['per'],
-        arc['arc_sizing']['meta_limit']['num'],
-        )
-    )
-    sys.stdout.write("\tMetadata Size:\t\t\t%s\t%s\n" % (
-        arc['arc_sizing']['meta_size']['per'],
-        arc['arc_sizing']['meta_size']['num'],
-        )
-    )
-    sys.stdout.write("\tDnode Size (Hard Limit):\t%s\t%s\n" % (
-        arc['arc_sizing']['dnode_limit']['per'],
-        arc['arc_sizing']['dnode_limit']['num'],
-        )
-    )
-    sys.stdout.write("\tDnode Size:\t\t\t%s\t%s\n" % (
-        arc['arc_sizing']['dnode_size']['per'],
-        arc['arc_sizing']['dnode_size']['num'],
-        )
-    )
-
-    sys.stdout.write("\n")
-
-    # ARC Hash Breakdown
-    sys.stdout.write("ARC Hash Breakdown:\n")
-    sys.stdout.write("\tElements Max:\t\t\t\t%s\n" %
-                     arc['arc_hash_break']['elements_max'])
-    sys.stdout.write("\tElements Current:\t\t%s\t%s\n" % (
-        arc['arc_hash_break']['elements_current']['per'],
-        arc['arc_hash_break']['elements_current']['num'],
-        )
-    )
-    sys.stdout.write("\tCollisions:\t\t\t\t%s\n" %
-                     arc['arc_hash_break']['collisions'])
-    sys.stdout.write("\tChain Max:\t\t\t\t%s\n" %
-                     arc['arc_hash_break']['chain_max'])
-    sys.stdout.write("\tChains:\t\t\t\t\t%s\n" %
-                     arc['arc_hash_break']['chains'])
-
-
-def get_arc_efficiency(Kstat):
-    """Collect information on the efficiency of the ARC"""
-
-    output = {}
-
-    arc_hits = Kstat["kstat.zfs.misc.arcstats.hits"]
-    arc_misses = Kstat["kstat.zfs.misc.arcstats.misses"]
-    demand_data_hits = Kstat["kstat.zfs.misc.arcstats.demand_data_hits"]
-    demand_data_misses = Kstat["kstat.zfs.misc.arcstats.demand_data_misses"]
-    demand_metadata_hits = Kstat[
-        "kstat.zfs.misc.arcstats.demand_metadata_hits"
-        ]
-    demand_metadata_misses = Kstat[
-        "kstat.zfs.misc.arcstats.demand_metadata_misses"
-        ]
-    mfu_ghost_hits = Kstat["kstat.zfs.misc.arcstats.mfu_ghost_hits"]
-    mfu_hits = Kstat["kstat.zfs.misc.arcstats.mfu_hits"]
-    mru_ghost_hits = Kstat["kstat.zfs.misc.arcstats.mru_ghost_hits"]
-    mru_hits = Kstat["kstat.zfs.misc.arcstats.mru_hits"]
-    prefetch_data_hits = Kstat["kstat.zfs.misc.arcstats.prefetch_data_hits"]
-    prefetch_data_misses = Kstat[
-        "kstat.zfs.misc.arcstats.prefetch_data_misses"
-        ]
-    prefetch_metadata_hits = Kstat[
-        "kstat.zfs.misc.arcstats.prefetch_metadata_hits"
-        ]
-    prefetch_metadata_misses = Kstat[
-        "kstat.zfs.misc.arcstats.prefetch_metadata_misses"
-        ]
-
-    anon_hits = arc_hits - (
-        mfu_hits + mru_hits + mfu_ghost_hits + mru_ghost_hits
-        )
-    arc_accesses_total = (arc_hits + arc_misses)
-    demand_data_total = (demand_data_hits + demand_data_misses)
-    prefetch_data_total = (prefetch_data_hits + prefetch_data_misses)
-    real_hits = (mfu_hits + mru_hits)
-
-    output["total_accesses"] = fHits(arc_accesses_total)
-    output["cache_hit_ratio"] = {
-        'per': fPerc(arc_hits, arc_accesses_total),
-        'num': fHits(arc_hits),
-    }
-    output["cache_miss_ratio"] = {
-        'per': fPerc(arc_misses, arc_accesses_total),
-        'num': fHits(arc_misses),
-    }
-    output["actual_hit_ratio"] = {
-        'per': fPerc(real_hits, arc_accesses_total),
-        'num': fHits(real_hits),
-    }
-    output["data_demand_efficiency"] = {
-        'per': fPerc(demand_data_hits, demand_data_total),
-        'num': fHits(demand_data_total),
-    }
-
-    if prefetch_data_total > 0:
-        output["data_prefetch_efficiency"] = {
-            'per': fPerc(prefetch_data_hits, prefetch_data_total),
-            'num': fHits(prefetch_data_total),
-        }
-
-    if anon_hits > 0:
-        output["cache_hits_by_cache_list"] = {}
-        output["cache_hits_by_cache_list"]["anonymously_used"] = {
-            'per': fPerc(anon_hits, arc_hits),
-            'num': fHits(anon_hits),
-        }
-
-    output["most_recently_used"] = {
-        'per': fPerc(mru_hits, arc_hits),
-        'num': fHits(mru_hits),
-    }
-    output["most_frequently_used"] = {
-        'per': fPerc(mfu_hits, arc_hits),
-        'num': fHits(mfu_hits),
-    }
-    output["most_recently_used_ghost"] = {
-        'per': fPerc(mru_ghost_hits, arc_hits),
-        'num': fHits(mru_ghost_hits),
-    }
-    output["most_frequently_used_ghost"] = {
-        'per': fPerc(mfu_ghost_hits, arc_hits),
-        'num': fHits(mfu_ghost_hits),
-    }
-
-    output["cache_hits_by_data_type"] = {}
-    output["cache_hits_by_data_type"]["demand_data"] = {
-        'per': fPerc(demand_data_hits, arc_hits),
-        'num': fHits(demand_data_hits),
-    }
-    output["cache_hits_by_data_type"]["prefetch_data"] = {
-        'per': fPerc(prefetch_data_hits, arc_hits),
-        'num': fHits(prefetch_data_hits),
-    }
-    output["cache_hits_by_data_type"]["demand_metadata"] = {
-        'per': fPerc(demand_metadata_hits, arc_hits),
-        'num': fHits(demand_metadata_hits),
-    }
-    output["cache_hits_by_data_type"]["prefetch_metadata"] = {
-        'per': fPerc(prefetch_metadata_hits, arc_hits),
-        'num': fHits(prefetch_metadata_hits),
-    }
-
-    output["cache_misses_by_data_type"] = {}
-    output["cache_misses_by_data_type"]["demand_data"] = {
-        'per': fPerc(demand_data_misses, arc_misses),
-        'num': fHits(demand_data_misses),
-    }
-    output["cache_misses_by_data_type"]["prefetch_data"] = {
-        'per': fPerc(prefetch_data_misses, arc_misses),
-        'num': fHits(prefetch_data_misses),
-    }
-    output["cache_misses_by_data_type"]["demand_metadata"] = {
-        'per': fPerc(demand_metadata_misses, arc_misses),
-        'num': fHits(demand_metadata_misses),
-    }
-    output["cache_misses_by_data_type"]["prefetch_metadata"] = {
-        'per': fPerc(prefetch_metadata_misses, arc_misses),
-        'num': fHits(prefetch_metadata_misses),
-    }
-
-    return output
-
-
-def _arc_efficiency(Kstat):
-    """Print information on the efficiency of the ARC"""
-
-    arc = get_arc_efficiency(Kstat)
-
-    sys.stdout.write("ARC Total accesses:\t\t\t\t\t%s\n" %
-                     arc['total_accesses'])
-    sys.stdout.write("\tCache Hit Ratio:\t\t%s\t%s\n" % (
-        arc['cache_hit_ratio']['per'],
-        arc['cache_hit_ratio']['num'],
-        )
-    )
-    sys.stdout.write("\tCache Miss Ratio:\t\t%s\t%s\n" % (
-        arc['cache_miss_ratio']['per'],
-        arc['cache_miss_ratio']['num'],
-        )
-    )
-
-    sys.stdout.write("\tActual Hit Ratio:\t\t%s\t%s\n" % (
-        arc['actual_hit_ratio']['per'],
-        arc['actual_hit_ratio']['num'],
-        )
-    )
-
-    sys.stdout.write("\n")
-    sys.stdout.write("\tData Demand Efficiency:\t\t%s\t%s\n" % (
-        arc['data_demand_efficiency']['per'],
-        arc['data_demand_efficiency']['num'],
-        )
-    )
-
-    if 'data_prefetch_efficiency' in arc:
-        sys.stdout.write("\tData Prefetch Efficiency:\t%s\t%s\n" % (
-            arc['data_prefetch_efficiency']['per'],
-            arc['data_prefetch_efficiency']['num'],
-            )
-        )
-    sys.stdout.write("\n")
-
-    sys.stdout.write("\tCACHE HITS BY CACHE LIST:\n")
-    if 'cache_hits_by_cache_list' in arc:
-        sys.stdout.write("\t  Anonymously Used:\t\t%s\t%s\n" % (
-            arc['cache_hits_by_cache_list']['anonymously_used']['per'],
-            arc['cache_hits_by_cache_list']['anonymously_used']['num'],
-            )
-        )
-    sys.stdout.write("\t  Most Recently Used:\t\t%s\t%s\n" % (
-        arc['most_recently_used']['per'],
-        arc['most_recently_used']['num'],
-        )
-    )
-    sys.stdout.write("\t  Most Frequently Used:\t\t%s\t%s\n" % (
-        arc['most_frequently_used']['per'],
-        arc['most_frequently_used']['num'],
-        )
-    )
-    sys.stdout.write("\t  Most Recently Used Ghost:\t%s\t%s\n" % (
-        arc['most_recently_used_ghost']['per'],
-        arc['most_recently_used_ghost']['num'],
-        )
-    )
-    sys.stdout.write("\t  Most Frequently Used Ghost:\t%s\t%s\n" % (
-        arc['most_frequently_used_ghost']['per'],
-        arc['most_frequently_used_ghost']['num'],
-        )
-    )
-
-    sys.stdout.write("\n\tCACHE HITS BY DATA TYPE:\n")
-    sys.stdout.write("\t  Demand Data:\t\t\t%s\t%s\n" % (
-        arc["cache_hits_by_data_type"]['demand_data']['per'],
-        arc["cache_hits_by_data_type"]['demand_data']['num'],
-        )
-    )
-    sys.stdout.write("\t  Prefetch Data:\t\t%s\t%s\n" % (
-        arc["cache_hits_by_data_type"]['prefetch_data']['per'],
-        arc["cache_hits_by_data_type"]['prefetch_data']['num'],
-        )
-    )
-    sys.stdout.write("\t  Demand Metadata:\t\t%s\t%s\n" % (
-        arc["cache_hits_by_data_type"]['demand_metadata']['per'],
-        arc["cache_hits_by_data_type"]['demand_metadata']['num'],
-        )
-    )
-    sys.stdout.write("\t  Prefetch Metadata:\t\t%s\t%s\n" % (
-        arc["cache_hits_by_data_type"]['prefetch_metadata']['per'],
-        arc["cache_hits_by_data_type"]['prefetch_metadata']['num'],
-        )
-    )
-
-    sys.stdout.write("\n\tCACHE MISSES BY DATA TYPE:\n")
-    sys.stdout.write("\t  Demand Data:\t\t\t%s\t%s\n" % (
-        arc["cache_misses_by_data_type"]['demand_data']['per'],
-        arc["cache_misses_by_data_type"]['demand_data']['num'],
-        )
-    )
-    sys.stdout.write("\t  Prefetch Data:\t\t%s\t%s\n" % (
-        arc["cache_misses_by_data_type"]['prefetch_data']['per'],
-        arc["cache_misses_by_data_type"]['prefetch_data']['num'],
-        )
-    )
-    sys.stdout.write("\t  Demand Metadata:\t\t%s\t%s\n" % (
-        arc["cache_misses_by_data_type"]['demand_metadata']['per'],
-        arc["cache_misses_by_data_type"]['demand_metadata']['num'],
-        )
-    )
-    sys.stdout.write("\t  Prefetch Metadata:\t\t%s\t%s\n" % (
-        arc["cache_misses_by_data_type"]['prefetch_metadata']['per'],
-        arc["cache_misses_by_data_type"]['prefetch_metadata']['num'],
-        )
-    )
-
-
-def get_l2arc_summary(Kstat):
-    """Collection information on the L2ARC"""
-
-    output = {}
-
-    l2_abort_lowmem = Kstat["kstat.zfs.misc.arcstats.l2_abort_lowmem"]
-    l2_cksum_bad = Kstat["kstat.zfs.misc.arcstats.l2_cksum_bad"]
-    l2_evict_lock_retry = Kstat["kstat.zfs.misc.arcstats.l2_evict_lock_retry"]
-    l2_evict_reading = Kstat["kstat.zfs.misc.arcstats.l2_evict_reading"]
-    l2_feeds = Kstat["kstat.zfs.misc.arcstats.l2_feeds"]
-    l2_free_on_write = Kstat["kstat.zfs.misc.arcstats.l2_free_on_write"]
-    l2_hdr_size = Kstat["kstat.zfs.misc.arcstats.l2_hdr_size"]
-    l2_hits = Kstat["kstat.zfs.misc.arcstats.l2_hits"]
-    l2_io_error = Kstat["kstat.zfs.misc.arcstats.l2_io_error"]
-    l2_misses = Kstat["kstat.zfs.misc.arcstats.l2_misses"]
-    l2_rw_clash = Kstat["kstat.zfs.misc.arcstats.l2_rw_clash"]
-    l2_size = Kstat["kstat.zfs.misc.arcstats.l2_size"]
-    l2_asize = Kstat["kstat.zfs.misc.arcstats.l2_asize"]
-    l2_writes_done = Kstat["kstat.zfs.misc.arcstats.l2_writes_done"]
-    l2_writes_error = Kstat["kstat.zfs.misc.arcstats.l2_writes_error"]
-    l2_writes_sent = Kstat["kstat.zfs.misc.arcstats.l2_writes_sent"]
-    l2_mfu_asize = Kstat["kstat.zfs.misc.arcstats.l2_mfu_asize"]
-    l2_mru_asize = Kstat["kstat.zfs.misc.arcstats.l2_mru_asize"]
-    l2_prefetch_asize = Kstat["kstat.zfs.misc.arcstats.l2_prefetch_asize"]
-    l2_bufc_data_asize = Kstat["kstat.zfs.misc.arcstats.l2_bufc_data_asize"]
-    l2_bufc_metadata_asize = Kstat["kstat.zfs.misc.arcstats.l2_bufc_metadata_asize"]
-
-    l2_access_total = (l2_hits + l2_misses)
-    output['l2_health_count'] = (l2_writes_error + l2_cksum_bad + l2_io_error)
-
-    output['l2_access_total'] = l2_access_total
-    output['l2_size'] = l2_size
-    output['l2_asize'] = l2_asize
-
-    if l2_size > 0 and l2_access_total > 0:
-
-        if output['l2_health_count'] > 0:
-            output["health"] = "DEGRADED"
-        else:
-            output["health"] = "HEALTHY"
-
-        output["low_memory_aborts"] = fHits(l2_abort_lowmem)
-        output["free_on_write"] = fHits(l2_free_on_write)
-        output["rw_clashes"] = fHits(l2_rw_clash)
-        output["bad_checksums"] = fHits(l2_cksum_bad)
-        output["io_errors"] = fHits(l2_io_error)
-
-        output["l2_arc_size"] = {}
-        output["l2_arc_size"]["adaptive"] = fBytes(l2_size)
-        output["l2_arc_size"]["actual"] = {
-            'per': fPerc(l2_asize, l2_size),
-            'num': fBytes(l2_asize)
-            }
-        output["l2_arc_size"]["head_size"] = {
-            'per': fPerc(l2_hdr_size, l2_size),
-            'num': fBytes(l2_hdr_size),
-        }
-        output["l2_arc_size"]["mfu_asize"] = {
-            'per': fPerc(l2_mfu_asize, l2_asize),
-            'num': fBytes(l2_mfu_asize),
-        }
-        output["l2_arc_size"]["mru_asize"] = {
-            'per': fPerc(l2_mru_asize, l2_asize),
-            'num': fBytes(l2_mru_asize),
-        }
-        output["l2_arc_size"]["prefetch_asize"] = {
-            'per': fPerc(l2_prefetch_asize, l2_asize),
-            'num': fBytes(l2_prefetch_asize),
-        }
-        output["l2_arc_size"]["bufc_data_asize"] = {
-            'per': fPerc(l2_bufc_data_asize, l2_asize),
-            'num': fBytes(l2_bufc_data_asize),
-        }
-        output["l2_arc_size"]["bufc_metadata_asize"] = {
-            'per': fPerc(l2_bufc_metadata_asize, l2_asize),
-            'num': fBytes(l2_bufc_metadata_asize),
-        }
-
-        output["l2_arc_evicts"] = {}
-        output["l2_arc_evicts"]['lock_retries'] = fHits(l2_evict_lock_retry)
-        output["l2_arc_evicts"]['reading'] = fHits(l2_evict_reading)
-
-        output['l2_arc_breakdown'] = {}
-        output['l2_arc_breakdown']['value'] = fHits(l2_access_total)
-        output['l2_arc_breakdown']['hit_ratio'] = {
-            'per': fPerc(l2_hits, l2_access_total),
-            'num': fHits(l2_hits),
-        }
-        output['l2_arc_breakdown']['miss_ratio'] = {
-            'per': fPerc(l2_misses, l2_access_total),
-            'num': fHits(l2_misses),
-        }
-        output['l2_arc_breakdown']['feeds'] = fHits(l2_feeds)
-
-        output['l2_arc_buffer'] = {}
-
-        output['l2_arc_writes'] = {}
-        output['l2_writes_done'] = l2_writes_done
-        output['l2_writes_sent'] = l2_writes_sent
-        if l2_writes_done != l2_writes_sent:
-            output['l2_arc_writes']['writes_sent'] = {
-                'value': "FAULTED",
-                'num': fHits(l2_writes_sent),
-            }
-            output['l2_arc_writes']['done_ratio'] = {
-                'per': fPerc(l2_writes_done, l2_writes_sent),
-                'num': fHits(l2_writes_done),
-            }
-            output['l2_arc_writes']['error_ratio'] = {
-                'per': fPerc(l2_writes_error, l2_writes_sent),
-                'num': fHits(l2_writes_error),
-            }
-        else:
-            output['l2_arc_writes']['writes_sent'] = {
-                'per': fPerc(100),
-                'num': fHits(l2_writes_sent),
-            }
-
-    return output
-
-
-def _l2arc_summary(Kstat):
-    """Print information on the L2ARC"""
-
-    arc = get_l2arc_summary(Kstat)
-
-    if arc['l2_size'] > 0 and arc['l2_access_total'] > 0:
-        sys.stdout.write("L2 ARC Summary: ")
-        if arc['l2_health_count'] > 0:
-            sys.stdout.write("(DEGRADED)\n")
-        else:
-            sys.stdout.write("(HEALTHY)\n")
-        sys.stdout.write("\tLow Memory Aborts:\t\t\t%s\n" %
-                         arc['low_memory_aborts'])
-        sys.stdout.write("\tFree on Write:\t\t\t\t%s\n" % arc['free_on_write'])
-        sys.stdout.write("\tR/W Clashes:\t\t\t\t%s\n" % arc['rw_clashes'])
-        sys.stdout.write("\tBad Checksums:\t\t\t\t%s\n" % arc['bad_checksums'])
-        sys.stdout.write("\tIO Errors:\t\t\t\t%s\n" % arc['io_errors'])
-        sys.stdout.write("\n")
-
-        sys.stdout.write("L2 ARC Size: (Adaptive)\t\t\t\t%s\n" %
-                         arc["l2_arc_size"]["adaptive"])
-        sys.stdout.write("\tCompressed:\t\t\t%s\t%s\n" % (
-            arc["l2_arc_size"]["actual"]["per"],
-            arc["l2_arc_size"]["actual"]["num"],
-            )
-        )
-        sys.stdout.write("\tHeader Size:\t\t\t%s\t%s\n" % (
-            arc["l2_arc_size"]["head_size"]["per"],
-            arc["l2_arc_size"]["head_size"]["num"],
-            )
-        )
-        sys.stdout.write("\tMFU Alloc. Size:\t\t%s\t%s\n" % (
-            arc["l2_arc_size"]["mfu_asize"]["per"],
-            arc["l2_arc_size"]["mfu_asize"]["num"],
-            )
-        )
-        sys.stdout.write("\tMRU Alloc. Size:\t\t%s\t%s\n" % (
-            arc["l2_arc_size"]["mru_asize"]["per"],
-            arc["l2_arc_size"]["mru_asize"]["num"],
-            )
-        )
-        sys.stdout.write("\tPrefetch Alloc. Size:\t\t%s\t%s\n" % (
-            arc["l2_arc_size"]["prefetch_asize"]["per"],
-            arc["l2_arc_size"]["prefetch_asize"]["num"],
-            )
-        )
-        sys.stdout.write("\tData (buf content) Alloc. Size:\t%s\t%s\n" % (
-            arc["l2_arc_size"]["bufc_data_asize"]["per"],
-            arc["l2_arc_size"]["bufc_data_asize"]["num"],
-            )
-        )
-        sys.stdout.write("\tMetadata (buf content) Size:\t%s\t%s\n" % (
-            arc["l2_arc_size"]["bufc_metadata_asize"]["per"],
-            arc["l2_arc_size"]["bufc_metadata_asize"]["num"],
-            )
-        )
-        sys.stdout.write("\n")
-
-        if arc["l2_arc_evicts"]['lock_retries'] != '0' or \
-           arc["l2_arc_evicts"]["reading"] != '0':
-            sys.stdout.write("L2 ARC Evictions:\n")
-            sys.stdout.write("\tLock Retries:\t\t\t\t%s\n" %
-                             arc["l2_arc_evicts"]['lock_retries'])
-            sys.stdout.write("\tUpon Reading:\t\t\t\t%s\n" %
-                             arc["l2_arc_evicts"]["reading"])
-            sys.stdout.write("\n")
-
-        sys.stdout.write("L2 ARC Breakdown:\t\t\t\t%s\n" %
-                         arc['l2_arc_breakdown']['value'])
-        sys.stdout.write("\tHit Ratio:\t\t\t%s\t%s\n" % (
-            arc['l2_arc_breakdown']['hit_ratio']['per'],
-            arc['l2_arc_breakdown']['hit_ratio']['num'],
-            )
-        )
-
-        sys.stdout.write("\tMiss Ratio:\t\t\t%s\t%s\n" % (
-            arc['l2_arc_breakdown']['miss_ratio']['per'],
-            arc['l2_arc_breakdown']['miss_ratio']['num'],
-            )
-        )
-
-        sys.stdout.write("\tFeeds:\t\t\t\t\t%s\n" %
-                         arc['l2_arc_breakdown']['feeds'])
-        sys.stdout.write("\n")
-
-        sys.stdout.write("L2 ARC Writes:\n")
-        if arc['l2_writes_done'] != arc['l2_writes_sent']:
-            sys.stdout.write("\tWrites Sent: (%s)\t\t\t\t%s\n" % (
-                arc['l2_arc_writes']['writes_sent']['value'],
-                arc['l2_arc_writes']['writes_sent']['num'],
-                )
-            )
-            sys.stdout.write("\t  Done Ratio:\t\t\t%s\t%s\n" % (
-                arc['l2_arc_writes']['done_ratio']['per'],
-                arc['l2_arc_writes']['done_ratio']['num'],
-                )
-            )
-            sys.stdout.write("\t  Error Ratio:\t\t\t%s\t%s\n" % (
-                arc['l2_arc_writes']['error_ratio']['per'],
-                arc['l2_arc_writes']['error_ratio']['num'],
-                )
-            )
-        else:
-            sys.stdout.write("\tWrites Sent:\t\t\t%s\t%s\n" % (
-                arc['l2_arc_writes']['writes_sent']['per'],
-                arc['l2_arc_writes']['writes_sent']['num'],
-                )
-            )
-
-
-def get_dmu_summary(Kstat):
-    """Collect information on the DMU"""
-
-    output = {}
-
-    zfetch_hits = Kstat["kstat.zfs.misc.zfetchstats.hits"]
-    zfetch_misses = Kstat["kstat.zfs.misc.zfetchstats.misses"]
-
-    zfetch_access_total = (zfetch_hits + zfetch_misses)
-    output['zfetch_access_total'] = zfetch_access_total
-
-    if zfetch_access_total > 0:
-        output['dmu'] = {}
-        output['dmu']['efficiency'] = {}
-        output['dmu']['efficiency']['value'] = fHits(zfetch_access_total)
-        output['dmu']['efficiency']['hit_ratio'] = {
-            'per': fPerc(zfetch_hits, zfetch_access_total),
-            'num': fHits(zfetch_hits),
-        }
-        output['dmu']['efficiency']['miss_ratio'] = {
-            'per': fPerc(zfetch_misses, zfetch_access_total),
-            'num': fHits(zfetch_misses),
-        }
-
-    return output
-
-
-def _dmu_summary(Kstat):
-    """Print information on the DMU"""
-
-    arc = get_dmu_summary(Kstat)
-
-    if arc['zfetch_access_total'] > 0:
-        sys.stdout.write("DMU Prefetch Efficiency:\t\t\t\t\t%s\n" %
-                         arc['dmu']['efficiency']['value'])
-        sys.stdout.write("\tHit Ratio:\t\t\t%s\t%s\n" % (
-            arc['dmu']['efficiency']['hit_ratio']['per'],
-            arc['dmu']['efficiency']['hit_ratio']['num'],
-            )
-        )
-        sys.stdout.write("\tMiss Ratio:\t\t\t%s\t%s\n" % (
-            arc['dmu']['efficiency']['miss_ratio']['per'],
-            arc['dmu']['efficiency']['miss_ratio']['num'],
-            )
-        )
-
-        sys.stdout.write("\n")
-
-
-def get_vdev_summary(Kstat):
-    """Collect information on the VDEVs"""
-
-    output = {}
-
-    vdev_cache_delegations = \
-        Kstat["kstat.zfs.misc.vdev_cache_stats.delegations"]
-    vdev_cache_misses = Kstat["kstat.zfs.misc.vdev_cache_stats.misses"]
-    vdev_cache_hits = Kstat["kstat.zfs.misc.vdev_cache_stats.hits"]
-    vdev_cache_total = (vdev_cache_misses + vdev_cache_hits +
-                        vdev_cache_delegations)
-
-    output['vdev_cache_total'] = vdev_cache_total
-
-    if vdev_cache_total > 0:
-        output['summary'] = fHits(vdev_cache_total)
-        output['hit_ratio'] = {
-            'per': fPerc(vdev_cache_hits, vdev_cache_total),
-            'num': fHits(vdev_cache_hits),
-        }
-        output['miss_ratio'] = {
-            'per': fPerc(vdev_cache_misses, vdev_cache_total),
-            'num': fHits(vdev_cache_misses),
-        }
-        output['delegations'] = {
-            'per': fPerc(vdev_cache_delegations, vdev_cache_total),
-            'num': fHits(vdev_cache_delegations),
-        }
-
-    return output
-
-
-def _vdev_summary(Kstat):
-    """Print information on the VDEVs"""
-
-    arc = get_vdev_summary(Kstat)
-
-    if arc['vdev_cache_total'] > 0:
-        sys.stdout.write("VDEV Cache Summary:\t\t\t\t%s\n" % arc['summary'])
-        sys.stdout.write("\tHit Ratio:\t\t\t%s\t%s\n" % (
-            arc['hit_ratio']['per'],
-            arc['hit_ratio']['num'],
-        ))
-        sys.stdout.write("\tMiss Ratio:\t\t\t%s\t%s\n" % (
-            arc['miss_ratio']['per'],
-            arc['miss_ratio']['num'],
-        ))
-        sys.stdout.write("\tDelegations:\t\t\t%s\t%s\n" % (
-            arc['delegations']['per'],
-            arc['delegations']['num'],
-        ))
-
-
-def _tunable_summary(Kstat):
-    """Print information on tunables, including descriptions if requested"""
-
-    global show_tunable_descriptions
-    global alternate_tunable_layout
-
-    tunables = load_tunables()
-    descriptions = {}
-
-    if show_tunable_descriptions:
-
-        command = ["/sbin/modinfo", "zfs", "-0"]
-
-        try:
-            p = Popen(command, stdin=PIPE, stdout=PIPE,
-                      stderr=PIPE, shell=False, close_fds=True)
-            p.wait()
-
-            # By default, Python 2 returns a string as the first element of the
-            # tuple from p.communicate(), while Python 3 returns bytes which
-            # must be decoded first. The better way to do this would be with
-            # subprocess.run() or at least .check_output(), but this fails on
-            # CentOS 6 because of its old version of Python 2
-            desc = bytes.decode(p.communicate()[0])
-            description_list = desc.strip().split('\0')
-
-            if p.returncode == 0:
-                for tunable in description_list:
-                    if tunable[0:5] == 'parm:':
-                        tunable = tunable[5:].strip()
-                        name, description = tunable.split(':', 1)
-                        if not description:
-                            description = "Description unavailable"
-                        descriptions[name] = description
-            else:
-                sys.stderr.write("%s: '%s' exited with code %i\n" %
-                                 (sys.argv[0], command[0], p.returncode))
-                sys.stderr.write("Tunable descriptions will be disabled.\n")
-        except OSError as e:
-            sys.stderr.write("%s: Cannot run '%s': %s\n" %
-                             (sys.argv[0], command[0], e.strerror))
-            sys.stderr.write("Tunable descriptions will be disabled.\n")
-
-    sys.stdout.write("ZFS Tunables:\n")
-
-    if alternate_tunable_layout:
-        fmt = "\t%s=%s\n"
-    else:
-        fmt = "\t%-50s%s\n"
-
-    for name in sorted(tunables.keys()):
-        if show_tunable_descriptions and name in descriptions:
-            sys.stdout.write("\t# %s\n" % descriptions[name])
-
-        sys.stdout.write(fmt % (name, tunables[name]))
-
-
-unSub = [
-    _arc_summary,
-    _arc_efficiency,
-    _l2arc_summary,
-    _dmu_summary,
-    _vdev_summary,
-    _tunable_summary
-]
-
-
-def zfs_header():
-    """Print title string with date"""
-
-    daydate = time.strftime('%a %b %d %H:%M:%S %Y')
-
-    sys.stdout.write('\n'+'-'*72+'\n')
-    sys.stdout.write('ZFS Subsystem Report\t\t\t\t%s' % daydate)
-    sys.stdout.write('\n')
-
-
-def usage():
-    """Print usage information"""
-
-    sys.stdout.write("Usage: arc_summary [-h] [-a] [-d] [-p PAGE]\n\n")
-    sys.stdout.write("\t -h, --help           : "
-                     "Print this help message and exit\n")
-    sys.stdout.write("\t -a, --alternate      : "
-                     "Show an alternate sysctl layout\n")
-    sys.stdout.write("\t -d, --description    : "
-                     "Show the sysctl descriptions\n")
-    sys.stdout.write("\t -p PAGE, --page=PAGE : "
-                     "Select a single output page to display,\n")
-    sys.stdout.write("\t                        "
-                     "should be an integer between 1 and " +
-                     str(len(unSub)) + "\n\n")
-    sys.stdout.write("Examples:\n")
-    sys.stdout.write("\tarc_summary -a\n")
-    sys.stdout.write("\tarc_summary -p 4\n")
-    sys.stdout.write("\tarc_summary -ad\n")
-    sys.stdout.write("\tarc_summary --page=2\n")
-
-
-def main():
-    """Main function"""
-
-    global show_tunable_descriptions
-    global alternate_tunable_layout
-
-    try:
-        try:
-            opts, args = getopt.getopt(
-                sys.argv[1:],
-                "adp:h", ["alternate", "description", "page=", "help"]
-            )
-        except getopt.error as e:
-            sys.stderr.write("Error: %s\n" % e.msg)
-            usage()
-            sys.exit(1)
-
-        args = {}
-        for opt, arg in opts:
-            if opt in ('-a', '--alternate'):
-                args['a'] = True
-            if opt in ('-d', '--description'):
-                args['d'] = True
-            if opt in ('-p', '--page'):
-                args['p'] = arg
-            if opt in ('-h', '--help'):
-                usage()
-                sys.exit(0)
-
-        Kstat = get_Kstat()
-
-        alternate_tunable_layout = 'a' in args
-        show_tunable_descriptions = 'd' in args
-
-        pages = []
-
-        if 'p' in args:
-            try:
-                pages.append(unSub[int(args['p']) - 1])
-            except IndexError:
-                sys.stderr.write('the argument to -p must be between 1 and ' +
-                                 str(len(unSub)) + '\n')
-                sys.exit(1)
-        else:
-            pages = unSub
-
-        zfs_header()
-        for page in pages:
-            page(Kstat)
-            sys.stdout.write("\n")
-    except IOError as ex:
-        if (ex.errno == errno.EPIPE):
-            sys.exit(0)
-        raise
-    except KeyboardInterrupt:
-        sys.exit(0)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/sys/contrib/openzfs/cmd/arc_summary/arc_summary3 b/sys/contrib/openzfs/cmd/arc_summary/arc_summary3
index 7b28012ede4d..4f275813d973 100755
--- a/sys/contrib/openzfs/cmd/arc_summary/arc_summary3
+++ b/sys/contrib/openzfs/cmd/arc_summary/arc_summary3
@@ -191,21 +191,13 @@ elif sys.platform.startswith('linux'):
         # there, so we fall back on modinfo
         command = ["/sbin/modinfo", request, "-0"]
 
-        # The recommended way to do this is with subprocess.run(). However,
-        # some installed versions of Python are < 3.5, so we offer them
-        # the option of doing it the old way (for now)
         info = ''
 
         try:
 
-            if 'run' in dir(subprocess):
-                info = subprocess.run(command, stdout=subprocess.PIPE,
-                                      universal_newlines=True)
-                raw_output = info.stdout.split('\0')
-            else:
-                info = subprocess.check_output(command,
-                                               universal_newlines=True)
-                raw_output = info.split('\0')
+            info = subprocess.run(command, stdout=subprocess.PIPE,
+                                  check=True, universal_newlines=True)
+            raw_output = info.stdout.split('\0')
 
         except subprocess.CalledProcessError:
             print("Error: Descriptions not available",
diff --git a/sys/contrib/openzfs/cmd/arcstat/arcstat.in b/sys/contrib/openzfs/cmd/arcstat/arcstat.in
index cd9a803a2414..9327f644f544 100755
--- a/sys/contrib/openzfs/cmd/arcstat/arcstat.in
+++ b/sys/contrib/openzfs/cmd/arcstat/arcstat.in
@@ -47,7 +47,7 @@
 # @hdr is the array of fields that needs to be printed, so we
 # just iterate over this array and print the values using our pretty printer.
 #
-# This script must remain compatible with Python 2.6+ and Python 3.4+.
+# This script must remain compatible with Python 3.6+.
 #
 
 import sys
diff --git a/sys/contrib/openzfs/cmd/dbufstat/dbufstat.in b/sys/contrib/openzfs/cmd/dbufstat/dbufstat.in
index 82250353f5eb..b716a0c9749b 100755
--- a/sys/contrib/openzfs/cmd/dbufstat/dbufstat.in
+++ b/sys/contrib/openzfs/cmd/dbufstat/dbufstat.in
@@ -27,7 +27,7 @@
 # Copyright (C) 2013 Lawrence Livermore National Security, LLC.
 # Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
 #
-# This script must remain compatible with Python 2.6+ and Python 3.4+.
+# This script must remain compatible with and Python 3.6+.
 #
 
 import sys
diff --git a/sys/contrib/openzfs/cmd/fsck_zfs/Makefile.am b/sys/contrib/openzfs/cmd/fsck_zfs/Makefile.am
index f8139f117ff2..d86ea1f786f4 100644
--- a/sys/contrib/openzfs/cmd/fsck_zfs/Makefile.am
+++ b/sys/contrib/openzfs/cmd/fsck_zfs/Makefile.am
@@ -4,3 +4,5 @@ include $(top_srcdir)/config/Shellcheck.am
 dist_sbin_SCRIPTS = fsck.zfs
 
 SUBSTFILES += $(dist_sbin_SCRIPTS)
+
+SHELLCHECK_OPTS = --enable=all
diff --git a/sys/contrib/openzfs/cmd/raidz_test/raidz_test.c b/sys/contrib/openzfs/cmd/raidz_test/raidz_test.c
index c1610a8d1b0c..b177105ee63b 100644
--- a/sys/contrib/openzfs/cmd/raidz_test/raidz_test.c
+++ b/sys/contrib/openzfs/cmd/raidz_test/raidz_test.c
@@ -266,12 +266,8 @@ cmp_data(raidz_test_opts_t *opts, raidz_map_t *rm)
 static int
 init_rand(void *data, size_t size, void *private)
 {
-	int i;
-	int *dst = (int *)data;
-
-	for (i = 0; i < size / sizeof (int); i++)
-		dst[i] = rand_data[i];
-
+	(void) private;
+	memcpy(data, rand_data, size);
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/cmd/zdb/zdb.c b/sys/contrib/openzfs/cmd/zdb/zdb.c
index 8fe926c50e85..c0b1a62a3182 100644
--- a/sys/contrib/openzfs/cmd/zdb/zdb.c
+++ b/sys/contrib/openzfs/cmd/zdb/zdb.c
@@ -39,6 +39,7 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <ctype.h>
+#include <getopt.h>
 #include <sys/zfs_context.h>
 #include <sys/spa.h>
 #include <sys/spa_impl.h>
@@ -383,10 +384,10 @@ livelist_verify(dsl_deadlist_t *dl, void *arg)
  * Check for errors in the livelist entry and discard the intermediary
  * data structures
  */
-/* ARGSUSED */
 static int
 sublivelist_verify_lightweight(void *args, dsl_deadlist_entry_t *dle)
 {
+	(void) args;
 	sublivelist_verify_t sv;
 	zfs_btree_create(&sv.sv_leftover, livelist_block_compare,
 	    sizeof (sublivelist_verify_block_t));
@@ -820,65 +821,87 @@ usage(void)
 	    "            z     ZAPs\n"
 	    "            -     Negate effect of next flag\n\n");
 	(void) fprintf(stderr, "    Options to control amount of output:\n");
-	(void) fprintf(stderr, "        -b block statistics\n");
-	(void) fprintf(stderr, "        -c checksum all metadata (twice for "
-	    "all data) blocks\n");
-	(void) fprintf(stderr, "        -C config (or cachefile if alone)\n");
-	(void) fprintf(stderr, "        -d dataset(s)\n");
-	(void) fprintf(stderr, "        -D dedup statistics\n");
-	(void) fprintf(stderr, "        -E decode and display block from an "
-	    "embedded block pointer\n");
-	(void) fprintf(stderr, "        -h pool history\n");
-	(void) fprintf(stderr, "        -i intent logs\n");
-	(void) fprintf(stderr, "        -l read label contents\n");
-	(void) fprintf(stderr, "        -k examine the checkpointed state "
-	    "of the pool\n");
-	(void) fprintf(stderr, "        -L disable leak tracking (do not "
-	    "load spacemaps)\n");
-	(void) fprintf(stderr, "        -m metaslabs\n");
-	(void) fprintf(stderr, "        -M metaslab groups\n");
-	(void) fprintf(stderr, "        -O perform object lookups by path\n");
-	(void) fprintf(stderr, "        -r copy an object by path to file\n");
-	(void) fprintf(stderr, "        -R read and display block from a "
-	    "device\n");
-	(void) fprintf(stderr, "        -s report stats on zdb's I/O\n");
-	(void) fprintf(stderr, "        -S simulate dedup to measure effect\n");
-	(void) fprintf(stderr, "        -v verbose (applies to all "
-	    "others)\n");
-	(void) fprintf(stderr, "        -y perform livelist and metaslab "
-	    "validation on any livelists being deleted\n\n");
+	(void) fprintf(stderr, "        -b --block-stats             "
+	    "block statistics\n");
+	(void) fprintf(stderr, "        -c --checksum                "
+	    "checksum all metadata (twice for all data) blocks\n");
+	(void) fprintf(stderr, "        -C --config                  "
+	    "config (or cachefile if alone)\n");
+	(void) fprintf(stderr, "        -d --datasets                "
+	    "dataset(s)\n");
+	(void) fprintf(stderr, "        -D --dedup-stats             "
+	    "dedup statistics\n");
+	(void) fprintf(stderr, "        -E --embedded-block-pointer=INTEGER\n"
+	    "                                     decode and display block "
+	    "from an embedded block pointer\n");
+	(void) fprintf(stderr, "        -h --history                 "
+	    "pool history\n");
+	(void) fprintf(stderr, "        -i --intent-logs             "
+	    "intent logs\n");
+	(void) fprintf(stderr, "        -l --label                   "
+	    "read label contents\n");
+	(void) fprintf(stderr, "        -k --checkpointed-state      "
+	    "examine the checkpointed state of the pool\n");
+	(void) fprintf(stderr, "        -L --disable-leak-tracking   "
+	    "disable leak tracking (do not load spacemaps)\n");
+	(void) fprintf(stderr, "        -m --metaslabs               "
+	    "metaslabs\n");
+	(void) fprintf(stderr, "        -M --metaslab-groups         "
+	    "metaslab groups\n");
+	(void) fprintf(stderr, "        -O --object-lookups          "
+	    "perform object lookups by path\n");
+	(void) fprintf(stderr, "        -r --copy-object             "
+	    "copy an object by path to file\n");
+	(void) fprintf(stderr, "        -R --read-block              "
+	    "read and display block from a device\n");
+	(void) fprintf(stderr, "        -s --io-stats                "
+	    "report stats on zdb's I/O\n");
+	(void) fprintf(stderr, "        -S --simulate-dedup          "
+	    "simulate dedup to measure effect\n");
+	(void) fprintf(stderr, "        -v --verbose                 "
+	    "verbose (applies to all others)\n");
+	(void) fprintf(stderr, "        -y --livelist                "
+	    "perform livelist and metaslab validation on any livelists being "
+	    "deleted\n\n");
 	(void) fprintf(stderr, "    Below options are intended for use "
 	    "with other options:\n");
-	(void) fprintf(stderr, "        -A ignore assertions (-A), enable "
-	    "panic recovery (-AA) or both (-AAA)\n");
-	(void) fprintf(stderr, "        -e pool is exported/destroyed/"
-	    "has altroot/not in a cachefile\n");
-	(void) fprintf(stderr, "        -F attempt automatic rewind within "
-	    "safe range of transaction groups\n");
-	(void) fprintf(stderr, "        -G dump zfs_dbgmsg buffer before "
-	    "exiting\n");
-	(void) fprintf(stderr, "        -I <number of inflight I/Os> -- "
-	    "specify the maximum number of\n           "
-	    "checksumming I/Os [default is 200]\n");
-	(void) fprintf(stderr, "        -o <variable>=<value> set global "
-	    "variable to an unsigned 32-bit integer\n");
-	(void) fprintf(stderr, "        -p <path> -- use one or more with "
-	    "-e to specify path to vdev dir\n");
-	(void) fprintf(stderr, "        -P print numbers in parseable form\n");
-	(void) fprintf(stderr, "        -q don't print label contents\n");
-	(void) fprintf(stderr, "        -t <txg> -- highest txg to use when "
-	    "searching for uberblocks\n");
-	(void) fprintf(stderr, "        -u uberblock\n");
-	(void) fprintf(stderr, "        -U <cachefile_path> -- use alternate "
-	    "cachefile\n");
-	(void) fprintf(stderr, "        -V do verbatim import\n");
-	(void) fprintf(stderr, "        -x <dumpdir> -- "
+	(void) fprintf(stderr, "        -A --ignore-assertions       "
+	    "ignore assertions (-A), enable panic recovery (-AA) or both "
+	    "(-AAA)\n");
+	(void) fprintf(stderr, "        -e --exported                "
+	    "pool is exported/destroyed/has altroot/not in a cachefile\n");
+	(void) fprintf(stderr, "        -F --automatic-rewind        "
+	    "attempt automatic rewind within safe range of transaction "
+	    "groups\n");
+	(void) fprintf(stderr, "        -G --dump-debug-msg          "
+	    "dump zfs_dbgmsg buffer before exiting\n");
+	(void) fprintf(stderr, "        -I --inflight=INTEGER        "
+	    "specify the maximum number of checksumming I/Os "
+	    "[default is 200]\n");
+	(void) fprintf(stderr, "        -o --option=\"OPTION=INTEGER\" "
+	    "set global variable to an unsigned 32-bit integer\n");
+	(void) fprintf(stderr, "        -p --path==PATH              "
+	    "use one or more with -e to specify path to vdev dir\n");
+	(void) fprintf(stderr, "        -P --parseable               "
+	    "print numbers in parseable form\n");
+	(void) fprintf(stderr, "        -q --skip-label              "
+	    "don't print label contents\n");
+	(void) fprintf(stderr, "        -t --txg=INTEGER             "
+	    "highest txg to use when searching for uberblocks\n");
+	(void) fprintf(stderr, "        -u --uberblock               "
+	    "uberblock\n");
+	(void) fprintf(stderr, "        -U --cachefile=PATH          "
+	    "use alternate cachefile\n");
+	(void) fprintf(stderr, "        -V --verbatim                "
+	    "do verbatim import\n");
+	(void) fprintf(stderr, "        -x --dump-blocks=PATH        "
 	    "dump all read blocks into specified directory\n");
-	(void) fprintf(stderr, "        -X attempt extreme rewind (does not "
-	    "work with dataset)\n");
-	(void) fprintf(stderr, "        -Y attempt all reconstruction "
-	    "combinations for split blocks\n");
-	(void) fprintf(stderr, "        -Z show ZSTD headers \n");
+	(void) fprintf(stderr, "        -X --extreme-rewind          "
+	    "attempt extreme rewind (does not work with dataset)\n");
+	(void) fprintf(stderr, "        -Y --all-reconstruction      "
+	    "attempt all reconstruction combinations for split blocks\n");
+	(void) fprintf(stderr, "        -Z --zstd-headers            "
+	    "show ZSTD headers \n");
 	(void) fprintf(stderr, "Specify an option more than once (e.g. -bb) "
 	    "to make only that option verbose\n");
 	(void) fprintf(stderr, "Default is to dump everything non-verbosely\n");
@@ -916,10 +939,10 @@ fatal(const char *fmt, ...)
 	exit(1);
 }
 
-/* ARGSUSED */
 static void
 dump_packed_nvlist(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) size;
 	nvlist_t *nv;
 	size_t nvsize = *(uint64_t *)data;
 	char *packed = umem_alloc(nvsize, UMEM_NOFAIL);
@@ -935,10 +958,10 @@ dump_packed_nvlist(objset_t *os, uint64_t object, void *data, size_t size)
 	nvlist_free(nv);
 }
 
-/* ARGSUSED */
 static void
 dump_history_offsets(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) size;
 	spa_history_phys_t *shp = data;
 
 	if (shp == NULL)
@@ -1058,26 +1081,25 @@ dump_zap_stats(objset_t *os, uint64_t object)
 	dump_histogram(zs.zs_buckets_with_n_entries, ZAP_HISTOGRAM_SIZE, 0);
 }
 
-/*ARGSUSED*/
 static void
 dump_none(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 }
 
-/*ARGSUSED*/
 static void
 dump_unknown(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 	(void) printf("\tUNKNOWN OBJECT TYPE\n");
 }
 
-/*ARGSUSED*/
 static void
 dump_uint8(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 }
 
-/*ARGSUSED*/
 static void
 dump_uint64(objset_t *os, uint64_t object, void *data, size_t size)
 {
@@ -1134,10 +1156,10 @@ dump_uint64(objset_t *os, uint64_t object, void *data, size_t size)
 		kmem_free(arr, oursize);
 }
 
-/*ARGSUSED*/
 static void
 dump_zap(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	zap_cursor_t zc;
 	zap_attribute_t attr;
 	void *prop;
@@ -1254,10 +1276,10 @@ dump_bpobj(objset_t *os, uint64_t object, void *data, size_t size)
 	}
 }
 
-/* ARGSUSED */
 static void
 dump_bpobj_subobjs(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	dmu_object_info_t doi;
 	int64_t i;
 
@@ -1283,18 +1305,18 @@ dump_bpobj_subobjs(objset_t *os, uint64_t object, void *data, size_t size)
 	kmem_free(subobjs, doi.doi_max_offset);
 }
 
-/*ARGSUSED*/
 static void
 dump_ddt_zap(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	dump_zap_stats(os, object);
 	/* contents are printed elsewhere, properly decoded */
 }
 
-/*ARGSUSED*/
 static void
 dump_sa_attrs(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	zap_cursor_t zc;
 	zap_attribute_t attr;
 
@@ -1318,10 +1340,10 @@ dump_sa_attrs(objset_t *os, uint64_t object, void *data, size_t size)
 	zap_cursor_fini(&zc);
 }
 
-/*ARGSUSED*/
 static void
 dump_sa_layouts(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	zap_cursor_t zc;
 	zap_attribute_t attr;
 	uint16_t *layout_attrs;
@@ -1356,10 +1378,10 @@ dump_sa_layouts(objset_t *os, uint64_t object, void *data, size_t size)
 	zap_cursor_fini(&zc);
 }
 
-/*ARGSUSED*/
 static void
 dump_zpldir(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	zap_cursor_t zc;
 	zap_attribute_t attr;
 	const char *typenames[] = {
@@ -2215,10 +2237,10 @@ dump_history(spa_t *spa)
 	free(buf);
 }
 
-/*ARGSUSED*/
 static void
 dump_dnode(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 }
 
 static uint64_t
@@ -2440,19 +2462,17 @@ visit_indirect(spa_t *spa, const dnode_phys_t *dnp,
 	return (err);
 }
 
-/*ARGSUSED*/
 static void
 dump_indirect(dnode_t *dn)
 {
 	dnode_phys_t *dnp = dn->dn_phys;
-	int j;
 	zbookmark_phys_t czb;
 
 	(void) printf("Indirect blocks:\n");
 
 	SET_BOOKMARK(&czb, dmu_objset_id(dn->dn_objset),
 	    dn->dn_object, dnp->dn_nlevels - 1, 0);
-	for (j = 0; j < dnp->dn_nblkptr; j++) {
+	for (int j = 0; j < dnp->dn_nblkptr; j++) {
 		czb.zb_blkid = j;
 		(void) visit_indirect(dmu_objset_spa(dn->dn_objset), dnp,
 		    &dnp->dn_blkptr[j], &czb);
@@ -2461,10 +2481,10 @@ dump_indirect(dnode_t *dn)
 	(void) printf("\n");
 }
 
-/*ARGSUSED*/
 static void
 dump_dsl_dir(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object;
 	dsl_dir_phys_t *dd = data;
 	time_t crtime;
 	char nice[32];
@@ -2518,10 +2538,10 @@ dump_dsl_dir(objset_t *os, uint64_t object, void *data, size_t size)
 	    (u_longlong_t)dd->dd_clones);
 }
 
-/*ARGSUSED*/
 static void
 dump_dsl_dataset(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object;
 	dsl_dataset_phys_t *ds = data;
 	time_t crtime;
 	char used[32], compressed[32], uncompressed[32], unique[32];
@@ -2581,10 +2601,10 @@ dump_dsl_dataset(objset_t *os, uint64_t object, void *data, size_t size)
 	(void) printf("\t\tbp = %s\n", blkbuf);
 }
 
-/* ARGSUSED */
 static int
 dump_bptree_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)
 {
+	(void) arg, (void) tx;
 	char blkbuf[BP_SPRINTF_LEN];
 
 	if (bp->blk_birth != 0) {
@@ -2622,10 +2642,10 @@ dump_bptree(objset_t *os, uint64_t obj, const char *name)
 	(void) bptree_iterate(os, obj, B_FALSE, dump_bptree_cb, NULL, NULL);
 }
 
-/* ARGSUSED */
 static int
 dump_bpobj_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)
 {
+	(void) arg, (void) tx;
 	char blkbuf[BP_SPRINTF_LEN];
 
 	ASSERT(bp->blk_birth != 0);
@@ -3187,10 +3207,10 @@ dump_znode_symlink(sa_handle_t *hdl)
 		(void) printf("\ttarget	%s\n", linktarget);
 }
 
-/*ARGSUSED*/
 static void
 dump_znode(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) data, (void) size;
 	char path[MAXPATHLEN * 2];	/* allow for xattr and failure prefix */
 	sa_handle_t *hdl;
 	uint64_t xattr, rdev, gen;
@@ -3282,16 +3302,16 @@ dump_znode(objset_t *os, uint64_t object, void *data, size_t size)
 	sa_handle_destroy(hdl);
 }
 
-/*ARGSUSED*/
 static void
 dump_acl(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 }
 
-/*ARGSUSED*/
 static void
 dump_dmu_objset(objset_t *os, uint64_t object, void *data, size_t size)
 {
+	(void) os, (void) object, (void) data, (void) size;
 }
 
 static object_viewer_t *object_viewer[DMU_OT_NUMTYPES + 1] = {
@@ -4985,10 +5005,10 @@ static uint64_t dataset_feature_count[SPA_FEATURES];
 static uint64_t global_feature_count[SPA_FEATURES];
 static uint64_t remap_deadlist_count = 0;
 
-/*ARGSUSED*/
 static int
 dump_one_objset(const char *dsname, void *arg)
 {
+	(void) arg;
 	int error;
 	objset_t *os;
 	spa_feature_t f;
@@ -5553,7 +5573,6 @@ static metaslab_ops_t zdb_metaslab_ops = {
 	NULL	/* alloc */
 };
 
-/* ARGSUSED */
 static int
 load_unflushed_svr_segs_cb(spa_t *spa, space_map_entry_t *sme,
     uint64_t txg, void *arg)
@@ -5582,11 +5601,12 @@ load_unflushed_svr_segs_cb(spa_t *spa, space_map_entry_t *sme,
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 claim_segment_impl_cb(uint64_t inner_offset, vdev_t *vd, uint64_t offset,
     uint64_t size, void *arg)
 {
+	(void) inner_offset, (void) arg;
+
 	/*
 	 * This callback was called through a remap from
 	 * a device being removed. Therefore, the vdev that
@@ -5660,11 +5680,11 @@ zdb_claim_removing(spa_t *spa, zdb_cb_t *zcb)
 	spa_config_exit(spa, SCL_CONFIG, FTAG);
 }
 
-/* ARGSUSED */
 static int
 increment_indirect_mapping_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,
     dmu_tx_t *tx)
 {
+	(void) tx;
 	zdb_cb_t *zcb = arg;
 	spa_t *spa = zcb->zcb_spa;
 	vdev_t *vd;
@@ -6276,10 +6296,10 @@ zdb_leak_fini(spa_t *spa, zdb_cb_t *zcb)
 	return (leaks);
 }
 
-/* ARGSUSED */
 static int
 count_block_cb(void *arg, const blkptr_t *bp, dmu_tx_t *tx)
 {
+	(void) tx;
 	zdb_cb_t *zcb = arg;
 
 	if (dump_opt['b'] >= 5) {
@@ -6736,11 +6756,11 @@ typedef struct zdb_ddt_entry {
 	avl_node_t	zdde_node;
 } zdb_ddt_entry_t;
 
-/* ARGSUSED */
 static int
 zdb_ddt_add_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) zilog, (void) dnp;
 	avl_tree_t *t = arg;
 	avl_index_t where;
 	zdb_ddt_entry_t *zdde, zdde_search;
@@ -7363,10 +7383,10 @@ verify_checkpoint(spa_t *spa)
 	return (error);
 }
 
-/* ARGSUSED */
 static void
 mos_leaks_cb(void *arg, uint64_t start, uint64_t size)
 {
+	(void) arg;
 	for (uint64_t i = start; i < size; i++) {
 		(void) printf("MOS object %llu referenced but not allocated\n",
 		    (u_longlong_t)i);
@@ -7967,6 +7987,7 @@ static boolean_t
 zdb_decompress_block(abd_t *pabd, void *buf, void *lbuf, uint64_t lsize,
     uint64_t psize, int flags)
 {
+	(void) buf;
 	boolean_t exceeded = B_FALSE;
 	/*
 	 * We don't know how the data was compressed, so just try
@@ -8368,6 +8389,23 @@ zdb_embedded_block(char *thing)
 	free(buf);
 }
 
+/* check for valid hex or decimal numeric string */
+static boolean_t
+zdb_numeric(char *str)
+{
+	int i = 0;
+
+	if (strlen(str) == 0)
+		return (B_FALSE);
+	if (strncmp(str, "0x", 2) == 0 || strncmp(str, "0X", 2) == 0)
+		i = 2;
+	for (; i < strlen(str); i++) {
+		if (!isxdigit(str[i]))
+			return (B_FALSE);
+	}
+	return (B_TRUE);
+}
+
 int
 main(int argc, char **argv)
 {
@@ -8412,8 +8450,51 @@ main(int argc, char **argv)
 	 */
 	zfs_btree_verify_intensity = 3;
 
-	while ((c = getopt(argc, argv,
-	    "AbcCdDeEFGhiI:klLmMo:Op:PqrRsSt:uU:vVx:XYyZ")) != -1) {
+	struct option long_options[] = {
+		{"ignore-assertions",	no_argument,		NULL, 'A'},
+		{"block-stats",		no_argument,		NULL, 'b'},
+		{"checksum",		no_argument,		NULL, 'c'},
+		{"config",		no_argument,		NULL, 'C'},
+		{"datasets",		no_argument,		NULL, 'd'},
+		{"dedup-stats",		no_argument,		NULL, 'D'},
+		{"exported",		no_argument,		NULL, 'e'},
+		{"embedded-block-pointer",	no_argument,	NULL, 'E'},
+		{"automatic-rewind",	no_argument,		NULL, 'F'},
+		{"dump-debug-msg",	no_argument,		NULL, 'G'},
+		{"history",		no_argument,		NULL, 'h'},
+		{"intent-logs",		no_argument,		NULL, 'i'},
+		{"inflight",		required_argument,	NULL, 'I'},
+		{"checkpointed-state",	no_argument,		NULL, 'k'},
+		{"label",		no_argument,		NULL, 'l'},
+		{"disable-leak-tracking",	no_argument,	NULL, 'L'},
+		{"metaslabs",		no_argument,		NULL, 'm'},
+		{"metaslab-groups",	no_argument,		NULL, 'M'},
+		{"numeric",		no_argument,		NULL, 'N'},
+		{"option",		required_argument,	NULL, 'o'},
+		{"object-lookups",	no_argument,		NULL, 'O'},
+		{"path",		required_argument,	NULL, 'p'},
+		{"parseable",		no_argument,		NULL, 'P'},
+		{"skip-label",		no_argument,		NULL, 'q'},
+		{"copy-object",		no_argument,		NULL, 'r'},
+		{"read-block",		no_argument,		NULL, 'R'},
+		{"io-stats",		no_argument,		NULL, 's'},
+		{"simulate-dedup",	no_argument,		NULL, 'S'},
+		{"txg",			required_argument,	NULL, 't'},
+		{"uberblock",		no_argument,		NULL, 'u'},
+		{"cachefile",		required_argument,	NULL, 'U'},
+		{"verbose",		no_argument,		NULL, 'v'},
+		{"verbatim",		no_argument,		NULL, 'V'},
+		{"dump-blocks",		required_argument,	NULL, 'x'},
+		{"extreme-rewind",	no_argument,		NULL, 'X'},
+		{"all-reconstruction",	no_argument,		NULL, 'Y'},
+		{"livelist",		no_argument,		NULL, 'y'},
+		{"zstd-headers",	no_argument,		NULL, 'Z'},
+		{0, 0, 0, 0}
+	};
+
+	while ((c = getopt_long(argc, argv,
+	    "AbcCdDeEFGhiI:klLmMNo:Op:PqrRsSt:uU:vVx:XYyZ",
+	    long_options, NULL)) != -1) {
 		switch (c) {
 		case 'b':
 		case 'c':
@@ -8427,6 +8508,7 @@ main(int argc, char **argv)
 		case 'l':
 		case 'm':
 		case 'M':
+		case 'N':
 		case 'O':
 		case 'r':
 		case 'R':
@@ -8518,32 +8600,6 @@ main(int argc, char **argv)
 		(void) fprintf(stderr, "-p option requires use of -e\n");
 		usage();
 	}
-	if (dump_opt['d'] || dump_opt['r']) {
-		/* <pool>[/<dataset | objset id> is accepted */
-		if (argv[2] && (objset_str = strchr(argv[2], '/')) != NULL &&
-		    objset_str++ != NULL) {
-			char *endptr;
-			errno = 0;
-			objset_id = strtoull(objset_str, &endptr, 0);
-			/* dataset 0 is the same as opening the pool */
-			if (errno == 0 && endptr != objset_str &&
-			    objset_id != 0) {
-				target_is_spa = B_FALSE;
-				dataset_lookup = B_TRUE;
-			} else if (objset_id != 0) {
-				printf("failed to open objset %s "
-				    "%llu %s", objset_str,
-				    (u_longlong_t)objset_id,
-				    strerror(errno));
-				exit(1);
-			}
-			/* normal dataset name not an objset ID */
-			if (endptr == objset_str) {
-				objset_id = -1;
-			}
-		}
-	}
-
 #if defined(_LP64)
 	/*
 	 * ZDB does not typically re-read blocks; therefore limit the ARC
@@ -8582,7 +8638,7 @@ main(int argc, char **argv)
 		verbose = MAX(verbose, 1);
 
 	for (c = 0; c < 256; c++) {
-		if (dump_all && strchr("AeEFklLOPrRSXy", c) == NULL)
+		if (dump_all && strchr("AeEFklLNOPrRSXy", c) == NULL)
 			dump_opt[c] = 1;
 		if (dump_opt[c])
 			dump_opt[c] += verbose;
@@ -8621,6 +8677,7 @@ main(int argc, char **argv)
 		return (dump_path(argv[0], argv[1], NULL));
 	}
 	if (dump_opt['r']) {
+		target_is_spa = B_FALSE;
 		if (argc != 3)
 			usage();
 		dump_opt['v'] = verbose;
@@ -8631,6 +8688,10 @@ main(int argc, char **argv)
 		rewind = ZPOOL_DO_REWIND |
 		    (dump_opt['X'] ? ZPOOL_EXTREME_REWIND : 0);
 
+	/* -N implies -d */
+	if (dump_opt['N'] && dump_opt['d'] == 0)
+		dump_opt['d'] = dump_opt['N'];
+
 	if (nvlist_alloc(&policy, NV_UNIQUE_NAME_TYPE, 0) != 0 ||
 	    nvlist_add_uint64(policy, ZPOOL_LOAD_REQUEST_TXG, max_txg) != 0 ||
 	    nvlist_add_uint32(policy, ZPOOL_LOAD_REWIND_POLICY, rewind) != 0)
@@ -8649,6 +8710,35 @@ main(int argc, char **argv)
 		targetlen = strlen(target);
 		if (targetlen && target[targetlen - 1] == '/')
 			target[targetlen - 1] = '\0';
+
+		/*
+		 * See if an objset ID was supplied (-d <pool>/<objset ID>).
+		 * To disambiguate tank/100, consider the 100 as objsetID
+		 * if -N was given, otherwise 100 is an objsetID iff
+		 * tank/100 as a named dataset fails on lookup.
+		 */
+		objset_str = strchr(target, '/');
+		if (objset_str && strlen(objset_str) > 1 &&
+		    zdb_numeric(objset_str + 1)) {
+			char *endptr;
+			errno = 0;
+			objset_str++;
+			objset_id = strtoull(objset_str, &endptr, 0);
+			/* dataset 0 is the same as opening the pool */
+			if (errno == 0 && endptr != objset_str &&
+			    objset_id != 0) {
+				if (dump_opt['N'])
+					dataset_lookup = B_TRUE;
+			}
+			/* normal dataset name not an objset ID */
+			if (endptr == objset_str) {
+				objset_id = -1;
+			}
+		} else if (objset_str && !zdb_numeric(objset_str + 1) &&
+		    dump_opt['N']) {
+			printf("Supply a numeric objset ID with -N\n");
+			exit(1);
+		}
 	} else {
 		target_pool = target;
 	}
@@ -8766,13 +8856,27 @@ main(int argc, char **argv)
 			}
 			return (error);
 		} else {
+			target_pool = strdup(target);
+			if (strpbrk(target, "/@") != NULL)
+				*strpbrk(target_pool, "/@") = '\0';
+
 			zdb_set_skip_mmp(target);
+			/*
+			 * If -N was supplied, the user has indicated that
+			 * zdb -d <pool>/<objsetID> is in effect.  Otherwise
+			 * we first assume that the dataset string is the
+			 * dataset name.  If dmu_objset_hold fails with the
+			 * dataset string, and we have an objset_id, retry the
+			 * lookup with the objsetID.
+			 */
+			boolean_t retry = B_TRUE;
+retry_lookup:
 			if (dataset_lookup == B_TRUE) {
 				/*
 				 * Use the supplied id to get the name
 				 * for open_objset.
 				 */
-				error = spa_open(target, &spa, FTAG);
+				error = spa_open(target_pool, &spa, FTAG);
 				if (error == 0) {
 					error = name_from_objset_id(spa,
 					    objset_id, dsname);
@@ -8781,10 +8885,23 @@ main(int argc, char **argv)
 						target = dsname;
 				}
 			}
-			if (error == 0)
+			if (error == 0) {
+				if (objset_id > 0 && retry) {
+					int err = dmu_objset_hold(target, FTAG,
+					    &os);
+					if (err) {
+						dataset_lookup = B_TRUE;
+						retry = B_FALSE;
+						goto retry_lookup;
+					} else {
+						dmu_objset_rele(os, FTAG);
+					}
+				}
 				error = open_objset(target, FTAG, &os);
+			}
 			if (error == 0)
 				spa = dmu_objset_spa(os);
+			free(target_pool);
 		}
 	}
 	nvlist_free(policy);
diff --git a/sys/contrib/openzfs/cmd/zdb/zdb_il.c b/sys/contrib/openzfs/cmd/zdb/zdb_il.c
index 553765b71716..d6f588d8316e 100644
--- a/sys/contrib/openzfs/cmd/zdb/zdb_il.c
+++ b/sys/contrib/openzfs/cmd/zdb/zdb_il.c
@@ -60,10 +60,10 @@ print_log_bp(const blkptr_t *bp, const char *prefix)
 	(void) printf("%s%s\n", prefix, blkbuf);
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_create(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog;
 	const lr_create_t *lr = arg;
 	time_t crtime = lr->lr_crtime[0];
 	char *name, *link;
@@ -96,20 +96,20 @@ zil_prt_rec_create(zilog_t *zilog, int txtype, const void *arg)
 	    (u_longlong_t)lr->lr_gen, (u_longlong_t)lr->lr_rdev);
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_remove(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_remove_t *lr = arg;
 
 	(void) printf("%sdoid %llu, name %s\n", tab_prefix,
 	    (u_longlong_t)lr->lr_doid, (char *)(lr + 1));
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_link(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_link_t *lr = arg;
 
 	(void) printf("%sdoid %llu, link_obj %llu, name %s\n", tab_prefix,
@@ -117,10 +117,10 @@ zil_prt_rec_link(zilog_t *zilog, int txtype, const void *arg)
 	    (char *)(lr + 1));
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_rename(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_rename_t *lr = arg;
 	char *snm = (char *)(lr + 1);
 	char *tnm = snm + strlen(snm) + 1;
@@ -130,10 +130,10 @@ zil_prt_rec_rename(zilog_t *zilog, int txtype, const void *arg)
 	(void) printf("%ssrc %s tgt %s\n", tab_prefix, snm, tnm);
 }
 
-/* ARGSUSED */
 static int
 zil_prt_rec_write_cb(void *data, size_t len, void *unused)
 {
+	(void) unused;
 	char *cdata = data;
 
 	for (size_t i = 0; i < len; i++) {
@@ -146,7 +146,6 @@ zil_prt_rec_write_cb(void *data, size_t len, void *unused)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_write(zilog_t *zilog, int txtype, const void *arg)
 {
@@ -209,10 +208,10 @@ zil_prt_rec_write(zilog_t *zilog, int txtype, const void *arg)
 	abd_free(data);
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_truncate(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_truncate_t *lr = arg;
 
 	(void) printf("%sfoid %llu, offset 0x%llx, length 0x%llx\n", tab_prefix,
@@ -220,10 +219,10 @@ zil_prt_rec_truncate(zilog_t *zilog, int txtype, const void *arg)
 	    (u_longlong_t)lr->lr_length);
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_setattr(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_setattr_t *lr = arg;
 	time_t atime = (time_t)lr->lr_atime[0];
 	time_t mtime = (time_t)lr->lr_mtime[0];
@@ -266,10 +265,10 @@ zil_prt_rec_setattr(zilog_t *zilog, int txtype, const void *arg)
 	}
 }
 
-/* ARGSUSED */
 static void
 zil_prt_rec_acl(zilog_t *zilog, int txtype, const void *arg)
 {
+	(void) zilog, (void) txtype;
 	const lr_acl_t *lr = arg;
 
 	(void) printf("%sfoid %llu, aclcnt %llu\n", tab_prefix,
@@ -307,10 +306,10 @@ static zil_rec_info_t zil_rec_info[TX_MAX_TYPE] = {
 	{.zri_print = zil_prt_rec_write,    .zri_name = "TX_WRITE2          "},
 };
 
-/* ARGSUSED */
 static int
 print_log_record(zilog_t *zilog, const lr_t *lr, void *arg, uint64_t claim_txg)
 {
+	(void) arg, (void) claim_txg;
 	int txtype;
 	int verbose = MAX(dump_opt['d'], dump_opt['i']);
 
@@ -341,11 +340,11 @@ print_log_record(zilog_t *zilog, const lr_t *lr, void *arg, uint64_t claim_txg)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 print_log_block(zilog_t *zilog, const blkptr_t *bp, void *arg,
     uint64_t claim_txg)
 {
+	(void) arg;
 	char blkbuf[BP_SPRINTF_LEN + 10];
 	int verbose = MAX(dump_opt['d'], dump_opt['i']);
 	const char *claim;
@@ -396,7 +395,6 @@ print_log_stats(int verbose)
 	(void) printf("\n");
 }
 
-/* ARGSUSED */
 void
 dump_intent_log(zilog_t *zilog)
 {
diff --git a/sys/contrib/openzfs/cmd/zed/Makefile.am b/sys/contrib/openzfs/cmd/zed/Makefile.am
index 7b662994d1c6..1492123e1696 100644
--- a/sys/contrib/openzfs/cmd/zed/Makefile.am
+++ b/sys/contrib/openzfs/cmd/zed/Makefile.am
@@ -5,6 +5,7 @@ AM_CFLAGS += $(LIBUDEV_CFLAGS) $(LIBUUID_CFLAGS)
 
 SUBDIRS = zed.d
 SHELLCHECKDIRS = $(SUBDIRS)
+SHELLCHECK_OPTS = --enable=all
 
 sbin_PROGRAMS = zed
 
diff --git a/sys/contrib/openzfs/cmd/zed/agents/fmd_api.c b/sys/contrib/openzfs/cmd/zed/agents/fmd_api.c
index c9231fba2aee..4095901dff0d 100644
--- a/sys/contrib/openzfs/cmd/zed/agents/fmd_api.c
+++ b/sys/contrib/openzfs/cmd/zed/agents/fmd_api.c
@@ -97,6 +97,7 @@ _umem_logging_init(void)
 int
 fmd_hdl_register(fmd_hdl_t *hdl, int version, const fmd_hdl_info_t *mip)
 {
+	(void) version;
 	fmd_module_t *mp = (fmd_module_t *)hdl;
 
 	mp->mod_info = mip;
@@ -179,18 +180,21 @@ fmd_hdl_getspecific(fmd_hdl_t *hdl)
 void *
 fmd_hdl_alloc(fmd_hdl_t *hdl, size_t size, int flags)
 {
+	(void) hdl;
 	return (umem_alloc(size, flags));
 }
 
 void *
 fmd_hdl_zalloc(fmd_hdl_t *hdl, size_t size, int flags)
 {
+	(void) hdl;
 	return (umem_zalloc(size, flags));
 }
 
 void
 fmd_hdl_free(fmd_hdl_t *hdl, void *data, size_t size)
 {
+	(void) hdl;
 	umem_free(data, size);
 }
 
@@ -217,6 +221,8 @@ fmd_hdl_debug(fmd_hdl_t *hdl, const char *format, ...)
 int32_t
 fmd_prop_get_int32(fmd_hdl_t *hdl, const char *name)
 {
+	(void) hdl;
+
 	/*
 	 * These can be looked up in mp->modinfo->fmdi_props
 	 * For now we just hard code for phase 2. In the
@@ -234,6 +240,8 @@ fmd_prop_get_int32(fmd_hdl_t *hdl, const char *name)
 int64_t
 fmd_prop_get_int64(fmd_hdl_t *hdl, const char *name)
 {
+	(void) hdl;
+
 	/*
 	 * These can be looked up in mp->modinfo->fmdi_props
 	 * For now we just hard code for phase 2. In the
@@ -337,12 +345,14 @@ fmd_case_uuresolved(fmd_hdl_t *hdl, const char *uuid)
 int
 fmd_case_solved(fmd_hdl_t *hdl, fmd_case_t *cp)
 {
+	(void) hdl;
 	return ((cp->ci_state >= FMD_CASE_SOLVED) ? FMD_B_TRUE : FMD_B_FALSE);
 }
 
 void
 fmd_case_add_ereport(fmd_hdl_t *hdl, fmd_case_t *cp, fmd_event_t *ep)
 {
+	(void) hdl, (void) cp, (void) ep;
 }
 
 static void
@@ -444,19 +454,21 @@ fmd_case_add_suspect(fmd_hdl_t *hdl, fmd_case_t *cp, nvlist_t *fault)
 void
 fmd_case_setspecific(fmd_hdl_t *hdl, fmd_case_t *cp, void *data)
 {
+	(void) hdl;
 	cp->ci_data = data;
 }
 
 void *
 fmd_case_getspecific(fmd_hdl_t *hdl, fmd_case_t *cp)
 {
+	(void) hdl;
 	return (cp->ci_data);
 }
 
 void
 fmd_buf_create(fmd_hdl_t *hdl, fmd_case_t *cp, const char *name, size_t size)
 {
-	assert(strcmp(name, "data") == 0);
+	assert(strcmp(name, "data") == 0), (void) name;
 	assert(cp->ci_bufptr == NULL);
 	assert(size < (1024 * 1024));
 
@@ -468,7 +480,8 @@ void
 fmd_buf_read(fmd_hdl_t *hdl, fmd_case_t *cp,
     const char *name, void *buf, size_t size)
 {
-	assert(strcmp(name, "data") == 0);
+	(void) hdl;
+	assert(strcmp(name, "data") == 0), (void) name;
 	assert(cp->ci_bufptr != NULL);
 	assert(size <= cp->ci_bufsiz);
 
@@ -479,7 +492,8 @@ void
 fmd_buf_write(fmd_hdl_t *hdl, fmd_case_t *cp,
     const char *name, const void *buf, size_t size)
 {
-	assert(strcmp(name, "data") == 0);
+	(void) hdl;
+	assert(strcmp(name, "data") == 0), (void) name;
 	assert(cp->ci_bufptr != NULL);
 	assert(cp->ci_bufsiz >= size);
 
@@ -583,6 +597,7 @@ _timer_notify(union sigval sv)
 fmd_timer_t *
 fmd_timer_install(fmd_hdl_t *hdl, void *arg, fmd_event_t *ep, hrtime_t delta)
 {
+	(void) ep;
 	struct sigevent sev;
 	struct itimerspec its;
 	fmd_timer_t *ftp;
@@ -626,6 +641,7 @@ nvlist_t *
 fmd_nvl_create_fault(fmd_hdl_t *hdl, const char *class, uint8_t certainty,
     nvlist_t *asru, nvlist_t *fru, nvlist_t *resource)
 {
+	(void) hdl;
 	nvlist_t *nvl;
 	int err = 0;
 
@@ -689,6 +705,7 @@ fmd_strmatch(const char *s, const char *p)
 int
 fmd_nvl_class_match(fmd_hdl_t *hdl, nvlist_t *nvl, const char *pattern)
 {
+	(void) hdl;
 	char *class;
 
 	return (nvl != NULL &&
@@ -699,6 +716,7 @@ fmd_nvl_class_match(fmd_hdl_t *hdl, nvlist_t *nvl, const char *pattern)
 nvlist_t *
 fmd_nvl_alloc(fmd_hdl_t *hdl, int flags)
 {
+	(void) hdl, (void) flags;
 	nvlist_t *nvl = NULL;
 
 	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)
diff --git a/sys/contrib/openzfs/cmd/zed/agents/zfs_agents.c b/sys/contrib/openzfs/cmd/zed/agents/zfs_agents.c
index 35dd818ff80d..2bc84a4f57d1 100644
--- a/sys/contrib/openzfs/cmd/zed/agents/zfs_agents.c
+++ b/sys/contrib/openzfs/cmd/zed/agents/zfs_agents.c
@@ -327,6 +327,8 @@ zfs_agent_dispatch(const char *class, const char *subclass, nvlist_t *nvl)
 static void *
 zfs_agent_consumer_thread(void *arg)
 {
+	(void) arg;
+
 	for (;;) {
 		agent_event_t *event;
 
diff --git a/sys/contrib/openzfs/cmd/zed/agents/zfs_diagnosis.c b/sys/contrib/openzfs/cmd/zed/agents/zfs_diagnosis.c
index 0b27f6702ee8..3e45a957f703 100644
--- a/sys/contrib/openzfs/cmd/zed/agents/zfs_diagnosis.c
+++ b/sys/contrib/openzfs/cmd/zed/agents/zfs_diagnosis.c
@@ -119,7 +119,7 @@ uu_list_t *zfs_cases;
  * Write out the persistent representation of an active case.
  */
 static void
-zfs_case_serialize(fmd_hdl_t *hdl, zfs_case_t *zcp)
+zfs_case_serialize(zfs_case_t *zcp)
 {
 	zcp->zc_data.zc_version = CASE_DATA_VERSION_SERD;
 }
@@ -209,10 +209,10 @@ zfs_mark_vdev(uint64_t pool_guid, nvlist_t *vd, er_timeval_t *loaded)
 	}
 }
 
-/*ARGSUSED*/
 static int
 zfs_mark_pool(zpool_handle_t *zhp, void *unused)
 {
+	(void) unused;
 	zfs_case_t *zcp;
 	uint64_t pool_guid;
 	uint64_t *tod;
@@ -373,8 +373,7 @@ zfs_serd_name(char *buf, uint64_t pool_guid, uint64_t vdev_guid,
  * case.
  */
 static void
-zfs_case_solve(fmd_hdl_t *hdl, zfs_case_t *zcp, const char *faultname,
-    boolean_t checkunusable)
+zfs_case_solve(fmd_hdl_t *hdl, zfs_case_t *zcp, const char *faultname)
 {
 	nvlist_t *detector, *fault;
 	boolean_t serialize;
@@ -412,7 +411,7 @@ zfs_case_solve(fmd_hdl_t *hdl, zfs_case_t *zcp, const char *faultname,
 		serialize = B_TRUE;
 	}
 	if (serialize)
-		zfs_case_serialize(hdl, zcp);
+		zfs_case_serialize(zcp);
 
 	nvlist_free(detector);
 }
@@ -424,10 +423,10 @@ timeval_earlier(er_timeval_t *a, er_timeval_t *b)
 	    (a->ertv_sec == b->ertv_sec && a->ertv_nsec < b->ertv_nsec));
 }
 
-/*ARGSUSED*/
 static void
 zfs_ereport_when(fmd_hdl_t *hdl, nvlist_t *nvl, er_timeval_t *when)
 {
+	(void) hdl;
 	int64_t *tod;
 	uint_t	nelem;
 
@@ -443,7 +442,6 @@ zfs_ereport_when(fmd_hdl_t *hdl, nvlist_t *nvl, er_timeval_t *when)
 /*
  * Main fmd entry point.
  */
-/*ARGSUSED*/
 static void
 zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 {
@@ -686,7 +684,7 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			if (zcp->zc_data.zc_has_remove_timer) {
 				fmd_timer_remove(hdl, zcp->zc_remove_timer);
 				zcp->zc_data.zc_has_remove_timer = 0;
-				zfs_case_serialize(hdl, zcp);
+				zfs_case_serialize(zcp);
 			}
 			if (zcp->zc_data.zc_serd_io[0] != '\0')
 				fmd_serd_reset(hdl, zcp->zc_data.zc_serd_io);
@@ -751,18 +749,18 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 				fmd_case_close(hdl, dcp->zc_case);
 		}
 
-		zfs_case_solve(hdl, zcp, "fault.fs.zfs.pool", B_TRUE);
+		zfs_case_solve(hdl, zcp, "fault.fs.zfs.pool");
 	} else if (fmd_nvl_class_match(hdl, nvl,
 	    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_LOG_REPLAY))) {
 		/*
 		 * Pool level fault for reading the intent logs.
 		 */
-		zfs_case_solve(hdl, zcp, "fault.fs.zfs.log_replay", B_TRUE);
+		zfs_case_solve(hdl, zcp, "fault.fs.zfs.log_replay");
 	} else if (fmd_nvl_class_match(hdl, nvl, "ereport.fs.zfs.vdev.*")) {
 		/*
 		 * Device fault.
 		 */
-		zfs_case_solve(hdl, zcp, "fault.fs.zfs.device",  B_TRUE);
+		zfs_case_solve(hdl, zcp, "fault.fs.zfs.device");
 	} else if (fmd_nvl_class_match(hdl, nvl,
 	    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO)) ||
 	    fmd_nvl_class_match(hdl, nvl,
@@ -789,7 +787,7 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 				fmd_serd_create(hdl, zcp->zc_data.zc_serd_io,
 				    fmd_prop_get_int32(hdl, "io_N"),
 				    fmd_prop_get_int64(hdl, "io_T"));
-				zfs_case_serialize(hdl, zcp);
+				zfs_case_serialize(zcp);
 			}
 			if (fmd_serd_record(hdl, zcp->zc_data.zc_serd_io, ep))
 				checkremove = B_TRUE;
@@ -802,12 +800,12 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 				    zcp->zc_data.zc_serd_checksum,
 				    fmd_prop_get_int32(hdl, "checksum_N"),
 				    fmd_prop_get_int64(hdl, "checksum_T"));
-				zfs_case_serialize(hdl, zcp);
+				zfs_case_serialize(zcp);
 			}
 			if (fmd_serd_record(hdl,
 			    zcp->zc_data.zc_serd_checksum, ep)) {
 				zfs_case_solve(hdl, zcp,
-				    "fault.fs.zfs.vdev.checksum", B_FALSE);
+				    "fault.fs.zfs.vdev.checksum");
 			}
 		} else if (fmd_nvl_class_match(hdl, nvl,
 		    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_IO_FAILURE)) &&
@@ -817,12 +815,11 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			if (strncmp(failmode, FM_EREPORT_FAILMODE_CONTINUE,
 			    strlen(FM_EREPORT_FAILMODE_CONTINUE)) == 0) {
 				zfs_case_solve(hdl, zcp,
-				    "fault.fs.zfs.io_failure_continue",
-				    B_FALSE);
+				    "fault.fs.zfs.io_failure_continue");
 			} else if (strncmp(failmode, FM_EREPORT_FAILMODE_WAIT,
 			    strlen(FM_EREPORT_FAILMODE_WAIT)) == 0) {
 				zfs_case_solve(hdl, zcp,
-				    "fault.fs.zfs.io_failure_wait", B_FALSE);
+				    "fault.fs.zfs.io_failure_wait");
 			}
 		} else if (fmd_nvl_class_match(hdl, nvl,
 		    ZFS_MAKE_EREPORT(FM_EREPORT_ZFS_PROBE_FAILURE))) {
@@ -844,7 +841,7 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
 			    zfs_remove_timeout);
 			if (!zcp->zc_data.zc_has_remove_timer) {
 				zcp->zc_data.zc_has_remove_timer = 1;
-				zfs_case_serialize(hdl, zcp);
+				zfs_case_serialize(zcp);
 			}
 		}
 	}
@@ -854,14 +851,13 @@ zfs_fm_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl, const char *class)
  * The timeout is fired when we diagnosed an I/O error, and it was not due to
  * device removal (which would cause the timeout to be cancelled).
  */
-/* ARGSUSED */
 static void
 zfs_fm_timeout(fmd_hdl_t *hdl, id_t id, void *data)
 {
 	zfs_case_t *zcp = data;
 
 	if (id == zcp->zc_remove_timer)
-		zfs_case_solve(hdl, zcp, "fault.fs.zfs.vdev.io", B_FALSE);
+		zfs_case_solve(hdl, zcp, "fault.fs.zfs.vdev.io");
 }
 
 /*
diff --git a/sys/contrib/openzfs/cmd/zed/agents/zfs_mod.c b/sys/contrib/openzfs/cmd/zed/agents/zfs_mod.c
index b496b29ac136..c62a976c2e3f 100644
--- a/sys/contrib/openzfs/cmd/zed/agents/zfs_mod.c
+++ b/sys/contrib/openzfs/cmd/zed/agents/zfs_mod.c
@@ -681,7 +681,7 @@ guid_iter(uint64_t pool_guid, uint64_t vdev_guid, const char *devid,
  * phys_path: 'pci-0000:04:00.0-sas-0x4433221106000000-lun-0'
  */
 static int
-zfs_deliver_add(nvlist_t *nvl, boolean_t is_lofi)
+zfs_deliver_add(nvlist_t *nvl)
 {
 	char *devpath = NULL, *devid;
 	uint64_t pool_guid = 0, vdev_guid = 0;
@@ -866,18 +866,15 @@ static int
 zfs_slm_deliver_event(const char *class, const char *subclass, nvlist_t *nvl)
 {
 	int ret;
-	boolean_t is_lofi = B_FALSE, is_check = B_FALSE, is_dle = B_FALSE;
+	boolean_t is_check = B_FALSE, is_dle = B_FALSE;
 
 	if (strcmp(class, EC_DEV_ADD) == 0) {
 		/*
 		 * We're mainly interested in disk additions, but we also listen
 		 * for new loop devices, to allow for simplified testing.
 		 */
-		if (strcmp(subclass, ESC_DISK) == 0)
-			is_lofi = B_FALSE;
-		else if (strcmp(subclass, ESC_LOFI) == 0)
-			is_lofi = B_TRUE;
-		else
+		if (strcmp(subclass, ESC_DISK) != 0 &&
+		    strcmp(subclass, ESC_LOFI) != 0)
 			return (0);
 
 		is_check = B_FALSE;
@@ -901,15 +898,16 @@ zfs_slm_deliver_event(const char *class, const char *subclass, nvlist_t *nvl)
 	else if (is_check)
 		ret = zfs_deliver_check(nvl);
 	else
-		ret = zfs_deliver_add(nvl, is_lofi);
+		ret = zfs_deliver_add(nvl);
 
 	return (ret);
 }
 
-/*ARGSUSED*/
 static void *
 zfs_enum_pools(void *arg)
 {
+	(void) arg;
+
 	(void) zpool_iter(g_zfshdl, zfs_unavail_pool, (void *)&g_pool_list);
 	/*
 	 * Linux - instead of using a thread pool, each list entry
diff --git a/sys/contrib/openzfs/cmd/zed/agents/zfs_retire.c b/sys/contrib/openzfs/cmd/zed/agents/zfs_retire.c
index 5fb7b4e84c5e..8f12bb82e1e4 100644
--- a/sys/contrib/openzfs/cmd/zed/agents/zfs_retire.c
+++ b/sys/contrib/openzfs/cmd/zed/agents/zfs_retire.c
@@ -263,7 +263,6 @@ replace_with_spare(fmd_hdl_t *hdl, zpool_handle_t *zhp, nvlist_t *vdev)
  * ASRU is now usable.  ZFS has found the device to be present and
  * functioning.
  */
-/*ARGSUSED*/
 static void
 zfs_vdev_repair(fmd_hdl_t *hdl, nvlist_t *nvl)
 {
@@ -302,11 +301,11 @@ zfs_vdev_repair(fmd_hdl_t *hdl, nvlist_t *nvl)
 	    vdev_guid, pool_guid);
 }
 
-/*ARGSUSED*/
 static void
 zfs_retire_recv(fmd_hdl_t *hdl, fmd_event_t *ep, nvlist_t *nvl,
     const char *class)
 {
+	(void) ep;
 	uint64_t pool_guid, vdev_guid;
 	zpool_handle_t *zhp;
 	nvlist_t *resource, *fault;
diff --git a/sys/contrib/openzfs/cmd/zed/zed.c b/sys/contrib/openzfs/cmd/zed/zed.c
index e45176c00bf2..4a413af6f927 100644
--- a/sys/contrib/openzfs/cmd/zed/zed.c
+++ b/sys/contrib/openzfs/cmd/zed/zed.c
@@ -36,6 +36,7 @@ static volatile sig_atomic_t _got_hup = 0;
 static void
 _exit_handler(int signum)
 {
+	(void) signum;
 	_got_exit = 1;
 }
 
@@ -45,6 +46,7 @@ _exit_handler(int signum)
 static void
 _hup_handler(int signum)
 {
+	(void) signum;
 	_got_hup = 1;
 }
 
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/Makefile.am b/sys/contrib/openzfs/cmd/zed/zed.d/Makefile.am
index 2c8173b3e769..24efaa74f154 100644
--- a/sys/contrib/openzfs/cmd/zed/zed.d/Makefile.am
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/Makefile.am
@@ -10,6 +10,10 @@ dist_zedconf_DATA = \
 	zed-functions.sh \
 	zed.rc
 
+SHELLCHECKSCRIPTS = zed-functions.sh zed.rc
+SHELLCHECK_OPTS = --enable=all
+SHELLCHECK_SHELL = dash
+
 zedexecdir = $(zfsexecdir)/zed.d
 
 dist_zedexec_SCRIPTS = \
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/all-debug.sh b/sys/contrib/openzfs/cmd/zed/zed.d/all-debug.sh
index 824c9fe423d7..ba19b96b082f 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/all-debug.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/all-debug.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Log all environment variables to ZED_DEBUG_LOG.
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/all-syslog.sh b/sys/contrib/openzfs/cmd/zed/zed.d/all-syslog.sh
index ea108c47b779..5f601144a97c 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/all-syslog.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/all-syslog.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Copyright (C) 2013-2014 Lawrence Livermore National Security, LLC.
 # Copyright (c) 2020 by Delphix. All rights reserved.
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/data-notify.sh b/sys/contrib/openzfs/cmd/zed/zed.d/data-notify.sh
index 792d30a66d23..9846769b1101 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/data-notify.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/data-notify.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Send notification in response to a DATA error.
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/generic-notify.sh b/sys/contrib/openzfs/cmd/zed/zed.d/generic-notify.sh
index 9cf657e39970..e73b053902fa 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/generic-notify.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/generic-notify.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Send notification in response to a given zevent.
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/history_event-zfs-list-cacher.sh.in b/sys/contrib/openzfs/cmd/zed/zed.d/history_event-zfs-list-cacher.sh.in
index db40fa36d668..8c5031a38c6a 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/history_event-zfs-list-cacher.sh.in
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/history_event-zfs-list-cacher.sh.in
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Track changes to enumerated pools for use in early-boot
 set -ef
@@ -72,7 +73,7 @@ PROPS="name,mountpoint,canmount,atime,relatime,devices,exec\
 ,org.openzfs.systemd:wanted-by,org.openzfs.systemd:required-by\
 ,org.openzfs.systemd:nofail,org.openzfs.systemd:ignore"
 
-"${ZFS}" list -H -t filesystem -o $PROPS -r "${ZEVENT_POOL}" > "${FSLIST_TMP}"
+"${ZFS}" list -H -t filesystem -o "${PROPS}" -r "${ZEVENT_POOL}" > "${FSLIST_TMP}"
 
 # Sort the output so that it is stable
 sort "${FSLIST_TMP}" -o "${FSLIST_TMP}"
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/resilver_finish-start-scrub.sh b/sys/contrib/openzfs/cmd/zed/zed.d/resilver_finish-start-scrub.sh
index c7cfd1ddba80..cafce6fde54b 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/resilver_finish-start-scrub.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/resilver_finish-start-scrub.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 # resilver_finish-start-scrub.sh
 # Run a scrub after a resilver
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/scrub_finish-notify.sh b/sys/contrib/openzfs/cmd/zed/zed.d/scrub_finish-notify.sh
index 5c0124b8d7e7..fc9dc23e04aa 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/scrub_finish-notify.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/scrub_finish-notify.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Send notification in response to a RESILVER_FINISH or SCRUB_FINISH.
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/statechange-led.sh b/sys/contrib/openzfs/cmd/zed/zed.d/statechange-led.sh
index 26e6064fa94a..46bfc1b866f1 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/statechange-led.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/statechange-led.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Turn off/on vdevs' enclosure fault LEDs when their pool's state changes.
 #
@@ -126,6 +127,9 @@ state_to_val()
 		ONLINE)
 			echo 0
 			;;
+		*)
+			echo "invalid state: $state"
+			;;
 	esac
 }
 
@@ -138,26 +142,24 @@ nvme_dev_to_slot()
 	dev="$1"
 
 	# Get the address "0000:01:00.0"
-	address=$(cat "/sys/class/block/$dev/device/address")
-
-	# For each /sys/bus/pci/slots subdir that is an actual number
-	# (rather than weird directories like "1-3/").
-	# shellcheck disable=SC2010
-	for i in $(ls /sys/bus/pci/slots/ | grep -E "^[0-9]+$") ; do
-		this_address=$(cat "/sys/bus/pci/slots/$i/address")
-
-		# The format of address is a little different between
-		# /sys/class/block/$dev/device/address and
-		# /sys/bus/pci/slots/
-		#
-		# address=           "0000:01:00.0"
-		# this_address =     "0000:01:00"
-		#
-		if echo "$address" | grep -Eq ^"$this_address" ; then
-			echo "/sys/bus/pci/slots/$i"
-			break
-		fi
-	done
+	read -r address < "/sys/class/block/$dev/device/address"
+
+	find /sys/bus/pci/slots -regex '.*/[0-9]+/address$' | \
+		while read -r sys_addr; do
+			read -r this_address < "$sys_addr"
+
+			# The format of address is a little different between
+			# /sys/class/block/$dev/device/address and
+			# /sys/bus/pci/slots/
+			#
+			# address=           "0000:01:00.0"
+			# this_address =     "0000:01:00"
+			#
+			if echo "$address" | grep -Eq ^"$this_address" ; then
+				echo "${sys_addr%/*}"
+				break
+			fi
+			done
 }
 
 
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/statechange-notify.sh b/sys/contrib/openzfs/cmd/zed/zed.d/statechange-notify.sh
index ab11dfbc99d5..c475fdb36660 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/statechange-notify.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/statechange-notify.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # CDDL HEADER START
 #
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/trim_finish-notify.sh b/sys/contrib/openzfs/cmd/zed/zed.d/trim_finish-notify.sh
index 8fdb64531d0a..a9ea489622c7 100755
--- a/sys/contrib/openzfs/cmd/zed/zed.d/trim_finish-notify.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/trim_finish-notify.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # Send notification in response to a TRIM_FINISH. The event
 # will be received for each vdev in the pool which was trimmed.
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/zed-functions.sh b/sys/contrib/openzfs/cmd/zed/zed.d/zed-functions.sh
index eb59036cf4d8..bbff9c008bd1 100644
--- a/sys/contrib/openzfs/cmd/zed/zed.d/zed-functions.sh
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/zed-functions.sh
@@ -1,5 +1,5 @@
 #!/bin/sh
-# shellcheck disable=SC2039
+# shellcheck disable=SC2154,SC3043
 # zed-functions.sh
 #
 # ZED helper functions for use in ZEDLETs
@@ -266,7 +266,7 @@ zed_notify_email()
         | sed   -e "s/@ADDRESS@/${ZED_EMAIL_ADDR}/g" \
                 -e "s/@SUBJECT@/${subject}/g")"
 
-    # shellcheck disable=SC2086
+    # shellcheck disable=SC2086,SC2248
     eval ${ZED_EMAIL_PROG} ${ZED_EMAIL_OPTS} < "${pathname}" >/dev/null 2>&1
     rv=$?
     if [ "${rv}" -ne 0 ]; then
diff --git a/sys/contrib/openzfs/cmd/zed/zed.d/zed.rc b/sys/contrib/openzfs/cmd/zed/zed.d/zed.rc
index 3bbd701f33fa..a8fdc86c3431 100644
--- a/sys/contrib/openzfs/cmd/zed/zed.d/zed.rc
+++ b/sys/contrib/openzfs/cmd/zed/zed.d/zed.rc
@@ -3,6 +3,7 @@
 #
 # This file should be owned by root and permissioned 0600.
 ##
+# shellcheck disable=SC2034
 
 ##
 # Absolute path to the debug output file.
@@ -13,9 +14,9 @@
 # Email address of the zpool administrator for receipt of notifications;
 #   multiple addresses can be specified if they are delimited by whitespace.
 # Email will only be sent if ZED_EMAIL_ADDR is defined.
-# Disabled by default; uncomment to enable.
+# Enabled by default; comment to disable.
 #
-#ZED_EMAIL_ADDR="root"
+ZED_EMAIL_ADDR="root"
 
 ##
 # Name or path of executable responsible for sending notifications via email;
diff --git a/sys/contrib/openzfs/cmd/zed/zed_exec.c b/sys/contrib/openzfs/cmd/zed/zed_exec.c
index 03dcd03aceb7..369c4b6950c5 100644
--- a/sys/contrib/openzfs/cmd/zed/zed_exec.c
+++ b/sys/contrib/openzfs/cmd/zed/zed_exec.c
@@ -187,11 +187,14 @@ _zed_exec_fork_child(uint64_t eid, const char *dir, const char *prog,
 
 static void
 _nop(int sig)
-{}
+{
+	(void) sig;
+}
 
 static void *
 _reap_children(void *arg)
 {
+	(void) arg;
 	struct launched_process_node node, *pnode;
 	pid_t pid;
 	int status;
diff --git a/sys/contrib/openzfs/cmd/zfs/zfs_iter.c b/sys/contrib/openzfs/cmd/zfs/zfs_iter.c
index f2359508c16d..69b802f77a78 100644
--- a/sys/contrib/openzfs/cmd/zfs/zfs_iter.c
+++ b/sys/contrib/openzfs/cmd/zfs/zfs_iter.c
@@ -219,9 +219,8 @@ zfs_sort_only_by_name(const zfs_sort_column_t *sc)
 	    sc->sc_prop == ZFS_PROP_NAME);
 }
 
-/* ARGSUSED */
 static int
-zfs_compare(const void *larg, const void *rarg, void *unused)
+zfs_compare(const void *larg, const void *rarg)
 {
 	zfs_handle_t *l = ((zfs_node_t *)larg)->zn_handle;
 	zfs_handle_t *r = ((zfs_node_t *)rarg)->zn_handle;
@@ -382,7 +381,7 @@ zfs_sort(const void *larg, const void *rarg, void *data)
 		}
 	}
 
-	return (zfs_compare(larg, rarg, NULL));
+	return (zfs_compare(larg, rarg));
 }
 
 int
diff --git a/sys/contrib/openzfs/cmd/zhack/zhack.c b/sys/contrib/openzfs/cmd/zhack/zhack.c
index bae242712a75..73ce888c0b1d 100644
--- a/sys/contrib/openzfs/cmd/zhack/zhack.c
+++ b/sys/contrib/openzfs/cmd/zhack/zhack.c
@@ -53,7 +53,6 @@
 #include <zfeature_common.h>
 #include <libzutil.h>
 
-const char cmdname[] = "zhack";
 static importargs_t g_importargs;
 static char *g_pool;
 static boolean_t g_readonly;
@@ -62,9 +61,9 @@ static __attribute__((noreturn)) void
 usage(void)
 {
 	(void) fprintf(stderr,
-	    "Usage: %s [-c cachefile] [-d dir] <subcommand> <args> ...\n"
+	    "Usage: zhack [-c cachefile] [-d dir] <subcommand> <args> ...\n"
 	    "where <subcommand> <args> is one of the following:\n"
-	    "\n", cmdname);
+	    "\n");
 
 	(void) fprintf(stderr,
 	    "    feature stat <pool>\n"
@@ -99,19 +98,20 @@ fatal(spa_t *spa, void *tag, const char *fmt, ...)
 	}
 
 	va_start(ap, fmt);
-	(void) fprintf(stderr, "%s: ", cmdname);
+	(void) fputs("zhack: ", stderr);
 	(void) vfprintf(stderr, fmt, ap);
 	va_end(ap);
-	(void) fprintf(stderr, "\n");
+	(void) fputc('\n', stderr);
 
 	exit(1);
 }
 
-/* ARGSUSED */
 static int
 space_delta_cb(dmu_object_type_t bonustype, const void *data,
     zfs_file_info_t *zoi)
 {
+	(void) data, (void) zoi;
+
 	/*
 	 * Is it a valid type of object to track?
 	 */
@@ -276,7 +276,7 @@ zhack_do_feature_enable(int argc, char **argv)
 	spa_t *spa;
 	objset_t *mos;
 	zfeature_info_t feature;
-	spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
+	const spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
 
 	/*
 	 * Features are not added to the pool's label until their refcounts
@@ -373,7 +373,7 @@ zhack_do_feature_ref(int argc, char **argv)
 	spa_t *spa;
 	objset_t *mos;
 	zfeature_info_t feature;
-	spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
+	const spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
 
 	/*
 	 * fi_desc does not matter here because it was written to disk
diff --git a/sys/contrib/openzfs/cmd/zinject/zinject.c b/sys/contrib/openzfs/cmd/zinject/zinject.c
index bf97b0d68713..10d5dbe90044 100644
--- a/sys/contrib/openzfs/cmd/zinject/zinject.c
+++ b/sys/contrib/openzfs/cmd/zinject/zinject.c
@@ -497,11 +497,11 @@ print_all_handlers(void)
 	return (count + total);
 }
 
-/* ARGSUSED */
 static int
 cancel_one_handler(int id, const char *pool, zinject_record_t *record,
     void *data)
 {
+	(void) pool, (void) record, (void) data;
 	zfs_cmd_t zc = {"\0"};
 
 	zc.zc_guid = (uint64_t)id;
diff --git a/sys/contrib/openzfs/cmd/zpool/Makefile.am b/sys/contrib/openzfs/cmd/zpool/Makefile.am
index fa494c030e1c..b89b5db85800 100644
--- a/sys/contrib/openzfs/cmd/zpool/Makefile.am
+++ b/sys/contrib/openzfs/cmd/zpool/Makefile.am
@@ -5,6 +5,8 @@ AM_CFLAGS += $(LIBBLKID_CFLAGS) $(LIBUUID_CFLAGS)
 
 DEFAULT_INCLUDES += -I$(srcdir)
 
+SHELLCHECK_OPTS = --enable=all
+
 sbin_PROGRAMS = zpool
 
 zpool_SOURCES = \
diff --git a/sys/contrib/openzfs/cmd/zpool/os/freebsd/zpool_vdev_os.c b/sys/contrib/openzfs/cmd/zpool/os/freebsd/zpool_vdev_os.c
index 66bfe28f13f8..8ebd3e60d5d6 100644
--- a/sys/contrib/openzfs/cmd/zpool/os/freebsd/zpool_vdev_os.c
+++ b/sys/contrib/openzfs/cmd/zpool/os/freebsd/zpool_vdev_os.c
@@ -86,6 +86,7 @@ int
 check_device(const char *name, boolean_t force, boolean_t isspare,
     boolean_t iswholedisk)
 {
+	(void) iswholedisk;
 	char path[MAXPATHLEN];
 
 	if (strncmp(name, _PATH_DEV, sizeof (_PATH_DEV) - 1) != 0)
@@ -99,6 +100,7 @@ check_device(const char *name, boolean_t force, boolean_t isspare,
 boolean_t
 check_sector_size_database(char *path, int *sector_size)
 {
+	(void) path, (void) sector_size;
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/cmd/zpool/os/linux/zpool_vdev_os.c b/sys/contrib/openzfs/cmd/zpool/os/linux/zpool_vdev_os.c
index 10929fa65a11..9d2c21c2a87b 100644
--- a/sys/contrib/openzfs/cmd/zpool/os/linux/zpool_vdev_os.c
+++ b/sys/contrib/openzfs/cmd/zpool/os/linux/zpool_vdev_os.c
@@ -409,6 +409,7 @@ check_device(const char *path, boolean_t force,
 void
 after_zpool_upgrade(zpool_handle_t *zhp)
 {
+	(void) zhp;
 }
 
 int
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/dm-deps b/sys/contrib/openzfs/cmd/zpool/zpool.d/dm-deps
index 42af6a8d63cd..44224787f096 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/dm-deps
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/dm-deps
@@ -9,6 +9,7 @@ if [ "$1" = "-h" ] ; then
 	exit
 fi
 
+# shellcheck disable=SC2154
 dev="$VDEV_PATH"
 
 # If the VDEV path is a symlink, resolve it to a real device
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/iostat b/sys/contrib/openzfs/cmd/zpool/zpool.d/iostat
index 19be475e9b27..95c459a3f0bf 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/iostat
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/iostat
@@ -27,6 +27,7 @@ elif [ "$script" = "iostat-10s" ] ; then
 	brief="yes"
 fi
 
+# shellcheck disable=SC2154
 if [ -f "$VDEV_UPATH" ] ; then
 	# We're a file-based vdev, iostat doesn't work on us.  Do nothing.
 	exit
@@ -67,7 +68,7 @@ i=0
 for col in $cols ; do
 	i=$((i+1))
 	# Skip the first column since it's just the device name
-	if [ $i -eq 1 ]; then
+	if [ "$i" -eq 1 ]; then
 		continue
 	fi
 
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/lsblk b/sys/contrib/openzfs/cmd/zpool/zpool.d/lsblk
index 919783a1c1bf..1ed1464431aa 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/lsblk
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/lsblk
@@ -66,6 +66,7 @@ for i in $list ; do
 
 	# Special case: Looking up the size of a file-based vdev can't
 	# be done with lsblk.
+	# shellcheck disable=SC2154
 	if [ "$i" = "size" ] && [ -f "$VDEV_UPATH" ] ; then
 		size=$(du -h --apparent-size "$VDEV_UPATH" | cut -f 1)
 		echo "size=$size"
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/media b/sys/contrib/openzfs/cmd/zpool/zpool.d/media
index 660f78b743fc..095ac86dc4d8 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/media
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/media
@@ -8,12 +8,14 @@ if [ "$1" = "-h" ] ; then
 	exit
 fi
 
+# shellcheck disable=SC2154
 if [ -b "$VDEV_UPATH" ]; then
 	device="${VDEV_UPATH##*/}"
 	read -r val 2>/dev/null < "/sys/block/$device/queue/rotational"
 	case "$val" in
 		0) MEDIA="ssd" ;;
 		1) MEDIA="hdd" ;;
+		*) MEDIA="invalid" ;;
 	esac
 
 	vpd_pg83="/sys/block/$device/device/vpd_pg83"
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/ses b/sys/contrib/openzfs/cmd/zpool/zpool.d/ses
index b51fe31894ab..638145c95d47 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/ses
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/ses
@@ -24,6 +24,7 @@ else
 fi
 
 for i in $scripts ; do
+	# shellcheck disable=SC2154
 	if [ -z "$VDEV_ENC_SYSFS_PATH" ] ; then
 		echo "$i="
 		continue
@@ -52,7 +53,9 @@ for i in $scripts ; do
 	locate_led)
 		val=$(cat "$VDEV_ENC_SYSFS_PATH/locate" 2>/dev/null)
 		;;
+	*)
+		val=invalid
+		;;
 	esac
 	echo "$i=$val"
 done
-
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/smart b/sys/contrib/openzfs/cmd/zpool/zpool.d/smart
index b95256d75648..032491988c18 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/smart
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/smart
@@ -69,6 +69,7 @@ if [ "$1" = "-h" ] ; then
         exit
 fi
 
+# shellcheck disable=SC2154
 if [ -b "$VDEV_UPATH" ] && PATH="/usr/sbin:$PATH" command -v smartctl > /dev/null || [ -n "$samples" ] ; then
 	if [ -n "$samples" ] ; then
 		# cat a smartctl output text file instead of running smartctl
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool.d/upath b/sys/contrib/openzfs/cmd/zpool/zpool.d/upath
index 16a4327d4850..e37ee1b8cc2a 100755
--- a/sys/contrib/openzfs/cmd/zpool/zpool.d/upath
+++ b/sys/contrib/openzfs/cmd/zpool/zpool.d/upath
@@ -4,4 +4,5 @@ if [ "$1" = "-h" ] ; then
 	exit
 fi
 
+# shellcheck disable=SC2154
 echo upath="$VDEV_UPATH"
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool_iter.c b/sys/contrib/openzfs/cmd/zpool/zpool_iter.c
index 8cf6bab42ff1..65e53f8e0e2a 100644
--- a/sys/contrib/openzfs/cmd/zpool/zpool_iter.c
+++ b/sys/contrib/openzfs/cmd/zpool/zpool_iter.c
@@ -63,10 +63,10 @@ struct zpool_list {
 	zfs_type_t	zl_type;
 };
 
-/* ARGSUSED */
 static int
 zpool_compare(const void *larg, const void *rarg, void *unused)
 {
+	(void) unused;
 	zpool_handle_t *l = ((zpool_node_t *)larg)->zn_handle;
 	zpool_handle_t *r = ((zpool_node_t *)rarg)->zn_handle;
 	const char *lname = zpool_get_name(l);
diff --git a/sys/contrib/openzfs/cmd/zpool/zpool_main.c b/sys/contrib/openzfs/cmd/zpool/zpool_main.c
index 4e2f828cb2ba..d7cce73d3dff 100644
--- a/sys/contrib/openzfs/cmd/zpool/zpool_main.c
+++ b/sys/contrib/openzfs/cmd/zpool/zpool_main.c
@@ -906,8 +906,7 @@ add_prop_list(const char *propname, char *propval, nvlist_t **props,
  * Set a default property pair (name, string-value) in a property nvlist
  */
 static int
-add_prop_list_default(const char *propname, char *propval, nvlist_t **props,
-    boolean_t poolprop)
+add_prop_list_default(const char *propname, char *propval, nvlist_t **props)
 {
 	char *pval;
 
@@ -1501,7 +1500,7 @@ zpool_do_create(int argc, char **argv)
 			    ZPOOL_PROP_ALTROOT), optarg, &props, B_TRUE))
 				goto errout;
 			if (add_prop_list_default(zpool_prop_to_name(
-			    ZPOOL_PROP_CACHEFILE), "none", &props, B_TRUE))
+			    ZPOOL_PROP_CACHEFILE), "none", &props))
 				goto errout;
 			break;
 		case 'm':
@@ -1579,7 +1578,7 @@ zpool_do_create(int argc, char **argv)
 			    ZPOOL_PROP_TNAME), optarg, &props, B_TRUE))
 				goto errout;
 			if (add_prop_list_default(zpool_prop_to_name(
-			    ZPOOL_PROP_CACHEFILE), "none", &props, B_TRUE))
+			    ZPOOL_PROP_CACHEFILE), "none", &props))
 				goto errout;
 			tname = optarg;
 			break;
@@ -3618,7 +3617,7 @@ zpool_do_import(int argc, char **argv)
 			    ZPOOL_PROP_ALTROOT), optarg, &props, B_TRUE))
 				goto error;
 			if (add_prop_list_default(zpool_prop_to_name(
-			    ZPOOL_PROP_CACHEFILE), "none", &props, B_TRUE))
+			    ZPOOL_PROP_CACHEFILE), "none", &props))
 				goto error;
 			break;
 		case 's':
@@ -3627,7 +3626,7 @@ zpool_do_import(int argc, char **argv)
 		case 't':
 			flags |= ZFS_IMPORT_TEMP_NAME;
 			if (add_prop_list_default(zpool_prop_to_name(
-			    ZPOOL_PROP_CACHEFILE), "none", &props, B_TRUE))
+			    ZPOOL_PROP_CACHEFILE), "none", &props))
 				goto error;
 			break;
 
@@ -4570,11 +4569,8 @@ single_histo_average(uint64_t *histo, unsigned int buckets)
 }
 
 static void
-print_iostat_queues(iostat_cbdata_t *cb, nvlist_t *oldnv,
-    nvlist_t *newnv)
+print_iostat_queues(iostat_cbdata_t *cb, nvlist_t *newnv)
 {
-	int i;
-	uint64_t val;
 	const char *names[] = {
 		ZPOOL_CONFIG_VDEV_SYNC_R_PEND_QUEUE,
 		ZPOOL_CONFIG_VDEV_SYNC_R_ACTIVE_QUEUE,
@@ -4604,8 +4600,8 @@ print_iostat_queues(iostat_cbdata_t *cb, nvlist_t *oldnv,
 	else
 		format = ZFS_NICENUM_1024;
 
-	for (i = 0; i < ARRAY_SIZE(names); i++) {
-		val = nva[i].data[0];
+	for (int i = 0; i < ARRAY_SIZE(names); i++) {
+		uint64_t val = nva[i].data[0];
 		print_one_stat(val, format, column_width, cb->cb_scripted);
 	}
 
@@ -4796,7 +4792,7 @@ print_vdev_stats(zpool_handle_t *zhp, const char *name, nvlist_t *oldnv,
 	if (cb->cb_flags & IOS_LATENCY_M)
 		print_iostat_latency(cb, oldnv, newnv);
 	if (cb->cb_flags & IOS_QUEUES_M)
-		print_iostat_queues(cb, oldnv, newnv);
+		print_iostat_queues(cb, newnv);
 	if (cb->cb_flags & IOS_ANYHISTO_M) {
 		printf("\n");
 		print_iostat_histos(cb, oldnv, newnv, scale, name);
@@ -6596,7 +6592,6 @@ zpool_do_attach_or_replace(int argc, char **argv, int replacing)
  *
  * Replace <device> with <new_device>.
  */
-/* ARGSUSED */
 int
 zpool_do_replace(int argc, char **argv)
 {
@@ -6632,7 +6627,6 @@ zpool_do_attach(int argc, char **argv)
  * is the last device in the mirror, or if the DTLs indicate that this device
  * has the only valid copy of some data.
  */
-/* ARGSUSED */
 int
 zpool_do_detach(int argc, char **argv)
 {
@@ -6939,7 +6933,6 @@ zpool_do_online(int argc, char **argv)
  *	-t	Only take the device off-line temporarily.  The offline/faulted
  *		state will not be persistent across reboots.
  */
-/* ARGSUSED */
 int
 zpool_do_offline(int argc, char **argv)
 {
@@ -9084,7 +9077,6 @@ upgrade_list_disabled_cb(zpool_handle_t *zhp, void *arg)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 upgrade_one(zpool_handle_t *zhp, void *data)
 {
@@ -9849,7 +9841,7 @@ zpool_do_events_next(ev_opts_t *opts)
 }
 
 static int
-zpool_do_events_clear(ev_opts_t *opts)
+zpool_do_events_clear(void)
 {
 	int count, ret;
 
@@ -9916,7 +9908,7 @@ zpool_do_events(int argc, char **argv)
 	}
 
 	if (opts.clear)
-		ret = zpool_do_events_clear(&opts);
+		ret = zpool_do_events_clear();
 	else
 		ret = zpool_do_events_next(&opts);
 
@@ -10854,6 +10846,8 @@ find_command_idx(char *command, int *idx)
 static int
 zpool_do_version(int argc, char **argv)
 {
+	(void) argc, (void) argv;
+
 	if (zfs_version_print() == -1)
 		return (1);
 
diff --git a/sys/contrib/openzfs/cmd/ztest/ztest.c b/sys/contrib/openzfs/cmd/ztest/ztest.c
index a2568962d877..bb2f14298279 100644
--- a/sys/contrib/openzfs/cmd/ztest/ztest.c
+++ b/sys/contrib/openzfs/cmd/ztest/ztest.c
@@ -253,7 +253,7 @@ extern uint64_t metaslab_force_ganging;
 extern uint64_t metaslab_df_alloc_threshold;
 extern unsigned long zfs_deadman_synctime_ms;
 extern int metaslab_preload_limit;
-extern boolean_t zfs_compressed_arc_enabled;
+extern int zfs_compressed_arc_enabled;
 extern int zfs_abd_scatter_enabled;
 extern int dmu_object_alloc_chunk_shift;
 extern boolean_t zfs_force_some_double_word_sm_entries;
@@ -1189,10 +1189,10 @@ ztest_kill(ztest_shared_t *zs)
 	(void) kill(getpid(), SIGKILL);
 }
 
-/* ARGSUSED */
 static void
 ztest_record_enospc(const char *s)
 {
+	(void) s;
 	ztest_shared->zs_enospc_count++;
 }
 
@@ -2389,10 +2389,10 @@ zil_replay_func_t *ztest_replay_vector[TX_MAX_TYPE] = {
  * ZIL get_data callbacks
  */
 
-/* ARGSUSED */
 static void
 ztest_get_done(zgd_t *zgd, int error)
 {
+	(void) error;
 	ztest_ds_t *zd = zgd->zgd_private;
 	uint64_t object = ((rl_t *)zgd->zgd_lr)->rl_object;
 
@@ -2409,6 +2409,7 @@ static int
 ztest_get_data(void *arg, uint64_t arg2, lr_write_t *lr, char *buf,
     struct lwb *lwb, zio_t *zio)
 {
+	(void) arg2;
 	ztest_ds_t *zd = arg;
 	objset_t *os = zd->zd_os;
 	uint64_t object = lr->lr_foid;
@@ -2869,10 +2870,10 @@ ztest_object_init(ztest_ds_t *zd, ztest_od_t *od, size_t size, boolean_t remove)
 	return (rv);
 }
 
-/* ARGSUSED */
 void
 ztest_zil_commit(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	zilog_t *zilog = zd->zd_zilog;
 
 	(void) pthread_rwlock_rdlock(&zd->zd_zilog_lock);
@@ -2898,10 +2899,10 @@ ztest_zil_commit(ztest_ds_t *zd, uint64_t id)
  * mount/unmount operation.  We hold the dataset across these operations in an
  * attempt to expose any implicit assumptions about ZIL management.
  */
-/* ARGSUSED */
 void
 ztest_zil_remount(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	objset_t *os = zd->zd_os;
 
 	/*
@@ -2935,10 +2936,10 @@ ztest_zil_remount(ztest_ds_t *zd, uint64_t id)
  * Verify that we can't destroy an active pool, create an existing pool,
  * or create a pool with a bad vdev spec.
  */
-/* ARGSUSED */
 void
 ztest_spa_create_destroy(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_opts_t *zo = &ztest_opts;
 	spa_t *spa;
 	nvlist_t *nvroot;
@@ -2998,10 +2999,10 @@ ztest_spa_create_destroy(ztest_ds_t *zd, uint64_t id)
  * Start and then stop the MMP threads to ensure the startup and shutdown code
  * works properly.  Actual protection and property-related code tested via ZTS.
  */
-/* ARGSUSED */
 void
 ztest_mmp_enable_disable(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_opts_t *zo = &ztest_opts;
 	spa_t *spa = ztest_spa;
 
@@ -3044,10 +3045,10 @@ ztest_mmp_enable_disable(ztest_ds_t *zd, uint64_t id)
 	spa_config_exit(spa, SCL_CONFIG, FTAG);
 }
 
-/* ARGSUSED */
 void
 ztest_spa_upgrade(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa;
 	uint64_t initial_version = SPA_VERSION_INITIAL;
 	uint64_t version, newversion;
@@ -3164,10 +3165,10 @@ ztest_spa_discard_checkpoint(spa_t *spa)
 
 }
 
-/* ARGSUSED */
 void
 ztest_spa_checkpoint_create_discard(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 
 	mutex_enter(&ztest_checkpoint_lock);
@@ -3208,10 +3209,10 @@ spa_num_top_vdevs(spa_t *spa)
 /*
  * Verify that vdev_add() works as expected.
  */
-/* ARGSUSED */
 void
 ztest_vdev_add_remove(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	uint64_t leaves;
@@ -3298,10 +3299,10 @@ ztest_vdev_add_remove(ztest_ds_t *zd, uint64_t id)
 	mutex_exit(&ztest_vdev_lock);
 }
 
-/* ARGSUSED */
 void
 ztest_vdev_class_add(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	uint64_t leaves;
@@ -3379,10 +3380,10 @@ ztest_vdev_class_add(ztest_ds_t *zd, uint64_t id)
 /*
  * Verify that adding/removing aux devices (l2arc, hot spare) works as expected.
  */
-/* ARGSUSED */
 void
 ztest_vdev_aux_add_remove(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	vdev_t *rvd = spa->spa_root_vdev;
@@ -3491,10 +3492,10 @@ ztest_vdev_aux_add_remove(ztest_ds_t *zd, uint64_t id)
 /*
  * split a pool if it has mirror tlvdevs
  */
-/* ARGSUSED */
 void
 ztest_split_pool(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	vdev_t *rvd = spa->spa_root_vdev;
@@ -3586,10 +3587,10 @@ ztest_split_pool(ztest_ds_t *zd, uint64_t id)
 /*
  * Verify that we can attach and detach devices.
  */
-/* ARGSUSED */
 void
 ztest_vdev_attach_detach(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	spa_aux_vdev_t *sav = &spa->spa_spares;
@@ -3829,10 +3830,10 @@ ztest_vdev_attach_detach(ztest_ds_t *zd, uint64_t id)
 	umem_free(newpath, MAXPATHLEN);
 }
 
-/* ARGSUSED */
 void
 ztest_device_removal(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	vdev_t *vd;
 	uint64_t guid;
@@ -3922,10 +3923,10 @@ grow_vdev(vdev_t *vd, void *arg)
 /*
  * Callback function which expands a given vdev by calling vdev_online().
  */
-/* ARGSUSED */
 static vdev_t *
 online_vdev(vdev_t *vd, void *arg)
 {
+	(void) arg;
 	spa_t *spa = vd->vdev_spa;
 	vdev_t *tvd = vd->vdev_top;
 	uint64_t guid = vd->vdev_guid;
@@ -4006,10 +4007,10 @@ vdev_walk_tree(vdev_t *vd, vdev_t *(*func)(vdev_t *, void *), void *arg)
 /*
  * Verify that dynamic LUN growth works as expected.
  */
-/* ARGSUSED */
 void
 ztest_vdev_LUN_growth(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	vdev_t *vd, *tvd;
 	metaslab_class_t *mc;
@@ -4161,10 +4162,11 @@ ztest_vdev_LUN_growth(ztest_ds_t *zd, uint64_t id)
 /*
  * Verify that dmu_objset_{create,destroy,open,close} work as expected.
  */
-/* ARGSUSED */
 static void
 ztest_objset_create_cb(objset_t *os, void *arg, cred_t *cr, dmu_tx_t *tx)
 {
+	(void) arg, (void) cr;
+
 	/*
 	 * Create the objects common to all ztest datasets.
 	 */
@@ -4241,10 +4243,10 @@ ztest_dataset_create(char *dsname)
 	    ZFS_SYNC_ALWAYS, B_FALSE));
 }
 
-/* ARGSUSED */
 static int
 ztest_objset_destroy_cb(const char *name, void *arg)
 {
+	(void) arg;
 	objset_t *os;
 	dmu_object_info_t doi;
 	int error;
@@ -4317,10 +4319,10 @@ ztest_snapshot_destroy(char *osname, uint64_t id)
 	return (B_TRUE);
 }
 
-/* ARGSUSED */
 void
 ztest_dmu_objset_create_destroy(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd;
 	ztest_ds_t *zdtmp;
 	int iters;
 	int error;
@@ -4642,6 +4644,7 @@ ztest_dmu_object_alloc_free(ztest_ds_t *zd, uint64_t id)
 void
 ztest_dmu_object_next_chunk(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	objset_t *os = zd->zd_os;
 	int dnodes_per_chunk = 1 << dmu_object_alloc_chunk_shift;
 	uint64_t object;
@@ -5188,10 +5191,10 @@ ztest_dmu_read_write_zcopy(ztest_ds_t *zd, uint64_t id)
 	umem_free(od, size);
 }
 
-/* ARGSUSED */
 void
 ztest_dmu_write_parallel(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	ztest_od_t *od;
 
 	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
@@ -5450,10 +5453,10 @@ ztest_fzap(ztest_ds_t *zd, uint64_t id)
 	umem_free(od, sizeof (ztest_od_t));
 }
 
-/* ARGSUSED */
 void
 ztest_zap_parallel(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	objset_t *os = zd->zd_os;
 	ztest_od_t *od;
 	uint64_t txg, object, count, wsize, wc, zl_wsize, zl_wc;
@@ -5785,10 +5788,10 @@ ztest_dmu_commit_callbacks(ztest_ds_t *zd, uint64_t id)
  * are consistent what was stored in the block tag when it was created,
  * and that its unused bonus buffer space has not been overwritten.
  */
-/* ARGSUSED */
 void
 ztest_verify_dnode_bt(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	objset_t *os = zd->zd_os;
 	uint64_t obj;
 	int err = 0;
@@ -5820,21 +5823,20 @@ ztest_verify_dnode_bt(ztest_ds_t *zd, uint64_t id)
 	}
 }
 
-/* ARGSUSED */
 void
 ztest_dsl_prop_get_set(ztest_ds_t *zd, uint64_t id)
 {
+	(void) id;
 	zfs_prop_t proplist[] = {
 		ZFS_PROP_CHECKSUM,
 		ZFS_PROP_COMPRESSION,
 		ZFS_PROP_COPIES,
 		ZFS_PROP_DEDUP
 	};
-	int p;
 
 	(void) pthread_rwlock_rdlock(&ztest_name_lock);
 
-	for (p = 0; p < sizeof (proplist) / sizeof (proplist[0]); p++)
+	for (int p = 0; p < sizeof (proplist) / sizeof (proplist[0]); p++)
 		(void) ztest_dsl_prop_set_uint64(zd->zd_name, proplist[p],
 		    ztest_random_dsl_prop(proplist[p]), (int)ztest_random(2));
 
@@ -5844,10 +5846,10 @@ ztest_dsl_prop_get_set(ztest_ds_t *zd, uint64_t id)
 	(void) pthread_rwlock_unlock(&ztest_name_lock);
 }
 
-/* ARGSUSED */
 void
 ztest_spa_prop_get_set(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	nvlist_t *props = NULL;
 
 	(void) pthread_rwlock_rdlock(&ztest_name_lock);
@@ -6008,10 +6010,10 @@ ztest_dmu_snapshot_hold(ztest_ds_t *zd, uint64_t id)
 /*
  * Inject random faults into the on-disk data.
  */
-/* ARGSUSED */
 void
 ztest_fault_inject(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	ztest_shared_t *zs = ztest_shared;
 	spa_t *spa = ztest_spa;
 	int fd;
@@ -6324,10 +6326,10 @@ ztest_scrub_impl(spa_t *spa)
 /*
  * Scrub the pool.
  */
-/* ARGSUSED */
 void
 ztest_scrub(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	int error;
 
@@ -6352,10 +6354,10 @@ ztest_scrub(ztest_ds_t *zd, uint64_t id)
 /*
  * Change the guid for the pool.
  */
-/* ARGSUSED */
 void
 ztest_reguid(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	uint64_t orig, load;
 	int error;
@@ -6385,6 +6387,7 @@ ztest_reguid(ztest_ds_t *zd, uint64_t id)
 void
 ztest_fletcher(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	hrtime_t end = gethrtime() + NANOSEC;
 
 	while (gethrtime() <= end) {
@@ -6454,6 +6457,7 @@ ztest_fletcher(ztest_ds_t *zd, uint64_t id)
 void
 ztest_fletcher_incr(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	void *buf;
 	size_t size;
 	int *ptr;
@@ -6657,10 +6661,10 @@ ztest_random_concrete_vdev_leaf(vdev_t *vd)
 	return (ztest_random_concrete_vdev_leaf(eligible[child_no]));
 }
 
-/* ARGSUSED */
 void
 ztest_initialize(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	int error = 0;
 
@@ -6729,10 +6733,10 @@ ztest_initialize(ztest_ds_t *zd, uint64_t id)
 	mutex_exit(&ztest_vdev_lock);
 }
 
-/* ARGSUSED */
 void
 ztest_trim(ztest_ds_t *zd, uint64_t id)
 {
+	(void) zd, (void) id;
 	spa_t *spa = ztest_spa;
 	int error = 0;
 
@@ -7246,10 +7250,10 @@ ztest_dataset_close(int d)
 	ztest_zd_fini(zd);
 }
 
-/* ARGSUSED */
 static int
 ztest_replay_zil_cb(const char *name, void *arg)
 {
+	(void) arg;
 	objset_t *os;
 	ztest_ds_t *zdtmp;
 
@@ -7371,7 +7375,7 @@ ztest_freeze(void)
 }
 
 static void
-ztest_import_impl(ztest_shared_t *zs)
+ztest_import_impl(void)
 {
 	importargs_t args = { 0 };
 	nvlist_t *cfg = NULL;
@@ -7404,7 +7408,7 @@ ztest_import(ztest_shared_t *zs)
 
 	kernel_init(SPA_MODE_READ | SPA_MODE_WRITE);
 
-	ztest_import_impl(zs);
+	ztest_import_impl();
 
 	VERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));
 	zs->zs_metaslab_sz =
@@ -7470,7 +7474,7 @@ ztest_run(ztest_shared_t *zs)
 	error = spa_open(ztest_opts.zo_pool, &spa, FTAG);
 	if (error) {
 		VERIFY3S(error, ==, ENOENT);
-		ztest_import_impl(zs);
+		ztest_import_impl();
 		VERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));
 		zs->zs_metaslab_sz =
 		    1ULL << spa->spa_root_vdev->vdev_child[0]->vdev_ms_shift;
diff --git a/sys/contrib/openzfs/cmd/zvol_wait/Makefile.am b/sys/contrib/openzfs/cmd/zvol_wait/Makefile.am
index 2e5bf3323389..ee66d51de96f 100644
--- a/sys/contrib/openzfs/cmd/zvol_wait/Makefile.am
+++ b/sys/contrib/openzfs/cmd/zvol_wait/Makefile.am
@@ -1,3 +1,5 @@
 include $(top_srcdir)/config/Shellcheck.am
 
 dist_bin_SCRIPTS = zvol_wait
+
+SHELLCHECK_OPTS = --enable=all
diff --git a/sys/contrib/openzfs/config/always-parallel.m4 b/sys/contrib/openzfs/config/always-parallel.m4
new file mode 100644
index 000000000000..c1f1ae78e7e7
--- /dev/null
+++ b/sys/contrib/openzfs/config/always-parallel.m4
@@ -0,0 +1,8 @@
+dnl #
+dnl # Check if GNU parallel is available.
+dnl #
+AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PARALLEL], [
+	AC_CHECK_PROG([PARALLEL], [parallel], [yes])
+
+	AM_CONDITIONAL([HAVE_PARALLEL], [test "x$PARALLEL" = "xyes"])
+])
diff --git a/sys/contrib/openzfs/config/always-python.m4 b/sys/contrib/openzfs/config/always-python.m4
index 5f47df424c27..5a2008124f72 100644
--- a/sys/contrib/openzfs/config/always-python.m4
+++ b/sys/contrib/openzfs/config/always-python.m4
@@ -1,7 +1,6 @@
 dnl #
 dnl # The majority of the python scripts are written to be compatible
-dnl # with Python 2.6 and Python 3.4.  Therefore, they may be installed
-dnl # and used with either interpreter.  This option is intended to
+dnl # with Python 3.6. This option is intended to
 dnl # to provide a method to specify the default system version, and
 dnl # set the PYTHON environment variable accordingly.
 dnl #
@@ -13,9 +12,7 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PYTHON], [
 		[with_python=check])
 
 	AS_CASE([$with_python],
-		[check], [AC_CHECK_PROGS([PYTHON], [python3 python2], [:])],
-		[2*], [PYTHON="python${with_python}"],
-		[*python2*], [PYTHON="${with_python}"],
+		[check], [AC_CHECK_PROGS([PYTHON], [python3], [:])],
 		[3*], [PYTHON="python${with_python}"],
 		[*python3*], [PYTHON="${with_python}"],
 		[no], [PYTHON=":"],
@@ -23,8 +20,7 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PYTHON], [
 	)
 
 	dnl #
-	dnl # Minimum supported Python versions for utilities:
-	dnl # Python 2.6 or Python 3.4
+	dnl # Minimum supported Python versions for utilities: Python 3.6
 	dnl #
 	AM_PATH_PYTHON([], [], [:])
 	AS_IF([test -z "$PYTHON_VERSION"], [
@@ -33,25 +29,16 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PYTHON], [
 	PYTHON_MINOR=${PYTHON_VERSION#*\.}
 
 	AS_CASE([$PYTHON_VERSION],
-		[2.*], [
-			AS_IF([test $PYTHON_MINOR -lt 6],
-				[AC_MSG_ERROR("Python >= 2.6 is required")])
-		],
 		[3.*], [
-			AS_IF([test $PYTHON_MINOR -lt 4],
-				[AC_MSG_ERROR("Python >= 3.4 is required")])
+			AS_IF([test $PYTHON_MINOR -lt 6],
+				[AC_MSG_ERROR("Python >= 3.6 is required")])
 		],
 		[:|2|3], [],
 		[PYTHON_VERSION=3]
 	)
 
 	AM_CONDITIONAL([USING_PYTHON], [test "$PYTHON" != :])
-	AM_CONDITIONAL([USING_PYTHON_2], [test "x${PYTHON_VERSION%%\.*}" = x2])
-	AM_CONDITIONAL([USING_PYTHON_3], [test "x${PYTHON_VERSION%%\.*}" = x3])
-
-	AM_COND_IF([USING_PYTHON_2],
-		[AC_SUBST([PYTHON_SHEBANG], [python2])],
-		[AC_SUBST([PYTHON_SHEBANG], [python3])])
+	AC_SUBST([PYTHON_SHEBANG], [python3])
 
 	dnl #
 	dnl # Request that packages be built for a specific Python version.
diff --git a/sys/contrib/openzfs/config/always-pyzfs.m4 b/sys/contrib/openzfs/config/always-pyzfs.m4
index 00e5d0e2cbbd..996a2a6e2401 100644
--- a/sys/contrib/openzfs/config/always-pyzfs.m4
+++ b/sys/contrib/openzfs/config/always-pyzfs.m4
@@ -18,7 +18,7 @@ AC_DEFUN([ZFS_AC_PYTHON_MODULE], [
 ])
 
 dnl #
-dnl # Determines if pyzfs can be built, requires Python 2.7 or later.
+dnl # Determines if pyzfs can be built, requires Python 3.6 or later.
 dnl #
 AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PYZFS], [
 	AC_ARG_ENABLE([pyzfs],
@@ -62,12 +62,11 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS_PYZFS], [
 	])
 
 	dnl #
-	dnl # Require python-devel libraries
+	dnl # Require python3-devel libraries
 	dnl #
 	AS_IF([test "x$enable_pyzfs" = xcheck  -o "x$enable_pyzfs" = xyes], [
 		AS_CASE([$PYTHON_VERSION],
-			[3.*], [PYTHON_REQUIRED_VERSION=">= '3.4.0'"],
-			[2.*], [PYTHON_REQUIRED_VERSION=">= '2.7.0'"],
+			[3.*], [PYTHON_REQUIRED_VERSION=">= '3.6.0'"],
 			[AC_MSG_ERROR("Python $PYTHON_VERSION unknown")]
 		)
 
diff --git a/sys/contrib/openzfs/config/ax_code_coverage.m4 b/sys/contrib/openzfs/config/ax_code_coverage.m4
index 3e3c666f3c54..cd2498358df2 100644
--- a/sys/contrib/openzfs/config/ax_code_coverage.m4
+++ b/sys/contrib/openzfs/config/ax_code_coverage.m4
@@ -224,6 +224,7 @@ CODE_COVERAGE_GENHTML_OPTIONS ?= $(CODE_COVERAGE_GENHTML_OPTIONS_DEFAULT)
 # Ignore tmp and tests themselves
 CODE_COVERAGE_IGNORE_PATTERN ?= "/tmp/*" "*/tests/*"
 CODE_COVERAGE_IGNORE_PATTERN += "*/module/zstd/lib/*"
+CODE_COVERAGE_IGNORE_PATTERN += "*/module/zfs/lz4.c"
 
 GITIGNOREFILES ?=
 GITIGNOREFILES += $(CODE_COVERAGE_OUTPUT_FILE) $(CODE_COVERAGE_OUTPUT_DIRECTORY)
diff --git a/sys/contrib/openzfs/config/user-libfetch.m4 b/sys/contrib/openzfs/config/user-libfetch.m4
index f5149fc1a5d7..d961c6ca77a1 100644
--- a/sys/contrib/openzfs/config/user-libfetch.m4
+++ b/sys/contrib/openzfs/config/user-libfetch.m4
@@ -32,7 +32,7 @@ AC_DEFUN([ZFS_AC_CONFIG_USER_LIBFETCH], [
 		have_libfetch=1
 		LIBFETCH_IS_FETCH=1
 		LIBFETCH_DYNAMIC=1
-		LIBFETCH_SONAME='"libfetch.so.6"'
+		LIBFETCH_SONAME="libfetch.so.6"
 		LIBFETCH_LIBS="-ldl"
 		AC_MSG_RESULT([fetch(3)])
 	], [])
@@ -45,7 +45,7 @@ AC_DEFUN([ZFS_AC_CONFIG_USER_LIBFETCH], [
 			LIBFETCH_IS_LIBCURL=1
 			if test "$(curl-config --built-shared)" = "yes"; then
 				LIBFETCH_DYNAMIC=1
-				LIBFETCH_SONAME='"libcurl.so.4"'
+				LIBFETCH_SONAME="libcurl.so.4"
 				LIBFETCH_LIBS="-ldl"
 				AC_MSG_RESULT([libcurl])
 			else
@@ -67,5 +67,5 @@ AC_DEFUN([ZFS_AC_CONFIG_USER_LIBFETCH], [
 	AC_DEFINE_UNQUOTED([LIBFETCH_IS_FETCH], [$LIBFETCH_IS_FETCH], [libfetch is fetch(3)])
 	AC_DEFINE_UNQUOTED([LIBFETCH_IS_LIBCURL], [$LIBFETCH_IS_LIBCURL], [libfetch is libcurl])
 	AC_DEFINE_UNQUOTED([LIBFETCH_DYNAMIC], [$LIBFETCH_DYNAMIC], [whether the chosen libfetch is to be loaded at run-time])
-	AC_DEFINE_UNQUOTED([LIBFETCH_SONAME], [$LIBFETCH_SONAME], [soname of chosen libfetch])
+	AC_DEFINE_UNQUOTED([LIBFETCH_SONAME], ["$LIBFETCH_SONAME"], [soname of chosen libfetch])
 ])
diff --git a/sys/contrib/openzfs/config/zfs-build.m4 b/sys/contrib/openzfs/config/zfs-build.m4
index ec4a2026bf57..b1604eb9d50e 100644
--- a/sys/contrib/openzfs/config/zfs-build.m4
+++ b/sys/contrib/openzfs/config/zfs-build.m4
@@ -226,6 +226,7 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS], [
 	ZFS_AC_CONFIG_ALWAYS_SED
 	ZFS_AC_CONFIG_ALWAYS_CPPCHECK
 	ZFS_AC_CONFIG_ALWAYS_SHELLCHECK
+	ZFS_AC_CONFIG_ALWAYS_PARALLEL
 ])
 
 AC_DEFUN([ZFS_AC_CONFIG], [
diff --git a/sys/contrib/openzfs/configure.ac b/sys/contrib/openzfs/configure.ac
index 4ff902cdc289..1ba037a36aa4 100644
--- a/sys/contrib/openzfs/configure.ac
+++ b/sys/contrib/openzfs/configure.ac
@@ -213,6 +213,7 @@ AC_CONFIG_FILES([
 	tests/zfs-tests/cmd/file_trunc/Makefile
 	tests/zfs-tests/cmd/file_write/Makefile
 	tests/zfs-tests/cmd/get_diff/Makefile
+	tests/zfs-tests/cmd/getversion/Makefile
 	tests/zfs-tests/cmd/largest_file/Makefile
 	tests/zfs-tests/cmd/libzfs_input_check/Makefile
 	tests/zfs-tests/cmd/mkbusy/Makefile
@@ -388,6 +389,7 @@ AC_CONFIG_FILES([
 	tests/zfs-tests/tests/functional/snapshot/Makefile
 	tests/zfs-tests/tests/functional/snapused/Makefile
 	tests/zfs-tests/tests/functional/sparse/Makefile
+	tests/zfs-tests/tests/functional/stat/Makefile
 	tests/zfs-tests/tests/functional/suid/Makefile
 	tests/zfs-tests/tests/functional/threadsappend/Makefile
 	tests/zfs-tests/tests/functional/tmpfile/Makefile
diff --git a/sys/contrib/openzfs/contrib/dracut/90zfs/module-setup.sh.in b/sys/contrib/openzfs/contrib/dracut/90zfs/module-setup.sh.in
index 10f915b2ef86..1eaff331eab4 100755
--- a/sys/contrib/openzfs/contrib/dracut/90zfs/module-setup.sh.in
+++ b/sys/contrib/openzfs/contrib/dracut/90zfs/module-setup.sh.in
@@ -61,7 +61,7 @@ install() {
 		dracut_install /usr/lib*/gcc/**/libgcc_s.so*
 	fi
 	# shellcheck disable=SC2050
-	if [ "@LIBFETCH_DYNAMIC@" != 0 ]; then
+	if [ @LIBFETCH_DYNAMIC@ -gt 0 ]; then
 		for d in $libdirs; do
 			[ -e "$d/@LIBFETCH_SONAME@" ] && dracut_install "$d/@LIBFETCH_SONAME@"
 		done
diff --git a/sys/contrib/openzfs/contrib/dracut/90zfs/zfs-load-key.sh.in b/sys/contrib/openzfs/contrib/dracut/90zfs/zfs-load-key.sh.in
index 2138ff943c64..c974b3d9ec4c 100755
--- a/sys/contrib/openzfs/contrib/dracut/90zfs/zfs-load-key.sh.in
+++ b/sys/contrib/openzfs/contrib/dracut/90zfs/zfs-load-key.sh.in
@@ -45,7 +45,7 @@ if [ "$(zpool list -H -o feature@encryption "${BOOTFS%%/*}")" = 'active' ]; then
         case "${KEYLOCATION%%://*}" in
             prompt)
                 for _ in 1 2 3; do
-                    systemd-ask-password "Encrypted ZFS password for ${BOOTFS}" --no-tty | zfs load-key "${ENCRYPTIONROOT}" && break
+                    systemd-ask-password --no-tty "Encrypted ZFS password for ${BOOTFS}" | zfs load-key "${ENCRYPTIONROOT}" && break
                 done
                 ;;
             http*)
diff --git a/sys/contrib/openzfs/contrib/initramfs/hooks/zfs.in b/sys/contrib/openzfs/contrib/initramfs/hooks/zfs.in
index 176a1568ec77..28dd252eea52 100755
--- a/sys/contrib/openzfs/contrib/initramfs/hooks/zfs.in
+++ b/sys/contrib/openzfs/contrib/initramfs/hooks/zfs.in
@@ -30,7 +30,7 @@ find /lib/ -type f -name "libgcc_s.so.[1-9]" | while read -r libgcc; do
 done
 
 # shellcheck disable=SC2050
-if [ "@LIBFETCH_DYNAMIC@" != 0 ]; then
+if [ @LIBFETCH_DYNAMIC@ -gt 0 ]; then
 	find /lib/ -name "@LIBFETCH_SONAME@" | while read -r libfetch; do
 		copy_exec "$libfetch"
 	done
diff --git a/sys/contrib/openzfs/contrib/initramfs/scripts/zfs b/sys/contrib/openzfs/contrib/initramfs/scripts/zfs
index fcb712cff272..85b00f9da86d 100644
--- a/sys/contrib/openzfs/contrib/initramfs/scripts/zfs
+++ b/sys/contrib/openzfs/contrib/initramfs/scripts/zfs
@@ -421,7 +421,7 @@ decrypt_fs()
 			elif [ -e /run/systemd/system ]; then
 				echo "systemd-ask-password" > /run/zfs_console_askpwd_cmd
 				for _ in 1 2 3; do
-					systemd-ask-password "Encrypted ZFS password for ${ENCRYPTIONROOT}" --no-tty | \
+					systemd-ask-password --no-tty "Encrypted ZFS password for ${ENCRYPTIONROOT}" | \
 						$ZFS load-key "${ENCRYPTIONROOT}" && break
 				done
 
diff --git a/sys/contrib/openzfs/contrib/pam_zfs_key/pam_zfs_key.c b/sys/contrib/openzfs/contrib/pam_zfs_key/pam_zfs_key.c
index dead090f9701..9702189f6702 100644
--- a/sys/contrib/openzfs/contrib/pam_zfs_key/pam_zfs_key.c
+++ b/sys/contrib/openzfs/contrib/pam_zfs_key/pam_zfs_key.c
@@ -219,6 +219,8 @@ pw_clear(pam_handle_t *pamh)
 static void
 destroy_pw(pam_handle_t *pamh, void *data, int errcode)
 {
+	(void) pamh, (void) errcode;
+
 	if (data != NULL) {
 		pw_free((pw_password_t *)data);
 	}
@@ -638,6 +640,8 @@ PAM_EXTERN int
 pam_sm_authenticate(pam_handle_t *pamh, int flags,
     int argc, const char **argv)
 {
+	(void) flags, (void) argc, (void) argv;
+
 	if (pw_fetch_lazy(pamh) == NULL) {
 		return (PAM_AUTH_ERR);
 	}
@@ -650,6 +654,7 @@ PAM_EXTERN int
 pam_sm_setcred(pam_handle_t *pamh, int flags,
     int argc, const char **argv)
 {
+	(void) pamh, (void) flags, (void) argc, (void) argv;
 	return (PAM_SUCCESS);
 }
 
@@ -737,6 +742,8 @@ PAM_EXTERN int
 pam_sm_open_session(pam_handle_t *pamh, int flags,
     int argc, const char **argv)
 {
+	(void) flags;
+
 	if (geteuid() != 0) {
 		pam_syslog(pamh, LOG_ERR,
 		    "Cannot zfs_mount when not being root.");
@@ -791,6 +798,8 @@ PAM_EXTERN int
 pam_sm_close_session(pam_handle_t *pamh, int flags,
     int argc, const char **argv)
 {
+	(void) flags;
+
 	if (geteuid() != 0) {
 		pam_syslog(pamh, LOG_ERR,
 		    "Cannot zfs_mount when not being root.");
diff --git a/sys/contrib/openzfs/contrib/pyzfs/setup.py.in b/sys/contrib/openzfs/contrib/pyzfs/setup.py.in
index bd8ffc728fa6..934b3189ebe1 100644
--- a/sys/contrib/openzfs/contrib/pyzfs/setup.py.in
+++ b/sys/contrib/openzfs/contrib/pyzfs/setup.py.in
@@ -29,13 +29,12 @@ setup(
         "Development Status :: 4 - Beta",
         "Intended Audience :: Developers",
         "License :: OSI Approved :: Apache Software License",
-        "Programming Language :: Python :: 2",
-        "Programming Language :: Python :: 2.7",
         "Programming Language :: Python :: 3",
-        "Programming Language :: Python :: 3.4",
-        "Programming Language :: Python :: 3.5",
         "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
         "Topic :: System :: Filesystems",
         "Topic :: Software Development :: Libraries",
     ],
@@ -53,7 +52,7 @@ setup(
     setup_requires=[
         "cffi",
     ],
-    python_requires='>=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,<4',
+    python_requires='>=3.6,<4',
     zip_safe=False,
     test_suite="libzfs_core.test",
 )
diff --git a/sys/contrib/openzfs/etc/Makefile.am b/sys/contrib/openzfs/etc/Makefile.am
index aa9ff182c863..4d2002036102 100644
--- a/sys/contrib/openzfs/etc/Makefile.am
+++ b/sys/contrib/openzfs/etc/Makefile.am
@@ -1,9 +1,10 @@
 include $(top_srcdir)/config/Shellcheck.am
 
 SUBDIRS = zfs sudoers.d
-SHELLCHECKDIRS = zfs
+SHELLCHECKDIRS = default $(ZFS_INIT_SYSV) zfs
+SHELLCHECK_OPTS = --enable=all
+
 if BUILD_LINUX
-SHELLCHECKDIRS += default $(ZFS_INIT_SYSV)
 SUBDIRS += default $(ZFS_INIT_SYSTEMD) $(ZFS_INIT_SYSV) $(ZFS_MODULE_LOAD)
 endif
 DIST_SUBDIRS = default init.d zfs systemd modules-load.d sudoers.d
diff --git a/sys/contrib/openzfs/etc/default/Makefile.am b/sys/contrib/openzfs/etc/default/Makefile.am
index 0f7c96698d45..74a4edd62873 100644
--- a/sys/contrib/openzfs/etc/default/Makefile.am
+++ b/sys/contrib/openzfs/etc/default/Makefile.am
@@ -5,4 +5,5 @@ initconf_SCRIPTS = zfs
 
 SUBSTFILES += $(initconf_SCRIPTS)
 
-SHELLCHECK_SHELL = sh
+SHELLCHECK_SHELL = dash
+SHELLCHECK_OPTS = --enable=all
diff --git a/sys/contrib/openzfs/etc/default/zfs.in b/sys/contrib/openzfs/etc/default/zfs.in
index fb4a1b65e348..ae813e9de9dd 100644
--- a/sys/contrib/openzfs/etc/default/zfs.in
+++ b/sys/contrib/openzfs/etc/default/zfs.in
@@ -1,4 +1,5 @@
 # OpenZFS userland configuration.
+# shellcheck disable=SC2154
 
 # NOTE: This file is intended for sysv init and initramfs.
 # Changing some of these settings may not make any difference on
diff --git a/sys/contrib/openzfs/etc/init.d/Makefile.am b/sys/contrib/openzfs/etc/init.d/Makefile.am
index 658623fda4aa..c336d607551d 100644
--- a/sys/contrib/openzfs/etc/init.d/Makefile.am
+++ b/sys/contrib/openzfs/etc/init.d/Makefile.am
@@ -7,4 +7,5 @@ init_SCRIPTS = zfs-import zfs-load-key zfs-mount zfs-share zfs-zed
 
 SUBSTFILES += $(init_SCRIPTS)
 
-SHELLCHECK_SHELL = dash # local variables
+SHELLCHECK_SHELL = dash
+SHELLCHECK_OPTS = --enable=all
diff --git a/sys/contrib/openzfs/etc/init.d/zfs-import.in b/sys/contrib/openzfs/etc/init.d/zfs-import.in
index 130174f74d06..a9a0604f81ac 100755
--- a/sys/contrib/openzfs/etc/init.d/zfs-import.in
+++ b/sys/contrib/openzfs/etc/init.d/zfs-import.in
@@ -1,4 +1,5 @@
 #!@DEFAULT_INIT_SHELL@
+# shellcheck disable=SC2154
 #
 # zfs-import    This script will import ZFS pools
 #
diff --git a/sys/contrib/openzfs/etc/init.d/zfs-load-key.in b/sys/contrib/openzfs/etc/init.d/zfs-load-key.in
index 2f8deffdc809..53c7766b793a 100755
--- a/sys/contrib/openzfs/etc/init.d/zfs-load-key.in
+++ b/sys/contrib/openzfs/etc/init.d/zfs-load-key.in
@@ -1,4 +1,5 @@
 #!@DEFAULT_INIT_SHELL@
+# shellcheck disable=SC2154
 #
 # zfs-load-key  This script will load/unload the zfs filesystems keys.
 #
diff --git a/sys/contrib/openzfs/etc/init.d/zfs-mount.in b/sys/contrib/openzfs/etc/init.d/zfs-mount.in
index 000619b6717c..d196d1555a45 100755
--- a/sys/contrib/openzfs/etc/init.d/zfs-mount.in
+++ b/sys/contrib/openzfs/etc/init.d/zfs-mount.in
@@ -1,4 +1,5 @@
 #!@DEFAULT_INIT_SHELL@
+# shellcheck disable=SC2154
 #
 # zfs-mount     This script will mount/umount the zfs filesystems.
 #
@@ -68,7 +69,7 @@ do_mount()
 	check_boolean "$DO_OVERLAY_MOUNTS" && overlay=O
 
 	zfs_action "Mounting ZFS filesystem(s)" \
-	    "$ZFS" mount -a$verbose$overlay "$MOUNT_EXTRA_OPTIONS"
+	    "$ZFS" mount "-a$verbose$overlay" "$MOUNT_EXTRA_OPTIONS"
 
 	# Require each volume/filesystem to have 'noauto' and no fsck
 	# option. This shouldn't really be necessary, as long as one
diff --git a/sys/contrib/openzfs/etc/init.d/zfs-share.in b/sys/contrib/openzfs/etc/init.d/zfs-share.in
index ef628fe46363..88978071cbf6 100755
--- a/sys/contrib/openzfs/etc/init.d/zfs-share.in
+++ b/sys/contrib/openzfs/etc/init.d/zfs-share.in
@@ -1,4 +1,5 @@
 #!@DEFAULT_INIT_SHELL@
+# shellcheck disable=SC2154
 #
 # zfs-share     This script will network share zfs filesystems and volumes.
 #
diff --git a/sys/contrib/openzfs/etc/init.d/zfs-zed.in b/sys/contrib/openzfs/etc/init.d/zfs-zed.in
index e5256cbc6280..47f742259b27 100755
--- a/sys/contrib/openzfs/etc/init.d/zfs-zed.in
+++ b/sys/contrib/openzfs/etc/init.d/zfs-zed.in
@@ -1,4 +1,5 @@
 #!@DEFAULT_INIT_SHELL@
+# shellcheck disable=SC2154
 #
 # zfs-zed
 #
diff --git a/sys/contrib/openzfs/etc/systemd/system/.gitignore b/sys/contrib/openzfs/etc/systemd/system/.gitignore
index efada54ad932..4813c65a25a8 100644
--- a/sys/contrib/openzfs/etc/systemd/system/.gitignore
+++ b/sys/contrib/openzfs/etc/systemd/system/.gitignore
@@ -1,3 +1,4 @@
 *.service
 *.target
 *.preset
+*.timer
diff --git a/sys/contrib/openzfs/etc/systemd/system/Makefile.am b/sys/contrib/openzfs/etc/systemd/system/Makefile.am
index c374a52ac7db..5e65e1db420c 100644
--- a/sys/contrib/openzfs/etc/systemd/system/Makefile.am
+++ b/sys/contrib/openzfs/etc/systemd/system/Makefile.am
@@ -12,7 +12,10 @@ systemdunit_DATA = \
 	zfs-volume-wait.service \
 	zfs-import.target \
 	zfs-volumes.target \
-	zfs.target
+	zfs.target \
+	zfs-scrub-monthly@.timer \
+	zfs-scrub-weekly@.timer \
+	zfs-scrub@.service
 
 SUBSTFILES += $(systemdpreset_DATA) $(systemdunit_DATA)
 
diff --git a/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-monthly@.timer.in b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-monthly@.timer.in
new file mode 100644
index 000000000000..903068468278
--- /dev/null
+++ b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-monthly@.timer.in
@@ -0,0 +1,12 @@
+[Unit]
+Description=Monthly zpool scrub timer for %i
+Documentation=man:zpool-scrub(8)
+
+[Timer]
+OnCalendar=monthly
+Persistent=true
+RandomizedDelaySec=1h
+Unit=zfs-scrub@%i.service
+
+[Install]
+WantedBy=timers.target
diff --git a/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-weekly@.timer.in b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-weekly@.timer.in
new file mode 100644
index 000000000000..ede699500599
--- /dev/null
+++ b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub-weekly@.timer.in
@@ -0,0 +1,12 @@
+[Unit]
+Description=Weekly zpool scrub timer for %i
+Documentation=man:zpool-scrub(8)
+
+[Timer]
+OnCalendar=weekly
+Persistent=true
+RandomizedDelaySec=1h
+Unit=zfs-scrub@%i.service
+
+[Install]
+WantedBy=timers.target
diff --git a/sys/contrib/openzfs/etc/systemd/system/zfs-scrub@.service.in b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub@.service.in
new file mode 100644
index 000000000000..bebe91d746ae
--- /dev/null
+++ b/sys/contrib/openzfs/etc/systemd/system/zfs-scrub@.service.in
@@ -0,0 +1,14 @@
+[Unit]
+Description=zpool scrub on %i
+Documentation=man:zpool-scrub(8)
+Requires=zfs.target
+After=zfs.target
+ConditionACPower=true
+ConditionPathIsDirectory=/sys/module/zfs
+
+[Service]
+ExecStart=/bin/sh -c '\
+if @sbindir@/zpool status %i | grep "scrub in progress"; then\
+exec @sbindir@/zpool wait -t scrub %i;\
+else exec @sbindir@/zpool scrub -w %i; fi'
+ExecStop=-/bin/sh -c '@sbindir@/zpool scrub -p %i 2>/dev/null || true'
diff --git a/sys/contrib/openzfs/etc/zfs/Makefile.am b/sys/contrib/openzfs/etc/zfs/Makefile.am
index 3dee81c75860..b7dbd33ccf49 100644
--- a/sys/contrib/openzfs/etc/zfs/Makefile.am
+++ b/sys/contrib/openzfs/etc/zfs/Makefile.am
@@ -15,4 +15,5 @@ pkgsysconf_SCRIPTS = \
 
 SUBSTFILES += $(pkgsysconf_SCRIPTS)
 
-SHELLCHECK_SHELL = dash # local variables
+SHELLCHECK_OPTS = --enable=all
+SHELLCHECK_SHELL = dash
diff --git a/sys/contrib/openzfs/etc/zfs/zfs-functions.in b/sys/contrib/openzfs/etc/zfs/zfs-functions.in
index 30441dc35d4b..2ff1a186188f 100644
--- a/sys/contrib/openzfs/etc/zfs/zfs-functions.in
+++ b/sys/contrib/openzfs/etc/zfs/zfs-functions.in
@@ -46,6 +46,7 @@ elif type success > /dev/null 2>&1 ; then
 
 	zfs_log_begin_msg() { printf "%s" "$1 "; }
 	zfs_log_end_msg() {
+		# shellcheck disable=SC2154
 		zfs_set_ifs "$OLD_IFS"
 		if [ "$1" -eq 0 ]; then
 			success
@@ -119,12 +120,12 @@ zfs_action()
 	$CMD
 	ret=$?
 	if [ "$ret" -eq 0 ]; then
-		zfs_log_end_msg $ret
+		zfs_log_end_msg "$ret"
 	else
-		zfs_log_failure_msg $ret
+		zfs_log_failure_msg "$ret"
 	fi
 
-	return $ret
+	return "$ret"
 }
 
 # Returns
diff --git a/sys/contrib/openzfs/include/libzfs.h b/sys/contrib/openzfs/include/libzfs.h
index e135ae2ee066..fe70a5b3a6fd 100644
--- a/sys/contrib/openzfs/include/libzfs.h
+++ b/sys/contrib/openzfs/include/libzfs.h
@@ -452,7 +452,7 @@ _LIBZFS_H void zpool_print_unsup_feat(nvlist_t *config);
  */
 struct zfs_cmd;
 
-_LIBZFS_H const char *zfs_history_event_names[];
+_LIBZFS_H const char *const zfs_history_event_names[];
 
 typedef enum {
 	VDEV_NAME_PATH		= 1 << 0,
diff --git a/sys/contrib/openzfs/include/os/freebsd/spl/sys/debug.h b/sys/contrib/openzfs/include/os/freebsd/spl/sys/debug.h
index 1f820bc3345f..6df76db7eadf 100644
--- a/sys/contrib/openzfs/include/os/freebsd/spl/sys/debug.h
+++ b/sys/contrib/openzfs/include/os/freebsd/spl/sys/debug.h
@@ -133,14 +133,14 @@ void spl_dumpstack(void);
  */
 #ifdef NDEBUG
 
-#define	ASSERT(x)		((void)0)
-#define	ASSERT3B(x,y,z)		((void)0)
-#define	ASSERT3S(x,y,z)		((void)0)
-#define	ASSERT3U(x,y,z)		((void)0)
-#define	ASSERT3P(x,y,z)		((void)0)
-#define	ASSERT0(x)		((void)0)
-#define	IMPLY(A, B)		((void)0)
-#define	EQUIV(A, B)		((void)0)
+#define	ASSERT(x)		((void) sizeof (!!(x)))
+#define	ASSERT3B(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3S(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3U(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3P(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT0(x)		((void) sizeof (!!(x)))
+#define	IMPLY(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
+#define	EQUIV(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
 
 /*
  * Debugging enabled (--enable-debug)
diff --git a/sys/contrib/openzfs/include/os/freebsd/spl/sys/vnode.h b/sys/contrib/openzfs/include/os/freebsd/spl/sys/vnode.h
index 1ac595aa15dd..d2c900854acb 100644
--- a/sys/contrib/openzfs/include/os/freebsd/spl/sys/vnode.h
+++ b/sys/contrib/openzfs/include/os/freebsd/spl/sys/vnode.h
@@ -134,7 +134,6 @@ vn_flush_cached_data(vnode_t *vp, boolean_t sync)
 /* TODO: This field needs conversion! */
 #define	va_nblocks	va_bytes
 #define	va_blksize	va_blocksize
-#define	va_seq		va_gen
 
 #define	MAXOFFSET_T	OFF_MAX
 #define	EXCL		0
diff --git a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/freebsd_crypto.h b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/freebsd_crypto.h
index e240f5b0ddca..a3ed4182656c 100644
--- a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/freebsd_crypto.h
+++ b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/freebsd_crypto.h
@@ -88,11 +88,11 @@ void crypto_mac_final(struct hmac_ctx *ctx, void *out_data,
 	size_t out_data_size);
 
 int freebsd_crypt_newsession(freebsd_crypt_session_t *sessp,
-    struct zio_crypt_info *, crypto_key_t *);
+    const struct zio_crypt_info *, crypto_key_t *);
 void freebsd_crypt_freesession(freebsd_crypt_session_t *sessp);
 
 int freebsd_crypt_uio(boolean_t, freebsd_crypt_session_t *,
-	struct zio_crypt_info *, zfs_uio_t *, crypto_key_t *, uint8_t *,
+	const struct zio_crypt_info *, zfs_uio_t *, crypto_key_t *, uint8_t *,
 	size_t, size_t);
 
 #endif /* _ZFS_FREEBSD_CRYPTO_H */
diff --git a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_context_os.h b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_context_os.h
index a32eb52c53c1..867199501396 100644
--- a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_context_os.h
+++ b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_context_os.h
@@ -48,7 +48,7 @@
 #define	cond_resched()		kern_yield(PRI_USER)
 
 #define	taskq_create_sysdc(a, b, d, e, p, dc, f) \
-	    (taskq_create(a, b, maxclsyspri, d, e, f))
+	    ((void) sizeof (dc), taskq_create(a, b, maxclsyspri, d, e, f))
 
 #define	tsd_create(keyp, destructor)    do {                 \
 		*(keyp) = osd_thread_register((destructor));         \
diff --git a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_znode_impl.h b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_znode_impl.h
index 4456046e6e4c..096c9e16d347 100644
--- a/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_znode_impl.h
+++ b/sys/contrib/openzfs/include/os/freebsd/zfs/sys/zfs_znode_impl.h
@@ -175,8 +175,7 @@ extern void	zfs_tstamp_update_setup_ext(struct znode *,
     uint_t, uint64_t [2], uint64_t [2], boolean_t have_tx);
 extern void zfs_znode_free(struct znode *);
 
-extern zil_replay_func_t *zfs_replay_vector[TX_MAX_TYPE];
-extern int zfsfstype;
+extern zil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE];
 
 extern int zfs_znode_parent_and_name(struct znode *zp, struct znode **dzpp,
     char *buf);
diff --git a/sys/contrib/openzfs/include/os/linux/spl/rpc/xdr.h b/sys/contrib/openzfs/include/os/linux/spl/rpc/xdr.h
index c62080a1178a..1c03a42a9961 100644
--- a/sys/contrib/openzfs/include/os/linux/spl/rpc/xdr.h
+++ b/sys/contrib/openzfs/include/os/linux/spl/rpc/xdr.h
@@ -36,7 +36,8 @@ enum xdr_op {
 struct xdr_ops;
 
 typedef struct {
-	struct xdr_ops	*x_ops;	/* Let caller know xdrmem_create() succeeds */
+	const struct xdr_ops	*x_ops;
+	    /* Let caller know xdrmem_create() succeeds */
 	caddr_t		x_addr;	/* Current buffer addr */
 	caddr_t		x_addr_end;	/* End of the buffer */
 	enum xdr_op	x_op;	/* Stream direction */
diff --git a/sys/contrib/openzfs/include/os/linux/spl/sys/debug.h b/sys/contrib/openzfs/include/os/linux/spl/sys/debug.h
index dc6b85eebff7..102fc640bf56 100644
--- a/sys/contrib/openzfs/include/os/linux/spl/sys/debug.h
+++ b/sys/contrib/openzfs/include/os/linux/spl/sys/debug.h
@@ -133,14 +133,14 @@ void spl_dumpstack(void);
  */
 #ifdef NDEBUG
 
-#define	ASSERT(x)		((void)0)
-#define	ASSERT3B(x,y,z)		((void)0)
-#define	ASSERT3S(x,y,z)		((void)0)
-#define	ASSERT3U(x,y,z)		((void)0)
-#define	ASSERT3P(x,y,z)		((void)0)
-#define	ASSERT0(x)		((void)0)
-#define	IMPLY(A, B)		((void)0)
-#define	EQUIV(A, B)		((void)0)
+#define	ASSERT(x)		((void) sizeof (!!(x)))
+#define	ASSERT3B(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3S(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3U(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3P(x,y,z)		((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT0(x)		((void) sizeof (!!(x)))
+#define	IMPLY(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
+#define	EQUIV(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
 
 /*
  * Debugging enabled (--enable-debug)
diff --git a/sys/contrib/openzfs/include/os/linux/spl/sys/sysmacros.h b/sys/contrib/openzfs/include/os/linux/spl/sys/sysmacros.h
index 98d1ab1d7f8a..be1f77e43bda 100644
--- a/sys/contrib/openzfs/include/os/linux/spl/sys/sysmacros.h
+++ b/sys/contrib/openzfs/include/os/linux/spl/sys/sysmacros.h
@@ -113,7 +113,6 @@
 #endif
 
 /* Missing globals */
-extern char spl_gitrev[64];
 extern unsigned long spl_hostid;
 
 /* Missing misc functions */
diff --git a/sys/contrib/openzfs/include/os/linux/spl/sys/taskq.h b/sys/contrib/openzfs/include/os/linux/spl/sys/taskq.h
index b50175a10873..2a6cd8283d16 100644
--- a/sys/contrib/openzfs/include/os/linux/spl/sys/taskq.h
+++ b/sys/contrib/openzfs/include/os/linux/spl/sys/taskq.h
@@ -160,7 +160,8 @@ extern taskq_t *taskq_of_curthread(void);
 #define	taskq_create_proc(name, nthreads, pri, min, max, proc, flags) \
     taskq_create(name, nthreads, pri, min, max, flags)
 #define	taskq_create_sysdc(name, nthreads, min, max, proc, dc, flags) \
-    taskq_create(name, nthreads, maxclsyspri, min, max, flags)
+	((void) sizeof (dc), \
+	    taskq_create(name, nthreads, maxclsyspri, min, max, flags))
 
 int spl_taskq_init(void);
 void spl_taskq_fini(void);
diff --git a/sys/contrib/openzfs/include/os/linux/zfs/sys/zfs_znode_impl.h b/sys/contrib/openzfs/include/os/linux/zfs/sys/zfs_znode_impl.h
index de46fc8f2bd8..2e1bd857614d 100644
--- a/sys/contrib/openzfs/include/os/linux/zfs/sys/zfs_znode_impl.h
+++ b/sys/contrib/openzfs/include/os/linux/zfs/sys/zfs_znode_impl.h
@@ -173,8 +173,7 @@ extern caddr_t zfs_map_page(page_t *, enum seg_rw);
 extern void zfs_unmap_page(page_t *, caddr_t);
 #endif /* HAVE_UIO_RW */
 
-extern zil_replay_func_t *zfs_replay_vector[TX_MAX_TYPE];
-extern int zfsfstype;
+extern zil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE];
 
 #ifdef	__cplusplus
 }
diff --git a/sys/contrib/openzfs/include/os/linux/zfs/sys/zpl.h b/sys/contrib/openzfs/include/os/linux/zfs/sys/zpl.h
index ff86e027bbe2..afb16e5c7907 100644
--- a/sys/contrib/openzfs/include/os/linux/zfs/sys/zpl.h
+++ b/sys/contrib/openzfs/include/os/linux/zfs/sys/zpl.h
@@ -99,7 +99,6 @@ extern const struct inode_operations zpl_ops_root;
 
 extern const struct file_operations zpl_fops_snapdir;
 extern const struct inode_operations zpl_ops_snapdir;
-extern const struct dentry_operations zpl_dops_snapdirs;
 
 extern const struct file_operations zpl_fops_shares;
 extern const struct inode_operations zpl_ops_shares;
diff --git a/sys/contrib/openzfs/include/sys/arc.h b/sys/contrib/openzfs/include/sys/arc.h
index 9041939e5b78..4f9bfe48d7e3 100644
--- a/sys/contrib/openzfs/include/sys/arc.h
+++ b/sys/contrib/openzfs/include/sys/arc.h
@@ -295,6 +295,8 @@ void arc_buf_freeze(arc_buf_t *buf);
 void arc_buf_thaw(arc_buf_t *buf);
 #ifdef ZFS_DEBUG
 int arc_referenced(arc_buf_t *buf);
+#else
+#define	arc_referenced(buf) ((void) sizeof (buf), 0)
 #endif
 
 int arc_read(zio_t *pio, spa_t *spa, const blkptr_t *bp,
diff --git a/sys/contrib/openzfs/include/sys/crypto/api.h b/sys/contrib/openzfs/include/sys/crypto/api.h
index 8aecfeaff0f4..17c9a645922e 100644
--- a/sys/contrib/openzfs/include/sys/crypto/api.h
+++ b/sys/contrib/openzfs/include/sys/crypto/api.h
@@ -58,7 +58,7 @@ typedef struct {
  */
 
 #define	CRYPTO_MECH_INVALID	((uint64_t)-1)
-extern crypto_mech_type_t crypto_mech2id(char *name);
+extern crypto_mech_type_t crypto_mech2id(const char *name);
 
 /*
  * Create and destroy context templates.
diff --git a/sys/contrib/openzfs/include/sys/crypto/icp.h b/sys/contrib/openzfs/include/sys/crypto/icp.h
index 4609e3a1dae7..ae7f7eae529e 100644
--- a/sys/contrib/openzfs/include/sys/crypto/icp.h
+++ b/sys/contrib/openzfs/include/sys/crypto/icp.h
@@ -29,12 +29,6 @@
 int aes_mod_init(void);
 int aes_mod_fini(void);
 
-int edonr_mod_init(void);
-int edonr_mod_fini(void);
-
-int sha1_mod_init(void);
-int sha1_mod_fini(void);
-
 int sha2_mod_init(void);
 int sha2_mod_fini(void);
 
diff --git a/sys/contrib/openzfs/include/sys/dmu.h b/sys/contrib/openzfs/include/sys/dmu.h
index 942ab9b10835..1ddff0d4e4e7 100644
--- a/sys/contrib/openzfs/include/sys/dmu.h
+++ b/sys/contrib/openzfs/include/sys/dmu.h
@@ -664,7 +664,6 @@ typedef struct dmu_buf_user {
  * NOTE: This function should only be called once on a given dmu_buf_user_t.
  *       To allow enforcement of this, dbu must already be zeroed on entry.
  */
-/*ARGSUSED*/
 static inline void
 dmu_buf_init_user(dmu_buf_user_t *dbu, dmu_buf_evict_func_t *evict_func_sync,
     dmu_buf_evict_func_t *evict_func_async,
@@ -863,7 +862,6 @@ int dmu_assign_arcbuf_by_dnode(dnode_t *dn, uint64_t offset,
 int dmu_assign_arcbuf_by_dbuf(dmu_buf_t *handle, uint64_t offset,
     struct arc_buf *buf, dmu_tx_t *tx);
 #define	dmu_assign_arcbuf	dmu_assign_arcbuf_by_dbuf
-extern int zfs_prefetch_disable;
 extern int zfs_max_recordsize;
 
 /*
diff --git a/sys/contrib/openzfs/include/sys/dmu_recv.h b/sys/contrib/openzfs/include/sys/dmu_recv.h
index 7188b2a02248..1fdb986e2ed6 100644
--- a/sys/contrib/openzfs/include/sys/dmu_recv.h
+++ b/sys/contrib/openzfs/include/sys/dmu_recv.h
@@ -35,7 +35,7 @@
 #include <sys/spa.h>
 #include <sys/objlist.h>
 
-extern const char *recv_clone_name;
+extern const char *const recv_clone_name;
 
 typedef struct dmu_recv_cookie {
 	struct dsl_dataset *drc_ds;
diff --git a/sys/contrib/openzfs/include/sys/dsl_dataset.h b/sys/contrib/openzfs/include/sys/dsl_dataset.h
index 3c9199b861c4..29bbf7e1868a 100644
--- a/sys/contrib/openzfs/include/sys/dsl_dataset.h
+++ b/sys/contrib/openzfs/include/sys/dsl_dataset.h
@@ -45,7 +45,6 @@
 extern "C" {
 #endif
 
-extern int zfs_allow_redacted_dataset_mount;
 struct dsl_dataset;
 struct dsl_dir;
 struct dsl_pool;
@@ -441,8 +440,8 @@ int dsl_dataset_set_compression(const char *dsname, zprop_source_t source,
 
 boolean_t dsl_dataset_is_before(dsl_dataset_t *later, dsl_dataset_t *earlier,
     uint64_t earlier_txg);
-void dsl_dataset_long_hold(dsl_dataset_t *ds, void *tag);
-void dsl_dataset_long_rele(dsl_dataset_t *ds, void *tag);
+void dsl_dataset_long_hold(dsl_dataset_t *ds, const void *tag);
+void dsl_dataset_long_rele(dsl_dataset_t *ds, const void *tag);
 boolean_t dsl_dataset_long_held(dsl_dataset_t *ds);
 
 int dsl_dataset_clone_swap_check_impl(dsl_dataset_t *clone,
diff --git a/sys/contrib/openzfs/include/sys/dsl_pool.h b/sys/contrib/openzfs/include/sys/dsl_pool.h
index 44900f8ceb2f..0283a8c589c1 100644
--- a/sys/contrib/openzfs/include/sys/dsl_pool.h
+++ b/sys/contrib/openzfs/include/sys/dsl_pool.h
@@ -60,7 +60,6 @@ struct dsl_deadlist;
 extern unsigned long zfs_dirty_data_max;
 extern unsigned long zfs_dirty_data_max_max;
 extern unsigned long zfs_wrlog_data_max;
-extern int zfs_dirty_data_sync_percent;
 extern int zfs_dirty_data_max_percent;
 extern int zfs_dirty_data_max_max_percent;
 extern int zfs_delay_min_dirty_percent;
diff --git a/sys/contrib/openzfs/include/sys/efi_partition.h b/sys/contrib/openzfs/include/sys/efi_partition.h
index cda2c98e5d53..af3e98a07954 100644
--- a/sys/contrib/openzfs/include/sys/efi_partition.h
+++ b/sys/contrib/openzfs/include/sys/efi_partition.h
@@ -369,7 +369,6 @@ _SYS_EFI_PARTITION_H int efi_alloc_and_read(int, struct dk_gpt **);
 _SYS_EFI_PARTITION_H int efi_write(int, struct dk_gpt *);
 _SYS_EFI_PARTITION_H int efi_rescan(int);
 _SYS_EFI_PARTITION_H void efi_free(struct dk_gpt *);
-_SYS_EFI_PARTITION_H int efi_type(int);
 _SYS_EFI_PARTITION_H void efi_err_check(struct dk_gpt *);
 _SYS_EFI_PARTITION_H int efi_use_whole_disk(int fd);
 #endif
diff --git a/sys/contrib/openzfs/include/sys/fs/zfs.h b/sys/contrib/openzfs/include/sys/fs/zfs.h
index 287b3beae91e..6bc82198df23 100644
--- a/sys/contrib/openzfs/include/sys/fs/zfs.h
+++ b/sys/contrib/openzfs/include/sys/fs/zfs.h
@@ -206,7 +206,8 @@ typedef enum {
 	ZFS_NUM_USERQUOTA_PROPS
 } zfs_userquota_prop_t;
 
-_SYS_FS_ZFS_H const char *zfs_userquota_prop_prefixes[ZFS_NUM_USERQUOTA_PROPS];
+_SYS_FS_ZFS_H const char *const zfs_userquota_prop_prefixes[
+    ZFS_NUM_USERQUOTA_PROPS];
 
 /*
  * Pool properties are identified by these constants and must be added to the
diff --git a/sys/contrib/openzfs/include/sys/metaslab.h b/sys/contrib/openzfs/include/sys/metaslab.h
index ecff65f13de5..129a68be41c5 100644
--- a/sys/contrib/openzfs/include/sys/metaslab.h
+++ b/sys/contrib/openzfs/include/sys/metaslab.h
@@ -43,7 +43,7 @@ typedef struct metaslab_ops {
 } metaslab_ops_t;
 
 
-extern metaslab_ops_t *zfs_metaslab_ops;
+extern const metaslab_ops_t zfs_metaslab_ops;
 
 int metaslab_init(metaslab_group_t *, uint64_t, uint64_t, uint64_t,
     metaslab_t **);
@@ -101,7 +101,7 @@ void metaslab_stat_fini(void);
 void metaslab_trace_init(zio_alloc_list_t *);
 void metaslab_trace_fini(zio_alloc_list_t *);
 
-metaslab_class_t *metaslab_class_create(spa_t *, metaslab_ops_t *);
+metaslab_class_t *metaslab_class_create(spa_t *, const metaslab_ops_t *);
 void metaslab_class_destroy(metaslab_class_t *);
 int metaslab_class_validate(metaslab_class_t *);
 void metaslab_class_histogram_verify(metaslab_class_t *);
diff --git a/sys/contrib/openzfs/include/sys/metaslab_impl.h b/sys/contrib/openzfs/include/sys/metaslab_impl.h
index adf4c03a20db..3dbee4c17fef 100644
--- a/sys/contrib/openzfs/include/sys/metaslab_impl.h
+++ b/sys/contrib/openzfs/include/sys/metaslab_impl.h
@@ -179,7 +179,7 @@ typedef struct metaslab_class_allocator {
 struct metaslab_class {
 	kmutex_t		mc_lock;
 	spa_t			*mc_spa;
-	metaslab_ops_t		*mc_ops;
+	const metaslab_ops_t		*mc_ops;
 
 	/*
 	 * Track the number of metaslab groups that have been initialized
diff --git a/sys/contrib/openzfs/include/sys/nvpair.h b/sys/contrib/openzfs/include/sys/nvpair.h
index 340b0d79c0a2..81494b62d7ec 100644
--- a/sys/contrib/openzfs/include/sys/nvpair.h
+++ b/sys/contrib/openzfs/include/sys/nvpair.h
@@ -135,12 +135,12 @@ struct nv_alloc_ops {
 	void (*nv_ao_reset)(nv_alloc_t *);
 };
 
-_SYS_NVPAIR_H const nv_alloc_ops_t *nv_fixed_ops;
-_SYS_NVPAIR_H nv_alloc_t *nv_alloc_nosleep;
+_SYS_NVPAIR_H const nv_alloc_ops_t *const nv_fixed_ops;
+_SYS_NVPAIR_H nv_alloc_t *const nv_alloc_nosleep;
 
 #if defined(_KERNEL)
-_SYS_NVPAIR_H nv_alloc_t *nv_alloc_sleep;
-_SYS_NVPAIR_H nv_alloc_t *nv_alloc_pushpage;
+_SYS_NVPAIR_H nv_alloc_t *const nv_alloc_sleep;
+_SYS_NVPAIR_H nv_alloc_t *const nv_alloc_pushpage;
 #endif
 
 _SYS_NVPAIR_H int nv_alloc_init(nv_alloc_t *, const nv_alloc_ops_t *,
diff --git a/sys/contrib/openzfs/include/sys/qat.h b/sys/contrib/openzfs/include/sys/qat.h
index 9ae8eb173572..fe0f2c672f97 100644
--- a/sys/contrib/openzfs/include/sys/qat.h
+++ b/sys/contrib/openzfs/include/sys/qat.h
@@ -171,7 +171,7 @@ extern int qat_init(void);
 extern void qat_fini(void);
 
 /* fake CpaStatus used to indicate data was not compressible */
-#define	CPA_STATUS_INCOMPRESSIBLE				(-127)
+#define	CPA_STATUS_INCOMPRESSIBLE		(-127)
 
 extern boolean_t qat_dc_use_accel(size_t s_len);
 extern boolean_t qat_crypt_use_accel(size_t s_len);
@@ -184,16 +184,24 @@ extern int qat_crypt(qat_encrypt_dir_t dir, uint8_t *src_buf, uint8_t *dst_buf,
 extern int qat_checksum(uint64_t cksum, uint8_t *buf, uint64_t size,
     zio_cksum_t *zcp);
 #else
-#define	CPA_STATUS_SUCCESS					0
-#define	CPA_STATUS_INCOMPRESSIBLE				(-127)
+#define	CPA_STATUS_SUCCESS			0
+#define	CPA_STATUS_INCOMPRESSIBLE		(-127)
 #define	qat_init()
 #define	qat_fini()
-#define	qat_dc_use_accel(s_len)					0
-#define	qat_crypt_use_accel(s_len)				0
-#define	qat_checksum_use_accel(s_len)				0
-#define	qat_compress(dir, s, sl, d, dl, cl)			0
-#define	qat_crypt(dir, s, d, a, al, i, db, k, c, el)		0
-#define	qat_checksum(c, buf, s, z)				0
+#define	qat_dc_use_accel(s_len)			((void) sizeof (s_len), 0)
+#define	qat_crypt_use_accel(s_len)		((void) sizeof (s_len), 0)
+#define	qat_checksum_use_accel(s_len)		((void) sizeof (s_len), 0)
+#define	qat_compress(dir, s, sl, d, dl, cl)			\
+	((void) sizeof (dir), (void) sizeof (s), (void) sizeof (sl), \
+	    (void) sizeof (d), (void) sizeof (dl), (void) sizeof (cl), 0)
+#define	qat_crypt(dir, s, d, a, al, i, db, k, c, el)		\
+	((void) sizeof (dir), (void) sizeof (s), (void) sizeof (d), \
+	    (void) sizeof (a),  (void) sizeof (al), (void) sizeof (i), \
+	    (void) sizeof (db), (void) sizeof (k), (void) sizeof (c), \
+	    (void) sizeof (el), 0)
+#define	qat_checksum(c, buf, s, z)				\
+	((void) sizeof (c), (void) sizeof (buf), (void) sizeof (s), \
+	    (void) sizeof (z), 0)
 #endif
 
 #endif /* _SYS_QAT_H */
diff --git a/sys/contrib/openzfs/include/sys/range_tree.h b/sys/contrib/openzfs/include/sys/range_tree.h
index fef3d4d7bd21..895d802572d8 100644
--- a/sys/contrib/openzfs/include/sys/range_tree.h
+++ b/sys/contrib/openzfs/include/sys/range_tree.h
@@ -63,7 +63,7 @@ typedef struct range_tree {
 	 */
 	uint8_t		rt_shift;
 	uint64_t	rt_start;
-	range_tree_ops_t *rt_ops;
+	const range_tree_ops_t *rt_ops;
 
 	/* rt_btree_compare should only be set if rt_arg is a b-tree */
 	void		*rt_arg;
@@ -278,11 +278,11 @@ rs_set_fill(range_seg_t *rs, range_tree_t *rt, uint64_t fill)
 
 typedef void range_tree_func_t(void *arg, uint64_t start, uint64_t size);
 
-range_tree_t *range_tree_create_impl(range_tree_ops_t *ops,
+range_tree_t *range_tree_create_impl(const range_tree_ops_t *ops,
     range_seg_type_t type, void *arg, uint64_t start, uint64_t shift,
     int (*zfs_btree_compare) (const void *, const void *), uint64_t gap);
-range_tree_t *range_tree_create(range_tree_ops_t *ops, range_seg_type_t type,
-    void *arg, uint64_t start, uint64_t shift);
+range_tree_t *range_tree_create(const range_tree_ops_t *ops,
+    range_seg_type_t type, void *arg, uint64_t start, uint64_t shift);
 void range_tree_destroy(range_tree_t *rt);
 boolean_t range_tree_contains(range_tree_t *rt, uint64_t start, uint64_t size);
 range_seg_t *range_tree_find(range_tree_t *rt, uint64_t start, uint64_t size);
@@ -321,7 +321,7 @@ void rt_btree_destroy(range_tree_t *rt, void *arg);
 void rt_btree_add(range_tree_t *rt, range_seg_t *rs, void *arg);
 void rt_btree_remove(range_tree_t *rt, range_seg_t *rs, void *arg);
 void rt_btree_vacate(range_tree_t *rt, void *arg);
-extern range_tree_ops_t rt_btree_ops;
+extern const range_tree_ops_t rt_btree_ops;
 
 #ifdef	__cplusplus
 }
diff --git a/sys/contrib/openzfs/include/sys/sa.h b/sys/contrib/openzfs/include/sys/sa.h
index 98eb8f9cd79f..32f6bd0ccd95 100644
--- a/sys/contrib/openzfs/include/sys/sa.h
+++ b/sys/contrib/openzfs/include/sys/sa.h
@@ -143,7 +143,8 @@ uint64_t sa_handle_object(sa_handle_t *);
 boolean_t sa_attr_would_spill(sa_handle_t *, sa_attr_type_t, int size);
 void sa_spill_rele(sa_handle_t *);
 void sa_register_update_callback(objset_t *, sa_update_cb_t *);
-int sa_setup(objset_t *, uint64_t, sa_attr_reg_t *, int, sa_attr_type_t **);
+int sa_setup(objset_t *, uint64_t, const sa_attr_reg_t *, int,
+    sa_attr_type_t **);
 void sa_tear_down(objset_t *);
 int sa_replace_all_by_template(sa_handle_t *, sa_bulk_attr_t *,
     int, dmu_tx_t *);
diff --git a/sys/contrib/openzfs/include/sys/spa.h b/sys/contrib/openzfs/include/sys/spa.h
index 2e365eabe21d..896b0f9563ae 100644
--- a/sys/contrib/openzfs/include/sys/spa.h
+++ b/sys/contrib/openzfs/include/sys/spa.h
@@ -1208,6 +1208,9 @@ extern unsigned long zfs_deadman_synctime_ms;
 extern unsigned long zfs_deadman_ziotime_ms;
 extern unsigned long zfs_deadman_checktime_ms;
 
+extern kmem_cache_t *zio_buf_cache[];
+extern kmem_cache_t *zio_data_buf_cache[];
+
 #ifdef	__cplusplus
 }
 #endif
diff --git a/sys/contrib/openzfs/include/sys/spa_impl.h b/sys/contrib/openzfs/include/sys/spa_impl.h
index eee4783fe3f8..9946c4e3c316 100644
--- a/sys/contrib/openzfs/include/sys/spa_impl.h
+++ b/sys/contrib/openzfs/include/sys/spa_impl.h
@@ -444,7 +444,7 @@ struct spa {
 };
 
 extern char *spa_config_path;
-extern char *zfs_deadman_failmode;
+extern const char *zfs_deadman_failmode;
 extern int spa_slop_shift;
 extern void spa_taskq_dispatch_ent(spa_t *spa, zio_type_t t, zio_taskq_type_t q,
     task_func_t *func, void *arg, uint_t flags, taskq_ent_t *ent);
diff --git a/sys/contrib/openzfs/include/sys/vdev_draid.h b/sys/contrib/openzfs/include/sys/vdev_draid.h
index 52ce4ba16105..dd334acbacf1 100644
--- a/sys/contrib/openzfs/include/sys/vdev_draid.h
+++ b/sys/contrib/openzfs/include/sys/vdev_draid.h
@@ -96,6 +96,7 @@ extern boolean_t vdev_draid_readable(vdev_t *, uint64_t);
 extern boolean_t vdev_draid_missing(vdev_t *, uint64_t, uint64_t, uint64_t);
 extern uint64_t vdev_draid_asize_to_psize(vdev_t *, uint64_t);
 extern void vdev_draid_map_alloc_empty(zio_t *, struct raidz_row *);
+extern int vdev_draid_map_verify_empty(zio_t *, struct raidz_row *);
 extern nvlist_t *vdev_draid_read_config_spare(vdev_t *);
 
 /* Functions for dRAID distributed spares. */
diff --git a/sys/contrib/openzfs/include/sys/vdev_impl.h b/sys/contrib/openzfs/include/sys/vdev_impl.h
index 86959725a513..1567182a7b7e 100644
--- a/sys/contrib/openzfs/include/sys/vdev_impl.h
+++ b/sys/contrib/openzfs/include/sys/vdev_impl.h
@@ -626,8 +626,6 @@ extern uint64_t vdev_get_ndisks(vdev_t *vd);
  * Global variables
  */
 extern int zfs_vdev_standard_sm_blksz;
-/* zdb uses this tunable, so it must be declared here to make lint happy. */
-extern int zfs_vdev_cache_size;
 
 /*
  * Functions from vdev_indirect.c
diff --git a/sys/contrib/openzfs/include/sys/vdev_raidz.h b/sys/contrib/openzfs/include/sys/vdev_raidz.h
index ee597eb0dbb3..c7cf0af6d945 100644
--- a/sys/contrib/openzfs/include/sys/vdev_raidz.h
+++ b/sys/contrib/openzfs/include/sys/vdev_raidz.h
@@ -32,6 +32,7 @@ extern "C" {
 #endif
 
 struct zio;
+struct raidz_col;
 struct raidz_row;
 struct raidz_map;
 #if !defined(_KERNEL)
@@ -49,6 +50,7 @@ void vdev_raidz_generate_parity(struct raidz_map *);
 void vdev_raidz_reconstruct(struct raidz_map *, const int *, int);
 void vdev_raidz_child_done(zio_t *);
 void vdev_raidz_io_done(zio_t *);
+void vdev_raidz_checksum_error(zio_t *, struct raidz_col *, abd_t *);
 
 extern const zio_vsd_ops_t vdev_raidz_vsd_ops;
 
diff --git a/sys/contrib/openzfs/include/sys/vdev_raidz_impl.h b/sys/contrib/openzfs/include/sys/vdev_raidz_impl.h
index 908723da0c2a..890e725e18d8 100644
--- a/sys/contrib/openzfs/include/sys/vdev_raidz_impl.h
+++ b/sys/contrib/openzfs/include/sys/vdev_raidz_impl.h
@@ -70,8 +70,8 @@ enum raidz_rec_op {
 	RAIDZ_REC_NUM = 7
 };
 
-extern const char *raidz_gen_name[RAIDZ_GEN_NUM];
-extern const char *raidz_rec_name[RAIDZ_REC_NUM];
+extern const char *const raidz_gen_name[RAIDZ_GEN_NUM];
+extern const char *const raidz_rec_name[RAIDZ_REC_NUM];
 
 /*
  * Methods used to define raidz implementation
diff --git a/sys/contrib/openzfs/include/sys/zfs_acl.h b/sys/contrib/openzfs/include/sys/zfs_acl.h
index 010686a9121b..98387a49adbe 100644
--- a/sys/contrib/openzfs/include/sys/zfs_acl.h
+++ b/sys/contrib/openzfs/include/sys/zfs_acl.h
@@ -166,7 +166,7 @@ typedef struct zfs_acl {
 	uint64_t	z_hints;	/* ACL hints (ZFS_INHERIT_ACE ...) */
 	zfs_acl_node_t	*z_curr_node;	/* current node iterator is handling */
 	list_t		z_acl;		/* chunks of ACE data */
-	acl_ops_t	*z_ops;		/* ACL operations */
+	const acl_ops_t	*z_ops;		/* ACL operations */
 } zfs_acl_t;
 
 typedef struct acl_locator_cb {
diff --git a/sys/contrib/openzfs/include/sys/zfs_context.h b/sys/contrib/openzfs/include/sys/zfs_context.h
index b1df9f3f3878..6d1fd83df522 100644
--- a/sys/contrib/openzfs/include/sys/zfs_context.h
+++ b/sys/contrib/openzfs/include/sys/zfs_context.h
@@ -492,7 +492,7 @@ extern taskq_t	*taskq_create(const char *, int, pri_t, int, int, uint_t);
 #define	taskq_create_proc(a, b, c, d, e, p, f) \
 	    (taskq_create(a, b, c, d, e, f))
 #define	taskq_create_sysdc(a, b, d, e, p, dc, f) \
-	    (taskq_create(a, b, maxclsyspri, d, e, f))
+	    ((void) sizeof (dc), taskq_create(a, b, maxclsyspri, d, e, f))
 extern taskqid_t taskq_dispatch(taskq_t *, task_func_t, void *, uint_t);
 extern taskqid_t taskq_dispatch_delay(taskq_t *, task_func_t, void *, uint_t,
     clock_t);
diff --git a/sys/contrib/openzfs/include/sys/zfs_ioctl_impl.h b/sys/contrib/openzfs/include/sys/zfs_ioctl_impl.h
index 3db67ae98414..f9e4f6e6c4b2 100644
--- a/sys/contrib/openzfs/include/sys/zfs_ioctl_impl.h
+++ b/sys/contrib/openzfs/include/sys/zfs_ioctl_impl.h
@@ -24,7 +24,6 @@
 #define	_ZFS_IOCTL_IMPL_H_
 
 extern kmutex_t zfsdev_state_lock;
-extern zfsdev_state_t *zfsdev_state_list;
 extern unsigned long zfs_max_nvlist_src_size;
 
 typedef int zfs_ioc_legacy_func_t(zfs_cmd_t *);
diff --git a/sys/contrib/openzfs/include/sys/zfs_sa.h b/sys/contrib/openzfs/include/sys/zfs_sa.h
index 1ca7ced331c5..a0c383807aa4 100644
--- a/sys/contrib/openzfs/include/sys/zfs_sa.h
+++ b/sys/contrib/openzfs/include/sys/zfs_sa.h
@@ -91,8 +91,7 @@ typedef enum zpl_attr {
 #define	SA_FLAGS_OFFSET		48
 #define	SA_PROJID_OFFSET	128
 
-extern sa_attr_reg_t zfs_attr_table[ZPL_END + 1];
-extern sa_attr_reg_t zfs_legacy_attr_table[ZPL_END + 1];
+extern const sa_attr_reg_t zfs_attr_table[ZPL_END + 1];
 
 /*
  * This is a deprecated data structure that only exists for
diff --git a/sys/contrib/openzfs/include/sys/zfs_sysfs.h b/sys/contrib/openzfs/include/sys/zfs_sysfs.h
index 912ef234f8c5..d1cb2ef4321c 100644
--- a/sys/contrib/openzfs/include/sys/zfs_sysfs.h
+++ b/sys/contrib/openzfs/include/sys/zfs_sysfs.h
@@ -25,6 +25,10 @@
 #ifndef	_SYS_ZFS_SYSFS_H
 #define	_SYS_ZFS_SYSFS_H extern __attribute__((visibility("default")))
 
+struct zfs_mod_supported_features;
+struct zfs_mod_supported_features *zfs_mod_list_supported(const char *scope);
+void zfs_mod_list_supported_free(struct zfs_mod_supported_features *);
+
 #ifdef _KERNEL
 
 void zfs_sysfs_init(void);
@@ -35,7 +39,8 @@ void zfs_sysfs_fini(void);
 #define	zfs_sysfs_init()
 #define	zfs_sysfs_fini()
 
-_SYS_ZFS_SYSFS_H boolean_t zfs_mod_supported(const char *, const char *);
+_SYS_ZFS_SYSFS_H boolean_t zfs_mod_supported(const char *, const char *,
+    const struct zfs_mod_supported_features *);
 #endif
 
 #define	ZFS_SYSFS_POOL_PROPERTIES	"properties.pool"
diff --git a/sys/contrib/openzfs/include/sys/zil.h b/sys/contrib/openzfs/include/sys/zil.h
index cefbccb32f22..8e5a49da2929 100644
--- a/sys/contrib/openzfs/include/sys/zil.h
+++ b/sys/contrib/openzfs/include/sys/zil.h
@@ -456,8 +456,6 @@ typedef struct zil_stats {
 	kstat_named_t zil_itx_metaslab_slog_bytes;
 } zil_stats_t;
 
-extern zil_stats_t zil_stats;
-
 #define	ZIL_STAT_INCR(stat, val) \
     atomic_add_64(&zil_stats.stat.value.ui64, (val));
 #define	ZIL_STAT_BUMP(stat) \
@@ -485,7 +483,7 @@ extern zilog_t	*zil_open(objset_t *os, zil_get_data_t *get_data);
 extern void	zil_close(zilog_t *zilog);
 
 extern void	zil_replay(objset_t *os, void *arg,
-    zil_replay_func_t *replay_func[TX_MAX_TYPE]);
+    zil_replay_func_t *const replay_func[TX_MAX_TYPE]);
 extern boolean_t zil_replaying(zilog_t *zilog, dmu_tx_t *tx);
 extern void	zil_destroy(zilog_t *zilog, boolean_t keep_first);
 extern void	zil_destroy_sync(zilog_t *zilog, dmu_tx_t *tx);
diff --git a/sys/contrib/openzfs/include/sys/zio.h b/sys/contrib/openzfs/include/sys/zio.h
index 121b58dea58e..07135d1e2a07 100644
--- a/sys/contrib/openzfs/include/sys/zio.h
+++ b/sys/contrib/openzfs/include/sys/zio.h
@@ -264,7 +264,7 @@ typedef void zio_done_func_t(zio_t *zio);
 
 extern int zio_exclude_metadata;
 extern int zio_dva_throttle_enabled;
-extern const char *zio_type_name[ZIO_TYPES];
+extern const char *const zio_type_name[ZIO_TYPES];
 
 /*
  * A bookmark is a four-tuple <objset, object, level, blkid> that uniquely
diff --git a/sys/contrib/openzfs/include/sys/zio_crypt.h b/sys/contrib/openzfs/include/sys/zio_crypt.h
index d7a63d69582d..f1edd76f0d8e 100644
--- a/sys/contrib/openzfs/include/sys/zio_crypt.h
+++ b/sys/contrib/openzfs/include/sys/zio_crypt.h
@@ -70,7 +70,7 @@ typedef struct zio_crypt_info {
 	char *ci_name;
 } zio_crypt_info_t;
 
-extern zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS];
+extern const zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS];
 
 /* in memory representation of an unwrapped key that is loaded into memory */
 typedef struct zio_crypt_key {
diff --git a/sys/contrib/openzfs/include/sys/zthr.h b/sys/contrib/openzfs/include/sys/zthr.h
index 19be89eeebe5..4881b4572641 100644
--- a/sys/contrib/openzfs/include/sys/zthr.h
+++ b/sys/contrib/openzfs/include/sys/zthr.h
@@ -38,6 +38,7 @@ extern void zthr_resume(zthr_t *t);
 extern void zthr_wait_cycle_done(zthr_t *t);
 
 extern boolean_t zthr_iscancelled(zthr_t *t);
+extern boolean_t zthr_iscurthread(zthr_t *t);
 extern boolean_t zthr_has_waiters(zthr_t *t);
 
 #endif /* _SYS_ZTHR_H */
diff --git a/sys/contrib/openzfs/include/sys/zvol_impl.h b/sys/contrib/openzfs/include/sys/zvol_impl.h
index 89fe59800498..223393de79fd 100644
--- a/sys/contrib/openzfs/include/sys/zvol_impl.h
+++ b/sys/contrib/openzfs/include/sys/zvol_impl.h
@@ -61,12 +61,11 @@ typedef struct zvol_state {
 } zvol_state_t;
 
 
-extern list_t zvol_state_list;
 extern krwlock_t zvol_state_lock;
 #define	ZVOL_HT_SIZE	1024
 extern struct hlist_head *zvol_htable;
 #define	ZVOL_HT_HEAD(hash)	(&zvol_htable[(hash) & (ZVOL_HT_SIZE-1)])
-extern zil_replay_func_t *zvol_replay_vector[TX_MAX_TYPE];
+extern zil_replay_func_t *const zvol_replay_vector[TX_MAX_TYPE];
 
 extern unsigned int zvol_volmode;
 extern unsigned int zvol_inhibit_dev;
diff --git a/sys/contrib/openzfs/include/zfs_comutil.h b/sys/contrib/openzfs/include/zfs_comutil.h
index 3e4716224a06..ea2da4a15f1d 100644
--- a/sys/contrib/openzfs/include/zfs_comutil.h
+++ b/sys/contrib/openzfs/include/zfs_comutil.h
@@ -43,7 +43,7 @@ _ZFS_COMUTIL_H int zfs_spa_version_map(int zpl_version);
 _ZFS_COMUTIL_H boolean_t zfs_dataset_name_hidden(const char *);
 
 #define	ZFS_NUM_LEGACY_HISTORY_EVENTS 41
-_ZFS_COMUTIL_H const char *
+_ZFS_COMUTIL_H const char *const
     zfs_history_event_names[ZFS_NUM_LEGACY_HISTORY_EVENTS];
 
 #ifdef	__cplusplus
diff --git a/sys/contrib/openzfs/include/zfs_deleg.h b/sys/contrib/openzfs/include/zfs_deleg.h
index 1ae08850fbe9..77f64786b089 100644
--- a/sys/contrib/openzfs/include/zfs_deleg.h
+++ b/sys/contrib/openzfs/include/zfs_deleg.h
@@ -85,7 +85,7 @@ typedef struct zfs_deleg_perm_tab {
 	zfs_deleg_note_t z_note;
 } zfs_deleg_perm_tab_t;
 
-_ZFS_DELEG_H zfs_deleg_perm_tab_t zfs_deleg_perm_tab[];
+_ZFS_DELEG_H const zfs_deleg_perm_tab_t zfs_deleg_perm_tab[];
 
 _ZFS_DELEG_H int zfs_deleg_verify_nvlist(nvlist_t *nvlist);
 _ZFS_DELEG_H void zfs_deleg_whokey(char *attr, zfs_deleg_who_type_t type,
diff --git a/sys/contrib/openzfs/include/zfs_prop.h b/sys/contrib/openzfs/include/zfs_prop.h
index 8014c757aaff..c7363f701530 100644
--- a/sys/contrib/openzfs/include/zfs_prop.h
+++ b/sys/contrib/openzfs/include/zfs_prop.h
@@ -28,6 +28,7 @@
 
 #include <sys/fs/zfs.h>
 #include <sys/types.h>
+#include <sys/zfs_sysfs.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -111,15 +112,19 @@ _ZFS_PROP_H zprop_desc_t *vdev_prop_get_table(void);
  */
 _ZFS_PROP_H void zprop_register_impl(int, const char *, zprop_type_t, uint64_t,
     const char *, zprop_attr_t, int, const char *, const char *,
-    boolean_t, boolean_t, const zprop_index_t *);
+    boolean_t, boolean_t, const zprop_index_t *,
+    const struct zfs_mod_supported_features *);
 _ZFS_PROP_H void zprop_register_string(int, const char *, const char *,
-    zprop_attr_t attr, int, const char *, const char *);
+    zprop_attr_t attr, int, const char *, const char *,
+    const struct zfs_mod_supported_features *);
 _ZFS_PROP_H void zprop_register_number(int, const char *, uint64_t,
-    zprop_attr_t, int, const char *, const char *);
+    zprop_attr_t, int, const char *, const char *,
+    const struct zfs_mod_supported_features *);
 _ZFS_PROP_H void zprop_register_index(int, const char *, uint64_t, zprop_attr_t,
-    int, const char *, const char *, const zprop_index_t *);
+    int, const char *, const char *, const zprop_index_t *,
+    const struct zfs_mod_supported_features *);
 _ZFS_PROP_H void zprop_register_hidden(int, const char *, zprop_type_t,
-    zprop_attr_t, int, const char *);
+    zprop_attr_t, int, const char *, const struct zfs_mod_supported_features *);
 
 /*
  * Common routines for zfs and zpool property management
diff --git a/sys/contrib/openzfs/lib/libefi/rdwr_efi.c b/sys/contrib/openzfs/lib/libefi/rdwr_efi.c
index fd243e230e7d..b4fec0c8600a 100644
--- a/sys/contrib/openzfs/lib/libefi/rdwr_efi.c
+++ b/sys/contrib/openzfs/lib/libefi/rdwr_efi.c
@@ -1541,33 +1541,6 @@ efi_free(struct dk_gpt *ptr)
 	free(ptr);
 }
 
-/*
- * Input: File descriptor
- * Output: 1 if disk has an EFI label, or > 2TB with no VTOC or legacy MBR.
- * Otherwise 0.
- */
-int
-efi_type(int fd)
-{
-#if 0
-	struct vtoc vtoc;
-	struct extvtoc extvtoc;
-
-	if (ioctl(fd, DKIOCGEXTVTOC, &extvtoc) == -1) {
-		if (errno == ENOTSUP)
-			return (1);
-		else if (errno == ENOTTY) {
-			if (ioctl(fd, DKIOCGVTOC, &vtoc) == -1)
-				if (errno == ENOTSUP)
-					return (1);
-		}
-	}
-	return (0);
-#else
-	return (ENOSYS);
-#endif
-}
-
 void
 efi_err_check(struct dk_gpt *vtoc)
 {
diff --git a/sys/contrib/openzfs/lib/libicp/Makefile.am b/sys/contrib/openzfs/lib/libicp/Makefile.am
index 0b87a988c07e..831d2fedff4d 100644
--- a/sys/contrib/openzfs/lib/libicp/Makefile.am
+++ b/sys/contrib/openzfs/lib/libicp/Makefile.am
@@ -17,7 +17,6 @@ ASM_SOURCES_AS = \
 	asm-x86_64/modes/gcm_pclmulqdq.S \
 	asm-x86_64/modes/aesni-gcm-x86_64.S \
 	asm-x86_64/modes/ghash-x86_64.S \
-	asm-x86_64/sha1/sha1-x86_64.S \
 	asm-x86_64/sha2/sha256_impl.S \
 	asm-x86_64/sha2/sha512_impl.S
 else
@@ -46,19 +45,15 @@ KERNEL_C = \
 	algs/modes/ctr.c \
 	algs/modes/ccm.c \
 	algs/modes/ecb.c \
-	algs/sha1/sha1.c \
 	algs/sha2/sha2.c \
 	algs/skein/skein.c \
 	algs/skein/skein_block.c \
 	algs/skein/skein_iv.c \
 	illumos-crypto.c \
 	io/aes.c \
-	io/edonr_mod.c \
-	io/sha1_mod.c \
 	io/sha2_mod.c \
 	io/skein_mod.c \
 	os/modhash.c \
-	os/modconf.c \
 	core/kcf_sched.c \
 	core/kcf_prov_lib.c \
 	core/kcf_callprov.c \
diff --git a/sys/contrib/openzfs/lib/libnvpair/libnvpair.abi b/sys/contrib/openzfs/lib/libnvpair/libnvpair.abi
index 4a001c3dc3a6..01be5785a4ae 100644
--- a/sys/contrib/openzfs/lib/libnvpair/libnvpair.abi
+++ b/sys/contrib/openzfs/lib/libnvpair/libnvpair.abi
@@ -3,8 +3,6 @@
     <dependency name='libc.so.6'/>
   </elf-needed>
   <elf-function-symbols>
-    <elf-symbol name='_fini' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
-    <elf-symbol name='_init' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='dump_nvlist' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='fnvlist_add_boolean' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='fnvlist_add_boolean_array' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
@@ -1332,7 +1330,8 @@
     </function-decl>
   </abi-instr>
   <abi-instr address-size='64' path='../../module/nvpair/nvpair_alloc_fixed.c' language='LANG_C99'>
-    <var-decl name='nv_fixed_ops' type-id='ee1d4944' mangled-name='nv_fixed_ops' visibility='default' elf-symbol-id='nv_fixed_ops'/>
+    <qualified-type-def type-id='ee1d4944' const='yes' id='4b95388f'/>
+    <var-decl name='nv_fixed_ops' type-id='4b95388f' mangled-name='nv_fixed_ops' visibility='default' elf-symbol-id='nv_fixed_ops'/>
   </abi-instr>
   <abi-instr address-size='64' path='libnvpair.c' language='LANG_C99'>
     <type-decl name='char' size-in-bits='8' id='a84c031d'/>
@@ -1342,6 +1341,10 @@
     <array-type-def dimensions='1' type-id='a84c031d' size-in-bits='160' id='664ac0b7'>
       <subrange length='20' type-id='7359adad' id='fdca39cf'/>
     </array-type-def>
+    <class-decl name='_IO_codecvt' is-struct='yes' visibility='default' is-declaration-only='yes' id='a4036571'/>
+    <class-decl name='_IO_marker' is-struct='yes' visibility='default' is-declaration-only='yes' id='010ae0b9'/>
+    <class-decl name='_IO_wide_data' is-struct='yes' visibility='default' is-declaration-only='yes' id='79bd3751'/>
+    <class-decl name='re_dfa_t' is-struct='yes' visibility='default' is-declaration-only='yes' id='b48d2441'/>
     <type-decl name='double' size-in-bits='64' id='a0eb0f08'/>
     <type-decl name='int' size-in-bits='32' id='95e97e5e'/>
     <type-decl name='long int' size-in-bits='64' id='bd54fe1a'/>
@@ -1354,6 +1357,7 @@
     <type-decl name='unsigned long int' size-in-bits='64' id='7359adad'/>
     <type-decl name='unsigned short int' size-in-bits='16' id='8efea9e5'/>
     <type-decl name='variadic parameter type' id='2c1145c5'/>
+    <type-decl name='void' id='48b5725f'/>
     <typedef-decl name='nvlist_prtctl_t' type-id='196db161' id='b0c1ff8d'/>
     <enum-decl name='nvlist_indent_mode' id='628aafab'>
       <underlying-type type-id='9cac1fee'/>
@@ -1775,16 +1779,17 @@
         <var-decl name='nvprt_custops' type-id='7be54adb' visibility='default'/>
       </data-member>
     </class-decl>
+    <typedef-decl name='__re_long_size_t' type-id='7359adad' id='ba516949'/>
     <typedef-decl name='reg_syntax_t' type-id='7359adad' id='1b72c3b3'/>
     <class-decl name='re_pattern_buffer' size-in-bits='512' is-struct='yes' visibility='default' id='19fc9a8c'>
       <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='buffer' type-id='cf536864' visibility='default'/>
+        <var-decl name='buffer' type-id='33976309' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='allocated' type-id='7359adad' visibility='default'/>
+        <var-decl name='allocated' type-id='ba516949' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='128'>
-        <var-decl name='used' type-id='7359adad' visibility='default'/>
+        <var-decl name='used' type-id='ba516949' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='192'>
         <var-decl name='syntax' type-id='1b72c3b3' visibility='default'/>
@@ -1821,18 +1826,26 @@
       </data-member>
     </class-decl>
     <typedef-decl name='regex_t' type-id='19fc9a8c' id='aca3bac8'/>
+    <typedef-decl name='int8_t' type-id='2171a512' id='ee31ee44'/>
+    <typedef-decl name='int16_t' type-id='03896e23' id='23bd8cb5'/>
+    <typedef-decl name='int32_t' type-id='33f57a65' id='3ff5601b'/>
+    <typedef-decl name='int64_t' type-id='0c9942d2' id='9da381c4'/>
+    <typedef-decl name='uint8_t' type-id='c51d6389' id='b96825af'/>
+    <typedef-decl name='uint16_t' type-id='253c2d2a' id='149c6638'/>
+    <typedef-decl name='uint32_t' type-id='62f1140c' id='8f92235e'/>
+    <typedef-decl name='uint64_t' type-id='8910171f' id='9c313c2d'/>
+    <typedef-decl name='__int8_t' type-id='28577a57' id='2171a512'/>
+    <typedef-decl name='__uint8_t' type-id='002ac4a6' id='c51d6389'/>
+    <typedef-decl name='__int16_t' type-id='a2185560' id='03896e23'/>
+    <typedef-decl name='__uint16_t' type-id='8efea9e5' id='253c2d2a'/>
+    <typedef-decl name='__int32_t' type-id='95e97e5e' id='33f57a65'/>
+    <typedef-decl name='__uint32_t' type-id='f0981eeb' id='62f1140c'/>
+    <typedef-decl name='__int64_t' type-id='bd54fe1a' id='0c9942d2'/>
+    <typedef-decl name='__uint64_t' type-id='7359adad' id='8910171f'/>
+    <typedef-decl name='__off_t' type-id='bd54fe1a' id='79989e9c'/>
+    <typedef-decl name='__off64_t' type-id='bd54fe1a' id='724e4de6'/>
+    <typedef-decl name='FILE' type-id='ec1ed955' id='aa12d1ba'/>
     <typedef-decl name='_IO_lock_t' type-id='48b5725f' id='bb4788fa'/>
-    <class-decl name='_IO_marker' size-in-bits='192' is-struct='yes' visibility='default' id='010ae0b9'>
-      <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='_next' type-id='e4c6fa61' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='_sbuf' type-id='dca988a5' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='128'>
-        <var-decl name='_pos' type-id='95e97e5e' visibility='default'/>
-      </data-member>
-    </class-decl>
     <class-decl name='_IO_FILE' size-in-bits='1728' is-struct='yes' visibility='default' id='ec1ed955'>
       <data-member access='public' layout-offset-in-bits='0'>
         <var-decl name='_flags' type-id='95e97e5e' visibility='default'/>
@@ -1901,16 +1914,16 @@
         <var-decl name='_offset' type-id='724e4de6' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1216'>
-        <var-decl name='__pad1' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_codecvt' type-id='570f8c59' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1280'>
-        <var-decl name='__pad2' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_wide_data' type-id='c65a1f29' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1344'>
-        <var-decl name='__pad3' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_freeres_list' type-id='dca988a5' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1408'>
-        <var-decl name='__pad4' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_freeres_buf' type-id='eaa32e2f' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1472'>
         <var-decl name='__pad5' type-id='b59d7dce' visibility='default'/>
@@ -1922,30 +1935,13 @@
         <var-decl name='_unused2' type-id='664ac0b7' visibility='default'/>
       </data-member>
     </class-decl>
-    <typedef-decl name='int8_t' type-id='2171a512' id='ee31ee44'/>
-    <typedef-decl name='int16_t' type-id='03896e23' id='23bd8cb5'/>
-    <typedef-decl name='int32_t' type-id='33f57a65' id='3ff5601b'/>
-    <typedef-decl name='int64_t' type-id='0c9942d2' id='9da381c4'/>
-    <typedef-decl name='uint8_t' type-id='c51d6389' id='b96825af'/>
-    <typedef-decl name='uint16_t' type-id='253c2d2a' id='149c6638'/>
-    <typedef-decl name='uint32_t' type-id='62f1140c' id='8f92235e'/>
-    <typedef-decl name='uint64_t' type-id='8910171f' id='9c313c2d'/>
-    <typedef-decl name='__int8_t' type-id='28577a57' id='2171a512'/>
-    <typedef-decl name='__uint8_t' type-id='002ac4a6' id='c51d6389'/>
-    <typedef-decl name='__int16_t' type-id='a2185560' id='03896e23'/>
-    <typedef-decl name='__uint16_t' type-id='8efea9e5' id='253c2d2a'/>
-    <typedef-decl name='__int32_t' type-id='95e97e5e' id='33f57a65'/>
-    <typedef-decl name='__uint32_t' type-id='f0981eeb' id='62f1140c'/>
-    <typedef-decl name='__int64_t' type-id='bd54fe1a' id='0c9942d2'/>
-    <typedef-decl name='__uint64_t' type-id='7359adad' id='8910171f'/>
-    <typedef-decl name='__off_t' type-id='bd54fe1a' id='79989e9c'/>
-    <typedef-decl name='__off64_t' type-id='bd54fe1a' id='724e4de6'/>
-    <typedef-decl name='FILE' type-id='ec1ed955' id='aa12d1ba'/>
     <typedef-decl name='size_t' type-id='7359adad' id='b59d7dce'/>
     <pointer-type-def type-id='aa12d1ba' size-in-bits='64' id='822cd80b'/>
     <pointer-type-def type-id='ec1ed955' size-in-bits='64' id='dca988a5'/>
+    <pointer-type-def type-id='a4036571' size-in-bits='64' id='570f8c59'/>
     <pointer-type-def type-id='bb4788fa' size-in-bits='64' id='cecf4ea7'/>
     <pointer-type-def type-id='010ae0b9' size-in-bits='64' id='e4c6fa61'/>
+    <pointer-type-def type-id='79bd3751' size-in-bits='64' id='c65a1f29'/>
     <pointer-type-def type-id='c19b74c3' size-in-bits='64' id='37e3bd22'/>
     <pointer-type-def type-id='a84c031d' size-in-bits='64' id='26a90f95'/>
     <pointer-type-def type-id='26a90f95' size-in-bits='64' id='9b23c9ad'/>
@@ -2014,6 +2010,7 @@
     <pointer-type-def type-id='8e8d4be3' size-in-bits='64' id='5ce45b60'/>
     <pointer-type-def type-id='5ce45b60' size-in-bits='64' id='857bb57e'/>
     <pointer-type-def type-id='57928edf' size-in-bits='64' id='3fa542f0'/>
+    <pointer-type-def type-id='b48d2441' size-in-bits='64' id='33976309'/>
     <pointer-type-def type-id='aca3bac8' size-in-bits='64' id='d33f11cb'/>
     <pointer-type-def type-id='d8bf0010' size-in-bits='64' id='45b65157'/>
     <pointer-type-def type-id='149c6638' size-in-bits='64' id='8a121f49'/>
@@ -2022,6 +2019,10 @@
     <pointer-type-def type-id='b96825af' size-in-bits='64' id='ae3e8ca6'/>
     <pointer-type-def type-id='002ac4a6' size-in-bits='64' id='cf536864'/>
     <pointer-type-def type-id='48b5725f' size-in-bits='64' id='eaa32e2f'/>
+    <class-decl name='_IO_codecvt' is-struct='yes' visibility='default' is-declaration-only='yes' id='a4036571'/>
+    <class-decl name='_IO_marker' is-struct='yes' visibility='default' is-declaration-only='yes' id='010ae0b9'/>
+    <class-decl name='_IO_wide_data' is-struct='yes' visibility='default' is-declaration-only='yes' id='79bd3751'/>
+    <class-decl name='re_dfa_t' is-struct='yes' visibility='default' is-declaration-only='yes' id='b48d2441'/>
     <function-decl name='nvlist_prtctl_setdest' mangled-name='nvlist_prtctl_setdest' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='nvlist_prtctl_setdest'>
       <parameter type-id='b0c1ff8d' name='pctl'/>
       <parameter type-id='822cd80b' name='fp'/>
@@ -2710,7 +2711,6 @@
       <parameter type-id='3502e3ff'/>
       <return type-id='95e97e5e'/>
     </function-type>
-    <type-decl name='void' id='48b5725f'/>
   </abi-instr>
   <abi-instr address-size='64' path='libnvpair_json.c' language='LANG_C99'>
     <function-decl name='nvlist_print_json' mangled-name='nvlist_print_json' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='nvlist_print_json'>
@@ -2766,10 +2766,11 @@
     <pointer-type-def type-id='aca16c06' size-in-bits='64' id='ee1d4944'/>
     <pointer-type-def type-id='e9ff7293' size-in-bits='64' id='76da8447'/>
     <pointer-type-def type-id='cca08635' size-in-bits='64' id='11871392'/>
+    <qualified-type-def type-id='11871392' const='yes' id='e1cbfe1d'/>
     <pointer-type-def type-id='51a21b4b' size-in-bits='64' id='fe356f6f'/>
     <pointer-type-def type-id='1169c032' size-in-bits='64' id='520da3f4'/>
     <pointer-type-def type-id='9fff962e' size-in-bits='64' id='9ff7f508'/>
-    <var-decl name='nv_alloc_nosleep' type-id='11871392' mangled-name='nv_alloc_nosleep' visibility='default' elf-symbol-id='nv_alloc_nosleep'/>
+    <var-decl name='nv_alloc_nosleep' type-id='e1cbfe1d' mangled-name='nv_alloc_nosleep' visibility='default' elf-symbol-id='nv_alloc_nosleep'/>
     <function-type size-in-bits='64' id='e9ff7293'>
       <parameter type-id='11871392'/>
       <parameter type-id='b7f2d5e6'/>
diff --git a/sys/contrib/openzfs/lib/libnvpair/libnvpair.c b/sys/contrib/openzfs/lib/libnvpair/libnvpair.c
index fd43a44c1c0d..0123bb772048 100644
--- a/sys/contrib/openzfs/lib/libnvpair/libnvpair.c
+++ b/sys/contrib/openzfs/lib/libnvpair/libnvpair.c
@@ -253,11 +253,11 @@ NVLIST_ARRPRTFUNC(int64_array, int64_t, longlong_t, "%lld")
 NVLIST_ARRPRTFUNC(uint64_array, uint64_t, u_longlong_t, "0x%llx")
 NVLIST_ARRPRTFUNC(string_array, char *, char *, "%s")
 
-/*ARGSUSED*/
 static int
 nvprint_nvlist(nvlist_prtctl_t pctl, void *private,
     nvlist_t *nvl, const char *name, nvlist_t *value)
 {
+	(void) private, (void) nvl;
 	FILE *fp = pctl->nvprt_fp;
 
 	indent(pctl, 1);
@@ -273,11 +273,11 @@ nvprint_nvlist(nvlist_prtctl_t pctl, void *private,
 	return (1);
 }
 
-/*ARGSUSED*/
 static int
 nvaprint_nvlist_array(nvlist_prtctl_t pctl, void *private,
     nvlist_t *nvl, const char *name, nvlist_t **valuep, uint_t count)
 {
+	(void) private, (void) nvl;
 	FILE *fp = pctl->nvprt_fp;
 	uint_t i;
 
diff --git a/sys/contrib/openzfs/lib/libnvpair/nvpair_alloc_system.c b/sys/contrib/openzfs/lib/libnvpair/nvpair_alloc_system.c
index 54dde1ee644f..59806ea4dc93 100644
--- a/sys/contrib/openzfs/lib/libnvpair/nvpair_alloc_system.c
+++ b/sys/contrib/openzfs/lib/libnvpair/nvpair_alloc_system.c
@@ -36,10 +36,10 @@ nv_alloc_sys(nv_alloc_t *nva, size_t size)
 	return (kmem_alloc(size, (int)(uintptr_t)nva->nva_arg));
 }
 
-/*ARGSUSED*/
 static void
 nv_free_sys(nv_alloc_t *nva, void *buf, size_t size)
 {
+	(void) nva;
 	kmem_free(buf, size);
 }
 
@@ -51,15 +51,15 @@ static const nv_alloc_ops_t system_ops = {
 	NULL			/* nv_ao_reset() */
 };
 
-nv_alloc_t nv_alloc_sleep_def = {
+static nv_alloc_t nv_alloc_sleep_def = {
 	&system_ops,
 	(void *)KM_SLEEP
 };
 
-nv_alloc_t nv_alloc_nosleep_def = {
+static nv_alloc_t nv_alloc_nosleep_def = {
 	&system_ops,
 	(void *)KM_NOSLEEP
 };
 
-nv_alloc_t *nv_alloc_sleep = &nv_alloc_sleep_def;
-nv_alloc_t *nv_alloc_nosleep = &nv_alloc_nosleep_def;
+nv_alloc_t *const nv_alloc_sleep = &nv_alloc_sleep_def;
+nv_alloc_t *const nv_alloc_nosleep = &nv_alloc_nosleep_def;
diff --git a/sys/contrib/openzfs/lib/libshare/nfs.c b/sys/contrib/openzfs/lib/libshare/nfs.c
index e339ebc81f1b..2a901bcec503 100644
--- a/sys/contrib/openzfs/lib/libshare/nfs.c
+++ b/sys/contrib/openzfs/lib/libshare/nfs.c
@@ -50,7 +50,9 @@ nfs_exports_lock(const char *name)
 		return (err);
 	}
 
-	if (flock(nfs_lock_fd, LOCK_EX) != 0) {
+	while ((err = flock(nfs_lock_fd, LOCK_EX)) != 0 && errno == EINTR)
+		;
+	if (err != 0) {
 		err = errno;
 		fprintf(stderr, "failed to lock %s: %s\n", name, strerror(err));
 		(void) close(nfs_lock_fd);
@@ -75,83 +77,190 @@ nfs_exports_unlock(const char *name)
 	nfs_lock_fd = -1;
 }
 
-static char *
-nfs_init_tmpfile(const char *prefix, const char *mdir)
-{
-	char *tmpfile = NULL;
-	struct stat sb;
+struct tmpfile {
+	/*
+	 * This only needs to be as wide as ZFS_EXPORTS_FILE and mktemp suffix,
+	 * 64 is more than enough.
+	 */
+	char name[64];
+	FILE *fp;
+};
 
+static boolean_t
+nfs_init_tmpfile(const char *prefix, const char *mdir, struct tmpfile *tmpf)
+{
 	if (mdir != NULL &&
-	    stat(mdir, &sb) < 0 &&
-	    mkdir(mdir, 0755) < 0) {
+	    mkdir(mdir, 0755) < 0 &&
+	    errno != EEXIST) {
 		fprintf(stderr, "failed to create %s: %s\n",
 		    mdir, strerror(errno));
-		return (NULL);
+		return (B_FALSE);
 	}
 
-	if (asprintf(&tmpfile, "%s.XXXXXXXX", prefix) == -1) {
-		fprintf(stderr, "Unable to allocate temporary file\n");
-		return (NULL);
-	}
+	strcpy(tmpf->name, prefix);
+	strcat(tmpf->name, ".XXXXXXXX");
 
-	int fd = mkostemp(tmpfile, O_CLOEXEC);
+	int fd = mkostemp(tmpf->name, O_CLOEXEC);
 	if (fd == -1) {
 		fprintf(stderr, "Unable to create temporary file: %s",
 		    strerror(errno));
-		free(tmpfile);
-		return (NULL);
+		return (B_FALSE);
+	}
+
+	tmpf->fp = fdopen(fd, "w+");
+	if (tmpf->fp == NULL) {
+		fprintf(stderr, "Unable to reopen temporary file: %s",
+		    strerror(errno));
+		close(fd);
+		return (B_FALSE);
 	}
-	close(fd);
-	return (tmpfile);
+
+	return (B_TRUE);
+}
+
+static void
+nfs_abort_tmpfile(struct tmpfile *tmpf)
+{
+	unlink(tmpf->name);
+	fclose(tmpf->fp);
 }
 
 static int
-nfs_fini_tmpfile(const char *exports, char *tmpfile)
+nfs_fini_tmpfile(const char *exports, struct tmpfile *tmpf)
 {
-	if (rename(tmpfile, exports) == -1) {
-		fprintf(stderr, "Unable to rename %s: %s\n", tmpfile,
+	if (fflush(tmpf->fp) != 0) {
+		fprintf(stderr, "Failed to write to temporary file: %s\n",
 		    strerror(errno));
-		unlink(tmpfile);
-		free(tmpfile);
+		nfs_abort_tmpfile(tmpf);
+		return (SA_SYSTEM_ERR);
+	}
+
+	if (rename(tmpf->name, exports) == -1) {
+		fprintf(stderr, "Unable to rename %s -> %s: %s\n",
+		    tmpf->name, exports, strerror(errno));
+		nfs_abort_tmpfile(tmpf);
 		return (SA_SYSTEM_ERR);
 	}
-	free(tmpfile);
+
+	(void) fchmod(fileno(tmpf->fp), 0644);
+	fclose(tmpf->fp);
 	return (SA_OK);
 }
 
+static int
+nfs_process_exports(const char *exports, const char *mountpoint,
+    boolean_t (*cbk)(void *userdata, char *line, boolean_t found_mountpoint),
+    void *userdata)
+{
+	int error = SA_OK;
+	boolean_t cont = B_TRUE;
+
+	FILE *oldfp = fopen(exports, "re");
+	if (oldfp != NULL) {
+		char *buf = NULL, *sep;
+		size_t buflen = 0, mplen = strlen(mountpoint);
+
+		while (cont && getline(&buf, &buflen, oldfp) != -1) {
+			if (buf[0] == '\n' || buf[0] == '#')
+				continue;
+
+			cont = cbk(userdata, buf,
+			    (sep = strpbrk(buf, "\t \n")) != NULL &&
+			    sep - buf == mplen &&
+			    strncmp(buf, mountpoint, mplen) == 0);
+		}
+		free(buf);
+
+		if (ferror(oldfp) != 0)
+			error = ferror(oldfp);
+
+		if (fclose(oldfp) != 0) {
+			fprintf(stderr, "Unable to close file %s: %s\n",
+			    exports, strerror(errno));
+			error = error != SA_OK ? error : SA_SYSTEM_ERR;
+		}
+	}
+
+	return (error);
+}
+
+static boolean_t
+nfs_copy_entries_cb(void *userdata, char *line, boolean_t found_mountpoint)
+{
+	FILE *newfp = userdata;
+	if (!found_mountpoint)
+		fputs(line, newfp);
+	return (B_TRUE);
+}
+
+/*
+ * Copy all entries from the exports file (if it exists) to newfp,
+ * omitting any entries for the specified mountpoint.
+ */
+static int
+nfs_copy_entries(FILE *newfp, const char *exports, const char *mountpoint)
+{
+	fputs(FILE_HEADER, newfp);
+
+	int error = nfs_process_exports(
+	    exports, mountpoint, nfs_copy_entries_cb, newfp);
+
+	if (error == SA_OK && ferror(newfp) != 0)
+		error = ferror(newfp);
+
+	return (error);
+}
+
 int
 nfs_toggle_share(const char *lockfile, const char *exports,
     const char *expdir, sa_share_impl_t impl_share,
-    int(*cbk)(sa_share_impl_t impl_share, char *filename))
+    int(*cbk)(sa_share_impl_t impl_share, FILE *tmpfile))
 {
 	int error;
-	char *filename;
+	struct tmpfile tmpf;
 
-	if ((filename = nfs_init_tmpfile(exports, expdir)) == NULL)
+	if (!nfs_init_tmpfile(exports, expdir, &tmpf))
 		return (SA_SYSTEM_ERR);
 
 	error = nfs_exports_lock(lockfile);
 	if (error != 0) {
-		unlink(filename);
-		free(filename);
+		nfs_abort_tmpfile(&tmpf);
 		return (error);
 	}
 
-	error = nfs_copy_entries(filename, impl_share->sa_mountpoint);
+	error = nfs_copy_entries(tmpf.fp, exports, impl_share->sa_mountpoint);
 	if (error != SA_OK)
 		goto fullerr;
 
-	error = cbk(impl_share, filename);
+	error = cbk(impl_share, tmpf.fp);
 	if (error != SA_OK)
 		goto fullerr;
 
-	error = nfs_fini_tmpfile(exports, filename);
+	error = nfs_fini_tmpfile(exports, &tmpf);
 	nfs_exports_unlock(lockfile);
 	return (error);
 
 fullerr:
-	unlink(filename);
-	free(filename);
+	nfs_abort_tmpfile(&tmpf);
 	nfs_exports_unlock(lockfile);
 	return (error);
 }
+
+static boolean_t
+nfs_is_shared_cb(void *userdata, char *line, boolean_t found_mountpoint)
+{
+	(void) line;
+
+	boolean_t *found = userdata;
+	*found = found_mountpoint;
+	return (!found_mountpoint);
+}
+
+boolean_t
+nfs_is_shared_impl(const char *exports, sa_share_impl_t impl_share)
+{
+	boolean_t found = B_FALSE;
+	nfs_process_exports(exports, impl_share->sa_mountpoint,
+	    nfs_is_shared_cb, &found);
+	return (found);
+}
diff --git a/sys/contrib/openzfs/lib/libshare/nfs.h b/sys/contrib/openzfs/lib/libshare/nfs.h
index 4dbcdf59859d..cfac274c3d26 100644
--- a/sys/contrib/openzfs/lib/libshare/nfs.h
+++ b/sys/contrib/openzfs/lib/libshare/nfs.h
@@ -30,7 +30,7 @@
 
 void libshare_nfs_init(void);
 
-int nfs_copy_entries(char *filename, const char *mountpoint);
+boolean_t nfs_is_shared_impl(const char *exports, sa_share_impl_t impl_share);
 int nfs_toggle_share(const char *lockfile, const char *exports,
     const char *expdir, sa_share_impl_t impl_share,
-    int(*cbk)(sa_share_impl_t impl_share, char *filename));
+    int(*cbk)(sa_share_impl_t impl_share, FILE *tmpfile));
diff --git a/sys/contrib/openzfs/lib/libshare/os/freebsd/nfs.c b/sys/contrib/openzfs/lib/libshare/os/freebsd/nfs.c
index 0041bc228bb5..494442cb520f 100644
--- a/sys/contrib/openzfs/lib/libshare/os/freebsd/nfs.c
+++ b/sys/contrib/openzfs/lib/libshare/os/freebsd/nfs.c
@@ -54,42 +54,6 @@ __FBSDID("$FreeBSD$");
 
 static sa_fstype_t *nfs_fstype;
 
-/*
- * Read one line from a file. Skip comments, empty lines and a line with a
- * mountpoint specified in the 'skip' argument.
- *
- * NOTE: This function returns a static buffer and thus is not thread-safe.
- */
-static char *
-zgetline(FILE *fd, const char *skip)
-{
-	static char line[MAXLINESIZE];
-	size_t len, skiplen = 0;
-	char *s, last;
-
-	if (skip != NULL)
-		skiplen = strlen(skip);
-	for (;;) {
-		s = fgets(line, sizeof (line), fd);
-		if (s == NULL)
-			return (NULL);
-		/* Skip empty lines and comments. */
-		if (line[0] == '\n' || line[0] == '#')
-			continue;
-		len = strlen(line);
-		if (line[len - 1] == '\n')
-			line[len - 1] = '\0';
-		last = line[skiplen];
-		/* Skip the given mountpoint. */
-		if (skip != NULL && strncmp(skip, line, skiplen) == 0 &&
-		    (last == '\t' || last == ' ' || last == '\0')) {
-			continue;
-		}
-		break;
-	}
-	return (line);
-}
-
 /*
  * This function translate options to a format acceptable by exports(5), eg.
  *
@@ -143,79 +107,16 @@ translate_opts(const char *shareopts)
 	return (newopts);
 }
 
-/*
- * This function copies all entries from the exports file to "filename",
- * omitting any entries for the specified mountpoint.
- */
-int
-nfs_copy_entries(char *filename, const char *mountpoint)
-{
-	int error = SA_OK;
-	char *line;
-
-	FILE *oldfp = fopen(ZFS_EXPORTS_FILE, "re");
-	FILE *newfp = fopen(filename, "w+e");
-	if (newfp == NULL) {
-		fprintf(stderr, "failed to open %s file: %s", filename,
-		    strerror(errno));
-		fclose(oldfp);
-		return (SA_SYSTEM_ERR);
-	}
-	fputs(FILE_HEADER, newfp);
-
-	/*
-	 * The ZFS_EXPORTS_FILE may not exist yet. If that's the
-	 * case then just write out the new file.
-	 */
-	if (oldfp != NULL) {
-		while ((line = zgetline(oldfp, mountpoint)) != NULL)
-			fprintf(newfp, "%s\n", line);
-		if (ferror(oldfp) != 0) {
-			error = ferror(oldfp);
-		}
-		if (fclose(oldfp) != 0) {
-			fprintf(stderr, "Unable to close file %s: %s\n",
-			    filename, strerror(errno));
-			error = error != 0 ? error : SA_SYSTEM_ERR;
-		}
-	}
-
-	if (error == 0 && ferror(newfp) != 0) {
-		error = ferror(newfp);
-	}
-
-	if (fclose(newfp) != 0) {
-		fprintf(stderr, "Unable to close file %s: %s\n",
-		    filename, strerror(errno));
-		error = error != 0 ? error : SA_SYSTEM_ERR;
-	}
-	return (error);
-}
-
 static int
-nfs_enable_share_impl(sa_share_impl_t impl_share, char *filename)
+nfs_enable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)
 {
-	FILE *fp = fopen(filename, "a+e");
-	if (fp == NULL) {
-		fprintf(stderr, "failed to open %s file: %s", filename,
-		    strerror(errno));
-		return (SA_SYSTEM_ERR);
-	}
-
 	char *shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
 	if (strcmp(shareopts, "on") == 0)
 		shareopts = "";
 
-	if (fprintf(fp, "%s\t%s\n", impl_share->sa_mountpoint,
+	if (fprintf(tmpfile, "%s\t%s\n", impl_share->sa_mountpoint,
 	    translate_opts(shareopts)) < 0) {
-		fprintf(stderr, "failed to write to %s\n", filename);
-		fclose(fp);
-		return (SA_SYSTEM_ERR);
-	}
-
-	if (fclose(fp) != 0) {
-		fprintf(stderr, "Unable to close file %s: %s\n",
-		    filename, strerror(errno));
+		fprintf(stderr, "failed to write to temporary file\n");
 		return (SA_SYSTEM_ERR);
 	}
 
@@ -231,8 +132,9 @@ nfs_enable_share(sa_share_impl_t impl_share)
 }
 
 static int
-nfs_disable_share_impl(sa_share_impl_t impl_share, char *filename)
+nfs_disable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)
 {
+	(void) impl_share, (void) tmpfile;
 	return (SA_OK);
 }
 
@@ -247,35 +149,7 @@ nfs_disable_share(sa_share_impl_t impl_share)
 static boolean_t
 nfs_is_shared(sa_share_impl_t impl_share)
 {
-	char *s, last, line[MAXLINESIZE];
-	size_t len;
-	char *mntpoint = impl_share->sa_mountpoint;
-	size_t mntlen = strlen(mntpoint);
-
-	FILE *fp = fopen(ZFS_EXPORTS_FILE, "re");
-	if (fp == NULL)
-		return (B_FALSE);
-
-	for (;;) {
-		s = fgets(line, sizeof (line), fp);
-		if (s == NULL)
-			return (B_FALSE);
-		/* Skip empty lines and comments. */
-		if (line[0] == '\n' || line[0] == '#')
-			continue;
-		len = strlen(line);
-		if (line[len - 1] == '\n')
-			line[len - 1] = '\0';
-		last = line[mntlen];
-		/* Skip the given mountpoint. */
-		if (strncmp(mntpoint, line, mntlen) == 0 &&
-		    (last == '\t' || last == ' ' || last == '\0')) {
-			fclose(fp);
-			return (B_TRUE);
-		}
-	}
-	fclose(fp);
-	return (B_FALSE);
+	return (nfs_is_shared_impl(ZFS_EXPORTS_FILE, impl_share));
 }
 
 static int
@@ -306,9 +180,10 @@ nfs_commit_shares(void)
 	struct pidfh *pfh;
 	pid_t mountdpid;
 
+start:
 	pfh = pidfile_open(_PATH_MOUNTDPID, 0600, &mountdpid);
 	if (pfh != NULL) {
-		/* Mountd is not running. */
+		/* mountd(8) is not running. */
 		pidfile_remove(pfh);
 		return (SA_OK);
 	}
@@ -316,6 +191,11 @@ nfs_commit_shares(void)
 		/* Cannot open pidfile for some reason. */
 		return (SA_SYSTEM_ERR);
 	}
+	if (mountdpid == -1) {
+		/* mountd(8) exists, but didn't write the PID yet */
+		usleep(500);
+		goto start;
+	}
 	/* We have mountd(8) PID in mountdpid variable. */
 	kill(mountdpid, SIGHUP);
 	return (SA_OK);
diff --git a/sys/contrib/openzfs/lib/libshare/os/linux/nfs.c b/sys/contrib/openzfs/lib/libshare/os/linux/nfs.c
index 4f754aabd3a3..002c5e24ca66 100644
--- a/sys/contrib/openzfs/lib/libshare/os/linux/nfs.c
+++ b/sys/contrib/openzfs/lib/libshare/os/linux/nfs.c
@@ -51,7 +51,7 @@ static sa_fstype_t *nfs_fstype;
 typedef int (*nfs_shareopt_callback_t)(const char *opt, const char *value,
     void *cookie);
 
-typedef int (*nfs_host_callback_t)(const char *sharepath, const char *filename,
+typedef int (*nfs_host_callback_t)(FILE *tmpfile, const char *sharepath,
     const char *host, const char *security, const char *access, void *cookie);
 
 /*
@@ -122,7 +122,7 @@ typedef struct nfs_host_cookie_s {
 	nfs_host_callback_t callback;
 	const char *sharepath;
 	void *cookie;
-	const char *filename;
+	FILE *tmpfile;
 	const char *security;
 } nfs_host_cookie_t;
 
@@ -203,7 +203,7 @@ foreach_nfs_host_cb(const char *opt, const char *value, void *pcookie)
 				}
 			}
 
-			error = udata->callback(udata->filename,
+			error = udata->callback(udata->tmpfile,
 			    udata->sharepath, host, udata->security,
 			    access, udata->cookie);
 
@@ -226,7 +226,7 @@ foreach_nfs_host_cb(const char *opt, const char *value, void *pcookie)
  * Invokes a callback function for all NFS hosts that are set for a share.
  */
 static int
-foreach_nfs_host(sa_share_impl_t impl_share, char *filename,
+foreach_nfs_host(sa_share_impl_t impl_share, FILE *tmpfile,
     nfs_host_callback_t callback, void *cookie)
 {
 	nfs_host_cookie_t udata;
@@ -235,7 +235,7 @@ foreach_nfs_host(sa_share_impl_t impl_share, char *filename,
 	udata.callback = callback;
 	udata.sharepath = impl_share->sa_mountpoint;
 	udata.cookie = cookie;
-	udata.filename = filename;
+	udata.tmpfile = tmpfile;
 	udata.security = "sys";
 
 	shareopts = FSINFO(impl_share, nfs_fstype)->shareopts;
@@ -247,8 +247,8 @@ foreach_nfs_host(sa_share_impl_t impl_share, char *filename,
 /*
  * Converts a Solaris NFS host specification to its Linux equivalent.
  */
-static int
-get_linux_hostspec(const char *solaris_hostspec, char **plinux_hostspec)
+static const char *
+get_linux_hostspec(const char *solaris_hostspec)
 {
 	/*
 	 * For now we just support CIDR masks (e.g. @192.168.0.0/16) and host
@@ -259,16 +259,10 @@ get_linux_hostspec(const char *solaris_hostspec, char **plinux_hostspec)
 		 * Solaris host specifier, e.g. @192.168.0.0/16; we just need
 		 * to skip the @ in this case
 		 */
-		*plinux_hostspec = strdup(solaris_hostspec + 1);
+		return (solaris_hostspec + 1);
 	} else {
-		*plinux_hostspec = strdup(solaris_hostspec);
-	}
-
-	if (*plinux_hostspec == NULL) {
-		return (SA_NO_MEMORY);
+		return (solaris_hostspec);
 	}
-
-	return (SA_OK);
 }
 
 /*
@@ -393,118 +387,30 @@ get_linux_shareopts(const char *shareopts, char **plinux_opts)
  * automatically exported upon boot or whenever the nfs server restarts.
  */
 static int
-nfs_add_entry(const char *filename, const char *sharepath,
+nfs_add_entry(FILE *tmpfile, const char *sharepath,
     const char *host, const char *security, const char *access_opts,
     void *pcookie)
 {
-	int error;
-	char *linuxhost;
 	const char *linux_opts = (const char *)pcookie;
 
-	error = get_linux_hostspec(host, &linuxhost);
-	if (error != SA_OK)
-		return (error);
-
 	if (linux_opts == NULL)
 		linux_opts = "";
 
-	FILE *fp = fopen(filename, "a+e");
-	if (fp == NULL) {
-		fprintf(stderr, "failed to open %s file: %s", filename,
-		    strerror(errno));
-		free(linuxhost);
+	if (fprintf(tmpfile, "%s %s(sec=%s,%s,%s)\n", sharepath,
+	    get_linux_hostspec(host), security, access_opts,
+	    linux_opts) < 0) {
+		fprintf(stderr, "failed to write to temporary file\n");
 		return (SA_SYSTEM_ERR);
 	}
 
-	if (fprintf(fp, "%s %s(sec=%s,%s,%s)\n", sharepath, linuxhost,
-	    security, access_opts, linux_opts) < 0) {
-		fprintf(stderr, "failed to write to %s\n", filename);
-		free(linuxhost);
-		fclose(fp);
-		return (SA_SYSTEM_ERR);
-	}
-
-	free(linuxhost);
-	if (fclose(fp) != 0) {
-		fprintf(stderr, "Unable to close file %s: %s\n",
-		    filename, strerror(errno));
-		return (SA_SYSTEM_ERR);
-	}
 	return (SA_OK);
 }
 
-/*
- * This function copies all entries from the exports file to "filename",
- * omitting any entries for the specified mountpoint.
- */
-int
-nfs_copy_entries(char *filename, const char *mountpoint)
-{
-	char *buf = NULL;
-	size_t buflen = 0;
-	int error = SA_OK;
-
-	FILE *oldfp = fopen(ZFS_EXPORTS_FILE, "re");
-	FILE *newfp = fopen(filename, "w+e");
-	if (newfp == NULL) {
-		fprintf(stderr, "failed to open %s file: %s", filename,
-		    strerror(errno));
-		fclose(oldfp);
-		return (SA_SYSTEM_ERR);
-	}
-	fputs(FILE_HEADER, newfp);
-
-	/*
-	 * The ZFS_EXPORTS_FILE may not exist yet. If that's the
-	 * case then just write out the new file.
-	 */
-	if (oldfp != NULL) {
-		while (getline(&buf, &buflen, oldfp) != -1) {
-			char *space = NULL;
-
-			if (buf[0] == '\n' || buf[0] == '#')
-				continue;
-
-			if ((space = strchr(buf, ' ')) != NULL) {
-				int mountpoint_len = strlen(mountpoint);
-
-				if (space - buf == mountpoint_len &&
-				    strncmp(mountpoint, buf,
-				    mountpoint_len) == 0) {
-					continue;
-				}
-			}
-			fputs(buf, newfp);
-		}
-
-		if (ferror(oldfp) != 0) {
-			error = ferror(oldfp);
-		}
-		if (fclose(oldfp) != 0) {
-			fprintf(stderr, "Unable to close file %s: %s\n",
-			    filename, strerror(errno));
-			error = error != 0 ? error : SA_SYSTEM_ERR;
-		}
-	}
-
-	if (error == 0 && ferror(newfp) != 0) {
-		error = ferror(newfp);
-	}
-
-	free(buf);
-	if (fclose(newfp) != 0) {
-		fprintf(stderr, "Unable to close file %s: %s\n",
-		    filename, strerror(errno));
-		error = error != 0 ? error : SA_SYSTEM_ERR;
-	}
-	return (error);
-}
-
 /*
  * Enables NFS sharing for the specified share.
  */
 static int
-nfs_enable_share_impl(sa_share_impl_t impl_share, char *filename)
+nfs_enable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)
 {
 	char *shareopts, *linux_opts;
 	int error;
@@ -514,7 +420,7 @@ nfs_enable_share_impl(sa_share_impl_t impl_share, char *filename)
 	if (error != SA_OK)
 		return (error);
 
-	error = foreach_nfs_host(impl_share, filename, nfs_add_entry,
+	error = foreach_nfs_host(impl_share, tmpfile, nfs_add_entry,
 	    linux_opts);
 	free(linux_opts);
 	return (error);
@@ -532,8 +438,9 @@ nfs_enable_share(sa_share_impl_t impl_share)
  * Disables NFS sharing for the specified share.
  */
 static int
-nfs_disable_share_impl(sa_share_impl_t impl_share, char *filename)
+nfs_disable_share_impl(sa_share_impl_t impl_share, FILE *tmpfile)
 {
+	(void) impl_share, (void) tmpfile;
 	return (SA_OK);
 }
 
@@ -548,31 +455,7 @@ nfs_disable_share(sa_share_impl_t impl_share)
 static boolean_t
 nfs_is_shared(sa_share_impl_t impl_share)
 {
-	size_t buflen = 0;
-	char *buf = NULL;
-
-	FILE *fp = fopen(ZFS_EXPORTS_FILE, "re");
-	if (fp == NULL) {
-		return (B_FALSE);
-	}
-	while ((getline(&buf, &buflen, fp)) != -1) {
-		char *space = NULL;
-
-		if ((space = strchr(buf, ' ')) != NULL) {
-			int mountpoint_len = strlen(impl_share->sa_mountpoint);
-
-			if (space - buf == mountpoint_len &&
-			    strncmp(impl_share->sa_mountpoint, buf,
-			    mountpoint_len) == 0) {
-				fclose(fp);
-				free(buf);
-				return (B_TRUE);
-			}
-		}
-	}
-	free(buf);
-	fclose(fp);
-	return (B_FALSE);
+	return (nfs_is_shared_impl(ZFS_EXPORTS_FILE, impl_share));
 }
 
 /*
diff --git a/sys/contrib/openzfs/lib/libshare/os/linux/smb.c b/sys/contrib/openzfs/lib/libshare/os/linux/smb.c
index 9b18848e09cf..312ffb97d120 100644
--- a/sys/contrib/openzfs/lib/libshare/os/linux/smb.c
+++ b/sys/contrib/openzfs/lib/libshare/os/linux/smb.c
@@ -254,7 +254,7 @@ smb_enable_share_one(const char *sharename, const char *sharepath)
 	argv[5] = (char *)name;
 	argv[6] = (char *)sharepath;
 	argv[7] = (char *)comment;
-	argv[8] = "Everyone:F";
+	argv[8] = (char *)"Everyone:F";
 	argv[9] = NULL;
 
 	rc = libzfs_run_process(argv[0], argv, 0);
diff --git a/sys/contrib/openzfs/lib/libspl/include/assert.h b/sys/contrib/openzfs/lib/libspl/include/assert.h
index 84dbccdc4a12..fadff14cce01 100644
--- a/sys/contrib/openzfs/lib/libspl/include/assert.h
+++ b/sys/contrib/openzfs/lib/libspl/include/assert.h
@@ -120,15 +120,15 @@ do {									\
 	__compile_time_assertion__ ## y[(x) ? 1 : -1]
 
 #ifdef NDEBUG
-#define	ASSERT3B(x, y, z)	((void)0)
-#define	ASSERT3S(x, y, z)	((void)0)
-#define	ASSERT3U(x, y, z)	((void)0)
-#define	ASSERT3P(x, y, z)	((void)0)
-#define	ASSERT0(x)		((void)0)
-#define	ASSERT(x)		((void)0)
-#define	assert(x)		((void)0)
-#define	IMPLY(A, B)		((void)0)
-#define	EQUIV(A, B)		((void)0)
+#define	ASSERT3B(x, y, z)	((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3S(x, y, z)	((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3U(x, y, z)	((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT3P(x, y, z)	((void) sizeof (!!(x)), (void) sizeof (!!(z)))
+#define	ASSERT0(x)		((void) sizeof (!!(x)))
+#define	ASSERT(x)		((void) sizeof (!!(x)))
+#define	assert(x)		((void) sizeof (!!(x)))
+#define	IMPLY(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
+#define	EQUIV(A, B)		((void) sizeof (!!(A)), (void) sizeof (!!(B)))
 #else
 #define	ASSERT3B	VERIFY3B
 #define	ASSERT3S	VERIFY3S
diff --git a/sys/contrib/openzfs/lib/libspl/include/sys/kmem.h b/sys/contrib/openzfs/lib/libspl/include/sys/kmem.h
index 83d47565aeaf..06c614e51d1c 100644
--- a/sys/contrib/openzfs/lib/libspl/include/sys/kmem.h
+++ b/sys/contrib/openzfs/lib/libspl/include/sys/kmem.h
@@ -35,8 +35,8 @@ extern "C" {
 #define	KM_SLEEP	0x00000000	/* same as KM_SLEEP */
 #define	KM_NOSLEEP	0x00000001	/* same as KM_NOSLEEP */
 
-#define	kmem_alloc(size, flags)		malloc(size)
-#define	kmem_free(ptr, size)		free(ptr)
+#define	kmem_alloc(size, flags)		((void) sizeof (flags), malloc(size))
+#define	kmem_free(ptr, size)		((void) sizeof (size), free(ptr))
 
 #ifdef	__cplusplus
 }
diff --git a/sys/contrib/openzfs/lib/libspl/include/umem.h b/sys/contrib/openzfs/lib/libspl/include/umem.h
index 65f12595e64f..eee0dc97578a 100644
--- a/sys/contrib/openzfs/lib/libspl/include/umem.h
+++ b/sys/contrib/openzfs/lib/libspl/include/umem.h
@@ -129,9 +129,9 @@ umem_zalloc(size_t size, int flags)
 }
 
 static inline void
-umem_free(void *ptr, size_t size __maybe_unused)
+umem_free(const void *ptr, size_t size __maybe_unused)
 {
-	free(ptr);
+	free((void *)ptr);
 }
 
 static inline void
diff --git a/sys/contrib/openzfs/lib/libspl/os/freebsd/mnttab.c b/sys/contrib/openzfs/lib/libspl/os/freebsd/mnttab.c
index bd3e3e4e3eef..d830257fbd16 100644
--- a/sys/contrib/openzfs/lib/libspl/os/freebsd/mnttab.c
+++ b/sys/contrib/openzfs/lib/libspl/os/freebsd/mnttab.c
@@ -91,16 +91,28 @@ optadd(char *mntopts, size_t size, const char *opt)
 	strlcat(mntopts, opt, size);
 }
 
+static __thread char gfstypename[MFSNAMELEN];
+static __thread char gmntfromname[MNAMELEN];
+static __thread char gmntonname[MNAMELEN];
+static __thread char gmntopts[MNTMAXSTR];
+
 void
 statfs2mnttab(struct statfs *sfs, struct mnttab *mp)
 {
-	static char mntopts[MNTMAXSTR];
 	long flags;
 
-	mntopts[0] = '\0';
+	strlcpy(gfstypename, sfs->f_fstypename, sizeof (gfstypename));
+	mp->mnt_fstype = gfstypename;
+
+	strlcpy(gmntfromname, sfs->f_mntfromname, sizeof (gmntfromname));
+	mp->mnt_special = gmntfromname;
+
+	strlcpy(gmntonname, sfs->f_mntonname, sizeof (gmntonname));
+	mp->mnt_mountp = gmntonname;
 
 	flags = sfs->f_flags;
-#define	OPTADD(opt)	optadd(mntopts, sizeof (mntopts), (opt))
+	gmntopts[0] = '\0';
+#define	OPTADD(opt)	optadd(gmntopts, sizeof (gmntopts), (opt))
 	if (flags & MNT_RDONLY)
 		OPTADD(MNTOPT_RO);
 	else
@@ -121,10 +133,7 @@ statfs2mnttab(struct statfs *sfs, struct mnttab *mp)
 	else
 		OPTADD(MNTOPT_EXEC);
 #undef	OPTADD
-	mp->mnt_special = strdup(sfs->f_mntfromname);
-	mp->mnt_mountp = strdup(sfs->f_mntonname);
-	mp->mnt_fstype = strdup(sfs->f_fstypename);
-	mp->mnt_mntopts = strdup(mntopts);
+	mp->mnt_mntopts = gmntopts;
 }
 
 static struct statfs *gsfs = NULL;
@@ -166,7 +175,6 @@ statfs_init(void)
 int
 getmntany(FILE *fd __unused, struct mnttab *mgetp, struct mnttab *mrefp)
 {
-	//	struct statfs *sfs;
 	int i, error;
 
 	error = statfs_init();
@@ -195,7 +203,6 @@ getmntany(FILE *fd __unused, struct mnttab *mgetp, struct mnttab *mrefp)
 int
 getmntent(FILE *fp, struct mnttab *mp)
 {
-	//	struct statfs *sfs;
 	int error, nfs;
 
 	nfs = (int)lseek(fileno(fp), 0, SEEK_CUR);
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs.abi b/sys/contrib/openzfs/lib/libzfs/libzfs.abi
index 9bd1fd0db0e9..122321103f7a 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs.abi
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs.abi
@@ -10,14 +10,11 @@
     <dependency name='libm.so.6'/>
     <dependency name='libcrypto.so.1.1'/>
     <dependency name='libz.so.1'/>
-    <dependency name='libdl.so.2'/>
     <dependency name='libpthread.so.0'/>
     <dependency name='libc.so.6'/>
     <dependency name='ld-linux-x86-64.so.2'/>
   </elf-needed>
   <elf-function-symbols>
-    <elf-symbol name='_fini' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
-    <elf-symbol name='_init' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='_sol_getmntent' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='atomic_add_16' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='atomic_add_16_nv' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
@@ -168,7 +165,6 @@
     <elf-symbol name='efi_err_check' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='efi_free' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='efi_rescan' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
-    <elf-symbol name='efi_type' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='efi_use_whole_disk' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='efi_write' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
     <elf-symbol name='entity_namecheck' type='func-type' binding='global-binding' visibility='default-visibility' is-defined='yes'/>
@@ -844,10 +840,6 @@
       <parameter type-id='0d8119a8' name='ptr'/>
       <return type-id='48b5725f'/>
     </function-decl>
-    <function-decl name='efi_type' mangled-name='efi_type' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='efi_type'>
-      <parameter type-id='95e97e5e' name='fd'/>
-      <return type-id='95e97e5e'/>
-    </function-decl>
     <function-decl name='efi_err_check' mangled-name='efi_err_check' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='efi_err_check'>
       <parameter type-id='0d8119a8' name='vtoc'/>
       <return type-id='48b5725f'/>
@@ -1401,6 +1393,9 @@
     <array-type-def dimensions='1' type-id='a84c031d' size-in-bits='160' id='664ac0b7'>
       <subrange length='20' type-id='7359adad' id='fdca39cf'/>
     </array-type-def>
+    <class-decl name='_IO_codecvt' is-struct='yes' visibility='default' is-declaration-only='yes' id='a4036571'/>
+    <class-decl name='_IO_marker' is-struct='yes' visibility='default' is-declaration-only='yes' id='010ae0b9'/>
+    <class-decl name='_IO_wide_data' is-struct='yes' visibility='default' is-declaration-only='yes' id='79bd3751'/>
     <class-decl name='extmnttab' size-in-bits='320' is-struct='yes' visibility='default' id='0c544dc0'>
       <data-member access='public' layout-offset-in-bits='0'>
         <var-decl name='mnt_special' type-id='26a90f95' visibility='default'/>
@@ -1421,18 +1416,66 @@
         <var-decl name='mnt_minor' type-id='3502e3ff' visibility='default'/>
       </data-member>
     </class-decl>
-    <typedef-decl name='_IO_lock_t' type-id='48b5725f' id='bb4788fa'/>
-    <class-decl name='_IO_marker' size-in-bits='192' is-struct='yes' visibility='default' id='010ae0b9'>
+    <class-decl name='stat64' size-in-bits='1152' is-struct='yes' visibility='default' id='0bbec9cd'>
       <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='_next' type-id='e4c6fa61' visibility='default'/>
+        <var-decl name='st_dev' type-id='35ed8932' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='_sbuf' type-id='dca988a5' visibility='default'/>
+        <var-decl name='st_ino' type-id='71288a47' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='128'>
-        <var-decl name='_pos' type-id='95e97e5e' visibility='default'/>
+        <var-decl name='st_nlink' type-id='80f0b9df' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='192'>
+        <var-decl name='st_mode' type-id='e1c52942' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='224'>
+        <var-decl name='st_uid' type-id='cc5fcceb' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='256'>
+        <var-decl name='st_gid' type-id='d94ec6d9' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='288'>
+        <var-decl name='__pad0' type-id='95e97e5e' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='320'>
+        <var-decl name='st_rdev' type-id='35ed8932' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='384'>
+        <var-decl name='st_size' type-id='79989e9c' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='448'>
+        <var-decl name='st_blksize' type-id='d3f10a7f' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='512'>
+        <var-decl name='st_blocks' type-id='4e711bf1' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='576'>
+        <var-decl name='st_atim' type-id='a9c79a1f' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='704'>
+        <var-decl name='st_mtim' type-id='a9c79a1f' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='832'>
+        <var-decl name='st_ctim' type-id='a9c79a1f' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='960'>
+        <var-decl name='__glibc_reserved' type-id='083f8d58' visibility='default'/>
       </data-member>
     </class-decl>
+    <typedef-decl name='__dev_t' type-id='7359adad' id='35ed8932'/>
+    <typedef-decl name='__gid_t' type-id='f0981eeb' id='d94ec6d9'/>
+    <typedef-decl name='__ino64_t' type-id='7359adad' id='71288a47'/>
+    <typedef-decl name='__mode_t' type-id='f0981eeb' id='e1c52942'/>
+    <typedef-decl name='__nlink_t' type-id='7359adad' id='80f0b9df'/>
+    <typedef-decl name='__off_t' type-id='bd54fe1a' id='79989e9c'/>
+    <typedef-decl name='__off64_t' type-id='bd54fe1a' id='724e4de6'/>
+    <typedef-decl name='__time_t' type-id='bd54fe1a' id='65eda9c0'/>
+    <typedef-decl name='__blksize_t' type-id='bd54fe1a' id='d3f10a7f'/>
+    <typedef-decl name='__blkcnt64_t' type-id='bd54fe1a' id='4e711bf1'/>
+    <typedef-decl name='__syscall_slong_t' type-id='bd54fe1a' id='03085adc'/>
+    <typedef-decl name='FILE' type-id='ec1ed955' id='aa12d1ba'/>
+    <typedef-decl name='_IO_lock_t' type-id='48b5725f' id='bb4788fa'/>
     <class-decl name='_IO_FILE' size-in-bits='1728' is-struct='yes' visibility='default' id='ec1ed955'>
       <data-member access='public' layout-offset-in-bits='0'>
         <var-decl name='_flags' type-id='95e97e5e' visibility='default'/>
@@ -1501,16 +1544,16 @@
         <var-decl name='_offset' type-id='724e4de6' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1216'>
-        <var-decl name='__pad1' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_codecvt' type-id='570f8c59' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1280'>
-        <var-decl name='__pad2' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_wide_data' type-id='c65a1f29' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1344'>
-        <var-decl name='__pad3' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_freeres_list' type-id='dca988a5' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1408'>
-        <var-decl name='__pad4' type-id='eaa32e2f' visibility='default'/>
+        <var-decl name='_freeres_buf' type-id='eaa32e2f' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='1472'>
         <var-decl name='__pad5' type-id='b59d7dce' visibility='default'/>
@@ -1522,65 +1565,6 @@
         <var-decl name='_unused2' type-id='664ac0b7' visibility='default'/>
       </data-member>
     </class-decl>
-    <class-decl name='stat64' size-in-bits='1152' is-struct='yes' visibility='default' id='0bbec9cd'>
-      <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='st_dev' type-id='35ed8932' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='st_ino' type-id='71288a47' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='128'>
-        <var-decl name='st_nlink' type-id='80f0b9df' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='192'>
-        <var-decl name='st_mode' type-id='e1c52942' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='224'>
-        <var-decl name='st_uid' type-id='cc5fcceb' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='256'>
-        <var-decl name='st_gid' type-id='d94ec6d9' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='288'>
-        <var-decl name='__pad0' type-id='95e97e5e' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='320'>
-        <var-decl name='st_rdev' type-id='35ed8932' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='384'>
-        <var-decl name='st_size' type-id='79989e9c' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='448'>
-        <var-decl name='st_blksize' type-id='d3f10a7f' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='512'>
-        <var-decl name='st_blocks' type-id='4e711bf1' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='576'>
-        <var-decl name='st_atim' type-id='a9c79a1f' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='704'>
-        <var-decl name='st_mtim' type-id='a9c79a1f' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='832'>
-        <var-decl name='st_ctim' type-id='a9c79a1f' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='960'>
-        <var-decl name='__glibc_reserved' type-id='083f8d58' visibility='default'/>
-      </data-member>
-    </class-decl>
-    <typedef-decl name='__dev_t' type-id='7359adad' id='35ed8932'/>
-    <typedef-decl name='__gid_t' type-id='f0981eeb' id='d94ec6d9'/>
-    <typedef-decl name='__ino64_t' type-id='7359adad' id='71288a47'/>
-    <typedef-decl name='__mode_t' type-id='f0981eeb' id='e1c52942'/>
-    <typedef-decl name='__nlink_t' type-id='7359adad' id='80f0b9df'/>
-    <typedef-decl name='__off_t' type-id='bd54fe1a' id='79989e9c'/>
-    <typedef-decl name='__off64_t' type-id='bd54fe1a' id='724e4de6'/>
-    <typedef-decl name='__time_t' type-id='bd54fe1a' id='65eda9c0'/>
-    <typedef-decl name='__blksize_t' type-id='bd54fe1a' id='d3f10a7f'/>
-    <typedef-decl name='__blkcnt64_t' type-id='bd54fe1a' id='4e711bf1'/>
-    <typedef-decl name='__syscall_slong_t' type-id='bd54fe1a' id='03085adc'/>
-    <typedef-decl name='FILE' type-id='ec1ed955' id='aa12d1ba'/>
     <class-decl name='timespec' size-in-bits='128' is-struct='yes' visibility='default' id='a9c79a1f'>
       <data-member access='public' layout-offset-in-bits='0'>
         <var-decl name='tv_sec' type-id='65eda9c0' visibility='default'/>
@@ -1591,10 +1575,15 @@
     </class-decl>
     <pointer-type-def type-id='aa12d1ba' size-in-bits='64' id='822cd80b'/>
     <pointer-type-def type-id='ec1ed955' size-in-bits='64' id='dca988a5'/>
+    <pointer-type-def type-id='a4036571' size-in-bits='64' id='570f8c59'/>
     <pointer-type-def type-id='bb4788fa' size-in-bits='64' id='cecf4ea7'/>
     <pointer-type-def type-id='010ae0b9' size-in-bits='64' id='e4c6fa61'/>
+    <pointer-type-def type-id='79bd3751' size-in-bits='64' id='c65a1f29'/>
     <pointer-type-def type-id='0c544dc0' size-in-bits='64' id='394fc496'/>
     <pointer-type-def type-id='0bbec9cd' size-in-bits='64' id='62f7a03d'/>
+    <class-decl name='_IO_codecvt' is-struct='yes' visibility='default' is-declaration-only='yes' id='a4036571'/>
+    <class-decl name='_IO_marker' is-struct='yes' visibility='default' is-declaration-only='yes' id='010ae0b9'/>
+    <class-decl name='_IO_wide_data' is-struct='yes' visibility='default' is-declaration-only='yes' id='79bd3751'/>
     <function-decl name='getmntany' mangled-name='getmntany' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='getmntany'>
       <parameter type-id='822cd80b' name='fp'/>
       <parameter type-id='9d424d31' name='mgetp'/>
@@ -1947,8 +1936,18 @@
       </data-member>
     </class-decl>
     <typedef-decl name='zfeature_info_t' type-id='1178d146' id='83f29ca2'/>
+    <class-decl name='zfs_mod_supported_features' size-in-bits='128' is-struct='yes' visibility='default' id='3eee3342'>
+      <data-member access='public' layout-offset-in-bits='0'>
+        <var-decl name='tree' type-id='eaa32e2f' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='64'>
+        <var-decl name='all_features' type-id='c19b74c3' visibility='default'/>
+      </data-member>
+    </class-decl>
     <qualified-type-def type-id='d6618c78' const='yes' id='81a65028'/>
     <pointer-type-def type-id='81a65028' size-in-bits='64' id='1acff326'/>
+    <qualified-type-def type-id='3eee3342' const='yes' id='0c1d5bbb'/>
+    <pointer-type-def type-id='0c1d5bbb' size-in-bits='64' id='a3372543'/>
     <pointer-type-def type-id='d6618c78' size-in-bits='64' id='a8425263'/>
     <var-decl name='spa_feature_table' type-id='d96379d0' mangled-name='spa_feature_table' visibility='default' elf-symbol-id='spa_feature_table'/>
     <var-decl name='zfeature_checks_disable' type-id='c19b74c3' mangled-name='zfeature_checks_disable' visibility='default' elf-symbol-id='zfeature_checks_disable'/>
@@ -1978,6 +1977,7 @@
     <function-decl name='zfs_mod_supported' mangled-name='zfs_mod_supported' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_mod_supported'>
       <parameter type-id='80f4b756' name='scope'/>
       <parameter type-id='80f4b756' name='name'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='c19b74c3'/>
     </function-decl>
     <function-decl name='zpool_feature_init' mangled-name='zpool_feature_init' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zpool_feature_init'>
@@ -1985,7 +1985,7 @@
     </function-decl>
   </abi-instr>
   <abi-instr address-size='64' path='../../module/zcommon/zfs_comutil.c' language='LANG_C99'>
-    <array-type-def dimensions='1' type-id='80f4b756' size-in-bits='2624' id='ef31fedf'>
+    <array-type-def dimensions='1' type-id='b99c00c9' size-in-bits='2624' id='5ce15418'>
       <subrange length='41' type-id='7359adad' id='cb834f44'/>
     </array-type-def>
     <class-decl name='zpool_load_policy' size-in-bits='256' is-struct='yes' visibility='default' id='2f65b36f'>
@@ -2003,8 +2003,9 @@
       </data-member>
     </class-decl>
     <typedef-decl name='zpool_load_policy_t' type-id='2f65b36f' id='d11b7617'/>
+    <qualified-type-def type-id='80f4b756' const='yes' id='b99c00c9'/>
     <pointer-type-def type-id='d11b7617' size-in-bits='64' id='23432aaa'/>
-    <var-decl name='zfs_history_event_names' type-id='ef31fedf' mangled-name='zfs_history_event_names' visibility='default' elf-symbol-id='zfs_history_event_names'/>
+    <var-decl name='zfs_history_event_names' type-id='5ce15418' mangled-name='zfs_history_event_names' visibility='default' elf-symbol-id='zfs_history_event_names'/>
     <function-decl name='zfs_allocatable_devs' mangled-name='zfs_allocatable_devs' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_allocatable_devs'>
       <parameter type-id='5ce45b60' name='nv'/>
       <return type-id='c19b74c3'/>
@@ -2033,7 +2034,7 @@
     </function-decl>
   </abi-instr>
   <abi-instr address-size='64' path='../../module/zcommon/zfs_deleg.c' language='LANG_C99'>
-    <array-type-def dimensions='1' type-id='f3f851ad' size-in-bits='infinite' id='bc4e5d90'>
+    <array-type-def dimensions='1' type-id='fa1870fd' size-in-bits='infinite' id='7c00e69d'>
       <subrange length='infinite' id='031f2035'/>
     </array-type-def>
     <enum-decl name='zfs_deleg_who_type_t' naming-typedef-id='36d4bd5a' id='b5fa5816'>
@@ -2096,7 +2097,8 @@
       </data-member>
     </class-decl>
     <typedef-decl name='zfs_deleg_perm_tab_t' type-id='5aa05c1f' id='f3f851ad'/>
-    <var-decl name='zfs_deleg_perm_tab' type-id='bc4e5d90' mangled-name='zfs_deleg_perm_tab' visibility='default' elf-symbol-id='zfs_deleg_perm_tab'/>
+    <qualified-type-def type-id='f3f851ad' const='yes' id='fa1870fd'/>
+    <var-decl name='zfs_deleg_perm_tab' type-id='7c00e69d' mangled-name='zfs_deleg_perm_tab' visibility='default' elf-symbol-id='zfs_deleg_perm_tab'/>
     <function-decl name='zfs_deleg_canonicalize_perm' mangled-name='zfs_deleg_canonicalize_perm' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_deleg_canonicalize_perm'>
       <parameter type-id='80f4b756' name='perm'/>
       <return type-id='80f4b756'/>
@@ -2454,7 +2456,7 @@
     </function-decl>
   </abi-instr>
   <abi-instr address-size='64' path='../../module/zcommon/zfs_prop.c' language='LANG_C99'>
-    <array-type-def dimensions='1' type-id='80f4b756' size-in-bits='768' id='35e4b367'>
+    <array-type-def dimensions='1' type-id='b99c00c9' size-in-bits='768' id='bcc77e38'>
       <subrange length='12' type-id='7359adad' id='84827bdc'/>
     </array-type-def>
     <enum-decl name='zprop_type_t' naming-typedef-id='31429eff' id='87676253'>
@@ -2531,7 +2533,7 @@
     <qualified-type-def type-id='64636ce3' const='yes' id='072f7953'/>
     <pointer-type-def type-id='072f7953' size-in-bits='64' id='c8bc397b'/>
     <pointer-type-def type-id='ffa52b96' size-in-bits='64' id='76c8174b'/>
-    <var-decl name='zfs_userquota_prop_prefixes' type-id='35e4b367' mangled-name='zfs_userquota_prop_prefixes' visibility='default' elf-symbol-id='zfs_userquota_prop_prefixes'/>
+    <var-decl name='zfs_userquota_prop_prefixes' type-id='bcc77e38' mangled-name='zfs_userquota_prop_prefixes' visibility='default' elf-symbol-id='zfs_userquota_prop_prefixes'/>
     <function-decl name='zfs_prop_get_table' mangled-name='zfs_prop_get_table' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_prop_get_table'>
       <return type-id='76c8174b'/>
     </function-decl>
@@ -2793,6 +2795,7 @@
       <parameter type-id='c19b74c3' name='rightalign'/>
       <parameter type-id='c19b74c3' name='visible'/>
       <parameter type-id='c8bc397b' name='idx_tbl'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='48b5725f'/>
     </function-decl>
     <function-decl name='zprop_register_string' mangled-name='zprop_register_string' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zprop_register_string'>
@@ -2803,6 +2806,7 @@
       <parameter type-id='95e97e5e' name='objset_types'/>
       <parameter type-id='80f4b756' name='values'/>
       <parameter type-id='80f4b756' name='colname'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='48b5725f'/>
     </function-decl>
     <function-decl name='zprop_register_number' mangled-name='zprop_register_number' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zprop_register_number'>
@@ -2813,6 +2817,7 @@
       <parameter type-id='95e97e5e' name='objset_types'/>
       <parameter type-id='80f4b756' name='values'/>
       <parameter type-id='80f4b756' name='colname'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='48b5725f'/>
     </function-decl>
     <function-decl name='zprop_register_index' mangled-name='zprop_register_index' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zprop_register_index'>
@@ -2824,6 +2829,7 @@
       <parameter type-id='80f4b756' name='values'/>
       <parameter type-id='80f4b756' name='colname'/>
       <parameter type-id='c8bc397b' name='idx_tbl'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='48b5725f'/>
     </function-decl>
     <function-decl name='zprop_register_hidden' mangled-name='zprop_register_hidden' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zprop_register_hidden'>
@@ -2833,6 +2839,7 @@
       <parameter type-id='999701cc' name='attr'/>
       <parameter type-id='95e97e5e' name='objset_types'/>
       <parameter type-id='80f4b756' name='colname'/>
+      <parameter type-id='a3372543' name='sfeatures'/>
       <return type-id='48b5725f'/>
     </function-decl>
     <function-decl name='zprop_iter_common' mangled-name='zprop_iter_common' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zprop_iter_common'>
@@ -2907,6 +2914,9 @@
     <array-type-def dimensions='1' type-id='a84c031d' size-in-bits='320' id='36c46961'>
       <subrange length='40' type-id='7359adad' id='8f80b239'/>
     </array-type-def>
+    <class-decl name='re_dfa_t' is-struct='yes' visibility='default' is-declaration-only='yes' id='b48d2441'/>
+    <class-decl name='uu_avl' is-struct='yes' visibility='default' is-declaration-only='yes' id='4af029d1'/>
+    <class-decl name='uu_avl_pool' is-struct='yes' visibility='default' is-declaration-only='yes' id='12a530a8'/>
     <type-decl name='int' size-in-bits='32' id='95e97e5e'/>
     <type-decl name='long int' size-in-bits='64' id='bd54fe1a'/>
     <type-decl name='long long int' size-in-bits='64' id='1eb56b1e'/>
@@ -3149,16 +3159,17 @@
         <var-decl name='zpool_start_block' type-id='804dc465' visibility='default'/>
       </data-member>
     </class-decl>
+    <typedef-decl name='__re_long_size_t' type-id='7359adad' id='ba516949'/>
     <typedef-decl name='reg_syntax_t' type-id='7359adad' id='1b72c3b3'/>
     <class-decl name='re_pattern_buffer' size-in-bits='512' is-struct='yes' visibility='default' id='19fc9a8c'>
       <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='buffer' type-id='cf536864' visibility='default'/>
+        <var-decl name='buffer' type-id='33976309' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='allocated' type-id='7359adad' visibility='default'/>
+        <var-decl name='allocated' type-id='ba516949' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='128'>
-        <var-decl name='used' type-id='7359adad' visibility='default'/>
+        <var-decl name='used' type-id='ba516949' visibility='default'/>
       </data-member>
       <data-member access='public' layout-offset-in-bits='192'>
         <var-decl name='syntax' type-id='1b72c3b3' visibility='default'/>
@@ -3212,15 +3223,6 @@
     <typedef-decl name='uint8_t' type-id='c51d6389' id='b96825af'/>
     <typedef-decl name='uint32_t' type-id='62f1140c' id='8f92235e'/>
     <typedef-decl name='uint64_t' type-id='8910171f' id='9c313c2d'/>
-    <class-decl name='__pthread_internal_list' size-in-bits='128' is-struct='yes' visibility='default' id='0e01899c'>
-      <data-member access='public' layout-offset-in-bits='0'>
-        <var-decl name='__prev' type-id='4d98cd5a' visibility='default'/>
-      </data-member>
-      <data-member access='public' layout-offset-in-bits='64'>
-        <var-decl name='__next' type-id='4d98cd5a' visibility='default'/>
-      </data-member>
-    </class-decl>
-    <typedef-decl name='__pthread_list_t' type-id='0e01899c' id='518fb49c'/>
     <class-decl name='__pthread_mutex_s' size-in-bits='320' is-struct='yes' visibility='default' id='4c734837'>
       <data-member access='public' layout-offset-in-bits='0'>
         <var-decl name='__lock' type-id='95e97e5e' visibility='default'/>
@@ -3247,6 +3249,15 @@
         <var-decl name='__list' type-id='518fb49c' visibility='default'/>
       </data-member>
     </class-decl>
+    <class-decl name='__pthread_internal_list' size-in-bits='128' is-struct='yes' visibility='default' id='0e01899c'>
+      <data-member access='public' layout-offset-in-bits='0'>
+        <var-decl name='__prev' type-id='4d98cd5a' visibility='default'/>
+      </data-member>
+      <data-member access='public' layout-offset-in-bits='64'>
+        <var-decl name='__next' type-id='4d98cd5a' visibility='default'/>
+      </data-member>
+    </class-decl>
+    <typedef-decl name='__pthread_list_t' type-id='0e01899c' id='518fb49c'/>
     <typedef-decl name='__uint8_t' type-id='002ac4a6' id='c51d6389'/>
     <typedef-decl name='__int32_t' type-id='95e97e5e' id='33f57a65'/>
     <typedef-decl name='__uint32_t' type-id='f0981eeb' id='62f1140c'/>
@@ -3264,6 +3275,7 @@
     <pointer-type-def type-id='95942d0c' size-in-bits='64' id='b0382bb3'/>
     <pointer-type-def type-id='8e8d4be3' size-in-bits='64' id='5ce45b60'/>
     <pointer-type-def type-id='5ce45b60' size-in-bits='64' id='857bb57e'/>
+    <pointer-type-def type-id='b48d2441' size-in-bits='64' id='33976309'/>
     <pointer-type-def type-id='b96825af' size-in-bits='64' id='ae3e8ca6'/>
     <pointer-type-def type-id='002ac4a6' size-in-bits='64' id='cf536864'/>
     <pointer-type-def type-id='7f84e390' size-in-bits='64' id='de82c773'/>
@@ -3271,6 +3283,7 @@
     <pointer-type-def type-id='48b5725f' size-in-bits='64' id='eaa32e2f'/>
     <pointer-type-def type-id='775509eb' size-in-bits='64' id='9200a744'/>
     <pointer-type-def type-id='b1efc708' size-in-bits='64' id='4c81de99'/>
+    <class-decl name='re_dfa_t' is-struct='yes' visibility='default' is-declaration-only='yes' id='b48d2441'/>
     <class-decl name='uu_avl' is-struct='yes' visibility='default' is-declaration-only='yes' id='4af029d1'/>
     <class-decl name='uu_avl_pool' is-struct='yes' visibility='default' is-declaration-only='yes' id='12a530a8'/>
     <function-decl name='zpool_get_config' mangled-name='zpool_get_config' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zpool_get_config'>
@@ -4175,10 +4188,6 @@
       <parameter type-id='9200a744' name='zhp'/>
       <return type-id='95e97e5e'/>
     </function-decl>
-    <function-decl name='zfs_shareall' mangled-name='zfs_shareall' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_shareall'>
-      <parameter type-id='9200a744' name='zhp'/>
-      <return type-id='95e97e5e'/>
-    </function-decl>
     <function-decl name='zfs_unshare_nfs' mangled-name='zfs_unshare_nfs' visibility='default' binding='global' size-in-bits='64' elf-symbol-id='zfs_unshare_nfs'>
       <parameter type-id='9200a744' name='zhp'/>
       <parameter type-id='80f4b756' name='mountpoint'/>
@@ -5623,7 +5632,7 @@
     </function-decl>
   </abi-instr>
   <abi-instr address-size='64' path='os/linux/zutil_import_os.c' language='LANG_C99'>
-    <qualified-type-def type-id='80f4b756' const='yes' id='b99c00c9'/>
+    <class-decl name='udev_device' is-struct='yes' visibility='default' is-declaration-only='yes' id='640b33ca'/>
     <pointer-type-def type-id='b99c00c9' size-in-bits='64' id='13956559'/>
     <pointer-type-def type-id='b59d7dce' size-in-bits='64' id='78c01427'/>
     <pointer-type-def type-id='640b33ca' size-in-bits='64' id='b32bae08'/>
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_changelist.c b/sys/contrib/openzfs/lib/libzfs/libzfs_changelist.c
index 4d90a511f607..9c8241a874fa 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_changelist.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_changelist.c
@@ -592,7 +592,6 @@ compare_props(const void *a, const void *b, zfs_prop_t prop)
 		return (strcmp(propb, propa));
 }
 
-/*ARGSUSED*/
 static int
 compare_mountpoints(const void *a, const void *b, void *unused)
 {
@@ -602,13 +601,14 @@ compare_mountpoints(const void *a, const void *b, void *unused)
 	 * hierarchy that is different from the dataset hierarchy, and still
 	 * allow it to be changed.
 	 */
+	(void) unused;
 	return (compare_props(a, b, ZFS_PROP_MOUNTPOINT));
 }
 
-/*ARGSUSED*/
 static int
 compare_dataset_names(const void *a, const void *b, void *unused)
 {
+	(void) unused;
 	return (compare_props(a, b, ZFS_PROP_NAME));
 }
 
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_config.c b/sys/contrib/openzfs/lib/libzfs/libzfs_config.c
index a3ecc4a327dc..dd590159660a 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_config.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_config.c
@@ -56,16 +56,14 @@ typedef struct config_node {
 	uu_avl_node_t	cn_avl;
 } config_node_t;
 
-/* ARGSUSED */
 static int
 config_node_compare(const void *a, const void *b, void *unused)
 {
-	int ret;
-
+	(void) unused;
 	const config_node_t *ca = (config_node_t *)a;
 	const config_node_t *cb = (config_node_t *)b;
 
-	ret = strcmp(ca->cn_name, cb->cn_name);
+	int ret = strcmp(ca->cn_name, cb->cn_name);
 
 	if (ret < 0)
 		return (-1);
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_crypto.c b/sys/contrib/openzfs/lib/libzfs/libzfs_crypto.c
index cfe04a79273d..e3486cf9a386 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_crypto.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_crypto.c
@@ -482,6 +482,7 @@ get_key_material_file(libzfs_handle_t *hdl, const char *uri,
     const char *fsname, zfs_keyformat_t keyformat, boolean_t newkey,
     uint8_t **restrict buf, size_t *restrict len_out)
 {
+	(void) fsname, (void) newkey;
 	FILE *f = NULL;
 	int ret = 0;
 
@@ -508,6 +509,7 @@ get_key_material_https(libzfs_handle_t *hdl, const char *uri,
     const char *fsname, zfs_keyformat_t keyformat, boolean_t newkey,
     uint8_t **restrict buf, size_t *restrict len_out)
 {
+	(void) fsname, (void) newkey;
 	int ret = 0;
 	FILE *key = NULL;
 	boolean_t is_http = strncmp(uri, "http:", strlen("http:")) == 0;
@@ -773,7 +775,7 @@ get_key_material(libzfs_handle_t *hdl, boolean_t do_verify, boolean_t newkey,
 
 static int
 derive_key(libzfs_handle_t *hdl, zfs_keyformat_t format, uint64_t iters,
-    uint8_t *key_material, size_t key_material_len, uint64_t salt,
+    uint8_t *key_material, uint64_t salt,
     uint8_t **key_out)
 {
 	int ret;
@@ -916,8 +918,7 @@ populate_create_encryption_params_nvlists(libzfs_handle_t *hdl,
 	}
 
 	/* derive a key from the key material */
-	ret = derive_key(hdl, keyformat, iters, key_material, key_material_len,
-	    salt, &key_data);
+	ret = derive_key(hdl, keyformat, iters, key_material, salt, &key_data);
 	if (ret != 0)
 		goto error;
 
@@ -1175,6 +1176,7 @@ int
 zfs_crypto_clone_check(libzfs_handle_t *hdl, zfs_handle_t *origin_zhp,
     char *parent_name, nvlist_t *props)
 {
+	(void) origin_zhp, (void) parent_name;
 	char errbuf[1024];
 
 	(void) snprintf(errbuf, sizeof (errbuf),
@@ -1372,8 +1374,8 @@ zfs_crypto_load_key(zfs_handle_t *zhp, boolean_t noop, char *alt_keylocation)
 		goto error;
 
 	/* derive a key from the key material */
-	ret = derive_key(zhp->zfs_hdl, keyformat, iters, key_material,
-	    key_material_len, salt, &key_data);
+	ret = derive_key(zhp->zfs_hdl, keyformat, iters, key_material, salt,
+	    &key_data);
 	if (ret != 0)
 		goto error;
 
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_dataset.c b/sys/contrib/openzfs/lib/libzfs/libzfs_dataset.c
index 5836587d27e2..bbc12877dc05 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_dataset.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_dataset.c
@@ -3155,6 +3155,7 @@ userquota_propname_decode(const char *propname, boolean_t zoned,
 		if (errno != 0 || *end != '\0')
 			return (EINVAL);
 #else
+		(void) domainlen;
 		return (ENOSYS);
 #endif /* HAVE_IDMAP */
 	} else {
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_mount.c b/sys/contrib/openzfs/lib/libzfs/libzfs_mount.c
index e97de8f20262..7959933ede5a 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_mount.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_mount.c
@@ -244,12 +244,11 @@ zfs_is_mounted(zfs_handle_t *zhp, char **where)
  * Checks any higher order concerns about whether the given dataset is
  * mountable, false otherwise.  zfs_is_mountable_internal specifically assumes
  * that the caller has verified the sanity of mounting the dataset at
- * mountpoint to the extent the caller wants.
+ * its mountpoint to the extent the caller wants.
  */
 static boolean_t
-zfs_is_mountable_internal(zfs_handle_t *zhp, const char *mountpoint)
+zfs_is_mountable_internal(zfs_handle_t *zhp)
 {
-
 	if (zfs_prop_get_int(zhp, ZFS_PROP_ZONED) &&
 	    getzoneid() == GLOBAL_ZONEID)
 		return (B_FALSE);
@@ -282,7 +281,7 @@ zfs_is_mountable(zfs_handle_t *zhp, char *buf, size_t buflen,
 	if (zfs_prop_get_int(zhp, ZFS_PROP_CANMOUNT) == ZFS_CANMOUNT_OFF)
 		return (B_FALSE);
 
-	if (!zfs_is_mountable_internal(zhp, buf))
+	if (!zfs_is_mountable_internal(zhp))
 		return (B_FALSE);
 
 	if (zfs_prop_get_int(zhp, ZFS_PROP_REDACTED) && !(flags & MS_FORCE))
@@ -402,7 +401,7 @@ zfs_mount_at(zfs_handle_t *zhp, const char *options, int flags,
 		remount = 1;
 
 	/* Potentially duplicates some checks if invoked by zfs_mount(). */
-	if (!zfs_is_mountable_internal(zhp, mountpoint))
+	if (!zfs_is_mountable_internal(zhp))
 		return (0);
 
 	/*
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_sendrecv.c b/sys/contrib/openzfs/lib/libzfs/libzfs_sendrecv.c
index 7460ffc4133b..d07e355e3921 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_sendrecv.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_sendrecv.c
@@ -2542,7 +2542,7 @@ zfs_send_one(zfs_handle_t *zhp, const char *from, int fd, sendflags_t *flags,
 			    "progress thread exited nonzero")));
 	}
 
-	if (flags->props || flags->holds || flags->backup) {
+	if (err == 0 && (flags->props || flags->holds || flags->backup)) {
 		/* Write the final end record. */
 		err = send_conclusion_record(fd, NULL);
 		if (err != 0)
diff --git a/sys/contrib/openzfs/lib/libzfs/libzfs_status.c b/sys/contrib/openzfs/lib/libzfs/libzfs_status.c
index 33d6e1bfdf80..b7713b2bfe09 100644
--- a/sys/contrib/openzfs/lib/libzfs/libzfs_status.c
+++ b/sys/contrib/openzfs/lib/libzfs/libzfs_status.c
@@ -96,48 +96,48 @@ static char *zfs_msgid_table[] = {
 
 #define	NMSGID	(sizeof (zfs_msgid_table) / sizeof (zfs_msgid_table[0]))
 
-/* ARGSUSED */
 static int
 vdev_missing(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_CANT_OPEN &&
 	    vs->vs_aux == VDEV_AUX_OPEN_FAILED);
 }
 
-/* ARGSUSED */
 static int
 vdev_faulted(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_FAULTED);
 }
 
-/* ARGSUSED */
 static int
 vdev_errors(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_DEGRADED ||
 	    vs->vs_read_errors != 0 || vs->vs_write_errors != 0 ||
 	    vs->vs_checksum_errors != 0);
 }
 
-/* ARGSUSED */
 static int
 vdev_broken(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_CANT_OPEN);
 }
 
-/* ARGSUSED */
 static int
 vdev_offlined(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_OFFLINE);
 }
 
-/* ARGSUSED */
 static int
 vdev_removed(vdev_stat_t *vs, uint_t vsc)
 {
+	(void) vsc;
 	return (vs->vs_state == VDEV_STATE_REMOVED);
 }
 
diff --git a/sys/contrib/openzfs/lib/libzfs/os/freebsd/libzfs_zmount.c b/sys/contrib/openzfs/lib/libzfs/os/freebsd/libzfs_zmount.c
index 12317fdde38e..79a8fe111f29 100644
--- a/sys/contrib/openzfs/lib/libzfs/os/freebsd/libzfs_zmount.c
+++ b/sys/contrib/openzfs/lib/libzfs/os/freebsd/libzfs_zmount.c
@@ -123,6 +123,7 @@ do_mount(zfs_handle_t *zhp, const char *mntpt, char *opts, int flags)
 int
 do_unmount(zfs_handle_t *zhp, const char *mntpt, int flags)
 {
+	(void) zhp;
 	if (unmount(mntpt, flags) < 0)
 		return (errno);
 	return (0);
@@ -138,10 +139,12 @@ zfs_mount_delegation_check(void)
 void
 zpool_disable_datasets_os(zpool_handle_t *zhp, boolean_t force)
 {
+	(void) zhp, (void) force;
 }
 
 /* Called from the tail end of zfs_unmount() */
 void
 zpool_disable_volume_os(const char *name)
 {
+	(void) name;
 }
diff --git a/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_mount_os.c b/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_mount_os.c
index 29fea736b605..1b01caeb7079 100644
--- a/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_mount_os.c
+++ b/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_mount_os.c
@@ -327,7 +327,7 @@ do_mount(zfs_handle_t *zhp, const char *mntpt, char *opts, int flags)
 
 	if (!libzfs_envvar_is_set("ZFS_MOUNT_HELPER")) {
 		char badopt[MNT_LINE_MAX] = {0};
-		unsigned long mntflags = flags, zfsflags;
+		unsigned long mntflags = flags, zfsflags = 0;
 		char myopts[MNT_LINE_MAX] = {0};
 
 		if (zfs_parse_mount_options(opts, &mntflags,
@@ -376,6 +376,8 @@ do_mount(zfs_handle_t *zhp, const char *mntpt, char *opts, int flags)
 int
 do_unmount(zfs_handle_t *zhp, const char *mntpt, int flags)
 {
+	(void) zhp;
+
 	if (!libzfs_envvar_is_set("ZFS_MOUNT_HELPER")) {
 		int rv = umount2(mntpt, flags);
 
@@ -416,10 +418,12 @@ zfs_mount_delegation_check(void)
 void
 zpool_disable_datasets_os(zpool_handle_t *zhp, boolean_t force)
 {
+	(void) zhp, (void) force;
 }
 
 /* Called from the tail end of zfs_unmount() */
 void
 zpool_disable_volume_os(const char *name)
 {
+	(void) name;
 }
diff --git a/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_util_os.c b/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_util_os.c
index 2ac31f1077ca..a32aa1513b39 100644
--- a/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_util_os.c
+++ b/sys/contrib/openzfs/lib/libzfs/os/linux/libzfs_util_os.c
@@ -187,6 +187,7 @@ find_shares_object(differ_info_t *di)
 int
 zfs_destroy_snaps_nvl_os(libzfs_handle_t *hdl, nvlist_t *snaps)
 {
+	(void) hdl, (void) snaps;
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/lib/libzfs_core/libzfs_core.c b/sys/contrib/openzfs/lib/libzfs_core/libzfs_core.c
index c7c4482a0cba..99652bc4a03a 100644
--- a/sys/contrib/openzfs/lib/libzfs_core/libzfs_core.c
+++ b/sys/contrib/openzfs/lib/libzfs_core/libzfs_core.c
@@ -476,10 +476,10 @@ lzc_exists(const char *dataset)
  * It was added to preserve the function signature in case it is
  * needed in the future.
  */
-/*ARGSUSED*/
 int
 lzc_sync(const char *pool_name, nvlist_t *innvl, nvlist_t **outnvl)
 {
+	(void) outnvl;
 	return (lzc_ioctl(ZFS_IOC_POOL_SYNC, pool_name, innvl, NULL));
 }
 
@@ -1032,6 +1032,7 @@ lzc_receive_one(const char *snapname, nvlist_t *props,
     uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,
     nvlist_t **errors)
 {
+	(void) action_handle, (void) cleanup_fd;
 	return (recv_impl(snapname, props, NULL, NULL, 0, origin, force,
 	    resumable, raw, input_fd, begin_record,
 	    read_bytes, errflags, errors));
@@ -1053,6 +1054,7 @@ lzc_receive_with_cmdprops(const char *snapname, nvlist_t *props,
     uint64_t *read_bytes, uint64_t *errflags, uint64_t *action_handle,
     nvlist_t **errors)
 {
+	(void) action_handle, (void) cleanup_fd;
 	return (recv_impl(snapname, props, cmdprops, wkeydata, wkeylen, origin,
 	    force, resumable, raw, input_fd, begin_record,
 	    read_bytes, errflags, errors));
diff --git a/sys/contrib/openzfs/lib/libzpool/Makefile.am b/sys/contrib/openzfs/lib/libzpool/Makefile.am
index dce3f81b829d..e49577ec4a63 100644
--- a/sys/contrib/openzfs/lib/libzpool/Makefile.am
+++ b/sys/contrib/openzfs/lib/libzpool/Makefile.am
@@ -94,6 +94,7 @@ KERNEL_C = \
 	gzip.c \
 	hkdf.c \
 	lz4.c \
+	lz4_zfs.c \
 	lzjb.c \
 	metaslab.c \
 	mmp.c \
diff --git a/sys/contrib/openzfs/lib/libzpool/kernel.c b/sys/contrib/openzfs/lib/libzpool/kernel.c
index ef75706fa6e3..41e0e7815c43 100644
--- a/sys/contrib/openzfs/lib/libzpool/kernel.c
+++ b/sys/contrib/openzfs/lib/libzpool/kernel.c
@@ -75,7 +75,6 @@ struct proc p0;
 #define	TS_STACK_MIN	MAX(PTHREAD_STACK_MIN, 32768)
 #define	TS_STACK_MAX	(256 * 1024)
 
-/*ARGSUSED*/
 kthread_t *
 zk_thread_create(void (*func)(void *), void *arg, size_t stksize, int state)
 {
@@ -129,30 +128,35 @@ zk_thread_create(void (*func)(void *), void *arg, size_t stksize, int state)
  * kstats
  * =========================================================================
  */
-/*ARGSUSED*/
 kstat_t *
 kstat_create(const char *module, int instance, const char *name,
     const char *class, uchar_t type, ulong_t ndata, uchar_t ks_flag)
 {
+	(void) module, (void) instance, (void) name, (void) class, (void) type,
+	    (void) ndata, (void) ks_flag;
 	return (NULL);
 }
 
-/*ARGSUSED*/
 void
 kstat_install(kstat_t *ksp)
-{}
+{
+	(void) ksp;
+}
 
-/*ARGSUSED*/
 void
 kstat_delete(kstat_t *ksp)
-{}
+{
+	(void) ksp;
+}
 
 void
 kstat_set_raw_ops(kstat_t *ksp,
     int (*headers)(char *buf, size_t size),
     int (*data)(char *buf, size_t size, void *data),
     void *(*addr)(kstat_t *ksp, loff_t index))
-{}
+{
+	(void) ksp, (void) headers, (void) data, (void) addr;
+}
 
 /*
  * =========================================================================
@@ -163,6 +167,7 @@ kstat_set_raw_ops(kstat_t *ksp,
 void
 mutex_init(kmutex_t *mp, char *name, int type, void *cookie)
 {
+	(void) name, (void) type, (void) cookie;
 	VERIFY0(pthread_mutex_init(&mp->m_lock, NULL));
 	memset(&mp->m_owner, 0, sizeof (pthread_t));
 }
@@ -183,9 +188,7 @@ mutex_enter(kmutex_t *mp)
 int
 mutex_tryenter(kmutex_t *mp)
 {
-	int error;
-
-	error = pthread_mutex_trylock(&mp->m_lock);
+	int error = pthread_mutex_trylock(&mp->m_lock);
 	if (error == 0) {
 		mp->m_owner = pthread_self();
 		return (1);
@@ -211,6 +214,7 @@ mutex_exit(kmutex_t *mp)
 void
 rw_init(krwlock_t *rwlp, char *name, int type, void *arg)
 {
+	(void) name, (void) type, (void) arg;
 	VERIFY0(pthread_rwlock_init(&rwlp->rw_lock, NULL));
 	rwlp->rw_readers = 0;
 	rwlp->rw_owner = 0;
@@ -269,19 +273,20 @@ rw_tryenter(krwlock_t *rwlp, krw_t rw)
 	return (0);
 }
 
-/* ARGSUSED */
 uint32_t
 zone_get_hostid(void *zonep)
 {
 	/*
 	 * We're emulating the system's hostid in userland.
 	 */
+	(void) zonep;
 	return (strtoul(hw_serial, NULL, 10));
 }
 
 int
 rw_tryupgrade(krwlock_t *rwlp)
 {
+	(void) rwlp;
 	return (0);
 }
 
@@ -294,6 +299,7 @@ rw_tryupgrade(krwlock_t *rwlp)
 void
 cv_init(kcondvar_t *cv, char *name, int type, void *arg)
 {
+	(void) name, (void) type, (void) arg;
 	VERIFY0(pthread_cond_init(cv, NULL));
 }
 
@@ -351,11 +357,11 @@ cv_timedwait(kcondvar_t *cv, kmutex_t *mp, clock_t abstime)
 	return (1);
 }
 
-/*ARGSUSED*/
 int
 cv_timedwait_hires(kcondvar_t *cv, kmutex_t *mp, hrtime_t tim, hrtime_t res,
     int flag)
 {
+	(void) res;
 	int error;
 	struct timeval tv;
 	struct timespec ts;
@@ -411,7 +417,9 @@ cv_broadcast(kcondvar_t *cv)
 
 void
 seq_printf(struct seq_file *m, const char *fmt, ...)
-{}
+{
+	(void) m, (void) fmt;
+}
 
 void
 procfs_list_install(const char *module,
@@ -424,6 +432,8 @@ procfs_list_install(const char *module,
     int (*clear)(procfs_list_t *procfs_list),
     size_t procfs_list_node_off)
 {
+	(void) module, (void) submodule, (void) name, (void) mode, (void) show,
+	    (void) show_header, (void) clear;
 	mutex_init(&procfs_list->pl_lock, NULL, MUTEX_DEFAULT, NULL);
 	list_create(&procfs_list->pl_list,
 	    procfs_list_node_off + sizeof (procfs_list_node_t),
@@ -434,7 +444,9 @@ procfs_list_install(const char *module,
 
 void
 procfs_list_uninstall(procfs_list_t *procfs_list)
-{}
+{
+	(void) procfs_list;
+}
 
 void
 procfs_list_destroy(procfs_list_t *procfs_list)
@@ -738,6 +750,7 @@ random_get_pseudo_bytes(uint8_t *ptr, size_t len)
 int
 ddi_strtoul(const char *hw_serial, char **nptr, int base, unsigned long *result)
 {
+	(void) nptr;
 	char *end;
 
 	*result = strtoul(hw_serial, &end, base);
@@ -749,6 +762,7 @@ ddi_strtoul(const char *hw_serial, char **nptr, int base, unsigned long *result)
 int
 ddi_strtoull(const char *str, char **nptr, int base, u_longlong_t *result)
 {
+	(void) nptr;
 	char *end;
 
 	*result = strtoull(str, &end, base);
@@ -826,60 +840,70 @@ kernel_fini(void)
 uid_t
 crgetuid(cred_t *cr)
 {
+	(void) cr;
 	return (0);
 }
 
 uid_t
 crgetruid(cred_t *cr)
 {
+	(void) cr;
 	return (0);
 }
 
 gid_t
 crgetgid(cred_t *cr)
 {
+	(void) cr;
 	return (0);
 }
 
 int
 crgetngroups(cred_t *cr)
 {
+	(void) cr;
 	return (0);
 }
 
 gid_t *
 crgetgroups(cred_t *cr)
 {
+	(void) cr;
 	return (NULL);
 }
 
 int
 zfs_secpolicy_snapshot_perms(const char *name, cred_t *cr)
 {
+	(void) name, (void) cr;
 	return (0);
 }
 
 int
 zfs_secpolicy_rename_perms(const char *from, const char *to, cred_t *cr)
 {
+	(void) from, (void) to, (void) cr;
 	return (0);
 }
 
 int
 zfs_secpolicy_destroy_perms(const char *name, cred_t *cr)
 {
+	(void) name, (void) cr;
 	return (0);
 }
 
 int
 secpolicy_zfs(const cred_t *cr)
 {
+	(void) cr;
 	return (0);
 }
 
 int
 secpolicy_zfs_proc(const cred_t *cr, proc_t *proc)
 {
+	(void) cr, (void) proc;
 	return (0);
 }
 
@@ -926,25 +950,25 @@ kmem_asprintf(const char *fmt, ...)
 	return (buf);
 }
 
-/* ARGSUSED */
 zfs_file_t *
 zfs_onexit_fd_hold(int fd, minor_t *minorp)
 {
+	(void) fd;
 	*minorp = 0;
 	return (NULL);
 }
 
-/* ARGSUSED */
 void
 zfs_onexit_fd_rele(zfs_file_t *fp)
 {
+	(void) fp;
 }
 
-/* ARGSUSED */
 int
 zfs_onexit_add_cb(minor_t minor, void (*func)(void *), void *data,
     uint64_t *action_handle)
 {
+	(void) minor, (void) func, (void) data, (void) action_handle;
 	return (0);
 }
 
@@ -957,6 +981,7 @@ spl_fstrans_mark(void)
 void
 spl_fstrans_unmark(fstrans_cookie_t cookie)
 {
+	(void) cookie;
 }
 
 int
@@ -976,22 +1001,26 @@ void *zvol_tag = "zvol_tag";
 void
 zvol_create_minor(const char *name)
 {
+	(void) name;
 }
 
 void
 zvol_create_minors_recursive(const char *name)
 {
+	(void) name;
 }
 
 void
 zvol_remove_minors(spa_t *spa, const char *name, boolean_t async)
 {
+	(void) spa, (void) name, (void) async;
 }
 
 void
 zvol_rename_minors(spa_t *spa, const char *oldname, const char *newname,
     boolean_t async)
 {
+	(void) spa, (void) oldname, (void) newname, (void) async;
 }
 
 /*
@@ -1285,10 +1314,9 @@ zfs_file_getattr(zfs_file_t *fp, zfs_file_attr_t *zfattr)
 int
 zfs_file_fsync(zfs_file_t *fp, int flags)
 {
-	int rc;
+	(void) flags;
 
-	rc = fsync(fp->f_fd);
-	if (rc < 0)
+	if (fsync(fp->f_fd) < 0)
 		return (errno);
 
 	return (0);
@@ -1310,6 +1338,7 @@ zfs_file_fallocate(zfs_file_t *fp, int mode, loff_t offset, loff_t len)
 #ifdef __linux__
 	return (fallocate(fp->f_fd, mode, offset, len));
 #else
+	(void) fp, (void) mode, (void) offset, (void) len;
 	return (EOPNOTSUPP);
 #endif
 }
@@ -1353,8 +1382,8 @@ zfs_file_unlink(const char *path)
 zfs_file_t *
 zfs_file_get(int fd)
 {
+	(void) fd;
 	abort();
-
 	return (NULL);
 }
 /*
@@ -1368,9 +1397,11 @@ void
 zfs_file_put(zfs_file_t *fp)
 {
 	abort();
+	(void) fp;
 }
 
 void
 zfsvfs_update_fromname(const char *oldname, const char *newname)
 {
+	(void) oldname, (void) newname;
 }
diff --git a/sys/contrib/openzfs/lib/libzpool/taskq.c b/sys/contrib/openzfs/lib/libzpool/taskq.c
index 456080f7f247..8a61130911c1 100644
--- a/sys/contrib/openzfs/lib/libzpool/taskq.c
+++ b/sys/contrib/openzfs/lib/libzpool/taskq.c
@@ -134,9 +134,10 @@ taskq_dispatch(taskq_t *tq, task_func_t func, void *arg, uint_t tqflags)
 }
 
 taskqid_t
-taskq_dispatch_delay(taskq_t *tq,  task_func_t func, void *arg, uint_t tqflags,
+taskq_dispatch_delay(taskq_t *tq, task_func_t func, void *arg, uint_t tqflags,
     clock_t expire_time)
 {
+	(void) tq, (void) func, (void) arg, (void) tqflags, (void) expire_time;
 	return (0);
 }
 
@@ -199,12 +200,14 @@ taskq_wait(taskq_t *tq)
 void
 taskq_wait_id(taskq_t *tq, taskqid_t id)
 {
+	(void) id;
 	taskq_wait(tq);
 }
 
 void
 taskq_wait_outstanding(taskq_t *tq, taskqid_t id)
 {
+	(void) id;
 	taskq_wait(tq);
 }
 
@@ -247,11 +250,11 @@ taskq_thread(void *arg)
 	thread_exit();
 }
 
-/*ARGSUSED*/
 taskq_t *
 taskq_create(const char *name, int nthreads, pri_t pri,
     int minalloc, int maxalloc, uint_t flags)
 {
+	(void) pri;
 	taskq_t *tq = kmem_zalloc(sizeof (taskq_t), KM_SLEEP);
 	int t;
 
@@ -356,6 +359,7 @@ taskq_of_curthread(void)
 int
 taskq_cancel_id(taskq_t *tq, taskqid_t id)
 {
+	(void) tq, (void) id;
 	return (ENOENT);
 }
 
diff --git a/sys/contrib/openzfs/lib/libzpool/util.c b/sys/contrib/openzfs/lib/libzpool/util.c
index a2bdfec1d173..b9ee52a61fc4 100644
--- a/sys/contrib/openzfs/lib/libzpool/util.c
+++ b/sys/contrib/openzfs/lib/libzpool/util.c
@@ -242,6 +242,7 @@ set_global_var(char const *arg)
 static nvlist_t *
 refresh_config(void *unused, nvlist_t *tryconfig)
 {
+	(void) unused;
 	return (spa_tryimport(tryconfig));
 }
 
@@ -254,6 +255,7 @@ refresh_config(void *unused, nvlist_t *tryconfig)
 static int
 pool_active(void *unused, const char *name, uint64_t guid, boolean_t *isactive)
 {
+	(void) unused, (void) guid;
 	zfs_iocparm_t zp;
 	zfs_cmd_t *zc = NULL;
 	zfs_cmd_legacy_t *zcl = NULL;
@@ -322,6 +324,7 @@ static int
 pool_active(void *unused, const char *name, uint64_t guid,
     boolean_t *isactive)
 {
+	(void) unused, (void) guid;
 	int fd = open(ZFS_DEV, O_RDWR | O_CLOEXEC);
 	if (fd < 0)
 		return (-1);
diff --git a/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_device_path_os.c b/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_device_path_os.c
index 71c936005242..ac4748ec7ac8 100644
--- a/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_device_path_os.c
+++ b/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_device_path_os.c
@@ -124,9 +124,9 @@ zpool_label_disk_wait(const char *path, int timeout_ms)
 	return (ENODEV);
 }
 
-/* ARGSUSED */
 boolean_t
 is_mpath_whole_disk(const char *path)
 {
+	(void) path;
 	return (B_FALSE);
 }
diff --git a/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_import_os.c b/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_import_os.c
index 3da661f4c557..da9a7ded936a 100644
--- a/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_import_os.c
+++ b/sys/contrib/openzfs/lib/libzutil/os/freebsd/zutil_import_os.c
@@ -243,12 +243,14 @@ zpool_find_import_blkid(libpc_handle_t *hdl, pthread_mutex_t *lock,
 }
 
 int
-zfs_dev_flush(int fd __unused)
+zfs_dev_flush(int fd)
 {
+	(void) fd;
 	return (0);
 }
 
 void
 update_vdevs_config_dev_sysfs_path(nvlist_t *config)
 {
+	(void) config;
 }
diff --git a/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_device_path_os.c b/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_device_path_os.c
index 13f8bd031612..17247233bcf2 100644
--- a/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_device_path_os.c
+++ b/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_device_path_os.c
@@ -668,10 +668,10 @@ is_mpath_whole_disk(const char *path)
 
 #else /* HAVE_LIBUDEV */
 
-/* ARGSUSED */
 boolean_t
 is_mpath_whole_disk(const char *path)
 {
+	(void) path;
 	return (B_FALSE);
 }
 
diff --git a/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_import_os.c b/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_import_os.c
index ab692401d88e..60d3369c9c45 100644
--- a/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_import_os.c
+++ b/sys/contrib/openzfs/lib/libzutil/os/linux/zutil_import_os.c
@@ -560,17 +560,17 @@ udev_device_is_ready(struct udev_device *dev)
 
 #else
 
-/* ARGSUSED */
 int
 zfs_device_get_devid(struct udev_device *dev, char *bufptr, size_t buflen)
 {
+	(void) dev, (void) bufptr, (void) buflen;
 	return (ENODATA);
 }
 
-/* ARGSUSED */
 int
 zfs_device_get_physical(struct udev_device *dev, char *bufptr, size_t buflen)
 {
+	(void) dev, (void) bufptr, (void) buflen;
 	return (ENODATA);
 }
 
@@ -788,6 +788,8 @@ update_vdev_config_dev_sysfs_path(nvlist_t *nv, char *path)
 static int
 sysfs_path_pool_vdev_iter_f(void *hdl_data, nvlist_t *nv, void *data)
 {
+	(void) hdl_data, (void) data;
+
 	char *path = NULL;
 	if (nvlist_lookup_string(nv, ZPOOL_CONFIG_PATH, &path) != 0)
 		return (1);
diff --git a/sys/contrib/openzfs/lib/libzutil/zutil_import.c b/sys/contrib/openzfs/lib/libzutil/zutil_import.c
index 4d956fdd8056..8876e7a7aa10 100644
--- a/sys/contrib/openzfs/lib/libzutil/zutil_import.c
+++ b/sys/contrib/openzfs/lib/libzutil/zutil_import.c
@@ -1393,6 +1393,7 @@ static nvlist_t *
 zpool_find_import_impl(libpc_handle_t *hdl, importargs_t *iarg,
     pthread_mutex_t *lock, avl_tree_t *cache)
 {
+	(void) lock;
 	nvlist_t *ret = NULL;
 	pool_list_t pools = { 0 };
 	pool_entry_t *pe, *penext;
diff --git a/sys/contrib/openzfs/man/man4/zfs.4 b/sys/contrib/openzfs/man/man4/zfs.4
index ae10b2a37db8..b2e850f840a1 100644
--- a/sys/contrib/openzfs/man/man4/zfs.4
+++ b/sys/contrib/openzfs/man/man4/zfs.4
@@ -110,7 +110,7 @@ A value of
 disables this feature.
 .
 .It Sy l2arc_exclude_special Ns = Ns Sy 0 Ns | Ns 1 Pq int
-Controls whether buffers present on special vdevs are eligibile for caching
+Controls whether buffers present on special vdevs are eligible for caching
 into L2ARC.
 If set to 1, exclude dbufs on special vdevs from being cached to L2ARC.
 .
@@ -348,7 +348,7 @@ When a vdev is added, target this number of metaslabs per top-level vdev.
 Default limit for metaslab size.
 .
 .It Sy zfs_vdev_max_auto_ashift Ns = Ns Sy ASHIFT_MAX Po 16 Pc Pq ulong
-Maximum ashift used when optimizing for logical -> physical sector size on new
+Maximum ashift used when optimizing for logical \[->] physical sector size on new
 top-level vdevs.
 .
 .It Sy zfs_vdev_min_auto_ashift Ns = Ns Sy ASHIFT_MIN Po 9 Pc Pq ulong
@@ -498,7 +498,7 @@ linear in kernel memory.
 Disabling can improve performance in some code paths
 at the expense of fragmented kernel memory.
 .
-.It Sy zfs_abd_scatter_max_order Ns = Ns Sy MAX_ORDER-1 Pq uint
+.It Sy zfs_abd_scatter_max_order Ns = Ns Sy MAX_ORDER\-1 Pq uint
 Maximum number of consecutive memory pages allocated in a single block for
 scatter/gather lists.
 .Pp
@@ -595,7 +595,9 @@ Under Linux, half of system memory will be used as the limit.
 Under
 .Fx ,
 the larger of
-.Sy all_system_memory - 1GB No and Sy 5/8 * all_system_memory
+.Sy all_system_memory No \- Sy 1GB
+and
+.Sy 5/8 No \(mu Sy all_system_memory
 will be used as the limit.
 This value must be at least
 .Sy 67108864 Ns B Pq 64MB .
@@ -666,7 +668,9 @@ to evict the required number of metadata buffers.
 Min size of ARC in bytes.
 .No If set to Sy 0 , arc_c_min
 will default to consuming the larger of
-.Sy 32MB No or Sy all_system_memory/32 .
+.Sy 32MB
+and
+.Sy all_system_memory No / Sy 32 .
 .
 .It Sy zfs_arc_min_prefetch_ms Ns = Ns Sy 0 Ns ms Ns Po Ns  Ns 1s Pc Pq int
 Minimum time prefetched blocks are locked in the ARC.
@@ -676,6 +680,13 @@ Minimum time "prescient prefetched" blocks are locked in the ARC.
 These blocks are meant to be prefetched fairly aggressively ahead of
 the code that may use them.
 .
+.It Sy zfs_arc_prune_task_threads Ns = Ns Sy 1 Pq int
+Number of arc_prune threads.
+.Fx
+does not need more than one.
+Linux may theoretically use one per mount point up to number of CPUs,
+but that was not proven to be useful.
+.
 .It Sy zfs_max_missing_tvds Ns = Ns Sy 0 Pq int
 Number of missing top-level vdevs which will be allowed during
 pool import (only in read-only mode).
@@ -719,10 +730,10 @@ ARC target size
 .Pq Sy arc_c
 by thresholds determined by this parameter.
 Exceeding by
-.Sy ( arc_c >> zfs_arc_overflow_shift ) * 0.5
+.Sy ( arc_c No >> Sy zfs_arc_overflow_shift ) No / Sy 2
 starts ARC reclamation process.
 If that appears insufficient, exceeding by
-.Sy ( arc_c >> zfs_arc_overflow_shift ) * 1.5
+.Sy ( arc_c No >> Sy zfs_arc_overflow_shift ) No \(mu Sy 1.5
 blocks new buffer allocation until the reclaim thread catches up.
 Started reclamation process continues till ARC size returns below the
 target size.
@@ -931,7 +942,7 @@ by the maximum number of operations per second.
 This will smoothly handle between ten times and a tenth of this number.
 .No See Sx ZFS TRANSACTION DELAY .
 .Pp
-.Sy zfs_delay_scale * zfs_dirty_data_max Em must be smaller than Sy 2^64 .
+.Sy zfs_delay_scale No \(mu Sy zfs_dirty_data_max Em must No be smaller than Sy 2^64 .
 .
 .It Sy zfs_disable_ivset_guid_check Ns = Ns Sy 0 Ns | Ns 1 Pq int
 Disables requirement for IVset GUIDs to be present and match when doing a raw
@@ -1134,11 +1145,6 @@ Maximum number of blocks freed in a single TXG.
 .It Sy zfs_max_async_dedup_frees Ns = Ns Sy 100000 Po 10^5 Pc Pq ulong
 Maximum number of dedup blocks freed in a single TXG.
 .
-.It Sy zfs_override_estimate_recordsize Ns = Ns Sy 0 Pq ulong
-If nonzer, override record size calculation for
-.Nm zfs Cm send
-estimates.
-.
 .It Sy zfs_vdev_async_read_max_active Ns = Ns Sy 3 Pq int
 Maximum asynchronous read I/O operations active to each device.
 .No See Sx ZFS I/O SCHEDULER .
@@ -1249,7 +1255,7 @@ For non-interactive I/O (scrub, resilver, removal, initialize and rebuild),
 the number of concurrently-active I/O operations is limited to
 .Sy zfs_*_min_active ,
 unless the vdev is "idle".
-When there are no interactive I/O operatinons active (synchronous or otherwise),
+When there are no interactive I/O operations active (synchronous or otherwise),
 and
 .Sy zfs_vdev_nia_delay
 operations have completed since the last interactive operation,
@@ -1415,7 +1421,7 @@ This option is used by the test suite to track race conditions.
 .
 .It Sy zfs_livelist_condense_sync_pause Ns = Ns Sy 0 Ns | Ns 1 Pq int
 When set, the livelist condense process pauses indefinitely before
-executing the synctask -
+executing the synctask \(em
 .Fn spa_livelist_condense_sync .
 This option is used by the test suite to trigger race conditions.
 .
@@ -1524,7 +1530,7 @@ This is one of the factors used to determine the
 length of the activity check during import.
 .Pp
 The multihost write period is
-.Sy zfs_multihost_interval / leaf-vdevs .
+.Sy zfs_multihost_interval No / Sy leaf-vdevs .
 On average a multihost write will be issued for each leaf vdev
 every
 .Sy zfs_multihost_interval
@@ -1541,7 +1547,7 @@ the risk of failing to detect an active pool.
 The total activity check time is never allowed to drop below one second.
 .Pp
 On import the activity check waits a minimum amount of time determined by
-.Sy zfs_multihost_interval * zfs_multihost_import_intervals ,
+.Sy zfs_multihost_interval No \(mu Sy zfs_multihost_import_intervals ,
 or the same product computed on the host which last had the pool imported,
 whichever is greater.
 The activity check time may be further extended if the value of MMP
@@ -1566,7 +1572,7 @@ its configuration may take action such as suspending the pool or offlining a
 device.
 .Pp
 Otherwise, the pool will be suspended if
-.Sy zfs_multihost_fail_intervals * zfs_multihost_interval
+.Sy zfs_multihost_fail_intervals No \(mu Sy zfs_multihost_interval
 milliseconds pass without a successful MMP write.
 This guarantees the activity test will see MMP writes if the pool is imported.
 .Sy 1 No is equivalent to Sy 2 ;
@@ -1798,7 +1804,7 @@ remove the spill block from an existing object.
 Including unmodified copies of the spill blocks creates a backwards-compatible
 stream which will recreate a spill block if it was incorrectly removed.
 .
-.It Sy zfs_send_no_prefetch_queue_ff Ns = Ns Sy 20 Ns ^-1 Pq int
+.It Sy zfs_send_no_prefetch_queue_ff Ns = Ns Sy 20 Ns ^\-1 Pq int
 The fill fraction of the
 .Nm zfs Cm send
 internal queues.
@@ -1809,7 +1815,7 @@ The maximum number of bytes allowed in
 .Nm zfs Cm send Ns 's
 internal queues.
 .
-.It Sy zfs_send_queue_ff Ns = Ns Sy 20 Ns ^-1 Pq int
+.It Sy zfs_send_queue_ff Ns = Ns Sy 20 Ns ^\-1 Pq int
 The fill fraction of the
 .Nm zfs Cm send
 prefetch queue.
@@ -1820,7 +1826,7 @@ The maximum number of bytes allowed that will be prefetched by
 .Nm zfs Cm send .
 This value must be at least twice the maximum block size in use.
 .
-.It Sy zfs_recv_queue_ff Ns = Ns Sy 20 Ns ^-1 Pq int
+.It Sy zfs_recv_queue_ff Ns = Ns Sy 20 Ns ^\-1 Pq int
 The fill fraction of the
 .Nm zfs Cm receive
 queue.
@@ -2092,7 +2098,7 @@ Limit SLOG write size per commit executed with synchronous priority.
 Any writes above that will be executed with lower (asynchronous) priority
 to limit potential SLOG device abuse by single active ZIL writer.
 .
-.It Sy zfs_embedded_slog_min_ms Ns = Ns Sy 64  Pq int
+.It Sy zfs_embedded_slog_min_ms Ns = Ns Sy 64 Pq int
 Usually, one metaslab from each normal-class vdev is dedicated for use by
 the ZIL to log synchronous writes.
 However, if there are fewer than
@@ -2312,7 +2318,7 @@ This credits the transaction for "time already served",
 e.g. reading indirect blocks.
 .Pp
 The minimum time for a transaction to take is calculated as
-.Dl min_time = min( Ns Sy zfs_delay_scale No * (dirty - min) / (max - dirty), 100ms)
+.D1 min_time = min( Ns Sy zfs_delay_scale No \(mu Po Sy dirty No \- Sy min Pc / Po Sy max No \- Sy dirty Pc , 100ms)
 .Pp
 The delay has two degrees of freedom that can be adjusted via tunables.
 The percentage of dirty data at which we start to delay is defined by
diff --git a/sys/contrib/openzfs/man/man7/vdevprops.7 b/sys/contrib/openzfs/man/man7/vdevprops.7
index ec7b52955e75..ab6c77064194 100644
--- a/sys/contrib/openzfs/man/man7/vdevprops.7
+++ b/sys/contrib/openzfs/man/man7/vdevprops.7
@@ -68,7 +68,7 @@ Percentage of vdev space used
 .It Sy state
 state of this vdev such as online, faulted, or offline
 .It Sy guid
-globaly unique id of this vdev
+globally unique id of this vdev
 .It Sy asize
 The allocable size of this vdev
 .It Sy psize
diff --git a/sys/contrib/openzfs/man/man7/zfsprops.7 b/sys/contrib/openzfs/man/man7/zfsprops.7
index 55bcde3dca41..c6aa8daa964f 100644
--- a/sys/contrib/openzfs/man/man7/zfsprops.7
+++ b/sys/contrib/openzfs/man/man7/zfsprops.7
@@ -905,7 +905,7 @@ ratio; for example, 8kB blocks on disks with 4kB disk sectors must compress to 1
 or less of their original size.
 .It Xo
 .Sy context Ns = Ns Sy none Ns | Ns
-.Ar SELinux-User : Ns Ar SElinux-Role : Ns Ar Selinux-Type : Ns Ar Sensitivity-Level
+.Ar SELinux-User : Ns Ar SELinux-Role : Ns Ar SELinux-Type : Ns Ar Sensitivity-Level
 .Xc
 This flag sets the SELinux context for all files in the file system under
 a mount point for that file system.
@@ -914,7 +914,7 @@ See
 for more information.
 .It Xo
 .Sy fscontext Ns = Ns Sy none Ns | Ns
-.Ar SELinux-User : Ns Ar SElinux-Role : Ns Ar Selinux-Type : Ns Ar Sensitivity-Level
+.Ar SELinux-User : Ns Ar SELinux-Role : Ns Ar SELinux-Type : Ns Ar Sensitivity-Level
 .Xc
 This flag sets the SELinux context for the file system file system being
 mounted.
@@ -923,7 +923,7 @@ See
 for more information.
 .It Xo
 .Sy defcontext Ns = Ns Sy none Ns | Ns
-.Ar SELinux-User : Ns Ar SElinux-Role : Ns Ar Selinux-Type : Ns Ar Sensitivity-Level
+.Ar SELinux-User : Ns Ar SELinux-Role : Ns Ar SELinux-Type : Ns Ar Sensitivity-Level
 .Xc
 This flag sets the SELinux default context for unlabeled files.
 See
@@ -931,7 +931,7 @@ See
 for more information.
 .It Xo
 .Sy rootcontext Ns = Ns Sy none Ns | Ns
-.Ar SELinux-User : Ns Ar SElinux-Role : Ns Ar Selinux-Type : Ns Ar Sensitivity-Level
+.Ar SELinux-User : Ns Ar SELinux-Role : Ns Ar SELinux-Type : Ns Ar Sensitivity-Level
 .Xc
 This flag sets the SELinux context for the root inode of the file system.
 See
diff --git a/sys/contrib/openzfs/man/man7/zpoolprops.7 b/sys/contrib/openzfs/man/man7/zpoolprops.7
index 513f02e0314f..543920a1d58e 100644
--- a/sys/contrib/openzfs/man/man7/zpoolprops.7
+++ b/sys/contrib/openzfs/man/man7/zpoolprops.7
@@ -337,7 +337,8 @@ The behavior of such an event is determined as follows:
 .Bl -tag -width "continue"
 .It Sy wait
 Blocks all I/O access until the device connectivity is recovered and the errors
-are cleared.
+are cleared with
+.Nm zpool Cm clear .
 This is the default behavior.
 .It Sy continue
 Returns
diff --git a/sys/contrib/openzfs/man/man8/zdb.8 b/sys/contrib/openzfs/man/man8/zdb.8
index 2b0471cc9ea4..55c575f0db1b 100644
--- a/sys/contrib/openzfs/man/man8/zdb.8
+++ b/sys/contrib/openzfs/man/man8/zdb.8
@@ -23,7 +23,7 @@
 .Nd display ZFS storage pool debugging and consistency information
 .Sh SYNOPSIS
 .Nm
-.Op Fl AbcdDFGhikLMPsvXYy
+.Op Fl AbcdDFGhikLMNPsvXYy
 .Op Fl e Oo Fl V Oc Oo Fl p Ar path Oc Ns 
 .Op Fl I Ar inflight I/Os
 .Oo Fl o Ar var Ns = Ns Ar value Oc Ns 
@@ -109,18 +109,18 @@ that zdb may interpret inconsistent pool data and behave erratically.
 .Sh OPTIONS
 Display options:
 .Bl -tag -width Ds
-.It Fl b
+.It Fl b , -block-stats
 Display statistics regarding the number, size
 .Pq logical, physical and allocated
 and deduplication of blocks.
-.It Fl c
+.It Fl c , -checksum
 Verify the checksum of all metadata blocks while printing block statistics
 .Po see
 .Fl b
 .Pc .
 .Pp
 If specified multiple times, verify the checksums of all blocks.
-.It Fl C
+.It Fl C , -config
 Display information about the configuration.
 If specified with no other options, instead display information about the cache
 file
@@ -133,10 +133,18 @@ cached configuration and the on-disk configuration.
 If specified multiple times with
 .Fl e
 also display the configuration that would be used were the pool to be imported.
-.It Fl d
+.It Fl d , -datasets
 Display information about datasets.
 Specified once, displays basic dataset information: ID, create transaction,
 size, and object count.
+See
+.Fl N
+for determining if
+.Op Ar poolname Ns Op / Ns Ar dataset | objset ID
+is to use the specified
+.Op Ar dataset | objset ID
+as a string (dataset name) or a number (objset ID) when
+datasets have numeric names.
 .Pp
 If specified multiple times provides greater and greater verbosity.
 .Pp
@@ -182,7 +190,7 @@ Dump ZAP objects
 .It Sy -
 Negate the effect of next flag
 .El
-.It Fl D
+.It Fl D , -dedup-stats
 Display deduplication statistics, including the deduplication ratio
 .Pq Sy dedup ,
 compression ratio
@@ -203,23 +211,23 @@ Display the statistics independently for each deduplication table.
 Dump the contents of the deduplication tables describing duplicate blocks.
 .It Fl DDDDD
 Also dump the contents of the deduplication tables describing unique blocks.
-.It Fl E Ar word0 : Ns Ar word1 Ns :: Ns Ar word15
+.It Fl E , -embedded-block-pointer Ns = Ns Ar word0 : Ns Ar word1 Ns :: Ns Ar word15
 Decode and display block from an embedded block pointer specified by the
 .Ar word
 arguments.
-.It Fl h
+.It Fl h , -history
 Display pool history similar to
 .Nm zpool Cm history ,
 but include internal changes, transaction, and dataset information.
-.It Fl i
+.It Fl i , -intent-logs
 Display information about intent log
 .Pq ZIL
 entries relating to each dataset.
 If specified multiple times, display counts of each intent log transaction type.
-.It Fl k
+.It Fl k , -checkpointed-state
 Examine the checkpointed state of the pool.
 Note, the on disk format of the pool is not reverted to the checkpointed state.
-.It Fl l Ar device
+.It Fl l , -label Ns = Ns Ar device
 Read the vdev labels and L2ARC header from the specified device.
 .Nm Fl l
 will return 0 if valid label was found, 1 if error occurred, and 2 if no valid
@@ -249,12 +257,12 @@ If the
 .Fl u
 option is also specified, also display the uberblocks on this device.
 Specify multiple times to increase verbosity.
-.It Fl L
+.It Fl L , -disable-leak-tracking
 Disable leak detection and the loading of space maps.
 By default,
 .Nm
 verifies that all non-free blocks are referenced, which can be very expensive.
-.It Fl m
+.It Fl m , -metaslabs
 Display the offset, spacemap, free space of each metaslab, all the log
 spacemaps and their obsolete entry statistics.
 .It Fl mm
@@ -265,11 +273,24 @@ Display the maximum contiguous free space, the in-core free space histogram, and
 the percentage of free space in each space map.
 .It Fl mmmm
 Display every spacemap record.
-.It Fl M
+.It Fl M , -metaslab-groups
 Display all "normal" vdev metaslab group information - per-vdev metaslab count, fragmentation,
 and free space histogram, as well as overall pool fragmentation and histogram.
 .It Fl MM
 "Special" vdevs are added to -M's normal output.
+.It Fl O , -object-lookups Ns = Ns Ar dataset path
+Also display information about the maximum contiguous free space and the
+percentage of free space in each space map.
+.It Fl MMM
+Display every spacemap record.
+.It Fl N
+Same as
+.Fl d
+but force zdb to interpret the
+.Op Ar dataset | objset ID
+in
+.Op Ar poolname Ns Op / Ns Ar dataset | objset ID
+as a numeric objset ID.
 .It Fl O Ar dataset path
 Look up the specified
 .Ar path
@@ -283,7 +304,7 @@ must be relative to the root of
 This option can be combined with
 .Fl v
 for increasing verbosity.
-.It Fl r Ar dataset path destination
+.It Fl r , -copy-object Ns = Ns Ar dataset path destination
 Copy the specified
 .Ar path
 inside of the
@@ -297,7 +318,7 @@ This option can be combined with
 .Fl v
 for increasing verbosity.
 .It Xo
-.Fl R Ar poolname vdev : Ns Ar offset : Ns Oo Ar lsize Ns / Oc Ns Ar psize Ns Op : Ns Ar flags
+.Fl R , -read-block Ns = Ns Ar poolname vdev : Ns Ar offset : Ns Oo Ar lsize Ns / Oc Ns Ar psize Ns Op : Ns Ar flags
 .Xc
 Read and display a block from the specified device.
 By default the block is displayed as a hex dump, but see the description of the
@@ -336,36 +357,36 @@ Dump raw uninterpreted block data
 .It Sy v
 Verbose output for guessing compression algorithm
 .El
-.It Fl s
+.It Fl s , -io-stats
 Report statistics on
 .Nm zdb
 I/O.
 Display operation counts, bandwidth, and error counts of I/O to the pool from
 .Nm .
-.It Fl S
+.It Fl S , -simulate-dedup
 Simulate the effects of deduplication, constructing a DDT and then display
 that DDT as with
 .Fl DD .
-.It Fl u
+.It Fl u , -uberblock
 Display the current uberblock.
 .El
 .Pp
 Other options:
 .Bl -tag -width Ds
-.It Fl A
+.It Fl A , -ignore-assertions
 Do not abort should any assertion fail.
 .It Fl AA
 Enable panic recovery, certain errors which would otherwise be fatal are
 demoted to warnings.
 .It Fl AAA
 Do not abort if asserts fail and also enable panic recovery.
-.It Fl e Oo Fl p Ar path Oc Ns 
+.It Fl e , -exported Ns = Ns Oo Fl p Ar path Oc Ns 
 Operate on an exported pool, not present in
 .Pa /etc/zfs/zpool.cache .
 The
 .Fl p
 flag specifies the path under which devices are to be searched.
-.It Fl x Ar dumpdir
+.It Fl x , -dump-blocks Ns = Ns Ar dumpdir
 All blocks accessed will be copied to files in the specified directory.
 The blocks will be placed in sparse files whose name is the same as
 that of the file or device read.
@@ -376,30 +397,30 @@ Note that the
 flags are sufficient to access
 .Pq and thus copy
 all metadata on the pool.
-.It Fl F
+.It Fl F , -automatic-rewind
 Attempt to make an unreadable pool readable by trying progressively older
 transactions.
-.It Fl G
+.It Fl G , -dump-debug-msg
 Dump the contents of the zfs_dbgmsg buffer before exiting
 .Nm .
 zfs_dbgmsg is a buffer used by ZFS to dump advanced debug information.
-.It Fl I Ar inflight I/Os
+.It Fl I , -inflight Ns = Ns Ar inflight I/Os
 Limit the number of outstanding checksum I/Os to the specified value.
 The default value is 200.
 This option affects the performance of the
 .Fl c
 option.
-.It Fl o Ar var Ns = Ns Ar value 
+.It Fl o , -option Ns = Ns Ar var Ns = Ns Ar value 
 Set the given global libzpool variable to the provided value.
 The value must be an unsigned 32-bit integer.
 Currently only little-endian systems are supported to avoid accidentally setting
 the high 32 bits of 64-bit variables.
-.It Fl P
+.It Fl P , -parseable
 Print numbers in an unscaled form more amenable to parsing, e.g.\&
 .Sy 1000000
 rather than
 .Sy 1M .
-.It Fl t Ar transaction
+.It Fl t , -txg Ns = Ns Ar transaction
 Specify the highest transaction to use when searching for uberblocks.
 See also the
 .Fl u
@@ -407,28 +428,28 @@ and
 .Fl l
 options for a means to see the available uberblocks and their associated
 transaction numbers.
-.It Fl U Ar cachefile
+.It Fl U , -cachefile Ns = Ns Ar cachefile
 Use a cache file other than
 .Pa /etc/zfs/zpool.cache .
-.It Fl v
+.It Fl v , -verbose
 Enable verbosity.
 Specify multiple times for increased verbosity.
-.It Fl V
+.It Fl V , -verbatim
 Attempt verbatim import.
 This mimics the behavior of the kernel when loading a pool from a cachefile.
 Only usable with
 .Fl e .
-.It Fl X
+.It Fl X , -extreme-rewind
 Attempt
 .Qq extreme
 transaction rewind, that is attempt the same recovery as
 .Fl F
 but read transactions otherwise deemed too old.
-.It Fl Y
+.It Fl Y , -all-reconstruction
 Attempt all possible combinations when reconstructing indirect split blocks.
 This flag disables the individual I/O deadman timer in order to allow as
 much time as required for the attempted reconstruction.
-.It Fl y
+.It Fl y , -livelist
 Perform validation for livelists that are being deleted.
 Scans through the livelist and metaslabs, checking for duplicate entries
 and compares the two, checking for potential double frees.
diff --git a/sys/contrib/openzfs/man/man8/zfs-load-key.8 b/sys/contrib/openzfs/man/man8/zfs-load-key.8
index ed89b65d7159..b12a79e0150a 100644
--- a/sys/contrib/openzfs/man/man8/zfs-load-key.8
+++ b/sys/contrib/openzfs/man/man8/zfs-load-key.8
@@ -200,7 +200,7 @@ if supported by your hardware, otherwise
 .Bl -tag -width "-r"
 .It Fl l
 Ensures the key is loaded before attempting to change the key.
-This is effectively equivalent to runnin
+This is effectively equivalent to running
 .Nm zfs Cm load-key Ar filesystem ; Nm zfs Cm change-key Ar filesystem
 .It Fl o Ar property Ns = Ns Ar value
 Allows the user to set encryption key properties
diff --git a/sys/contrib/openzfs/man/man8/zfs-share.8 b/sys/contrib/openzfs/man/man8/zfs-share.8
index e30d538814ca..89121ead0958 100644
--- a/sys/contrib/openzfs/man/man8/zfs-share.8
+++ b/sys/contrib/openzfs/man/man8/zfs-share.8
@@ -29,7 +29,7 @@
 .\" Copyright 2018 Nexenta Systems, Inc.
 .\" Copyright 2019 Joyent, Inc.
 .\"
-.Dd June 30, 2019
+.Dd May 17, 2021
 .Dt ZFS-SHARE 8
 .Os
 .
@@ -39,6 +39,7 @@
 .Sh SYNOPSIS
 .Nm zfs
 .Cm share
+.Op Fl l
 .Fl a Ns | Ns Ar filesystem
 .Nm zfs
 .Cm unshare
@@ -49,10 +50,19 @@
 .It Xo
 .Nm zfs
 .Cm share
+.Op Fl l
 .Fl a Ns | Ns Ar filesystem
 .Xc
 Shares available ZFS file systems.
 .Bl -tag -width "-a"
+.It Fl l
+Load keys for encrypted filesystems as they are being mounted.
+This is equivalent to executing
+.Nm zfs Cm load-key
+on each encryption root before mounting it.
+Note that if a filesystem has
+.Sy keylocation Ns = Ns Sy prompt ,
+this will cause the terminal to interactively block after asking for the key.
 .It Fl a
 Share all available ZFS file systems.
 Invoked automatically as part of the boot process.
diff --git a/sys/contrib/openzfs/man/man8/zgenhostid.8 b/sys/contrib/openzfs/man/man8/zgenhostid.8
index 0dcebef73c31..e157578cf0bb 100644
--- a/sys/contrib/openzfs/man/man8/zgenhostid.8
+++ b/sys/contrib/openzfs/man/man8/zgenhostid.8
@@ -80,7 +80,7 @@ be an 8-digit-long hexadecimal number, optionally prefixed by
 .Dl # Nm Qq $ Ns Pq Nm hostid
 .It Record a custom hostid Po Ar 0xdeadbeef Pc in Pa /etc/hostid
 .Dl # Nm Ar deadbeef
-.It Record a custom hostid Po Ar 0x01234567 Pc in Pa /tmp/hostid No and ovewrite the file if it exists
+.It Record a custom hostid Po Ar 0x01234567 Pc in Pa /tmp/hostid No and overwrite the file if it exists
 .Dl # Nm Fl f o Ar /tmp/hostid 0x01234567
 .El
 .
diff --git a/sys/contrib/openzfs/man/man8/zpool-attach.8 b/sys/contrib/openzfs/man/man8/zpool-attach.8
index 19d8f6ac07ac..9dfa35a107d3 100644
--- a/sys/contrib/openzfs/man/man8/zpool-attach.8
+++ b/sys/contrib/openzfs/man/man8/zpool-attach.8
@@ -79,7 +79,7 @@ The only property supported at the moment is
 The
 .Ar new_device
 is reconstructed sequentially to restore redundancy as quickly as possible.
-Checksums are not verfied during sequential reconstruction so a scrub is
+Checksums are not verified during sequential reconstruction so a scrub is
 started when the resilver completes.
 Sequential reconstruction is not supported for raidz configurations.
 .It Fl w
diff --git a/sys/contrib/openzfs/man/man8/zpool-clear.8 b/sys/contrib/openzfs/man/man8/zpool-clear.8
index 6e41566ca6da..0b256b28bd21 100644
--- a/sys/contrib/openzfs/man/man8/zpool-clear.8
+++ b/sys/contrib/openzfs/man/man8/zpool-clear.8
@@ -44,9 +44,12 @@ Clears device errors in a pool.
 If no arguments are specified, all device errors within the pool are cleared.
 If one or more devices is specified, only those errors associated with the
 specified device or devices are cleared.
-If
+.Pp
+If the pool was suspended it will be brought back online provided the
+devices can be accessed.
+Pools with
 .Sy multihost
-is enabled and the pool has been suspended, this will not resume I/O.
+enabled which have been suspended cannot be resumed.
 While the pool was suspended, it may have been imported on
 another host, and resuming I/O could result in pool damage.
 .
diff --git a/sys/contrib/openzfs/man/man8/zpool-events.8 b/sys/contrib/openzfs/man/man8/zpool-events.8
index ab1d6ea56213..55f7babae2bd 100644
--- a/sys/contrib/openzfs/man/man8/zpool-events.8
+++ b/sys/contrib/openzfs/man/man8/zpool-events.8
@@ -68,7 +68,7 @@ Print the entire payload for each event.
 .El
 .
 .Sh EVENTS
-Theese are the different event subclasses.
+These are the different event subclasses.
 The full event name would be
 .Sy ereport.fs.zfs.\& Ns Em SUBCLASS ,
 but only the last part is listed here.
@@ -136,7 +136,7 @@ Issued when the ashift alignment requirement has increased.
 .It Sy vdev.remove
 Issued when a vdev is detached from a mirror (or a spare detached from a
 vdev where it have been used to replace a failed drive - only works if
-the original drive have been readded).
+the original drive have been re-added).
 .It Sy vdev.clear
 Issued when clearing device errors in a pool.
 Such as running
diff --git a/sys/contrib/openzfs/man/man8/zpool-replace.8 b/sys/contrib/openzfs/man/man8/zpool-replace.8
index 2b2875ed4292..cc61fa3ea37e 100644
--- a/sys/contrib/openzfs/man/man8/zpool-replace.8
+++ b/sys/contrib/openzfs/man/man8/zpool-replace.8
@@ -85,7 +85,7 @@ The only property supported at the moment is
 The
 .Ar new-device
 is reconstructed sequentially to restore redundancy as quickly as possible.
-Checksums are not verfied during sequential reconstruction so a scrub is
+Checksums are not verified during sequential reconstruction so a scrub is
 started when the resilver completes.
 Sequential reconstruction is not supported for raidz configurations.
 .It Fl w
diff --git a/sys/contrib/openzfs/man/man8/zpool-scrub.8 b/sys/contrib/openzfs/man/man8/zpool-scrub.8
index 768f71539290..69ae825b6158 100644
--- a/sys/contrib/openzfs/man/man8/zpool-scrub.8
+++ b/sys/contrib/openzfs/man/man8/zpool-scrub.8
@@ -116,8 +116,29 @@ scanned at 100M/s, and 68.4M of that file data has been
 scrubbed sequentially at 10.0M/s.
 .El
 .El
+.Sh PERIODIC SCRUB
+On machines using systemd, scrub timers can be enabled on per-pool basis.
+.Nm weekly
+and
+.Nm monthly
+timer units are provided.
+.Bl -tag -width Ds
+.It Xo
+.Xc
+.Nm systemctl
+.Cm enable
+.Cm zfs-scrub-\fIweekly\fB@\fIrpool\fB.timer
+.Cm --now
+.It Xo
+.Xc
+.Nm systemctl
+.Cm enable
+.Cm zfs-scrub-\fImonthly\fB@\fIotherpool\fB.timer
+.Cm --now
+.El
 .
 .Sh SEE ALSO
+.Xr systemd.timer 5 ,
 .Xr zpool-iostat 8 ,
 .Xr zpool-resilver 8 ,
 .Xr zpool-status 8
diff --git a/sys/contrib/openzfs/module/Makefile.bsd b/sys/contrib/openzfs/module/Makefile.bsd
index 315be2808605..5172394e6ac8 100644
--- a/sys/contrib/openzfs/module/Makefile.bsd
+++ b/sys/contrib/openzfs/module/Makefile.bsd
@@ -228,6 +228,7 @@ SRCS+=	abd.c \
 	gzip.c \
 	lzjb.c \
 	lz4.c \
+	lz4_zfs.c \
 	metaslab.c \
 	mmp.c \
 	multilist.c \
@@ -352,7 +353,7 @@ CFLAGS.dsl_deadlist.c= -Wno-cast-qual
 CFLAGS.dsl_prop.c= -Wno-cast-qual
 CFLAGS.edonr.c=-Wno-cast-qual
 CFLAGS.fm.c= -Wno-cast-qual
-CFLAGS.lz4.c= -Wno-cast-qual
+CFLAGS.lz4_zfs.c= -Wno-cast-qual
 CFLAGS.spa.c= -Wno-cast-qual
 CFLAGS.spa_misc.c= -Wno-cast-qual
 CFLAGS.sysctl_os.c= -include ../zfs_config.h
diff --git a/sys/contrib/openzfs/module/Makefile.in b/sys/contrib/openzfs/module/Makefile.in
index b15ab9109725..0dd9df501782 100644
--- a/sys/contrib/openzfs/module/Makefile.in
+++ b/sys/contrib/openzfs/module/Makefile.in
@@ -51,10 +51,8 @@ endif
 FMAKE = env -u MAKEFLAGS make $(FMAKEFLAGS)
 
 modules-Linux:
-	list='$(SUBDIR_TARGETS)'; for targetdir in $$list; do \
-		$(MAKE) -C $$targetdir; \
-	done
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` @KERNEL_MAKE@ CONFIG_ZFS=m modules
+	list='$(SUBDIR_TARGETS)'; for td in $$list; do $(MAKE) -C $$td; done
+	$(MAKE) -C @LINUX_OBJ@ M="$$PWD" @KERNEL_MAKE@ CONFIG_ZFS=m modules
 
 modules-FreeBSD:
 	+$(FMAKE)
@@ -67,7 +65,7 @@ modules: modules-@ac_system@
 clean-Linux:
 	@# Only cleanup the kernel build directories when CONFIG_KERNEL
 	@# is defined.  This indicates that kernel modules should be built.
-@CONFIG_KERNEL_TRUE@	$(MAKE) -C @LINUX_OBJ@ M=`pwd` @KERNEL_MAKE@ clean
+@CONFIG_KERNEL_TRUE@	$(MAKE) -C @LINUX_OBJ@ M="$$PWD" @KERNEL_MAKE@ clean
 
 	if [ -f @LINUX_SYMBOLS@ ]; then $(RM) @LINUX_SYMBOLS@; fi
 	if [ -f Module.markers ]; then $(RM) Module.markers; fi
@@ -81,7 +79,7 @@ clean: clean-@ac_system@
 
 modules_install-Linux:
 	@# Install the kernel modules
-	$(MAKE) -C @LINUX_OBJ@ M=`pwd` modules_install \
+	$(MAKE) -C @LINUX_OBJ@ M="$$PWD" modules_install \
 		INSTALL_MOD_PATH=$(INSTALL_MOD_PATH) \
 		INSTALL_MOD_DIR=$(INSTALL_MOD_DIR) \
 		KERNELRELEASE=@LINUX_VERSION@
@@ -90,7 +88,15 @@ modules_install-Linux:
 	if [ -n "$(DESTDIR)" ]; then \
 		find $$kmoddir -name 'modules.*' | xargs $(RM); \
 	fi
+	@# Debian ships tiny fake System.map files that are
+	@# syntactically valid but just say
+	@# "if you want system.map go install this package"
+	@# Naturally, depmod is less than amused by this.
+	@# So if we find it missing or with one of these present,
+	@# we check for the alternate path for the System.map
 	sysmap=$(INSTALL_MOD_PATH)/boot/System.map-@LINUX_VERSION@; \
+	{ [ -f "$$sysmap" ] && [ $$(wc -l < "$$sysmap") -ge 100 ]; } || \
+		sysmap=$(INSTALL_MOD_PATH)/usr/lib/debug/boot/System.map-@LINUX_VERSION@; \
 	if [ -f $$sysmap ]; then \
 		depmod -ae -F $$sysmap @LINUX_VERSION@; \
 	fi
diff --git a/sys/contrib/openzfs/module/avl/avl.c b/sys/contrib/openzfs/module/avl/avl.c
index 3d36d4c87e0b..c86dc9835a54 100644
--- a/sys/contrib/openzfs/module/avl/avl.c
+++ b/sys/contrib/openzfs/module/avl/avl.c
@@ -119,7 +119,7 @@
  * additional memory reference. Since the translation arrays are both very
  * small the data should remain efficiently in cache.
  */
-static const int  avl_child2balance[2]	= {-1, 1};
+static const int  avl_child2balance[]	= {-1, 1};
 static const int  avl_balance2child[]	= {0, 0, 1};
 
 
@@ -908,7 +908,6 @@ avl_create(avl_tree_t *tree, int (*compar) (const void *, const void *),
 /*
  * Delete a tree.
  */
-/* ARGSUSED */
 void
 avl_destroy(avl_tree_t *tree)
 {
diff --git a/sys/contrib/openzfs/module/icp/Makefile.in b/sys/contrib/openzfs/module/icp/Makefile.in
index 858c5a610c26..f51fcac6d9e1 100644
--- a/sys/contrib/openzfs/module/icp/Makefile.in
+++ b/sys/contrib/openzfs/module/icp/Makefile.in
@@ -26,12 +26,9 @@ $(MODULE)-objs += core/kcf_mech_tabs.o
 $(MODULE)-objs += core/kcf_prov_lib.o
 $(MODULE)-objs += spi/kcf_spi.o
 $(MODULE)-objs += io/aes.o
-$(MODULE)-objs += io/edonr_mod.o
-$(MODULE)-objs += io/sha1_mod.o
 $(MODULE)-objs += io/sha2_mod.o
 $(MODULE)-objs += io/skein_mod.o
 $(MODULE)-objs += os/modhash.o
-$(MODULE)-objs += os/modconf.o
 $(MODULE)-objs += algs/modes/cbc.o
 $(MODULE)-objs += algs/modes/ccm.o
 $(MODULE)-objs += algs/modes/ctr.o
@@ -43,7 +40,6 @@ $(MODULE)-objs += algs/aes/aes_impl_generic.o
 $(MODULE)-objs += algs/aes/aes_impl.o
 $(MODULE)-objs += algs/aes/aes_modes.o
 $(MODULE)-objs += algs/edonr/edonr.o
-$(MODULE)-objs += algs/sha1/sha1.o
 $(MODULE)-objs += algs/sha2/sha2.o
 $(MODULE)-objs += algs/skein/skein.o
 $(MODULE)-objs += algs/skein/skein_block.o
@@ -55,7 +51,6 @@ $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/aes/aes_aesni.o
 $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/modes/gcm_pclmulqdq.o
 $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/modes/aesni-gcm-x86_64.o
 $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/modes/ghash-x86_64.o
-$(MODULE)-$(CONFIG_X86_64) += asm-x86_64/sha1/sha1-x86_64.o
 $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/sha2/sha256_impl.o
 $(MODULE)-$(CONFIG_X86_64) += asm-x86_64/sha2/sha512_impl.o
 
@@ -72,7 +67,6 @@ OBJECT_FILES_NON_STANDARD_ghash-x86_64.o := y
 # Suppress objtool "unsupported stack pointer realignment" warnings. We are
 # not using a DRAP register while aligning the stack to a 64 byte boundary.
 # See #6950 for the reasoning.
-OBJECT_FILES_NON_STANDARD_sha1-x86_64.o := y
 OBJECT_FILES_NON_STANDARD_sha256_impl.o := y
 OBJECT_FILES_NON_STANDARD_sha512_impl.o := y
 
@@ -86,13 +80,11 @@ ICP_DIRS = \
 	algs/aes \
 	algs/edonr \
 	algs/modes \
-	algs/sha1 \
 	algs/sha2 \
 	algs/skein \
 	asm-x86_64 \
 	asm-x86_64/aes \
 	asm-x86_64/modes \
-	asm-x86_64/sha1 \
 	asm-x86_64/sha2 \
 	asm-i386 \
 	asm-generic
diff --git a/sys/contrib/openzfs/module/icp/algs/aes/aes_impl.c b/sys/contrib/openzfs/module/icp/algs/aes/aes_impl.c
index 037be0db60d7..c238bee2170b 100644
--- a/sys/contrib/openzfs/module/icp/algs/aes/aes_impl.c
+++ b/sys/contrib/openzfs/module/icp/algs/aes/aes_impl.c
@@ -206,7 +206,6 @@ aes_decrypt_block(const void *ks, const uint8_t *ct, uint8_t *pt)
  * size		Size of key schedule allocated, in bytes
  * kmflag	Flag passed to kmem_alloc(9F); ignored in userland.
  */
-/* ARGSUSED */
 void *
 aes_alloc_keysched(size_t *size, int kmflag)
 {
@@ -226,7 +225,7 @@ static aes_impl_ops_t aes_fastest_impl = {
 };
 
 /* All compiled in implementations */
-const aes_impl_ops_t *aes_all_impl[] = {
+static const aes_impl_ops_t *aes_all_impl[] = {
 	&aes_generic_impl,
 #if defined(__x86_64)
 	&aes_x86_64_impl,
diff --git a/sys/contrib/openzfs/module/icp/algs/edonr/edonr.c b/sys/contrib/openzfs/module/icp/algs/edonr/edonr.c
index ee96e692ef00..20418eaa73cf 100644
--- a/sys/contrib/openzfs/module/icp/algs/edonr/edonr.c
+++ b/sys/contrib/openzfs/module/icp/algs/edonr/edonr.c
@@ -29,6 +29,12 @@
  * Portions copyright (c) 2013, Saso Kiselkov, All rights reserved
  */
 
+/*
+ * Unlike sha2 or skein, we won't expose edonr via the Kernel Cryptographic
+ * Framework (KCF), because Edon-R is *NOT* suitable for general-purpose
+ * cryptographic use. Users of Edon-R must interface directly to this module.
+ */
+
 #include <sys/strings.h>
 #include <sys/edonr.h>
 #include <sys/debug.h>
diff --git a/sys/contrib/openzfs/module/icp/algs/edonr/edonr_byteorder.h b/sys/contrib/openzfs/module/icp/algs/edonr/edonr_byteorder.h
index 2b5d48287f26..cd35e5e4c7c9 100644
--- a/sys/contrib/openzfs/module/icp/algs/edonr/edonr_byteorder.h
+++ b/sys/contrib/openzfs/module/icp/algs/edonr/edonr_byteorder.h
@@ -61,7 +61,7 @@
 #endif /* !MACHINE_IS_BIG_ENDIAN && !MACHINE_IS_LITTLE_ENDIAN */
 
 #if !defined(MACHINE_IS_BIG_ENDIAN) && !defined(MACHINE_IS_LITTLE_ENDIAN)
-#error unknown machine byte sex
+#error unknown machine byte order
 #endif
 
 #define	BYTEORDER_INCLUDED
diff --git a/sys/contrib/openzfs/module/icp/algs/modes/cbc.c b/sys/contrib/openzfs/module/icp/algs/modes/cbc.c
index 85864f56dead..bddb5b64ddd3 100644
--- a/sys/contrib/openzfs/module/icp/algs/modes/cbc.c
+++ b/sys/contrib/openzfs/module/icp/algs/modes/cbc.c
@@ -137,7 +137,6 @@ cbc_encrypt_contiguous_blocks(cbc_ctx_t *ctx, char *data, size_t length,
 #define	OTHER(a, ctx) \
 	(((a) == (ctx)->cbc_lastblock) ? (ctx)->cbc_iv : (ctx)->cbc_lastblock)
 
-/* ARGSUSED */
 int
 cbc_decrypt_contiguous_blocks(cbc_ctx_t *ctx, char *data, size_t length,
     crypto_data_t *out, size_t block_size,
@@ -259,7 +258,6 @@ cbc_init_ctx(cbc_ctx_t *cbc_ctx, char *param, size_t param_len,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 void *
 cbc_alloc_ctx(int kmflag)
 {
diff --git a/sys/contrib/openzfs/module/icp/algs/modes/ccm.c b/sys/contrib/openzfs/module/icp/algs/modes/ccm.c
index 5d6507c49db1..a41cbc395fd6 100644
--- a/sys/contrib/openzfs/module/icp/algs/modes/ccm.c
+++ b/sys/contrib/openzfs/module/icp/algs/modes/ccm.c
@@ -190,7 +190,6 @@ calculate_ccm_mac(ccm_ctx_t *ctx, uint8_t *ccm_mac,
 	}
 }
 
-/* ARGSUSED */
 int
 ccm_encrypt_final(ccm_ctx_t *ctx, crypto_data_t *out, size_t block_size,
     int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),
@@ -342,7 +341,6 @@ ccm_decrypt_incomplete_block(ccm_ctx_t *ctx,
  * returned to the caller.  It will be returned when decrypt_final() is
  * called if the MAC matches
  */
-/* ARGSUSED */
 int
 ccm_mode_decrypt_contiguous_blocks(ccm_ctx_t *ctx, char *data, size_t length,
     crypto_data_t *out, size_t block_size,
@@ -350,6 +348,7 @@ ccm_mode_decrypt_contiguous_blocks(ccm_ctx_t *ctx, char *data, size_t length,
     void (*copy_block)(uint8_t *, uint8_t *),
     void (*xor_block)(uint8_t *, uint8_t *))
 {
+	(void) out;
 	size_t remainder = length;
 	size_t need = 0;
 	uint8_t *datap = (uint8_t *)data;
diff --git a/sys/contrib/openzfs/module/icp/algs/modes/ctr.c b/sys/contrib/openzfs/module/icp/algs/modes/ctr.c
index 0188bdd395ff..82295cda877e 100644
--- a/sys/contrib/openzfs/module/icp/algs/modes/ctr.c
+++ b/sys/contrib/openzfs/module/icp/algs/modes/ctr.c
@@ -214,7 +214,6 @@ ctr_init_ctx(ctr_ctx_t *ctr_ctx, ulong_t count, uint8_t *cb,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 void *
 ctr_alloc_ctx(int kmflag)
 {
diff --git a/sys/contrib/openzfs/module/icp/algs/modes/ecb.c b/sys/contrib/openzfs/module/icp/algs/modes/ecb.c
index 025f5825cf04..ffbdb9d57d0a 100644
--- a/sys/contrib/openzfs/module/icp/algs/modes/ecb.c
+++ b/sys/contrib/openzfs/module/icp/algs/modes/ecb.c
@@ -114,7 +114,6 @@ ecb_cipher_contiguous_blocks(ecb_ctx_t *ctx, char *data, size_t length,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 void *
 ecb_alloc_ctx(int kmflag)
 {
diff --git a/sys/contrib/openzfs/module/icp/algs/modes/gcm.c b/sys/contrib/openzfs/module/icp/algs/modes/gcm.c
index 7332834cbe37..d9796cd0ed49 100644
--- a/sys/contrib/openzfs/module/icp/algs/modes/gcm.c
+++ b/sys/contrib/openzfs/module/icp/algs/modes/gcm.c
@@ -199,13 +199,13 @@ gcm_mode_encrypt_contiguous_blocks(gcm_ctx_t *ctx, char *data, size_t length,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 int
 gcm_encrypt_final(gcm_ctx_t *ctx, crypto_data_t *out, size_t block_size,
     int (*encrypt_block)(const void *, const uint8_t *, uint8_t *),
     void (*copy_block)(uint8_t *, uint8_t *),
     void (*xor_block)(uint8_t *, uint8_t *))
 {
+	(void) copy_block;
 #ifdef CAN_USE_GCM_ASM
 	if (ctx->gcm_use_avx == B_TRUE)
 		return (gcm_encrypt_final_avx(ctx, out, block_size));
@@ -324,7 +324,6 @@ gcm_decrypt_incomplete_block(gcm_ctx_t *ctx, size_t block_size, size_t index,
 	}
 }
 
-/* ARGSUSED */
 int
 gcm_mode_decrypt_contiguous_blocks(gcm_ctx_t *ctx, char *data, size_t length,
     crypto_data_t *out, size_t block_size,
@@ -332,6 +331,8 @@ gcm_mode_decrypt_contiguous_blocks(gcm_ctx_t *ctx, char *data, size_t length,
     void (*copy_block)(uint8_t *, uint8_t *),
     void (*xor_block)(uint8_t *, uint8_t *))
 {
+	(void) out, (void) block_size, (void) encrypt_block, (void) copy_block,
+	    (void) xor_block;
 	size_t new_len;
 	uint8_t *new;
 
@@ -778,7 +779,7 @@ static gcm_impl_ops_t gcm_fastest_impl = {
 };
 
 /* All compiled in implementations */
-const gcm_impl_ops_t *gcm_all_impl[] = {
+static const gcm_impl_ops_t *gcm_all_impl[] = {
 	&gcm_generic_impl,
 #if defined(__x86_64) && defined(HAVE_PCLMULQDQ)
 	&gcm_pclmulqdq_impl,
@@ -1045,9 +1046,6 @@ MODULE_PARM_DESC(icp_gcm_impl, "Select gcm implementation.");
 #define	GCM_AVX_MAX_CHUNK_SIZE \
 	(((128*1024)/GCM_AVX_MIN_DECRYPT_BYTES) * GCM_AVX_MIN_DECRYPT_BYTES)
 
-/* Get the chunk size module parameter. */
-#define	GCM_CHUNK_SIZE_READ *(volatile uint32_t *) &gcm_avx_chunk_size
-
 /* Clear the FPU registers since they hold sensitive internal state. */
 #define	clear_fpu_regs() clear_fpu_regs_avx()
 #define	GHASH_AVX(ctx, in, len) \
@@ -1056,6 +1054,9 @@ MODULE_PARM_DESC(icp_gcm_impl, "Select gcm implementation.");
 
 #define	gcm_incr_counter_block(ctx) gcm_incr_counter_block_by(ctx, 1)
 
+/* Get the chunk size module parameter. */
+#define	GCM_CHUNK_SIZE_READ *(volatile uint32_t *) &gcm_avx_chunk_size
+
 /*
  * Module parameter: number of bytes to process at once while owning the FPU.
  * Rounded down to the next GCM_AVX_MIN_DECRYPT_BYTES byte boundary and is
diff --git a/sys/contrib/openzfs/module/icp/algs/sha1/sha1.c b/sys/contrib/openzfs/module/icp/algs/sha1/sha1.c
deleted file mode 100644
index da34222c8fc3..000000000000
--- a/sys/contrib/openzfs/module/icp/algs/sha1/sha1.c
+++ /dev/null
@@ -1,835 +0,0 @@
-/*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-/*
- * The basic framework for this code came from the reference
- * implementation for MD5.  That implementation is Copyright (C)
- * 1991-2, RSA Data Security, Inc. Created 1991. All rights reserved.
- *
- * License to copy and use this software is granted provided that it
- * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
- * Algorithm" in all material mentioning or referencing this software
- * or this function.
- *
- * License is also granted to make and use derivative works provided
- * that such works are identified as "derived from the RSA Data
- * Security, Inc. MD5 Message-Digest Algorithm" in all material
- * mentioning or referencing the derived work.
- *
- * RSA Data Security, Inc. makes no representations concerning either
- * the merchantability of this software or the suitability of this
- * software for any particular purpose. It is provided "as is"
- * without express or implied warranty of any kind.
- *
- * These notices must be retained in any copies of any part of this
- * documentation and/or software.
- *
- * NOTE: Cleaned-up and optimized, version of SHA1, based on the FIPS 180-1
- * standard, available at http://www.itl.nist.gov/fipspubs/fip180-1.htm
- * Not as fast as one would like -- further optimizations are encouraged
- * and appreciated.
- */
-
-#include <sys/zfs_context.h>
-#include <sha1/sha1.h>
-#include <sha1/sha1_consts.h>
-
-#ifdef _LITTLE_ENDIAN
-#include <sys/byteorder.h>
-#define	HAVE_HTONL
-#endif
-
-#define	_RESTRICT_KYWD
-
-static void Encode(uint8_t *, const uint32_t *, size_t);
-
-#if	defined(__sparc)
-
-#define	SHA1_TRANSFORM(ctx, in) \
-	SHA1Transform((ctx)->state[0], (ctx)->state[1], (ctx)->state[2], \
-		(ctx)->state[3], (ctx)->state[4], (ctx), (in))
-
-static void SHA1Transform(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t,
-	SHA1_CTX *, const uint8_t *);
-
-#elif	defined(__amd64)
-
-#define	SHA1_TRANSFORM(ctx, in) sha1_block_data_order((ctx), (in), 1)
-#define	SHA1_TRANSFORM_BLOCKS(ctx, in, num) sha1_block_data_order((ctx), \
-		(in), (num))
-
-void sha1_block_data_order(SHA1_CTX *ctx, const void *inpp, size_t num_blocks);
-
-#else
-
-#define	SHA1_TRANSFORM(ctx, in) SHA1Transform((ctx), (in))
-
-static void SHA1Transform(SHA1_CTX *, const uint8_t *);
-
-#endif
-
-
-static uint8_t PADDING[64] = { 0x80, /* all zeros */ };
-
-/*
- * F, G, and H are the basic SHA1 functions.
- */
-#define	F(b, c, d)	(((b) & (c)) | ((~b) & (d)))
-#define	G(b, c, d)	((b) ^ (c) ^ (d))
-#define	H(b, c, d)	(((b) & (c)) | (((b)|(c)) & (d)))
-
-/*
- * SHA1Init()
- *
- * purpose: initializes the sha1 context and begins and sha1 digest operation
- *   input: SHA1_CTX *	: the context to initializes.
- *  output: void
- */
-
-void
-SHA1Init(SHA1_CTX *ctx)
-{
-	ctx->count[0] = ctx->count[1] = 0;
-
-	/*
-	 * load magic initialization constants. Tell lint
-	 * that these constants are unsigned by using U.
-	 */
-
-	ctx->state[0] = 0x67452301U;
-	ctx->state[1] = 0xefcdab89U;
-	ctx->state[2] = 0x98badcfeU;
-	ctx->state[3] = 0x10325476U;
-	ctx->state[4] = 0xc3d2e1f0U;
-}
-
-void
-SHA1Update(SHA1_CTX *ctx, const void *inptr, size_t input_len)
-{
-	uint32_t i, buf_index, buf_len;
-	const uint8_t *input = inptr;
-#if defined(__amd64)
-	uint32_t	block_count;
-#endif	/* __amd64 */
-
-	/* check for noop */
-	if (input_len == 0)
-		return;
-
-	/* compute number of bytes mod 64 */
-	buf_index = (ctx->count[1] >> 3) & 0x3F;
-
-	/* update number of bits */
-	if ((ctx->count[1] += (input_len << 3)) < (input_len << 3))
-		ctx->count[0]++;
-
-	ctx->count[0] += (input_len >> 29);
-
-	buf_len = 64 - buf_index;
-
-	/* transform as many times as possible */
-	i = 0;
-	if (input_len >= buf_len) {
-
-		/*
-		 * general optimization:
-		 *
-		 * only do initial bcopy() and SHA1Transform() if
-		 * buf_index != 0.  if buf_index == 0, we're just
-		 * wasting our time doing the bcopy() since there
-		 * wasn't any data left over from a previous call to
-		 * SHA1Update().
-		 */
-
-		if (buf_index) {
-			bcopy(input, &ctx->buf_un.buf8[buf_index], buf_len);
-			SHA1_TRANSFORM(ctx, ctx->buf_un.buf8);
-			i = buf_len;
-		}
-
-#if !defined(__amd64)
-		for (; i + 63 < input_len; i += 64)
-			SHA1_TRANSFORM(ctx, &input[i]);
-#else
-		block_count = (input_len - i) >> 6;
-		if (block_count > 0) {
-			SHA1_TRANSFORM_BLOCKS(ctx, &input[i], block_count);
-			i += block_count << 6;
-		}
-#endif	/* !__amd64 */
-
-		/*
-		 * general optimization:
-		 *
-		 * if i and input_len are the same, return now instead
-		 * of calling bcopy(), since the bcopy() in this case
-		 * will be an expensive nop.
-		 */
-
-		if (input_len == i)
-			return;
-
-		buf_index = 0;
-	}
-
-	/* buffer remaining input */
-	bcopy(&input[i], &ctx->buf_un.buf8[buf_index], input_len - i);
-}
-
-/*
- * SHA1Final()
- *
- * purpose: ends an sha1 digest operation, finalizing the message digest and
- *          zeroing the context.
- *   input: uchar_t *	: A buffer to store the digest.
- *			: The function actually uses void* because many
- *			: callers pass things other than uchar_t here.
- *          SHA1_CTX *  : the context to finalize, save, and zero
- *  output: void
- */
-
-void
-SHA1Final(void *digest, SHA1_CTX *ctx)
-{
-	uint8_t		bitcount_be[sizeof (ctx->count)];
-	uint32_t	index = (ctx->count[1] >> 3) & 0x3f;
-
-	/* store bit count, big endian */
-	Encode(bitcount_be, ctx->count, sizeof (bitcount_be));
-
-	/* pad out to 56 mod 64 */
-	SHA1Update(ctx, PADDING, ((index < 56) ? 56 : 120) - index);
-
-	/* append length (before padding) */
-	SHA1Update(ctx, bitcount_be, sizeof (bitcount_be));
-
-	/* store state in digest */
-	Encode(digest, ctx->state, sizeof (ctx->state));
-
-	/* zeroize sensitive information */
-	bzero(ctx, sizeof (*ctx));
-}
-
-
-#if !defined(__amd64)
-
-typedef uint32_t sha1word;
-
-/*
- * sparc optimization:
- *
- * on the sparc, we can load big endian 32-bit data easily.  note that
- * special care must be taken to ensure the address is 32-bit aligned.
- * in the interest of speed, we don't check to make sure, since
- * careful programming can guarantee this for us.
- */
-
-#if	defined(_ZFS_BIG_ENDIAN)
-#define	LOAD_BIG_32(addr)	(*(uint32_t *)(addr))
-
-#elif	defined(HAVE_HTONL)
-#define	LOAD_BIG_32(addr) htonl(*((uint32_t *)(addr)))
-
-#else
-#define	LOAD_BIG_32(addr)	BE_32(*((uint32_t *)(addr)))
-#endif	/* _BIG_ENDIAN */
-
-/*
- * SHA1Transform()
- */
-#if	defined(W_ARRAY)
-#define	W(n) w[n]
-#else	/* !defined(W_ARRAY) */
-#define	W(n) w_ ## n
-#endif	/* !defined(W_ARRAY) */
-
-/*
- * ROTATE_LEFT rotates x left n bits.
- */
-
-#if	defined(__GNUC__) && defined(_LP64)
-static __inline__ uint64_t
-ROTATE_LEFT(uint64_t value, uint32_t n)
-{
-	uint32_t t32;
-
-	t32 = (uint32_t)value;
-	return ((t32 << n) | (t32 >> (32 - n)));
-}
-
-#else
-
-#define	ROTATE_LEFT(x, n)	\
-	(((x) << (n)) | ((x) >> ((sizeof (x) * NBBY)-(n))))
-
-#endif
-
-#if	defined(__sparc)
-
-
-/*
- * sparc register window optimization:
- *
- * `a', `b', `c', `d', and `e' are passed into SHA1Transform
- * explicitly since it increases the number of registers available to
- * the compiler.  under this scheme, these variables can be held in
- * %i0 - %i4, which leaves more local and out registers available.
- *
- * purpose: sha1 transformation -- updates the digest based on `block'
- *   input: uint32_t	: bytes  1 -  4 of the digest
- *          uint32_t	: bytes  5 -  8 of the digest
- *          uint32_t	: bytes  9 - 12 of the digest
- *          uint32_t	: bytes 12 - 16 of the digest
- *          uint32_t	: bytes 16 - 20 of the digest
- *          SHA1_CTX *	: the context to update
- *          uint8_t [64]: the block to use to update the digest
- *  output: void
- */
-
-
-void
-SHA1Transform(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e,
-    SHA1_CTX *ctx, const uint8_t blk[64])
-{
-	/*
-	 * sparc optimization:
-	 *
-	 * while it is somewhat counter-intuitive, on sparc, it is
-	 * more efficient to place all the constants used in this
-	 * function in an array and load the values out of the array
-	 * than to manually load the constants.  this is because
-	 * setting a register to a 32-bit value takes two ops in most
-	 * cases: a `sethi' and an `or', but loading a 32-bit value
-	 * from memory only takes one `ld' (or `lduw' on v9).  while
-	 * this increases memory usage, the compiler can find enough
-	 * other things to do while waiting to keep the pipeline does
-	 * not stall.  additionally, it is likely that many of these
-	 * constants are cached so that later accesses do not even go
-	 * out to the bus.
-	 *
-	 * this array is declared `static' to keep the compiler from
-	 * having to bcopy() this array onto the stack frame of
-	 * SHA1Transform() each time it is called -- which is
-	 * unacceptably expensive.
-	 *
-	 * the `const' is to ensure that callers are good citizens and
-	 * do not try to munge the array.  since these routines are
-	 * going to be called from inside multithreaded kernelland,
-	 * this is a good safety check. -- `sha1_consts' will end up in
-	 * .rodata.
-	 *
-	 * unfortunately, loading from an array in this manner hurts
-	 * performance under Intel.  So, there is a macro,
-	 * SHA1_CONST(), used in SHA1Transform(), that either expands to
-	 * a reference to this array, or to the actual constant,
-	 * depending on what platform this code is compiled for.
-	 */
-
-
-	static const uint32_t sha1_consts[] = {
-		SHA1_CONST_0, SHA1_CONST_1, SHA1_CONST_2, SHA1_CONST_3
-	};
-
-
-	/*
-	 * general optimization:
-	 *
-	 * use individual integers instead of using an array.  this is a
-	 * win, although the amount it wins by seems to vary quite a bit.
-	 */
-
-
-	uint32_t	w_0, w_1, w_2,  w_3,  w_4,  w_5,  w_6,  w_7;
-	uint32_t	w_8, w_9, w_10, w_11, w_12, w_13, w_14, w_15;
-
-
-	/*
-	 * sparc optimization:
-	 *
-	 * if `block' is already aligned on a 4-byte boundary, use
-	 * LOAD_BIG_32() directly.  otherwise, bcopy() into a
-	 * buffer that *is* aligned on a 4-byte boundary and then do
-	 * the LOAD_BIG_32() on that buffer.  benchmarks have shown
-	 * that using the bcopy() is better than loading the bytes
-	 * individually and doing the endian-swap by hand.
-	 *
-	 * even though it's quite tempting to assign to do:
-	 *
-	 * blk = bcopy(ctx->buf_un.buf32, blk, sizeof (ctx->buf_un.buf32));
-	 *
-	 * and only have one set of LOAD_BIG_32()'s, the compiler
-	 * *does not* like that, so please resist the urge.
-	 */
-
-
-	if ((uintptr_t)blk & 0x3) {		/* not 4-byte aligned? */
-		bcopy(blk, ctx->buf_un.buf32,  sizeof (ctx->buf_un.buf32));
-		w_15 = LOAD_BIG_32(ctx->buf_un.buf32 + 15);
-		w_14 = LOAD_BIG_32(ctx->buf_un.buf32 + 14);
-		w_13 = LOAD_BIG_32(ctx->buf_un.buf32 + 13);
-		w_12 = LOAD_BIG_32(ctx->buf_un.buf32 + 12);
-		w_11 = LOAD_BIG_32(ctx->buf_un.buf32 + 11);
-		w_10 = LOAD_BIG_32(ctx->buf_un.buf32 + 10);
-		w_9  = LOAD_BIG_32(ctx->buf_un.buf32 +  9);
-		w_8  = LOAD_BIG_32(ctx->buf_un.buf32 +  8);
-		w_7  = LOAD_BIG_32(ctx->buf_un.buf32 +  7);
-		w_6  = LOAD_BIG_32(ctx->buf_un.buf32 +  6);
-		w_5  = LOAD_BIG_32(ctx->buf_un.buf32 +  5);
-		w_4  = LOAD_BIG_32(ctx->buf_un.buf32 +  4);
-		w_3  = LOAD_BIG_32(ctx->buf_un.buf32 +  3);
-		w_2  = LOAD_BIG_32(ctx->buf_un.buf32 +  2);
-		w_1  = LOAD_BIG_32(ctx->buf_un.buf32 +  1);
-		w_0  = LOAD_BIG_32(ctx->buf_un.buf32 +  0);
-	} else {
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_15 = LOAD_BIG_32(blk + 60);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_14 = LOAD_BIG_32(blk + 56);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_13 = LOAD_BIG_32(blk + 52);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_12 = LOAD_BIG_32(blk + 48);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_11 = LOAD_BIG_32(blk + 44);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_10 = LOAD_BIG_32(blk + 40);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_9  = LOAD_BIG_32(blk + 36);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_8  = LOAD_BIG_32(blk + 32);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_7  = LOAD_BIG_32(blk + 28);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_6  = LOAD_BIG_32(blk + 24);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_5  = LOAD_BIG_32(blk + 20);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_4  = LOAD_BIG_32(blk + 16);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_3  = LOAD_BIG_32(blk + 12);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_2  = LOAD_BIG_32(blk +  8);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_1  = LOAD_BIG_32(blk +  4);
-		/* LINTED E_BAD_PTR_CAST_ALIGN */
-		w_0  = LOAD_BIG_32(blk +  0);
-	}
-#else	/* !defined(__sparc) */
-
-void /* CSTYLED */
-SHA1Transform(SHA1_CTX *ctx, const uint8_t blk[64])
-{
-	/* CSTYLED */
-	sha1word a = ctx->state[0];
-	sha1word b = ctx->state[1];
-	sha1word c = ctx->state[2];
-	sha1word d = ctx->state[3];
-	sha1word e = ctx->state[4];
-
-#if	defined(W_ARRAY)
-	sha1word	w[16];
-#else	/* !defined(W_ARRAY) */
-	sha1word	w_0, w_1, w_2,  w_3,  w_4,  w_5,  w_6,  w_7;
-	sha1word	w_8, w_9, w_10, w_11, w_12, w_13, w_14, w_15;
-#endif	/* !defined(W_ARRAY) */
-
-	W(0)  = LOAD_BIG_32((void *)(blk +  0));
-	W(1)  = LOAD_BIG_32((void *)(blk +  4));
-	W(2)  = LOAD_BIG_32((void *)(blk +  8));
-	W(3)  = LOAD_BIG_32((void *)(blk + 12));
-	W(4)  = LOAD_BIG_32((void *)(blk + 16));
-	W(5)  = LOAD_BIG_32((void *)(blk + 20));
-	W(6)  = LOAD_BIG_32((void *)(blk + 24));
-	W(7)  = LOAD_BIG_32((void *)(blk + 28));
-	W(8)  = LOAD_BIG_32((void *)(blk + 32));
-	W(9)  = LOAD_BIG_32((void *)(blk + 36));
-	W(10) = LOAD_BIG_32((void *)(blk + 40));
-	W(11) = LOAD_BIG_32((void *)(blk + 44));
-	W(12) = LOAD_BIG_32((void *)(blk + 48));
-	W(13) = LOAD_BIG_32((void *)(blk + 52));
-	W(14) = LOAD_BIG_32((void *)(blk + 56));
-	W(15) = LOAD_BIG_32((void *)(blk + 60));
-
-#endif /* !defined(__sparc) */
-
-	/*
-	 * general optimization:
-	 *
-	 * even though this approach is described in the standard as
-	 * being slower algorithmically, it is 30-40% faster than the
-	 * "faster" version under SPARC, because this version has more
-	 * of the constraints specified at compile-time and uses fewer
-	 * variables (and therefore has better register utilization)
-	 * than its "speedier" brother.  (i've tried both, trust me)
-	 *
-	 * for either method given in the spec, there is an "assignment"
-	 * phase where the following takes place:
-	 *
-	 *	tmp = (main_computation);
-	 *	e = d; d = c; c = rotate_left(b, 30); b = a; a = tmp;
-	 *
-	 * we can make the algorithm go faster by not doing this work,
-	 * but just pretending that `d' is now `e', etc. this works
-	 * really well and obviates the need for a temporary variable.
-	 * however, we still explicitly perform the rotate action,
-	 * since it is cheaper on SPARC to do it once than to have to
-	 * do it over and over again.
-	 */
-
-	/* round 1 */
-	e = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(0) + SHA1_CONST(0); /* 0 */
-	b = ROTATE_LEFT(b, 30);
-
-	d = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(1) + SHA1_CONST(0); /* 1 */
-	a = ROTATE_LEFT(a, 30);
-
-	c = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(2) + SHA1_CONST(0); /* 2 */
-	e = ROTATE_LEFT(e, 30);
-
-	b = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(3) + SHA1_CONST(0); /* 3 */
-	d = ROTATE_LEFT(d, 30);
-
-	a = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(4) + SHA1_CONST(0); /* 4 */
-	c = ROTATE_LEFT(c, 30);
-
-	e = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(5) + SHA1_CONST(0); /* 5 */
-	b = ROTATE_LEFT(b, 30);
-
-	d = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(6) + SHA1_CONST(0); /* 6 */
-	a = ROTATE_LEFT(a, 30);
-
-	c = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(7) + SHA1_CONST(0); /* 7 */
-	e = ROTATE_LEFT(e, 30);
-
-	b = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(8) + SHA1_CONST(0); /* 8 */
-	d = ROTATE_LEFT(d, 30);
-
-	a = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(9) + SHA1_CONST(0); /* 9 */
-	c = ROTATE_LEFT(c, 30);
-
-	e = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(10) + SHA1_CONST(0); /* 10 */
-	b = ROTATE_LEFT(b, 30);
-
-	d = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(11) + SHA1_CONST(0); /* 11 */
-	a = ROTATE_LEFT(a, 30);
-
-	c = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(12) + SHA1_CONST(0); /* 12 */
-	e = ROTATE_LEFT(e, 30);
-
-	b = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(13) + SHA1_CONST(0); /* 13 */
-	d = ROTATE_LEFT(d, 30);
-
-	a = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(14) + SHA1_CONST(0); /* 14 */
-	c = ROTATE_LEFT(c, 30);
-
-	e = ROTATE_LEFT(a, 5) + F(b, c, d) + e + W(15) + SHA1_CONST(0); /* 15 */
-	b = ROTATE_LEFT(b, 30);
-
-	W(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);		/* 16 */
-	d = ROTATE_LEFT(e, 5) + F(a, b, c) + d + W(0) + SHA1_CONST(0);
-	a = ROTATE_LEFT(a, 30);
-
-	W(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);		/* 17 */
-	c = ROTATE_LEFT(d, 5) + F(e, a, b) + c + W(1) + SHA1_CONST(0);
-	e = ROTATE_LEFT(e, 30);
-
-	W(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);	/* 18 */
-	b = ROTATE_LEFT(c, 5) + F(d, e, a) + b + W(2) + SHA1_CONST(0);
-	d = ROTATE_LEFT(d, 30);
-
-	W(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);		/* 19 */
-	a = ROTATE_LEFT(b, 5) + F(c, d, e) + a + W(3) + SHA1_CONST(0);
-	c = ROTATE_LEFT(c, 30);
-
-	/* round 2 */
-	W(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);		/* 20 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(4) + SHA1_CONST(1);
-	b = ROTATE_LEFT(b, 30);
-
-	W(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);		/* 21 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(5) + SHA1_CONST(1);
-	a = ROTATE_LEFT(a, 30);
-
-	W(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);		/* 22 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(6) + SHA1_CONST(1);
-	e = ROTATE_LEFT(e, 30);
-
-	W(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);		/* 23 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(7) + SHA1_CONST(1);
-	d = ROTATE_LEFT(d, 30);
-
-	W(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);		/* 24 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(8) + SHA1_CONST(1);
-	c = ROTATE_LEFT(c, 30);
-
-	W(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);		/* 25 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(9) + SHA1_CONST(1);
-	b = ROTATE_LEFT(b, 30);
-
-	W(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);	/* 26 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(10) + SHA1_CONST(1);
-	a = ROTATE_LEFT(a, 30);
-
-	W(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);	/* 27 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(11) + SHA1_CONST(1);
-	e = ROTATE_LEFT(e, 30);
-
-	W(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);	/* 28 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(12) + SHA1_CONST(1);
-	d = ROTATE_LEFT(d, 30);
-
-	W(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);	/* 29 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(13) + SHA1_CONST(1);
-	c = ROTATE_LEFT(c, 30);
-
-	W(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);	/* 30 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(14) + SHA1_CONST(1);
-	b = ROTATE_LEFT(b, 30);
-
-	W(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);	/* 31 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(15) + SHA1_CONST(1);
-	a = ROTATE_LEFT(a, 30);
-
-	W(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);		/* 32 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(0) + SHA1_CONST(1);
-	e = ROTATE_LEFT(e, 30);
-
-	W(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);		/* 33 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(1) + SHA1_CONST(1);
-	d = ROTATE_LEFT(d, 30);
-
-	W(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);	/* 34 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(2) + SHA1_CONST(1);
-	c = ROTATE_LEFT(c, 30);
-
-	W(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);		/* 35 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(3) + SHA1_CONST(1);
-	b = ROTATE_LEFT(b, 30);
-
-	W(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);		/* 36 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(4) + SHA1_CONST(1);
-	a = ROTATE_LEFT(a, 30);
-
-	W(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);		/* 37 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(5) + SHA1_CONST(1);
-	e = ROTATE_LEFT(e, 30);
-
-	W(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);		/* 38 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(6) + SHA1_CONST(1);
-	d = ROTATE_LEFT(d, 30);
-
-	W(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);		/* 39 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(7) + SHA1_CONST(1);
-	c = ROTATE_LEFT(c, 30);
-
-	/* round 3 */
-	W(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);		/* 40 */
-	e = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(8) + SHA1_CONST(2);
-	b = ROTATE_LEFT(b, 30);
-
-	W(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);		/* 41 */
-	d = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(9) + SHA1_CONST(2);
-	a = ROTATE_LEFT(a, 30);
-
-	W(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);	/* 42 */
-	c = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(10) + SHA1_CONST(2);
-	e = ROTATE_LEFT(e, 30);
-
-	W(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);	/* 43 */
-	b = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(11) + SHA1_CONST(2);
-	d = ROTATE_LEFT(d, 30);
-
-	W(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);	/* 44 */
-	a = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(12) + SHA1_CONST(2);
-	c = ROTATE_LEFT(c, 30);
-
-	W(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);	/* 45 */
-	e = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(13) + SHA1_CONST(2);
-	b = ROTATE_LEFT(b, 30);
-
-	W(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);	/* 46 */
-	d = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(14) + SHA1_CONST(2);
-	a = ROTATE_LEFT(a, 30);
-
-	W(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);	/* 47 */
-	c = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(15) + SHA1_CONST(2);
-	e = ROTATE_LEFT(e, 30);
-
-	W(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);		/* 48 */
-	b = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(0) + SHA1_CONST(2);
-	d = ROTATE_LEFT(d, 30);
-
-	W(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);		/* 49 */
-	a = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(1) + SHA1_CONST(2);
-	c = ROTATE_LEFT(c, 30);
-
-	W(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);	/* 50 */
-	e = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(2) + SHA1_CONST(2);
-	b = ROTATE_LEFT(b, 30);
-
-	W(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);		/* 51 */
-	d = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(3) + SHA1_CONST(2);
-	a = ROTATE_LEFT(a, 30);
-
-	W(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);		/* 52 */
-	c = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(4) + SHA1_CONST(2);
-	e = ROTATE_LEFT(e, 30);
-
-	W(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);		/* 53 */
-	b = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(5) + SHA1_CONST(2);
-	d = ROTATE_LEFT(d, 30);
-
-	W(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);		/* 54 */
-	a = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(6) + SHA1_CONST(2);
-	c = ROTATE_LEFT(c, 30);
-
-	W(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);		/* 55 */
-	e = ROTATE_LEFT(a, 5) + H(b, c, d) + e + W(7) + SHA1_CONST(2);
-	b = ROTATE_LEFT(b, 30);
-
-	W(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);		/* 56 */
-	d = ROTATE_LEFT(e, 5) + H(a, b, c) + d + W(8) + SHA1_CONST(2);
-	a = ROTATE_LEFT(a, 30);
-
-	W(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);		/* 57 */
-	c = ROTATE_LEFT(d, 5) + H(e, a, b) + c + W(9) + SHA1_CONST(2);
-	e = ROTATE_LEFT(e, 30);
-
-	W(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);	/* 58 */
-	b = ROTATE_LEFT(c, 5) + H(d, e, a) + b + W(10) + SHA1_CONST(2);
-	d = ROTATE_LEFT(d, 30);
-
-	W(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);	/* 59 */
-	a = ROTATE_LEFT(b, 5) + H(c, d, e) + a + W(11) + SHA1_CONST(2);
-	c = ROTATE_LEFT(c, 30);
-
-	/* round 4 */
-	W(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);	/* 60 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(12) + SHA1_CONST(3);
-	b = ROTATE_LEFT(b, 30);
-
-	W(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);	/* 61 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(13) + SHA1_CONST(3);
-	a = ROTATE_LEFT(a, 30);
-
-	W(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);	/* 62 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(14) + SHA1_CONST(3);
-	e = ROTATE_LEFT(e, 30);
-
-	W(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);	/* 63 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(15) + SHA1_CONST(3);
-	d = ROTATE_LEFT(d, 30);
-
-	W(0) = ROTATE_LEFT((W(13) ^ W(8) ^ W(2) ^ W(0)), 1);		/* 64 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(0) + SHA1_CONST(3);
-	c = ROTATE_LEFT(c, 30);
-
-	W(1) = ROTATE_LEFT((W(14) ^ W(9) ^ W(3) ^ W(1)), 1);		/* 65 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(1) + SHA1_CONST(3);
-	b = ROTATE_LEFT(b, 30);
-
-	W(2) = ROTATE_LEFT((W(15) ^ W(10) ^ W(4) ^ W(2)), 1);	/* 66 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(2) + SHA1_CONST(3);
-	a = ROTATE_LEFT(a, 30);
-
-	W(3) = ROTATE_LEFT((W(0) ^ W(11) ^ W(5) ^ W(3)), 1);		/* 67 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(3) + SHA1_CONST(3);
-	e = ROTATE_LEFT(e, 30);
-
-	W(4) = ROTATE_LEFT((W(1) ^ W(12) ^ W(6) ^ W(4)), 1);		/* 68 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(4) + SHA1_CONST(3);
-	d = ROTATE_LEFT(d, 30);
-
-	W(5) = ROTATE_LEFT((W(2) ^ W(13) ^ W(7) ^ W(5)), 1);		/* 69 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(5) + SHA1_CONST(3);
-	c = ROTATE_LEFT(c, 30);
-
-	W(6) = ROTATE_LEFT((W(3) ^ W(14) ^ W(8) ^ W(6)), 1);		/* 70 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(6) + SHA1_CONST(3);
-	b = ROTATE_LEFT(b, 30);
-
-	W(7) = ROTATE_LEFT((W(4) ^ W(15) ^ W(9) ^ W(7)), 1);		/* 71 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(7) + SHA1_CONST(3);
-	a = ROTATE_LEFT(a, 30);
-
-	W(8) = ROTATE_LEFT((W(5) ^ W(0) ^ W(10) ^ W(8)), 1);		/* 72 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(8) + SHA1_CONST(3);
-	e = ROTATE_LEFT(e, 30);
-
-	W(9) = ROTATE_LEFT((W(6) ^ W(1) ^ W(11) ^ W(9)), 1);		/* 73 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(9) + SHA1_CONST(3);
-	d = ROTATE_LEFT(d, 30);
-
-	W(10) = ROTATE_LEFT((W(7) ^ W(2) ^ W(12) ^ W(10)), 1);	/* 74 */
-	a = ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(10) + SHA1_CONST(3);
-	c = ROTATE_LEFT(c, 30);
-
-	W(11) = ROTATE_LEFT((W(8) ^ W(3) ^ W(13) ^ W(11)), 1);	/* 75 */
-	e = ROTATE_LEFT(a, 5) + G(b, c, d) + e + W(11) + SHA1_CONST(3);
-	b = ROTATE_LEFT(b, 30);
-
-	W(12) = ROTATE_LEFT((W(9) ^ W(4) ^ W(14) ^ W(12)), 1);	/* 76 */
-	d = ROTATE_LEFT(e, 5) + G(a, b, c) + d + W(12) + SHA1_CONST(3);
-	a = ROTATE_LEFT(a, 30);
-
-	W(13) = ROTATE_LEFT((W(10) ^ W(5) ^ W(15) ^ W(13)), 1);	/* 77 */
-	c = ROTATE_LEFT(d, 5) + G(e, a, b) + c + W(13) + SHA1_CONST(3);
-	e = ROTATE_LEFT(e, 30);
-
-	W(14) = ROTATE_LEFT((W(11) ^ W(6) ^ W(0) ^ W(14)), 1);	/* 78 */
-	b = ROTATE_LEFT(c, 5) + G(d, e, a) + b + W(14) + SHA1_CONST(3);
-	d = ROTATE_LEFT(d, 30);
-
-	W(15) = ROTATE_LEFT((W(12) ^ W(7) ^ W(1) ^ W(15)), 1);	/* 79 */
-
-	ctx->state[0] += ROTATE_LEFT(b, 5) + G(c, d, e) + a + W(15) +
-	    SHA1_CONST(3);
-	ctx->state[1] += b;
-	ctx->state[2] += ROTATE_LEFT(c, 30);
-	ctx->state[3] += d;
-	ctx->state[4] += e;
-
-	/* zeroize sensitive information */
-	W(0) = W(1) = W(2) = W(3) = W(4) = W(5) = W(6) = W(7) = W(8) = 0;
-	W(9) = W(10) = W(11) = W(12) = W(13) = W(14) = W(15) = 0;
-}
-#endif	/* !__amd64 */
-
-
-/*
- * Encode()
- *
- * purpose: to convert a list of numbers from little endian to big endian
- *   input: uint8_t *	: place to store the converted big endian numbers
- *	    uint32_t *	: place to get numbers to convert from
- *          size_t	: the length of the input in bytes
- *  output: void
- */
-
-static void
-Encode(uint8_t *_RESTRICT_KYWD output, const uint32_t *_RESTRICT_KYWD input,
-    size_t len)
-{
-	size_t		i, j;
-
-#if defined(__sparc)
-	if (IS_P2ALIGNED(output, sizeof (uint32_t))) {
-		for (i = 0, j = 0; j < len; i++, j += 4) {
-			/* LINTED E_BAD_PTR_CAST_ALIGN */
-			*((uint32_t *)(output + j)) = input[i];
-		}
-	} else {
-#endif /* little endian -- will work on big endian, but slowly */
-
-		for (i = 0, j = 0; j < len; i++, j += 4) {
-			output[j]	= (input[i] >> 24) & 0xff;
-			output[j + 1]	= (input[i] >> 16) & 0xff;
-			output[j + 2]	= (input[i] >>  8) & 0xff;
-			output[j + 3]	= input[i] & 0xff;
-		}
-#if defined(__sparc)
-	}
-#endif
-}
diff --git a/sys/contrib/openzfs/module/icp/algs/sha2/sha2.c b/sys/contrib/openzfs/module/icp/algs/sha2/sha2.c
index 75f6a3c1af4b..6f1e9b7193d4 100644
--- a/sys/contrib/openzfs/module/icp/algs/sha2/sha2.c
+++ b/sys/contrib/openzfs/module/icp/algs/sha2/sha2.c
@@ -65,7 +65,7 @@ static void SHA256Transform(SHA2_CTX *, const uint8_t *);
 static void SHA512Transform(SHA2_CTX *, const uint8_t *);
 #endif	/* __amd64 && _KERNEL */
 
-static uint8_t PADDING[128] = { 0x80, /* all zeros */ };
+static const uint8_t PADDING[128] = { 0x80, /* all zeros */ };
 
 /*
  * The low-level checksum routines use a lot of stack space. On systems where
diff --git a/sys/contrib/openzfs/module/icp/algs/skein/skein_impl.h b/sys/contrib/openzfs/module/icp/algs/skein/skein_impl.h
index 2f6307fa7b55..1fa249e95e4b 100644
--- a/sys/contrib/openzfs/module/icp/algs/skein/skein_impl.h
+++ b/sys/contrib/openzfs/module/icp/algs/skein/skein_impl.h
@@ -263,8 +263,6 @@ extern const uint64_t SKEIN_256_IV_128[];
 extern const uint64_t SKEIN_256_IV_160[];
 extern const uint64_t SKEIN_256_IV_224[];
 extern const uint64_t SKEIN_256_IV_256[];
-extern const uint64_t SKEIN_512_IV_128[];
-extern const uint64_t SKEIN_512_IV_160[];
 extern const uint64_t SKEIN_512_IV_224[];
 extern const uint64_t SKEIN_512_IV_256[];
 extern const uint64_t SKEIN_512_IV_384[];
diff --git a/sys/contrib/openzfs/module/icp/algs/skein/skein_iv.c b/sys/contrib/openzfs/module/icp/algs/skein/skein_iv.c
index 140d38f76547..84cefe4546ca 100644
--- a/sys/contrib/openzfs/module/icp/algs/skein/skein_iv.c
+++ b/sys/contrib/openzfs/module/icp/algs/skein/skein_iv.c
@@ -52,30 +52,6 @@ const uint64_t SKEIN_256_IV_256[] = {
 	MK_64(0x6A54E920, 0xFDE8DA69)
 };
 
-/* blkSize =  512 bits. hashSize =  128 bits */
-const uint64_t SKEIN_512_IV_128[] = {
-	MK_64(0xA8BC7BF3, 0x6FBF9F52),
-	MK_64(0x1E9872CE, 0xBD1AF0AA),
-	MK_64(0x309B1790, 0xB32190D3),
-	MK_64(0xBCFBB854, 0x3F94805C),
-	MK_64(0x0DA61BCD, 0x6E31B11B),
-	MK_64(0x1A18EBEA, 0xD46A32E3),
-	MK_64(0xA2CC5B18, 0xCE84AA82),
-	MK_64(0x6982AB28, 0x9D46982D)
-};
-
-/* blkSize =  512 bits. hashSize =  160 bits */
-const uint64_t SKEIN_512_IV_160[] = {
-	MK_64(0x28B81A2A, 0xE013BD91),
-	MK_64(0xC2F11668, 0xB5BDF78F),
-	MK_64(0x1760D8F3, 0xF6A56F12),
-	MK_64(0x4FB74758, 0x8239904F),
-	MK_64(0x21EDE07F, 0x7EAF5056),
-	MK_64(0xD908922E, 0x63ED70B8),
-	MK_64(0xB8EC76FF, 0xECCB52FA),
-	MK_64(0x01A47BB8, 0xA3F27A6E)
-};
-
 /* blkSize =  512 bits. hashSize =  224 bits */
 const uint64_t SKEIN_512_IV_224[] = {
 	MK_64(0xCCD06162, 0x48677224),
diff --git a/sys/contrib/openzfs/module/icp/api/kcf_miscapi.c b/sys/contrib/openzfs/module/icp/api/kcf_miscapi.c
index c0f415b264a7..5c0d60391f44 100644
--- a/sys/contrib/openzfs/module/icp/api/kcf_miscapi.c
+++ b/sys/contrib/openzfs/module/icp/api/kcf_miscapi.c
@@ -62,7 +62,7 @@ static kcf_ntfy_elem_t *ntfy_list_head;
  *	CRYPTO_MECH_INVALID otherwise.
  */
 crypto_mech_type_t
-crypto_mech2id(char *mechname)
+crypto_mech2id(const char *mechname)
 {
 	return (crypto_mech2id_common(mechname, B_TRUE));
 }
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_aesni.S b/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_aesni.S
index 4a80c62097ae..1a8669ccd1d6 100644
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_aesni.S
+++ b/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_aesni.S
@@ -154,26 +154,26 @@
 
 #include <sys/types.h>
 
-/* ARGSUSED */
 void
 aes_encrypt_intel(const uint32_t rk[], int Nr, const uint32_t pt[4],
     uint32_t ct[4]) {
+	(void) rk, (void) Nr, (void) pt, (void) ct;
 }
-/* ARGSUSED */
 void
 aes_decrypt_intel(const uint32_t rk[], int Nr, const uint32_t ct[4],
     uint32_t pt[4]) {
+	(void) rk, (void) Nr, (void) ct, (void) pt;
 }
-/* ARGSUSED */
 int
 rijndael_key_setup_enc_intel(uint32_t rk[], const uint32_t cipherKey[],
     uint64_t keyBits) {
+	(void) rk, (void) cipherKey, (void) keyBits;
 	return (0);
 }
-/* ARGSUSED */
 int
 rijndael_key_setup_dec_intel(uint32_t rk[], const uint32_t cipherKey[],
    uint64_t keyBits) {
+	(void) rk, (void) cipherKey, (void) keyBits;
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_amd64.S b/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_amd64.S
index 9db3a3179230..d16cc9996e25 100644
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_amd64.S
+++ b/sys/contrib/openzfs/module/icp/asm-x86_64/aes/aes_amd64.S
@@ -186,15 +186,15 @@
 #if defined(lint) || defined(__lint)
 
 #include <sys/types.h>
-/* ARGSUSED */
 void
 aes_encrypt_amd64(const uint32_t rk[], int Nr, const uint32_t pt[4],
 	uint32_t ct[4]) {
+   (void) rk, (void) Nr, (void) pt, (void) ct;
 }
-/* ARGSUSED */
 void
 aes_decrypt_amd64(const uint32_t rk[], int Nr, const uint32_t ct[4],
 	uint32_t pt[4]) {
+   (void) rk, (void) Nr, (void) pt, (void) ct;
 }
 
 
@@ -693,7 +693,7 @@ aes_decrypt_amd64(const uint32_t rk[], int Nr, const uint32_t ct[4],
  * int aes_encrypt(const unsigned char *in,
  *	unsigned char *out, const aes_encrypt_ctx cx[1])/
  */
-.data
+.section .rodata
 .align	64
 enc_tab:
 	enc_vals(u8)
@@ -798,7 +798,7 @@ ENTRY_NP(aes_encrypt_amd64)
  * int aes_decrypt(const unsigned char *in,
  *	unsigned char *out, const aes_encrypt_ctx cx[1])/
  */
-.data
+.section .rodata
 .align	64
 dec_tab:
 	dec_vals(v8)
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/modes/gcm_pclmulqdq.S b/sys/contrib/openzfs/module/icp/asm-x86_64/modes/gcm_pclmulqdq.S
index 59edc4c8d56c..74eacbbe6388 100644
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/modes/gcm_pclmulqdq.S
+++ b/sys/contrib/openzfs/module/icp/asm-x86_64/modes/gcm_pclmulqdq.S
@@ -85,9 +85,9 @@
 
 #include <sys/types.h>
 
-/* ARGSUSED */
 void
 gcm_mul_pclmulqdq(uint64_t *x_in, uint64_t *y, uint64_t *res) {
+	(void) x_in, (void) y, (void) res;
 }
 
 #elif defined(HAVE_PCLMULQDQ)	/* guard by instruction set */
@@ -101,7 +101,7 @@ gcm_mul_pclmulqdq(uint64_t *x_in, uint64_t *y, uint64_t *res) {
 
 // static uint8_t byte_swap16_mask[] = {
 //	 15, 14, 13, 12, 11, 10, 9, 8, 7, 6 ,5, 4, 3, 2, 1, 0 };
-.data
+.section .rodata
 .align XMM_ALIGN
 .Lbyte_swap16_mask:
 	.byte	15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/sha1/sha1-x86_64.S b/sys/contrib/openzfs/module/icp/asm-x86_64/sha1/sha1-x86_64.S
deleted file mode 100644
index fc844cd8c74f..000000000000
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/sha1/sha1-x86_64.S
+++ /dev/null
@@ -1,1369 +0,0 @@
-/*
- * !/usr/bin/env perl
- *
- *  ====================================================================
- *  Written by Andy Polyakov <appro@fy.chalmers.se> for the OpenSSL
- *  project. The module is, however, dual licensed under OpenSSL and
- *  CRYPTOGAMS licenses depending on where you obtain it. For further
- *  details see http://www.openssl.org/~appro/cryptogams/.
- *  ====================================================================
- *
- *  sha1_block procedure for x86_64.
- *
- *  It was brought to my attention that on EM64T compiler-generated code
- *  was far behind 32-bit assembler implementation. This is unlike on
- *  Opteron where compiler-generated code was only 15% behind 32-bit
- *  assembler, which originally made it hard to motivate the effort.
- *  There was suggestion to mechanically translate 32-bit code, but I
- *  dismissed it, reasoning that x86_64 offers enough register bank
- *  capacity to fully utilize SHA-1 parallelism. Therefore this fresh
- *  implementation:-) However! While 64-bit code does performs better
- *  on Opteron, I failed to beat 32-bit assembler on EM64T core. Well,
- *  x86_64 does offer larger *addressable* bank, but out-of-order core
- *  reaches for even more registers through dynamic aliasing, and EM64T
- *  core must have managed to run-time optimize even 32-bit code just as
- *  good as 64-bit one. Performance improvement is summarized in the
- *  following table:
- *
- * 		gcc 3.4		32-bit asm	cycles/byte
- *  Opteron	+45%		+20%		6.8
- *  Xeon P4	+65%		+0%		9.9
- *  Core2		+60%		+10%		7.0
- *
- *
- *  OpenSolaris OS modifications
- *
- *  Sun elects to use this software under the BSD license.
- *
- *  This source originates from OpenSSL file sha1-x86_64.pl at
- *  ftp://ftp.openssl.org/snapshot/openssl-0.9.8-stable-SNAP-20080131.tar.gz
- *  (presumably for future OpenSSL release 0.9.8h), with these changes:
- *
- *  1. Added perl "use strict" and declared variables.
- *
- *  2. Added OpenSolaris ENTRY_NP/SET_SIZE macros from
- *  /usr/include/sys/asm_linkage.h, .ident keywords, and lint(1B) guards.
- *
- *  3. Removed x86_64-xlate.pl script (not needed for as(1) or gas(1)
- *  assemblers).
- *
- */
-
-/*
- * This file was generated by a perl script (sha1-x86_64.pl). The comments from
- * the original file have been pasted above.
- */
-
-#if defined(lint) || defined(__lint)
-#include <sys/stdint.h>
-#include <sys/sha1.h>
-
-
-/* ARGSUSED */
-void
-sha1_block_data_order(SHA1_CTX *ctx, const void *inpp, size_t blocks)
-{
-}
-
-#else
-#define _ASM
-#include <sys/asm_linkage.h>
-ENTRY_NP(sha1_block_data_order)
-.cfi_startproc
-	mov	%rsp,%rax
-.cfi_def_cfa_register %rax
-	push	%rbx
-.cfi_offset	%rbx,-16
-	push	%rbp
-.cfi_offset	%rbp,-24
-	push	%r12
-.cfi_offset	%r12,-32
-	mov	%rdi,%r8	# reassigned argument
-.cfi_register	%rdi, %r8
-	sub	$72,%rsp
-	mov	%rsi,%r9	# reassigned argument
-.cfi_register	%rsi, %r9
-	and	$-64,%rsp
-	mov	%rdx,%r10	# reassigned argument
-.cfi_register	%rdx, %r10
-	mov	%rax,64(%rsp)
-# echo ".cfi_cfa_expression %rsp+64,deref,+8" |
-#	openssl/crypto/perlasm/x86_64-xlate.pl
-.cfi_escape	0x0f,0x06,0x77,0xc0,0x00,0x06,0x23,0x08
-
-	mov	0(%r8),%edx
-	mov	4(%r8),%esi
-	mov	8(%r8),%edi
-	mov	12(%r8),%ebp
-	mov	16(%r8),%r11d
-.align	4
-.Lloop:
-	mov	0(%r9),%eax
-	bswap	%eax
-	mov	%eax,0(%rsp)
-	lea	0x5a827999(%eax,%r11d),%r12d
-	mov	%edi,%ebx
-	mov	4(%r9),%eax
-	mov	%edx,%r11d
-	xor	%ebp,%ebx
-	bswap	%eax
-	rol	$5,%r11d
-	and	%esi,%ebx
-	mov	%eax,4(%rsp)
-	add	%r11d,%r12d
-	xor	%ebp,%ebx
-	rol	$30,%esi
-	add	%ebx,%r12d
-	lea	0x5a827999(%eax,%ebp),%r11d
-	mov	%esi,%ebx
-	mov	8(%r9),%eax
-	mov	%r12d,%ebp
-	xor	%edi,%ebx
-	bswap	%eax
-	rol	$5,%ebp
-	and	%edx,%ebx
-	mov	%eax,8(%rsp)
-	add	%ebp,%r11d
-	xor	%edi,%ebx
-	rol	$30,%edx
-	add	%ebx,%r11d
-	lea	0x5a827999(%eax,%edi),%ebp
-	mov	%edx,%ebx
-	mov	12(%r9),%eax
-	mov	%r11d,%edi
-	xor	%esi,%ebx
-	bswap	%eax
-	rol	$5,%edi
-	and	%r12d,%ebx
-	mov	%eax,12(%rsp)
-	add	%edi,%ebp
-	xor	%esi,%ebx
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	lea	0x5a827999(%eax,%esi),%edi
-	mov	%r12d,%ebx
-	mov	16(%r9),%eax
-	mov	%ebp,%esi
-	xor	%edx,%ebx
-	bswap	%eax
-	rol	$5,%esi
-	and	%r11d,%ebx
-	mov	%eax,16(%rsp)
-	add	%esi,%edi
-	xor	%edx,%ebx
-	rol	$30,%r11d
-	add	%ebx,%edi
-	lea	0x5a827999(%eax,%edx),%esi
-	mov	%r11d,%ebx
-	mov	20(%r9),%eax
-	mov	%edi,%edx
-	xor	%r12d,%ebx
-	bswap	%eax
-	rol	$5,%edx
-	and	%ebp,%ebx
-	mov	%eax,20(%rsp)
-	add	%edx,%esi
-	xor	%r12d,%ebx
-	rol	$30,%ebp
-	add	%ebx,%esi
-	lea	0x5a827999(%eax,%r12d),%edx
-	mov	%ebp,%ebx
-	mov	24(%r9),%eax
-	mov	%esi,%r12d
-	xor	%r11d,%ebx
-	bswap	%eax
-	rol	$5,%r12d
-	and	%edi,%ebx
-	mov	%eax,24(%rsp)
-	add	%r12d,%edx
-	xor	%r11d,%ebx
-	rol	$30,%edi
-	add	%ebx,%edx
-	lea	0x5a827999(%eax,%r11d),%r12d
-	mov	%edi,%ebx
-	mov	28(%r9),%eax
-	mov	%edx,%r11d
-	xor	%ebp,%ebx
-	bswap	%eax
-	rol	$5,%r11d
-	and	%esi,%ebx
-	mov	%eax,28(%rsp)
-	add	%r11d,%r12d
-	xor	%ebp,%ebx
-	rol	$30,%esi
-	add	%ebx,%r12d
-	lea	0x5a827999(%eax,%ebp),%r11d
-	mov	%esi,%ebx
-	mov	32(%r9),%eax
-	mov	%r12d,%ebp
-	xor	%edi,%ebx
-	bswap	%eax
-	rol	$5,%ebp
-	and	%edx,%ebx
-	mov	%eax,32(%rsp)
-	add	%ebp,%r11d
-	xor	%edi,%ebx
-	rol	$30,%edx
-	add	%ebx,%r11d
-	lea	0x5a827999(%eax,%edi),%ebp
-	mov	%edx,%ebx
-	mov	36(%r9),%eax
-	mov	%r11d,%edi
-	xor	%esi,%ebx
-	bswap	%eax
-	rol	$5,%edi
-	and	%r12d,%ebx
-	mov	%eax,36(%rsp)
-	add	%edi,%ebp
-	xor	%esi,%ebx
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	lea	0x5a827999(%eax,%esi),%edi
-	mov	%r12d,%ebx
-	mov	40(%r9),%eax
-	mov	%ebp,%esi
-	xor	%edx,%ebx
-	bswap	%eax
-	rol	$5,%esi
-	and	%r11d,%ebx
-	mov	%eax,40(%rsp)
-	add	%esi,%edi
-	xor	%edx,%ebx
-	rol	$30,%r11d
-	add	%ebx,%edi
-	lea	0x5a827999(%eax,%edx),%esi
-	mov	%r11d,%ebx
-	mov	44(%r9),%eax
-	mov	%edi,%edx
-	xor	%r12d,%ebx
-	bswap	%eax
-	rol	$5,%edx
-	and	%ebp,%ebx
-	mov	%eax,44(%rsp)
-	add	%edx,%esi
-	xor	%r12d,%ebx
-	rol	$30,%ebp
-	add	%ebx,%esi
-	lea	0x5a827999(%eax,%r12d),%edx
-	mov	%ebp,%ebx
-	mov	48(%r9),%eax
-	mov	%esi,%r12d
-	xor	%r11d,%ebx
-	bswap	%eax
-	rol	$5,%r12d
-	and	%edi,%ebx
-	mov	%eax,48(%rsp)
-	add	%r12d,%edx
-	xor	%r11d,%ebx
-	rol	$30,%edi
-	add	%ebx,%edx
-	lea	0x5a827999(%eax,%r11d),%r12d
-	mov	%edi,%ebx
-	mov	52(%r9),%eax
-	mov	%edx,%r11d
-	xor	%ebp,%ebx
-	bswap	%eax
-	rol	$5,%r11d
-	and	%esi,%ebx
-	mov	%eax,52(%rsp)
-	add	%r11d,%r12d
-	xor	%ebp,%ebx
-	rol	$30,%esi
-	add	%ebx,%r12d
-	lea	0x5a827999(%eax,%ebp),%r11d
-	mov	%esi,%ebx
-	mov	56(%r9),%eax
-	mov	%r12d,%ebp
-	xor	%edi,%ebx
-	bswap	%eax
-	rol	$5,%ebp
-	and	%edx,%ebx
-	mov	%eax,56(%rsp)
-	add	%ebp,%r11d
-	xor	%edi,%ebx
-	rol	$30,%edx
-	add	%ebx,%r11d
-	lea	0x5a827999(%eax,%edi),%ebp
-	mov	%edx,%ebx
-	mov	60(%r9),%eax
-	mov	%r11d,%edi
-	xor	%esi,%ebx
-	bswap	%eax
-	rol	$5,%edi
-	and	%r12d,%ebx
-	mov	%eax,60(%rsp)
-	add	%edi,%ebp
-	xor	%esi,%ebx
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	lea	0x5a827999(%eax,%esi),%edi
-	mov	0(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	8(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%esi
-	xor	32(%rsp),%eax
-	and	%r11d,%ebx
-	add	%esi,%edi
-	xor	52(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,0(%rsp)
-	lea	0x5a827999(%eax,%edx),%esi
-	mov	4(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	12(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edx
-	xor	36(%rsp),%eax
-	and	%ebp,%ebx
-	add	%edx,%esi
-	xor	56(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,4(%rsp)
-	lea	0x5a827999(%eax,%r12d),%edx
-	mov	8(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	16(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%r12d
-	xor	40(%rsp),%eax
-	and	%edi,%ebx
-	add	%r12d,%edx
-	xor	60(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,8(%rsp)
-	lea	0x5a827999(%eax,%r11d),%r12d
-	mov	12(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	20(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%r11d
-	xor	44(%rsp),%eax
-	and	%esi,%ebx
-	add	%r11d,%r12d
-	xor	0(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,12(%rsp)
-	lea	0x5a827999(%eax,%ebp),%r11d
-	mov	16(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	24(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%ebp
-	xor	48(%rsp),%eax
-	and	%edx,%ebx
-	add	%ebp,%r11d
-	xor	4(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,16(%rsp)
-	lea	0x6ed9eba1(%eax,%edi),%ebp
-	mov	20(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	28(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	52(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	8(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,20(%rsp)
-	lea	0x6ed9eba1(%eax,%esi),%edi
-	mov	24(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	32(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	56(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	12(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,24(%rsp)
-	lea	0x6ed9eba1(%eax,%edx),%esi
-	mov	28(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	36(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	60(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	16(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,28(%rsp)
-	lea	0x6ed9eba1(%eax,%r12d),%edx
-	mov	32(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	40(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	0(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	20(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,32(%rsp)
-	lea	0x6ed9eba1(%eax,%r11d),%r12d
-	mov	36(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	44(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	4(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	24(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,36(%rsp)
-	lea	0x6ed9eba1(%eax,%ebp),%r11d
-	mov	40(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	48(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	8(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	28(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,40(%rsp)
-	lea	0x6ed9eba1(%eax,%edi),%ebp
-	mov	44(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	52(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	12(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	32(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,44(%rsp)
-	lea	0x6ed9eba1(%eax,%esi),%edi
-	mov	48(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	56(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	16(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	36(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,48(%rsp)
-	lea	0x6ed9eba1(%eax,%edx),%esi
-	mov	52(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	60(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	20(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	40(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,52(%rsp)
-	lea	0x6ed9eba1(%eax,%r12d),%edx
-	mov	56(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	0(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	24(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	44(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,56(%rsp)
-	lea	0x6ed9eba1(%eax,%r11d),%r12d
-	mov	60(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	4(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	28(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	48(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,60(%rsp)
-	lea	0x6ed9eba1(%eax,%ebp),%r11d
-	mov	0(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	8(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	32(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	52(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,0(%rsp)
-	lea	0x6ed9eba1(%eax,%edi),%ebp
-	mov	4(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	12(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	36(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	56(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,4(%rsp)
-	lea	0x6ed9eba1(%eax,%esi),%edi
-	mov	8(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	16(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	40(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	60(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,8(%rsp)
-	lea	0x6ed9eba1(%eax,%edx),%esi
-	mov	12(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	20(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	44(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	0(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,12(%rsp)
-	lea	0x6ed9eba1(%eax,%r12d),%edx
-	mov	16(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	24(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	48(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	4(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,16(%rsp)
-	lea	0x6ed9eba1(%eax,%r11d),%r12d
-	mov	20(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	28(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	52(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	8(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,20(%rsp)
-	lea	0x6ed9eba1(%eax,%ebp),%r11d
-	mov	24(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	32(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	56(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	12(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,24(%rsp)
-	lea	0x6ed9eba1(%eax,%edi),%ebp
-	mov	28(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	36(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	60(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	16(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,28(%rsp)
-	lea	0x6ed9eba1(%eax,%esi),%edi
-	mov	32(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	40(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	0(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	20(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,32(%rsp)
-	lea	-0x70e44324(%eax,%edx),%esi
-	mov	36(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%ebp,%ecx
-	xor	44(%rsp),%eax
-	mov	%edi,%edx
-	and	%r11d,%ebx
-	xor	4(%rsp),%eax
-	or	%r11d,%ecx
-	rol	$5,%edx
-	xor	24(%rsp),%eax
-	and	%r12d,%ecx
-	add	%edx,%esi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%ebp
-	mov	%eax,36(%rsp)
-	add	%ebx,%esi
-	lea	-0x70e44324(%eax,%r12d),%edx
-	mov	40(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edi,%ecx
-	xor	48(%rsp),%eax
-	mov	%esi,%r12d
-	and	%ebp,%ebx
-	xor	8(%rsp),%eax
-	or	%ebp,%ecx
-	rol	$5,%r12d
-	xor	28(%rsp),%eax
-	and	%r11d,%ecx
-	add	%r12d,%edx
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edi
-	mov	%eax,40(%rsp)
-	add	%ebx,%edx
-	lea	-0x70e44324(%eax,%r11d),%r12d
-	mov	44(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%esi,%ecx
-	xor	52(%rsp),%eax
-	mov	%edx,%r11d
-	and	%edi,%ebx
-	xor	12(%rsp),%eax
-	or	%edi,%ecx
-	rol	$5,%r11d
-	xor	32(%rsp),%eax
-	and	%ebp,%ecx
-	add	%r11d,%r12d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%esi
-	mov	%eax,44(%rsp)
-	add	%ebx,%r12d
-	lea	-0x70e44324(%eax,%ebp),%r11d
-	mov	48(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%edx,%ecx
-	xor	56(%rsp),%eax
-	mov	%r12d,%ebp
-	and	%esi,%ebx
-	xor	16(%rsp),%eax
-	or	%esi,%ecx
-	rol	$5,%ebp
-	xor	36(%rsp),%eax
-	and	%edi,%ecx
-	add	%ebp,%r11d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edx
-	mov	%eax,48(%rsp)
-	add	%ebx,%r11d
-	lea	-0x70e44324(%eax,%edi),%ebp
-	mov	52(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%r12d,%ecx
-	xor	60(%rsp),%eax
-	mov	%r11d,%edi
-	and	%edx,%ebx
-	xor	20(%rsp),%eax
-	or	%edx,%ecx
-	rol	$5,%edi
-	xor	40(%rsp),%eax
-	and	%esi,%ecx
-	add	%edi,%ebp
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r12d
-	mov	%eax,52(%rsp)
-	add	%ebx,%ebp
-	lea	-0x70e44324(%eax,%esi),%edi
-	mov	56(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%r11d,%ecx
-	xor	0(%rsp),%eax
-	mov	%ebp,%esi
-	and	%r12d,%ebx
-	xor	24(%rsp),%eax
-	or	%r12d,%ecx
-	rol	$5,%esi
-	xor	44(%rsp),%eax
-	and	%edx,%ecx
-	add	%esi,%edi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r11d
-	mov	%eax,56(%rsp)
-	add	%ebx,%edi
-	lea	-0x70e44324(%eax,%edx),%esi
-	mov	60(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%ebp,%ecx
-	xor	4(%rsp),%eax
-	mov	%edi,%edx
-	and	%r11d,%ebx
-	xor	28(%rsp),%eax
-	or	%r11d,%ecx
-	rol	$5,%edx
-	xor	48(%rsp),%eax
-	and	%r12d,%ecx
-	add	%edx,%esi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%ebp
-	mov	%eax,60(%rsp)
-	add	%ebx,%esi
-	lea	-0x70e44324(%eax,%r12d),%edx
-	mov	0(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edi,%ecx
-	xor	8(%rsp),%eax
-	mov	%esi,%r12d
-	and	%ebp,%ebx
-	xor	32(%rsp),%eax
-	or	%ebp,%ecx
-	rol	$5,%r12d
-	xor	52(%rsp),%eax
-	and	%r11d,%ecx
-	add	%r12d,%edx
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edi
-	mov	%eax,0(%rsp)
-	add	%ebx,%edx
-	lea	-0x70e44324(%eax,%r11d),%r12d
-	mov	4(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%esi,%ecx
-	xor	12(%rsp),%eax
-	mov	%edx,%r11d
-	and	%edi,%ebx
-	xor	36(%rsp),%eax
-	or	%edi,%ecx
-	rol	$5,%r11d
-	xor	56(%rsp),%eax
-	and	%ebp,%ecx
-	add	%r11d,%r12d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%esi
-	mov	%eax,4(%rsp)
-	add	%ebx,%r12d
-	lea	-0x70e44324(%eax,%ebp),%r11d
-	mov	8(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%edx,%ecx
-	xor	16(%rsp),%eax
-	mov	%r12d,%ebp
-	and	%esi,%ebx
-	xor	40(%rsp),%eax
-	or	%esi,%ecx
-	rol	$5,%ebp
-	xor	60(%rsp),%eax
-	and	%edi,%ecx
-	add	%ebp,%r11d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edx
-	mov	%eax,8(%rsp)
-	add	%ebx,%r11d
-	lea	-0x70e44324(%eax,%edi),%ebp
-	mov	12(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%r12d,%ecx
-	xor	20(%rsp),%eax
-	mov	%r11d,%edi
-	and	%edx,%ebx
-	xor	44(%rsp),%eax
-	or	%edx,%ecx
-	rol	$5,%edi
-	xor	0(%rsp),%eax
-	and	%esi,%ecx
-	add	%edi,%ebp
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r12d
-	mov	%eax,12(%rsp)
-	add	%ebx,%ebp
-	lea	-0x70e44324(%eax,%esi),%edi
-	mov	16(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%r11d,%ecx
-	xor	24(%rsp),%eax
-	mov	%ebp,%esi
-	and	%r12d,%ebx
-	xor	48(%rsp),%eax
-	or	%r12d,%ecx
-	rol	$5,%esi
-	xor	4(%rsp),%eax
-	and	%edx,%ecx
-	add	%esi,%edi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r11d
-	mov	%eax,16(%rsp)
-	add	%ebx,%edi
-	lea	-0x70e44324(%eax,%edx),%esi
-	mov	20(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%ebp,%ecx
-	xor	28(%rsp),%eax
-	mov	%edi,%edx
-	and	%r11d,%ebx
-	xor	52(%rsp),%eax
-	or	%r11d,%ecx
-	rol	$5,%edx
-	xor	8(%rsp),%eax
-	and	%r12d,%ecx
-	add	%edx,%esi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%ebp
-	mov	%eax,20(%rsp)
-	add	%ebx,%esi
-	lea	-0x70e44324(%eax,%r12d),%edx
-	mov	24(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edi,%ecx
-	xor	32(%rsp),%eax
-	mov	%esi,%r12d
-	and	%ebp,%ebx
-	xor	56(%rsp),%eax
-	or	%ebp,%ecx
-	rol	$5,%r12d
-	xor	12(%rsp),%eax
-	and	%r11d,%ecx
-	add	%r12d,%edx
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edi
-	mov	%eax,24(%rsp)
-	add	%ebx,%edx
-	lea	-0x70e44324(%eax,%r11d),%r12d
-	mov	28(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%esi,%ecx
-	xor	36(%rsp),%eax
-	mov	%edx,%r11d
-	and	%edi,%ebx
-	xor	60(%rsp),%eax
-	or	%edi,%ecx
-	rol	$5,%r11d
-	xor	16(%rsp),%eax
-	and	%ebp,%ecx
-	add	%r11d,%r12d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%esi
-	mov	%eax,28(%rsp)
-	add	%ebx,%r12d
-	lea	-0x70e44324(%eax,%ebp),%r11d
-	mov	32(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%edx,%ecx
-	xor	40(%rsp),%eax
-	mov	%r12d,%ebp
-	and	%esi,%ebx
-	xor	0(%rsp),%eax
-	or	%esi,%ecx
-	rol	$5,%ebp
-	xor	20(%rsp),%eax
-	and	%edi,%ecx
-	add	%ebp,%r11d
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edx
-	mov	%eax,32(%rsp)
-	add	%ebx,%r11d
-	lea	-0x70e44324(%eax,%edi),%ebp
-	mov	36(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%r12d,%ecx
-	xor	44(%rsp),%eax
-	mov	%r11d,%edi
-	and	%edx,%ebx
-	xor	4(%rsp),%eax
-	or	%edx,%ecx
-	rol	$5,%edi
-	xor	24(%rsp),%eax
-	and	%esi,%ecx
-	add	%edi,%ebp
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r12d
-	mov	%eax,36(%rsp)
-	add	%ebx,%ebp
-	lea	-0x70e44324(%eax,%esi),%edi
-	mov	40(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%r11d,%ecx
-	xor	48(%rsp),%eax
-	mov	%ebp,%esi
-	and	%r12d,%ebx
-	xor	8(%rsp),%eax
-	or	%r12d,%ecx
-	rol	$5,%esi
-	xor	28(%rsp),%eax
-	and	%edx,%ecx
-	add	%esi,%edi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%r11d
-	mov	%eax,40(%rsp)
-	add	%ebx,%edi
-	lea	-0x70e44324(%eax,%edx),%esi
-	mov	44(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%ebp,%ecx
-	xor	52(%rsp),%eax
-	mov	%edi,%edx
-	and	%r11d,%ebx
-	xor	12(%rsp),%eax
-	or	%r11d,%ecx
-	rol	$5,%edx
-	xor	32(%rsp),%eax
-	and	%r12d,%ecx
-	add	%edx,%esi
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%ebp
-	mov	%eax,44(%rsp)
-	add	%ebx,%esi
-	lea	-0x70e44324(%eax,%r12d),%edx
-	mov	48(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edi,%ecx
-	xor	56(%rsp),%eax
-	mov	%esi,%r12d
-	and	%ebp,%ebx
-	xor	16(%rsp),%eax
-	or	%ebp,%ecx
-	rol	$5,%r12d
-	xor	36(%rsp),%eax
-	and	%r11d,%ecx
-	add	%r12d,%edx
-	rol	$1,%eax
-	or	%ecx,%ebx
-	rol	$30,%edi
-	mov	%eax,48(%rsp)
-	add	%ebx,%edx
-	lea	-0x359d3e2a(%eax,%r11d),%r12d
-	mov	52(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	60(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	20(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	40(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,52(%rsp)
-	lea	-0x359d3e2a(%eax,%ebp),%r11d
-	mov	56(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	0(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	24(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	44(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,56(%rsp)
-	lea	-0x359d3e2a(%eax,%edi),%ebp
-	mov	60(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	4(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	28(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	48(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,60(%rsp)
-	lea	-0x359d3e2a(%eax,%esi),%edi
-	mov	0(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	8(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	32(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	52(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,0(%rsp)
-	lea	-0x359d3e2a(%eax,%edx),%esi
-	mov	4(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	12(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	36(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	56(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,4(%rsp)
-	lea	-0x359d3e2a(%eax,%r12d),%edx
-	mov	8(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	16(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	40(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	60(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,8(%rsp)
-	lea	-0x359d3e2a(%eax,%r11d),%r12d
-	mov	12(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	20(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	44(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	0(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,12(%rsp)
-	lea	-0x359d3e2a(%eax,%ebp),%r11d
-	mov	16(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	24(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	48(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	4(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,16(%rsp)
-	lea	-0x359d3e2a(%eax,%edi),%ebp
-	mov	20(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	28(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	52(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	8(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,20(%rsp)
-	lea	-0x359d3e2a(%eax,%esi),%edi
-	mov	24(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	32(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	56(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	12(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,24(%rsp)
-	lea	-0x359d3e2a(%eax,%edx),%esi
-	mov	28(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	36(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	60(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	16(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	mov	%eax,28(%rsp)
-	lea	-0x359d3e2a(%eax,%r12d),%edx
-	mov	32(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	40(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	0(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	20(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	mov	%eax,32(%rsp)
-	lea	-0x359d3e2a(%eax,%r11d),%r12d
-	mov	36(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	44(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	4(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	24(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	mov	%eax,36(%rsp)
-	lea	-0x359d3e2a(%eax,%ebp),%r11d
-	mov	40(%rsp),%eax
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	48(%rsp),%eax
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	8(%rsp),%eax
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	xor	28(%rsp),%eax
-	rol	$30,%edx
-	add	%ebx,%r11d
-	rol	$1,%eax
-	mov	%eax,40(%rsp)
-	lea	-0x359d3e2a(%eax,%edi),%ebp
-	mov	44(%rsp),%eax
-	mov	%edx,%ebx
-	mov	%r11d,%edi
-	xor	52(%rsp),%eax
-	xor	%r12d,%ebx
-	rol	$5,%edi
-	xor	12(%rsp),%eax
-	xor	%esi,%ebx
-	add	%edi,%ebp
-	xor	32(%rsp),%eax
-	rol	$30,%r12d
-	add	%ebx,%ebp
-	rol	$1,%eax
-	mov	%eax,44(%rsp)
-	lea	-0x359d3e2a(%eax,%esi),%edi
-	mov	48(%rsp),%eax
-	mov	%r12d,%ebx
-	mov	%ebp,%esi
-	xor	56(%rsp),%eax
-	xor	%r11d,%ebx
-	rol	$5,%esi
-	xor	16(%rsp),%eax
-	xor	%edx,%ebx
-	add	%esi,%edi
-	xor	36(%rsp),%eax
-	rol	$30,%r11d
-	add	%ebx,%edi
-	rol	$1,%eax
-	mov	%eax,48(%rsp)
-	lea	-0x359d3e2a(%eax,%edx),%esi
-	mov	52(%rsp),%eax
-	mov	%r11d,%ebx
-	mov	%edi,%edx
-	xor	60(%rsp),%eax
-	xor	%ebp,%ebx
-	rol	$5,%edx
-	xor	20(%rsp),%eax
-	xor	%r12d,%ebx
-	add	%edx,%esi
-	xor	40(%rsp),%eax
-	rol	$30,%ebp
-	add	%ebx,%esi
-	rol	$1,%eax
-	lea	-0x359d3e2a(%eax,%r12d),%edx
-	mov	56(%rsp),%eax
-	mov	%ebp,%ebx
-	mov	%esi,%r12d
-	xor	0(%rsp),%eax
-	xor	%edi,%ebx
-	rol	$5,%r12d
-	xor	24(%rsp),%eax
-	xor	%r11d,%ebx
-	add	%r12d,%edx
-	xor	44(%rsp),%eax
-	rol	$30,%edi
-	add	%ebx,%edx
-	rol	$1,%eax
-	lea	-0x359d3e2a(%eax,%r11d),%r12d
-	mov	60(%rsp),%eax
-	mov	%edi,%ebx
-	mov	%edx,%r11d
-	xor	4(%rsp),%eax
-	xor	%esi,%ebx
-	rol	$5,%r11d
-	xor	28(%rsp),%eax
-	xor	%ebp,%ebx
-	add	%r11d,%r12d
-	xor	48(%rsp),%eax
-	rol	$30,%esi
-	add	%ebx,%r12d
-	rol	$1,%eax
-	lea	-0x359d3e2a(%eax,%ebp),%r11d
-	mov	%esi,%ebx
-	mov	%r12d,%ebp
-	xor	%edx,%ebx
-	rol	$5,%ebp
-	xor	%edi,%ebx
-	add	%ebp,%r11d
-	rol	$30,%edx
-	add	%ebx,%r11d
-	// Update and save state information in SHA-1 context
-	add	0(%r8),%r11d
-	add	4(%r8),%r12d
-	add	8(%r8),%edx
-	add	12(%r8),%esi
-	add	16(%r8),%edi
-	mov	%r11d,0(%r8)
-	mov	%r12d,4(%r8)
-	mov	%edx,8(%r8)
-	mov	%esi,12(%r8)
-	mov	%edi,16(%r8)
-
-	xchg	%r11d,%edx	# mov	%r11d,%edx
-	xchg	%r12d,%esi	# mov	%r12d,%esi
-	xchg	%r11d,%edi	# mov	%edx,%edi
-	xchg	%r12d,%ebp	# mov	%esi,%ebp
-			# mov	%edi,%r11d
-	lea	64(%r9),%r9
-	sub	$1,%r10
-	jnz	.Lloop
-	mov	64(%rsp),%rsp
-.cfi_def_cfa	%rsp,8
-	movq	-24(%rsp),%r12
-.cfi_restore	%r12
-	movq	-16(%rsp),%rbp
-.cfi_restore	%rbp
-	movq	-8(%rsp),%rbx
-.cfi_restore	%rbx
-	ret
-.cfi_endproc
-SET_SIZE(sha1_block_data_order)
-
-.data
-.asciz	"SHA1 block transform for x86_64, CRYPTOGAMS by <appro@openssl.org>"
-
-#endif /* lint || __lint */
-
-#ifdef __ELF__
-.section .note.GNU-stack,"",%progbits
-#endif
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha256_impl.S b/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha256_impl.S
index 28b048d2db24..951297c72ff8 100644
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha256_impl.S
+++ b/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha256_impl.S
@@ -71,10 +71,10 @@
 #include <sys/stdint.h>
 #include <sha2/sha2.h>
 
-/* ARGSUSED */
 void
 SHA256TransformBlocks(SHA2_CTX *ctx, const void *in, size_t num)
 {
+	(void) ctx, (void) in, (void) num;
 }
 
 
@@ -2062,7 +2062,7 @@ ENTRY_NP(SHA256TransformBlocks)
 .cfi_endproc
 SET_SIZE(SHA256TransformBlocks)
 
-.data
+.section .rodata
 .align	64
 .type	K256,@object
 K256:
diff --git a/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha512_impl.S b/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha512_impl.S
index 746c85a98566..921d3d8cddae 100644
--- a/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha512_impl.S
+++ b/sys/contrib/openzfs/module/icp/asm-x86_64/sha2/sha512_impl.S
@@ -72,10 +72,10 @@
 #include <sys/stdint.h>
 #include <sha2/sha2.h>
 
-/* ARGSUSED */
 void
 SHA512TransformBlocks(SHA2_CTX *ctx, const void *in, size_t num)
 {
+	(void) ctx, (void) in, (void) num;
 }
 
 
@@ -2063,7 +2063,7 @@ ENTRY_NP(SHA512TransformBlocks)
 .cfi_endproc
 SET_SIZE(SHA512TransformBlocks)
 
-.data
+.section .rodata
 .align	64
 .type	K512,@object
 K512:
diff --git a/sys/contrib/openzfs/module/icp/core/kcf_callprov.c b/sys/contrib/openzfs/module/icp/core/kcf_callprov.c
index fd2f7e1aac3d..345014d0a1e4 100644
--- a/sys/contrib/openzfs/module/icp/core/kcf_callprov.c
+++ b/sys/contrib/openzfs/module/icp/core/kcf_callprov.c
@@ -116,7 +116,7 @@ kcf_get_hardware_provider(crypto_mech_type_t mech_type_1,
 	kcf_provider_list_t *p;
 	kcf_ops_class_t class;
 	kcf_mech_entry_t *me;
-	kcf_mech_entry_tab_t *me_tab;
+	const kcf_mech_entry_tab_t *me_tab;
 	int index, len, gqlen = INT_MAX, rv = CRYPTO_SUCCESS;
 
 	/* get the mech entry for the specified mechanism */
@@ -258,7 +258,7 @@ kcf_get_mech_provider(crypto_mech_type_t mech_type, kcf_mech_entry_t **mepp,
 	kcf_ops_class_t class;
 	int index;
 	kcf_mech_entry_t *me;
-	kcf_mech_entry_tab_t *me_tab;
+	const kcf_mech_entry_tab_t *me_tab;
 
 	class = KCF_MECH2CLASS(mech_type);
 	if ((class < KCF_FIRST_OPSCLASS) || (class > KCF_LAST_OPSCLASS)) {
diff --git a/sys/contrib/openzfs/module/icp/core/kcf_mech_tabs.c b/sys/contrib/openzfs/module/icp/core/kcf_mech_tabs.c
index 2642b317d698..60055e78af68 100644
--- a/sys/contrib/openzfs/module/icp/core/kcf_mech_tabs.c
+++ b/sys/contrib/openzfs/module/icp/core/kcf_mech_tabs.c
@@ -82,14 +82,14 @@
 
 /* RFE 4687834 Will deal with the extensibility of these tables later */
 
-kcf_mech_entry_t kcf_digest_mechs_tab[KCF_MAXDIGEST];
-kcf_mech_entry_t kcf_cipher_mechs_tab[KCF_MAXCIPHER];
-kcf_mech_entry_t kcf_mac_mechs_tab[KCF_MAXMAC];
-kcf_mech_entry_t kcf_sign_mechs_tab[KCF_MAXSIGN];
-kcf_mech_entry_t kcf_keyops_mechs_tab[KCF_MAXKEYOPS];
-kcf_mech_entry_t kcf_misc_mechs_tab[KCF_MAXMISC];
-
-kcf_mech_entry_tab_t kcf_mech_tabs_tab[KCF_LAST_OPSCLASS + 1] = {
+static kcf_mech_entry_t kcf_digest_mechs_tab[KCF_MAXDIGEST];
+static kcf_mech_entry_t kcf_cipher_mechs_tab[KCF_MAXCIPHER];
+static kcf_mech_entry_t kcf_mac_mechs_tab[KCF_MAXMAC];
+static kcf_mech_entry_t kcf_sign_mechs_tab[KCF_MAXSIGN];
+static kcf_mech_entry_t kcf_keyops_mechs_tab[KCF_MAXKEYOPS];
+static kcf_mech_entry_t kcf_misc_mechs_tab[KCF_MAXMISC];
+
+const kcf_mech_entry_tab_t kcf_mech_tabs_tab[KCF_LAST_OPSCLASS + 1] = {
 	{0, NULL},				/* No class zero */
 	{KCF_MAXDIGEST, kcf_digest_mechs_tab},
 	{KCF_MAXCIPHER, kcf_cipher_mechs_tab},
@@ -108,22 +108,22 @@ kcf_mech_entry_tab_t kcf_mech_tabs_tab[KCF_LAST_OPSCLASS + 1] = {
  * There is room for refinement here.
  *
  */
-int kcf_md5_threshold = 512;
-int kcf_sha1_threshold = 512;
-int kcf_des_threshold = 512;
-int kcf_des3_threshold = 512;
-int kcf_aes_threshold = 512;
-int kcf_bf_threshold = 512;
-int kcf_rc4_threshold = 512;
-
-kmutex_t kcf_mech_tabs_lock;
+static const int kcf_md5_threshold = 512;
+static const int kcf_sha1_threshold = 512;
+static const int kcf_des_threshold = 512;
+static const int kcf_des3_threshold = 512;
+static const int kcf_aes_threshold = 512;
+static const int kcf_bf_threshold = 512;
+static const int kcf_rc4_threshold = 512;
+
+static kmutex_t kcf_mech_tabs_lock;
 static uint32_t kcf_gen_swprov = 0;
 
-int kcf_mech_hash_size = 256;
-mod_hash_t *kcf_mech_hash;	/* mech name to id hash */
+static const int kcf_mech_hash_size = 256;
+static mod_hash_t *kcf_mech_hash;	/* mech name to id hash */
 
 static crypto_mech_type_t
-kcf_mech_hash_find(char *mechname)
+kcf_mech_hash_find(const char *mechname)
 {
 	mod_hash_val_t hv;
 	crypto_mech_type_t mt;
@@ -166,7 +166,6 @@ kcf_destroy_mech_tabs(void)
 void
 kcf_init_mech_tabs(void)
 {
-	int i, max;
 	kcf_ops_class_t class;
 	kcf_mech_entry_t *me_tab;
 
@@ -249,9 +248,9 @@ kcf_init_mech_tabs(void)
 	    kcf_mech_hash_size, mod_hash_null_valdtor);
 
 	for (class = KCF_FIRST_OPSCLASS; class <= KCF_LAST_OPSCLASS; class++) {
-		max = kcf_mech_tabs_tab[class].met_size;
+		int max = kcf_mech_tabs_tab[class].met_size;
 		me_tab = kcf_mech_tabs_tab[class].met_tab;
-		for (i = 0; i < max; i++) {
+		for (int i = 0; i < max; i++) {
 			mutex_init(&(me_tab[i].me_mutex), NULL,
 			    MUTEX_DEFAULT, NULL);
 			if (me_tab[i].me_name[0] != 0) {
@@ -747,7 +746,7 @@ kcf_get_mech_entry(crypto_mech_type_t mech_type, kcf_mech_entry_t **mep)
 {
 	kcf_ops_class_t		class;
 	int			index;
-	kcf_mech_entry_tab_t	*me_tab;
+	const kcf_mech_entry_tab_t	*me_tab;
 
 	ASSERT(mep != NULL);
 
@@ -776,16 +775,10 @@ kcf_get_mech_entry(crypto_mech_type_t mech_type, kcf_mech_entry_t **mep)
  * If there are no hardware or software providers for the mechanism,
  * but there is an unloaded software provider, this routine will attempt
  * to load it.
- *
- * If the MOD_NOAUTOUNLOAD flag is not set, a software provider is
- * in constant danger of being unloaded.  For consumers that call
- * crypto_mech2id() only once, the provider will not be reloaded
- * if it becomes unloaded.  If a provider gets loaded elsewhere
- * without the MOD_NOAUTOUNLOAD flag being set, we set it now.
  */
 crypto_mech_type_t
-crypto_mech2id_common(char *mechname, boolean_t load_module)
+crypto_mech2id_common(const char *mechname, boolean_t load_module)
 {
-	crypto_mech_type_t mt = kcf_mech_hash_find(mechname);
-	return (mt);
+	(void) load_module;
+	return (kcf_mech_hash_find(mechname));
 }
diff --git a/sys/contrib/openzfs/module/icp/core/kcf_prov_lib.c b/sys/contrib/openzfs/module/icp/core/kcf_prov_lib.c
index 1b115d976232..6e8853c56dc6 100644
--- a/sys/contrib/openzfs/module/icp/core/kcf_prov_lib.c
+++ b/sys/contrib/openzfs/module/icp/core/kcf_prov_lib.c
@@ -40,6 +40,7 @@ int
 crypto_uio_data(crypto_data_t *data, uchar_t *buf, int len, cmd_type_t cmd,
     void *digest_ctx, void (*update)(void))
 {
+	(void) digest_ctx, (void) update;
 	zfs_uio_t *uiop = data->cd_uio;
 	off_t offset = data->cd_offset;
 	size_t length = len;
diff --git a/sys/contrib/openzfs/module/icp/core/kcf_prov_tabs.c b/sys/contrib/openzfs/module/icp/core/kcf_prov_tabs.c
index 9d303d022517..664e96da9c28 100644
--- a/sys/contrib/openzfs/module/icp/core/kcf_prov_tabs.c
+++ b/sys/contrib/openzfs/module/icp/core/kcf_prov_tabs.c
@@ -205,7 +205,8 @@ kcf_prov_tab_lookup(crypto_provider_id_t prov_id)
 }
 
 static void
-allocate_ops_v1(crypto_ops_t *src, crypto_ops_t *dst, uint_t *mech_list_count)
+allocate_ops_v1(const crypto_ops_t *src, crypto_ops_t *dst,
+    uint_t *mech_list_count)
 {
 	if (src->co_control_ops != NULL)
 		dst->co_control_ops = kmem_alloc(sizeof (crypto_control_ops_t),
@@ -274,7 +275,7 @@ allocate_ops_v1(crypto_ops_t *src, crypto_ops_t *dst, uint_t *mech_list_count)
 }
 
 static void
-allocate_ops_v2(crypto_ops_t *src, crypto_ops_t *dst)
+allocate_ops_v2(const crypto_ops_t *src, crypto_ops_t *dst)
 {
 	if (src->co_mech_ops != NULL)
 		dst->co_mech_ops = kmem_alloc(sizeof (crypto_mech_ops_t),
@@ -282,7 +283,7 @@ allocate_ops_v2(crypto_ops_t *src, crypto_ops_t *dst)
 }
 
 static void
-allocate_ops_v3(crypto_ops_t *src, crypto_ops_t *dst)
+allocate_ops_v3(const crypto_ops_t *src, crypto_ops_t *dst)
 {
 	if (src->co_nostore_key_ops != NULL)
 		dst->co_nostore_key_ops =
@@ -297,12 +298,11 @@ allocate_ops_v3(crypto_ops_t *src, crypto_ops_t *dst)
  * since it is invoked from user context during provider registration.
  */
 kcf_provider_desc_t *
-kcf_alloc_provider_desc(crypto_provider_info_t *info)
+kcf_alloc_provider_desc(const crypto_provider_info_t *info)
 {
-	int i, j;
 	kcf_provider_desc_t *desc;
 	uint_t mech_list_count = info->pi_mech_list_count;
-	crypto_ops_t *src_ops = info->pi_ops_vector;
+	const crypto_ops_t *src_ops = info->pi_ops_vector;
 
 	desc = kmem_zalloc(sizeof (kcf_provider_desc_t), KM_SLEEP);
 
@@ -330,21 +330,22 @@ kcf_alloc_provider_desc(crypto_provider_info_t *info)
 	 * KCF needs to allocate storage where copies of the ops
 	 * vectors are copied.
 	 */
-	desc->pd_ops_vector = kmem_zalloc(sizeof (crypto_ops_t), KM_SLEEP);
+	crypto_ops_t *opvec = kmem_zalloc(sizeof (crypto_ops_t), KM_SLEEP);
 
 	if (info->pi_provider_type != CRYPTO_LOGICAL_PROVIDER) {
-		allocate_ops_v1(src_ops, desc->pd_ops_vector, &mech_list_count);
+		allocate_ops_v1(src_ops, opvec, &mech_list_count);
 		if (info->pi_interface_version >= CRYPTO_SPI_VERSION_2)
-			allocate_ops_v2(src_ops, desc->pd_ops_vector);
+			allocate_ops_v2(src_ops, opvec);
 		if (info->pi_interface_version == CRYPTO_SPI_VERSION_3)
-			allocate_ops_v3(src_ops, desc->pd_ops_vector);
+			allocate_ops_v3(src_ops, opvec);
 	}
+	desc->pd_ops_vector = opvec;
 
 	desc->pd_mech_list_count = mech_list_count;
 	desc->pd_mechanisms = kmem_zalloc(sizeof (crypto_mech_info_t) *
 	    mech_list_count, KM_SLEEP);
-	for (i = 0; i < KCF_OPS_CLASSSIZE; i++)
-		for (j = 0; j < KCF_MAXMECHTAB; j++)
+	for (int i = 0; i < KCF_OPS_CLASSSIZE; i++)
+		for (int j = 0; j < KCF_MAXMECHTAB; j++)
 			desc->pd_mech_indx[i][j] = KCF_INVALID_INDX;
 
 	desc->pd_prov_id = KCF_PROVID_INVALID;
diff --git a/sys/contrib/openzfs/module/icp/core/kcf_sched.c b/sys/contrib/openzfs/module/icp/core/kcf_sched.c
index 81fd15f8ea26..062e96059f20 100644
--- a/sys/contrib/openzfs/module/icp/core/kcf_sched.c
+++ b/sys/contrib/openzfs/module/icp/core/kcf_sched.c
@@ -35,15 +35,12 @@
 #include <sys/crypto/sched_impl.h>
 #include <sys/crypto/api.h>
 
-kcf_global_swq_t *gswq;	/* Global software queue */
+static kcf_global_swq_t *gswq;	/* Global software queue */
 
 /* Thread pool related variables */
 static kcf_pool_t *kcfpool;	/* Thread pool of kcfd LWPs */
-int kcf_maxthreads = 2;
-int kcf_minthreads = 1;
-int kcf_thr_multiple = 2;	/* Boot-time tunable for experimentation */
-static ulong_t	kcf_idlethr_timeout;
-#define	KCF_DEFAULT_THRTIMEOUT	60000000	/* 60 seconds */
+static const int kcf_maxthreads = 2;
+static const int kcf_minthreads = 1;
 
 /* kmem caches used by the scheduler */
 static kmem_cache_t *kcf_sreq_cache;
@@ -970,10 +967,10 @@ kcf_enqueue(kcf_areq_node_t *node)
 /*
  * kmem_cache_alloc constructor for sync request structure.
  */
-/* ARGSUSED */
 static int
 kcf_sreq_cache_constructor(void *buf, void *cdrarg, int kmflags)
 {
+	(void) cdrarg, (void) kmflags;
 	kcf_sreq_node_t *sreq = (kcf_sreq_node_t *)buf;
 
 	sreq->sn_type = CRYPTO_SYNCH;
@@ -983,10 +980,10 @@ kcf_sreq_cache_constructor(void *buf, void *cdrarg, int kmflags)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 kcf_sreq_cache_destructor(void *buf, void *cdrarg)
 {
+	(void) cdrarg;
 	kcf_sreq_node_t *sreq = (kcf_sreq_node_t *)buf;
 
 	mutex_destroy(&sreq->sn_lock);
@@ -996,10 +993,10 @@ kcf_sreq_cache_destructor(void *buf, void *cdrarg)
 /*
  * kmem_cache_alloc constructor for async request structure.
  */
-/* ARGSUSED */
 static int
 kcf_areq_cache_constructor(void *buf, void *cdrarg, int kmflags)
 {
+	(void) cdrarg, (void) kmflags;
 	kcf_areq_node_t *areq = (kcf_areq_node_t *)buf;
 
 	areq->an_type = CRYPTO_ASYNCH;
@@ -1011,10 +1008,10 @@ kcf_areq_cache_constructor(void *buf, void *cdrarg, int kmflags)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 kcf_areq_cache_destructor(void *buf, void *cdrarg)
 {
+	(void) cdrarg;
 	kcf_areq_node_t *areq = (kcf_areq_node_t *)buf;
 
 	ASSERT(areq->an_refcnt == 0);
@@ -1026,10 +1023,10 @@ kcf_areq_cache_destructor(void *buf, void *cdrarg)
 /*
  * kmem_cache_alloc constructor for kcf_context structure.
  */
-/* ARGSUSED */
 static int
 kcf_context_cache_constructor(void *buf, void *cdrarg, int kmflags)
 {
+	(void) cdrarg, (void) kmflags;
 	kcf_context_t *kctx = (kcf_context_t *)buf;
 
 	kctx->kc_refcnt = 0;
@@ -1038,10 +1035,10 @@ kcf_context_cache_constructor(void *buf, void *cdrarg, int kmflags)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 kcf_context_cache_destructor(void *buf, void *cdrarg)
 {
+	(void) cdrarg;
 	kcf_context_t *kctx = (kcf_context_t *)buf;
 
 	ASSERT(kctx->kc_refcnt == 0);
@@ -1289,8 +1286,6 @@ kcfpool_alloc()
 
 	mutex_init(&kcfpool->kp_user_lock, NULL, MUTEX_DEFAULT, NULL);
 	cv_init(&kcfpool->kp_user_cv, NULL, CV_DEFAULT, NULL);
-
-	kcf_idlethr_timeout = KCF_DEFAULT_THRTIMEOUT;
 }
 
 /*
diff --git a/sys/contrib/openzfs/module/icp/illumos-crypto.c b/sys/contrib/openzfs/module/icp/illumos-crypto.c
index 3c5ef4393940..5b2820220f2c 100644
--- a/sys/contrib/openzfs/module/icp/illumos-crypto.c
+++ b/sys/contrib/openzfs/module/icp/illumos-crypto.c
@@ -61,16 +61,15 @@
  * the future it may make sense to have encryption algorithms that are
  * loadable into the ICP at runtime via separate kernel modules.
  * However, considering that this code will probably not see much use
- * outside of zfs and zfs encryption only requires aes and sha256
+ * outside of zfs and zfs encryption only requires a select few
  * algorithms it seemed like more trouble than it was worth to port over
  * Illumos's kernel module structure to a Linux kernel module. In
  * addition, The Illumos code related to keeping track of kernel modules
- * is very much tied to the Illumos OS and proved difficult to port to
- * Linux. Therefore, the structure of the ICP was simplified to work
- * statically and several pieces of code responsible for keeping track
- * of Illumos kernel modules were removed and simplified. All module
- * initialization and destruction is now called in this file during
- * Linux kernel module loading and unloading.
+ * is very much tied to the Illumos OS and proved difficult to port.
+ * Therefore, the structure of the ICP was simplified to work
+ * statically and all the Illumos kernel module loading subsystem was removed.
+ * All module initialization and destruction is now called in this file
+ * during kernel module loading and unloading.
  *
  * 4) Adding destructors: The Illumos Crypto Layer is built into
  * the Illumos kernel and is not meant to be unloaded. Some destructors
@@ -111,8 +110,6 @@ icp_fini(void)
 {
 	skein_mod_fini();
 	sha2_mod_fini();
-	sha1_mod_fini();
-	edonr_mod_fini();
 	aes_mod_fini();
 	kcf_sched_destroy();
 	kcf_prov_tab_destroy();
@@ -141,8 +138,6 @@ icp_init(void)
 
 	/* initialize algorithms */
 	aes_mod_init();
-	edonr_mod_init();
-	sha1_mod_init();
 	sha2_mod_init();
 	skein_mod_init();
 
diff --git a/sys/contrib/openzfs/module/icp/include/sha1/sha1.h b/sys/contrib/openzfs/module/icp/include/sha1/sha1.h
deleted file mode 100644
index 251b64fcaeee..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sha1/sha1.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef _SYS_SHA1_H
-#define	_SYS_SHA1_H
-
-#include <sys/types.h>		/* for uint_* */
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-/*
- * NOTE: n2rng (Niagara2 RNG driver) accesses the state field of
- * SHA1_CTX directly.  NEVER change this structure without verifying
- * compatibility with n2rng.  The important thing is that the state
- * must be in a field declared as uint32_t state[5].
- */
-/* SHA-1 context. */
-typedef struct 	{
-	uint32_t state[5];	/* state (ABCDE) */
-	uint32_t count[2];	/* number of bits, modulo 2^64 (msb first) */
-	union 	{
-		uint8_t		buf8[64];	/* undigested input */
-		uint32_t	buf32[16];	/* realigned input */
-	} buf_un;
-} SHA1_CTX;
-
-#define	SHA1_DIGEST_LENGTH 20
-
-void SHA1Init(SHA1_CTX *);
-void SHA1Update(SHA1_CTX *, const void *, size_t);
-void SHA1Final(void *, SHA1_CTX *);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* _SYS_SHA1_H */
diff --git a/sys/contrib/openzfs/module/icp/include/sha1/sha1_consts.h b/sys/contrib/openzfs/module/icp/include/sha1/sha1_consts.h
deleted file mode 100644
index 848d25ef050f..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sha1/sha1_consts.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright (c) 1998, by Sun Microsystems, Inc.
- * All rights reserved.
- */
-
-#ifndef	_SYS_SHA1_CONSTS_H
-#define	_SYS_SHA1_CONSTS_H
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-/*
- * as explained in sha1.c, loading 32-bit constants on a sparc is expensive
- * since it involves both a `sethi' and an `or'.  thus, we instead use `ld'
- * to load the constants from an array called `sha1_consts'.  however, on
- * intel (and perhaps other processors), it is cheaper to load the constant
- * directly.  thus, the c code in SHA1Transform() uses the macro SHA1_CONST()
- * which either expands to a constant or an array reference, depending on
- * the architecture the code is being compiled for.
- */
-
-#include <sys/types.h>		/* uint32_t */
-
-extern	const uint32_t	sha1_consts[];
-
-#if	defined(__sparc)
-#define	SHA1_CONST(x)		(sha1_consts[x])
-#else
-#define	SHA1_CONST(x)		(SHA1_CONST_ ## x)
-#endif
-
-/* constants, as provided in FIPS 180-1 */
-
-#define	SHA1_CONST_0		0x5a827999U
-#define	SHA1_CONST_1		0x6ed9eba1U
-#define	SHA1_CONST_2		0x8f1bbcdcU
-#define	SHA1_CONST_3		0xca62c1d6U
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* _SYS_SHA1_CONSTS_H */
diff --git a/sys/contrib/openzfs/module/icp/include/sha1/sha1_impl.h b/sys/contrib/openzfs/module/icp/include/sha1/sha1_impl.h
deleted file mode 100644
index 1c1f8728f9b5..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sha1/sha1_impl.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef	_SHA1_IMPL_H
-#define	_SHA1_IMPL_H
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define	SHA1_HASH_SIZE		20	/* SHA_1 digest length in bytes */
-#define	SHA1_DIGEST_LENGTH	20	/* SHA1 digest length in bytes */
-#define	SHA1_HMAC_BLOCK_SIZE	64	/* SHA1-HMAC block size */
-#define	SHA1_HMAC_MIN_KEY_LEN	1	/* SHA1-HMAC min key length in bytes */
-#define	SHA1_HMAC_MAX_KEY_LEN	INT_MAX /* SHA1-HMAC max key length in bytes */
-#define	SHA1_HMAC_INTS_PER_BLOCK	(SHA1_HMAC_BLOCK_SIZE/sizeof (uint32_t))
-
-/*
- * CSPI information (entry points, provider info, etc.)
- */
-typedef enum sha1_mech_type {
-	SHA1_MECH_INFO_TYPE,		/* SUN_CKM_SHA1 */
-	SHA1_HMAC_MECH_INFO_TYPE,	/* SUN_CKM_SHA1_HMAC */
-	SHA1_HMAC_GEN_MECH_INFO_TYPE	/* SUN_CKM_SHA1_HMAC_GENERAL */
-} sha1_mech_type_t;
-
-/*
- * Context for SHA1 mechanism.
- */
-typedef struct sha1_ctx {
-	sha1_mech_type_t	sc_mech_type;	/* type of context */
-	SHA1_CTX		sc_sha1_ctx;	/* SHA1 context */
-} sha1_ctx_t;
-
-/*
- * Context for SHA1-HMAC and SHA1-HMAC-GENERAL mechanisms.
- */
-typedef struct sha1_hmac_ctx {
-	sha1_mech_type_t	hc_mech_type;	/* type of context */
-	uint32_t		hc_digest_len;	/* digest len in bytes */
-	SHA1_CTX		hc_icontext;	/* inner SHA1 context */
-	SHA1_CTX		hc_ocontext;	/* outer SHA1 context */
-} sha1_hmac_ctx_t;
-
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* _SHA1_IMPL_H */
diff --git a/sys/contrib/openzfs/module/icp/include/sys/crypto/impl.h b/sys/contrib/openzfs/module/icp/include/sys/crypto/impl.h
index 0f37f3f63532..4906549b5687 100644
--- a/sys/contrib/openzfs/module/icp/include/sys/crypto/impl.h
+++ b/sys/contrib/openzfs/module/icp/include/sys/crypto/impl.h
@@ -34,7 +34,6 @@
 #include <sys/crypto/common.h>
 #include <sys/crypto/api.h>
 #include <sys/crypto/spi.h>
-#include <sys/crypto/ioctl.h>
 
 #ifdef	__cplusplus
 extern "C" {
@@ -211,7 +210,7 @@ typedef struct kcf_provider_desc {
 	struct kcf_provider_list	*pd_provider_list;
 	kcondvar_t			pd_resume_cv;
 	crypto_provider_handle_t	pd_prov_handle;
-	crypto_ops_t			*pd_ops_vector;
+	const crypto_ops_t			*pd_ops_vector;
 	ushort_t			pd_mech_indx[KCF_OPS_CLASSSIZE]\
 					    [KCF_MAXMECHTAB];
 	crypto_mech_info_t		*pd_mechanisms;
@@ -398,19 +397,6 @@ extern kcf_soft_conf_entry_t *soft_config_list;
 #define	KCF_MAXKEYOPS		116	/* Key generation and derivation */
 #define	KCF_MAXMISC		16	/* Others ... */
 
-#define	KCF_MAXMECHS		KCF_MAXDIGEST + KCF_MAXCIPHER + KCF_MAXMAC + \
-				KCF_MAXSIGN + KCF_MAXKEYOPS + \
-				KCF_MAXMISC
-
-extern kcf_mech_entry_t kcf_digest_mechs_tab[];
-extern kcf_mech_entry_t kcf_cipher_mechs_tab[];
-extern kcf_mech_entry_t kcf_mac_mechs_tab[];
-extern kcf_mech_entry_t kcf_sign_mechs_tab[];
-extern kcf_mech_entry_t kcf_keyops_mechs_tab[];
-extern kcf_mech_entry_t kcf_misc_mechs_tab[];
-
-extern kmutex_t kcf_mech_tabs_lock;
-
 typedef	enum {
 	KCF_DIGEST_CLASS = 1,
 	KCF_CIPHER_CLASS,
@@ -430,7 +416,7 @@ typedef	struct kcf_mech_entry_tab {
 	kcf_mech_entry_t	*met_tab;	/* the table		 */
 } kcf_mech_entry_tab_t;
 
-extern kcf_mech_entry_tab_t kcf_mech_tabs_tab[];
+extern const kcf_mech_entry_tab_t kcf_mech_tabs_tab[];
 
 #define	KCF_MECHID(class, index)				\
 	(((crypto_mech_type_t)(class) << 32) | (crypto_mech_type_t)(index))
@@ -1276,9 +1262,6 @@ void crypto_free_dev_list(crypto_dev_list_entry_t *list, uint_t count);
 
 /* Miscellaneous */
 int crypto_get_mechanism_number(caddr_t name, crypto_mech_type_t *number);
-int crypto_get_function_list(crypto_provider_id_t id,
-    crypto_function_list_t **list, int kmflag);
-void crypto_free_function_list(crypto_function_list_t *list);
 int crypto_build_permitted_mech_names(kcf_provider_desc_t *,
     crypto_mech_name_t **, uint_t *, int);
 extern void kcf_destroy_mech_tabs(void);
@@ -1287,12 +1270,13 @@ extern int kcf_add_mech_provider(short, kcf_provider_desc_t *,
     kcf_prov_mech_desc_t **);
 extern void kcf_remove_mech_provider(char *, kcf_provider_desc_t *);
 extern int kcf_get_mech_entry(crypto_mech_type_t, kcf_mech_entry_t **);
-extern kcf_provider_desc_t *kcf_alloc_provider_desc(crypto_provider_info_t *);
+extern kcf_provider_desc_t *kcf_alloc_provider_desc(
+    const crypto_provider_info_t *);
 extern void kcf_provider_zero_refcnt(kcf_provider_desc_t *);
 extern void kcf_free_provider_desc(kcf_provider_desc_t *);
 extern void kcf_soft_config_init(void);
 extern int get_sw_provider_for_mech(crypto_mech_name_t, char **);
-extern crypto_mech_type_t crypto_mech2id_common(char *, boolean_t);
+extern crypto_mech_type_t crypto_mech2id_common(const char *, boolean_t);
 extern void undo_register_provider(kcf_provider_desc_t *, boolean_t);
 extern void redo_register_provider(kcf_provider_desc_t *);
 extern void kcf_rnd_init(void);
diff --git a/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctl.h b/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctl.h
deleted file mode 100644
index 6e371e343945..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctl.h
+++ /dev/null
@@ -1,1480 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef	_SYS_CRYPTO_IOCTL_H
-#define	_SYS_CRYPTO_IOCTL_H
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#include <sys/zfs_context.h>
-#include <sys/crypto/api.h>
-#include <sys/crypto/spi.h>
-#include <sys/crypto/common.h>
-
-#define	CRYPTO_MAX_ATTRIBUTE_COUNT	128
-
-#define	CRYPTO_IOFLAGS_RW_SESSION	0x00000001
-
-#define	CRYPTO(x)		(('y' << 8) | (x))
-
-#define	MAX_NUM_THRESHOLD	7
-
-/* the PKCS11 Mechanisms */
-#define	CKM_RC4			0x00000111
-#define	CKM_DES3_ECB		0x00000132
-#define	CKM_DES3_CBC		0x00000133
-#define	CKM_MD5			0x00000210
-#define	CKM_SHA_1		0x00000220
-#define	CKM_AES_ECB		0x00001081
-#define	CKM_AES_CBC		0x00001082
-
-/*
- * General Purpose Ioctls
- */
-
-typedef struct fl_mechs_threshold {
-	int		mech_type;
-	uint32_t	mech_threshold;
-} fl_mechs_threshold_t;
-
-typedef struct crypto_function_list {
-	boolean_t fl_digest_init;
-	boolean_t fl_digest;
-	boolean_t fl_digest_update;
-	boolean_t fl_digest_key;
-	boolean_t fl_digest_final;
-
-	boolean_t fl_encrypt_init;
-	boolean_t fl_encrypt;
-	boolean_t fl_encrypt_update;
-	boolean_t fl_encrypt_final;
-
-	boolean_t fl_decrypt_init;
-	boolean_t fl_decrypt;
-	boolean_t fl_decrypt_update;
-	boolean_t fl_decrypt_final;
-
-	boolean_t fl_mac_init;
-	boolean_t fl_mac;
-	boolean_t fl_mac_update;
-	boolean_t fl_mac_final;
-
-	boolean_t fl_sign_init;
-	boolean_t fl_sign;
-	boolean_t fl_sign_update;
-	boolean_t fl_sign_final;
-	boolean_t fl_sign_recover_init;
-	boolean_t fl_sign_recover;
-
-	boolean_t fl_verify_init;
-	boolean_t fl_verify;
-	boolean_t fl_verify_update;
-	boolean_t fl_verify_final;
-	boolean_t fl_verify_recover_init;
-	boolean_t fl_verify_recover;
-
-	boolean_t fl_digest_encrypt_update;
-	boolean_t fl_decrypt_digest_update;
-	boolean_t fl_sign_encrypt_update;
-	boolean_t fl_decrypt_verify_update;
-
-	boolean_t fl_seed_random;
-	boolean_t fl_generate_random;
-
-	boolean_t fl_session_open;
-	boolean_t fl_session_close;
-	boolean_t fl_session_login;
-	boolean_t fl_session_logout;
-
-	boolean_t fl_object_create;
-	boolean_t fl_object_copy;
-	boolean_t fl_object_destroy;
-	boolean_t fl_object_get_size;
-	boolean_t fl_object_get_attribute_value;
-	boolean_t fl_object_set_attribute_value;
-	boolean_t fl_object_find_init;
-	boolean_t fl_object_find;
-	boolean_t fl_object_find_final;
-
-	boolean_t fl_key_generate;
-	boolean_t fl_key_generate_pair;
-	boolean_t fl_key_wrap;
-	boolean_t fl_key_unwrap;
-	boolean_t fl_key_derive;
-
-	boolean_t fl_init_token;
-	boolean_t fl_init_pin;
-	boolean_t fl_set_pin;
-
-	boolean_t prov_is_limited;
-	uint32_t prov_hash_threshold;
-	uint32_t prov_hash_limit;
-
-	int total_threshold_count;
-	fl_mechs_threshold_t	fl_threshold[MAX_NUM_THRESHOLD];
-} crypto_function_list_t;
-
-typedef struct crypto_get_function_list {
-	uint_t			fl_return_value;
-	crypto_provider_id_t	fl_provider_id;
-	crypto_function_list_t	fl_list;
-} crypto_get_function_list_t;
-
-typedef struct crypto_get_mechanism_number {
-	uint_t			pn_return_value;
-	caddr_t			pn_mechanism_string;
-	size_t			pn_mechanism_len;
-	crypto_mech_type_t	pn_internal_number;
-} crypto_get_mechanism_number_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_get_mechanism_number32 {
-	uint32_t		pn_return_value;
-	caddr32_t		pn_mechanism_string;
-	size32_t		pn_mechanism_len;
-	crypto_mech_type_t	pn_internal_number;
-} crypto_get_mechanism_number32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_GET_FUNCTION_LIST	CRYPTO(20)
-#define	CRYPTO_GET_MECHANISM_NUMBER	CRYPTO(21)
-
-/*
- * Session Ioctls
- */
-
-typedef uint32_t	crypto_flags_t;
-
-typedef struct crypto_open_session {
-	uint_t			os_return_value;
-	crypto_session_id_t	os_session;
-	crypto_flags_t		os_flags;
-	crypto_provider_id_t	os_provider_id;
-} crypto_open_session_t;
-
-typedef struct crypto_close_session {
-	uint_t			cs_return_value;
-	crypto_session_id_t	cs_session;
-} crypto_close_session_t;
-
-typedef struct crypto_close_all_sessions {
-	uint_t			as_return_value;
-	crypto_provider_id_t	as_provider_id;
-} crypto_close_all_sessions_t;
-
-#define	CRYPTO_OPEN_SESSION		CRYPTO(30)
-#define	CRYPTO_CLOSE_SESSION		CRYPTO(31)
-#define	CRYPTO_CLOSE_ALL_SESSIONS	CRYPTO(32)
-
-/*
- * Login Ioctls
- */
-typedef struct crypto_login {
-	uint_t			co_return_value;
-	crypto_session_id_t	co_session;
-	uint_t			co_user_type;
-	uint_t			co_pin_len;
-	caddr_t			co_pin;
-} crypto_login_t;
-
-typedef struct crypto_logout {
-	uint_t			cl_return_value;
-	crypto_session_id_t	cl_session;
-} crypto_logout_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_login32 {
-	uint32_t		co_return_value;
-	crypto_session_id_t	co_session;
-	uint32_t		co_user_type;
-	uint32_t		co_pin_len;
-	caddr32_t		co_pin;
-} crypto_login32_t;
-
-typedef struct crypto_logout32 {
-	uint32_t		cl_return_value;
-	crypto_session_id_t	cl_session;
-} crypto_logout32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_LOGIN			CRYPTO(40)
-#define	CRYPTO_LOGOUT			CRYPTO(41)
-
-/*
- * Cryptographic Ioctls
- */
-typedef struct crypto_encrypt {
-	uint_t			ce_return_value;
-	crypto_session_id_t	ce_session;
-	size_t			ce_datalen;
-	caddr_t			ce_databuf;
-	size_t			ce_encrlen;
-	caddr_t			ce_encrbuf;
-	uint_t			ce_flags;
-} crypto_encrypt_t;
-
-typedef struct crypto_encrypt_init {
-	uint_t			ei_return_value;
-	crypto_session_id_t	ei_session;
-	crypto_mechanism_t	ei_mech;
-	crypto_key_t		ei_key;
-} crypto_encrypt_init_t;
-
-typedef struct crypto_encrypt_update {
-	uint_t			eu_return_value;
-	crypto_session_id_t	eu_session;
-	size_t			eu_datalen;
-	caddr_t			eu_databuf;
-	size_t			eu_encrlen;
-	caddr_t			eu_encrbuf;
-} crypto_encrypt_update_t;
-
-typedef struct crypto_encrypt_final {
-	uint_t			ef_return_value;
-	crypto_session_id_t	ef_session;
-	size_t			ef_encrlen;
-	caddr_t			ef_encrbuf;
-} crypto_encrypt_final_t;
-
-typedef struct crypto_decrypt {
-	uint_t			cd_return_value;
-	crypto_session_id_t	cd_session;
-	size_t			cd_encrlen;
-	caddr_t			cd_encrbuf;
-	size_t			cd_datalen;
-	caddr_t			cd_databuf;
-	uint_t			cd_flags;
-} crypto_decrypt_t;
-
-typedef struct crypto_decrypt_init {
-	uint_t			di_return_value;
-	crypto_session_id_t	di_session;
-	crypto_mechanism_t	di_mech;
-	crypto_key_t		di_key;
-} crypto_decrypt_init_t;
-
-typedef struct crypto_decrypt_update {
-	uint_t			du_return_value;
-	crypto_session_id_t	du_session;
-	size_t			du_encrlen;
-	caddr_t			du_encrbuf;
-	size_t			du_datalen;
-	caddr_t			du_databuf;
-} crypto_decrypt_update_t;
-
-typedef struct crypto_decrypt_final {
-	uint_t			df_return_value;
-	crypto_session_id_t	df_session;
-	size_t			df_datalen;
-	caddr_t			df_databuf;
-} crypto_decrypt_final_t;
-
-typedef struct crypto_digest {
-	uint_t			cd_return_value;
-	crypto_session_id_t	cd_session;
-	size_t			cd_datalen;
-	caddr_t			cd_databuf;
-	size_t			cd_digestlen;
-	caddr_t			cd_digestbuf;
-} crypto_digest_t;
-
-typedef struct crypto_digest_init {
-	uint_t			di_return_value;
-	crypto_session_id_t	di_session;
-	crypto_mechanism_t	di_mech;
-} crypto_digest_init_t;
-
-typedef struct crypto_digest_update {
-	uint_t			du_return_value;
-	crypto_session_id_t	du_session;
-	size_t			du_datalen;
-	caddr_t			du_databuf;
-} crypto_digest_update_t;
-
-typedef struct crypto_digest_key {
-	uint_t			dk_return_value;
-	crypto_session_id_t	dk_session;
-	crypto_key_t		dk_key;
-} crypto_digest_key_t;
-
-typedef struct crypto_digest_final {
-	uint_t			df_return_value;
-	crypto_session_id_t	df_session;
-	size_t			df_digestlen;
-	caddr_t			df_digestbuf;
-} crypto_digest_final_t;
-
-typedef struct crypto_mac {
-	uint_t			cm_return_value;
-	crypto_session_id_t	cm_session;
-	size_t			cm_datalen;
-	caddr_t			cm_databuf;
-	size_t			cm_maclen;
-	caddr_t			cm_macbuf;
-} crypto_mac_t;
-
-typedef struct crypto_mac_init {
-	uint_t			mi_return_value;
-	crypto_session_id_t	mi_session;
-	crypto_mechanism_t	mi_mech;
-	crypto_key_t		mi_key;
-} crypto_mac_init_t;
-
-typedef struct crypto_mac_update {
-	uint_t			mu_return_value;
-	crypto_session_id_t	mu_session;
-	size_t			mu_datalen;
-	caddr_t			mu_databuf;
-} crypto_mac_update_t;
-
-typedef struct crypto_mac_final {
-	uint_t			mf_return_value;
-	crypto_session_id_t	mf_session;
-	size_t			mf_maclen;
-	caddr_t			mf_macbuf;
-} crypto_mac_final_t;
-
-typedef struct crypto_sign {
-	uint_t			cs_return_value;
-	crypto_session_id_t	cs_session;
-	size_t			cs_datalen;
-	caddr_t			cs_databuf;
-	size_t			cs_signlen;
-	caddr_t			cs_signbuf;
-} crypto_sign_t;
-
-typedef struct crypto_sign_init {
-	uint_t			si_return_value;
-	crypto_session_id_t	si_session;
-	crypto_mechanism_t	si_mech;
-	crypto_key_t		si_key;
-} crypto_sign_init_t;
-
-typedef struct crypto_sign_update {
-	uint_t			su_return_value;
-	crypto_session_id_t	su_session;
-	size_t			su_datalen;
-	caddr_t			su_databuf;
-} crypto_sign_update_t;
-
-typedef struct crypto_sign_final {
-	uint_t			sf_return_value;
-	crypto_session_id_t	sf_session;
-	size_t			sf_signlen;
-	caddr_t			sf_signbuf;
-} crypto_sign_final_t;
-
-typedef struct crypto_sign_recover_init {
-	uint_t			ri_return_value;
-	crypto_session_id_t	ri_session;
-	crypto_mechanism_t	ri_mech;
-	crypto_key_t		ri_key;
-} crypto_sign_recover_init_t;
-
-typedef struct crypto_sign_recover {
-	uint_t			sr_return_value;
-	crypto_session_id_t	sr_session;
-	size_t			sr_datalen;
-	caddr_t			sr_databuf;
-	size_t			sr_signlen;
-	caddr_t			sr_signbuf;
-} crypto_sign_recover_t;
-
-typedef struct crypto_verify {
-	uint_t			cv_return_value;
-	crypto_session_id_t	cv_session;
-	size_t			cv_datalen;
-	caddr_t			cv_databuf;
-	size_t			cv_signlen;
-	caddr_t			cv_signbuf;
-} crypto_verify_t;
-
-typedef struct crypto_verify_init {
-	uint_t			vi_return_value;
-	crypto_session_id_t	vi_session;
-	crypto_mechanism_t	vi_mech;
-	crypto_key_t		vi_key;
-} crypto_verify_init_t;
-
-typedef struct crypto_verify_update {
-	uint_t			vu_return_value;
-	crypto_session_id_t	vu_session;
-	size_t			vu_datalen;
-	caddr_t			vu_databuf;
-} crypto_verify_update_t;
-
-typedef struct crypto_verify_final {
-	uint_t			vf_return_value;
-	crypto_session_id_t	vf_session;
-	size_t			vf_signlen;
-	caddr_t			vf_signbuf;
-} crypto_verify_final_t;
-
-typedef struct crypto_verify_recover_init {
-	uint_t			ri_return_value;
-	crypto_session_id_t	ri_session;
-	crypto_mechanism_t	ri_mech;
-	crypto_key_t		ri_key;
-} crypto_verify_recover_init_t;
-
-typedef struct crypto_verify_recover {
-	uint_t			vr_return_value;
-	crypto_session_id_t	vr_session;
-	size_t			vr_signlen;
-	caddr_t			vr_signbuf;
-	size_t			vr_datalen;
-	caddr_t			vr_databuf;
-} crypto_verify_recover_t;
-
-typedef struct crypto_digest_encrypt_update {
-	uint_t			eu_return_value;
-	crypto_session_id_t	eu_session;
-	size_t			eu_datalen;
-	caddr_t			eu_databuf;
-	size_t			eu_encrlen;
-	caddr_t			eu_encrbuf;
-} crypto_digest_encrypt_update_t;
-
-typedef struct crypto_decrypt_digest_update {
-	uint_t			du_return_value;
-	crypto_session_id_t	du_session;
-	size_t			du_encrlen;
-	caddr_t			du_encrbuf;
-	size_t			du_datalen;
-	caddr_t			du_databuf;
-} crypto_decrypt_digest_update_t;
-
-typedef struct crypto_sign_encrypt_update {
-	uint_t			eu_return_value;
-	crypto_session_id_t	eu_session;
-	size_t			eu_datalen;
-	caddr_t			eu_databuf;
-	size_t			eu_encrlen;
-	caddr_t			eu_encrbuf;
-} crypto_sign_encrypt_update_t;
-
-typedef struct crypto_decrypt_verify_update {
-	uint_t			vu_return_value;
-	crypto_session_id_t	vu_session;
-	size_t			vu_encrlen;
-	caddr_t			vu_encrbuf;
-	size_t			vu_datalen;
-	caddr_t			vu_databuf;
-} crypto_decrypt_verify_update_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_encrypt32 {
-	uint32_t		ce_return_value;
-	crypto_session_id_t	ce_session;
-	size32_t		ce_datalen;
-	caddr32_t		ce_databuf;
-	size32_t		ce_encrlen;
-	caddr32_t		ce_encrbuf;
-	uint32_t		ce_flags;
-} crypto_encrypt32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_encrypt_init32 {
-	uint32_t		ei_return_value;
-	crypto_session_id_t	ei_session;
-	crypto_mechanism32_t	ei_mech;
-	crypto_key32_t		ei_key;
-} crypto_encrypt_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_encrypt_update32 {
-	uint32_t		eu_return_value;
-	crypto_session_id_t	eu_session;
-	size32_t		eu_datalen;
-	caddr32_t		eu_databuf;
-	size32_t		eu_encrlen;
-	caddr32_t		eu_encrbuf;
-} crypto_encrypt_update32_t;
-
-typedef struct crypto_encrypt_final32 {
-	uint32_t		ef_return_value;
-	crypto_session_id_t	ef_session;
-	size32_t		ef_encrlen;
-	caddr32_t		ef_encrbuf;
-} crypto_encrypt_final32_t;
-
-typedef struct crypto_decrypt32 {
-	uint32_t		cd_return_value;
-	crypto_session_id_t	cd_session;
-	size32_t		cd_encrlen;
-	caddr32_t		cd_encrbuf;
-	size32_t		cd_datalen;
-	caddr32_t		cd_databuf;
-	uint32_t		cd_flags;
-} crypto_decrypt32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_decrypt_init32 {
-	uint32_t		di_return_value;
-	crypto_session_id_t	di_session;
-	crypto_mechanism32_t	di_mech;
-	crypto_key32_t		di_key;
-} crypto_decrypt_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_decrypt_update32 {
-	uint32_t		du_return_value;
-	crypto_session_id_t	du_session;
-	size32_t		du_encrlen;
-	caddr32_t		du_encrbuf;
-	size32_t		du_datalen;
-	caddr32_t		du_databuf;
-} crypto_decrypt_update32_t;
-
-typedef struct crypto_decrypt_final32 {
-	uint32_t		df_return_value;
-	crypto_session_id_t	df_session;
-	size32_t		df_datalen;
-	caddr32_t		df_databuf;
-} crypto_decrypt_final32_t;
-
-typedef struct crypto_digest32 {
-	uint32_t		cd_return_value;
-	crypto_session_id_t	cd_session;
-	size32_t		cd_datalen;
-	caddr32_t		cd_databuf;
-	size32_t		cd_digestlen;
-	caddr32_t		cd_digestbuf;
-} crypto_digest32_t;
-
-typedef struct crypto_digest_init32 {
-	uint32_t		di_return_value;
-	crypto_session_id_t	di_session;
-	crypto_mechanism32_t	di_mech;
-} crypto_digest_init32_t;
-
-typedef struct crypto_digest_update32 {
-	uint32_t		du_return_value;
-	crypto_session_id_t	du_session;
-	size32_t		du_datalen;
-	caddr32_t		du_databuf;
-} crypto_digest_update32_t;
-
-typedef struct crypto_digest_key32 {
-	uint32_t		dk_return_value;
-	crypto_session_id_t	dk_session;
-	crypto_key32_t		dk_key;
-} crypto_digest_key32_t;
-
-typedef struct crypto_digest_final32 {
-	uint32_t		df_return_value;
-	crypto_session_id_t	df_session;
-	size32_t		df_digestlen;
-	caddr32_t		df_digestbuf;
-} crypto_digest_final32_t;
-
-typedef struct crypto_mac32 {
-	uint32_t		cm_return_value;
-	crypto_session_id_t	cm_session;
-	size32_t		cm_datalen;
-	caddr32_t		cm_databuf;
-	size32_t		cm_maclen;
-	caddr32_t		cm_macbuf;
-} crypto_mac32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_mac_init32 {
-	uint32_t		mi_return_value;
-	crypto_session_id_t	mi_session;
-	crypto_mechanism32_t	mi_mech;
-	crypto_key32_t		mi_key;
-} crypto_mac_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_mac_update32 {
-	uint32_t		mu_return_value;
-	crypto_session_id_t	mu_session;
-	size32_t		mu_datalen;
-	caddr32_t		mu_databuf;
-} crypto_mac_update32_t;
-
-typedef struct crypto_mac_final32 {
-	uint32_t		mf_return_value;
-	crypto_session_id_t	mf_session;
-	size32_t		mf_maclen;
-	caddr32_t		mf_macbuf;
-} crypto_mac_final32_t;
-
-typedef struct crypto_sign32 {
-	uint32_t		cs_return_value;
-	crypto_session_id_t	cs_session;
-	size32_t		cs_datalen;
-	caddr32_t		cs_databuf;
-	size32_t		cs_signlen;
-	caddr32_t		cs_signbuf;
-} crypto_sign32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_sign_init32 {
-	uint32_t		si_return_value;
-	crypto_session_id_t	si_session;
-	crypto_mechanism32_t	si_mech;
-	crypto_key32_t		si_key;
-} crypto_sign_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_sign_update32 {
-	uint32_t		su_return_value;
-	crypto_session_id_t	su_session;
-	size32_t		su_datalen;
-	caddr32_t		su_databuf;
-} crypto_sign_update32_t;
-
-typedef struct crypto_sign_final32 {
-	uint32_t		sf_return_value;
-	crypto_session_id_t	sf_session;
-	size32_t		sf_signlen;
-	caddr32_t		sf_signbuf;
-} crypto_sign_final32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_sign_recover_init32 {
-	uint32_t		ri_return_value;
-	crypto_session_id_t	ri_session;
-	crypto_mechanism32_t	ri_mech;
-	crypto_key32_t		ri_key;
-} crypto_sign_recover_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_sign_recover32 {
-	uint32_t		sr_return_value;
-	crypto_session_id_t	sr_session;
-	size32_t		sr_datalen;
-	caddr32_t		sr_databuf;
-	size32_t		sr_signlen;
-	caddr32_t		sr_signbuf;
-} crypto_sign_recover32_t;
-
-typedef struct crypto_verify32 {
-	uint32_t		cv_return_value;
-	crypto_session_id_t	cv_session;
-	size32_t		cv_datalen;
-	caddr32_t		cv_databuf;
-	size32_t		cv_signlen;
-	caddr32_t		cv_signbuf;
-} crypto_verify32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_verify_init32 {
-	uint32_t		vi_return_value;
-	crypto_session_id_t	vi_session;
-	crypto_mechanism32_t	vi_mech;
-	crypto_key32_t		vi_key;
-} crypto_verify_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_verify_update32 {
-	uint32_t		vu_return_value;
-	crypto_session_id_t	vu_session;
-	size32_t		vu_datalen;
-	caddr32_t		vu_databuf;
-} crypto_verify_update32_t;
-
-typedef struct crypto_verify_final32 {
-	uint32_t		vf_return_value;
-	crypto_session_id_t	vf_session;
-	size32_t		vf_signlen;
-	caddr32_t		vf_signbuf;
-} crypto_verify_final32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_verify_recover_init32 {
-	uint32_t		ri_return_value;
-	crypto_session_id_t	ri_session;
-	crypto_mechanism32_t	ri_mech;
-	crypto_key32_t		ri_key;
-} crypto_verify_recover_init32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_verify_recover32 {
-	uint32_t		vr_return_value;
-	crypto_session_id_t	vr_session;
-	size32_t		vr_signlen;
-	caddr32_t		vr_signbuf;
-	size32_t		vr_datalen;
-	caddr32_t		vr_databuf;
-} crypto_verify_recover32_t;
-
-typedef struct crypto_digest_encrypt_update32 {
-	uint32_t		eu_return_value;
-	crypto_session_id_t	eu_session;
-	size32_t		eu_datalen;
-	caddr32_t		eu_databuf;
-	size32_t		eu_encrlen;
-	caddr32_t		eu_encrbuf;
-} crypto_digest_encrypt_update32_t;
-
-typedef struct crypto_decrypt_digest_update32 {
-	uint32_t		du_return_value;
-	crypto_session_id_t	du_session;
-	size32_t		du_encrlen;
-	caddr32_t		du_encrbuf;
-	size32_t		du_datalen;
-	caddr32_t		du_databuf;
-} crypto_decrypt_digest_update32_t;
-
-typedef struct crypto_sign_encrypt_update32 {
-	uint32_t		eu_return_value;
-	crypto_session_id_t	eu_session;
-	size32_t		eu_datalen;
-	caddr32_t		eu_databuf;
-	size32_t		eu_encrlen;
-	caddr32_t		eu_encrbuf;
-} crypto_sign_encrypt_update32_t;
-
-typedef struct crypto_decrypt_verify_update32 {
-	uint32_t		vu_return_value;
-	crypto_session_id_t	vu_session;
-	size32_t		vu_encrlen;
-	caddr32_t		vu_encrbuf;
-	size32_t		vu_datalen;
-	caddr32_t		vu_databuf;
-} crypto_decrypt_verify_update32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_ENCRYPT			CRYPTO(50)
-#define	CRYPTO_ENCRYPT_INIT		CRYPTO(51)
-#define	CRYPTO_ENCRYPT_UPDATE		CRYPTO(52)
-#define	CRYPTO_ENCRYPT_FINAL		CRYPTO(53)
-#define	CRYPTO_DECRYPT			CRYPTO(54)
-#define	CRYPTO_DECRYPT_INIT		CRYPTO(55)
-#define	CRYPTO_DECRYPT_UPDATE		CRYPTO(56)
-#define	CRYPTO_DECRYPT_FINAL		CRYPTO(57)
-
-#define	CRYPTO_DIGEST			CRYPTO(58)
-#define	CRYPTO_DIGEST_INIT		CRYPTO(59)
-#define	CRYPTO_DIGEST_UPDATE		CRYPTO(60)
-#define	CRYPTO_DIGEST_KEY		CRYPTO(61)
-#define	CRYPTO_DIGEST_FINAL		CRYPTO(62)
-#define	CRYPTO_MAC			CRYPTO(63)
-#define	CRYPTO_MAC_INIT			CRYPTO(64)
-#define	CRYPTO_MAC_UPDATE		CRYPTO(65)
-#define	CRYPTO_MAC_FINAL		CRYPTO(66)
-
-#define	CRYPTO_SIGN			CRYPTO(67)
-#define	CRYPTO_SIGN_INIT		CRYPTO(68)
-#define	CRYPTO_SIGN_UPDATE		CRYPTO(69)
-#define	CRYPTO_SIGN_FINAL		CRYPTO(70)
-#define	CRYPTO_SIGN_RECOVER_INIT	CRYPTO(71)
-#define	CRYPTO_SIGN_RECOVER		CRYPTO(72)
-#define	CRYPTO_VERIFY			CRYPTO(73)
-#define	CRYPTO_VERIFY_INIT		CRYPTO(74)
-#define	CRYPTO_VERIFY_UPDATE		CRYPTO(75)
-#define	CRYPTO_VERIFY_FINAL		CRYPTO(76)
-#define	CRYPTO_VERIFY_RECOVER_INIT	CRYPTO(77)
-#define	CRYPTO_VERIFY_RECOVER		CRYPTO(78)
-
-#define	CRYPTO_DIGEST_ENCRYPT_UPDATE	CRYPTO(79)
-#define	CRYPTO_DECRYPT_DIGEST_UPDATE	CRYPTO(80)
-#define	CRYPTO_SIGN_ENCRYPT_UPDATE	CRYPTO(81)
-#define	CRYPTO_DECRYPT_VERIFY_UPDATE	CRYPTO(82)
-
-/*
- * Random Number Ioctls
- */
-typedef struct crypto_seed_random {
-	uint_t			sr_return_value;
-	crypto_session_id_t	sr_session;
-	size_t			sr_seedlen;
-	caddr_t			sr_seedbuf;
-} crypto_seed_random_t;
-
-typedef struct crypto_generate_random {
-	uint_t			gr_return_value;
-	crypto_session_id_t	gr_session;
-	caddr_t			gr_buf;
-	size_t			gr_buflen;
-} crypto_generate_random_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_seed_random32 {
-	uint32_t		sr_return_value;
-	crypto_session_id_t	sr_session;
-	size32_t		sr_seedlen;
-	caddr32_t		sr_seedbuf;
-} crypto_seed_random32_t;
-
-typedef struct crypto_generate_random32 {
-	uint32_t		gr_return_value;
-	crypto_session_id_t	gr_session;
-	caddr32_t		gr_buf;
-	size32_t		gr_buflen;
-} crypto_generate_random32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_SEED_RANDOM		CRYPTO(90)
-#define	CRYPTO_GENERATE_RANDOM		CRYPTO(91)
-
-/*
- * Object Management Ioctls
- */
-typedef struct crypto_object_create {
-	uint_t			oc_return_value;
-	crypto_session_id_t	oc_session;
-	crypto_object_id_t	oc_handle;
-	uint_t			oc_count;
-	caddr_t			oc_attributes;
-} crypto_object_create_t;
-
-typedef struct crypto_object_copy {
-	uint_t			oc_return_value;
-	crypto_session_id_t	oc_session;
-	crypto_object_id_t	oc_handle;
-	crypto_object_id_t	oc_new_handle;
-	uint_t			oc_count;
-	caddr_t			oc_new_attributes;
-} crypto_object_copy_t;
-
-typedef struct crypto_object_destroy {
-	uint_t			od_return_value;
-	crypto_session_id_t	od_session;
-	crypto_object_id_t	od_handle;
-} crypto_object_destroy_t;
-
-typedef struct crypto_object_get_attribute_value {
-	uint_t			og_return_value;
-	crypto_session_id_t	og_session;
-	crypto_object_id_t	og_handle;
-	uint_t			og_count;
-	caddr_t			og_attributes;
-} crypto_object_get_attribute_value_t;
-
-typedef struct crypto_object_get_size {
-	uint_t			gs_return_value;
-	crypto_session_id_t	gs_session;
-	crypto_object_id_t	gs_handle;
-	size_t			gs_size;
-} crypto_object_get_size_t;
-
-typedef struct crypto_object_set_attribute_value {
-	uint_t			sa_return_value;
-	crypto_session_id_t	sa_session;
-	crypto_object_id_t	sa_handle;
-	uint_t			sa_count;
-	caddr_t			sa_attributes;
-} crypto_object_set_attribute_value_t;
-
-typedef struct crypto_object_find_init {
-	uint_t			fi_return_value;
-	crypto_session_id_t	fi_session;
-	uint_t			fi_count;
-	caddr_t			fi_attributes;
-} crypto_object_find_init_t;
-
-typedef struct crypto_object_find_update {
-	uint_t			fu_return_value;
-	crypto_session_id_t	fu_session;
-	uint_t			fu_max_count;
-	uint_t			fu_count;
-	caddr_t			fu_handles;
-} crypto_object_find_update_t;
-
-typedef struct crypto_object_find_final {
-	uint_t			ff_return_value;
-	crypto_session_id_t	ff_session;
-} crypto_object_find_final_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_object_create32 {
-	uint32_t		oc_return_value;
-	crypto_session_id_t	oc_session;
-	crypto_object_id_t	oc_handle;
-	uint32_t		oc_count;
-	caddr32_t		oc_attributes;
-} crypto_object_create32_t;
-
-typedef struct crypto_object_copy32 {
-	uint32_t		oc_return_value;
-	crypto_session_id_t	oc_session;
-	crypto_object_id_t	oc_handle;
-	crypto_object_id_t	oc_new_handle;
-	uint32_t		oc_count;
-	caddr32_t		oc_new_attributes;
-} crypto_object_copy32_t;
-
-typedef struct crypto_object_destroy32 {
-	uint32_t		od_return_value;
-	crypto_session_id_t	od_session;
-	crypto_object_id_t	od_handle;
-} crypto_object_destroy32_t;
-
-typedef struct crypto_object_get_attribute_value32 {
-	uint32_t		og_return_value;
-	crypto_session_id_t	og_session;
-	crypto_object_id_t	og_handle;
-	uint32_t		og_count;
-	caddr32_t		og_attributes;
-} crypto_object_get_attribute_value32_t;
-
-typedef struct crypto_object_get_size32 {
-	uint32_t		gs_return_value;
-	crypto_session_id_t	gs_session;
-	crypto_object_id_t	gs_handle;
-	size32_t		gs_size;
-} crypto_object_get_size32_t;
-
-typedef struct crypto_object_set_attribute_value32 {
-	uint32_t		sa_return_value;
-	crypto_session_id_t	sa_session;
-	crypto_object_id_t	sa_handle;
-	uint32_t		sa_count;
-	caddr32_t		sa_attributes;
-} crypto_object_set_attribute_value32_t;
-
-typedef struct crypto_object_find_init32 {
-	uint32_t		fi_return_value;
-	crypto_session_id_t	fi_session;
-	uint32_t		fi_count;
-	caddr32_t		fi_attributes;
-} crypto_object_find_init32_t;
-
-typedef struct crypto_object_find_update32 {
-	uint32_t		fu_return_value;
-	crypto_session_id_t	fu_session;
-	uint32_t		fu_max_count;
-	uint32_t		fu_count;
-	caddr32_t		fu_handles;
-} crypto_object_find_update32_t;
-
-typedef struct crypto_object_find_final32 {
-	uint32_t		ff_return_value;
-	crypto_session_id_t	ff_session;
-} crypto_object_find_final32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_OBJECT_CREATE			CRYPTO(100)
-#define	CRYPTO_OBJECT_COPY			CRYPTO(101)
-#define	CRYPTO_OBJECT_DESTROY			CRYPTO(102)
-#define	CRYPTO_OBJECT_GET_ATTRIBUTE_VALUE	CRYPTO(103)
-#define	CRYPTO_OBJECT_GET_SIZE			CRYPTO(104)
-#define	CRYPTO_OBJECT_SET_ATTRIBUTE_VALUE	CRYPTO(105)
-#define	CRYPTO_OBJECT_FIND_INIT			CRYPTO(106)
-#define	CRYPTO_OBJECT_FIND_UPDATE		CRYPTO(107)
-#define	CRYPTO_OBJECT_FIND_FINAL		CRYPTO(108)
-
-/*
- * Key Generation Ioctls
- */
-typedef struct crypto_object_generate_key {
-	uint_t			gk_return_value;
-	crypto_session_id_t	gk_session;
-	crypto_object_id_t	gk_handle;
-	crypto_mechanism_t	gk_mechanism;
-	uint_t			gk_count;
-	caddr_t			gk_attributes;
-} crypto_object_generate_key_t;
-
-typedef struct crypto_object_generate_key_pair {
-	uint_t			kp_return_value;
-	crypto_session_id_t	kp_session;
-	crypto_object_id_t	kp_public_handle;
-	crypto_object_id_t	kp_private_handle;
-	uint_t			kp_public_count;
-	uint_t			kp_private_count;
-	caddr_t			kp_public_attributes;
-	caddr_t			kp_private_attributes;
-	crypto_mechanism_t	kp_mechanism;
-} crypto_object_generate_key_pair_t;
-
-typedef struct crypto_object_wrap_key {
-	uint_t			wk_return_value;
-	crypto_session_id_t	wk_session;
-	crypto_mechanism_t	wk_mechanism;
-	crypto_key_t		wk_wrapping_key;
-	crypto_object_id_t	wk_object_handle;
-	size_t			wk_wrapped_key_len;
-	caddr_t			wk_wrapped_key;
-} crypto_object_wrap_key_t;
-
-typedef struct crypto_object_unwrap_key {
-	uint_t			uk_return_value;
-	crypto_session_id_t	uk_session;
-	crypto_mechanism_t	uk_mechanism;
-	crypto_key_t		uk_unwrapping_key;
-	crypto_object_id_t	uk_object_handle;
-	size_t			uk_wrapped_key_len;
-	caddr_t			uk_wrapped_key;
-	uint_t			uk_count;
-	caddr_t			uk_attributes;
-} crypto_object_unwrap_key_t;
-
-typedef struct crypto_derive_key {
-	uint_t			dk_return_value;
-	crypto_session_id_t	dk_session;
-	crypto_mechanism_t	dk_mechanism;
-	crypto_key_t		dk_base_key;
-	crypto_object_id_t	dk_object_handle;
-	uint_t			dk_count;
-	caddr_t			dk_attributes;
-} crypto_derive_key_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_object_generate_key32 {
-	uint32_t		gk_return_value;
-	crypto_session_id_t	gk_session;
-	crypto_object_id_t	gk_handle;
-	crypto_mechanism32_t	gk_mechanism;
-	uint32_t		gk_count;
-	caddr32_t		gk_attributes;
-} crypto_object_generate_key32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-typedef struct crypto_object_generate_key_pair32 {
-	uint32_t		kp_return_value;
-	crypto_session_id_t	kp_session;
-	crypto_object_id_t	kp_public_handle;
-	crypto_object_id_t	kp_private_handle;
-	uint32_t		kp_public_count;
-	uint32_t		kp_private_count;
-	caddr32_t		kp_public_attributes;
-	caddr32_t		kp_private_attributes;
-	crypto_mechanism32_t	kp_mechanism;
-} crypto_object_generate_key_pair32_t;
-
-typedef struct crypto_object_wrap_key32 {
-	uint32_t		wk_return_value;
-	crypto_session_id_t	wk_session;
-	crypto_mechanism32_t	wk_mechanism;
-	crypto_key32_t		wk_wrapping_key;
-	crypto_object_id_t	wk_object_handle;
-	size32_t		wk_wrapped_key_len;
-	caddr32_t		wk_wrapped_key;
-} crypto_object_wrap_key32_t;
-
-typedef struct crypto_object_unwrap_key32 {
-	uint32_t		uk_return_value;
-	crypto_session_id_t	uk_session;
-	crypto_mechanism32_t	uk_mechanism;
-	crypto_key32_t		uk_unwrapping_key;
-	crypto_object_id_t	uk_object_handle;
-	size32_t		uk_wrapped_key_len;
-	caddr32_t		uk_wrapped_key;
-	uint32_t		uk_count;
-	caddr32_t		uk_attributes;
-} crypto_object_unwrap_key32_t;
-
-typedef struct crypto_derive_key32 {
-	uint32_t		dk_return_value;
-	crypto_session_id_t	dk_session;
-	crypto_mechanism32_t	dk_mechanism;
-	crypto_key32_t		dk_base_key;
-	crypto_object_id_t	dk_object_handle;
-	uint32_t		dk_count;
-	caddr32_t		dk_attributes;
-} crypto_derive_key32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_GENERATE_KEY		CRYPTO(110)
-#define	CRYPTO_GENERATE_KEY_PAIR	CRYPTO(111)
-#define	CRYPTO_WRAP_KEY			CRYPTO(112)
-#define	CRYPTO_UNWRAP_KEY		CRYPTO(113)
-#define	CRYPTO_DERIVE_KEY		CRYPTO(114)
-
-/*
- * Provider Management Ioctls
- */
-
-typedef struct crypto_get_provider_list {
-	uint_t			pl_return_value;
-	uint_t			pl_count;
-	crypto_provider_entry_t	pl_list[1];
-} crypto_get_provider_list_t;
-
-typedef struct crypto_provider_data {
-	uchar_t			pd_prov_desc[CRYPTO_PROVIDER_DESCR_MAX_LEN];
-	uchar_t			pd_label[CRYPTO_EXT_SIZE_LABEL];
-	uchar_t			pd_manufacturerID[CRYPTO_EXT_SIZE_MANUF];
-	uchar_t			pd_model[CRYPTO_EXT_SIZE_MODEL];
-	uchar_t			pd_serial_number[CRYPTO_EXT_SIZE_SERIAL];
-	ulong_t			pd_flags;
-	ulong_t			pd_max_session_count;
-	ulong_t			pd_session_count;
-	ulong_t			pd_max_rw_session_count;
-	ulong_t			pd_rw_session_count;
-	ulong_t			pd_max_pin_len;
-	ulong_t			pd_min_pin_len;
-	ulong_t			pd_total_public_memory;
-	ulong_t			pd_free_public_memory;
-	ulong_t			pd_total_private_memory;
-	ulong_t			pd_free_private_memory;
-	crypto_version_t	pd_hardware_version;
-	crypto_version_t	pd_firmware_version;
-	uchar_t			pd_time[CRYPTO_EXT_SIZE_TIME];
-} crypto_provider_data_t;
-
-typedef struct crypto_get_provider_info {
-	uint_t			gi_return_value;
-	crypto_provider_id_t	gi_provider_id;
-	crypto_provider_data_t	gi_provider_data;
-} crypto_get_provider_info_t;
-
-typedef struct crypto_get_provider_mechanisms {
-	uint_t			pm_return_value;
-	crypto_provider_id_t	pm_provider_id;
-	uint_t			pm_count;
-	crypto_mech_name_t	pm_list[1];
-} crypto_get_provider_mechanisms_t;
-
-typedef struct crypto_get_provider_mechanism_info {
-	uint_t			mi_return_value;
-	crypto_provider_id_t	mi_provider_id;
-	crypto_mech_name_t	mi_mechanism_name;
-	uint32_t		mi_min_key_size;
-	uint32_t		mi_max_key_size;
-	uint32_t		mi_flags;
-} crypto_get_provider_mechanism_info_t;
-
-typedef struct crypto_init_token {
-	uint_t			it_return_value;
-	crypto_provider_id_t	it_provider_id;
-	caddr_t			it_pin;
-	size_t			it_pin_len;
-	caddr_t			it_label;
-} crypto_init_token_t;
-
-typedef struct crypto_init_pin {
-	uint_t			ip_return_value;
-	crypto_session_id_t	ip_session;
-	caddr_t			ip_pin;
-	size_t			ip_pin_len;
-} crypto_init_pin_t;
-
-typedef struct crypto_set_pin {
-	uint_t			sp_return_value;
-	crypto_session_id_t	sp_session;
-	caddr_t			sp_old_pin;
-	size_t			sp_old_len;
-	caddr_t			sp_new_pin;
-	size_t			sp_new_len;
-} crypto_set_pin_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_get_provider_list32 {
-	uint32_t		pl_return_value;
-	uint32_t		pl_count;
-	crypto_provider_entry_t pl_list[1];
-} crypto_get_provider_list32_t;
-
-typedef struct crypto_version32 {
-	uchar_t	cv_major;
-	uchar_t	cv_minor;
-} crypto_version32_t;
-
-typedef struct crypto_provider_data32 {
-	uchar_t			pd_prov_desc[CRYPTO_PROVIDER_DESCR_MAX_LEN];
-	uchar_t			pd_label[CRYPTO_EXT_SIZE_LABEL];
-	uchar_t			pd_manufacturerID[CRYPTO_EXT_SIZE_MANUF];
-	uchar_t			pd_model[CRYPTO_EXT_SIZE_MODEL];
-	uchar_t			pd_serial_number[CRYPTO_EXT_SIZE_SERIAL];
-	uint32_t		pd_flags;
-	uint32_t		pd_max_session_count;
-	uint32_t		pd_session_count;
-	uint32_t		pd_max_rw_session_count;
-	uint32_t		pd_rw_session_count;
-	uint32_t		pd_max_pin_len;
-	uint32_t		pd_min_pin_len;
-	uint32_t		pd_total_public_memory;
-	uint32_t		pd_free_public_memory;
-	uint32_t		pd_total_private_memory;
-	uint32_t		pd_free_private_memory;
-	crypto_version32_t	pd_hardware_version;
-	crypto_version32_t	pd_firmware_version;
-	uchar_t			pd_time[CRYPTO_EXT_SIZE_TIME];
-} crypto_provider_data32_t;
-
-typedef struct crypto_get_provider_info32 {
-	uint32_t		gi_return_value;
-	crypto_provider_id_t	gi_provider_id;
-	crypto_provider_data32_t gi_provider_data;
-} crypto_get_provider_info32_t;
-
-typedef struct crypto_get_provider_mechanisms32 {
-	uint32_t		pm_return_value;
-	crypto_provider_id_t	pm_provider_id;
-	uint32_t		pm_count;
-	crypto_mech_name_t	pm_list[1];
-} crypto_get_provider_mechanisms32_t;
-
-typedef struct crypto_init_token32 {
-	uint32_t		it_return_value;
-	crypto_provider_id_t	it_provider_id;
-	caddr32_t		it_pin;
-	size32_t		it_pin_len;
-	caddr32_t		it_label;
-} crypto_init_token32_t;
-
-typedef struct crypto_init_pin32 {
-	uint32_t		ip_return_value;
-	crypto_session_id_t	ip_session;
-	caddr32_t		ip_pin;
-	size32_t		ip_pin_len;
-} crypto_init_pin32_t;
-
-typedef struct crypto_set_pin32 {
-	uint32_t		sp_return_value;
-	crypto_session_id_t	sp_session;
-	caddr32_t		sp_old_pin;
-	size32_t		sp_old_len;
-	caddr32_t		sp_new_pin;
-	size32_t		sp_new_len;
-} crypto_set_pin32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_GET_PROVIDER_LIST		CRYPTO(120)
-#define	CRYPTO_GET_PROVIDER_INFO		CRYPTO(121)
-#define	CRYPTO_GET_PROVIDER_MECHANISMS		CRYPTO(122)
-#define	CRYPTO_GET_PROVIDER_MECHANISM_INFO	CRYPTO(123)
-#define	CRYPTO_INIT_TOKEN			CRYPTO(124)
-#define	CRYPTO_INIT_PIN				CRYPTO(125)
-#define	CRYPTO_SET_PIN				CRYPTO(126)
-
-/*
- * No (Key) Store Key Generation Ioctls
- */
-typedef struct crypto_nostore_generate_key {
-	uint_t			ngk_return_value;
-	crypto_session_id_t	ngk_session;
-	crypto_mechanism_t	ngk_mechanism;
-	uint_t			ngk_in_count;
-	uint_t			ngk_out_count;
-	caddr_t			ngk_in_attributes;
-	caddr_t			ngk_out_attributes;
-} crypto_nostore_generate_key_t;
-
-typedef struct crypto_nostore_generate_key_pair {
-	uint_t			nkp_return_value;
-	crypto_session_id_t	nkp_session;
-	uint_t			nkp_in_public_count;
-	uint_t			nkp_in_private_count;
-	uint_t			nkp_out_public_count;
-	uint_t			nkp_out_private_count;
-	caddr_t			nkp_in_public_attributes;
-	caddr_t			nkp_in_private_attributes;
-	caddr_t			nkp_out_public_attributes;
-	caddr_t			nkp_out_private_attributes;
-	crypto_mechanism_t	nkp_mechanism;
-} crypto_nostore_generate_key_pair_t;
-
-typedef struct crypto_nostore_derive_key {
-	uint_t			ndk_return_value;
-	crypto_session_id_t	ndk_session;
-	crypto_mechanism_t	ndk_mechanism;
-	crypto_key_t		ndk_base_key;
-	uint_t			ndk_in_count;
-	uint_t			ndk_out_count;
-	caddr_t			ndk_in_attributes;
-	caddr_t			ndk_out_attributes;
-} crypto_nostore_derive_key_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_nostore_generate_key32 {
-	uint32_t		ngk_return_value;
-	crypto_session_id_t	ngk_session;
-	crypto_mechanism32_t	ngk_mechanism;
-	uint32_t		ngk_in_count;
-	uint32_t		ngk_out_count;
-	caddr32_t		ngk_in_attributes;
-	caddr32_t		ngk_out_attributes;
-} crypto_nostore_generate_key32_t;
-
-typedef struct crypto_nostore_generate_key_pair32 {
-	uint32_t		nkp_return_value;
-	crypto_session_id_t	nkp_session;
-	uint32_t		nkp_in_public_count;
-	uint32_t		nkp_in_private_count;
-	uint32_t		nkp_out_public_count;
-	uint32_t		nkp_out_private_count;
-	caddr32_t		nkp_in_public_attributes;
-	caddr32_t		nkp_in_private_attributes;
-	caddr32_t		nkp_out_public_attributes;
-	caddr32_t		nkp_out_private_attributes;
-	crypto_mechanism32_t	nkp_mechanism;
-} crypto_nostore_generate_key_pair32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack(4)
-#endif
-
-typedef struct crypto_nostore_derive_key32 {
-	uint32_t		ndk_return_value;
-	crypto_session_id_t	ndk_session;
-	crypto_mechanism32_t	ndk_mechanism;
-	crypto_key32_t		ndk_base_key;
-	uint32_t		ndk_in_count;
-	uint32_t		ndk_out_count;
-	caddr32_t		ndk_in_attributes;
-	caddr32_t		ndk_out_attributes;
-} crypto_nostore_derive_key32_t;
-
-#if _LONG_LONG_ALIGNMENT == 8 && _LONG_LONG_ALIGNMENT_32 == 4
-#pragma pack()
-#endif
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_NOSTORE_GENERATE_KEY		CRYPTO(127)
-#define	CRYPTO_NOSTORE_GENERATE_KEY_PAIR	CRYPTO(128)
-#define	CRYPTO_NOSTORE_DERIVE_KEY		CRYPTO(129)
-
-/*
- * Mechanism Ioctls
- */
-
-typedef struct crypto_get_mechanism_list {
-	uint_t			ml_return_value;
-	uint_t			ml_count;
-	crypto_mech_name_t	ml_list[1];
-} crypto_get_mechanism_list_t;
-
-typedef struct crypto_get_all_mechanism_info {
-	uint_t			mi_return_value;
-	crypto_mech_name_t	mi_mechanism_name;
-	uint_t			mi_count;
-	crypto_mechanism_info_t	mi_list[1];
-} crypto_get_all_mechanism_info_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_get_mechanism_list32 {
-	uint32_t		ml_return_value;
-	uint32_t		ml_count;
-	crypto_mech_name_t	ml_list[1];
-} crypto_get_mechanism_list32_t;
-
-typedef struct crypto_get_all_mechanism_info32 {
-	uint32_t		mi_return_value;
-	crypto_mech_name_t	mi_mechanism_name;
-	uint32_t		mi_count;
-	crypto_mechanism_info32_t mi_list[1];
-} crypto_get_all_mechanism_info32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_GET_MECHANISM_LIST		CRYPTO(140)
-#define	CRYPTO_GET_ALL_MECHANISM_INFO		CRYPTO(141)
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _SYS_CRYPTO_IOCTL_H */
diff --git a/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctladmin.h b/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctladmin.h
deleted file mode 100644
index 24babd7755cc..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sys/crypto/ioctladmin.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef	_SYS_CRYPTO_IOCTLADMIN_H
-#define	_SYS_CRYPTO_IOCTLADMIN_H
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#include <sys/zfs_context.h>
-#include <sys/crypto/common.h>
-
-#define	ADMIN_IOCTL_DEVICE	"/dev/cryptoadm"
-
-#define	CRYPTOADMIN(x)		(('y' << 8) | (x))
-
-/*
- * Administrative IOCTLs
- */
-
-typedef struct crypto_get_dev_list {
-	uint_t			dl_return_value;
-	uint_t			dl_dev_count;
-	crypto_dev_list_entry_t	dl_devs[1];
-} crypto_get_dev_list_t;
-
-typedef struct crypto_get_soft_list {
-	uint_t			sl_return_value;
-	uint_t			sl_soft_count;
-	size_t			sl_soft_len;
-	caddr_t			sl_soft_names;
-} crypto_get_soft_list_t;
-
-typedef struct crypto_get_dev_info {
-	uint_t			di_return_value;
-	char			di_dev_name[MAXNAMELEN];
-	uint_t			di_dev_instance;
-	uint_t			di_count;
-	crypto_mech_name_t	di_list[1];
-} crypto_get_dev_info_t;
-
-typedef struct crypto_get_soft_info {
-	uint_t			si_return_value;
-	char			si_name[MAXNAMELEN];
-	uint_t			si_count;
-	crypto_mech_name_t	si_list[1];
-} crypto_get_soft_info_t;
-
-typedef struct crypto_load_dev_disabled {
-	uint_t			dd_return_value;
-	char			dd_dev_name[MAXNAMELEN];
-	uint_t			dd_dev_instance;
-	uint_t			dd_count;
-	crypto_mech_name_t	dd_list[1];
-} crypto_load_dev_disabled_t;
-
-typedef struct crypto_load_soft_disabled {
-	uint_t			sd_return_value;
-	char			sd_name[MAXNAMELEN];
-	uint_t			sd_count;
-	crypto_mech_name_t	sd_list[1];
-} crypto_load_soft_disabled_t;
-
-typedef struct crypto_unload_soft_module {
-	uint_t			sm_return_value;
-	char			sm_name[MAXNAMELEN];
-} crypto_unload_soft_module_t;
-
-typedef struct crypto_load_soft_config {
-	uint_t			sc_return_value;
-	char			sc_name[MAXNAMELEN];
-	uint_t			sc_count;
-	crypto_mech_name_t	sc_list[1];
-} crypto_load_soft_config_t;
-
-typedef struct crypto_load_door {
-	uint_t			ld_return_value;
-	uint_t			ld_did;
-} crypto_load_door_t;
-
-#ifdef	_KERNEL
-#ifdef	_SYSCALL32
-
-typedef struct crypto_get_soft_list32 {
-	uint32_t		sl_return_value;
-	uint32_t		sl_soft_count;
-	size32_t		sl_soft_len;
-	caddr32_t		sl_soft_names;
-} crypto_get_soft_list32_t;
-
-#endif	/* _SYSCALL32 */
-#endif	/* _KERNEL */
-
-#define	CRYPTO_GET_VERSION		CRYPTOADMIN(1)
-#define	CRYPTO_GET_DEV_LIST		CRYPTOADMIN(2)
-#define	CRYPTO_GET_SOFT_LIST		CRYPTOADMIN(3)
-#define	CRYPTO_GET_DEV_INFO		CRYPTOADMIN(4)
-#define	CRYPTO_GET_SOFT_INFO		CRYPTOADMIN(5)
-#define	CRYPTO_LOAD_DEV_DISABLED	CRYPTOADMIN(8)
-#define	CRYPTO_LOAD_SOFT_DISABLED	CRYPTOADMIN(9)
-#define	CRYPTO_UNLOAD_SOFT_MODULE	CRYPTOADMIN(10)
-#define	CRYPTO_LOAD_SOFT_CONFIG		CRYPTOADMIN(11)
-#define	CRYPTO_POOL_CREATE		CRYPTOADMIN(12)
-#define	CRYPTO_POOL_WAIT		CRYPTOADMIN(13)
-#define	CRYPTO_POOL_RUN			CRYPTOADMIN(14)
-#define	CRYPTO_LOAD_DOOR		CRYPTOADMIN(15)
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _SYS_CRYPTO_IOCTLADMIN_H */
diff --git a/sys/contrib/openzfs/module/icp/include/sys/crypto/sched_impl.h b/sys/contrib/openzfs/module/icp/include/sys/crypto/sched_impl.h
index 85ea0ba1d092..29ef8021f0fc 100644
--- a/sys/contrib/openzfs/module/icp/include/sys/crypto/sched_impl.h
+++ b/sys/contrib/openzfs/module/icp/include/sys/crypto/sched_impl.h
@@ -457,12 +457,9 @@ typedef struct kcf_ntfy_elem {
 #define	CRYPTO_TASKQ_MIN	64
 #define	CRYPTO_TASKQ_MAX	2 * 1024 * 1024
 
-extern int crypto_taskq_threads;
-extern int crypto_taskq_minalloc;
-extern int crypto_taskq_maxalloc;
-extern kcf_global_swq_t *gswq;
-extern int kcf_maxthreads;
-extern int kcf_minthreads;
+extern const int crypto_taskq_threads;
+extern const int crypto_taskq_minalloc;
+extern const int crypto_taskq_maxalloc;
 
 /*
  * All pending crypto bufcalls are put on a list. cbuf_list_lock
diff --git a/sys/contrib/openzfs/module/icp/include/sys/crypto/spi.h b/sys/contrib/openzfs/module/icp/include/sys/crypto/spi.h
index 2c62b5706651..0f1b455c808e 100644
--- a/sys/contrib/openzfs/module/icp/include/sys/crypto/spi.h
+++ b/sys/contrib/openzfs/module/icp/include/sys/crypto/spi.h
@@ -498,10 +498,10 @@ typedef struct crypto_nostore_key_ops {
  * by calling crypto_register_provider(9F).
  */
 typedef struct crypto_ops_v1 {
-	crypto_control_ops_t			*co_control_ops;
-	crypto_digest_ops_t			*co_digest_ops;
-	crypto_cipher_ops_t			*co_cipher_ops;
-	crypto_mac_ops_t			*co_mac_ops;
+	const crypto_control_ops_t			*co_control_ops;
+	const crypto_digest_ops_t			*co_digest_ops;
+	const crypto_cipher_ops_t			*co_cipher_ops;
+	const crypto_mac_ops_t			*co_mac_ops;
 	crypto_sign_ops_t			*co_sign_ops;
 	crypto_verify_ops_t			*co_verify_ops;
 	crypto_dual_ops_t			*co_dual_ops;
@@ -511,7 +511,7 @@ typedef struct crypto_ops_v1 {
 	crypto_object_ops_t			*co_object_ops;
 	crypto_key_ops_t			*co_key_ops;
 	crypto_provider_management_ops_t	*co_provider_ops;
-	crypto_ctx_ops_t			*co_ctx_ops;
+	const crypto_ctx_ops_t			*co_ctx_ops;
 } crypto_ops_v1_t;
 
 typedef struct crypto_ops_v2 {
@@ -653,9 +653,9 @@ typedef struct crypto_provider_info_v1 {
 	char				*pi_provider_description;
 	crypto_provider_type_t		pi_provider_type;
 	crypto_provider_handle_t	pi_provider_handle;
-	crypto_ops_t			*pi_ops_vector;
+	const crypto_ops_t			*pi_ops_vector;
 	uint_t				pi_mech_list_count;
-	crypto_mech_info_t		*pi_mechanisms;
+	const crypto_mech_info_t		*pi_mechanisms;
 	uint_t				pi_logical_provider_count;
 	crypto_kcf_provider_handle_t	*pi_logical_providers;
 } crypto_provider_info_v1_t;
@@ -711,7 +711,7 @@ typedef struct crypto_provider_info {
  * of state changes, and notify the kernel when a asynchronous request
  * completed.
  */
-extern int crypto_register_provider(crypto_provider_info_t *,
+extern int crypto_register_provider(const crypto_provider_info_t *,
 		crypto_kcf_provider_handle_t *);
 extern int crypto_unregister_provider(crypto_kcf_provider_handle_t);
 extern void crypto_provider_notification(crypto_kcf_provider_handle_t, uint_t);
diff --git a/sys/contrib/openzfs/module/icp/include/sys/modctl.h b/sys/contrib/openzfs/module/icp/include/sys/modctl.h
deleted file mode 100644
index 6c26ad618c93..000000000000
--- a/sys/contrib/openzfs/module/icp/include/sys/modctl.h
+++ /dev/null
@@ -1,477 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#ifndef	_SYS_MODCTL_H
-#define	_SYS_MODCTL_H
-
-/*
- * loadable module support.
- */
-
-#include <sys/zfs_context.h>
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-struct modlmisc;
-struct modlinkage;
-
-/*
- * The following structure defines the operations used by modctl
- * to load and unload modules.  Each supported loadable module type
- * requires a set of mod_ops.
- */
-struct mod_ops {
-	int	(*modm_install)(struct modlmisc *, struct modlinkage *);
-	int	(*modm_remove)(struct modlmisc *, struct modlinkage *);
-	int	(*modm_info)(void *, struct modlinkage *, int *);
-};
-
-/*
- * The defined set of mod_ops structures for each loadable module type
- * Defined in modctl.c
- */
-extern struct mod_ops mod_brandops;
-#if defined(__i386) || defined(__amd64)
-extern struct mod_ops mod_cpuops;
-#endif
-extern struct mod_ops mod_cryptoops;
-extern struct mod_ops mod_driverops;
-extern struct mod_ops mod_execops;
-extern struct mod_ops mod_fsops;
-extern struct mod_ops mod_miscops;
-extern struct mod_ops mod_schedops;
-extern struct mod_ops mod_strmodops;
-extern struct mod_ops mod_syscallops;
-extern struct mod_ops mod_sockmodops;
-#ifdef _SYSCALL32_IMPL
-extern struct mod_ops mod_syscallops32;
-#endif
-extern struct mod_ops mod_dacfops;
-extern struct mod_ops mod_ippops;
-extern struct mod_ops mod_pcbeops;
-extern struct mod_ops mod_devfsops;
-extern struct mod_ops mod_kiconvops;
-
-/*
- * Definitions for the module specific linkage structures.
- * The first two fields are the same in all of the structures.
- * The linkinfo is for informational purposes only and is returned by
- * modctl with the MODINFO cmd.
- */
-
-/* For cryptographic providers */
-struct modlcrypto {
-	struct mod_ops		*crypto_modops;
-	char			*crypto_linkinfo;
-};
-
-/* For misc */
-struct modlmisc {
-	struct mod_ops		*misc_modops;
-	char			*misc_linkinfo;
-};
-
-/*
- * Revision number of loadable modules support.  This is the value
- * that must be used in the modlinkage structure.
- */
-#define	MODREV_1		1
-
-/*
- * The modlinkage structure is the structure that the module writer
- * provides to the routines to install, remove, and stat a module.
- * The ml_linkage element is an array of pointers to linkage structures.
- * For most modules there is only one linkage structure.  We allocate
- * enough space for 3 linkage structures which happens to be the most
- * we have in any sun supplied module.  For those modules with more
- * than 3 linkage structures (which is very unlikely), a modlinkage
- * structure must be kmem_alloc'd in the module wrapper to be big enough
- * for all of the linkage structures.
- */
-struct modlinkage {
-	int		ml_rev;		/* rev of loadable modules system */
-#ifdef _LP64
-	void		*ml_linkage[7];	/* more space in 64-bit OS */
-#else
-	void		*ml_linkage[4];	/* NULL terminated list of */
-					/* linkage structures */
-#endif
-};
-
-/*
- * commands.  These are the commands supported by the modctl system call.
- */
-#define	MODLOAD			0
-#define	MODUNLOAD		1
-#define	MODINFO			2
-#define	MODRESERVED		3
-#define	MODSETMINIROOT		4
-#define	MODADDMAJBIND		5
-#define	MODGETPATH		6
-#define	MODREADSYSBIND		7
-#define	MODGETMAJBIND		8
-#define	MODGETNAME		9
-#define	MODSIZEOF_DEVID		10
-#define	MODGETDEVID		11
-#define	MODSIZEOF_MINORNAME	12
-#define	MODGETMINORNAME		13
-#define	MODGETPATHLEN		14
-#define	MODEVENTS		15
-#define	MODGETFBNAME		16
-#define	MODREREADDACF		17
-#define	MODLOADDRVCONF		18
-#define	MODUNLOADDRVCONF	19
-#define	MODREMMAJBIND		20
-#define	MODDEVT2INSTANCE	21
-#define	MODGETDEVFSPATH_LEN	22
-#define	MODGETDEVFSPATH		23
-#define	MODDEVID2PATHS		24
-#define	MODSETDEVPOLICY		26
-#define	MODGETDEVPOLICY		27
-#define	MODALLOCPRIV		28
-#define	MODGETDEVPOLICYBYNAME	29
-#define	MODLOADMINORPERM	31
-#define	MODADDMINORPERM		32
-#define	MODREMMINORPERM		33
-#define	MODREMDRVCLEANUP	34
-#define	MODDEVEXISTS		35
-#define	MODDEVREADDIR		36
-#define	MODDEVNAME		37
-#define	MODGETDEVFSPATH_MI_LEN	38
-#define	MODGETDEVFSPATH_MI	39
-#define	MODRETIRE		40
-#define	MODUNRETIRE		41
-#define	MODISRETIRED		42
-#define	MODDEVEMPTYDIR		43
-#define	MODREMDRVALIAS		44
-
-/*
- * sub cmds for MODEVENTS
- */
-#define	MODEVENTS_FLUSH				0
-#define	MODEVENTS_FLUSH_DUMP			1
-#define	MODEVENTS_SET_DOOR_UPCALL_FILENAME	2
-#define	MODEVENTS_GETDATA			3
-#define	MODEVENTS_FREEDATA			4
-#define	MODEVENTS_POST_EVENT			5
-#define	MODEVENTS_REGISTER_EVENT		6
-
-/*
- * devname subcmds for MODDEVNAME
- */
-#define	MODDEVNAME_LOOKUPDOOR	0
-#define	MODDEVNAME_DEVFSADMNODE	1
-#define	MODDEVNAME_NSMAPS	2
-#define	MODDEVNAME_PROFILE	3
-#define	MODDEVNAME_RECONFIG	4
-#define	MODDEVNAME_SYSAVAIL	5
-
-
-/*
- * Data structure passed to modconfig command in kernel to build devfs tree
- */
-
-struct aliases {
-	struct aliases *a_next;
-	char *a_name;
-	int a_len;
-};
-
-#define	MAXMODCONFNAME	256
-
-struct modconfig {
-	char drvname[MAXMODCONFNAME];
-	char drvclass[MAXMODCONFNAME];
-	int major;
-	int flags;
-	int num_aliases;
-	struct aliases *ap;
-};
-
-#if defined(_SYSCALL32)
-
-struct aliases32 {
-	caddr32_t a_next;
-	caddr32_t a_name;
-	int32_t a_len;
-};
-
-struct modconfig32 {
-	char drvname[MAXMODCONFNAME];
-	char drvclass[MAXMODCONFNAME];
-	int32_t major;
-	int32_t flags;
-	int32_t num_aliases;
-	caddr32_t ap;
-};
-
-#endif /* _SYSCALL32 */
-
-/* flags for modconfig */
-#define	MOD_UNBIND_OVERRIDE	0x01		/* fail unbind if in use */
-
-/*
- * Max module path length
- */
-#define	MOD_MAXPATH	256
-
-/*
- * Default search path for modules ADDITIONAL to the directory
- * where the kernel components we booted from are.
- *
- * Most often, this will be "/platform/{platform}/kernel /kernel /usr/kernel",
- * but we don't wire it down here.
- */
-#define	MOD_DEFPATH	"/kernel /usr/kernel"
-
-/*
- * Default file name extension for autoloading modules.
- */
-#define	MOD_DEFEXT	""
-
-/*
- * Parameters for modinfo
- */
-#define	MODMAXNAMELEN 32		/* max module name length */
-#define	MODMAXLINKINFOLEN 32		/* max link info length */
-
-/*
- * Module specific information.
- */
-struct modspecific_info {
-	char	msi_linkinfo[MODMAXLINKINFOLEN]; /* name in linkage struct */
-	int	msi_p0;			/* module specific information */
-};
-
-/*
- * Structure returned by modctl with MODINFO command.
- */
-#define	MODMAXLINK 10			/* max linkages modinfo can handle */
-
-struct modinfo {
-	int		   mi_info;		/* Flags for info wanted */
-	int		   mi_state;		/* Flags for module state */
-	int		   mi_id;		/* id of this loaded module */
-	int		   mi_nextid;		/* id of next module or -1 */
-	caddr_t		   mi_base;		/* virtual addr of text */
-	size_t		   mi_size;		/* size of module in bytes */
-	int		   mi_rev;		/* loadable modules rev */
-	int		   mi_loadcnt;		/* # of times loaded */
-	char		   mi_name[MODMAXNAMELEN]; /* name of module */
-	struct modspecific_info mi_msinfo[MODMAXLINK];
-						/* mod specific info */
-};
-
-
-#if defined(_SYSCALL32)
-
-#define	MODMAXNAMELEN32 32		/* max module name length */
-#define	MODMAXLINKINFOLEN32 32		/* max link info length */
-#define	MODMAXLINK32 10			/* max linkages modinfo can handle */
-
-struct modspecific_info32 {
-	char	msi_linkinfo[MODMAXLINKINFOLEN32]; /* name in linkage struct */
-	int32_t	msi_p0;			/* module specific information */
-};
-
-struct modinfo32 {
-	int32_t		   mi_info;		/* Flags for info wanted */
-	int32_t		   mi_state;		/* Flags for module state */
-	int32_t		   mi_id;		/* id of this loaded module */
-	int32_t		   mi_nextid;		/* id of next module or -1 */
-	caddr32_t	   mi_base;		/* virtual addr of text */
-	uint32_t	   mi_size;		/* size of module in bytes */
-	int32_t		   mi_rev;		/* loadable modules rev */
-	int32_t		   mi_loadcnt;		/* # of times loaded */
-	char		   mi_name[MODMAXNAMELEN32]; /* name of module */
-	struct modspecific_info32 mi_msinfo[MODMAXLINK32];
-						/* mod specific info */
-};
-
-#endif /* _SYSCALL32 */
-
-/* Values for mi_info flags */
-#define	MI_INFO_ONE	1
-#define	MI_INFO_ALL	2
-#define	MI_INFO_CNT	4
-#define	MI_INFO_LINKAGE	8	/* used internally to extract modlinkage */
-/*
- * MI_INFO_NOBASE indicates caller does not need mi_base. Failure to use this
- * flag may lead 32-bit apps to receive an EOVERFLOW error from modctl(MODINFO)
- * when used with a 64-bit kernel.
- */
-#define	MI_INFO_NOBASE	16
-
-/* Values for mi_state */
-#define	MI_LOADED	1
-#define	MI_INSTALLED	2
-
-/*
- * Macros to vector to the appropriate module specific routine.
- */
-#define	MODL_INSTALL(MODL, MODLP) \
-	(*(MODL)->misc_modops->modm_install)(MODL, MODLP)
-#define	MODL_REMOVE(MODL, MODLP) \
-	(*(MODL)->misc_modops->modm_remove)(MODL, MODLP)
-#define	MODL_INFO(MODL, MODLP, P0) \
-	(*(MODL)->misc_modops->modm_info)(MODL, MODLP, P0)
-
-/*
- * Definitions for stubs
- */
-struct mod_stub_info {
-	uintptr_t mods_func_adr;
-	struct mod_modinfo *mods_modinfo;
-	uintptr_t mods_stub_adr;
-	int (*mods_errfcn)(void);
-	int mods_flag;			/* flags defined below */
-};
-
-/*
- * Definitions for mods_flag.
- */
-#define	MODS_WEAK	0x01		/* weak stub (not loaded if called) */
-#define	MODS_NOUNLOAD	0x02		/* module not unloadable (no _fini()) */
-#define	MODS_INSTALLED	0x10		/* module installed */
-
-struct mod_modinfo {
-	char *modm_module_name;
-	struct modctl *mp;
-	struct mod_stub_info modm_stubs[1];
-};
-
-struct modctl_list {
-	struct modctl_list *modl_next;
-	struct modctl *modl_modp;
-};
-
-/*
- * Structure to manage a loadable module.
- * Note: the module (mod_mp) structure's "text" and "text_size" information
- * are replicated in the modctl structure so that mod_containing_pc()
- * doesn't have to grab any locks (modctls are persistent; modules are not.)
- */
-typedef struct modctl {
-	struct modctl	*mod_next;	/* &modules based list */
-	struct modctl	*mod_prev;
-	int		mod_id;
-	void		*mod_mp;
-	kthread_t	*mod_inprogress_thread;
-	struct mod_modinfo *mod_modinfo;
-	struct modlinkage *mod_linkage;
-	char		*mod_filename;
-	char		*mod_modname;
-
-	char		mod_busy;	/* inprogress_thread has locked */
-	char		mod_want;	/* someone waiting for unlock */
-	char		mod_prim;	/* primary module */
-
-	int		mod_ref;	/* ref count - from dependent or stub */
-
-	char		mod_loaded;	/* module in memory */
-	char		mod_installed;	/* post _init pre _fini */
-	char		mod_loadflags;
-	char		mod_delay_unload;	/* deferred unload */
-
-	struct modctl_list *mod_requisites;	/* mods this one depends on. */
-	void		*____unused;	/* NOTE: reuse (same size) is OK, */
-					/* deletion causes mdb.vs.core issues */
-	int		mod_loadcnt;	/* number of times mod was loaded */
-	int		mod_nenabled;	/* # of enabled DTrace probes in mod */
-	char		*mod_text;
-	size_t		mod_text_size;
-
-	int		mod_gencount;	/* # times loaded/unloaded */
-	struct modctl	*mod_requisite_loading;	/* mod circular dependency */
-} modctl_t;
-
-/*
- * mod_loadflags
- */
-
-#define	MOD_NOAUTOUNLOAD	0x1	/* Auto mod-unloader skips this mod */
-#define	MOD_NONOTIFY		0x2	/* No krtld notifications on (un)load */
-#define	MOD_NOUNLOAD		0x4	/* Assume EBUSY for all _fini's */
-
-#define	MOD_BIND_HASHSIZE	64
-#define	MOD_BIND_HASHMASK	(MOD_BIND_HASHSIZE-1)
-
-typedef int modid_t;
-
-/*
- * global function and data declarations
- */
-extern kmutex_t mod_lock;
-
-extern char *systemfile;
-extern char **syscallnames;
-extern int moddebug;
-
-/*
- * this is the head of a doubly linked list.  Only the next and prev
- * pointers are used
- */
-extern modctl_t modules;
-
-/*
- * Only the following are part of the DDI/DKI
- */
-extern int	mod_install(struct modlinkage *);
-extern int	mod_remove(struct modlinkage *);
-extern int	mod_info(struct modlinkage *, struct modinfo *);
-
-/*
- * bit definitions for moddebug.
- */
-#define	MODDEBUG_LOADMSG	0x80000000	/* print "[un]loading..." msg */
-#define	MODDEBUG_ERRMSG		0x40000000	/* print detailed error msgs */
-#define	MODDEBUG_LOADMSG2	0x20000000	/* print 2nd level msgs */
-#define	MODDEBUG_RETIRE		0x10000000	/* print retire msgs */
-#define	MODDEBUG_BINDING	0x00040000	/* driver/alias binding */
-#define	MODDEBUG_FINI_EBUSY	0x00020000	/* pretend fini returns EBUSY */
-#define	MODDEBUG_NOAUL_IPP	0x00010000	/* no Autounloading ipp mods */
-#define	MODDEBUG_NOAUL_DACF	0x00008000	/* no Autounloading dacf mods */
-#define	MODDEBUG_KEEPTEXT	0x00004000	/* keep text after unloading */
-#define	MODDEBUG_NOAUL_DRV	0x00001000	/* no Autounloading Drivers */
-#define	MODDEBUG_NOAUL_EXEC	0x00000800	/* no Autounloading Execs */
-#define	MODDEBUG_NOAUL_FS	0x00000400	/* no Autounloading File sys */
-#define	MODDEBUG_NOAUL_MISC	0x00000200	/* no Autounloading misc */
-#define	MODDEBUG_NOAUL_SCHED	0x00000100	/* no Autounloading scheds */
-#define	MODDEBUG_NOAUL_STR	0x00000080	/* no Autounloading streams */
-#define	MODDEBUG_NOAUL_SYS	0x00000040	/* no Autounloading syscalls */
-#define	MODDEBUG_NOCTF		0x00000020	/* do not load CTF debug data */
-#define	MODDEBUG_NOAUTOUNLOAD	0x00000010	/* no autounloading at all */
-#define	MODDEBUG_DDI_MOD	0x00000008	/* ddi_mod{open,sym,close} */
-#define	MODDEBUG_MP_MATCH	0x00000004	/* dev_minorperm */
-#define	MODDEBUG_MINORPERM	0x00000002	/* minor perm modctls */
-#define	MODDEBUG_USERDEBUG	0x00000001	/* bpt after init_module() */
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _SYS_MODCTL_H */
diff --git a/sys/contrib/openzfs/module/icp/io/aes.c b/sys/contrib/openzfs/module/icp/io/aes.c
index c47c7567b900..be1736864c0b 100644
--- a/sys/contrib/openzfs/module/icp/io/aes.c
+++ b/sys/contrib/openzfs/module/icp/io/aes.c
@@ -32,31 +32,14 @@
 #include <sys/crypto/spi.h>
 #include <sys/crypto/icp.h>
 #include <modes/modes.h>
-#include <sys/modctl.h>
 #define	_AES_IMPL
 #include <aes/aes_impl.h>
 #include <modes/gcm_impl.h>
 
-#define	CRYPTO_PROVIDER_NAME "aes"
-
-extern struct mod_ops mod_cryptoops;
-
-/*
- * Module linkage information for the kernel.
- */
-static struct modlcrypto modlcrypto = {
-	&mod_cryptoops,
-	"AES Kernel SW Provider"
-};
-
-static struct modlinkage modlinkage = {
-	MODREV_1, { (void *)&modlcrypto, NULL }
-};
-
 /*
  * Mechanism info structure passed to KCF during registration.
  */
-static crypto_mech_info_t aes_mech_info_tab[] = {
+static const crypto_mech_info_t aes_mech_info_tab[] = {
 	/* AES_ECB */
 	{SUN_CKM_AES_ECB, AES_ECB_MECH_INFO_TYPE,
 	    CRYPTO_FG_ENCRYPT | CRYPTO_FG_ENCRYPT_ATOMIC |
@@ -94,7 +77,7 @@ static crypto_mech_info_t aes_mech_info_tab[] = {
 
 static void aes_provider_status(crypto_provider_handle_t, uint_t *);
 
-static crypto_control_ops_t aes_control_ops = {
+static const crypto_control_ops_t aes_control_ops = {
 	aes_provider_status
 };
 
@@ -127,7 +110,7 @@ static int aes_decrypt_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_key_t *, crypto_data_t *,
     crypto_data_t *, crypto_spi_ctx_template_t, crypto_req_handle_t);
 
-static crypto_cipher_ops_t aes_cipher_ops = {
+static const crypto_cipher_ops_t aes_cipher_ops = {
 	.encrypt_init = aes_encrypt_init,
 	.encrypt = aes_encrypt,
 	.encrypt_update = aes_encrypt_update,
@@ -147,7 +130,7 @@ static int aes_mac_verify_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_key_t *, crypto_data_t *, crypto_data_t *,
     crypto_spi_ctx_template_t, crypto_req_handle_t);
 
-static crypto_mac_ops_t aes_mac_ops = {
+static const crypto_mac_ops_t aes_mac_ops = {
 	.mac_init = NULL,
 	.mac = NULL,
 	.mac_update = NULL,
@@ -161,12 +144,12 @@ static int aes_create_ctx_template(crypto_provider_handle_t,
     size_t *, crypto_req_handle_t);
 static int aes_free_context(crypto_ctx_t *);
 
-static crypto_ctx_ops_t aes_ctx_ops = {
+static const crypto_ctx_ops_t aes_ctx_ops = {
 	.create_ctx_template = aes_create_ctx_template,
 	.free_context = aes_free_context
 };
 
-static crypto_ops_t aes_crypto_ops = {{{{{
+static const crypto_ops_t aes_crypto_ops = {{{{{
 	&aes_control_ops,
 	NULL,
 	&aes_cipher_ops,
@@ -183,13 +166,13 @@ static crypto_ops_t aes_crypto_ops = {{{{{
 	&aes_ctx_ops
 }}}}};
 
-static crypto_provider_info_t aes_prov_info = {{{{
+static const crypto_provider_info_t aes_prov_info = {{{{
 	CRYPTO_SPI_VERSION_1,
 	"AES Software Provider",
 	CRYPTO_SW_PROVIDER,
 	NULL,
 	&aes_crypto_ops,
-	sizeof (aes_mech_info_tab)/sizeof (crypto_mech_info_t),
+	sizeof (aes_mech_info_tab) / sizeof (crypto_mech_info_t),
 	aes_mech_info_tab
 }}}};
 
@@ -199,20 +182,13 @@ static crypto_data_t null_crypto_data = { CRYPTO_DATA_RAW };
 int
 aes_mod_init(void)
 {
-	int ret;
-
 	/* Determine the fastest available implementation. */
 	aes_impl_init();
 	gcm_impl_init();
 
-	if ((ret = mod_install(&modlinkage)) != 0)
-		return (ret);
-
 	/* Register with KCF.  If the registration fails, remove the module. */
-	if (crypto_register_provider(&aes_prov_info, &aes_prov_handle)) {
-		(void) mod_remove(&modlinkage);
+	if (crypto_register_provider(&aes_prov_info, &aes_prov_handle))
 		return (EACCES);
-	}
 
 	return (0);
 }
@@ -228,7 +204,7 @@ aes_mod_fini(void)
 		aes_prov_handle = 0;
 	}
 
-	return (mod_remove(&modlinkage));
+	return (0);
 }
 
 static int
@@ -311,10 +287,10 @@ init_keysched(crypto_key_t *key, void *newbie)
 /*
  * KCF software provider control entry points.
  */
-/* ARGSUSED */
 static void
 aes_provider_status(crypto_provider_handle_t provider, uint_t *status)
 {
+	(void) provider;
 	*status = CRYPTO_PROVIDER_READY;
 }
 
@@ -617,11 +593,11 @@ aes_decrypt(crypto_ctx_t *ctx, crypto_data_t *ciphertext,
 }
 
 
-/* ARGSUSED */
 static int
 aes_encrypt_update(crypto_ctx_t *ctx, crypto_data_t *plaintext,
     crypto_data_t *ciphertext, crypto_req_handle_t req)
 {
+	(void) req;
 	off_t saved_offset;
 	size_t saved_length, out_len;
 	int ret = CRYPTO_SUCCESS;
@@ -769,11 +745,11 @@ aes_decrypt_update(crypto_ctx_t *ctx, crypto_data_t *ciphertext,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 aes_encrypt_final(crypto_ctx_t *ctx, crypto_data_t *data,
     crypto_req_handle_t req)
 {
+	(void) req;
 	aes_ctx_t *aes_ctx;
 	int ret;
 
@@ -826,11 +802,11 @@ aes_encrypt_final(crypto_ctx_t *ctx, crypto_data_t *data,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 static int
 aes_decrypt_final(crypto_ctx_t *ctx, crypto_data_t *data,
     crypto_req_handle_t req)
 {
+	(void) req;
 	aes_ctx_t *aes_ctx;
 	int ret;
 	off_t saved_offset;
@@ -929,13 +905,13 @@ aes_decrypt_final(crypto_ctx_t *ctx, crypto_data_t *data,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 static int
 aes_encrypt_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_key_t *key, crypto_data_t *plaintext, crypto_data_t *ciphertext,
     crypto_spi_ctx_template_t template, crypto_req_handle_t req)
 {
+	(void) provider, (void) session_id;
 	aes_ctx_t aes_ctx;	/* on the stack */
 	off_t saved_offset;
 	size_t saved_length;
@@ -1065,13 +1041,13 @@ aes_encrypt_atomic(crypto_provider_handle_t provider,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 aes_decrypt_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_key_t *key, crypto_data_t *ciphertext, crypto_data_t *plaintext,
     crypto_spi_ctx_template_t template, crypto_req_handle_t req)
 {
+	(void) provider, (void) session_id;
 	aes_ctx_t aes_ctx;	/* on the stack */
 	off_t saved_offset;
 	size_t saved_length;
@@ -1235,12 +1211,12 @@ aes_decrypt_atomic(crypto_provider_handle_t provider,
 /*
  * KCF software provider context template entry points.
  */
-/* ARGSUSED */
 static int
 aes_create_ctx_template(crypto_provider_handle_t provider,
     crypto_mechanism_t *mechanism, crypto_key_t *key,
     crypto_spi_ctx_template_t *tmpl, size_t *tmpl_size, crypto_req_handle_t req)
 {
+	(void) provider;
 	void *keysched;
 	size_t size;
 	int rv;
diff --git a/sys/contrib/openzfs/module/icp/io/edonr_mod.c b/sys/contrib/openzfs/module/icp/io/edonr_mod.c
deleted file mode 100644
index a806af610629..000000000000
--- a/sys/contrib/openzfs/module/icp/io/edonr_mod.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://opensource.org/licenses/CDDL-1.0.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2013 Saso Kiselkov. All rights reserved.
- */
-
-#include <sys/modctl.h>
-#include <sys/crypto/common.h>
-#include <sys/crypto/icp.h>
-#include <sys/crypto/spi.h>
-#include <sys/sysmacros.h>
-#include <sys/edonr.h>
-
-/*
- * Unlike sha2 or skein, we won't expose edonr via the Kernel Cryptographic
- * Framework (KCF), because Edon-R is *NOT* suitable for general-purpose
- * cryptographic use. Users of Edon-R must interface directly to this module.
- */
-
-static struct modlmisc modlmisc = {
-	&mod_cryptoops,
-	"Edon-R Message-Digest Algorithm"
-};
-
-static struct modlinkage modlinkage = {
-	MODREV_1, {&modlmisc, NULL}
-};
-
-int
-edonr_mod_init(void)
-{
-	int error;
-
-	if ((error = mod_install(&modlinkage)) != 0)
-		return (error);
-
-	return (0);
-}
-
-int
-edonr_mod_fini(void)
-{
-	return (mod_remove(&modlinkage));
-}
diff --git a/sys/contrib/openzfs/module/icp/io/sha1_mod.c b/sys/contrib/openzfs/module/icp/io/sha1_mod.c
deleted file mode 100644
index 6dcee6b2ecf2..000000000000
--- a/sys/contrib/openzfs/module/icp/io/sha1_mod.c
+++ /dev/null
@@ -1,1230 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-
-/*
- * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#include <sys/zfs_context.h>
-#include <sys/modctl.h>
-#include <sys/crypto/common.h>
-#include <sys/crypto/icp.h>
-#include <sys/crypto/spi.h>
-
-#include <sha1/sha1.h>
-#include <sha1/sha1_impl.h>
-
-/*
- * The sha1 module is created with two modlinkages:
- * - a modlmisc that allows consumers to directly call the entry points
- *   SHA1Init, SHA1Update, and SHA1Final.
- * - a modlcrypto that allows the module to register with the Kernel
- *   Cryptographic Framework (KCF) as a software provider for the SHA1
- *   mechanisms.
- */
-
-static struct modlcrypto modlcrypto = {
-	&mod_cryptoops,
-	"SHA1 Kernel SW Provider 1.1"
-};
-
-static struct modlinkage modlinkage = {
-	MODREV_1, { &modlcrypto, NULL }
-};
-
-
-/*
- * Macros to access the SHA1 or SHA1-HMAC contexts from a context passed
- * by KCF to one of the entry points.
- */
-
-#define	PROV_SHA1_CTX(ctx)	((sha1_ctx_t *)(ctx)->cc_provider_private)
-#define	PROV_SHA1_HMAC_CTX(ctx)	((sha1_hmac_ctx_t *)(ctx)->cc_provider_private)
-
-/* to extract the digest length passed as mechanism parameter */
-#define	PROV_SHA1_GET_DIGEST_LEN(m, len) {				\
-	if (IS_P2ALIGNED((m)->cm_param, sizeof (ulong_t)))		\
-		(len) = (uint32_t)*((ulong_t *)(void *)mechanism->cm_param); \
-	else {								\
-		ulong_t tmp_ulong;					\
-		bcopy((m)->cm_param, &tmp_ulong, sizeof (ulong_t));	\
-		(len) = (uint32_t)tmp_ulong;				\
-	}								\
-}
-
-#define	PROV_SHA1_DIGEST_KEY(ctx, key, len, digest) {	\
-	SHA1Init(ctx);					\
-	SHA1Update(ctx, key, len);			\
-	SHA1Final(digest, ctx);				\
-}
-
-/*
- * Mechanism info structure passed to KCF during registration.
- */
-static crypto_mech_info_t sha1_mech_info_tab[] = {
-	/* SHA1 */
-	{SUN_CKM_SHA1, SHA1_MECH_INFO_TYPE,
-	    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC,
-	    0, 0, CRYPTO_KEYSIZE_UNIT_IN_BITS},
-	/* SHA1-HMAC */
-	{SUN_CKM_SHA1_HMAC, SHA1_HMAC_MECH_INFO_TYPE,
-	    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC,
-	    SHA1_HMAC_MIN_KEY_LEN, SHA1_HMAC_MAX_KEY_LEN,
-	    CRYPTO_KEYSIZE_UNIT_IN_BYTES},
-	/* SHA1-HMAC GENERAL */
-	{SUN_CKM_SHA1_HMAC_GENERAL, SHA1_HMAC_GEN_MECH_INFO_TYPE,
-	    CRYPTO_FG_MAC | CRYPTO_FG_MAC_ATOMIC,
-	    SHA1_HMAC_MIN_KEY_LEN, SHA1_HMAC_MAX_KEY_LEN,
-	    CRYPTO_KEYSIZE_UNIT_IN_BYTES}
-};
-
-static void sha1_provider_status(crypto_provider_handle_t, uint_t *);
-
-static crypto_control_ops_t sha1_control_ops = {
-	sha1_provider_status
-};
-
-static int sha1_digest_init(crypto_ctx_t *, crypto_mechanism_t *,
-    crypto_req_handle_t);
-static int sha1_digest(crypto_ctx_t *, crypto_data_t *, crypto_data_t *,
-    crypto_req_handle_t);
-static int sha1_digest_update(crypto_ctx_t *, crypto_data_t *,
-    crypto_req_handle_t);
-static int sha1_digest_final(crypto_ctx_t *, crypto_data_t *,
-    crypto_req_handle_t);
-static int sha1_digest_atomic(crypto_provider_handle_t, crypto_session_id_t,
-    crypto_mechanism_t *, crypto_data_t *, crypto_data_t *,
-    crypto_req_handle_t);
-
-static crypto_digest_ops_t sha1_digest_ops = {
-	.digest_init = sha1_digest_init,
-	.digest = sha1_digest,
-	.digest_update = sha1_digest_update,
-	.digest_key = NULL,
-	.digest_final = sha1_digest_final,
-	.digest_atomic = sha1_digest_atomic
-};
-
-static int sha1_mac_init(crypto_ctx_t *, crypto_mechanism_t *, crypto_key_t *,
-    crypto_spi_ctx_template_t, crypto_req_handle_t);
-static int sha1_mac_update(crypto_ctx_t *, crypto_data_t *,
-    crypto_req_handle_t);
-static int sha1_mac_final(crypto_ctx_t *, crypto_data_t *, crypto_req_handle_t);
-static int sha1_mac_atomic(crypto_provider_handle_t, crypto_session_id_t,
-    crypto_mechanism_t *, crypto_key_t *, crypto_data_t *, crypto_data_t *,
-    crypto_spi_ctx_template_t, crypto_req_handle_t);
-static int sha1_mac_verify_atomic(crypto_provider_handle_t, crypto_session_id_t,
-    crypto_mechanism_t *, crypto_key_t *, crypto_data_t *, crypto_data_t *,
-    crypto_spi_ctx_template_t, crypto_req_handle_t);
-
-static crypto_mac_ops_t sha1_mac_ops = {
-	.mac_init = sha1_mac_init,
-	.mac = NULL,
-	.mac_update = sha1_mac_update,
-	.mac_final = sha1_mac_final,
-	.mac_atomic = sha1_mac_atomic,
-	.mac_verify_atomic = sha1_mac_verify_atomic
-};
-
-static int sha1_create_ctx_template(crypto_provider_handle_t,
-    crypto_mechanism_t *, crypto_key_t *, crypto_spi_ctx_template_t *,
-    size_t *, crypto_req_handle_t);
-static int sha1_free_context(crypto_ctx_t *);
-
-static crypto_ctx_ops_t sha1_ctx_ops = {
-	.create_ctx_template = sha1_create_ctx_template,
-	.free_context = sha1_free_context
-};
-
-static crypto_ops_t sha1_crypto_ops = {{{{{
-	&sha1_control_ops,
-	&sha1_digest_ops,
-	NULL,
-	&sha1_mac_ops,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	&sha1_ctx_ops,
-}}}}};
-
-static crypto_provider_info_t sha1_prov_info = {{{{
-	CRYPTO_SPI_VERSION_1,
-	"SHA1 Software Provider",
-	CRYPTO_SW_PROVIDER,
-	NULL,
-	&sha1_crypto_ops,
-	sizeof (sha1_mech_info_tab)/sizeof (crypto_mech_info_t),
-	sha1_mech_info_tab
-}}}};
-
-static crypto_kcf_provider_handle_t sha1_prov_handle = 0;
-
-int
-sha1_mod_init(void)
-{
-	int ret;
-
-	if ((ret = mod_install(&modlinkage)) != 0)
-		return (ret);
-
-	/*
-	 * Register with KCF. If the registration fails, log an
-	 * error but do not uninstall the module, since the functionality
-	 * provided by misc/sha1 should still be available.
-	 */
-	if ((ret = crypto_register_provider(&sha1_prov_info,
-	    &sha1_prov_handle)) != CRYPTO_SUCCESS)
-		cmn_err(CE_WARN, "sha1 _init: "
-		    "crypto_register_provider() failed (0x%x)", ret);
-
-	return (0);
-}
-
-int
-sha1_mod_fini(void)
-{
-	int ret;
-
-	if (sha1_prov_handle != 0) {
-		if ((ret = crypto_unregister_provider(sha1_prov_handle)) !=
-		    CRYPTO_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "sha1 _fini: crypto_unregister_provider() "
-			    "failed (0x%x)", ret);
-			return (EBUSY);
-		}
-		sha1_prov_handle = 0;
-	}
-
-	return (mod_remove(&modlinkage));
-}
-
-/*
- * KCF software provider control entry points.
- */
-/* ARGSUSED */
-static void
-sha1_provider_status(crypto_provider_handle_t provider, uint_t *status)
-{
-	*status = CRYPTO_PROVIDER_READY;
-}
-
-/*
- * KCF software provider digest entry points.
- */
-
-static int
-sha1_digest_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,
-    crypto_req_handle_t req)
-{
-	if (mechanism->cm_type != SHA1_MECH_INFO_TYPE)
-		return (CRYPTO_MECHANISM_INVALID);
-
-	/*
-	 * Allocate and initialize SHA1 context.
-	 */
-	ctx->cc_provider_private = kmem_alloc(sizeof (sha1_ctx_t),
-	    crypto_kmflag(req));
-	if (ctx->cc_provider_private == NULL)
-		return (CRYPTO_HOST_MEMORY);
-
-	PROV_SHA1_CTX(ctx)->sc_mech_type = SHA1_MECH_INFO_TYPE;
-	SHA1Init(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx);
-
-	return (CRYPTO_SUCCESS);
-}
-
-/*
- * Helper SHA1 digest update function for uio data.
- */
-static int
-sha1_digest_update_uio(SHA1_CTX *sha1_ctx, crypto_data_t *data)
-{
-	off_t offset = data->cd_offset;
-	size_t length = data->cd_length;
-	uint_t vec_idx = 0;
-	size_t cur_len;
-
-	/* we support only kernel buffer */
-	if (zfs_uio_segflg(data->cd_uio) != UIO_SYSSPACE)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	/*
-	 * Jump to the first iovec containing data to be
-	 * digested.
-	 */
-	offset = zfs_uio_index_at_offset(data->cd_uio, offset, &vec_idx);
-	if (vec_idx == zfs_uio_iovcnt(data->cd_uio)) {
-		/*
-		 * The caller specified an offset that is larger than the
-		 * total size of the buffers it provided.
-		 */
-		return (CRYPTO_DATA_LEN_RANGE);
-	}
-
-	/*
-	 * Now do the digesting on the iovecs.
-	 */
-	while (vec_idx < zfs_uio_iovcnt(data->cd_uio) && length > 0) {
-		cur_len = MIN(zfs_uio_iovlen(data->cd_uio, vec_idx) -
-		    offset, length);
-
-		SHA1Update(sha1_ctx,
-		    (uint8_t *)zfs_uio_iovbase(data->cd_uio, vec_idx) + offset,
-		    cur_len);
-
-		length -= cur_len;
-		vec_idx++;
-		offset = 0;
-	}
-
-	if (vec_idx == zfs_uio_iovcnt(data->cd_uio) && length > 0) {
-		/*
-		 * The end of the specified iovec's was reached but
-		 * the length requested could not be processed, i.e.
-		 * The caller requested to digest more data than it provided.
-		 */
-		return (CRYPTO_DATA_LEN_RANGE);
-	}
-
-	return (CRYPTO_SUCCESS);
-}
-
-/*
- * Helper SHA1 digest final function for uio data.
- * digest_len is the length of the desired digest. If digest_len
- * is smaller than the default SHA1 digest length, the caller
- * must pass a scratch buffer, digest_scratch, which must
- * be at least SHA1_DIGEST_LENGTH bytes.
- */
-static int
-sha1_digest_final_uio(SHA1_CTX *sha1_ctx, crypto_data_t *digest,
-    ulong_t digest_len, uchar_t *digest_scratch)
-{
-	off_t offset = digest->cd_offset;
-	uint_t vec_idx = 0;
-
-	/* we support only kernel buffer */
-	if (zfs_uio_segflg(digest->cd_uio) != UIO_SYSSPACE)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	/*
-	 * Jump to the first iovec containing ptr to the digest to
-	 * be returned.
-	 */
-	offset = zfs_uio_index_at_offset(digest->cd_uio, offset, &vec_idx);
-	if (vec_idx == zfs_uio_iovcnt(digest->cd_uio)) {
-		/*
-		 * The caller specified an offset that is
-		 * larger than the total size of the buffers
-		 * it provided.
-		 */
-		return (CRYPTO_DATA_LEN_RANGE);
-	}
-
-	if (offset + digest_len <=
-	    zfs_uio_iovlen(digest->cd_uio, vec_idx)) {
-		/*
-		 * The computed SHA1 digest will fit in the current
-		 * iovec.
-		 */
-		if (digest_len != SHA1_DIGEST_LENGTH) {
-			/*
-			 * The caller requested a short digest. Digest
-			 * into a scratch buffer and return to
-			 * the user only what was requested.
-			 */
-			SHA1Final(digest_scratch, sha1_ctx);
-			bcopy(digest_scratch, (uchar_t *)
-			    zfs_uio_iovbase(digest->cd_uio, vec_idx) + offset,
-			    digest_len);
-		} else {
-			SHA1Final((uchar_t *)zfs_uio_iovbase(digest->
-			    cd_uio, vec_idx) + offset,
-			    sha1_ctx);
-		}
-	} else {
-		/*
-		 * The computed digest will be crossing one or more iovec's.
-		 * This is bad performance-wise but we need to support it.
-		 * Allocate a small scratch buffer on the stack and
-		 * copy it piece meal to the specified digest iovec's.
-		 */
-		uchar_t digest_tmp[SHA1_DIGEST_LENGTH];
-		off_t scratch_offset = 0;
-		size_t length = digest_len;
-		size_t cur_len;
-
-		SHA1Final(digest_tmp, sha1_ctx);
-
-		while (vec_idx < zfs_uio_iovcnt(digest->cd_uio) && length > 0) {
-			cur_len = MIN(zfs_uio_iovlen(digest->cd_uio, vec_idx) -
-			    offset, length);
-			bcopy(digest_tmp + scratch_offset,
-			    zfs_uio_iovbase(digest->cd_uio, vec_idx) + offset,
-			    cur_len);
-
-			length -= cur_len;
-			vec_idx++;
-			scratch_offset += cur_len;
-			offset = 0;
-		}
-
-		if (vec_idx == zfs_uio_iovcnt(digest->cd_uio) && length > 0) {
-			/*
-			 * The end of the specified iovec's was reached but
-			 * the length requested could not be processed, i.e.
-			 * The caller requested to digest more data than it
-			 * provided.
-			 */
-			return (CRYPTO_DATA_LEN_RANGE);
-		}
-	}
-
-	return (CRYPTO_SUCCESS);
-}
-
-/* ARGSUSED */
-static int
-sha1_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest,
-    crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-
-	ASSERT(ctx->cc_provider_private != NULL);
-
-	/*
-	 * We need to just return the length needed to store the output.
-	 * We should not destroy the context for the following cases.
-	 */
-	if ((digest->cd_length == 0) ||
-	    (digest->cd_length < SHA1_DIGEST_LENGTH)) {
-		digest->cd_length = SHA1_DIGEST_LENGTH;
-		return (CRYPTO_BUFFER_TOO_SMALL);
-	}
-
-	/*
-	 * Do the SHA1 update on the specified input data.
-	 */
-	switch (data->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Update(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,
-		    data->cd_length);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_update_uio(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    data);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	if (ret != CRYPTO_SUCCESS) {
-		/* the update failed, free context and bail */
-		kmem_free(ctx->cc_provider_private, sizeof (sha1_ctx_t));
-		ctx->cc_provider_private = NULL;
-		digest->cd_length = 0;
-		return (ret);
-	}
-
-	/*
-	 * Do a SHA1 final, must be done separately since the digest
-	 * type can be different than the input data type.
-	 */
-	switch (digest->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Final((unsigned char *)digest->cd_raw.iov_base +
-		    digest->cd_offset, &PROV_SHA1_CTX(ctx)->sc_sha1_ctx);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_final_uio(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    digest, SHA1_DIGEST_LENGTH, NULL);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	/* all done, free context and return */
-
-	if (ret == CRYPTO_SUCCESS) {
-		digest->cd_length = SHA1_DIGEST_LENGTH;
-	} else {
-		digest->cd_length = 0;
-	}
-
-	kmem_free(ctx->cc_provider_private, sizeof (sha1_ctx_t));
-	ctx->cc_provider_private = NULL;
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_digest_update(crypto_ctx_t *ctx, crypto_data_t *data,
-    crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-
-	ASSERT(ctx->cc_provider_private != NULL);
-
-	/*
-	 * Do the SHA1 update on the specified input data.
-	 */
-	switch (data->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Update(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,
-		    data->cd_length);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_update_uio(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    data);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_digest_final(crypto_ctx_t *ctx, crypto_data_t *digest,
-    crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-
-	ASSERT(ctx->cc_provider_private != NULL);
-
-	/*
-	 * We need to just return the length needed to store the output.
-	 * We should not destroy the context for the following cases.
-	 */
-	if ((digest->cd_length == 0) ||
-	    (digest->cd_length < SHA1_DIGEST_LENGTH)) {
-		digest->cd_length = SHA1_DIGEST_LENGTH;
-		return (CRYPTO_BUFFER_TOO_SMALL);
-	}
-
-	/*
-	 * Do a SHA1 final.
-	 */
-	switch (digest->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Final((unsigned char *)digest->cd_raw.iov_base +
-		    digest->cd_offset, &PROV_SHA1_CTX(ctx)->sc_sha1_ctx);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_final_uio(&PROV_SHA1_CTX(ctx)->sc_sha1_ctx,
-		    digest, SHA1_DIGEST_LENGTH, NULL);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	/* all done, free context and return */
-
-	if (ret == CRYPTO_SUCCESS) {
-		digest->cd_length = SHA1_DIGEST_LENGTH;
-	} else {
-		digest->cd_length = 0;
-	}
-
-	kmem_free(ctx->cc_provider_private, sizeof (sha1_ctx_t));
-	ctx->cc_provider_private = NULL;
-
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_digest_atomic(crypto_provider_handle_t provider,
-    crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
-    crypto_data_t *data, crypto_data_t *digest,
-    crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-	SHA1_CTX sha1_ctx;
-
-	if (mechanism->cm_type != SHA1_MECH_INFO_TYPE)
-		return (CRYPTO_MECHANISM_INVALID);
-
-	/*
-	 * Do the SHA1 init.
-	 */
-	SHA1Init(&sha1_ctx);
-
-	/*
-	 * Do the SHA1 update on the specified input data.
-	 */
-	switch (data->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Update(&sha1_ctx,
-		    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,
-		    data->cd_length);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_update_uio(&sha1_ctx, data);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	if (ret != CRYPTO_SUCCESS) {
-		/* the update failed, bail */
-		digest->cd_length = 0;
-		return (ret);
-	}
-
-	/*
-	 * Do a SHA1 final, must be done separately since the digest
-	 * type can be different than the input data type.
-	 */
-	switch (digest->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Final((unsigned char *)digest->cd_raw.iov_base +
-		    digest->cd_offset, &sha1_ctx);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_final_uio(&sha1_ctx, digest,
-		    SHA1_DIGEST_LENGTH, NULL);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	if (ret == CRYPTO_SUCCESS) {
-		digest->cd_length = SHA1_DIGEST_LENGTH;
-	} else {
-		digest->cd_length = 0;
-	}
-
-	return (ret);
-}
-
-/*
- * KCF software provider mac entry points.
- *
- * SHA1 HMAC is: SHA1(key XOR opad, SHA1(key XOR ipad, text))
- *
- * Init:
- * The initialization routine initializes what we denote
- * as the inner and outer contexts by doing
- * - for inner context: SHA1(key XOR ipad)
- * - for outer context: SHA1(key XOR opad)
- *
- * Update:
- * Each subsequent SHA1 HMAC update will result in an
- * update of the inner context with the specified data.
- *
- * Final:
- * The SHA1 HMAC final will do a SHA1 final operation on the
- * inner context, and the resulting digest will be used
- * as the data for an update on the outer context. Last
- * but not least, a SHA1 final on the outer context will
- * be performed to obtain the SHA1 HMAC digest to return
- * to the user.
- */
-
-/*
- * Initialize a SHA1-HMAC context.
- */
-static void
-sha1_mac_init_ctx(sha1_hmac_ctx_t *ctx, void *keyval, uint_t length_in_bytes)
-{
-	uint32_t ipad[SHA1_HMAC_INTS_PER_BLOCK];
-	uint32_t opad[SHA1_HMAC_INTS_PER_BLOCK];
-	uint_t i;
-
-	bzero(ipad, SHA1_HMAC_BLOCK_SIZE);
-	bzero(opad, SHA1_HMAC_BLOCK_SIZE);
-
-	bcopy(keyval, ipad, length_in_bytes);
-	bcopy(keyval, opad, length_in_bytes);
-
-	/* XOR key with ipad (0x36) and opad (0x5c) */
-	for (i = 0; i < SHA1_HMAC_INTS_PER_BLOCK; i++) {
-		ipad[i] ^= 0x36363636;
-		opad[i] ^= 0x5c5c5c5c;
-	}
-
-	/* perform SHA1 on ipad */
-	SHA1Init(&ctx->hc_icontext);
-	SHA1Update(&ctx->hc_icontext, (uint8_t *)ipad, SHA1_HMAC_BLOCK_SIZE);
-
-	/* perform SHA1 on opad */
-	SHA1Init(&ctx->hc_ocontext);
-	SHA1Update(&ctx->hc_ocontext, (uint8_t *)opad, SHA1_HMAC_BLOCK_SIZE);
-}
-
-/*
- */
-static int
-sha1_mac_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,
-    crypto_key_t *key, crypto_spi_ctx_template_t ctx_template,
-    crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-	uint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);
-
-	if (mechanism->cm_type != SHA1_HMAC_MECH_INFO_TYPE &&
-	    mechanism->cm_type != SHA1_HMAC_GEN_MECH_INFO_TYPE)
-		return (CRYPTO_MECHANISM_INVALID);
-
-	/* Add support for key by attributes (RFE 4706552) */
-	if (key->ck_format != CRYPTO_KEY_RAW)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	ctx->cc_provider_private = kmem_alloc(sizeof (sha1_hmac_ctx_t),
-	    crypto_kmflag(req));
-	if (ctx->cc_provider_private == NULL)
-		return (CRYPTO_HOST_MEMORY);
-
-	if (ctx_template != NULL) {
-		/* reuse context template */
-		bcopy(ctx_template, PROV_SHA1_HMAC_CTX(ctx),
-		    sizeof (sha1_hmac_ctx_t));
-	} else {
-		/* no context template, compute context */
-		if (keylen_in_bytes > SHA1_HMAC_BLOCK_SIZE) {
-			uchar_t digested_key[SHA1_DIGEST_LENGTH];
-			sha1_hmac_ctx_t *hmac_ctx = ctx->cc_provider_private;
-
-			/*
-			 * Hash the passed-in key to get a smaller key.
-			 * The inner context is used since it hasn't been
-			 * initialized yet.
-			 */
-			PROV_SHA1_DIGEST_KEY(&hmac_ctx->hc_icontext,
-			    key->ck_data, keylen_in_bytes, digested_key);
-			sha1_mac_init_ctx(PROV_SHA1_HMAC_CTX(ctx),
-			    digested_key, SHA1_DIGEST_LENGTH);
-		} else {
-			sha1_mac_init_ctx(PROV_SHA1_HMAC_CTX(ctx),
-			    key->ck_data, keylen_in_bytes);
-		}
-	}
-
-	/*
-	 * Get the mechanism parameters, if applicable.
-	 */
-	PROV_SHA1_HMAC_CTX(ctx)->hc_mech_type = mechanism->cm_type;
-	if (mechanism->cm_type == SHA1_HMAC_GEN_MECH_INFO_TYPE) {
-		if (mechanism->cm_param == NULL ||
-		    mechanism->cm_param_len != sizeof (ulong_t))
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-		PROV_SHA1_GET_DIGEST_LEN(mechanism,
-		    PROV_SHA1_HMAC_CTX(ctx)->hc_digest_len);
-		if (PROV_SHA1_HMAC_CTX(ctx)->hc_digest_len >
-		    SHA1_DIGEST_LENGTH)
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-	}
-
-	if (ret != CRYPTO_SUCCESS) {
-		bzero(ctx->cc_provider_private, sizeof (sha1_hmac_ctx_t));
-		kmem_free(ctx->cc_provider_private, sizeof (sha1_hmac_ctx_t));
-		ctx->cc_provider_private = NULL;
-	}
-
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_mac_update(crypto_ctx_t *ctx, crypto_data_t *data, crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-
-	ASSERT(ctx->cc_provider_private != NULL);
-
-	/*
-	 * Do a SHA1 update of the inner context using the specified
-	 * data.
-	 */
-	switch (data->cd_format) {
-	case CRYPTO_DATA_RAW:
-		SHA1Update(&PROV_SHA1_HMAC_CTX(ctx)->hc_icontext,
-		    (uint8_t *)data->cd_raw.iov_base + data->cd_offset,
-		    data->cd_length);
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_update_uio(
-		    &PROV_SHA1_HMAC_CTX(ctx)->hc_icontext, data);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_mac_final(crypto_ctx_t *ctx, crypto_data_t *mac, crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-	uchar_t digest[SHA1_DIGEST_LENGTH];
-	uint32_t digest_len = SHA1_DIGEST_LENGTH;
-
-	ASSERT(ctx->cc_provider_private != NULL);
-
-	if (PROV_SHA1_HMAC_CTX(ctx)->hc_mech_type ==
-	    SHA1_HMAC_GEN_MECH_INFO_TYPE)
-		digest_len = PROV_SHA1_HMAC_CTX(ctx)->hc_digest_len;
-
-	/*
-	 * We need to just return the length needed to store the output.
-	 * We should not destroy the context for the following cases.
-	 */
-	if ((mac->cd_length == 0) || (mac->cd_length < digest_len)) {
-		mac->cd_length = digest_len;
-		return (CRYPTO_BUFFER_TOO_SMALL);
-	}
-
-	/*
-	 * Do a SHA1 final on the inner context.
-	 */
-	SHA1Final(digest, &PROV_SHA1_HMAC_CTX(ctx)->hc_icontext);
-
-	/*
-	 * Do a SHA1 update on the outer context, feeding the inner
-	 * digest as data.
-	 */
-	SHA1Update(&PROV_SHA1_HMAC_CTX(ctx)->hc_ocontext, digest,
-	    SHA1_DIGEST_LENGTH);
-
-	/*
-	 * Do a SHA1 final on the outer context, storing the computing
-	 * digest in the users buffer.
-	 */
-	switch (mac->cd_format) {
-	case CRYPTO_DATA_RAW:
-		if (digest_len != SHA1_DIGEST_LENGTH) {
-			/*
-			 * The caller requested a short digest. Digest
-			 * into a scratch buffer and return to
-			 * the user only what was requested.
-			 */
-			SHA1Final(digest,
-			    &PROV_SHA1_HMAC_CTX(ctx)->hc_ocontext);
-			bcopy(digest, (unsigned char *)mac->cd_raw.iov_base +
-			    mac->cd_offset, digest_len);
-		} else {
-			SHA1Final((unsigned char *)mac->cd_raw.iov_base +
-			    mac->cd_offset,
-			    &PROV_SHA1_HMAC_CTX(ctx)->hc_ocontext);
-		}
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_final_uio(
-		    &PROV_SHA1_HMAC_CTX(ctx)->hc_ocontext, mac,
-		    digest_len, digest);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	if (ret == CRYPTO_SUCCESS) {
-		mac->cd_length = digest_len;
-	} else {
-		mac->cd_length = 0;
-	}
-
-	bzero(ctx->cc_provider_private, sizeof (sha1_hmac_ctx_t));
-	kmem_free(ctx->cc_provider_private, sizeof (sha1_hmac_ctx_t));
-	ctx->cc_provider_private = NULL;
-
-	return (ret);
-}
-
-#define	SHA1_MAC_UPDATE(data, ctx, ret) {				\
-	switch (data->cd_format) {					\
-	case CRYPTO_DATA_RAW:						\
-		SHA1Update(&(ctx).hc_icontext,				\
-		    (uint8_t *)data->cd_raw.iov_base +			\
-		    data->cd_offset, data->cd_length);			\
-		break;							\
-	case CRYPTO_DATA_UIO:						\
-		ret = sha1_digest_update_uio(&(ctx).hc_icontext, data); \
-		break;							\
-	default:							\
-		ret = CRYPTO_ARGUMENTS_BAD;				\
-	}								\
-}
-
-/* ARGSUSED */
-static int
-sha1_mac_atomic(crypto_provider_handle_t provider,
-    crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
-    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,
-    crypto_spi_ctx_template_t ctx_template, crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-	uchar_t digest[SHA1_DIGEST_LENGTH];
-	sha1_hmac_ctx_t sha1_hmac_ctx;
-	uint32_t digest_len = SHA1_DIGEST_LENGTH;
-	uint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);
-
-	if (mechanism->cm_type != SHA1_HMAC_MECH_INFO_TYPE &&
-	    mechanism->cm_type != SHA1_HMAC_GEN_MECH_INFO_TYPE)
-		return (CRYPTO_MECHANISM_INVALID);
-
-	/* Add support for key by attributes (RFE 4706552) */
-	if (key->ck_format != CRYPTO_KEY_RAW)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	if (ctx_template != NULL) {
-		/* reuse context template */
-		bcopy(ctx_template, &sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-	} else {
-		/* no context template, initialize context */
-		if (keylen_in_bytes > SHA1_HMAC_BLOCK_SIZE) {
-			/*
-			 * Hash the passed-in key to get a smaller key.
-			 * The inner context is used since it hasn't been
-			 * initialized yet.
-			 */
-			PROV_SHA1_DIGEST_KEY(&sha1_hmac_ctx.hc_icontext,
-			    key->ck_data, keylen_in_bytes, digest);
-			sha1_mac_init_ctx(&sha1_hmac_ctx, digest,
-			    SHA1_DIGEST_LENGTH);
-		} else {
-			sha1_mac_init_ctx(&sha1_hmac_ctx, key->ck_data,
-			    keylen_in_bytes);
-		}
-	}
-
-	/* get the mechanism parameters, if applicable */
-	if (mechanism->cm_type == SHA1_HMAC_GEN_MECH_INFO_TYPE) {
-		if (mechanism->cm_param == NULL ||
-		    mechanism->cm_param_len != sizeof (ulong_t)) {
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-			goto bail;
-		}
-		PROV_SHA1_GET_DIGEST_LEN(mechanism, digest_len);
-		if (digest_len > SHA1_DIGEST_LENGTH) {
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-			goto bail;
-		}
-	}
-
-	/* do a SHA1 update of the inner context using the specified data */
-	SHA1_MAC_UPDATE(data, sha1_hmac_ctx, ret);
-	if (ret != CRYPTO_SUCCESS)
-		/* the update failed, free context and bail */
-		goto bail;
-
-	/*
-	 * Do a SHA1 final on the inner context.
-	 */
-	SHA1Final(digest, &sha1_hmac_ctx.hc_icontext);
-
-	/*
-	 * Do an SHA1 update on the outer context, feeding the inner
-	 * digest as data.
-	 */
-	SHA1Update(&sha1_hmac_ctx.hc_ocontext, digest, SHA1_DIGEST_LENGTH);
-
-	/*
-	 * Do a SHA1 final on the outer context, storing the computed
-	 * digest in the users buffer.
-	 */
-	switch (mac->cd_format) {
-	case CRYPTO_DATA_RAW:
-		if (digest_len != SHA1_DIGEST_LENGTH) {
-			/*
-			 * The caller requested a short digest. Digest
-			 * into a scratch buffer and return to
-			 * the user only what was requested.
-			 */
-			SHA1Final(digest, &sha1_hmac_ctx.hc_ocontext);
-			bcopy(digest, (unsigned char *)mac->cd_raw.iov_base +
-			    mac->cd_offset, digest_len);
-		} else {
-			SHA1Final((unsigned char *)mac->cd_raw.iov_base +
-			    mac->cd_offset, &sha1_hmac_ctx.hc_ocontext);
-		}
-		break;
-	case CRYPTO_DATA_UIO:
-		ret = sha1_digest_final_uio(&sha1_hmac_ctx.hc_ocontext, mac,
-		    digest_len, digest);
-		break;
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	if (ret == CRYPTO_SUCCESS) {
-		mac->cd_length = digest_len;
-	} else {
-		mac->cd_length = 0;
-	}
-	/* Extra paranoia: zeroize the context on the stack */
-	bzero(&sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-
-	return (ret);
-bail:
-	bzero(&sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-	mac->cd_length = 0;
-	return (ret);
-}
-
-/* ARGSUSED */
-static int
-sha1_mac_verify_atomic(crypto_provider_handle_t provider,
-    crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
-    crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,
-    crypto_spi_ctx_template_t ctx_template, crypto_req_handle_t req)
-{
-	int ret = CRYPTO_SUCCESS;
-	uchar_t digest[SHA1_DIGEST_LENGTH];
-	sha1_hmac_ctx_t sha1_hmac_ctx;
-	uint32_t digest_len = SHA1_DIGEST_LENGTH;
-	uint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);
-
-	if (mechanism->cm_type != SHA1_HMAC_MECH_INFO_TYPE &&
-	    mechanism->cm_type != SHA1_HMAC_GEN_MECH_INFO_TYPE)
-		return (CRYPTO_MECHANISM_INVALID);
-
-	/* Add support for key by attributes (RFE 4706552) */
-	if (key->ck_format != CRYPTO_KEY_RAW)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	if (ctx_template != NULL) {
-		/* reuse context template */
-		bcopy(ctx_template, &sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-	} else {
-		/* no context template, initialize context */
-		if (keylen_in_bytes > SHA1_HMAC_BLOCK_SIZE) {
-			/*
-			 * Hash the passed-in key to get a smaller key.
-			 * The inner context is used since it hasn't been
-			 * initialized yet.
-			 */
-			PROV_SHA1_DIGEST_KEY(&sha1_hmac_ctx.hc_icontext,
-			    key->ck_data, keylen_in_bytes, digest);
-			sha1_mac_init_ctx(&sha1_hmac_ctx, digest,
-			    SHA1_DIGEST_LENGTH);
-		} else {
-			sha1_mac_init_ctx(&sha1_hmac_ctx, key->ck_data,
-			    keylen_in_bytes);
-		}
-	}
-
-	/* get the mechanism parameters, if applicable */
-	if (mechanism->cm_type == SHA1_HMAC_GEN_MECH_INFO_TYPE) {
-		if (mechanism->cm_param == NULL ||
-		    mechanism->cm_param_len != sizeof (ulong_t)) {
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-			goto bail;
-		}
-		PROV_SHA1_GET_DIGEST_LEN(mechanism, digest_len);
-		if (digest_len > SHA1_DIGEST_LENGTH) {
-			ret = CRYPTO_MECHANISM_PARAM_INVALID;
-			goto bail;
-		}
-	}
-
-	if (mac->cd_length != digest_len) {
-		ret = CRYPTO_INVALID_MAC;
-		goto bail;
-	}
-
-	/* do a SHA1 update of the inner context using the specified data */
-	SHA1_MAC_UPDATE(data, sha1_hmac_ctx, ret);
-	if (ret != CRYPTO_SUCCESS)
-		/* the update failed, free context and bail */
-		goto bail;
-
-	/* do a SHA1 final on the inner context */
-	SHA1Final(digest, &sha1_hmac_ctx.hc_icontext);
-
-	/*
-	 * Do an SHA1 update on the outer context, feeding the inner
-	 * digest as data.
-	 */
-	SHA1Update(&sha1_hmac_ctx.hc_ocontext, digest, SHA1_DIGEST_LENGTH);
-
-	/*
-	 * Do a SHA1 final on the outer context, storing the computed
-	 * digest in the users buffer.
-	 */
-	SHA1Final(digest, &sha1_hmac_ctx.hc_ocontext);
-
-	/*
-	 * Compare the computed digest against the expected digest passed
-	 * as argument.
-	 */
-
-	switch (mac->cd_format) {
-
-	case CRYPTO_DATA_RAW:
-		if (bcmp(digest, (unsigned char *)mac->cd_raw.iov_base +
-		    mac->cd_offset, digest_len) != 0)
-			ret = CRYPTO_INVALID_MAC;
-		break;
-
-	case CRYPTO_DATA_UIO: {
-		off_t offset = mac->cd_offset;
-		uint_t vec_idx = 0;
-		off_t scratch_offset = 0;
-		size_t length = digest_len;
-		size_t cur_len;
-
-		/* we support only kernel buffer */
-		if (zfs_uio_segflg(mac->cd_uio) != UIO_SYSSPACE)
-			return (CRYPTO_ARGUMENTS_BAD);
-
-		/* jump to the first iovec containing the expected digest */
-		offset = zfs_uio_index_at_offset(mac->cd_uio, offset, &vec_idx);
-		if (vec_idx == zfs_uio_iovcnt(mac->cd_uio)) {
-			/*
-			 * The caller specified an offset that is
-			 * larger than the total size of the buffers
-			 * it provided.
-			 */
-			ret = CRYPTO_DATA_LEN_RANGE;
-			break;
-		}
-
-		/* do the comparison of computed digest vs specified one */
-		while (vec_idx < zfs_uio_iovcnt(mac->cd_uio) && length > 0) {
-			cur_len = MIN(zfs_uio_iovlen(mac->cd_uio, vec_idx) -
-			    offset, length);
-
-			if (bcmp(digest + scratch_offset,
-			    zfs_uio_iovbase(mac->cd_uio, vec_idx) + offset,
-			    cur_len) != 0) {
-				ret = CRYPTO_INVALID_MAC;
-				break;
-			}
-
-			length -= cur_len;
-			vec_idx++;
-			scratch_offset += cur_len;
-			offset = 0;
-		}
-		break;
-	}
-
-	default:
-		ret = CRYPTO_ARGUMENTS_BAD;
-	}
-
-	bzero(&sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-	return (ret);
-bail:
-	bzero(&sha1_hmac_ctx, sizeof (sha1_hmac_ctx_t));
-	mac->cd_length = 0;
-	return (ret);
-}
-
-/*
- * KCF software provider context management entry points.
- */
-
-/* ARGSUSED */
-static int
-sha1_create_ctx_template(crypto_provider_handle_t provider,
-    crypto_mechanism_t *mechanism, crypto_key_t *key,
-    crypto_spi_ctx_template_t *ctx_template, size_t *ctx_template_size,
-    crypto_req_handle_t req)
-{
-	sha1_hmac_ctx_t *sha1_hmac_ctx_tmpl;
-	uint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);
-
-	if ((mechanism->cm_type != SHA1_HMAC_MECH_INFO_TYPE) &&
-	    (mechanism->cm_type != SHA1_HMAC_GEN_MECH_INFO_TYPE)) {
-		return (CRYPTO_MECHANISM_INVALID);
-	}
-
-	/* Add support for key by attributes (RFE 4706552) */
-	if (key->ck_format != CRYPTO_KEY_RAW)
-		return (CRYPTO_ARGUMENTS_BAD);
-
-	/*
-	 * Allocate and initialize SHA1 context.
-	 */
-	sha1_hmac_ctx_tmpl = kmem_alloc(sizeof (sha1_hmac_ctx_t),
-	    crypto_kmflag(req));
-	if (sha1_hmac_ctx_tmpl == NULL)
-		return (CRYPTO_HOST_MEMORY);
-
-	if (keylen_in_bytes > SHA1_HMAC_BLOCK_SIZE) {
-		uchar_t digested_key[SHA1_DIGEST_LENGTH];
-
-		/*
-		 * Hash the passed-in key to get a smaller key.
-		 * The inner context is used since it hasn't been
-		 * initialized yet.
-		 */
-		PROV_SHA1_DIGEST_KEY(&sha1_hmac_ctx_tmpl->hc_icontext,
-		    key->ck_data, keylen_in_bytes, digested_key);
-		sha1_mac_init_ctx(sha1_hmac_ctx_tmpl, digested_key,
-		    SHA1_DIGEST_LENGTH);
-	} else {
-		sha1_mac_init_ctx(sha1_hmac_ctx_tmpl, key->ck_data,
-		    keylen_in_bytes);
-	}
-
-	sha1_hmac_ctx_tmpl->hc_mech_type = mechanism->cm_type;
-	*ctx_template = (crypto_spi_ctx_template_t)sha1_hmac_ctx_tmpl;
-	*ctx_template_size = sizeof (sha1_hmac_ctx_t);
-
-
-	return (CRYPTO_SUCCESS);
-}
-
-static int
-sha1_free_context(crypto_ctx_t *ctx)
-{
-	uint_t ctx_len;
-	sha1_mech_type_t mech_type;
-
-	if (ctx->cc_provider_private == NULL)
-		return (CRYPTO_SUCCESS);
-
-	/*
-	 * We have to free either SHA1 or SHA1-HMAC contexts, which
-	 * have different lengths.
-	 */
-
-	mech_type = PROV_SHA1_CTX(ctx)->sc_mech_type;
-	if (mech_type == SHA1_MECH_INFO_TYPE)
-		ctx_len = sizeof (sha1_ctx_t);
-	else {
-		ASSERT(mech_type == SHA1_HMAC_MECH_INFO_TYPE ||
-		    mech_type == SHA1_HMAC_GEN_MECH_INFO_TYPE);
-		ctx_len = sizeof (sha1_hmac_ctx_t);
-	}
-
-	bzero(ctx->cc_provider_private, ctx_len);
-	kmem_free(ctx->cc_provider_private, ctx_len);
-	ctx->cc_provider_private = NULL;
-
-	return (CRYPTO_SUCCESS);
-}
diff --git a/sys/contrib/openzfs/module/icp/io/sha2_mod.c b/sys/contrib/openzfs/module/icp/io/sha2_mod.c
index d690cd0bcb05..a43c7c5b7b8e 100644
--- a/sys/contrib/openzfs/module/icp/io/sha2_mod.c
+++ b/sys/contrib/openzfs/module/icp/io/sha2_mod.c
@@ -25,7 +25,6 @@
  */
 
 #include <sys/zfs_context.h>
-#include <sys/modctl.h>
 #include <sys/crypto/common.h>
 #include <sys/crypto/spi.h>
 #include <sys/crypto/icp.h>
@@ -33,24 +32,6 @@
 #include <sys/sha2.h>
 #include <sha2/sha2_impl.h>
 
-/*
- * The sha2 module is created with two modlinkages:
- * - a modlmisc that allows consumers to directly call the entry points
- *   SHA2Init, SHA2Update, and SHA2Final.
- * - a modlcrypto that allows the module to register with the Kernel
- *   Cryptographic Framework (KCF) as a software provider for the SHA2
- *   mechanisms.
- */
-
-static struct modlcrypto modlcrypto = {
-	&mod_cryptoops,
-	"SHA2 Kernel SW Provider"
-};
-
-static struct modlinkage modlinkage = {
-	MODREV_1, {&modlcrypto, NULL}
-};
-
 /*
  * Macros to access the SHA2 or SHA2-HMAC contexts from a context passed
  * by KCF to one of the entry points.
@@ -79,7 +60,7 @@ static struct modlinkage modlinkage = {
 /*
  * Mechanism info structure passed to KCF during registration.
  */
-static crypto_mech_info_t sha2_mech_info_tab[] = {
+static const crypto_mech_info_t sha2_mech_info_tab[] = {
 	/* SHA256 */
 	{SUN_CKM_SHA256, SHA256_MECH_INFO_TYPE,
 	    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC,
@@ -126,7 +107,7 @@ static crypto_mech_info_t sha2_mech_info_tab[] = {
 
 static void sha2_provider_status(crypto_provider_handle_t, uint_t *);
 
-static crypto_control_ops_t sha2_control_ops = {
+static const crypto_control_ops_t sha2_control_ops = {
 	sha2_provider_status
 };
 
@@ -142,7 +123,7 @@ static int sha2_digest_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_data_t *, crypto_data_t *,
     crypto_req_handle_t);
 
-static crypto_digest_ops_t sha2_digest_ops = {
+static const crypto_digest_ops_t sha2_digest_ops = {
 	.digest_init = sha2_digest_init,
 	.digest = sha2_digest,
 	.digest_update = sha2_digest_update,
@@ -163,7 +144,7 @@ static int sha2_mac_verify_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_key_t *, crypto_data_t *, crypto_data_t *,
     crypto_spi_ctx_template_t, crypto_req_handle_t);
 
-static crypto_mac_ops_t sha2_mac_ops = {
+static const crypto_mac_ops_t sha2_mac_ops = {
 	.mac_init = sha2_mac_init,
 	.mac = NULL,
 	.mac_update = sha2_mac_update,
@@ -177,12 +158,12 @@ static int sha2_create_ctx_template(crypto_provider_handle_t,
     size_t *, crypto_req_handle_t);
 static int sha2_free_context(crypto_ctx_t *);
 
-static crypto_ctx_ops_t sha2_ctx_ops = {
+static const crypto_ctx_ops_t sha2_ctx_ops = {
 	.create_ctx_template = sha2_create_ctx_template,
 	.free_context = sha2_free_context
 };
 
-static crypto_ops_t sha2_crypto_ops = {{{{{
+static const crypto_ops_t sha2_crypto_ops = {{{{{
 	&sha2_control_ops,
 	&sha2_digest_ops,
 	NULL,
@@ -199,13 +180,13 @@ static crypto_ops_t sha2_crypto_ops = {{{{{
 	&sha2_ctx_ops
 }}}}};
 
-static crypto_provider_info_t sha2_prov_info = {{{{
+static const crypto_provider_info_t sha2_prov_info = {{{{
 	CRYPTO_SPI_VERSION_1,
 	"SHA2 Software Provider",
 	CRYPTO_SW_PROVIDER,
 	NULL,
 	&sha2_crypto_ops,
-	sizeof (sha2_mech_info_tab)/sizeof (crypto_mech_info_t),
+	sizeof (sha2_mech_info_tab) / sizeof (crypto_mech_info_t),
 	sha2_mech_info_tab
 }}}};
 
@@ -216,9 +197,6 @@ sha2_mod_init(void)
 {
 	int ret;
 
-	if ((ret = mod_install(&modlinkage)) != 0)
-		return (ret);
-
 	/*
 	 * Register with KCF. If the registration fails, log an
 	 * error but do not uninstall the module, since the functionality
@@ -235,7 +213,7 @@ sha2_mod_init(void)
 int
 sha2_mod_fini(void)
 {
-	int ret;
+	int ret = 0;
 
 	if (sha2_prov_handle != 0) {
 		if ((ret = crypto_unregister_provider(sha2_prov_handle)) !=
@@ -248,16 +226,16 @@ sha2_mod_fini(void)
 		sha2_prov_handle = 0;
 	}
 
-	return (mod_remove(&modlinkage));
+	return (ret);
 }
 
 /*
  * KCF software provider control entry points.
  */
-/* ARGSUSED */
 static void
 sha2_provider_status(crypto_provider_handle_t provider, uint_t *status)
 {
+	(void) provider;
 	*status = CRYPTO_PROVIDER_READY;
 }
 
@@ -438,11 +416,11 @@ sha2_digest_final_uio(SHA2_CTX *sha2_ctx, crypto_data_t *digest,
 	return (CRYPTO_SUCCESS);
 }
 
-/* ARGSUSED */
 static int
 sha2_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest,
     crypto_req_handle_t req)
 {
+	(void) req;
 	int ret = CRYPTO_SUCCESS;
 	uint_t sha_digest_len;
 
@@ -526,11 +504,11 @@ sha2_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_digest_update(crypto_ctx_t *ctx, crypto_data_t *data,
     crypto_req_handle_t req)
 {
+	(void) req;
 	int ret = CRYPTO_SUCCESS;
 
 	ASSERT(ctx->cc_provider_private != NULL);
@@ -555,11 +533,11 @@ sha2_digest_update(crypto_ctx_t *ctx, crypto_data_t *data,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_digest_final(crypto_ctx_t *ctx, crypto_data_t *digest,
     crypto_req_handle_t req)
 {
+	(void) req;
 	int ret = CRYPTO_SUCCESS;
 	uint_t sha_digest_len;
 
@@ -618,13 +596,13 @@ sha2_digest_final(crypto_ctx_t *ctx, crypto_data_t *digest,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_digest_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_data_t *data, crypto_data_t *digest,
     crypto_req_handle_t req)
 {
+	(void) provider, (void) session_id, (void) req;
 	int ret = CRYPTO_SUCCESS;
 	SHA2_CTX sha2_ctx;
 	uint32_t sha_digest_len;
@@ -840,11 +818,11 @@ sha2_mac_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_mac_update(crypto_ctx_t *ctx, crypto_data_t *data,
     crypto_req_handle_t req)
 {
+	(void) req;
 	int ret = CRYPTO_SUCCESS;
 
 	ASSERT(ctx->cc_provider_private != NULL);
@@ -870,10 +848,10 @@ sha2_mac_update(crypto_ctx_t *ctx, crypto_data_t *data,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_mac_final(crypto_ctx_t *ctx, crypto_data_t *mac, crypto_req_handle_t req)
 {
+	(void) req;
 	int ret = CRYPTO_SUCCESS;
 	uchar_t digest[SHA512_DIGEST_LENGTH];
 	uint32_t digest_len, sha_digest_len;
@@ -983,13 +961,13 @@ sha2_mac_final(crypto_ctx_t *ctx, crypto_data_t *mac, crypto_req_handle_t req)
 	}								\
 }
 
-/* ARGSUSED */
 static int
 sha2_mac_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,
     crypto_spi_ctx_template_t ctx_template, crypto_req_handle_t req)
 {
+	(void) provider, (void) session_id, (void) req;
 	int ret = CRYPTO_SUCCESS;
 	uchar_t digest[SHA512_DIGEST_LENGTH];
 	sha2_hmac_ctx_t sha2_hmac_ctx;
@@ -1121,13 +1099,13 @@ sha2_mac_atomic(crypto_provider_handle_t provider,
 	return (ret);
 }
 
-/* ARGSUSED */
 static int
 sha2_mac_verify_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_key_t *key, crypto_data_t *data, crypto_data_t *mac,
     crypto_spi_ctx_template_t ctx_template, crypto_req_handle_t req)
 {
+	(void) provider, (void) session_id, (void) req;
 	int ret = CRYPTO_SUCCESS;
 	uchar_t digest[SHA512_DIGEST_LENGTH];
 	sha2_hmac_ctx_t sha2_hmac_ctx;
@@ -1301,13 +1279,13 @@ sha2_mac_verify_atomic(crypto_provider_handle_t provider,
  * KCF software provider context management entry points.
  */
 
-/* ARGSUSED */
 static int
 sha2_create_ctx_template(crypto_provider_handle_t provider,
     crypto_mechanism_t *mechanism, crypto_key_t *key,
     crypto_spi_ctx_template_t *ctx_template, size_t *ctx_template_size,
     crypto_req_handle_t req)
 {
+	(void) provider;
 	sha2_hmac_ctx_t *sha2_hmac_ctx_tmpl;
 	uint_t keylen_in_bytes = CRYPTO_BITS2BYTES(key->ck_length);
 	uint32_t sha_digest_len, sha_hmac_block_size;
diff --git a/sys/contrib/openzfs/module/icp/io/skein_mod.c b/sys/contrib/openzfs/module/icp/io/skein_mod.c
index ac7d201eb708..d0917e71b12e 100644
--- a/sys/contrib/openzfs/module/icp/io/skein_mod.c
+++ b/sys/contrib/openzfs/module/icp/io/skein_mod.c
@@ -23,7 +23,6 @@
  * Copyright 2013 Saso Kiselkov. All rights reserved.
  */
 
-#include <sys/modctl.h>
 #include <sys/crypto/common.h>
 #include <sys/crypto/icp.h>
 #include <sys/crypto/spi.h>
@@ -31,26 +30,7 @@
 #define	SKEIN_MODULE_IMPL
 #include <sys/skein.h>
 
-/*
- * Like the sha2 module, we create the skein module with two modlinkages:
- * - modlmisc to allow direct calls to Skein_* API functions.
- * - modlcrypto to integrate well into the Kernel Crypto Framework (KCF).
- */
-static struct modlmisc modlmisc = {
-	&mod_cryptoops,
-	"Skein Message-Digest Algorithm"
-};
-
-static struct modlcrypto modlcrypto = {
-	&mod_cryptoops,
-	"Skein Kernel SW Provider"
-};
-
-static struct modlinkage modlinkage = {
-	MODREV_1, {&modlmisc, &modlcrypto, NULL}
-};
-
-static crypto_mech_info_t skein_mech_info_tab[] = {
+static const crypto_mech_info_t skein_mech_info_tab[] = {
 	{CKM_SKEIN_256, SKEIN_256_MECH_INFO_TYPE,
 	    CRYPTO_FG_DIGEST | CRYPTO_FG_DIGEST_ATOMIC,
 	    0, 0, CRYPTO_KEYSIZE_UNIT_IN_BITS},
@@ -73,7 +53,7 @@ static crypto_mech_info_t skein_mech_info_tab[] = {
 
 static void skein_provider_status(crypto_provider_handle_t, uint_t *);
 
-static crypto_control_ops_t skein_control_ops = {
+static const crypto_control_ops_t skein_control_ops = {
 	skein_provider_status
 };
 
@@ -87,7 +67,7 @@ static int skein_digest_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_data_t *, crypto_data_t *,
     crypto_req_handle_t);
 
-static crypto_digest_ops_t skein_digest_ops = {
+static const crypto_digest_ops_t skein_digest_ops = {
 	.digest_init = skein_digest_init,
 	.digest = skein_digest,
 	.digest_update = skein_update,
@@ -102,7 +82,7 @@ static int skein_mac_atomic(crypto_provider_handle_t, crypto_session_id_t,
     crypto_mechanism_t *, crypto_key_t *, crypto_data_t *, crypto_data_t *,
     crypto_spi_ctx_template_t, crypto_req_handle_t);
 
-static crypto_mac_ops_t skein_mac_ops = {
+static const crypto_mac_ops_t skein_mac_ops = {
 	.mac_init = skein_mac_init,
 	.mac = NULL,
 	.mac_update = skein_update, /* using regular digest update is OK here */
@@ -116,12 +96,12 @@ static int skein_create_ctx_template(crypto_provider_handle_t,
     size_t *, crypto_req_handle_t);
 static int skein_free_context(crypto_ctx_t *);
 
-static crypto_ctx_ops_t skein_ctx_ops = {
+static const crypto_ctx_ops_t skein_ctx_ops = {
 	.create_ctx_template = skein_create_ctx_template,
 	.free_context = skein_free_context
 };
 
-static crypto_ops_t skein_crypto_ops = {{{{{
+static const crypto_ops_t skein_crypto_ops = {{{{{
 	&skein_control_ops,
 	&skein_digest_ops,
 	NULL,
@@ -138,7 +118,7 @@ static crypto_ops_t skein_crypto_ops = {{{{{
 	&skein_ctx_ops,
 }}}}};
 
-static crypto_provider_info_t skein_prov_info = {{{{
+static const crypto_provider_info_t skein_prov_info = {{{{
 	CRYPTO_SPI_VERSION_1,
 	"Skein Software Provider",
 	CRYPTO_SW_PROVIDER,
@@ -214,11 +194,6 @@ skein_get_digest_bitlen(const crypto_mechanism_t *mechanism, size_t *result)
 int
 skein_mod_init(void)
 {
-	int error;
-
-	if ((error = mod_install(&modlinkage)) != 0)
-		return (error);
-
 	/*
 	 * Try to register with KCF - failure shouldn't unload us, since we
 	 * still may want to continue providing misc/skein functionality.
@@ -231,7 +206,7 @@ skein_mod_init(void)
 int
 skein_mod_fini(void)
 {
-	int ret;
+	int ret = 0;
 
 	if (skein_prov_handle != 0) {
 		if ((ret = crypto_unregister_provider(skein_prov_handle)) !=
@@ -244,16 +219,16 @@ skein_mod_fini(void)
 		skein_prov_handle = 0;
 	}
 
-	return (mod_remove(&modlinkage));
+	return (0);
 }
 
 /*
  * KCF software provider control entry points.
  */
-/* ARGSUSED */
 static void
 skein_provider_status(crypto_provider_handle_t provider, uint_t *status)
 {
+	(void) provider;
 	*status = CRYPTO_PROVIDER_READY;
 }
 
@@ -462,10 +437,10 @@ skein_digest(crypto_ctx_t *ctx, crypto_data_t *data, crypto_data_t *digest,
  * can push more data). This is used both for digest and MAC operation.
  * Supported input data formats are raw, uio and mblk.
  */
-/*ARGSUSED*/
 static int
 skein_update(crypto_ctx_t *ctx, crypto_data_t *data, crypto_req_handle_t req)
 {
+	(void) req;
 	int error = CRYPTO_SUCCESS;
 
 	ASSERT(SKEIN_CTX(ctx) != NULL);
@@ -491,7 +466,6 @@ skein_update(crypto_ctx_t *ctx, crypto_data_t *data, crypto_req_handle_t req)
  * for digest and MAC operation.
  * Supported output digest formats are raw, uio and mblk.
  */
-/*ARGSUSED*/
 static int
 skein_final(crypto_ctx_t *ctx, crypto_data_t *digest, crypto_req_handle_t req)
 {
@@ -537,15 +511,15 @@ skein_final(crypto_ctx_t *ctx, crypto_data_t *digest, crypto_req_handle_t req)
  * `data' and writing the output to `digest'.
  * Supported input/output formats are raw, uio and mblk.
  */
-/*ARGSUSED*/
 static int
 skein_digest_atomic(crypto_provider_handle_t provider,
     crypto_session_id_t session_id, crypto_mechanism_t *mechanism,
     crypto_data_t *data, crypto_data_t *digest, crypto_req_handle_t req)
 {
-	int		error;
-	skein_ctx_t	skein_ctx;
-	crypto_ctx_t	ctx;
+	(void) provider, (void) session_id, (void) req;
+	int	 error;
+	skein_ctx_t skein_ctx;
+	crypto_ctx_t ctx;
 	SKEIN_CTX_LVALUE(&ctx) = &skein_ctx;
 
 	/* Init */
@@ -640,7 +614,6 @@ skein_mac_init(crypto_ctx_t *ctx, crypto_mechanism_t *mechanism,
  * The MAC update and final calls are reused from the regular digest code.
  */
 
-/*ARGSUSED*/
 /*
  * Same as skein_digest_atomic, performs an atomic Skein MAC operation in
  * one step. All the same properties apply to the arguments of this
@@ -653,9 +626,10 @@ skein_mac_atomic(crypto_provider_handle_t provider,
     crypto_spi_ctx_template_t ctx_template, crypto_req_handle_t req)
 {
 	/* faux crypto context just for skein_digest_{update,final} */
-	int		error;
-	crypto_ctx_t	ctx;
-	skein_ctx_t	skein_ctx;
+	(void) provider, (void) session_id;
+	int	 error;
+	crypto_ctx_t ctx;
+	skein_ctx_t skein_ctx;
 	SKEIN_CTX_LVALUE(&ctx) = &skein_ctx;
 
 	if (ctx_template != NULL) {
@@ -686,15 +660,15 @@ skein_mac_atomic(crypto_provider_handle_t provider,
  * properties apply to the arguments of this function as to those of
  * skein_mac_init.
  */
-/*ARGSUSED*/
 static int
 skein_create_ctx_template(crypto_provider_handle_t provider,
     crypto_mechanism_t *mechanism, crypto_key_t *key,
     crypto_spi_ctx_template_t *ctx_template, size_t *ctx_template_size,
     crypto_req_handle_t req)
 {
-	int		error;
-	skein_ctx_t	*ctx_tmpl;
+	(void) provider;
+	int	 error;
+	skein_ctx_t *ctx_tmpl;
 
 	ctx_tmpl = kmem_alloc(sizeof (*ctx_tmpl), crypto_kmflag(req));
 	if (ctx_tmpl == NULL)
diff --git a/sys/contrib/openzfs/module/icp/os/modconf.c b/sys/contrib/openzfs/module/icp/os/modconf.c
deleted file mode 100644
index 3743416ed951..000000000000
--- a/sys/contrib/openzfs/module/icp/os/modconf.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * CDDL HEADER START
- *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
- *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
- *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
- *
- * CDDL HEADER END
- */
-/*
- * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
- */
-
-#include <sys/zfs_context.h>
-#include <sys/modctl.h>
-
-/*
- * Null operations; used for uninitialized and "misc" modules.
- */
-static int mod_null(struct modlmisc *, struct modlinkage *);
-static int mod_infonull(void *, struct modlinkage *, int *);
-
-/*
- * Cryptographic Modules
- */
-struct mod_ops mod_cryptoops = {
-	.modm_install = mod_null,
-	.modm_remove = mod_null,
-	.modm_info = mod_infonull
-};
-
-/*
- * Null operation; return 0.
- */
-static int
-mod_null(struct modlmisc *modl, struct modlinkage *modlp)
-{
-	return (0);
-}
-
-/*
- * Status for User modules.
- */
-static int
-mod_infonull(void *modl, struct modlinkage *modlp, int *p0)
-{
-	*p0 = -1;		/* for modinfo display */
-	return (0);
-}
-
-/*
- * Install a module.
- * (This routine is in the Solaris SPARC DDI/DKI)
- */
-int
-mod_install(struct modlinkage *modlp)
-{
-	int retval = -1;	/* No linkage structures */
-	struct modlmisc **linkpp;
-	struct modlmisc **linkpp1;
-
-	if (modlp->ml_rev != MODREV_1) {
-		cmn_err(CE_WARN, "mod_install: "
-		    "modlinkage structure is not MODREV_1\n");
-		return (EINVAL);
-	}
-	linkpp = (struct modlmisc **)&modlp->ml_linkage[0];
-
-	while (*linkpp != NULL) {
-		if ((retval = MODL_INSTALL(*linkpp, modlp)) != 0) {
-			linkpp1 = (struct modlmisc **)&modlp->ml_linkage[0];
-
-			while (linkpp1 != linkpp) {
-				MODL_REMOVE(*linkpp1, modlp); /* clean up */
-				linkpp1++;
-			}
-			break;
-		}
-		linkpp++;
-	}
-	return (retval);
-}
-
-static char *reins_err =
-	"Could not reinstall %s\nReboot to correct the problem";
-
-/*
- * Remove a module.  This is called by the module wrapper routine.
- * (This routine is in the Solaris SPARC DDI/DKI)
- */
-int
-mod_remove(struct modlinkage *modlp)
-{
-	int retval = 0;
-	struct modlmisc **linkpp, *last_linkp;
-
-	linkpp = (struct modlmisc **)&modlp->ml_linkage[0];
-
-	while (*linkpp != NULL) {
-		if ((retval = MODL_REMOVE(*linkpp, modlp)) != 0) {
-			last_linkp = *linkpp;
-			linkpp = (struct modlmisc **)&modlp->ml_linkage[0];
-			while (*linkpp != last_linkp) {
-				if (MODL_INSTALL(*linkpp, modlp) != 0) {
-					cmn_err(CE_WARN, reins_err,
-					    (*linkpp)->misc_linkinfo);
-					break;
-				}
-				linkpp++;
-			}
-			break;
-		}
-		linkpp++;
-	}
-	return (retval);
-}
-
-/*
- * Get module status.
- * (This routine is in the Solaris SPARC DDI/DKI)
- */
-int
-mod_info(struct modlinkage *modlp, struct modinfo *modinfop)
-{
-	int i;
-	int retval = 0;
-	struct modspecific_info *msip;
-	struct modlmisc **linkpp;
-
-	modinfop->mi_rev = modlp->ml_rev;
-
-	linkpp = (struct modlmisc **)modlp->ml_linkage;
-	msip = &modinfop->mi_msinfo[0];
-
-	for (i = 0; i < MODMAXLINK; i++) {
-		if (*linkpp == NULL) {
-			msip->msi_linkinfo[0] = '\0';
-		} else {
-			(void) strlcpy(msip->msi_linkinfo,
-			    (*linkpp)->misc_linkinfo, MODMAXLINKINFOLEN);
-			retval = MODL_INFO(*linkpp, modlp, &msip->msi_p0);
-			if (retval != 0)
-				break;
-			linkpp++;
-		}
-		msip++;
-	}
-
-	if (modinfop->mi_info == MI_INFO_LINKAGE) {
-		/*
-		 * Slight kludge used to extract the address of the
-		 * modlinkage structure from the module (just after
-		 * loading a module for the very first time)
-		 */
-		modinfop->mi_base = (void *)modlp;
-	}
-
-	if (retval == 0)
-		return (1);
-	return (0);
-}
diff --git a/sys/contrib/openzfs/module/icp/os/modhash.c b/sys/contrib/openzfs/module/icp/os/modhash.c
index a897871001ce..8bd06973eff1 100644
--- a/sys/contrib/openzfs/module/icp/os/modhash.c
+++ b/sys/contrib/openzfs/module/icp/os/modhash.c
@@ -172,16 +172,16 @@ kmutex_t mh_head_lock;
  * mod_hash_null_valdtor()
  * 	no-op key and value destructors.
  */
-/*ARGSUSED*/
 void
 mod_hash_null_keydtor(mod_hash_key_t key)
 {
+	(void) key;
 }
 
-/*ARGSUSED*/
 void
 mod_hash_null_valdtor(mod_hash_val_t val)
 {
+	(void) val;
 }
 
 /*
@@ -198,10 +198,10 @@ mod_hash_null_valdtor(mod_hash_val_t val)
  *	"Compilers: Principles, Tools & Techniques", by Aho, Sethi, Ullman
  */
 
-/*ARGSUSED*/
 uint_t
 mod_hash_bystr(void *hash_data, mod_hash_key_t key)
 {
+	(void) hash_data;
 	uint_t hash = 0;
 	uint_t g;
 	char *p, *k = (char *)key;
@@ -672,10 +672,10 @@ mod_hash_reserve_nosleep(mod_hash_t *hash, mod_hash_hndl_t *handlep)
 
 }
 
-/*ARGSUSED*/
 void
 mod_hash_cancel(mod_hash_t *hash, mod_hash_hndl_t *handlep)
 {
+	(void) hash;
 	kmem_cache_free(mh_e_cache, *handlep);
 	*handlep = (mod_hash_hndl_t)0;
 }
diff --git a/sys/contrib/openzfs/module/icp/spi/kcf_spi.c b/sys/contrib/openzfs/module/icp/spi/kcf_spi.c
index 34b36b81c0ab..25fe9b5b66be 100644
--- a/sys/contrib/openzfs/module/icp/spi/kcf_spi.c
+++ b/sys/contrib/openzfs/module/icp/spi/kcf_spi.c
@@ -39,18 +39,19 @@
 /*
  * minalloc and maxalloc values to be used for taskq_create().
  */
-int crypto_taskq_threads = CRYPTO_TASKQ_THREADS;
-int crypto_taskq_minalloc = CRYPTO_TASKQ_MIN;
-int crypto_taskq_maxalloc = CRYPTO_TASKQ_MAX;
+const int crypto_taskq_threads = CRYPTO_TASKQ_THREADS;
+const int crypto_taskq_minalloc = CRYPTO_TASKQ_MIN;
+const int crypto_taskq_maxalloc = CRYPTO_TASKQ_MAX;
 
 static void remove_provider(kcf_provider_desc_t *);
-static void process_logical_providers(crypto_provider_info_t *,
+static void process_logical_providers(const crypto_provider_info_t *,
+    kcf_provider_desc_t *);
+static int init_prov_mechs(const crypto_provider_info_t *,
     kcf_provider_desc_t *);
-static int init_prov_mechs(crypto_provider_info_t *, kcf_provider_desc_t *);
 static int kcf_prov_kstat_update(kstat_t *, int);
 static void delete_kstat(kcf_provider_desc_t *);
 
-static kcf_prov_stats_t kcf_stats_ks_data_template = {
+static const kcf_prov_stats_t kcf_stats_ks_data_template = {
 	{ "kcf_ops_total",		KSTAT_DATA_UINT64 },
 	{ "kcf_ops_passed",		KSTAT_DATA_UINT64 },
 	{ "kcf_ops_failed",		KSTAT_DATA_UINT64 },
@@ -58,7 +59,7 @@ static kcf_prov_stats_t kcf_stats_ks_data_template = {
 };
 
 #define	KCF_SPI_COPY_OPS(src, dst, ops) if ((src)->ops != NULL) \
-	*((dst)->ops) = *((src)->ops);
+	memcpy((void *) (dst)->ops, (src)->ops, sizeof (*(src)->ops));
 
 /*
  * Copy an ops vector from src to dst. Used during provider registration
@@ -69,7 +70,7 @@ static kcf_prov_stats_t kcf_stats_ks_data_template = {
  * persistent.
  */
 static void
-copy_ops_vector_v1(crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
+copy_ops_vector_v1(const crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
 {
 	KCF_SPI_COPY_OPS(src_ops, dst_ops, co_control_ops);
 	KCF_SPI_COPY_OPS(src_ops, dst_ops, co_digest_ops);
@@ -88,13 +89,13 @@ copy_ops_vector_v1(crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
 }
 
 static void
-copy_ops_vector_v2(crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
+copy_ops_vector_v2(const crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
 {
 	KCF_SPI_COPY_OPS(src_ops, dst_ops, co_mech_ops);
 }
 
 static void
-copy_ops_vector_v3(crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
+copy_ops_vector_v3(const crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
 {
 	KCF_SPI_COPY_OPS(src_ops, dst_ops, co_nostore_key_ops);
 }
@@ -108,7 +109,7 @@ copy_ops_vector_v3(crypto_ops_t *src_ops, crypto_ops_t *dst_ops)
  * routines.  Software providers call this routine in their _init() routine.
  */
 int
-crypto_register_provider(crypto_provider_info_t *info,
+crypto_register_provider(const crypto_provider_info_t *info,
     crypto_kcf_provider_handle_t *handle)
 {
 	char *ks_name;
@@ -158,16 +159,14 @@ crypto_register_provider(crypto_provider_info_t *info,
 		if (info->pi_ops_vector == NULL) {
 			goto bail;
 		}
-		copy_ops_vector_v1(info->pi_ops_vector,
-		    prov_desc->pd_ops_vector);
+		crypto_ops_t *pvec = (crypto_ops_t *)prov_desc->pd_ops_vector;
+		copy_ops_vector_v1(info->pi_ops_vector, pvec);
 		if (info->pi_interface_version >= CRYPTO_SPI_VERSION_2) {
-			copy_ops_vector_v2(info->pi_ops_vector,
-			    prov_desc->pd_ops_vector);
+			copy_ops_vector_v2(info->pi_ops_vector, pvec);
 			prov_desc->pd_flags = info->pi_flags;
 		}
 		if (info->pi_interface_version == CRYPTO_SPI_VERSION_3) {
-			copy_ops_vector_v3(info->pi_ops_vector,
-			    prov_desc->pd_ops_vector);
+			copy_ops_vector_v3(info->pi_ops_vector, pvec);
 		}
 	}
 
@@ -199,8 +198,8 @@ crypto_register_provider(crypto_provider_info_t *info,
 	 */
 	if (prov_desc->pd_prov_type == CRYPTO_HW_PROVIDER)
 		prov_desc->pd_sched_info.ks_taskq = taskq_create("kcf_taskq",
-		    crypto_taskq_threads, minclsyspri,
-		    crypto_taskq_minalloc, crypto_taskq_maxalloc,
+		    CRYPTO_TASKQ_THREADS, minclsyspri,
+		    CRYPTO_TASKQ_MIN, CRYPTO_TASKQ_MAX,
 		    TASKQ_PREPOPULATE);
 	else
 		prov_desc->pd_sched_info.ks_taskq = NULL;
@@ -566,7 +565,7 @@ crypto_kmflag(crypto_req_handle_t handle)
  * if the table of mechanisms is full.
  */
 static int
-init_prov_mechs(crypto_provider_info_t *info, kcf_provider_desc_t *desc)
+init_prov_mechs(const crypto_provider_info_t *info, kcf_provider_desc_t *desc)
 {
 	uint_t mech_idx;
 	uint_t cleanup_idx;
@@ -811,7 +810,8 @@ remove_provider_from_array(kcf_provider_desc_t *p1, kcf_provider_desc_t *p2)
  * descriptors (kcf_provider_desc_t) attached to a logical provider.
  */
 static void
-process_logical_providers(crypto_provider_info_t *info, kcf_provider_desc_t *hp)
+process_logical_providers(const crypto_provider_info_t *info,
+    kcf_provider_desc_t *hp)
 {
 	kcf_provider_desc_t *lp;
 	crypto_provider_id_t handle;
diff --git a/sys/contrib/openzfs/module/nvpair/fnvpair.c b/sys/contrib/openzfs/module/nvpair/fnvpair.c
index 3a4f07486808..43c4b73590c4 100644
--- a/sys/contrib/openzfs/module/nvpair/fnvpair.c
+++ b/sys/contrib/openzfs/module/nvpair/fnvpair.c
@@ -82,13 +82,13 @@ fnvlist_pack(nvlist_t *nvl, size_t *sizep)
 	return (packed);
 }
 
-/*ARGSUSED*/
 void
 fnvlist_pack_free(char *pack, size_t size)
 {
 #ifdef _KERNEL
 	kmem_free(pack, size);
 #else
+	(void) size;
 	free(pack);
 #endif
 }
diff --git a/sys/contrib/openzfs/module/nvpair/nvpair.c b/sys/contrib/openzfs/module/nvpair/nvpair.c
index 668e4a978105..b4463dd7308f 100644
--- a/sys/contrib/openzfs/module/nvpair/nvpair.c
+++ b/sys/contrib/openzfs/module/nvpair/nvpair.c
@@ -146,12 +146,12 @@ static int nvlist_add_common(nvlist_t *nvl, const char *name, data_type_t type,
 	((i_nvp_t *)((size_t)(nvp) - offsetof(i_nvp_t, nvi_nvp)))
 
 #ifdef _KERNEL
-int nvpair_max_recursion = 20;
+static const int nvpair_max_recursion = 20;
 #else
-int nvpair_max_recursion = 100;
+static const int nvpair_max_recursion = 100;
 #endif
 
-uint64_t nvlist_hashtable_init_size = (1 << 4);
+static const uint64_t nvlist_hashtable_init_size = (1 << 4);
 
 int
 nv_alloc_init(nv_alloc_t *nva, const nv_alloc_ops_t *nvo, /* args */ ...)
@@ -576,6 +576,7 @@ nvlist_nv_alloc(int kmflag)
 		return (nv_alloc_pushpage);
 	}
 #else
+	(void) kmflag;
 	return (nv_alloc_nosleep);
 #endif /* _KERNEL */
 }
@@ -2296,10 +2297,11 @@ nvlist_add_nvpair(nvlist_t *nvl, nvpair_t *nvp)
  * the values are taken from nvl in the case of duplicates.
  * Return 0 on success.
  */
-/*ARGSUSED*/
 int
 nvlist_merge(nvlist_t *dst, nvlist_t *nvl, int flag)
 {
+	(void) flag;
+
 	if (nvl == NULL || dst == NULL)
 		return (EINVAL);
 
@@ -2803,10 +2805,10 @@ nvs_native_create(nvstream_t *nvs, nvs_native_t *native, char *buf,
 	}
 }
 
-/*ARGSUSED*/
 static void
 nvs_native_destroy(nvstream_t *nvs)
 {
+	(void) nvs;
 }
 
 static int
diff --git a/sys/contrib/openzfs/module/nvpair/nvpair_alloc_fixed.c b/sys/contrib/openzfs/module/nvpair/nvpair_alloc_fixed.c
index c8a604a2bfac..d7d3e7afd520 100644
--- a/sys/contrib/openzfs/module/nvpair/nvpair_alloc_fixed.c
+++ b/sys/contrib/openzfs/module/nvpair/nvpair_alloc_fixed.c
@@ -85,11 +85,11 @@ nv_fixed_alloc(nv_alloc_t *nva, size_t size)
 	return ((void *)new);
 }
 
-/*ARGSUSED*/
 static void
 nv_fixed_free(nv_alloc_t *nva, void *buf, size_t size)
 {
 	/* don't free memory in the pre-allocated buffer */
+	(void) nva, (void) buf, (void) size;
 }
 
 static void
@@ -100,7 +100,7 @@ nv_fixed_reset(nv_alloc_t *nva)
 	nvb->nvb_cur = (uintptr_t)&nvb[1];
 }
 
-const nv_alloc_ops_t nv_fixed_ops_def = {
+static const nv_alloc_ops_t nv_fixed_ops_def = {
 	.nv_ao_init = nv_fixed_init,
 	.nv_ao_fini = NULL,
 	.nv_ao_alloc = nv_fixed_alloc,
@@ -108,7 +108,7 @@ const nv_alloc_ops_t nv_fixed_ops_def = {
 	.nv_ao_reset = nv_fixed_reset
 };
 
-const nv_alloc_ops_t *nv_fixed_ops = &nv_fixed_ops_def;
+const nv_alloc_ops_t *const nv_fixed_ops = &nv_fixed_ops_def;
 
 #if defined(_KERNEL)
 EXPORT_SYMBOL(nv_fixed_ops);
diff --git a/sys/contrib/openzfs/module/nvpair/nvpair_alloc_spl.c b/sys/contrib/openzfs/module/nvpair/nvpair_alloc_spl.c
index ed8fa4d09402..aa344b6423e8 100644
--- a/sys/contrib/openzfs/module/nvpair/nvpair_alloc_spl.c
+++ b/sys/contrib/openzfs/module/nvpair/nvpair_alloc_spl.c
@@ -52,7 +52,7 @@ nv_free_spl(nv_alloc_t *nva, void *buf, size_t size)
 	kmem_free(buf, size);
 }
 
-const nv_alloc_ops_t spl_sleep_ops_def = {
+static const nv_alloc_ops_t spl_sleep_ops_def = {
 	.nv_ao_init = NULL,
 	.nv_ao_fini = NULL,
 	.nv_ao_alloc = nv_alloc_sleep_spl,
@@ -60,7 +60,7 @@ const nv_alloc_ops_t spl_sleep_ops_def = {
 	.nv_ao_reset = NULL
 };
 
-const nv_alloc_ops_t spl_pushpage_ops_def = {
+static const nv_alloc_ops_t spl_pushpage_ops_def = {
 	.nv_ao_init = NULL,
 	.nv_ao_fini = NULL,
 	.nv_ao_alloc = nv_alloc_pushpage_spl,
@@ -68,7 +68,7 @@ const nv_alloc_ops_t spl_pushpage_ops_def = {
 	.nv_ao_reset = NULL
 };
 
-const nv_alloc_ops_t spl_nosleep_ops_def = {
+static const nv_alloc_ops_t spl_nosleep_ops_def = {
 	.nv_ao_init = NULL,
 	.nv_ao_fini = NULL,
 	.nv_ao_alloc = nv_alloc_nosleep_spl,
@@ -76,21 +76,21 @@ const nv_alloc_ops_t spl_nosleep_ops_def = {
 	.nv_ao_reset = NULL
 };
 
-nv_alloc_t nv_alloc_sleep_def = {
+static nv_alloc_t nv_alloc_sleep_def = {
 	&spl_sleep_ops_def,
 	NULL
 };
 
-nv_alloc_t nv_alloc_pushpage_def = {
+static nv_alloc_t nv_alloc_pushpage_def = {
 	&spl_pushpage_ops_def,
 	NULL
 };
 
-nv_alloc_t nv_alloc_nosleep_def = {
+static nv_alloc_t nv_alloc_nosleep_def = {
 	&spl_nosleep_ops_def,
 	NULL
 };
 
-nv_alloc_t *nv_alloc_sleep = &nv_alloc_sleep_def;
-nv_alloc_t *nv_alloc_pushpage = &nv_alloc_pushpage_def;
-nv_alloc_t *nv_alloc_nosleep = &nv_alloc_nosleep_def;
+nv_alloc_t *const nv_alloc_sleep = &nv_alloc_sleep_def;
+nv_alloc_t *const nv_alloc_pushpage = &nv_alloc_pushpage_def;
+nv_alloc_t *const nv_alloc_nosleep = &nv_alloc_nosleep_def;
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/abd_os.c b/sys/contrib/openzfs/module/os/freebsd/zfs/abd_os.c
index fa1034ff88bc..722a8898cde8 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/abd_os.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/abd_os.c
@@ -93,7 +93,7 @@ struct {
  * of multi-page linear ABDs are expensive operations due to KVA mapping and
  * unmapping, and with time they cause KVA fragmentations.
  */
-size_t zfs_abd_scatter_min_size = PAGE_SIZE + 1;
+static size_t zfs_abd_scatter_min_size = PAGE_SIZE + 1;
 
 #if defined(_KERNEL)
 SYSCTL_DECL(_vfs_zfs);
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/crypto_os.c b/sys/contrib/openzfs/module/os/freebsd/zfs/crypto_os.c
index 6a67dbc9f616..f971b62bd124 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/crypto_os.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/crypto_os.c
@@ -198,7 +198,7 @@ zfs_crypto_dispatch(freebsd_crypt_session_t *session, 	struct cryptop *crp)
 static void
 freebsd_crypt_uio_debug_log(boolean_t encrypt,
     freebsd_crypt_session_t *input_sessionp,
-    struct zio_crypt_info *c_info,
+    const struct zio_crypt_info *c_info,
     zfs_uio_t *data_uio,
     crypto_key_t *key,
     uint8_t *ivbuf,
@@ -241,7 +241,7 @@ freebsd_crypt_uio_debug_log(boolean_t encrypt,
 #if __FreeBSD_version >= 1300087
 int
 freebsd_crypt_newsession(freebsd_crypt_session_t *sessp,
-    struct zio_crypt_info *c_info, crypto_key_t *key)
+    const struct zio_crypt_info *c_info, crypto_key_t *key)
 {
 	struct crypto_session_params csp;
 	int error = 0;
@@ -322,7 +322,7 @@ freebsd_crypt_newsession(freebsd_crypt_session_t *sessp,
 int
 freebsd_crypt_uio(boolean_t encrypt,
     freebsd_crypt_session_t *input_sessionp,
-    struct zio_crypt_info *c_info,
+    const struct zio_crypt_info *c_info,
     zfs_uio_t *data_uio,
     crypto_key_t *key,
     uint8_t *ivbuf,
@@ -382,7 +382,7 @@ freebsd_crypt_uio(boolean_t encrypt,
 #else
 int
 freebsd_crypt_newsession(freebsd_crypt_session_t *sessp,
-    struct zio_crypt_info *c_info, crypto_key_t *key)
+    const struct zio_crypt_info *c_info, crypto_key_t *key)
 {
 	struct cryptoini cria, crie, *crip;
 	struct enc_xform *xform;
@@ -492,7 +492,7 @@ freebsd_crypt_newsession(freebsd_crypt_session_t *sessp,
 int
 freebsd_crypt_uio(boolean_t encrypt,
     freebsd_crypt_session_t *input_sessionp,
-    struct zio_crypt_info *c_info,
+    const struct zio_crypt_info *c_info,
     zfs_uio_t *data_uio,
     crypto_key_t *key,
     uint8_t *ivbuf,
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/spa_os.c b/sys/contrib/openzfs/module/os/freebsd/zfs/spa_os.c
index 85aecaacefdd..c8c833426131 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/spa_os.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/spa_os.c
@@ -183,7 +183,6 @@ spa_import_rootpool(const char *name, bool checkpointrewind)
 	spa_t *spa;
 	vdev_t *rvd;
 	nvlist_t *config, *nvtop;
-	uint64_t txg;
 	char *pname;
 	int error;
 
@@ -196,7 +195,6 @@ spa_import_rootpool(const char *name, bool checkpointrewind)
 	if (config != NULL) {
 		pname = fnvlist_lookup_string(config, ZPOOL_CONFIG_POOL_NAME);
 		VERIFY0(strcmp(name, pname));
-		txg = fnvlist_lookup_uint64(config, ZPOOL_CONFIG_POOL_TXG);
 
 		if ((spa = spa_lookup(pname)) != NULL) {
 			/*
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/vdev_file.c b/sys/contrib/openzfs/module/os/freebsd/zfs/vdev_file.c
index fc04a7476154..ef87d6610977 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/vdev_file.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/vdev_file.c
@@ -40,8 +40,8 @@
 
 static taskq_t *vdev_file_taskq;
 
-unsigned long vdev_file_logical_ashift = SPA_MINBLOCKSHIFT;
-unsigned long vdev_file_physical_ashift = SPA_MINBLOCKSHIFT;
+static unsigned long vdev_file_logical_ashift = SPA_MINBLOCKSHIFT;
+static unsigned long vdev_file_physical_ashift = SPA_MINBLOCKSHIFT;
 
 void
 vdev_file_init(void)
@@ -234,6 +234,7 @@ vdev_file_io_strategy(void *arg)
 		err = zfs_file_pwrite(vf->vf_file, buf, size, off, &resid);
 		abd_return_buf(zio->io_abd, buf, size);
 	}
+	zio->io_error = err;
 	if (resid != 0 && zio->io_error == 0)
 		zio->io_error = ENOSPC;
 
@@ -286,10 +287,10 @@ vdev_file_io_start(zio_t *zio)
 	    TQ_SLEEP), !=, 0);
 }
 
-/* ARGSUSED */
 static void
 vdev_file_io_done(zio_t *zio)
 {
+	(void) zio;
 }
 
 vdev_ops_t vdev_file_ops = {
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_acl.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_acl.c
index ae758bcefe21..bd22cda416bd 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_acl.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_acl.c
@@ -171,7 +171,7 @@ zfs_ace_v0_data(void *acep, void **datap)
 	return (0);
 }
 
-static acl_ops_t zfs_acl_v0_ops = {
+static const acl_ops_t zfs_acl_v0_ops = {
 	zfs_ace_v0_get_mask,
 	zfs_ace_v0_set_mask,
 	zfs_ace_v0_get_flags,
@@ -307,7 +307,7 @@ zfs_ace_fuid_data(void *acep, void **datap)
 	}
 }
 
-static acl_ops_t zfs_acl_fuid_ops = {
+static const acl_ops_t zfs_acl_fuid_ops = {
 	zfs_ace_fuid_get_mask,
 	zfs_ace_fuid_set_mask,
 	zfs_ace_fuid_get_flags,
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_ctldir.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_ctldir.c
index 11620949dec6..206f65b08c56 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_ctldir.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_ctldir.c
@@ -496,7 +496,7 @@ zfsctl_common_getattr(vnode_t *vp, vattr_t *vap)
 	 */
 	vap->va_blksize = 0;
 	vap->va_nblocks = 0;
-	vap->va_seq = 0;
+	vap->va_gen = 0;
 	vn_fsid(vp, vap);
 	vap->va_mode = zfsctl_ctldir_mode;
 	vap->va_type = VDIR;
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_debug.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_debug.c
index dad342b06fc1..0ff22cfe79ec 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_debug.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_debug.c
@@ -33,11 +33,11 @@ typedef struct zfs_dbgmsg {
 	char zdm_msg[1]; /* variable length allocation */
 } zfs_dbgmsg_t;
 
-list_t zfs_dbgmsgs;
-int zfs_dbgmsg_size = 0;
-kmutex_t zfs_dbgmsgs_lock;
+static list_t zfs_dbgmsgs;
+static int zfs_dbgmsg_size = 0;
+static kmutex_t zfs_dbgmsgs_lock;
 int zfs_dbgmsg_maxsize = 4<<20; /* 4MB */
-kstat_t *zfs_dbgmsg_kstat;
+static kstat_t *zfs_dbgmsg_kstat;
 
 /*
  * Internal ZFS debug messages are enabled by default.
@@ -51,7 +51,7 @@ kstat_t *zfs_dbgmsg_kstat;
  * # Disable the kernel debug message log.
  * sysctl vfs.zfs.dbgmsg_enable=0
  */
-int zfs_dbgmsg_enable = 1;
+int zfs_dbgmsg_enable = B_TRUE;
 
 static int
 zfs_dbgmsg_headers(char *buf, size_t size)
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_racct.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_racct.c
index b46cc046268e..883255bc1901 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_racct.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_racct.c
@@ -37,6 +37,8 @@ zfs_racct_read(uint64_t size, uint64_t iops)
 		racct_add_force(curproc, RACCT_READIOPS, iops);
 		PROC_UNLOCK(curproc);
 	}
+#else
+	(void) size;
 #endif /* RACCT */
 }
 
@@ -51,5 +53,7 @@ zfs_racct_write(uint64_t size, uint64_t iops)
 		racct_add_force(curproc, RACCT_WRITEIOPS, iops);
 		PROC_UNLOCK(curproc);
 	}
+#else
+	(void) size;
 #endif /* RACCT */
 }
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vfsops.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vfsops.c
index 42e11eeb183d..23f3f62c37f4 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vfsops.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vfsops.c
@@ -1791,6 +1791,7 @@ zfs_fhtovp(vfs_t *vfsp, fid_t *fidp, int flags, vnode_t **vpp)
 	vnode_t		*dvp;
 	uint64_t	object = 0;
 	uint64_t	fid_gen = 0;
+	uint64_t	setgen = 0;
 	uint64_t	gen_mask;
 	uint64_t	zp_gen;
 	int 		i, err;
@@ -1806,7 +1807,6 @@ zfs_fhtovp(vfs_t *vfsp, fid_t *fidp, int flags, vnode_t **vpp)
 	if (zfsvfs->z_parent == zfsvfs && fidp->fid_len == LONG_FID_LEN) {
 		zfid_long_t	*zlfid = (zfid_long_t *)fidp;
 		uint64_t	objsetid = 0;
-		uint64_t	setgen = 0;
 
 		for (i = 0; i < sizeof (zlfid->zf_setid); i++)
 			objsetid |= ((uint64_t)zlfid->zf_setid[i]) << (8 * i);
@@ -1835,6 +1835,12 @@ zfs_fhtovp(vfs_t *vfsp, fid_t *fidp, int flags, vnode_t **vpp)
 		return (SET_ERROR(EINVAL));
 	}
 
+	if (fidp->fid_len == LONG_FID_LEN && (fid_gen > 1 || setgen != 0)) {
+		dprintf("snapdir fid: fid_gen (%llu) and setgen (%llu)\n",
+		    (u_longlong_t)fid_gen, (u_longlong_t)setgen);
+		return (SET_ERROR(EINVAL));
+	}
+
 	/*
 	 * A zero fid_gen means we are in .zfs or the .zfs/snapshot
 	 * directory tree. If the object == zfsvfs->z_shares_dir, then
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vnops_os.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vnops_os.c
index 5aa54c6d2745..3db117525215 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vnops_os.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_vnops_os.c
@@ -113,6 +113,12 @@ VFS_SMR_DECLARE;
 #define	VNCHECKREF(vp)
 #endif
 
+#if __FreeBSD_version >= 1400045
+typedef uint64_t cookie_t;
+#else
+typedef ulong_t cookie_t;
+#endif
+
 /*
  * Programming rules.
  *
@@ -1665,7 +1671,7 @@ zfs_rmdir(znode_t *dzp, const char *name, znode_t *cwd, cred_t *cr, int flags)
 /* ARGSUSED */
 static int
 zfs_readdir(vnode_t *vp, zfs_uio_t *uio, cred_t *cr, int *eofp,
-    int *ncookies, uint64_t **cookies)
+    int *ncookies, cookie_t **cookies)
 {
 	znode_t		*zp = VTOZ(vp);
 	iovec_t		*iovp;
@@ -1687,7 +1693,7 @@ zfs_readdir(vnode_t *vp, zfs_uio_t *uio, cred_t *cr, int *eofp,
 	boolean_t	check_sysattrs;
 	uint8_t		type;
 	int		ncooks;
-	uint64_t	*cooks = NULL;
+	cookie_t	*cooks = NULL;
 	int		flags = 0;
 
 	ZFS_ENTER(zfsvfs);
@@ -2051,7 +2057,7 @@ zfs_getattr(vnode_t *vp, vattr_t *vap, int flags, cred_t *cr)
 	vap->va_size = zp->z_size;
 	if (vp->v_type == VBLK || vp->v_type == VCHR)
 		vap->va_rdev = zfs_cmpldev(rdev);
-	vap->va_seq = zp->z_seq;
+	vap->va_gen = zp->z_gen;
 	vap->va_flags = 0;	/* FreeBSD: Reset chflags(2) flags. */
 	vap->va_filerev = zp->z_seq;
 
@@ -4718,7 +4724,7 @@ struct vop_readdir_args {
 	struct ucred *a_cred;
 	int *a_eofflag;
 	int *a_ncookies;
-	uint64_t **a_cookies;
+	cookie_t **a_cookies;
 };
 #endif
 
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_znode.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_znode.c
index fd51668d2bea..5978a1232249 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_znode.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zfs_znode.c
@@ -571,7 +571,6 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 	dmu_buf_t	*db;
 	timestruc_t	now;
 	uint64_t	gen, obj;
-	int		err;
 	int		bonuslen;
 	int		dnodesize;
 	sa_handle_t	*sa_hdl;
@@ -811,12 +810,11 @@ zfs_mknode(znode_t *dzp, vattr_t *vap, dmu_tx_t *tx, cred_t *cr,
 		VERIFY0(zfs_aclset_common(*zpp, acl_ids->z_aclp, cr, tx));
 	}
 	if (!(flag & IS_ROOT_NODE)) {
-		vnode_t *vp;
-
-		vp = ZTOV(*zpp);
+		vnode_t *vp = ZTOV(*zpp);
 		vp->v_vflag |= VV_FORCEINSMQ;
-		err = insmntque(vp, zfsvfs->z_vfs);
+		int err = insmntque(vp, zfsvfs->z_vfs);
 		vp->v_vflag &= ~VV_FORCEINSMQ;
+		(void) err;
 		KASSERT(err == 0, ("insmntque() failed: error %d", err));
 	}
 	kmem_free(sa_attrs, sizeof (sa_bulk_attr_t) * ZPL_END);
@@ -928,11 +926,9 @@ zfs_zget(zfsvfs_t *zfsvfs, uint64_t obj_num, znode_t **zpp)
 	znode_t		*zp;
 	vnode_t		*vp;
 	sa_handle_t	*hdl;
-	struct thread	*td;
 	int locked;
 	int err;
 
-	td = curthread;
 	getnewvnode_reserve_();
 again:
 	*zpp = NULL;
@@ -958,7 +954,7 @@ zfs_zget(zfsvfs_t *zfsvfs, uint64_t obj_num, znode_t **zpp)
 
 	hdl = dmu_buf_get_user(db);
 	if (hdl != NULL) {
-		zp  = sa_get_userdata(hdl);
+		zp = sa_get_userdata(hdl);
 
 		/*
 		 * Since "SA" does immediate eviction we
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zio_crypt.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zio_crypt.c
index 832378a92a8d..ea120bcb5b03 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zio_crypt.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zio_crypt.c
@@ -185,13 +185,7 @@
 #define	ZFS_KEY_MAX_SALT_USES_DEFAULT	400000000
 #define	ZFS_CURRENT_MAX_SALT_USES	\
 	(MIN(zfs_key_max_salt_uses, ZFS_KEY_MAX_SALT_USES_DEFAULT))
-unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;
-
-/*
- * Set to a nonzero value to cause zio_do_crypt_uio() to fail 1/this many
- * calls, to test decryption error handling code paths.
- */
-uint64_t zio_decrypt_fail_fraction = 0;
+static unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;
 
 typedef struct blkptr_auth_buf {
 	uint64_t bab_prop;			/* blk_prop - portable mask */
@@ -199,7 +193,7 @@ typedef struct blkptr_auth_buf {
 	uint64_t bab_pad;			/* reserved for future use */
 } blkptr_auth_buf_t;
 
-zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {
+const zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {
 	{"",			ZC_TYPE_NONE,	0,	"inherit"},
 	{"",			ZC_TYPE_NONE,	0,	"on"},
 	{"",			ZC_TYPE_NONE,	0,	"off"},
@@ -237,7 +231,7 @@ zio_crypt_key_init(uint64_t crypt, zio_crypt_key_t *key)
 	int ret;
 	crypto_mechanism_t mech __unused;
 	uint_t keydata_len;
-	zio_crypt_info_t *ci = NULL;
+	const zio_crypt_info_t *ci = NULL;
 
 	ASSERT3P(key, !=, NULL);
 	ASSERT3U(crypt, <, ZIO_CRYPT_FUNCTIONS);
@@ -406,16 +400,13 @@ zio_do_crypt_uio_opencrypto(boolean_t encrypt, freebsd_crypt_session_t *sess,
     uint64_t crypt, crypto_key_t *key, uint8_t *ivbuf, uint_t datalen,
     zfs_uio_t *uio, uint_t auth_len)
 {
-	zio_crypt_info_t *ci;
-	int ret;
-
-	ci = &zio_crypt_table[crypt];
+	const zio_crypt_info_t *ci = &zio_crypt_table[crypt];
 	if (ci->ci_crypt_type != ZC_TYPE_GCM &&
 	    ci->ci_crypt_type != ZC_TYPE_CCM)
 		return (ENOTSUP);
 
 
-	ret = freebsd_crypt_uio(encrypt, sess, ci, uio, key, ivbuf,
+	int ret = freebsd_crypt_uio(encrypt, sess, ci, uio, key, ivbuf,
 	    datalen, auth_len);
 	if (ret != 0) {
 #ifdef FCRYPTO_DEBUG
@@ -1033,7 +1024,6 @@ zio_crypt_do_dnode_hmac_updates(crypto_context_t ctx, uint64_t version,
  * and le_bswap indicates whether a byteswap is needed to get this block
  * into little endian format.
  */
-/* ARGSUSED */
 int
 zio_crypt_do_objset_hmacs(zio_crypt_key_t *key, void *data, uint_t datalen,
     boolean_t should_bswap, uint8_t *portable_mac, uint8_t *local_mac)
@@ -1075,11 +1065,26 @@ zio_crypt_do_objset_hmacs(zio_crypt_key_t *key, void *data, uint_t datalen,
 
 	bcopy(raw_portable_mac, portable_mac, ZIO_OBJSET_MAC_LEN);
 
+	/*
+	 * This is necessary here as we check next whether
+	 * OBJSET_FLAG_USERACCOUNTING_COMPLETE is set in order to
+	 * decide if the local_mac should be zeroed out. That flag will always
+	 * be set by dmu_objset_id_quota_upgrade_cb() and
+	 * dmu_objset_userspace_upgrade_cb() if useraccounting has been
+	 * completed.
+	 */
+	intval = osp->os_flags;
+	if (should_bswap)
+		intval = BSWAP_64(intval);
+	boolean_t uacct_incomplete =
+	    !(intval & OBJSET_FLAG_USERACCOUNTING_COMPLETE);
+
 	/*
 	 * The local MAC protects the user, group and project accounting.
 	 * If these objects are not present, the local MAC is zeroed out.
 	 */
-	if ((datalen >= OBJSET_PHYS_SIZE_V3 &&
+	if (uacct_incomplete ||
+	    (datalen >= OBJSET_PHYS_SIZE_V3 &&
 	    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&
 	    osp->os_groupused_dnode.dn_type == DMU_OT_NONE &&
 	    osp->os_projectused_dnode.dn_type == DMU_OT_NONE) ||
@@ -1242,13 +1247,13 @@ zio_crypt_do_indirect_mac_checksum_abd(boolean_t generate, abd_t *abd,
  * It also means we'll only return one zfs_uio_t.
  */
 
-/* ARGSUSED */
 static int
 zio_crypt_init_uios_zil(boolean_t encrypt, uint8_t *plainbuf,
     uint8_t *cipherbuf, uint_t datalen, boolean_t byteswap, zfs_uio_t *puio,
     zfs_uio_t *out_uio, uint_t *enc_len, uint8_t **authbuf, uint_t *auth_len,
     boolean_t *no_crypt)
 {
+	(void) puio;
 	uint8_t *aadbuf = zio_buf_alloc(datalen);
 	uint8_t *src, *dst, *slrp, *dlrp, *blkend, *aadp;
 	iovec_t *dst_iovecs;
@@ -1545,12 +1550,12 @@ zio_crypt_init_uios_dnode(boolean_t encrypt, uint64_t version,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 zio_crypt_init_uios_normal(boolean_t encrypt, uint8_t *plainbuf,
     uint8_t *cipherbuf, uint_t datalen, zfs_uio_t *puio, zfs_uio_t *out_uio,
     uint_t *enc_len)
 {
+	(void) puio;
 	int ret;
 	uint_t nr_plain = 1, nr_cipher = 2;
 	iovec_t *plain_iovecs = NULL, *cipher_iovecs = NULL;
diff --git a/sys/contrib/openzfs/module/os/freebsd/zfs/zvol_os.c b/sys/contrib/openzfs/module/os/freebsd/zfs/zvol_os.c
index 450369192569..8785557cb61d 100644
--- a/sys/contrib/openzfs/module/os/freebsd/zfs/zvol_os.c
+++ b/sys/contrib/openzfs/module/os/freebsd/zfs/zvol_os.c
@@ -210,22 +210,27 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 	zvol_state_t *zv;
 	int err = 0;
 	boolean_t drop_suspend = B_FALSE;
-	boolean_t drop_namespace = B_FALSE;
 
 	if (!zpool_on_zvol && tsd_get(zfs_geom_probe_vdev_key) != NULL) {
 		/*
-		 * if zfs_geom_probe_vdev_key is set, that means that zfs is
+		 * If zfs_geom_probe_vdev_key is set, that means that zfs is
 		 * attempting to probe geom providers while looking for a
 		 * replacement for a missing VDEV.  In this case, the
 		 * spa_namespace_lock will not be held, but it is still illegal
 		 * to use a zvol as a vdev.  Deadlocks can result if another
-		 * thread has spa_namespace_lock
+		 * thread has spa_namespace_lock.
 		 */
 		return (SET_ERROR(EOPNOTSUPP));
 	}
 
 retry:
 	rw_enter(&zvol_state_lock, ZVOL_RW_READER);
+	/*
+	 * Obtain a copy of private under zvol_state_lock to make sure either
+	 * the result of zvol free code setting private to NULL is observed,
+	 * or the zv is protected from being freed because of the positive
+	 * zv_open_count.
+	 */
 	zv = pp->private;
 	if (zv == NULL) {
 		rw_exit(&zvol_state_lock);
@@ -233,18 +238,6 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 		goto out_locked;
 	}
 
-	if (zv->zv_open_count == 0 && !mutex_owned(&spa_namespace_lock)) {
-		/*
-		 * We need to guarantee that the namespace lock is held
-		 * to avoid spurious failures in zvol_first_open.
-		 */
-		drop_namespace = B_TRUE;
-		if (!mutex_tryenter(&spa_namespace_lock)) {
-			rw_exit(&zvol_state_lock);
-			mutex_enter(&spa_namespace_lock);
-			goto retry;
-		}
-	}
 	mutex_enter(&zv->zv_state_lock);
 	if (zv->zv_zso->zso_dying) {
 		rw_exit(&zvol_state_lock);
@@ -254,9 +247,9 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 	ASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_GEOM);
 
 	/*
-	 * make sure zvol is not suspended during first open
+	 * Make sure zvol is not suspended during first open
 	 * (hold zv_suspend_lock) and respect proper lock acquisition
-	 * ordering - zv_suspend_lock before zv_state_lock
+	 * ordering - zv_suspend_lock before zv_state_lock.
 	 */
 	if (zv->zv_open_count == 0) {
 		drop_suspend = B_TRUE;
@@ -264,7 +257,7 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 			mutex_exit(&zv->zv_state_lock);
 			rw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);
 			mutex_enter(&zv->zv_state_lock);
-			/* check to see if zv_suspend_lock is needed */
+			/* Check to see if zv_suspend_lock is needed. */
 			if (zv->zv_open_count != 0) {
 				rw_exit(&zv->zv_suspend_lock);
 				drop_suspend = B_FALSE;
@@ -276,8 +269,27 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
 
 	if (zv->zv_open_count == 0) {
+		boolean_t drop_namespace = B_FALSE;
+
 		ASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));
+
+		/*
+		 * Take spa_namespace_lock to prevent lock inversion when
+		 * zvols from one pool are opened as vdevs in another.
+		 */
+		if (!mutex_owned(&spa_namespace_lock)) {
+			if (!mutex_tryenter(&spa_namespace_lock)) {
+				mutex_exit(&zv->zv_state_lock);
+				rw_exit(&zv->zv_suspend_lock);
+				kern_yield(PRI_USER);
+				goto retry;
+			} else {
+				drop_namespace = B_TRUE;
+			}
+		}
 		err = zvol_first_open(zv, !(flag & FWRITE));
+		if (drop_namespace)
+			mutex_exit(&spa_namespace_lock);
 		if (err)
 			goto out_zv_locked;
 		pp->mediasize = zv->zv_volsize;
@@ -285,6 +297,8 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 		pp->stripesize = zv->zv_volblocksize;
 	}
 
+	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
+
 	/*
 	 * Check for a bad on-disk format version now since we
 	 * lied about owning the dataset readonly before.
@@ -317,8 +331,6 @@ zvol_geom_open(struct g_provider *pp, int flag, int count)
 out_zv_locked:
 	mutex_exit(&zv->zv_state_lock);
 out_locked:
-	if (drop_namespace)
-		mutex_exit(&spa_namespace_lock);
 	if (drop_suspend)
 		rw_exit(&zv->zv_suspend_lock);
 	return (err);
@@ -354,9 +366,9 @@ zvol_geom_close(struct g_provider *pp, int flag, int count)
 	ASSERT3U(zv->zv_open_count, >, 0);
 
 	/*
-	 * make sure zvol is not suspended during last close
+	 * Make sure zvol is not suspended during last close
 	 * (hold zv_suspend_lock) and respect proper lock acquisition
-	 * ordering - zv_suspend_lock before zv_state_lock
+	 * ordering - zv_suspend_lock before zv_state_lock.
 	 */
 	new_open_count = zv->zv_open_count - count;
 	if (new_open_count == 0) {
@@ -364,7 +376,7 @@ zvol_geom_close(struct g_provider *pp, int flag, int count)
 			mutex_exit(&zv->zv_state_lock);
 			rw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);
 			mutex_enter(&zv->zv_state_lock);
-			/* check to see if zv_suspend_lock is needed */
+			/* Check to see if zv_suspend_lock is needed. */
 			new_open_count = zv->zv_open_count - count;
 			if (new_open_count != 0) {
 				rw_exit(&zv->zv_suspend_lock);
@@ -695,7 +707,7 @@ zvol_geom_bio_strategy(struct bio *bp)
 			}
 		}
 		if (error) {
-			/* convert checksum errors into IO errors */
+			/* Convert checksum errors into IO errors. */
 			if (error == ECKSUM)
 				error = SET_ERROR(EIO);
 			break;
@@ -773,13 +785,13 @@ zvol_cdev_read(struct cdev *dev, struct uio *uio_s, int ioflag)
 	while (zfs_uio_resid(&uio) > 0 && zfs_uio_offset(&uio) < volsize) {
 		uint64_t bytes = MIN(zfs_uio_resid(&uio), DMU_MAX_ACCESS >> 1);
 
-		/* don't read past the end */
+		/* Don't read past the end. */
 		if (bytes > volsize - zfs_uio_offset(&uio))
 			bytes = volsize - zfs_uio_offset(&uio);
 
 		error =  dmu_read_uio_dnode(zv->zv_dn, &uio, bytes);
 		if (error) {
-			/* convert checksum errors into IO errors */
+			/* Convert checksum errors into IO errors. */
 			if (error == ECKSUM)
 				error = SET_ERROR(EIO);
 			break;
@@ -826,7 +838,7 @@ zvol_cdev_write(struct cdev *dev, struct uio *uio_s, int ioflag)
 		uint64_t off = zfs_uio_offset(&uio);
 		dmu_tx_t *tx = dmu_tx_create(zv->zv_objset);
 
-		if (bytes > volsize - off)	/* don't write past the end */
+		if (bytes > volsize - off)	/* Don't write past the end. */
 			bytes = volsize - off;
 
 		dmu_tx_hold_write_by_dnode(tx, zv->zv_dn, off, bytes);
@@ -859,10 +871,15 @@ zvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)
 	struct zvol_state_dev *zsd;
 	int err = 0;
 	boolean_t drop_suspend = B_FALSE;
-	boolean_t drop_namespace = B_FALSE;
 
 retry:
 	rw_enter(&zvol_state_lock, ZVOL_RW_READER);
+	/*
+	 * Obtain a copy of si_drv2 under zvol_state_lock to make sure either
+	 * the result of zvol free code setting si_drv2 to NULL is observed,
+	 * or the zv is protected from being freed because of the positive
+	 * zv_open_count.
+	 */
 	zv = dev->si_drv2;
 	if (zv == NULL) {
 		rw_exit(&zvol_state_lock);
@@ -870,26 +887,18 @@ zvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)
 		goto out_locked;
 	}
 
-	if (zv->zv_open_count == 0 && !mutex_owned(&spa_namespace_lock)) {
-		/*
-		 * We need to guarantee that the namespace lock is held
-		 * to avoid spurious failures in zvol_first_open.
-		 */
-		drop_namespace = B_TRUE;
-		if (!mutex_tryenter(&spa_namespace_lock)) {
-			rw_exit(&zvol_state_lock);
-			mutex_enter(&spa_namespace_lock);
-			goto retry;
-		}
-	}
 	mutex_enter(&zv->zv_state_lock);
-
+	if (zv->zv_zso->zso_dying) {
+		rw_exit(&zvol_state_lock);
+		err = SET_ERROR(ENXIO);
+		goto out_zv_locked;
+	}
 	ASSERT3S(zv->zv_volmode, ==, ZFS_VOLMODE_DEV);
 
 	/*
-	 * make sure zvol is not suspended during first open
+	 * Make sure zvol is not suspended during first open
 	 * (hold zv_suspend_lock) and respect proper lock acquisition
-	 * ordering - zv_suspend_lock before zv_state_lock
+	 * ordering - zv_suspend_lock before zv_state_lock.
 	 */
 	if (zv->zv_open_count == 0) {
 		drop_suspend = B_TRUE;
@@ -897,7 +906,7 @@ zvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)
 			mutex_exit(&zv->zv_state_lock);
 			rw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);
 			mutex_enter(&zv->zv_state_lock);
-			/* check to see if zv_suspend_lock is needed */
+			/* Check to see if zv_suspend_lock is needed. */
 			if (zv->zv_open_count != 0) {
 				rw_exit(&zv->zv_suspend_lock);
 				drop_suspend = B_FALSE;
@@ -909,12 +918,33 @@ zvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)
 	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
 
 	if (zv->zv_open_count == 0) {
+		boolean_t drop_namespace = B_FALSE;
+
 		ASSERT(ZVOL_RW_READ_HELD(&zv->zv_suspend_lock));
+
+		/*
+		 * Take spa_namespace_lock to prevent lock inversion when
+		 * zvols from one pool are opened as vdevs in another.
+		 */
+		if (!mutex_owned(&spa_namespace_lock)) {
+			if (!mutex_tryenter(&spa_namespace_lock)) {
+				rw_exit(&zvol_state_lock);
+				mutex_enter(&spa_namespace_lock);
+				kern_yield(PRI_USER);
+				goto retry;
+			} else {
+				drop_namespace = B_TRUE;
+			}
+		}
 		err = zvol_first_open(zv, !(flags & FWRITE));
+		if (drop_namespace)
+			mutex_exit(&spa_namespace_lock);
 		if (err)
 			goto out_zv_locked;
 	}
 
+	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
+
 	if ((flags & FWRITE) && (zv->zv_flags & ZVOL_RDONLY)) {
 		err = SET_ERROR(EROFS);
 		goto out_opened;
@@ -949,8 +979,6 @@ zvol_cdev_open(struct cdev *dev, int flags, int fmt, struct thread *td)
 out_zv_locked:
 	mutex_exit(&zv->zv_state_lock);
 out_locked:
-	if (drop_namespace)
-		mutex_exit(&spa_namespace_lock);
 	if (drop_suspend)
 		rw_exit(&zv->zv_suspend_lock);
 	return (err);
@@ -984,16 +1012,16 @@ zvol_cdev_close(struct cdev *dev, int flags, int fmt, struct thread *td)
 	 */
 	ASSERT3U(zv->zv_open_count, >, 0);
 	/*
-	 * make sure zvol is not suspended during last close
+	 * Make sure zvol is not suspended during last close
 	 * (hold zv_suspend_lock) and respect proper lock acquisition
-	 * ordering - zv_suspend_lock before zv_state_lock
+	 * ordering - zv_suspend_lock before zv_state_lock.
 	 */
 	if (zv->zv_open_count == 1) {
 		if (!rw_tryenter(&zv->zv_suspend_lock, ZVOL_RW_READER)) {
 			mutex_exit(&zv->zv_state_lock);
 			rw_enter(&zv->zv_suspend_lock, ZVOL_RW_READER);
 			mutex_enter(&zv->zv_state_lock);
-			/* check to see if zv_suspend_lock is needed */
+			/* Check to see if zv_suspend_lock is needed. */
 			if (zv->zv_open_count != 1) {
 				rw_exit(&zv->zv_suspend_lock);
 				drop_suspend = B_FALSE;
@@ -1035,7 +1063,7 @@ zvol_cdev_ioctl(struct cdev *dev, ulong_t cmd, caddr_t data,
 	zvol_state_t *zv;
 	zfs_locked_range_t *lr;
 	off_t offset, length;
-	int i, error;
+	int error;
 	boolean_t sync;
 
 	zv = dev->si_drv2;
@@ -1044,7 +1072,6 @@ zvol_cdev_ioctl(struct cdev *dev, ulong_t cmd, caddr_t data,
 	KASSERT(zv->zv_open_count > 0,
 	    ("Device with zero access count in %s", __func__));
 
-	i = IOCPARM_LEN(cmd);
 	switch (cmd) {
 	case DIOCGSECTORSIZE:
 		*(uint32_t *)data = DEV_BSIZE;
@@ -1189,7 +1216,7 @@ zvol_rename_minor(zvol_state_t *zv, const char *newname)
 	ASSERT(RW_LOCK_HELD(&zvol_state_lock));
 	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
 
-	/* move to new hashtable entry  */
+	/* Move to a new hashtable entry.  */
 	zv->zv_hash = zvol_name_hash(zv->zv_name);
 	hlist_del(&zv->zv_hlink);
 	hlist_add_head(&zv->zv_hlink, ZVOL_HT_HEAD(zv->zv_hash));
@@ -1319,7 +1346,7 @@ zvol_create_minor_impl(const char *name)
 
 	doi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);
 
-	/* lie and say we're read-only */
+	/* Lie and say we're read-only. */
 	error = dmu_objset_own(name, DMU_OST_ZVOL, B_TRUE, B_TRUE, FTAG, &os);
 	if (error)
 		goto out_doi;
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-generic.c b/sys/contrib/openzfs/module/os/linux/spl/spl-generic.c
index 5ea4fc635165..a7239385953e 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-generic.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-generic.c
@@ -44,17 +44,14 @@
 #include <sys/random.h>
 #include <sys/strings.h>
 #include <linux/kmod.h>
-#include "zfs_gitrev.h"
 #include <linux/mod_compat.h>
 #include <sys/cred.h>
 #include <sys/vnode.h>
 
-char spl_gitrev[64] = ZFS_META_GITREV;
-
 /* BEGIN CSTYLED */
 unsigned long spl_hostid = 0;
 EXPORT_SYMBOL(spl_hostid);
-/* BEGIN CSTYLED */
+
 module_param(spl_hostid, ulong, 0644);
 MODULE_PARM_DESC(spl_hostid, "The system hostid.");
 /* END CSTYLED */
@@ -632,7 +629,7 @@ spl_getattr(struct file *filp, struct kstat *stat)
  *
  */
 
-char *spl_hostid_path = HW_HOSTID_PATH;
+static char *spl_hostid_path = HW_HOSTID_PATH;
 module_param(spl_hostid_path, charp, 0444);
 MODULE_PARM_DESC(spl_hostid_path, "The system hostid file (/etc/hostid)");
 
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-kmem-cache.c b/sys/contrib/openzfs/module/os/linux/spl/spl-kmem-cache.c
index 2151ef008fd6..3d926173674d 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-kmem-cache.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-kmem-cache.c
@@ -72,7 +72,7 @@
  * will be limited to 2-256 objects per magazine (i.e per cpu).  Magazines
  * may never be entirely disabled in this implementation.
  */
-unsigned int spl_kmem_cache_magazine_size = 0;
+static unsigned int spl_kmem_cache_magazine_size = 0;
 module_param(spl_kmem_cache_magazine_size, uint, 0444);
 MODULE_PARM_DESC(spl_kmem_cache_magazine_size,
 	"Default magazine size (2-256), set automatically (0)");
@@ -84,15 +84,15 @@ MODULE_PARM_DESC(spl_kmem_cache_magazine_size,
  * setting this value to KMC_RECLAIM_ONCE limits how aggressively the cache
  * is reclaimed.  This may increase the likelihood of out of memory events.
  */
-unsigned int spl_kmem_cache_reclaim = 0 /* KMC_RECLAIM_ONCE */;
+static unsigned int spl_kmem_cache_reclaim = 0 /* KMC_RECLAIM_ONCE */;
 module_param(spl_kmem_cache_reclaim, uint, 0644);
 MODULE_PARM_DESC(spl_kmem_cache_reclaim, "Single reclaim pass (0x1)");
 
-unsigned int spl_kmem_cache_obj_per_slab = SPL_KMEM_CACHE_OBJ_PER_SLAB;
+static unsigned int spl_kmem_cache_obj_per_slab = SPL_KMEM_CACHE_OBJ_PER_SLAB;
 module_param(spl_kmem_cache_obj_per_slab, uint, 0644);
 MODULE_PARM_DESC(spl_kmem_cache_obj_per_slab, "Number of objects per slab");
 
-unsigned int spl_kmem_cache_max_size = SPL_KMEM_CACHE_MAX_SIZE;
+static unsigned int spl_kmem_cache_max_size = SPL_KMEM_CACHE_MAX_SIZE;
 module_param(spl_kmem_cache_max_size, uint, 0644);
 MODULE_PARM_DESC(spl_kmem_cache_max_size, "Maximum size of slab in MB");
 
@@ -103,7 +103,7 @@ MODULE_PARM_DESC(spl_kmem_cache_max_size, "Maximum size of slab in MB");
  * of 16K was determined to be optimal for architectures using 4K pages and
  * to also work well on architecutres using larger 64K page sizes.
  */
-unsigned int spl_kmem_cache_slab_limit = 16384;
+static unsigned int spl_kmem_cache_slab_limit = 16384;
 module_param(spl_kmem_cache_slab_limit, uint, 0644);
 MODULE_PARM_DESC(spl_kmem_cache_slab_limit,
 	"Objects less than N bytes use the Linux slab");
@@ -112,7 +112,7 @@ MODULE_PARM_DESC(spl_kmem_cache_slab_limit,
  * The number of threads available to allocate new slabs for caches.  This
  * should not need to be tuned but it is available for performance analysis.
  */
-unsigned int spl_kmem_cache_kmem_threads = 4;
+static unsigned int spl_kmem_cache_kmem_threads = 4;
 module_param(spl_kmem_cache_kmem_threads, uint, 0444);
 MODULE_PARM_DESC(spl_kmem_cache_kmem_threads,
 	"Number of spl_kmem_cache threads");
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-kstat.c b/sys/contrib/openzfs/module/os/linux/spl/spl-kstat.c
index 0c46708326d8..a417d4d7c358 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-kstat.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-kstat.c
@@ -358,7 +358,7 @@ kstat_seq_stop(struct seq_file *f, void *v)
 	mutex_exit(ksp->ks_lock);
 }
 
-static struct seq_operations kstat_seq_ops = {
+static const struct seq_operations kstat_seq_ops = {
 	.show  = kstat_seq_show,
 	.start = kstat_seq_start,
 	.next  = kstat_seq_next,
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-proc.c b/sys/contrib/openzfs/module/os/linux/spl/spl-proc.c
index c4af27a7fcd7..f500492eafdc 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-proc.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-proc.c
@@ -35,6 +35,7 @@
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/version.h>
+#include "zfs_gitrev.h"
 
 #if defined(CONSTIFY_PLUGIN) && LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 typedef struct ctl_table __no_const spl_ctl_table;
@@ -461,7 +462,7 @@ slab_seq_stop(struct seq_file *f, void *v)
 	up_read(&spl_kmem_cache_sem);
 }
 
-static struct seq_operations slab_seq_ops = {
+static const struct seq_operations slab_seq_ops = {
 	.show  = slab_seq_show,
 	.start = slab_seq_start,
 	.next  = slab_seq_next,
@@ -494,14 +495,14 @@ taskq_seq_stop(struct seq_file *f, void *v)
 	up_read(&tq_list_sem);
 }
 
-static struct seq_operations taskq_all_seq_ops = {
+static const struct seq_operations taskq_all_seq_ops = {
 	.show	= taskq_all_seq_show,
 	.start	= taskq_seq_start,
 	.next	= taskq_seq_next,
 	.stop	= taskq_seq_stop,
 };
 
-static struct seq_operations taskq_seq_ops = {
+static const struct seq_operations taskq_seq_ops = {
 	.show	= taskq_seq_show,
 	.start	= taskq_seq_start,
 	.next	= taskq_seq_next,
@@ -612,8 +613,8 @@ static struct ctl_table spl_table[] = {
 	 */
 	{
 		.procname	= "gitrev",
-		.data		= spl_gitrev,
-		.maxlen		= sizeof (spl_gitrev),
+		.data		= (char *)ZFS_META_GITREV,
+		.maxlen		= sizeof (ZFS_META_GITREV),
 		.mode		= 0444,
 		.proc_handler	= &proc_dostring,
 	},
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-procfs-list.c b/sys/contrib/openzfs/module/os/linux/spl/spl-procfs-list.c
index cae13228c62c..1922825c94a8 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-procfs-list.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-procfs-list.c
@@ -158,7 +158,7 @@ procfs_list_seq_stop(struct seq_file *f, void *p)
 	mutex_exit(&procfs_list->pl_lock);
 }
 
-static struct seq_operations procfs_list_seq_ops = {
+static const struct seq_operations procfs_list_seq_ops = {
 	.show  = procfs_list_seq_show,
 	.start = procfs_list_seq_start,
 	.next  = procfs_list_seq_next,
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-taskq.c b/sys/contrib/openzfs/module/os/linux/spl/spl-taskq.c
index a879c2856302..0aab148975aa 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-taskq.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-taskq.c
@@ -32,21 +32,21 @@
 #include <linux/cpuhotplug.h>
 #endif
 
-int spl_taskq_thread_bind = 0;
+static int spl_taskq_thread_bind = 0;
 module_param(spl_taskq_thread_bind, int, 0644);
 MODULE_PARM_DESC(spl_taskq_thread_bind, "Bind taskq thread to CPU by default");
 
 
-int spl_taskq_thread_dynamic = 1;
+static int spl_taskq_thread_dynamic = 1;
 module_param(spl_taskq_thread_dynamic, int, 0444);
 MODULE_PARM_DESC(spl_taskq_thread_dynamic, "Allow dynamic taskq threads");
 
-int spl_taskq_thread_priority = 1;
+static int spl_taskq_thread_priority = 1;
 module_param(spl_taskq_thread_priority, int, 0644);
 MODULE_PARM_DESC(spl_taskq_thread_priority,
 	"Allow non-default priority for taskq threads");
 
-int spl_taskq_thread_sequential = 4;
+static int spl_taskq_thread_sequential = 4;
 module_param(spl_taskq_thread_sequential, int, 0644);
 MODULE_PARM_DESC(spl_taskq_thread_sequential,
 	"Create new taskq threads after N sequential tasks");
diff --git a/sys/contrib/openzfs/module/os/linux/spl/spl-xdr.c b/sys/contrib/openzfs/module/os/linux/spl/spl-xdr.c
index 5e763c25606f..6b77524181db 100644
--- a/sys/contrib/openzfs/module/os/linux/spl/spl-xdr.c
+++ b/sys/contrib/openzfs/module/os/linux/spl/spl-xdr.c
@@ -127,8 +127,8 @@
  * space or MMIO space), the computer may explode.
  */
 
-static struct xdr_ops xdrmem_encode_ops;
-static struct xdr_ops xdrmem_decode_ops;
+static const struct xdr_ops xdrmem_encode_ops;
+static const struct xdr_ops xdrmem_decode_ops;
 
 void
 xdrmem_create(XDR *xdrs, const caddr_t addr, const uint_t size,
@@ -489,7 +489,7 @@ xdr_dec_string(XDR *xdrs, char **sp, const uint_t maxsize)
 	return (FALSE);
 }
 
-static struct xdr_ops xdrmem_encode_ops = {
+static const struct xdr_ops xdrmem_encode_ops = {
 	.xdr_control		= xdrmem_control,
 	.xdr_char		= xdrmem_enc_char,
 	.xdr_u_short		= xdrmem_enc_ushort,
@@ -500,7 +500,7 @@ static struct xdr_ops xdrmem_encode_ops = {
 	.xdr_array		= xdr_enc_array
 };
 
-static struct xdr_ops xdrmem_decode_ops = {
+static const struct xdr_ops xdrmem_decode_ops = {
 	.xdr_control		= xdrmem_control,
 	.xdr_char		= xdrmem_dec_char,
 	.xdr_u_short		= xdrmem_dec_ushort,
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/abd_os.c b/sys/contrib/openzfs/module/os/linux/zfs/abd_os.c
index a8f1ea7ca3de..113aee58599f 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/abd_os.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/abd_os.c
@@ -149,8 +149,6 @@ struct {
 #define	abd_for_each_sg(abd, sg, n, i)	\
 	for_each_sg(ABD_SCATTER(abd).abd_sgl, sg, n, i)
 
-unsigned zfs_abd_scatter_max_order = MAX_ORDER - 1;
-
 /*
  * zfs_abd_scatter_min_size is the minimum allocation size to use scatter
  * ABD's.  Smaller allocations will use linear ABD's which uses
@@ -173,7 +171,7 @@ unsigned zfs_abd_scatter_max_order = MAX_ORDER - 1;
  * By default we use linear allocations for 512B and 1KB, and scatter
  * allocations for larger (1.5KB and up).
  */
-int zfs_abd_scatter_min_size = 512 * 3;
+static int zfs_abd_scatter_min_size = 512 * 3;
 
 /*
  * We use a scattered SPA_MAXBLOCKSIZE sized ABD whose pages are
@@ -205,6 +203,7 @@ abd_alloc_struct_impl(size_t size)
 	 * In Linux we do not use the size passed in during ABD
 	 * allocation, so we just ignore it.
 	 */
+	(void) size;
 	abd_t *abd = kmem_cache_alloc(abd_cache, KM_PUSHPAGE);
 	ASSERT3P(abd, !=, NULL);
 	ABDSTAT_INCR(abdstat_struct_size, sizeof (abd_t));
@@ -220,6 +219,8 @@ abd_free_struct_impl(abd_t *abd)
 }
 
 #ifdef _KERNEL
+static unsigned zfs_abd_scatter_max_order = MAX_ORDER - 1;
+
 /*
  * Mark zfs data pages so they can be excluded from kernel crash dumps
  */
@@ -838,6 +839,7 @@ abd_t *
 abd_get_offset_scatter(abd_t *abd, abd_t *sabd, size_t off,
     size_t size)
 {
+	(void) size;
 	int i = 0;
 	struct scatterlist *sg = NULL;
 
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/arc_os.c b/sys/contrib/openzfs/module/os/linux/zfs/arc_os.c
index f96cd1271ee5..3dc0b7106112 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/arc_os.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/arc_os.c
@@ -398,11 +398,11 @@ param_set_arc_int(const char *buf, zfs_kernel_param_t *kp)
 }
 
 #ifdef CONFIG_MEMORY_HOTPLUG
-/* ARGSUSED */
 static int
 arc_hotplug_callback(struct notifier_block *self, unsigned long action,
     void *arg)
 {
+	(void) self, (void) arg;
 	uint64_t allmem = arc_all_memory();
 	if (action != MEM_ONLINE)
 		return (NOTIFY_OK);
@@ -458,6 +458,7 @@ arc_available_memory(void)
 int
 arc_memory_throttle(spa_t *spa, uint64_t reserve, uint64_t txg)
 {
+	(void) spa, (void) reserve, (void) txg;
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/vdev_disk.c b/sys/contrib/openzfs/module/os/linux/zfs/vdev_disk.c
index 46b459f5c80b..c06ba613b16d 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/vdev_disk.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/vdev_disk.c
@@ -919,7 +919,7 @@ param_set_vdev_scheduler(const char *val, zfs_kernel_param_t *kp)
 	return (error);
 }
 
-char *zfs_vdev_scheduler = "unused";
+static const char *zfs_vdev_scheduler = "unused";
 module_param_call(zfs_vdev_scheduler, param_set_vdev_scheduler,
     param_get_charp, &zfs_vdev_scheduler, 0644);
 MODULE_PARM_DESC(zfs_vdev_scheduler, "I/O scheduler");
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/vdev_file.c b/sys/contrib/openzfs/module/os/linux/zfs/vdev_file.c
index bf8a13ae6154..f073145326e3 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/vdev_file.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/vdev_file.c
@@ -53,8 +53,8 @@ static taskq_t *vdev_file_taskq;
  * impact the vdev_ashift setting which can only be set at vdev creation
  * time.
  */
-unsigned long vdev_file_logical_ashift = SPA_MINBLOCKSHIFT;
-unsigned long vdev_file_physical_ashift = SPA_MINBLOCKSHIFT;
+static unsigned long vdev_file_logical_ashift = SPA_MINBLOCKSHIFT;
+static unsigned long vdev_file_physical_ashift = SPA_MINBLOCKSHIFT;
 
 static void
 vdev_file_hold(vdev_t *vd)
@@ -298,10 +298,10 @@ vdev_file_io_start(zio_t *zio)
 	    TQ_SLEEP), !=, TASKQID_INVALID);
 }
 
-/* ARGSUSED */
 static void
 vdev_file_io_done(zio_t *zio)
 {
+	(void) zio;
 }
 
 vdev_ops_t vdev_file_ops = {
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_acl.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_acl.c
index cf37aecf8a22..94b20dd6e582 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_acl.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_acl.c
@@ -171,7 +171,7 @@ zfs_ace_v0_data(void *acep, void **datap)
 	return (0);
 }
 
-static acl_ops_t zfs_acl_v0_ops = {
+static const acl_ops_t zfs_acl_v0_ops = {
 	.ace_mask_get = zfs_ace_v0_get_mask,
 	.ace_mask_set = zfs_ace_v0_set_mask,
 	.ace_flags_get = zfs_ace_v0_get_flags,
@@ -307,7 +307,7 @@ zfs_ace_fuid_data(void *acep, void **datap)
 	}
 }
 
-static acl_ops_t zfs_acl_fuid_ops = {
+static const acl_ops_t zfs_acl_fuid_ops = {
 	.ace_mask_get = zfs_ace_fuid_get_mask,
 	.ace_mask_set = zfs_ace_fuid_set_mask,
 	.ace_flags_get = zfs_ace_fuid_get_flags,
@@ -2702,7 +2702,7 @@ zfs_zaccess_unix(znode_t *zp, mode_t mode, cred_t *cr)
 }
 
 /* See zfs_zaccess_delete() */
-int zfs_write_implies_delete_child = 1;
+static const boolean_t zfs_write_implies_delete_child = B_TRUE;
 
 /*
  * Determine whether delete access should be granted.
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_ctldir.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_ctldir.c
index c58d851d77d3..f7e71461a3bd 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_ctldir.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_ctldir.c
@@ -110,7 +110,7 @@ static krwlock_t zfs_snapshot_lock;
  * Control Directory Tunables (.zfs)
  */
 int zfs_expire_snapshot = ZFSCTL_EXPIRE_SNAPSHOT;
-int zfs_admin_snapshot = 0;
+static int zfs_admin_snapshot = 0;
 
 typedef struct {
 	char		*se_name;	/* full snapshot name */
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_debug.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_debug.c
index 98c9923d5927..be65f0a2e245 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_debug.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_debug.c
@@ -33,8 +33,8 @@ typedef struct zfs_dbgmsg {
 	char			zdm_msg[1]; /* variable length allocation */
 } zfs_dbgmsg_t;
 
-procfs_list_t zfs_dbgmsgs;
-int zfs_dbgmsg_size = 0;
+static procfs_list_t zfs_dbgmsgs;
+static int zfs_dbgmsg_size = 0;
 int zfs_dbgmsg_maxsize = 4<<20; /* 4MB */
 
 /*
@@ -49,7 +49,7 @@ int zfs_dbgmsg_maxsize = 4<<20; /* 4MB */
  * # Clear the kernel debug message log.
  * echo 0 >/proc/spl/kstat/zfs/dbgmsg
  */
-int zfs_dbgmsg_enable = 1;
+int zfs_dbgmsg_enable = B_TRUE;
 
 static int
 zfs_dbgmsg_show_header(struct seq_file *f)
@@ -84,6 +84,7 @@ zfs_dbgmsg_purge(int max_size)
 static int
 zfs_dbgmsg_clear(procfs_list_t *procfs_list)
 {
+	(void) procfs_list;
 	mutex_enter(&zfs_dbgmsgs.pl_lock);
 	zfs_dbgmsg_purge(0);
 	mutex_exit(&zfs_dbgmsgs.pl_lock);
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_racct.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_racct.c
index 7897e0f9edc1..ce623ef9d185 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_racct.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_racct.c
@@ -28,9 +28,11 @@
 void
 zfs_racct_read(uint64_t size, uint64_t iops)
 {
+	(void) size, (void) iops;
 }
 
 void
 zfs_racct_write(uint64_t size, uint64_t iops)
 {
+	(void) size, (void) iops;
 }
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_vfsops.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_vfsops.c
index ff0b0d9df8f0..acf8c7b89522 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_vfsops.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_vfsops.c
@@ -1251,6 +1251,11 @@ zfs_prune(struct super_block *sb, unsigned long nr_to_scan, int *objects)
 		*objects = 0;
 		for_each_online_node(sc.nid) {
 			*objects += (*shrinker->scan_objects)(shrinker, &sc);
+			/*
+			 * reset sc.nr_to_scan, modified by
+			 * scan_objects == super_cache_scan
+			 */
+			sc.nr_to_scan = nr_to_scan;
 		}
 	} else {
 			*objects = (*shrinker->scan_objects)(shrinker, &sc);
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_vnops_os.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_vnops_os.c
index 6c7de9830c15..aff3c4ad4e4c 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_vnops_os.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_vnops_os.c
@@ -320,7 +320,7 @@ mappedread(znode_t *zp, int nbytes, zfs_uio_t *uio)
 }
 #endif /* _KERNEL */
 
-unsigned long zfs_delete_blocks = DMU_MAX_DELETEBLKCNT;
+static unsigned long zfs_delete_blocks = DMU_MAX_DELETEBLKCNT;
 
 /*
  * Write the bytes to a file.
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zfs_znode.c b/sys/contrib/openzfs/module/os/linux/zfs/zfs_znode.c
index 859c51baffd8..5b1573a6df1a 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zfs_znode.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zfs_znode.c
@@ -80,7 +80,7 @@ unsigned int zfs_object_mutex_size = ZFS_OBJ_MTX_SZ;
  * This is used by the test suite so that it can delay znodes from being
  * freed in order to inspect the unlinked set.
  */
-int zfs_unlink_suspend_progress = 0;
+static int zfs_unlink_suspend_progress = 0;
 
 /*
  * This callback is invoked when acquiring a RL_WRITER or RL_APPEND lock on
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zio_crypt.c b/sys/contrib/openzfs/module/os/linux/zfs/zio_crypt.c
index 52e62f4d1da4..a979f7e20c1b 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zio_crypt.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zio_crypt.c
@@ -186,7 +186,7 @@
 #define	ZFS_KEY_MAX_SALT_USES_DEFAULT	400000000
 #define	ZFS_CURRENT_MAX_SALT_USES	\
 	(MIN(zfs_key_max_salt_uses, ZFS_KEY_MAX_SALT_USES_DEFAULT))
-unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;
+static unsigned long zfs_key_max_salt_uses = ZFS_KEY_MAX_SALT_USES_DEFAULT;
 
 typedef struct blkptr_auth_buf {
 	uint64_t bab_prop;			/* blk_prop - portable mask */
@@ -194,7 +194,7 @@ typedef struct blkptr_auth_buf {
 	uint64_t bab_pad;			/* reserved for future use */
 } blkptr_auth_buf_t;
 
-zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {
+const zio_crypt_info_t zio_crypt_table[ZIO_CRYPT_FUNCTIONS] = {
 	{"",			ZC_TYPE_NONE,	0,	"inherit"},
 	{"",			ZC_TYPE_NONE,	0,	"on"},
 	{"",			ZC_TYPE_NONE,	0,	"off"},
@@ -1203,11 +1203,26 @@ zio_crypt_do_objset_hmacs(zio_crypt_key_t *key, void *data, uint_t datalen,
 
 	bcopy(raw_portable_mac, portable_mac, ZIO_OBJSET_MAC_LEN);
 
+	/*
+	 * This is necessary here as we check next whether
+	 * OBJSET_FLAG_USERACCOUNTING_COMPLETE is set in order to
+	 * decide if the local_mac should be zeroed out. That flag will always
+	 * be set by dmu_objset_id_quota_upgrade_cb() and
+	 * dmu_objset_userspace_upgrade_cb() if useraccounting has been
+	 * completed.
+	 */
+	intval = osp->os_flags;
+	if (should_bswap)
+		intval = BSWAP_64(intval);
+	boolean_t uacct_incomplete =
+	    !(intval & OBJSET_FLAG_USERACCOUNTING_COMPLETE);
+
 	/*
 	 * The local MAC protects the user, group and project accounting.
 	 * If these objects are not present, the local MAC is zeroed out.
 	 */
-	if ((datalen >= OBJSET_PHYS_SIZE_V3 &&
+	if (uacct_incomplete ||
+	    (datalen >= OBJSET_PHYS_SIZE_V3 &&
 	    osp->os_userused_dnode.dn_type == DMU_OT_NONE &&
 	    osp->os_groupused_dnode.dn_type == DMU_OT_NONE &&
 	    osp->os_projectused_dnode.dn_type == DMU_OT_NONE) ||
@@ -1761,6 +1776,7 @@ zio_crypt_init_uios_normal(boolean_t encrypt, uint8_t *plainbuf,
     uint8_t *cipherbuf, uint_t datalen, zfs_uio_t *puio, zfs_uio_t *cuio,
     uint_t *enc_len)
 {
+	(void) encrypt;
 	int ret;
 	uint_t nr_plain = 1, nr_cipher = 2;
 	iovec_t *plain_iovecs = NULL, *cipher_iovecs = NULL;
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zpl_ctldir.c b/sys/contrib/openzfs/module/os/linux/zfs/zpl_ctldir.c
index 9b526afd0002..a640930a02e1 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zpl_ctldir.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zpl_ctldir.c
@@ -201,7 +201,7 @@ zpl_snapdir_revalidate(struct dentry *dentry, unsigned int flags)
 	return (!!dentry->d_inode);
 }
 
-dentry_operations_t zpl_dops_snapdirs = {
+static const dentry_operations_t zpl_dops_snapdirs = {
 /*
  * Auto mounting of snapshots is only supported for 2.6.37 and
  * newer kernels.  Prior to this kernel the ops->follow_link()
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zpl_file.c b/sys/contrib/openzfs/module/os/linux/zfs/zpl_file.c
index 7e88eae33711..21926f170c5c 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zpl_file.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zpl_file.c
@@ -41,7 +41,7 @@
  * When using fallocate(2) to preallocate space, inflate the requested
  * capacity check by 10% to account for the required metadata blocks.
  */
-unsigned int zfs_fallocate_reserve_percent = 110;
+static unsigned int zfs_fallocate_reserve_percent = 110;
 
 static int
 zpl_open(struct inode *ip, struct file *filp)
@@ -817,6 +817,14 @@ zpl_fallocate(struct file *filp, int mode, loff_t offset, loff_t len)
 	    mode, offset, len);
 }
 
+static int
+zpl_ioctl_getversion(struct file *filp, void __user *arg)
+{
+	uint32_t generation = file_inode(filp)->i_generation;
+
+	return (copy_to_user(arg, &generation, sizeof (generation)));
+}
+
 #define	ZFS_FL_USER_VISIBLE	(FS_FL_USER_VISIBLE | ZFS_PROJINHERIT_FL)
 #define	ZFS_FL_USER_MODIFIABLE	(FS_FL_USER_MODIFIABLE | ZFS_PROJINHERIT_FL)
 
@@ -989,6 +997,8 @@ static long
 zpl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
+	case FS_IOC_GETVERSION:
+		return (zpl_ioctl_getversion(filp, (void *)arg));
 	case FS_IOC_GETFLAGS:
 		return (zpl_ioctl_getflags(filp, (void *)arg));
 	case FS_IOC_SETFLAGS:
@@ -1007,6 +1017,9 @@ static long
 zpl_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
 	switch (cmd) {
+	case FS_IOC32_GETVERSION:
+		cmd = FS_IOC_GETVERSION;
+		break;
 	case FS_IOC32_GETFLAGS:
 		cmd = FS_IOC_GETFLAGS;
 		break;
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zpl_xattr.c b/sys/contrib/openzfs/module/os/linux/zfs/zpl_xattr.c
index e7726e8458af..a1921ed08863 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zpl_xattr.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zpl_xattr.c
@@ -746,7 +746,7 @@ __zpl_xattr_user_set(struct inode *ip, const char *name,
 }
 ZPL_XATTR_SET_WRAPPER(zpl_xattr_user_set);
 
-xattr_handler_t zpl_xattr_user_handler =
+static xattr_handler_t zpl_xattr_user_handler =
 {
 	.prefix	= XATTR_USER_PREFIX,
 	.list	= zpl_xattr_user_list,
@@ -815,8 +815,7 @@ __zpl_xattr_trusted_set(struct inode *ip, const char *name,
 }
 ZPL_XATTR_SET_WRAPPER(zpl_xattr_trusted_set);
 
-xattr_handler_t zpl_xattr_trusted_handler =
-{
+static xattr_handler_t zpl_xattr_trusted_handler = {
 	.prefix	= XATTR_TRUSTED_PREFIX,
 	.list	= zpl_xattr_trusted_list,
 	.get	= zpl_xattr_trusted_get,
@@ -910,7 +909,7 @@ zpl_xattr_security_init(struct inode *ip, struct inode *dip,
 /*
  * Security xattr namespace handlers.
  */
-xattr_handler_t zpl_xattr_security_handler = {
+static xattr_handler_t zpl_xattr_security_handler = {
 	.prefix	= XATTR_SECURITY_PREFIX,
 	.list	= zpl_xattr_security_list,
 	.get	= zpl_xattr_security_get,
@@ -1333,8 +1332,7 @@ ZPL_XATTR_SET_WRAPPER(zpl_xattr_acl_set_default);
  * Use .name instead of .prefix when available. xattr_resolve_name will match
  * whole name and reject anything that has .name only as prefix.
  */
-xattr_handler_t zpl_xattr_acl_access_handler =
-{
+static xattr_handler_t zpl_xattr_acl_access_handler = {
 #ifdef HAVE_XATTR_HANDLER_NAME
 	.name	= XATTR_NAME_POSIX_ACL_ACCESS,
 #else
@@ -1356,8 +1354,7 @@ xattr_handler_t zpl_xattr_acl_access_handler =
  * Use .name instead of .prefix when available. xattr_resolve_name will match
  * whole name and reject anything that has .name only as prefix.
  */
-xattr_handler_t zpl_xattr_acl_default_handler =
-{
+static xattr_handler_t zpl_xattr_acl_default_handler = {
 #ifdef HAVE_XATTR_HANDLER_NAME
 	.name	= XATTR_NAME_POSIX_ACL_DEFAULT,
 #else
diff --git a/sys/contrib/openzfs/module/os/linux/zfs/zvol_os.c b/sys/contrib/openzfs/module/os/linux/zfs/zvol_os.c
index 44caadd587f7..cef52e22483a 100644
--- a/sys/contrib/openzfs/module/os/linux/zfs/zvol_os.c
+++ b/sys/contrib/openzfs/module/os/linux/zfs/zvol_os.c
@@ -41,12 +41,12 @@
 #include <linux/blkdev_compat.h>
 #include <linux/task_io_accounting_ops.h>
 
-unsigned int zvol_major = ZVOL_MAJOR;
-unsigned int zvol_request_sync = 0;
-unsigned int zvol_prefetch_bytes = (128 * 1024);
-unsigned long zvol_max_discard_blocks = 16384;
-unsigned int zvol_threads = 32;
-unsigned int zvol_open_timeout_ms = 1000;
+static unsigned int zvol_major = ZVOL_MAJOR;
+static unsigned int zvol_request_sync = 0;
+static unsigned int zvol_prefetch_bytes = (128 * 1024);
+static unsigned long zvol_max_discard_blocks = 16384;
+static unsigned int zvol_threads = 32;
+static const unsigned int zvol_open_timeout_ms = 1000;
 
 struct zvol_state_os {
 	struct gendisk		*zvo_disk;	/* generic disk */
@@ -496,8 +496,7 @@ zvol_open(struct block_device *bdev, fmode_t flag)
 {
 	zvol_state_t *zv;
 	int error = 0;
-	boolean_t drop_suspend = B_TRUE;
-	boolean_t drop_namespace = B_FALSE;
+	boolean_t drop_suspend = B_FALSE;
 #ifndef HAVE_BLKDEV_GET_ERESTARTSYS
 	hrtime_t timeout = MSEC2NSEC(zvol_open_timeout_ms);
 	hrtime_t start = gethrtime();
@@ -517,7 +516,36 @@ zvol_open(struct block_device *bdev, fmode_t flag)
 		return (SET_ERROR(-ENXIO));
 	}
 
-	if (zv->zv_open_count == 0 && !mutex_owned(&spa_namespace_lock)) {
+	mutex_enter(&zv->zv_state_lock);
+	/*
+	 * Make sure zvol is not suspended during first open
+	 * (hold zv_suspend_lock) and respect proper lock acquisition
+	 * ordering - zv_suspend_lock before zv_state_lock
+	 */
+	if (zv->zv_open_count == 0) {
+		if (!rw_tryenter(&zv->zv_suspend_lock, RW_READER)) {
+			mutex_exit(&zv->zv_state_lock);
+			rw_enter(&zv->zv_suspend_lock, RW_READER);
+			mutex_enter(&zv->zv_state_lock);
+			/* check to see if zv_suspend_lock is needed */
+			if (zv->zv_open_count != 0) {
+				rw_exit(&zv->zv_suspend_lock);
+			} else {
+				drop_suspend = B_TRUE;
+			}
+		} else {
+			drop_suspend = B_TRUE;
+		}
+	}
+	rw_exit(&zvol_state_lock);
+
+	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
+
+	if (zv->zv_open_count == 0) {
+		boolean_t drop_namespace = B_FALSE;
+
+		ASSERT(RW_READ_HELD(&zv->zv_suspend_lock));
+
 		/*
 		 * In all other call paths the spa_namespace_lock is taken
 		 * before the bdev->bd_mutex lock.  However, on open(2)
@@ -542,84 +570,51 @@ zvol_open(struct block_device *bdev, fmode_t flag)
 		 * the kernel so the only option is to return the error for
 		 * the caller to handle it.
 		 */
-		if (!mutex_tryenter(&spa_namespace_lock)) {
-			rw_exit(&zvol_state_lock);
+		if (!mutex_owned(&spa_namespace_lock)) {
+			if (!mutex_tryenter(&spa_namespace_lock)) {
+				mutex_exit(&zv->zv_state_lock);
+				rw_exit(&zv->zv_suspend_lock);
 
 #ifdef HAVE_BLKDEV_GET_ERESTARTSYS
-			schedule();
-			return (SET_ERROR(-ERESTARTSYS));
-#else
-			if ((gethrtime() - start) > timeout)
+				schedule();
 				return (SET_ERROR(-ERESTARTSYS));
+#else
+				if ((gethrtime() - start) > timeout)
+					return (SET_ERROR(-ERESTARTSYS));
 
-			schedule_timeout(MSEC_TO_TICK(10));
-			goto retry;
+				schedule_timeout(MSEC_TO_TICK(10));
+				goto retry;
 #endif
-		} else {
-			drop_namespace = B_TRUE;
-		}
-	}
-
-	mutex_enter(&zv->zv_state_lock);
-	/*
-	 * make sure zvol is not suspended during first open
-	 * (hold zv_suspend_lock) and respect proper lock acquisition
-	 * ordering - zv_suspend_lock before zv_state_lock
-	 */
-	if (zv->zv_open_count == 0) {
-		if (!rw_tryenter(&zv->zv_suspend_lock, RW_READER)) {
-			mutex_exit(&zv->zv_state_lock);
-			rw_enter(&zv->zv_suspend_lock, RW_READER);
-			mutex_enter(&zv->zv_state_lock);
-			/* check to see if zv_suspend_lock is needed */
-			if (zv->zv_open_count != 0) {
-				rw_exit(&zv->zv_suspend_lock);
-				drop_suspend = B_FALSE;
+			} else {
+				drop_namespace = B_TRUE;
 			}
 		}
-	} else {
-		drop_suspend = B_FALSE;
-	}
-	rw_exit(&zvol_state_lock);
-
-	ASSERT(MUTEX_HELD(&zv->zv_state_lock));
 
-	if (zv->zv_open_count == 0) {
-		ASSERT(RW_READ_HELD(&zv->zv_suspend_lock));
 		error = -zvol_first_open(zv, !(flag & FMODE_WRITE));
-		if (error)
-			goto out_mutex;
-	}
 
-	if ((flag & FMODE_WRITE) && (zv->zv_flags & ZVOL_RDONLY)) {
-		error = -EROFS;
-		goto out_open_count;
+		if (drop_namespace)
+			mutex_exit(&spa_namespace_lock);
 	}
 
-	zv->zv_open_count++;
-
-	mutex_exit(&zv->zv_state_lock);
-	if (drop_namespace)
-		mutex_exit(&spa_namespace_lock);
-	if (drop_suspend)
-		rw_exit(&zv->zv_suspend_lock);
-
-	zfs_check_media_change(bdev);
-
-	return (0);
+	if (error == 0) {
+		if ((flag & FMODE_WRITE) && (zv->zv_flags & ZVOL_RDONLY)) {
+			if (zv->zv_open_count == 0)
+				zvol_last_close(zv);
 
-out_open_count:
-	if (zv->zv_open_count == 0)
-		zvol_last_close(zv);
+			error = SET_ERROR(-EROFS);
+		} else {
+			zv->zv_open_count++;
+		}
+	}
 
-out_mutex:
 	mutex_exit(&zv->zv_state_lock);
-	if (drop_namespace)
-		mutex_exit(&spa_namespace_lock);
 	if (drop_suspend)
 		rw_exit(&zv->zv_suspend_lock);
 
-	return (SET_ERROR(error));
+	if (error == 0)
+		zfs_check_media_change(bdev);
+
+	return (error);
 }
 
 static void
@@ -807,7 +802,7 @@ zvol_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 	return (0);
 }
 
-static struct block_device_operations zvol_ops = {
+static const struct block_device_operations zvol_ops = {
 	.open			= zvol_open,
 	.release		= zvol_release,
 	.ioctl			= zvol_ioctl,
diff --git a/sys/contrib/openzfs/module/unicode/u8_textprep.c b/sys/contrib/openzfs/module/unicode/u8_textprep.c
index bce5f19625cb..863f69f7ba82 100644
--- a/sys/contrib/openzfs/module/unicode/u8_textprep.c
+++ b/sys/contrib/openzfs/module/unicode/u8_textprep.c
@@ -200,7 +200,7 @@ typedef enum {
 #define	I_				U8_ILLEGAL_CHAR
 #define	O_				U8_OUT_OF_RANGE_CHAR
 
-const int8_t u8_number_of_bytes[0x100] = {
+static const int8_t u8_number_of_bytes[0x100] = {
 	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
@@ -238,7 +238,7 @@ const int8_t u8_number_of_bytes[0x100] = {
 #undef	I_
 #undef	O_
 
-const uint8_t u8_valid_min_2nd_byte[0x100] = {
+static const uint8_t u8_valid_min_2nd_byte[0x100] = {
 	0,    0,    0,    0,    0,    0,    0,    0,
 	0,    0,    0,    0,    0,    0,    0,    0,
 	0,    0,    0,    0,    0,    0,    0,    0,
@@ -280,7 +280,7 @@ const uint8_t u8_valid_min_2nd_byte[0x100] = {
 	0,    0,    0,    0,    0,    0,    0,    0,
 };
 
-const uint8_t u8_valid_max_2nd_byte[0x100] = {
+static const uint8_t u8_valid_max_2nd_byte[0x100] = {
 	0,    0,    0,    0,    0,    0,    0,    0,
 	0,    0,    0,    0,    0,    0,    0,    0,
 	0,    0,    0,    0,    0,    0,    0,    0,
diff --git a/sys/contrib/openzfs/module/unicode/uconv.c b/sys/contrib/openzfs/module/unicode/uconv.c
index fe84979d08b2..6854aeab277f 100644
--- a/sys/contrib/openzfs/module/unicode/uconv.c
+++ b/sys/contrib/openzfs/module/unicode/uconv.c
@@ -139,11 +139,7 @@ static const uchar_t remaining_bytes_tbl[0x100] = {
  * the first byte of a UTF-8 character.  Index is remaining bytes at above of
  * the character.
  */
-#ifdef	_KERNEL
-const uchar_t u8_masks_tbl[6] = { 0x00, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
-#else
 static const uchar_t u8_masks_tbl[6] = { 0x00, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
-#endif	/* _KERNEL */
 
 /*
  * The following two vectors are to provide valid minimum and
diff --git a/sys/contrib/openzfs/module/zcommon/zfeature_common.c b/sys/contrib/openzfs/module/zcommon/zfeature_common.c
index 8d84c6d15148..529c52316f3e 100644
--- a/sys/contrib/openzfs/module/zcommon/zfeature_common.c
+++ b/sys/contrib/openzfs/module/zcommon/zfeature_common.c
@@ -32,6 +32,8 @@
 #ifndef _KERNEL
 #include <errno.h>
 #include <string.h>
+#include <dirent.h>
+#include <search.h>
 #include <sys/stat.h>
 #endif
 #include <sys/debug.h>
@@ -164,30 +166,109 @@ deps_contains_feature(const spa_feature_t *deps, const spa_feature_t feature)
 	return (B_FALSE);
 }
 
+#define	STRCMP ((int(*)(const void *, const void *))&strcmp)
+struct zfs_mod_supported_features {
+	void *tree;
+	boolean_t all_features;
+};
+
+struct zfs_mod_supported_features *
+zfs_mod_list_supported(const char *scope)
+{
+#if defined(__FreeBSD__) || defined(_KERNEL) || defined(LIB_ZPOOL_BUILD)
+	(void) scope;
+	return (NULL);
+#else
+	struct zfs_mod_supported_features *ret = calloc(1, sizeof (*ret));
+	if (ret == NULL)
+		return (NULL);
+
+	DIR *sysfs_dir = NULL;
+	char path[128];
+
+	if (snprintf(path, sizeof (path), "%s/%s",
+	    ZFS_SYSFS_DIR, scope) < sizeof (path))
+		sysfs_dir = opendir(path);
+	if (sysfs_dir == NULL && errno == ENOENT) {
+		if (snprintf(path, sizeof (path), "%s/%s",
+		    ZFS_SYSFS_ALT_DIR, scope) < sizeof (path))
+			sysfs_dir = opendir(path);
+	}
+	if (sysfs_dir == NULL) {
+		ret->all_features = errno == ENOENT &&
+		    (access(ZFS_SYSFS_DIR, F_OK) == 0 ||
+		    access(ZFS_SYSFS_ALT_DIR, F_OK) == 0);
+		return (ret);
+	}
+
+	struct dirent *node;
+	while ((node = readdir(sysfs_dir)) != NULL) {
+		if (strcmp(node->d_name, ".") == 0 ||
+		    strcmp(node->d_name, "..") == 0)
+			continue;
+
+		char *name = strdup(node->d_name);
+		if (name == NULL) {
+			goto nomem;
+		}
+
+		if (tsearch(name, &ret->tree, STRCMP) == NULL) {
+			/*
+			 * Don't bother checking for duplicate entries:
+			 * we're iterating a single directory.
+			 */
+			free(name);
+			goto nomem;
+		}
+	}
+
+end:
+	closedir(sysfs_dir);
+	return (ret);
+
+nomem:
+	zfs_mod_list_supported_free(ret);
+	ret = NULL;
+	goto end;
+#endif
+}
+
+void
+zfs_mod_list_supported_free(struct zfs_mod_supported_features *list)
+{
+#if !defined(__FreeBSD__) && !defined(_KERNEL) && !defined(LIB_ZPOOL_BUILD)
+	if (list) {
+		tdestroy(list->tree, free);
+		free(list);
+	}
+#else
+	(void) list;
+#endif
+}
+
 #if !defined(_KERNEL) && !defined(LIB_ZPOOL_BUILD)
 static boolean_t
 zfs_mod_supported_impl(const char *scope, const char *name, const char *sysfs)
 {
-	boolean_t supported = B_FALSE;
-	char *path;
-
-	int len = asprintf(&path, "%s%s%s%s%s", sysfs,
-	    scope == NULL ? "" : "/", scope == NULL ? "" : scope,
-	    name == NULL ? "" : "/", name == NULL ? "" : name);
-	if (len > 0) {
-		struct stat64 statbuf;
-		supported = !!(stat64(path, &statbuf) == 0);
-		free(path);
-	}
-
-	return (supported);
+	char path[128];
+	if (snprintf(path, sizeof (path), "%s%s%s%s%s", sysfs,
+	    scope == NULL ? "" : "/", scope ?: "",
+	    name == NULL ? "" : "/", name ?: "") < sizeof (path))
+		return (access(path, F_OK) == 0);
+	else
+		return (B_FALSE);
 }
 
 boolean_t
-zfs_mod_supported(const char *scope, const char *name)
+zfs_mod_supported(const char *scope, const char *name,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	boolean_t supported;
 
+	if (sfeatures != NULL)
+		return (sfeatures->all_features ||
+		    tfind(name, &sfeatures->tree, STRCMP));
+
 	/*
 	 * Check both the primary and alternate sysfs locations to determine
 	 * if the required functionality is supported.
@@ -202,10 +283,10 @@ zfs_mod_supported(const char *scope, const char *name)
 	 * scope directory does not exist.
 	 */
 	if (supported == B_FALSE) {
-		struct stat64 statbuf;
-		if ((stat64(ZFS_SYSFS_DIR, &statbuf) == 0) &&
-		    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_DIR) &&
-		    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_ALT_DIR)) {
+		if ((access(ZFS_SYSFS_DIR, F_OK) == 0 &&
+		    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_DIR)) ||
+		    (access(ZFS_SYSFS_ALT_DIR, F_OK) == 0 &&
+		    !zfs_mod_supported_impl(scope, NULL, ZFS_SYSFS_ALT_DIR))) {
 			supported = B_TRUE;
 		}
 	}
@@ -215,7 +296,8 @@ zfs_mod_supported(const char *scope, const char *name)
 #endif
 
 static boolean_t
-zfs_mod_supported_feature(const char *name)
+zfs_mod_supported_feature(const char *name,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	/*
 	 * The zfs module spa_feature_table[], whether in-kernel or in
@@ -229,20 +311,21 @@ zfs_mod_supported_feature(const char *name)
 	 */
 
 #if defined(_KERNEL) || defined(LIB_ZPOOL_BUILD) || defined(__FreeBSD__)
-	(void) name;
+	(void) name, (void) sfeatures;
 	return (B_TRUE);
 #else
-	return (zfs_mod_supported(ZFS_SYSFS_POOL_FEATURES, name));
+	return (zfs_mod_supported(ZFS_SYSFS_POOL_FEATURES, name, sfeatures));
 #endif
 }
 
 static void
 zfeature_register(spa_feature_t fid, const char *guid, const char *name,
     const char *desc, zfeature_flags_t flags, zfeature_type_t type,
-    const spa_feature_t *deps)
+    const spa_feature_t *deps,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	zfeature_info_t *feature = &spa_feature_table[fid];
-	static spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
+	static const spa_feature_t nodeps[] = { SPA_FEATURE_NONE };
 
 	ASSERT(name != NULL);
 	ASSERT(desc != NULL);
@@ -264,7 +347,8 @@ zfeature_register(spa_feature_t fid, const char *guid, const char *name,
 	feature->fi_flags = flags;
 	feature->fi_type = type;
 	feature->fi_depends = deps;
-	feature->fi_zfs_mod_supported = zfs_mod_supported_feature(guid);
+	feature->fi_zfs_mod_supported =
+	    zfs_mod_supported_feature(guid, sfeatures);
 }
 
 /*
@@ -283,318 +367,335 @@ zfeature_register(spa_feature_t fid, const char *guid, const char *name,
 void
 zpool_feature_init(void)
 {
+	struct zfs_mod_supported_features *sfeatures =
+	    zfs_mod_list_supported(ZFS_SYSFS_POOL_FEATURES);
+
 	zfeature_register(SPA_FEATURE_ASYNC_DESTROY,
 	    "com.delphix:async_destroy", "async_destroy",
 	    "Destroy filesystems asynchronously.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_EMPTY_BPOBJ,
 	    "com.delphix:empty_bpobj", "empty_bpobj",
 	    "Snapshots use less space.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_LZ4_COMPRESS,
 	    "org.illumos:lz4_compress", "lz4_compress",
 	    "LZ4 compression algorithm support.",
-	    ZFEATURE_FLAG_ACTIVATE_ON_ENABLE, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_ACTIVATE_ON_ENABLE, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_MULTI_VDEV_CRASH_DUMP,
 	    "com.joyent:multi_vdev_crash_dump", "multi_vdev_crash_dump",
 	    "Crash dumps to multiple vdev pools.",
-	    0, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    0, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
 
 	zfeature_register(SPA_FEATURE_SPACEMAP_HISTOGRAM,
 	    "com.delphix:spacemap_histogram", "spacemap_histogram",
 	    "Spacemaps maintain space histograms.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_ENABLED_TXG,
 	    "com.delphix:enabled_txg", "enabled_txg",
 	    "Record txg at which a feature is enabled",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	{
-	static const spa_feature_t hole_birth_deps[] = {
-		SPA_FEATURE_ENABLED_TXG,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_HOLE_BIRTH,
-	    "com.delphix:hole_birth", "hole_birth",
-	    "Retain hole birth txg for more precise zfs send",
-	    ZFEATURE_FLAG_MOS | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,
-	    ZFEATURE_TYPE_BOOLEAN, hole_birth_deps);
+		static const spa_feature_t hole_birth_deps[] = {
+			SPA_FEATURE_ENABLED_TXG,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_HOLE_BIRTH,
+		    "com.delphix:hole_birth", "hole_birth",
+		    "Retain hole birth txg for more precise zfs send",
+		    ZFEATURE_FLAG_MOS | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,
+		    ZFEATURE_TYPE_BOOLEAN, hole_birth_deps, sfeatures);
 	}
 
 	zfeature_register(SPA_FEATURE_POOL_CHECKPOINT,
 	    "com.delphix:zpool_checkpoint", "zpool_checkpoint",
 	    "Pool state can be checkpointed, allowing rewind later.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_SPACEMAP_V2,
 	    "com.delphix:spacemap_v2", "spacemap_v2",
 	    "Space maps representing large segments are more efficient.",
 	    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,
-	    ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
 
 	zfeature_register(SPA_FEATURE_EXTENSIBLE_DATASET,
 	    "com.delphix:extensible_dataset", "extensible_dataset",
 	    "Enhanced dataset functionality, used by other features.",
-	    0, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    0, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
 
 	{
-	static const spa_feature_t bookmarks_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-
-	zfeature_register(SPA_FEATURE_BOOKMARKS,
-	    "com.delphix:bookmarks", "bookmarks",
-	    "\"zfs bookmark\" command",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
-	    bookmarks_deps);
+		static const spa_feature_t bookmarks_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+
+		zfeature_register(SPA_FEATURE_BOOKMARKS,
+		    "com.delphix:bookmarks", "bookmarks",
+		    "\"zfs bookmark\" command",
+		    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
+		    bookmarks_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t filesystem_limits_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_FS_SS_LIMIT,
-	    "com.joyent:filesystem_limits", "filesystem_limits",
-	    "Filesystem and snapshot limits.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
-	    filesystem_limits_deps);
+		static const spa_feature_t filesystem_limits_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_FS_SS_LIMIT,
+		    "com.joyent:filesystem_limits", "filesystem_limits",
+		    "Filesystem and snapshot limits.",
+		    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
+		    filesystem_limits_deps, sfeatures);
 	}
 
 	zfeature_register(SPA_FEATURE_EMBEDDED_DATA,
 	    "com.delphix:embedded_data", "embedded_data",
 	    "Blocks which compress very well use even less space.",
 	    ZFEATURE_FLAG_MOS | ZFEATURE_FLAG_ACTIVATE_ON_ENABLE,
-	    ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
 
 	{
-	static const spa_feature_t livelist_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_LIVELIST,
-	    "com.delphix:livelist", "livelist",
-	    "Improved clone deletion performance.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
-	    livelist_deps);
+		static const spa_feature_t livelist_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_LIVELIST,
+		    "com.delphix:livelist", "livelist",
+		    "Improved clone deletion performance.",
+		    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
+		    livelist_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t log_spacemap_deps[] = {
-		SPA_FEATURE_SPACEMAP_V2,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_LOG_SPACEMAP,
-	    "com.delphix:log_spacemap", "log_spacemap",
-	    "Log metaslab changes on a single spacemap and "
-	    "flush them periodically.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
-	    log_spacemap_deps);
+		static const spa_feature_t log_spacemap_deps[] = {
+			SPA_FEATURE_SPACEMAP_V2,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_LOG_SPACEMAP,
+		    "com.delphix:log_spacemap", "log_spacemap",
+		    "Log metaslab changes on a single spacemap and "
+		    "flush them periodically.",
+		    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
+		    log_spacemap_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t large_blocks_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_LARGE_BLOCKS,
-	    "org.open-zfs:large_blocks", "large_blocks",
-	    "Support for blocks larger than 128KB.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    large_blocks_deps);
+		static const spa_feature_t large_blocks_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_LARGE_BLOCKS,
+		    "org.open-zfs:large_blocks", "large_blocks",
+		    "Support for blocks larger than 128KB.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    large_blocks_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t large_dnode_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_LARGE_DNODE,
-	    "org.zfsonlinux:large_dnode", "large_dnode",
-	    "Variable on-disk size of dnodes.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    large_dnode_deps);
+		static const spa_feature_t large_dnode_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_LARGE_DNODE,
+		    "org.zfsonlinux:large_dnode", "large_dnode",
+		    "Variable on-disk size of dnodes.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    large_dnode_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t sha512_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_SHA512,
-	    "org.illumos:sha512", "sha512",
-	    "SHA-512/256 hash algorithm.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    sha512_deps);
+		static const spa_feature_t sha512_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_SHA512,
+		    "org.illumos:sha512", "sha512",
+		    "SHA-512/256 hash algorithm.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    sha512_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t skein_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_SKEIN,
-	    "org.illumos:skein", "skein",
-	    "Skein hash algorithm.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    skein_deps);
+		static const spa_feature_t skein_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_SKEIN,
+		    "org.illumos:skein", "skein",
+		    "Skein hash algorithm.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    skein_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t edonr_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_EDONR,
-	    "org.illumos:edonr", "edonr",
-	    "Edon-R hash algorithm.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    edonr_deps);
+		static const spa_feature_t edonr_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_EDONR,
+		    "org.illumos:edonr", "edonr",
+		    "Edon-R hash algorithm.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    edonr_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t redact_books_deps[] = {
-		SPA_FEATURE_BOOKMARK_V2,
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_BOOKMARKS,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_REDACTION_BOOKMARKS,
-	    "com.delphix:redaction_bookmarks", "redaction_bookmarks",
-	    "Support for bookmarks which store redaction lists for zfs "
-	    "redacted send/recv.", 0, ZFEATURE_TYPE_BOOLEAN,
-	    redact_books_deps);
+		static const spa_feature_t redact_books_deps[] = {
+			SPA_FEATURE_BOOKMARK_V2,
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_BOOKMARKS,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_REDACTION_BOOKMARKS,
+		    "com.delphix:redaction_bookmarks", "redaction_bookmarks",
+		    "Support for bookmarks which store redaction lists for zfs "
+		    "redacted send/recv.", 0, ZFEATURE_TYPE_BOOLEAN,
+		    redact_books_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t redact_datasets_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_REDACTED_DATASETS,
-	    "com.delphix:redacted_datasets", "redacted_datasets", "Support for "
-	    "redacted datasets, produced by receiving a redacted zfs send "
-	    "stream.", ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_UINT64_ARRAY,
-	    redact_datasets_deps);
+		static const spa_feature_t redact_datasets_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_REDACTED_DATASETS,
+		    "com.delphix:redacted_datasets", "redacted_datasets",
+		    "Support for redacted datasets, produced by receiving "
+		    "a redacted zfs send stream.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_UINT64_ARRAY,
+		    redact_datasets_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t bookmark_written_deps[] = {
-		SPA_FEATURE_BOOKMARK_V2,
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_BOOKMARKS,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_BOOKMARK_WRITTEN,
-	    "com.delphix:bookmark_written", "bookmark_written",
-	    "Additional accounting, enabling the written#<bookmark> property"
-	    "(space written since a bookmark), and estimates of send stream "
-	    "sizes for incrementals from bookmarks.",
-	    0, ZFEATURE_TYPE_BOOLEAN, bookmark_written_deps);
+		static const spa_feature_t bookmark_written_deps[] = {
+			SPA_FEATURE_BOOKMARK_V2,
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_BOOKMARKS,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_BOOKMARK_WRITTEN,
+		    "com.delphix:bookmark_written", "bookmark_written",
+		    "Additional accounting, enabling the written#<bookmark> "
+		    "property (space written since a bookmark), "
+		    "and estimates of send stream sizes for incrementals from "
+		    "bookmarks.",
+		    0, ZFEATURE_TYPE_BOOLEAN, bookmark_written_deps, sfeatures);
 	}
 
 	zfeature_register(SPA_FEATURE_DEVICE_REMOVAL,
 	    "com.delphix:device_removal", "device_removal",
 	    "Top-level vdevs can be removed, reducing logical pool size.",
-	    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
 
 	{
-	static const spa_feature_t obsolete_counts_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_DEVICE_REMOVAL,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_OBSOLETE_COUNTS,
-	    "com.delphix:obsolete_counts", "obsolete_counts",
-	    "Reduce memory used by removed devices when their blocks are "
-	    "freed or remapped.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
-	    obsolete_counts_deps);
+		static const spa_feature_t obsolete_counts_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_DEVICE_REMOVAL,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_OBSOLETE_COUNTS,
+		    "com.delphix:obsolete_counts", "obsolete_counts",
+		    "Reduce memory used by removed devices when their blocks "
+		    "are freed or remapped.",
+		    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN,
+		    obsolete_counts_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t userobj_accounting_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_USEROBJ_ACCOUNTING,
-	    "org.zfsonlinux:userobj_accounting", "userobj_accounting",
-	    "User/Group object accounting.",
-	    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,
-	    ZFEATURE_TYPE_BOOLEAN, userobj_accounting_deps);
+		static const spa_feature_t userobj_accounting_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_USEROBJ_ACCOUNTING,
+		    "org.zfsonlinux:userobj_accounting", "userobj_accounting",
+		    "User/Group object accounting.",
+		    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,
+		    ZFEATURE_TYPE_BOOLEAN, userobj_accounting_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t bookmark_v2_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_BOOKMARKS,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_BOOKMARK_V2,
-	    "com.datto:bookmark_v2", "bookmark_v2",
-	    "Support for larger bookmarks",
-	    0, ZFEATURE_TYPE_BOOLEAN, bookmark_v2_deps);
+		static const spa_feature_t bookmark_v2_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_BOOKMARKS,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_BOOKMARK_V2,
+		    "com.datto:bookmark_v2", "bookmark_v2",
+		    "Support for larger bookmarks",
+		    0, ZFEATURE_TYPE_BOOLEAN, bookmark_v2_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t encryption_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_BOOKMARK_V2,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_ENCRYPTION,
-	    "com.datto:encryption", "encryption",
-	    "Support for dataset level encryption",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
-	    encryption_deps);
+		static const spa_feature_t encryption_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_BOOKMARK_V2,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_ENCRYPTION,
+		    "com.datto:encryption", "encryption",
+		    "Support for dataset level encryption",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN,
+		    encryption_deps, sfeatures);
 	}
 
 	{
-	static const spa_feature_t project_quota_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_PROJECT_QUOTA,
-	    "org.zfsonlinux:project_quota", "project_quota",
-	    "space/object accounting based on project ID.",
-	    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,
-	    ZFEATURE_TYPE_BOOLEAN, project_quota_deps);
+		static const spa_feature_t project_quota_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_PROJECT_QUOTA,
+		    "org.zfsonlinux:project_quota", "project_quota",
+		    "space/object accounting based on project ID.",
+		    ZFEATURE_FLAG_READONLY_COMPAT | ZFEATURE_FLAG_PER_DATASET,
+		    ZFEATURE_TYPE_BOOLEAN, project_quota_deps, sfeatures);
 	}
 
 	zfeature_register(SPA_FEATURE_ALLOCATION_CLASSES,
 	    "org.zfsonlinux:allocation_classes", "allocation_classes",
 	    "Support for separate allocation classes.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_RESILVER_DEFER,
 	    "com.datto:resilver_defer", "resilver_defer",
 	    "Support for deferring new resilvers when one is already running.",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	zfeature_register(SPA_FEATURE_DEVICE_REBUILD,
 	    "org.openzfs:device_rebuild", "device_rebuild",
 	    "Support for sequential mirror/dRAID device rebuilds",
-	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_READONLY_COMPAT, ZFEATURE_TYPE_BOOLEAN, NULL,
+	    sfeatures);
 
 	{
-	static const spa_feature_t zstd_deps[] = {
-		SPA_FEATURE_EXTENSIBLE_DATASET,
-		SPA_FEATURE_NONE
-	};
-	zfeature_register(SPA_FEATURE_ZSTD_COMPRESS,
-	    "org.freebsd:zstd_compress", "zstd_compress",
-	    "zstd compression algorithm support.",
-	    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN, zstd_deps);
+		static const spa_feature_t zstd_deps[] = {
+			SPA_FEATURE_EXTENSIBLE_DATASET,
+			SPA_FEATURE_NONE
+		};
+		zfeature_register(SPA_FEATURE_ZSTD_COMPRESS,
+		    "org.freebsd:zstd_compress", "zstd_compress",
+		    "zstd compression algorithm support.",
+		    ZFEATURE_FLAG_PER_DATASET, ZFEATURE_TYPE_BOOLEAN, zstd_deps,
+		    sfeatures);
 	}
 
 	zfeature_register(SPA_FEATURE_DRAID,
 	    "org.openzfs:draid", "draid", "Support for distributed spare RAID",
-	    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL);
+	    ZFEATURE_FLAG_MOS, ZFEATURE_TYPE_BOOLEAN, NULL, sfeatures);
+
+	zfs_mod_list_supported_free(sfeatures);
 }
 
 #if defined(_KERNEL)
diff --git a/sys/contrib/openzfs/module/zcommon/zfs_comutil.c b/sys/contrib/openzfs/module/zcommon/zfs_comutil.c
index 886167759be8..020e7e86c11f 100644
--- a/sys/contrib/openzfs/module/zcommon/zfs_comutil.c
+++ b/sys/contrib/openzfs/module/zcommon/zfs_comutil.c
@@ -158,13 +158,11 @@ static zfs_version_spa_map_t zfs_version_table[] = {
 int
 zfs_zpl_version_map(int spa_version)
 {
-	int i;
 	int version = -1;
 
-	for (i = 0; zfs_version_table[i].version_spa; i++) {
+	for (int i = 0; zfs_version_table[i].version_spa; i++)
 		if (spa_version >= zfs_version_table[i].version_spa)
 			version = zfs_version_table[i].version_zpl;
-	}
 
 	return (version);
 }
@@ -176,22 +174,18 @@ zfs_zpl_version_map(int spa_version)
 int
 zfs_spa_version_map(int zpl_version)
 {
-	int i;
-	int version = -1;
-
-	for (i = 0; zfs_version_table[i].version_zpl; i++) {
+	for (int i = 0; zfs_version_table[i].version_zpl; i++)
 		if (zfs_version_table[i].version_zpl >= zpl_version)
 			return (zfs_version_table[i].version_spa);
-	}
 
-	return (version);
+	return (-1);
 }
 
 /*
  * This is the table of legacy internal event names; it should not be modified.
  * The internal events are now stored in the history log as strings.
  */
-const char *zfs_history_event_names[ZFS_NUM_LEGACY_HISTORY_EVENTS] = {
+const char *const zfs_history_event_names[ZFS_NUM_LEGACY_HISTORY_EVENTS] = {
 	"invalid event",
 	"pool create",
 	"vdev add",
@@ -243,9 +237,7 @@ zfs_dataset_name_hidden(const char *name)
 	 * internal datasets (which have a $ in their name), and
 	 * temporary datasets (which have a % in their name).
 	 */
-	if (strchr(name, '$') != NULL)
-		return (B_TRUE);
-	if (strchr(name, '%') != NULL)
+	if (strpbrk(name, "$%") != NULL)
 		return (B_TRUE);
 	if (!INGLOBALZONE(curproc) && !zone_dataset_visible(name, NULL))
 		return (B_TRUE);
diff --git a/sys/contrib/openzfs/module/zcommon/zfs_deleg.c b/sys/contrib/openzfs/module/zcommon/zfs_deleg.c
index e1f5a353b7a4..8a4a6ca86e13 100644
--- a/sys/contrib/openzfs/module/zcommon/zfs_deleg.c
+++ b/sys/contrib/openzfs/module/zcommon/zfs_deleg.c
@@ -42,7 +42,7 @@
 #include "zfs_deleg.h"
 #include "zfs_namecheck.h"
 
-zfs_deleg_perm_tab_t zfs_deleg_perm_tab[] = {
+const zfs_deleg_perm_tab_t zfs_deleg_perm_tab[] = {
 	{ZFS_DELEG_PERM_ALLOW},
 	{ZFS_DELEG_PERM_BOOKMARK},
 	{ZFS_DELEG_PERM_CLONE},
@@ -89,15 +89,12 @@ zfs_valid_permission_name(const char *perm)
 const char *
 zfs_deleg_canonicalize_perm(const char *perm)
 {
-	int i;
-	zfs_prop_t prop;
-
-	for (i = 0; zfs_deleg_perm_tab[i].z_perm != NULL; i++) {
+	for (int i = 0; zfs_deleg_perm_tab[i].z_perm != NULL; i++) {
 		if (strcmp(perm, zfs_deleg_perm_tab[i].z_perm) == 0)
 			return (perm);
 	}
 
-	prop = zfs_name_to_prop(perm);
+	zfs_prop_t prop = zfs_name_to_prop(perm);
 	if (prop != ZPROP_INVAL && zfs_prop_delegatable(prop))
 		return (zfs_prop_to_name(prop));
 	return (NULL);
diff --git a/sys/contrib/openzfs/module/zcommon/zfs_fletcher.c b/sys/contrib/openzfs/module/zcommon/zfs_fletcher.c
index 7a9de4a4309d..e7a8553f3f39 100644
--- a/sys/contrib/openzfs/module/zcommon/zfs_fletcher.c
+++ b/sys/contrib/openzfs/module/zcommon/zfs_fletcher.c
@@ -226,7 +226,6 @@ static struct fletcher_4_kstat {
 /* Indicate that benchmark has been completed */
 static boolean_t fletcher_4_initialized = B_FALSE;
 
-/*ARGSUSED*/
 void
 fletcher_init(zio_cksum_t *zcp)
 {
@@ -258,11 +257,11 @@ fletcher_2_incremental_native(void *buf, size_t size, void *data)
 	return (0);
 }
 
-/*ARGSUSED*/
 void
 fletcher_2_native(const void *buf, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_init(zcp);
 	(void) fletcher_2_incremental_native((void *) buf, size, zcp);
 }
@@ -292,11 +291,11 @@ fletcher_2_incremental_byteswap(void *buf, size_t size, void *data)
 	return (0);
 }
 
-/*ARGSUSED*/
 void
 fletcher_2_byteswap(const void *buf, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_init(zcp);
 	(void) fletcher_2_incremental_byteswap((void *) buf, size, zcp);
 }
@@ -460,11 +459,11 @@ fletcher_4_native_impl(const void *buf, uint64_t size, zio_cksum_t *zcp)
 	ops->fini_native(&ctx, zcp);
 }
 
-/*ARGSUSED*/
 void
 fletcher_4_native(const void *buf, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	const uint64_t p2size = P2ALIGN(size, FLETCHER_MIN_SIMD_SIZE);
 
 	ASSERT(IS_P2ALIGNED(size, sizeof (uint32_t)));
@@ -502,11 +501,11 @@ fletcher_4_byteswap_impl(const void *buf, uint64_t size, zio_cksum_t *zcp)
 	ops->fini_byteswap(&ctx, zcp);
 }
 
-/*ARGSUSED*/
 void
 fletcher_4_byteswap(const void *buf, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	const uint64_t p2size = P2ALIGN(size, FLETCHER_MIN_SIMD_SIZE);
 
 	ASSERT(IS_P2ALIGNED(size, sizeof (uint32_t)));
diff --git a/sys/contrib/openzfs/module/zcommon/zfs_prop.c b/sys/contrib/openzfs/module/zcommon/zfs_prop.c
index 2a0e26eca9c8..36f30859df04 100644
--- a/sys/contrib/openzfs/module/zcommon/zfs_prop.c
+++ b/sys/contrib/openzfs/module/zcommon/zfs_prop.c
@@ -50,7 +50,7 @@
 static zprop_desc_t zfs_prop_table[ZFS_NUM_PROPS];
 
 /* Note this is indexed by zfs_userquota_prop_t, keep the order the same */
-const char *zfs_userquota_prop_prefixes[] = {
+const char *const zfs_userquota_prop_prefixes[] = {
 	"userused@",
 	"userquota@",
 	"groupused@",
@@ -74,7 +74,7 @@ zfs_prop_get_table(void)
 void
 zfs_prop_init(void)
 {
-	static zprop_index_t checksum_table[] = {
+	static const zprop_index_t checksum_table[] = {
 		{ "on",		ZIO_CHECKSUM_ON },
 		{ "off",	ZIO_CHECKSUM_OFF },
 		{ "fletcher2",	ZIO_CHECKSUM_FLETCHER_2 },
@@ -87,7 +87,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t dedup_table[] = {
+	static const zprop_index_t dedup_table[] = {
 		{ "on",		ZIO_CHECKSUM_ON },
 		{ "off",	ZIO_CHECKSUM_OFF },
 		{ "verify",	ZIO_CHECKSUM_ON | ZIO_CHECKSUM_VERIFY },
@@ -105,7 +105,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t compress_table[] = {
+	static const zprop_index_t compress_table[] = {
 		{ "on",		ZIO_COMPRESS_ON },
 		{ "off",	ZIO_COMPRESS_OFF },
 		{ "lzjb",	ZIO_COMPRESS_LZJB },
@@ -205,7 +205,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t crypto_table[] = {
+	static const zprop_index_t crypto_table[] = {
 		{ "on",			ZIO_CRYPT_ON },
 		{ "off",		ZIO_CRYPT_OFF },
 		{ "aes-128-ccm",	ZIO_CRYPT_AES_128_CCM },
@@ -217,7 +217,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t keyformat_table[] = {
+	static const zprop_index_t keyformat_table[] = {
 		{ "none",		ZFS_KEYFORMAT_NONE },
 		{ "raw",		ZFS_KEYFORMAT_RAW },
 		{ "hex",		ZFS_KEYFORMAT_HEX },
@@ -225,19 +225,19 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t snapdir_table[] = {
+	static const zprop_index_t snapdir_table[] = {
 		{ "hidden",	ZFS_SNAPDIR_HIDDEN },
 		{ "visible",	ZFS_SNAPDIR_VISIBLE },
 		{ NULL }
 	};
 
-	static zprop_index_t snapdev_table[] = {
+	static const zprop_index_t snapdev_table[] = {
 		{ "hidden",	ZFS_SNAPDEV_HIDDEN },
 		{ "visible",	ZFS_SNAPDEV_VISIBLE },
 		{ NULL }
 	};
 
-	static zprop_index_t acl_mode_table[] = {
+	static const zprop_index_t acl_mode_table[] = {
 		{ "discard",	ZFS_ACL_DISCARD },
 		{ "groupmask",	ZFS_ACL_GROUPMASK },
 		{ "passthrough", ZFS_ACL_PASSTHROUGH },
@@ -245,7 +245,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t acltype_table[] = {
+	static const zprop_index_t acltype_table[] = {
 		{ "off",	ZFS_ACLTYPE_OFF },
 		{ "posix",	ZFS_ACLTYPE_POSIX },
 		{ "nfsv4",	ZFS_ACLTYPE_NFSV4 },
@@ -255,7 +255,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t acl_inherit_table[] = {
+	static const zprop_index_t acl_inherit_table[] = {
 		{ "discard",	ZFS_ACL_DISCARD },
 		{ "noallow",	ZFS_ACL_NOALLOW },
 		{ "restricted",	ZFS_ACL_RESTRICTED },
@@ -265,14 +265,14 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t case_table[] = {
+	static const zprop_index_t case_table[] = {
 		{ "sensitive",		ZFS_CASE_SENSITIVE },
 		{ "insensitive",	ZFS_CASE_INSENSITIVE },
 		{ "mixed",		ZFS_CASE_MIXED },
 		{ NULL }
 	};
 
-	static zprop_index_t copies_table[] = {
+	static const zprop_index_t copies_table[] = {
 		{ "1",		1 },
 		{ "2",		2 },
 		{ "3",		3 },
@@ -284,7 +284,7 @@ zfs_prop_init(void)
 	 * u8_textprep() to represent the various normalization property
 	 * values.
 	 */
-	static zprop_index_t normalize_table[] = {
+	static const zprop_index_t normalize_table[] = {
 		{ "none",	0 },
 		{ "formD",	U8_TEXTPREP_NFD },
 		{ "formKC",	U8_TEXTPREP_NFKC },
@@ -293,7 +293,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t version_table[] = {
+	static const zprop_index_t version_table[] = {
 		{ "1",		1 },
 		{ "2",		2 },
 		{ "3",		3 },
@@ -303,47 +303,47 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t boolean_table[] = {
+	static const zprop_index_t boolean_table[] = {
 		{ "off",	0 },
 		{ "on",		1 },
 		{ NULL }
 	};
 
-	static zprop_index_t keystatus_table[] = {
+	static const zprop_index_t keystatus_table[] = {
 		{ "none",		ZFS_KEYSTATUS_NONE},
 		{ "unavailable",	ZFS_KEYSTATUS_UNAVAILABLE},
 		{ "available",		ZFS_KEYSTATUS_AVAILABLE},
 		{ NULL }
 	};
 
-	static zprop_index_t logbias_table[] = {
+	static const zprop_index_t logbias_table[] = {
 		{ "latency",	ZFS_LOGBIAS_LATENCY },
 		{ "throughput",	ZFS_LOGBIAS_THROUGHPUT },
 		{ NULL }
 	};
 
-	static zprop_index_t canmount_table[] = {
+	static const zprop_index_t canmount_table[] = {
 		{ "off",	ZFS_CANMOUNT_OFF },
 		{ "on",		ZFS_CANMOUNT_ON },
 		{ "noauto",	ZFS_CANMOUNT_NOAUTO },
 		{ NULL }
 	};
 
-	static zprop_index_t cache_table[] = {
+	static const zprop_index_t cache_table[] = {
 		{ "none",	ZFS_CACHE_NONE },
 		{ "metadata",	ZFS_CACHE_METADATA },
 		{ "all",	ZFS_CACHE_ALL },
 		{ NULL }
 	};
 
-	static zprop_index_t sync_table[] = {
+	static const zprop_index_t sync_table[] = {
 		{ "standard",	ZFS_SYNC_STANDARD },
 		{ "always",	ZFS_SYNC_ALWAYS },
 		{ "disabled",	ZFS_SYNC_DISABLED },
 		{ NULL }
 	};
 
-	static zprop_index_t xattr_table[] = {
+	static const zprop_index_t xattr_table[] = {
 		{ "off",	ZFS_XATTR_OFF },
 		{ "on",		ZFS_XATTR_DIR },
 		{ "sa",		ZFS_XATTR_SA },
@@ -351,7 +351,7 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t dnsize_table[] = {
+	static const zprop_index_t dnsize_table[] = {
 		{ "legacy",	ZFS_DNSIZE_LEGACY },
 		{ "auto",	ZFS_DNSIZE_AUTO },
 		{ "1k",		ZFS_DNSIZE_1K },
@@ -362,13 +362,13 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
-	static zprop_index_t redundant_metadata_table[] = {
+	static const zprop_index_t redundant_metadata_table[] = {
 		{ "all",	ZFS_REDUNDANT_METADATA_ALL },
 		{ "most",	ZFS_REDUNDANT_METADATA_MOST },
 		{ NULL }
 	};
 
-	static zprop_index_t volmode_table[] = {
+	static const zprop_index_t volmode_table[] = {
 		{ "default",	ZFS_VOLMODE_DEFAULT },
 		{ "full",	ZFS_VOLMODE_GEOM },
 		{ "geom",	ZFS_VOLMODE_GEOM },
@@ -377,44 +377,47 @@ zfs_prop_init(void)
 		{ NULL }
 	};
 
+	struct zfs_mod_supported_features *sfeatures =
+	    zfs_mod_list_supported(ZFS_SYSFS_DATASET_PROPERTIES);
+
 	/* inherit index properties */
 	zprop_register_index(ZFS_PROP_REDUNDANT_METADATA, "redundant_metadata",
 	    ZFS_REDUNDANT_METADATA_ALL,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
 	    "all | most", "REDUND_MD",
-	    redundant_metadata_table);
+	    redundant_metadata_table, sfeatures);
 	zprop_register_index(ZFS_PROP_SYNC, "sync", ZFS_SYNC_STANDARD,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
 	    "standard | always | disabled", "SYNC",
-	    sync_table);
+	    sync_table, sfeatures);
 	zprop_register_index(ZFS_PROP_CHECKSUM, "checksum",
 	    ZIO_CHECKSUM_DEFAULT, PROP_INHERIT, ZFS_TYPE_FILESYSTEM |
 	    ZFS_TYPE_VOLUME,
 	    "on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein"
 	    " | edonr",
-	    "CHECKSUM", checksum_table);
+	    "CHECKSUM", checksum_table, sfeatures);
 	zprop_register_index(ZFS_PROP_DEDUP, "dedup", ZIO_CHECKSUM_OFF,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
 	    "on | off | verify | sha256[,verify] | sha512[,verify] | "
 	    "skein[,verify] | edonr,verify",
-	    "DEDUP", dedup_table);
+	    "DEDUP", dedup_table, sfeatures);
 	zprop_register_index(ZFS_PROP_COMPRESSION, "compression",
 	    ZIO_COMPRESS_DEFAULT, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
 	    "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4 | "
 	    "zstd | zstd-[1-19] | "
 	    "zstd-fast | zstd-fast-[1-10,20,30,40,50,60,70,80,90,100,500,1000]",
-	    "COMPRESS", compress_table);
+	    "COMPRESS", compress_table, sfeatures);
 	zprop_register_index(ZFS_PROP_SNAPDIR, "snapdir", ZFS_SNAPDIR_HIDDEN,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
-	    "hidden | visible", "SNAPDIR", snapdir_table);
+	    "hidden | visible", "SNAPDIR", snapdir_table, sfeatures);
 	zprop_register_index(ZFS_PROP_SNAPDEV, "snapdev", ZFS_SNAPDEV_HIDDEN,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "hidden | visible", "SNAPDEV", snapdev_table);
+	    "hidden | visible", "SNAPDEV", snapdev_table, sfeatures);
 	zprop_register_index(ZFS_PROP_ACLMODE, "aclmode", ZFS_ACL_DISCARD,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
 	    "discard | groupmask | passthrough | restricted", "ACLMODE",
-	    acl_mode_table);
+	    acl_mode_table, sfeatures);
 	zprop_register_index(ZFS_PROP_ACLTYPE, "acltype",
 #ifdef __linux__
 	    /* Linux doesn't natively support ZFS's NFSv4-style ACLs. */
@@ -423,270 +426,288 @@ zfs_prop_init(void)
 	    ZFS_ACLTYPE_NFSV4,
 #endif
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT,
-	    "off | nfsv4 | posix", "ACLTYPE", acltype_table);
+	    "off | nfsv4 | posix", "ACLTYPE", acltype_table, sfeatures);
 	zprop_register_index(ZFS_PROP_ACLINHERIT, "aclinherit",
 	    ZFS_ACL_RESTRICTED, PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
 	    "discard | noallow | restricted | passthrough | passthrough-x",
-	    "ACLINHERIT", acl_inherit_table);
+	    "ACLINHERIT", acl_inherit_table, sfeatures);
 	zprop_register_index(ZFS_PROP_COPIES, "copies", 1, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "1 | 2 | 3", "COPIES", copies_table);
+	    "1 | 2 | 3", "COPIES", copies_table, sfeatures);
 	zprop_register_index(ZFS_PROP_PRIMARYCACHE, "primarycache",
 	    ZFS_CACHE_ALL, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT | ZFS_TYPE_VOLUME,
-	    "all | none | metadata", "PRIMARYCACHE", cache_table);
+	    "all | none | metadata", "PRIMARYCACHE", cache_table, sfeatures);
 	zprop_register_index(ZFS_PROP_SECONDARYCACHE, "secondarycache",
 	    ZFS_CACHE_ALL, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT | ZFS_TYPE_VOLUME,
-	    "all | none | metadata", "SECONDARYCACHE", cache_table);
+	    "all | none | metadata", "SECONDARYCACHE", cache_table, sfeatures);
 	zprop_register_index(ZFS_PROP_LOGBIAS, "logbias", ZFS_LOGBIAS_LATENCY,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "latency | throughput", "LOGBIAS", logbias_table);
+	    "latency | throughput", "LOGBIAS", logbias_table, sfeatures);
 	zprop_register_index(ZFS_PROP_XATTR, "xattr", ZFS_XATTR_DIR,
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT,
-	    "on | off | dir | sa", "XATTR", xattr_table);
+	    "on | off | dir | sa", "XATTR", xattr_table, sfeatures);
 	zprop_register_index(ZFS_PROP_DNODESIZE, "dnodesize",
 	    ZFS_DNSIZE_LEGACY, PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
-	    "legacy | auto | 1k | 2k | 4k | 8k | 16k", "DNSIZE", dnsize_table);
+	    "legacy | auto | 1k | 2k | 4k | 8k | 16k", "DNSIZE", dnsize_table,
+	    sfeatures);
 	zprop_register_index(ZFS_PROP_VOLMODE, "volmode",
 	    ZFS_VOLMODE_DEFAULT, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "default | full | geom | dev | none", "VOLMODE", volmode_table);
+	    "default | full | geom | dev | none", "VOLMODE", volmode_table,
+	    sfeatures);
 
 	/* inherit index (boolean) properties */
 	zprop_register_index(ZFS_PROP_ATIME, "atime", 1, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "ATIME", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "ATIME", boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_RELATIME, "relatime", 0, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "RELATIME", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "RELATIME", boolean_table,
+	    sfeatures);
 	zprop_register_index(ZFS_PROP_DEVICES, "devices", 1, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT, "on | off", "DEVICES",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_EXEC, "exec", 1, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT, "on | off", "EXEC",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_SETUID, "setuid", 1, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT, "on | off", "SETUID",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_READONLY, "readonly", 0, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "on | off", "RDONLY",
-	    boolean_table);
+	    boolean_table, sfeatures);
 #ifdef __FreeBSD__
 	zprop_register_index(ZFS_PROP_ZONED, "jailed", 0, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "JAILED", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "JAILED", boolean_table,
+	    sfeatures);
 #else
 	zprop_register_index(ZFS_PROP_ZONED, "zoned", 0, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "ZONED", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "ZONED", boolean_table, sfeatures);
 #endif
 	zprop_register_index(ZFS_PROP_VSCAN, "vscan", 0, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "VSCAN", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "VSCAN", boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_NBMAND, "nbmand", 0, PROP_INHERIT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT, "on | off", "NBMAND",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_OVERLAY, "overlay", 1, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "on | off", "OVERLAY", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "on | off", "OVERLAY", boolean_table,
+	    sfeatures);
 
 	/* default index properties */
 	zprop_register_index(ZFS_PROP_VERSION, "version", 0, PROP_DEFAULT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT,
-	    "1 | 2 | 3 | 4 | 5 | current", "VERSION", version_table);
+	    "1 | 2 | 3 | 4 | 5 | current", "VERSION", version_table, sfeatures);
 	zprop_register_index(ZFS_PROP_CANMOUNT, "canmount", ZFS_CANMOUNT_ON,
 	    PROP_DEFAULT, ZFS_TYPE_FILESYSTEM, "on | off | noauto",
-	    "CANMOUNT", canmount_table);
+	    "CANMOUNT", canmount_table, sfeatures);
 
 	/* readonly index properties */
 	zprop_register_index(ZFS_PROP_MOUNTED, "mounted", 0, PROP_READONLY,
-	    ZFS_TYPE_FILESYSTEM, "yes | no", "MOUNTED", boolean_table);
+	    ZFS_TYPE_FILESYSTEM, "yes | no", "MOUNTED", boolean_table,
+	    sfeatures);
 	zprop_register_index(ZFS_PROP_DEFER_DESTROY, "defer_destroy", 0,
 	    PROP_READONLY, ZFS_TYPE_SNAPSHOT, "yes | no", "DEFER_DESTROY",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZFS_PROP_KEYSTATUS, "keystatus",
 	    ZFS_KEYSTATUS_NONE, PROP_READONLY, ZFS_TYPE_DATASET,
 	    "none | unavailable | available",
-	    "KEYSTATUS", keystatus_table);
+	    "KEYSTATUS", keystatus_table, sfeatures);
 
 	/* set once index properties */
 	zprop_register_index(ZFS_PROP_NORMALIZE, "normalization", 0,
 	    PROP_ONETIME, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT,
 	    "none | formC | formD | formKC | formKD", "NORMALIZATION",
-	    normalize_table);
+	    normalize_table, sfeatures);
 	zprop_register_index(ZFS_PROP_CASE, "casesensitivity",
 	    ZFS_CASE_SENSITIVE, PROP_ONETIME, ZFS_TYPE_FILESYSTEM |
 	    ZFS_TYPE_SNAPSHOT,
-	    "sensitive | insensitive | mixed", "CASE", case_table);
+	    "sensitive | insensitive | mixed", "CASE", case_table, sfeatures);
 	zprop_register_index(ZFS_PROP_KEYFORMAT, "keyformat",
 	    ZFS_KEYFORMAT_NONE, PROP_ONETIME_DEFAULT,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "none | raw | hex | passphrase", "KEYFORMAT", keyformat_table);
+	    "none | raw | hex | passphrase", "KEYFORMAT", keyformat_table,
+	    sfeatures);
 	zprop_register_index(ZFS_PROP_ENCRYPTION, "encryption",
 	    ZIO_CRYPT_DEFAULT, PROP_ONETIME, ZFS_TYPE_DATASET,
 	    "on | off | aes-128-ccm | aes-192-ccm | aes-256-ccm | "
 	    "aes-128-gcm | aes-192-gcm | aes-256-gcm", "ENCRYPTION",
-	    crypto_table);
+	    crypto_table, sfeatures);
 
 	/* set once index (boolean) properties */
 	zprop_register_index(ZFS_PROP_UTF8ONLY, "utf8only", 0, PROP_ONETIME,
 	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_SNAPSHOT,
-	    "on | off", "UTF8ONLY", boolean_table);
+	    "on | off", "UTF8ONLY", boolean_table, sfeatures);
 
 	/* string properties */
 	zprop_register_string(ZFS_PROP_ORIGIN, "origin", NULL, PROP_READONLY,
-	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<snapshot>", "ORIGIN");
+	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<snapshot>", "ORIGIN",
+	    sfeatures);
 	zprop_register_string(ZFS_PROP_CLONES, "clones", NULL, PROP_READONLY,
-	    ZFS_TYPE_SNAPSHOT, "<dataset>[,...]", "CLONES");
+	    ZFS_TYPE_SNAPSHOT, "<dataset>[,...]", "CLONES", sfeatures);
 	zprop_register_string(ZFS_PROP_MOUNTPOINT, "mountpoint", "/",
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM, "<path> | legacy | none",
-	    "MOUNTPOINT");
+	    "MOUNTPOINT", sfeatures);
 	zprop_register_string(ZFS_PROP_SHARENFS, "sharenfs", "off",
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM, "on | off | NFS share options",
-	    "SHARENFS");
+	    "SHARENFS", sfeatures);
 	zprop_register_string(ZFS_PROP_TYPE, "type", NULL, PROP_READONLY,
 	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK,
-	    "filesystem | volume | snapshot | bookmark", "TYPE");
+	    "filesystem | volume | snapshot | bookmark", "TYPE", sfeatures);
 	zprop_register_string(ZFS_PROP_SHARESMB, "sharesmb", "off",
 	    PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
-	    "on | off | SMB share options", "SHARESMB");
+	    "on | off | SMB share options", "SHARESMB", sfeatures);
 	zprop_register_string(ZFS_PROP_MLSLABEL, "mlslabel",
 	    ZFS_MLSLABEL_DEFAULT, PROP_INHERIT, ZFS_TYPE_DATASET,
-	    "<sensitivity label>", "MLSLABEL");
+	    "<sensitivity label>", "MLSLABEL", sfeatures);
 	zprop_register_string(ZFS_PROP_SELINUX_CONTEXT, "context",
 	    "none", PROP_DEFAULT, ZFS_TYPE_DATASET, "<selinux context>",
-	    "CONTEXT");
+	    "CONTEXT", sfeatures);
 	zprop_register_string(ZFS_PROP_SELINUX_FSCONTEXT, "fscontext",
 	    "none", PROP_DEFAULT, ZFS_TYPE_DATASET, "<selinux fscontext>",
-	    "FSCONTEXT");
+	    "FSCONTEXT", sfeatures);
 	zprop_register_string(ZFS_PROP_SELINUX_DEFCONTEXT, "defcontext",
 	    "none", PROP_DEFAULT, ZFS_TYPE_DATASET, "<selinux defcontext>",
-	    "DEFCONTEXT");
+	    "DEFCONTEXT", sfeatures);
 	zprop_register_string(ZFS_PROP_SELINUX_ROOTCONTEXT, "rootcontext",
 	    "none", PROP_DEFAULT, ZFS_TYPE_DATASET, "<selinux rootcontext>",
-	    "ROOTCONTEXT");
+	    "ROOTCONTEXT", sfeatures);
 	zprop_register_string(ZFS_PROP_RECEIVE_RESUME_TOKEN,
 	    "receive_resume_token",
 	    NULL, PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<string token>", "RESUMETOK");
+	    "<string token>", "RESUMETOK", sfeatures);
 	zprop_register_string(ZFS_PROP_ENCRYPTION_ROOT, "encryptionroot", NULL,
 	    PROP_READONLY, ZFS_TYPE_DATASET, "<filesystem | volume>",
-	    "ENCROOT");
+	    "ENCROOT", sfeatures);
 	zprop_register_string(ZFS_PROP_KEYLOCATION, "keylocation",
 	    "none", PROP_DEFAULT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "prompt | <file URI> | <https URL> | <http URL>", "KEYLOCATION");
+	    "prompt | <file URI> | <https URL> | <http URL>", "KEYLOCATION",
+	    sfeatures);
 	zprop_register_string(ZFS_PROP_REDACT_SNAPS,
 	    "redact_snaps", NULL, PROP_READONLY,
 	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<snapshot>[,...]",
-	    "RSNAPS");
+	    "RSNAPS", sfeatures);
 
 	/* readonly number properties */
 	zprop_register_number(ZFS_PROP_USED, "used", 0, PROP_READONLY,
-	    ZFS_TYPE_DATASET, "<size>", "USED");
+	    ZFS_TYPE_DATASET, "<size>", "USED", sfeatures);
 	zprop_register_number(ZFS_PROP_AVAILABLE, "available", 0, PROP_READONLY,
-	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>", "AVAIL");
+	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>", "AVAIL",
+	    sfeatures);
 	zprop_register_number(ZFS_PROP_REFERENCED, "referenced", 0,
 	    PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<size>",
-	    "REFER");
+	    "REFER", sfeatures);
 	zprop_register_number(ZFS_PROP_COMPRESSRATIO, "compressratio", 0,
 	    PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK,
-	    "<1.00x or higher if compressed>", "RATIO");
+	    "<1.00x or higher if compressed>", "RATIO", sfeatures);
 	zprop_register_number(ZFS_PROP_REFRATIO, "refcompressratio", 0,
 	    PROP_READONLY, ZFS_TYPE_DATASET,
-	    "<1.00x or higher if compressed>", "REFRATIO");
+	    "<1.00x or higher if compressed>", "REFRATIO", sfeatures);
 	zprop_register_number(ZFS_PROP_VOLBLOCKSIZE, "volblocksize",
 	    ZVOL_DEFAULT_BLOCKSIZE, PROP_ONETIME,
-	    ZFS_TYPE_VOLUME, "512 to 128k, power of 2",	"VOLBLOCK");
+	    ZFS_TYPE_VOLUME, "512 to 128k, power of 2",	"VOLBLOCK", sfeatures);
 	zprop_register_number(ZFS_PROP_USEDSNAP, "usedbysnapshots", 0,
 	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>",
-	    "USEDSNAP");
+	    "USEDSNAP", sfeatures);
 	zprop_register_number(ZFS_PROP_USEDDS, "usedbydataset", 0,
 	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>",
-	    "USEDDS");
+	    "USEDDS", sfeatures);
 	zprop_register_number(ZFS_PROP_USEDCHILD, "usedbychildren", 0,
 	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>",
-	    "USEDCHILD");
+	    "USEDCHILD", sfeatures);
 	zprop_register_number(ZFS_PROP_USEDREFRESERV, "usedbyrefreservation", 0,
 	    PROP_READONLY,
-	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>", "USEDREFRESERV");
+	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>", "USEDREFRESERV",
+	    sfeatures);
 	zprop_register_number(ZFS_PROP_USERREFS, "userrefs", 0, PROP_READONLY,
-	    ZFS_TYPE_SNAPSHOT, "<count>", "USERREFS");
+	    ZFS_TYPE_SNAPSHOT, "<count>", "USERREFS", sfeatures);
 	zprop_register_number(ZFS_PROP_WRITTEN, "written", 0, PROP_READONLY,
-	    ZFS_TYPE_DATASET, "<size>", "WRITTEN");
+	    ZFS_TYPE_DATASET, "<size>", "WRITTEN", sfeatures);
 	zprop_register_number(ZFS_PROP_LOGICALUSED, "logicalused", 0,
 	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "<size>",
-	    "LUSED");
+	    "LUSED", sfeatures);
 	zprop_register_number(ZFS_PROP_LOGICALREFERENCED, "logicalreferenced",
 	    0, PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<size>",
-	    "LREFER");
+	    "LREFER", sfeatures);
 	zprop_register_number(ZFS_PROP_FILESYSTEM_COUNT, "filesystem_count",
 	    UINT64_MAX, PROP_READONLY, ZFS_TYPE_FILESYSTEM,
-	    "<count>", "FSCOUNT");
+	    "<count>", "FSCOUNT", sfeatures);
 	zprop_register_number(ZFS_PROP_SNAPSHOT_COUNT, "snapshot_count",
 	    UINT64_MAX, PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<count>", "SSCOUNT");
+	    "<count>", "SSCOUNT", sfeatures);
 	zprop_register_number(ZFS_PROP_GUID, "guid", 0, PROP_READONLY,
-	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<uint64>", "GUID");
+	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<uint64>", "GUID",
+	    sfeatures);
 	zprop_register_number(ZFS_PROP_CREATETXG, "createtxg", 0, PROP_READONLY,
-	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<uint64>", "CREATETXG");
+	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "<uint64>", "CREATETXG",
+	    sfeatures);
 	zprop_register_number(ZFS_PROP_PBKDF2_ITERS, "pbkdf2iters",
 	    0, PROP_ONETIME_DEFAULT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<iters>", "PBKDF2ITERS");
+	    "<iters>", "PBKDF2ITERS", sfeatures);
 	zprop_register_number(ZFS_PROP_OBJSETID, "objsetid", 0,
-	    PROP_READONLY, ZFS_TYPE_DATASET, "<uint64>", "OBJSETID");
+	    PROP_READONLY, ZFS_TYPE_DATASET, "<uint64>", "OBJSETID", sfeatures);
 
 	/* default number properties */
 	zprop_register_number(ZFS_PROP_QUOTA, "quota", 0, PROP_DEFAULT,
-	    ZFS_TYPE_FILESYSTEM, "<size> | none", "QUOTA");
+	    ZFS_TYPE_FILESYSTEM, "<size> | none", "QUOTA", sfeatures);
 	zprop_register_number(ZFS_PROP_RESERVATION, "reservation", 0,
 	    PROP_DEFAULT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<size> | none", "RESERV");
+	    "<size> | none", "RESERV", sfeatures);
 	zprop_register_number(ZFS_PROP_VOLSIZE, "volsize", 0, PROP_DEFAULT,
-	    ZFS_TYPE_SNAPSHOT | ZFS_TYPE_VOLUME, "<size>", "VOLSIZE");
+	    ZFS_TYPE_SNAPSHOT | ZFS_TYPE_VOLUME, "<size>", "VOLSIZE",
+	    sfeatures);
 	zprop_register_number(ZFS_PROP_REFQUOTA, "refquota", 0, PROP_DEFAULT,
-	    ZFS_TYPE_FILESYSTEM, "<size> | none", "REFQUOTA");
+	    ZFS_TYPE_FILESYSTEM, "<size> | none", "REFQUOTA", sfeatures);
 	zprop_register_number(ZFS_PROP_REFRESERVATION, "refreservation", 0,
 	    PROP_DEFAULT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<size> | none", "REFRESERV");
+	    "<size> | none", "REFRESERV", sfeatures);
 	zprop_register_number(ZFS_PROP_FILESYSTEM_LIMIT, "filesystem_limit",
 	    UINT64_MAX, PROP_DEFAULT, ZFS_TYPE_FILESYSTEM,
-	    "<count> | none", "FSLIMIT");
+	    "<count> | none", "FSLIMIT", sfeatures);
 	zprop_register_number(ZFS_PROP_SNAPSHOT_LIMIT, "snapshot_limit",
 	    UINT64_MAX, PROP_DEFAULT, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME,
-	    "<count> | none", "SSLIMIT");
+	    "<count> | none", "SSLIMIT", sfeatures);
 
 	/* inherit number properties */
 	zprop_register_number(ZFS_PROP_RECORDSIZE, "recordsize",
 	    SPA_OLD_MAXBLOCKSIZE, PROP_INHERIT,
-	    ZFS_TYPE_FILESYSTEM, "512 to 1M, power of 2", "RECSIZE");
+	    ZFS_TYPE_FILESYSTEM, "512 to 1M, power of 2", "RECSIZE", sfeatures);
 	zprop_register_number(ZFS_PROP_SPECIAL_SMALL_BLOCKS,
 	    "special_small_blocks", 0, PROP_INHERIT, ZFS_TYPE_FILESYSTEM,
-	    "zero or 512 to 1M, power of 2", "SPECIAL_SMALL_BLOCKS");
+	    "zero or 512 to 1M, power of 2", "SPECIAL_SMALL_BLOCKS", sfeatures);
 
 	/* hidden properties */
 	zprop_register_hidden(ZFS_PROP_NUMCLONES, "numclones", PROP_TYPE_NUMBER,
-	    PROP_READONLY, ZFS_TYPE_SNAPSHOT, "NUMCLONES");
+	    PROP_READONLY, ZFS_TYPE_SNAPSHOT, "NUMCLONES", sfeatures);
 	zprop_register_hidden(ZFS_PROP_NAME, "name", PROP_TYPE_STRING,
-	    PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "NAME");
+	    PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "NAME",
+	    sfeatures);
 	zprop_register_hidden(ZFS_PROP_ISCSIOPTIONS, "iscsioptions",
-	    PROP_TYPE_STRING, PROP_INHERIT, ZFS_TYPE_VOLUME, "ISCSIOPTIONS");
+	    PROP_TYPE_STRING, PROP_INHERIT, ZFS_TYPE_VOLUME, "ISCSIOPTIONS",
+	    sfeatures);
 	zprop_register_hidden(ZFS_PROP_STMF_SHAREINFO, "stmf_sbd_lu",
 	    PROP_TYPE_STRING, PROP_INHERIT, ZFS_TYPE_VOLUME,
-	    "STMF_SBD_LU");
+	    "STMF_SBD_LU", sfeatures);
 	zprop_register_hidden(ZFS_PROP_USERACCOUNTING, "useraccounting",
 	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_DATASET,
-	    "USERACCOUNTING");
+	    "USERACCOUNTING", sfeatures);
 	zprop_register_hidden(ZFS_PROP_UNIQUE, "unique", PROP_TYPE_NUMBER,
-	    PROP_READONLY, ZFS_TYPE_DATASET, "UNIQUE");
+	    PROP_READONLY, ZFS_TYPE_DATASET, "UNIQUE", sfeatures);
 	zprop_register_hidden(ZFS_PROP_INCONSISTENT, "inconsistent",
-	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_DATASET, "INCONSISTENT");
+	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_DATASET, "INCONSISTENT",
+	    sfeatures);
 	zprop_register_hidden(ZFS_PROP_IVSET_GUID, "ivsetguid",
 	    PROP_TYPE_NUMBER, PROP_READONLY,
-	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "IVSETGUID");
+	    ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK, "IVSETGUID", sfeatures);
 	zprop_register_hidden(ZFS_PROP_PREV_SNAP, "prevsnap", PROP_TYPE_STRING,
-	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "PREVSNAP");
+	    PROP_READONLY, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "PREVSNAP",
+	    sfeatures);
 	zprop_register_hidden(ZFS_PROP_PBKDF2_SALT, "pbkdf2salt",
 	    PROP_TYPE_NUMBER, PROP_ONETIME_DEFAULT,
-	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "PBKDF2SALT");
+	    ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME, "PBKDF2SALT", sfeatures);
 	zprop_register_hidden(ZFS_PROP_KEY_GUID, "keyguid", PROP_TYPE_NUMBER,
-	    PROP_READONLY, ZFS_TYPE_DATASET, "KEYGUID");
+	    PROP_READONLY, ZFS_TYPE_DATASET, "KEYGUID", sfeatures);
 	zprop_register_hidden(ZFS_PROP_REDACTED, "redacted", PROP_TYPE_NUMBER,
-	    PROP_READONLY, ZFS_TYPE_DATASET, "REDACTED");
+	    PROP_READONLY, ZFS_TYPE_DATASET, "REDACTED", sfeatures);
 
 	/*
 	 * Properties that are obsolete and not used.  These are retained so
@@ -694,12 +715,14 @@ zfs_prop_init(void)
 	 * have NULL pointers in the zfs_prop_table[].
 	 */
 	zprop_register_hidden(ZFS_PROP_REMAPTXG, "remaptxg", PROP_TYPE_NUMBER,
-	    PROP_READONLY, ZFS_TYPE_DATASET, "REMAPTXG");
+	    PROP_READONLY, ZFS_TYPE_DATASET, "REMAPTXG", sfeatures);
 
 	/* oddball properties */
 	zprop_register_impl(ZFS_PROP_CREATION, "creation", PROP_TYPE_NUMBER, 0,
 	    NULL, PROP_READONLY, ZFS_TYPE_DATASET | ZFS_TYPE_BOOKMARK,
-	    "<date>", "CREATION", B_FALSE, B_TRUE, NULL);
+	    "<date>", "CREATION", B_FALSE, B_TRUE, NULL, sfeatures);
+
+	zfs_mod_list_supported_free(sfeatures);
 }
 
 boolean_t
diff --git a/sys/contrib/openzfs/module/zcommon/zpool_prop.c b/sys/contrib/openzfs/module/zcommon/zpool_prop.c
index 8e7a20e8efdc..44bfe4add230 100644
--- a/sys/contrib/openzfs/module/zcommon/zpool_prop.c
+++ b/sys/contrib/openzfs/module/zcommon/zpool_prop.c
@@ -52,103 +52,118 @@ zpool_prop_get_table(void)
 void
 zpool_prop_init(void)
 {
-	static zprop_index_t boolean_table[] = {
+	static const zprop_index_t boolean_table[] = {
 		{ "off",	0},
 		{ "on",		1},
 		{ NULL }
 	};
 
-	static zprop_index_t failuremode_table[] = {
+	static const zprop_index_t failuremode_table[] = {
 		{ "wait",	ZIO_FAILURE_MODE_WAIT },
 		{ "continue",	ZIO_FAILURE_MODE_CONTINUE },
 		{ "panic",	ZIO_FAILURE_MODE_PANIC },
 		{ NULL }
 	};
 
+	struct zfs_mod_supported_features *sfeatures =
+	    zfs_mod_list_supported(ZFS_SYSFS_POOL_PROPERTIES);
+
 	/* string properties */
 	zprop_register_string(ZPOOL_PROP_ALTROOT, "altroot", NULL, PROP_DEFAULT,
-	    ZFS_TYPE_POOL, "<path>", "ALTROOT");
+	    ZFS_TYPE_POOL, "<path>", "ALTROOT", sfeatures);
 	zprop_register_string(ZPOOL_PROP_BOOTFS, "bootfs", NULL, PROP_DEFAULT,
-	    ZFS_TYPE_POOL, "<filesystem>", "BOOTFS");
+	    ZFS_TYPE_POOL, "<filesystem>", "BOOTFS", sfeatures);
 	zprop_register_string(ZPOOL_PROP_CACHEFILE, "cachefile", NULL,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "<file> | none", "CACHEFILE");
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "<file> | none", "CACHEFILE",
+	    sfeatures);
 	zprop_register_string(ZPOOL_PROP_COMMENT, "comment", NULL,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "<comment-string>", "COMMENT");
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "<comment-string>", "COMMENT",
+	    sfeatures);
 	zprop_register_string(ZPOOL_PROP_COMPATIBILITY, "compatibility",
 	    "off", PROP_DEFAULT, ZFS_TYPE_POOL,
-	    "<file[,file...]> | off | legacy", "COMPATIBILITY");
+	    "<file[,file...]> | off | legacy", "COMPATIBILITY", sfeatures);
 
 	/* readonly number properties */
 	zprop_register_number(ZPOOL_PROP_SIZE, "size", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<size>", "SIZE");
+	    ZFS_TYPE_POOL, "<size>", "SIZE", sfeatures);
 	zprop_register_number(ZPOOL_PROP_FREE, "free", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<size>", "FREE");
+	    ZFS_TYPE_POOL, "<size>", "FREE", sfeatures);
 	zprop_register_number(ZPOOL_PROP_FREEING, "freeing", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<size>", "FREEING");
+	    ZFS_TYPE_POOL, "<size>", "FREEING", sfeatures);
 	zprop_register_number(ZPOOL_PROP_CHECKPOINT, "checkpoint", 0,
-	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "CKPOINT");
+	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "CKPOINT", sfeatures);
 	zprop_register_number(ZPOOL_PROP_LEAKED, "leaked", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<size>", "LEAKED");
+	    ZFS_TYPE_POOL, "<size>", "LEAKED", sfeatures);
 	zprop_register_number(ZPOOL_PROP_ALLOCATED, "allocated", 0,
-	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "ALLOC");
+	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "ALLOC", sfeatures);
 	zprop_register_number(ZPOOL_PROP_EXPANDSZ, "expandsize", 0,
-	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "EXPANDSZ");
+	    PROP_READONLY, ZFS_TYPE_POOL, "<size>", "EXPANDSZ", sfeatures);
 	zprop_register_number(ZPOOL_PROP_FRAGMENTATION, "fragmentation", 0,
-	    PROP_READONLY, ZFS_TYPE_POOL, "<percent>", "FRAG");
+	    PROP_READONLY, ZFS_TYPE_POOL, "<percent>", "FRAG", sfeatures);
 	zprop_register_number(ZPOOL_PROP_CAPACITY, "capacity", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<size>", "CAP");
+	    ZFS_TYPE_POOL, "<size>", "CAP", sfeatures);
 	zprop_register_number(ZPOOL_PROP_GUID, "guid", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<guid>", "GUID");
+	    ZFS_TYPE_POOL, "<guid>", "GUID", sfeatures);
 	zprop_register_number(ZPOOL_PROP_LOAD_GUID, "load_guid", 0,
-	    PROP_READONLY, ZFS_TYPE_POOL, "<load_guid>", "LOAD_GUID");
+	    PROP_READONLY, ZFS_TYPE_POOL, "<load_guid>", "LOAD_GUID",
+	    sfeatures);
 	zprop_register_number(ZPOOL_PROP_HEALTH, "health", 0, PROP_READONLY,
-	    ZFS_TYPE_POOL, "<state>", "HEALTH");
+	    ZFS_TYPE_POOL, "<state>", "HEALTH", sfeatures);
 	zprop_register_number(ZPOOL_PROP_DEDUPRATIO, "dedupratio", 0,
 	    PROP_READONLY, ZFS_TYPE_POOL, "<1.00x or higher if deduped>",
-	    "DEDUP");
+	    "DEDUP", sfeatures);
 
 	/* default number properties */
 	zprop_register_number(ZPOOL_PROP_VERSION, "version", SPA_VERSION,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "<version>", "VERSION");
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "<version>", "VERSION", sfeatures);
 	zprop_register_number(ZPOOL_PROP_ASHIFT, "ashift", 0, PROP_DEFAULT,
-	    ZFS_TYPE_POOL, "<ashift, 9-16, or 0=default>", "ASHIFT");
+	    ZFS_TYPE_POOL, "<ashift, 9-16, or 0=default>", "ASHIFT", sfeatures);
 
 	/* default index (boolean) properties */
 	zprop_register_index(ZPOOL_PROP_DELEGATION, "delegation", 1,
 	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "DELEGATION",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZPOOL_PROP_AUTOREPLACE, "autoreplace", 0,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "REPLACE", boolean_table);
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "REPLACE", boolean_table,
+	    sfeatures);
 	zprop_register_index(ZPOOL_PROP_LISTSNAPS, "listsnapshots", 0,
 	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "LISTSNAPS",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(ZPOOL_PROP_AUTOEXPAND, "autoexpand", 0,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "EXPAND", boolean_table);
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "EXPAND", boolean_table,
+	    sfeatures);
 	zprop_register_index(ZPOOL_PROP_READONLY, "readonly", 0,
-	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "RDONLY", boolean_table);
+	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "RDONLY", boolean_table,
+	    sfeatures);
 	zprop_register_index(ZPOOL_PROP_MULTIHOST, "multihost", 0,
 	    PROP_DEFAULT, ZFS_TYPE_POOL, "on | off", "MULTIHOST",
-	    boolean_table);
+	    boolean_table, sfeatures);
 
 	/* default index properties */
 	zprop_register_index(ZPOOL_PROP_FAILUREMODE, "failmode",
 	    ZIO_FAILURE_MODE_WAIT, PROP_DEFAULT, ZFS_TYPE_POOL,
-	    "wait | continue | panic", "FAILMODE", failuremode_table);
+	    "wait | continue | panic", "FAILMODE", failuremode_table,
+	    sfeatures);
 	zprop_register_index(ZPOOL_PROP_AUTOTRIM, "autotrim",
 	    SPA_AUTOTRIM_DEFAULT, PROP_DEFAULT, ZFS_TYPE_POOL,
-	    "on | off", "AUTOTRIM", boolean_table);
+	    "on | off", "AUTOTRIM", boolean_table, sfeatures);
 
 	/* hidden properties */
 	zprop_register_hidden(ZPOOL_PROP_NAME, "name", PROP_TYPE_STRING,
-	    PROP_READONLY, ZFS_TYPE_POOL, "NAME");
+	    PROP_READONLY, ZFS_TYPE_POOL, "NAME", sfeatures);
 	zprop_register_hidden(ZPOOL_PROP_MAXBLOCKSIZE, "maxblocksize",
-	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_POOL, "MAXBLOCKSIZE");
+	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_POOL, "MAXBLOCKSIZE",
+	    sfeatures);
 	zprop_register_hidden(ZPOOL_PROP_TNAME, "tname", PROP_TYPE_STRING,
-	    PROP_ONETIME, ZFS_TYPE_POOL, "TNAME");
+	    PROP_ONETIME, ZFS_TYPE_POOL, "TNAME", sfeatures);
 	zprop_register_hidden(ZPOOL_PROP_MAXDNODESIZE, "maxdnodesize",
-	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_POOL, "MAXDNODESIZE");
+	    PROP_TYPE_NUMBER, PROP_READONLY, ZFS_TYPE_POOL, "MAXDNODESIZE",
+	    sfeatures);
 	zprop_register_hidden(ZPOOL_PROP_DEDUPDITTO, "dedupditto",
-	    PROP_TYPE_NUMBER, PROP_DEFAULT, ZFS_TYPE_POOL, "DEDUPDITTO");
+	    PROP_TYPE_NUMBER, PROP_DEFAULT, ZFS_TYPE_POOL, "DEDUPDITTO",
+	    sfeatures);
+
+	zfs_mod_list_supported_free(sfeatures);
 }
 
 /*
@@ -271,114 +286,122 @@ vdev_prop_get_table(void)
 void
 vdev_prop_init(void)
 {
-	static zprop_index_t boolean_table[] = {
+	static const zprop_index_t boolean_table[] = {
 		{ "off",	0},
 		{ "on",		1},
 		{ NULL }
 	};
-	static zprop_index_t boolean_na_table[] = {
+	static const zprop_index_t boolean_na_table[] = {
 		{ "off",	0},
 		{ "on",		1},
 		{ "-",		2},	/* ZPROP_BOOLEAN_NA */
 		{ NULL }
 	};
 
+	struct zfs_mod_supported_features *sfeatures =
+	    zfs_mod_list_supported(ZFS_SYSFS_VDEV_PROPERTIES);
+
 	/* string properties */
 	zprop_register_string(VDEV_PROP_COMMENT, "comment", NULL,
-	    PROP_DEFAULT, ZFS_TYPE_VDEV, "<comment-string>", "COMMENT");
+	    PROP_DEFAULT, ZFS_TYPE_VDEV, "<comment-string>", "COMMENT",
+	    sfeatures);
 	zprop_register_string(VDEV_PROP_PATH, "path", NULL,
-	    PROP_DEFAULT, ZFS_TYPE_VDEV, "<device-path>", "PATH");
+	    PROP_DEFAULT, ZFS_TYPE_VDEV, "<device-path>", "PATH", sfeatures);
 	zprop_register_string(VDEV_PROP_DEVID, "devid", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<devid>", "DEVID");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<devid>", "DEVID", sfeatures);
 	zprop_register_string(VDEV_PROP_PHYS_PATH, "physpath", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<physpath>", "PHYSPATH");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<physpath>", "PHYSPATH", sfeatures);
 	zprop_register_string(VDEV_PROP_ENC_PATH, "encpath", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<encpath>", "ENCPATH");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<encpath>", "ENCPATH", sfeatures);
 	zprop_register_string(VDEV_PROP_FRU, "fru", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<fru>", "FRU");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<fru>", "FRU", sfeatures);
 	zprop_register_string(VDEV_PROP_PARENT, "parent", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<parent>", "PARENT");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<parent>", "PARENT", sfeatures);
 	zprop_register_string(VDEV_PROP_CHILDREN, "children", NULL,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<child[,...]>", "CHILDREN");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<child[,...]>", "CHILDREN",
+	    sfeatures);
 
 	/* readonly number properties */
 	zprop_register_number(VDEV_PROP_SIZE, "size", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<size>", "SIZE");
+	    ZFS_TYPE_VDEV, "<size>", "SIZE", sfeatures);
 	zprop_register_number(VDEV_PROP_FREE, "free", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<size>", "FREE");
+	    ZFS_TYPE_VDEV, "<size>", "FREE", sfeatures);
 	zprop_register_number(VDEV_PROP_ALLOCATED, "allocated", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<size>", "ALLOC");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<size>", "ALLOC", sfeatures);
 	zprop_register_number(VDEV_PROP_EXPANDSZ, "expandsize", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<size>", "EXPANDSZ");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<size>", "EXPANDSZ", sfeatures);
 	zprop_register_number(VDEV_PROP_FRAGMENTATION, "fragmentation", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<percent>", "FRAG");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<percent>", "FRAG", sfeatures);
 	zprop_register_number(VDEV_PROP_CAPACITY, "capacity", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<size>", "CAP");
+	    ZFS_TYPE_VDEV, "<size>", "CAP", sfeatures);
 	zprop_register_number(VDEV_PROP_GUID, "guid", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<guid>", "GUID");
+	    ZFS_TYPE_VDEV, "<guid>", "GUID", sfeatures);
 	zprop_register_number(VDEV_PROP_STATE, "state", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<state>", "STATE");
+	    ZFS_TYPE_VDEV, "<state>", "STATE", sfeatures);
 	zprop_register_number(VDEV_PROP_BOOTSIZE, "bootsize", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<size>", "BOOTSIZE");
+	    ZFS_TYPE_VDEV, "<size>", "BOOTSIZE", sfeatures);
 	zprop_register_number(VDEV_PROP_ASIZE, "asize", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<asize>", "ASIZE");
+	    ZFS_TYPE_VDEV, "<asize>", "ASIZE", sfeatures);
 	zprop_register_number(VDEV_PROP_PSIZE, "psize", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<psize>", "PSIZE");
+	    ZFS_TYPE_VDEV, "<psize>", "PSIZE", sfeatures);
 	zprop_register_number(VDEV_PROP_ASHIFT, "ashift", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<ashift>", "ASHIFT");
+	    ZFS_TYPE_VDEV, "<ashift>", "ASHIFT", sfeatures);
 	zprop_register_number(VDEV_PROP_PARITY, "parity", 0, PROP_READONLY,
-	    ZFS_TYPE_VDEV, "<parity>", "PARITY");
+	    ZFS_TYPE_VDEV, "<parity>", "PARITY", sfeatures);
 	zprop_register_number(VDEV_PROP_NUMCHILDREN, "numchildren", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<number-of-children>", "NUMCHILD");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<number-of-children>", "NUMCHILD",
+	    sfeatures);
 	zprop_register_number(VDEV_PROP_READ_ERRORS, "read_errors", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "RDERR");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "RDERR", sfeatures);
 	zprop_register_number(VDEV_PROP_WRITE_ERRORS, "write_errors", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "WRERR");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "WRERR", sfeatures);
 	zprop_register_number(VDEV_PROP_CHECKSUM_ERRORS, "checksum_errors", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "CKERR");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<errors>", "CKERR", sfeatures);
 	zprop_register_number(VDEV_PROP_INITIALIZE_ERRORS,
 	    "initialize_errors", 0, PROP_READONLY, ZFS_TYPE_VDEV, "<errors>",
-	    "INITERR");
+	    "INITERR", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_NULL, "null_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "NULLOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "NULLOP", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_READ, "read_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "READOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "READOP", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_WRITE, "write_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "WRITEOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "WRITEOP", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_FREE, "free_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "FREEOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "FREEOP", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_CLAIM, "claim_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "CLAIMOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "CLAIMOP", sfeatures);
 	zprop_register_number(VDEV_PROP_OPS_TRIM, "trim_ops", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "TRIMOP");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<operations>", "TRIMOP", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_NULL, "null_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "NULLBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "NULLBYTE", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_READ, "read_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "READBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "READBYTE", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_WRITE, "write_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "WRITEBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "WRITEBYTE", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_FREE, "free_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "FREEBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "FREEBYTE", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_CLAIM, "claim_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "CLAIMBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "CLAIMBYTE", sfeatures);
 	zprop_register_number(VDEV_PROP_BYTES_TRIM, "trim_bytes", 0,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "TRIMBYTE");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "<bytes>", "TRIMBYTE", sfeatures);
 
 	/* default numeric properties */
 
 	/* default index (boolean) properties */
 	zprop_register_index(VDEV_PROP_REMOVING, "removing", 0,
 	    PROP_READONLY, ZFS_TYPE_VDEV, "on | off", "REMOVING",
-	    boolean_table);
+	    boolean_table, sfeatures);
 	zprop_register_index(VDEV_PROP_ALLOCATING, "allocating", 1,
 	    PROP_DEFAULT, ZFS_TYPE_VDEV, "on | off", "ALLOCATING",
-	    boolean_na_table);
+	    boolean_na_table, sfeatures);
 
 	/* default index properties */
 
 	/* hidden properties */
 	zprop_register_hidden(VDEV_PROP_NAME, "name", PROP_TYPE_STRING,
-	    PROP_READONLY, ZFS_TYPE_VDEV, "NAME");
+	    PROP_READONLY, ZFS_TYPE_VDEV, "NAME", sfeatures);
+
+	zfs_mod_list_supported_free(sfeatures);
 }
 
 /*
diff --git a/sys/contrib/openzfs/module/zcommon/zprop_common.c b/sys/contrib/openzfs/module/zcommon/zprop_common.c
index 17a48361f96e..c32039c1b61d 100644
--- a/sys/contrib/openzfs/module/zcommon/zprop_common.c
+++ b/sys/contrib/openzfs/module/zcommon/zprop_common.c
@@ -71,7 +71,8 @@ zprop_get_numprops(zfs_type_t type)
 }
 
 static boolean_t
-zfs_mod_supported_prop(const char *name, zfs_type_t type)
+zfs_mod_supported_prop(const char *name, zfs_type_t type,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 /*
  * The zfs module spa_feature_table[], whether in-kernel or in libzpool,
@@ -82,11 +83,13 @@ zfs_mod_supported_prop(const char *name, zfs_type_t type)
  * tree, but this has not been done yet.
  */
 #if defined(_KERNEL) || defined(LIB_ZPOOL_BUILD) || defined(__FreeBSD__)
+	(void) name, (void) type, (void) sfeatures;
 	return (B_TRUE);
 #else
 	return (zfs_mod_supported(type == ZFS_TYPE_POOL ?
 	    ZFS_SYSFS_POOL_PROPERTIES : (type == ZFS_TYPE_VDEV ?
-	    ZFS_SYSFS_VDEV_PROPERTIES : ZFS_SYSFS_DATASET_PROPERTIES), name));
+	    ZFS_SYSFS_VDEV_PROPERTIES : ZFS_SYSFS_DATASET_PROPERTIES),
+	    name, sfeatures));
 #endif
 }
 
@@ -94,7 +97,8 @@ void
 zprop_register_impl(int prop, const char *name, zprop_type_t type,
     uint64_t numdefault, const char *strdefault, zprop_attr_t attr,
     int objset_types, const char *values, const char *colname,
-    boolean_t rightalign, boolean_t visible, const zprop_index_t *idx_tbl)
+    boolean_t rightalign, boolean_t visible, const zprop_index_t *idx_tbl,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	zprop_desc_t *prop_tbl = zprop_get_proptable(objset_types);
 	zprop_desc_t *pd;
@@ -116,7 +120,8 @@ zprop_register_impl(int prop, const char *name, zprop_type_t type,
 	pd->pd_colname = colname;
 	pd->pd_rightalign = rightalign;
 	pd->pd_visible = visible;
-	pd->pd_zfs_mod_supported = zfs_mod_supported_prop(name, objset_types);
+	pd->pd_zfs_mod_supported =
+	    zfs_mod_supported_prop(name, objset_types, sfeatures);
 	pd->pd_table = idx_tbl;
 	pd->pd_table_size = 0;
 	while (idx_tbl && (idx_tbl++)->pi_name != NULL)
@@ -126,38 +131,40 @@ zprop_register_impl(int prop, const char *name, zprop_type_t type,
 void
 zprop_register_string(int prop, const char *name, const char *def,
     zprop_attr_t attr, int objset_types, const char *values,
-    const char *colname)
+    const char *colname, const struct zfs_mod_supported_features *sfeatures)
 {
 	zprop_register_impl(prop, name, PROP_TYPE_STRING, 0, def, attr,
-	    objset_types, values, colname, B_FALSE, B_TRUE, NULL);
+	    objset_types, values, colname, B_FALSE, B_TRUE, NULL, sfeatures);
 
 }
 
 void
 zprop_register_number(int prop, const char *name, uint64_t def,
     zprop_attr_t attr, int objset_types, const char *values,
-    const char *colname)
+    const char *colname, const struct zfs_mod_supported_features *sfeatures)
 {
 	zprop_register_impl(prop, name, PROP_TYPE_NUMBER, def, NULL, attr,
-	    objset_types, values, colname, B_TRUE, B_TRUE, NULL);
+	    objset_types, values, colname, B_TRUE, B_TRUE, NULL, sfeatures);
 }
 
 void
 zprop_register_index(int prop, const char *name, uint64_t def,
     zprop_attr_t attr, int objset_types, const char *values,
-    const char *colname, const zprop_index_t *idx_tbl)
+    const char *colname, const zprop_index_t *idx_tbl,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	zprop_register_impl(prop, name, PROP_TYPE_INDEX, def, NULL, attr,
-	    objset_types, values, colname, B_FALSE, B_TRUE, idx_tbl);
+	    objset_types, values, colname, B_FALSE, B_TRUE, idx_tbl, sfeatures);
 }
 
 void
 zprop_register_hidden(int prop, const char *name, zprop_type_t type,
-    zprop_attr_t attr, int objset_types, const char *colname)
+    zprop_attr_t attr, int objset_types, const char *colname,
+    const struct zfs_mod_supported_features *sfeatures)
 {
 	zprop_register_impl(prop, name, type, 0, NULL, attr,
 	    objset_types, NULL, colname,
-	    type == PROP_TYPE_NUMBER, B_FALSE, NULL);
+	    type == PROP_TYPE_NUMBER, B_FALSE, NULL, sfeatures);
 }
 
 
diff --git a/sys/contrib/openzfs/module/zfs/Makefile.in b/sys/contrib/openzfs/module/zfs/Makefile.in
index 653ea0da9bcc..30dc91a7eb59 100644
--- a/sys/contrib/openzfs/module/zfs/Makefile.in
+++ b/sys/contrib/openzfs/module/zfs/Makefile.in
@@ -56,6 +56,7 @@ $(MODULE)-objs += fm.o
 $(MODULE)-objs += gzip.o
 $(MODULE)-objs += hkdf.o
 $(MODULE)-objs += lz4.o
+$(MODULE)-objs += lz4_zfs.o
 $(MODULE)-objs += lzjb.o
 $(MODULE)-objs += metaslab.o
 $(MODULE)-objs += mmp.o
diff --git a/sys/contrib/openzfs/module/zfs/abd.c b/sys/contrib/openzfs/module/zfs/abd.c
index bf39cd613330..8ee8e7e57420 100644
--- a/sys/contrib/openzfs/module/zfs/abd.c
+++ b/sys/contrib/openzfs/module/zfs/abd.c
@@ -889,10 +889,10 @@ abd_copy_from_buf_off(abd_t *abd, const void *buf, size_t off, size_t size)
 	    &ba_ptr);
 }
 
-/*ARGSUSED*/
 static int
 abd_zero_off_cb(void *buf, size_t size, void *private)
 {
+	(void) private;
 	(void) memset(buf, 0, size);
 	return (0);
 }
@@ -967,10 +967,10 @@ abd_iterate_func2(abd_t *dabd, abd_t *sabd, size_t doff, size_t soff,
 	return (ret);
 }
 
-/*ARGSUSED*/
 static int
 abd_copy_off_cb(void *dbuf, void *sbuf, size_t size, void *private)
 {
+	(void) private;
 	(void) memcpy(dbuf, sbuf, size);
 	return (0);
 }
@@ -985,10 +985,10 @@ abd_copy_off(abd_t *dabd, abd_t *sabd, size_t doff, size_t soff, size_t size)
 	    abd_copy_off_cb, NULL);
 }
 
-/*ARGSUSED*/
 static int
 abd_cmp_cb(void *bufa, void *bufb, size_t size, void *private)
 {
+	(void) private;
 	return (memcmp(bufa, bufb, size));
 }
 
diff --git a/sys/contrib/openzfs/module/zfs/arc.c b/sys/contrib/openzfs/module/zfs/arc.c
index 5427f2a71a4f..214c75fe6157 100644
--- a/sys/contrib/openzfs/module/zfs/arc.c
+++ b/sys/contrib/openzfs/module/zfs/arc.c
@@ -328,6 +328,8 @@ static zthr_t *arc_reap_zthr;
  * arc_evict(), which improves arc_is_overflowing().
  */
 static zthr_t *arc_evict_zthr;
+static arc_buf_hdr_t **arc_state_evict_markers;
+static int arc_state_evict_marker_count;
 
 static kmutex_t arc_evict_lock;
 static boolean_t arc_evict_needed = B_FALSE;
@@ -352,7 +354,7 @@ static list_t arc_evict_waiters;
  * can still happen, even during the potentially long time that arc_size is
  * more than arc_c.
  */
-int zfs_arc_eviction_pct = 200;
+static int zfs_arc_eviction_pct = 200;
 
 /*
  * The number of headers to evict in arc_evict_state_impl() before
@@ -361,7 +363,7 @@ int zfs_arc_eviction_pct = 200;
  * oldest header in the arc state), but comes with higher overhead
  * (i.e. more invocations of arc_evict_state_impl()).
  */
-int zfs_arc_evict_batch_limit = 10;
+static int zfs_arc_evict_batch_limit = 10;
 
 /* number of seconds before growing cache again */
 int arc_grow_retry = 5;
@@ -369,13 +371,13 @@ int arc_grow_retry = 5;
 /*
  * Minimum time between calls to arc_kmem_reap_soon().
  */
-int arc_kmem_cache_reap_retry_ms = 1000;
+static const int arc_kmem_cache_reap_retry_ms = 1000;
 
 /* shift of arc_c for calculating overflow limit in arc_get_data_impl */
-int zfs_arc_overflow_shift = 8;
+static int zfs_arc_overflow_shift = 8;
 
 /* shift of arc_c for calculating both min and max arc_p */
-int arc_p_min_shift = 4;
+static int arc_p_min_shift = 4;
 
 /* log2(fraction of arc to reclaim) */
 int arc_shrink_shift = 7;
@@ -421,19 +423,22 @@ unsigned long zfs_arc_max = 0;
 unsigned long zfs_arc_min = 0;
 unsigned long zfs_arc_meta_limit = 0;
 unsigned long zfs_arc_meta_min = 0;
-unsigned long zfs_arc_dnode_limit = 0;
-unsigned long zfs_arc_dnode_reduce_percent = 10;
-int zfs_arc_grow_retry = 0;
-int zfs_arc_shrink_shift = 0;
-int zfs_arc_p_min_shift = 0;
+static unsigned long zfs_arc_dnode_limit = 0;
+static unsigned long zfs_arc_dnode_reduce_percent = 10;
+static int zfs_arc_grow_retry = 0;
+static int zfs_arc_shrink_shift = 0;
+static int zfs_arc_p_min_shift = 0;
 int zfs_arc_average_blocksize = 8 * 1024; /* 8KB */
 
 /*
- * ARC dirty data constraints for arc_tempreserve_space() throttle.
+ * ARC dirty data constraints for arc_tempreserve_space() throttle:
+ * * total dirty data limit
+ * * anon block dirty limit
+ * * each pool's anon allowance
  */
-unsigned long zfs_arc_dirty_limit_percent = 50;	/* total dirty data limit */
-unsigned long zfs_arc_anon_limit_percent = 25;	/* anon block dirty limit */
-unsigned long zfs_arc_pool_dirty_percent = 20;	/* each pool's anon allowance */
+static const unsigned long zfs_arc_dirty_limit_percent = 50;
+static const unsigned long zfs_arc_anon_limit_percent = 25;
+static const unsigned long zfs_arc_pool_dirty_percent = 20;
 
 /*
  * Enable or disable compressed arc buffers.
@@ -444,24 +449,29 @@ int zfs_compressed_arc_enabled = B_TRUE;
  * ARC will evict meta buffers that exceed arc_meta_limit. This
  * tunable make arc_meta_limit adjustable for different workloads.
  */
-unsigned long zfs_arc_meta_limit_percent = 75;
+static unsigned long zfs_arc_meta_limit_percent = 75;
 
 /*
  * Percentage that can be consumed by dnodes of ARC meta buffers.
  */
-unsigned long zfs_arc_dnode_limit_percent = 10;
+static unsigned long zfs_arc_dnode_limit_percent = 10;
 
 /*
- * These tunables are Linux specific
+ * These tunables are Linux-specific
  */
-unsigned long zfs_arc_sys_free = 0;
-int zfs_arc_min_prefetch_ms = 0;
-int zfs_arc_min_prescient_prefetch_ms = 0;
-int zfs_arc_p_dampener_disable = 1;
-int zfs_arc_meta_prune = 10000;
-int zfs_arc_meta_strategy = ARC_STRATEGY_META_BALANCED;
-int zfs_arc_meta_adjust_restarts = 4096;
-int zfs_arc_lotsfree_percent = 10;
+static unsigned long zfs_arc_sys_free = 0;
+static int zfs_arc_min_prefetch_ms = 0;
+static int zfs_arc_min_prescient_prefetch_ms = 0;
+static int zfs_arc_p_dampener_disable = 1;
+static int zfs_arc_meta_prune = 10000;
+static int zfs_arc_meta_strategy = ARC_STRATEGY_META_BALANCED;
+static int zfs_arc_meta_adjust_restarts = 4096;
+static int zfs_arc_lotsfree_percent = 10;
+
+/*
+ * Number of arc_prune threads
+ */
+static int zfs_arc_prune_task_threads = 1;
 
 /* The 6 states: */
 arc_state_t ARC_anon;
@@ -646,7 +656,7 @@ arc_sums_t arc_sums;
 		ARCSTAT(stat) = x; \
 	} while (0)
 
-kstat_t			*arc_ksp;
+static kstat_t			*arc_ksp;
 
 /*
  * There are several ARC variables that are critical to export as kstats --
@@ -780,7 +790,7 @@ unsigned long l2arc_feed_min_ms = L2ARC_FEED_MIN_MS;	/* min interval msecs */
 int l2arc_noprefetch = B_TRUE;			/* don't cache prefetch bufs */
 int l2arc_feed_again = B_TRUE;			/* turbo warmup */
 int l2arc_norw = B_FALSE;			/* no reads during writes */
-int l2arc_meta_percent = 33;			/* limit on headers size */
+static int l2arc_meta_percent = 33;		/* limit on headers size */
 
 /*
  * L2ARC Internals
@@ -881,7 +891,7 @@ int l2arc_exclude_special = 0;
  * l2arc_mfuonly : A ZFS module parameter that controls whether only MFU
  * 		metadata and data are cached from ARC into L2ARC.
  */
-int l2arc_mfuonly = 0;
+static int l2arc_mfuonly = 0;
 
 /*
  * L2ARC TRIM
@@ -898,7 +908,7 @@ int l2arc_mfuonly = 0;
  * 		will vary depending of how well the specific device handles
  * 		these commands.
  */
-unsigned long l2arc_trim_ahead = 0;
+static unsigned long l2arc_trim_ahead = 0;
 
 /*
  * Performance tuning of L2ARC persistence:
@@ -913,8 +923,8 @@ unsigned long l2arc_trim_ahead = 0;
  * 		data. In this case do not write log blocks in L2ARC in order
  * 		not to waste space.
  */
-int l2arc_rebuild_enabled = B_TRUE;
-unsigned long l2arc_rebuild_blocks_min_l2size = 1024 * 1024 * 1024;
+static int l2arc_rebuild_enabled = B_TRUE;
+static unsigned long l2arc_rebuild_blocks_min_l2size = 1024 * 1024 * 1024;
 
 /* L2ARC persistence rebuild control routines. */
 void l2arc_rebuild_vdev(vdev_t *vd, boolean_t reopen);
@@ -1093,8 +1103,6 @@ static kmem_cache_t *buf_cache;
 static void
 buf_fini(void)
 {
-	int i;
-
 #if defined(_KERNEL)
 	/*
 	 * Large allocations which do not require contiguous pages
@@ -1106,7 +1114,7 @@ buf_fini(void)
 	kmem_free(buf_hash_table.ht_table,
 	    (buf_hash_table.ht_mask + 1) * sizeof (void *));
 #endif
-	for (i = 0; i < BUF_LOCKS; i++)
+	for (int i = 0; i < BUF_LOCKS; i++)
 		mutex_destroy(BUF_HASH_LOCK(i));
 	kmem_cache_destroy(hdr_full_cache);
 	kmem_cache_destroy(hdr_full_crypt_cache);
@@ -1118,10 +1126,10 @@ buf_fini(void)
  * Constructor callback - called when the cache is empty
  * and a new buf is requested.
  */
-/* ARGSUSED */
 static int
 hdr_full_cons(void *vbuf, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	arc_buf_hdr_t *hdr = vbuf;
 
 	bzero(hdr, HDR_FULL_SIZE);
@@ -1137,10 +1145,10 @@ hdr_full_cons(void *vbuf, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 hdr_full_crypt_cons(void *vbuf, void *unused, int kmflag)
 {
+	(void) unused;
 	arc_buf_hdr_t *hdr = vbuf;
 
 	hdr_full_cons(vbuf, unused, kmflag);
@@ -1150,10 +1158,10 @@ hdr_full_crypt_cons(void *vbuf, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 hdr_l2only_cons(void *vbuf, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	arc_buf_hdr_t *hdr = vbuf;
 
 	bzero(hdr, HDR_L2ONLY_SIZE);
@@ -1162,10 +1170,10 @@ hdr_l2only_cons(void *vbuf, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 buf_cons(void *vbuf, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	arc_buf_t *buf = vbuf;
 
 	bzero(buf, sizeof (arc_buf_t));
@@ -1179,10 +1187,10 @@ buf_cons(void *vbuf, void *unused, int kmflag)
  * Destructor callback - called when a cached buf is
  * no longer required.
  */
-/* ARGSUSED */
 static void
 hdr_full_dest(void *vbuf, void *unused)
 {
+	(void) unused;
 	arc_buf_hdr_t *hdr = vbuf;
 
 	ASSERT(HDR_EMPTY(hdr));
@@ -1193,30 +1201,30 @@ hdr_full_dest(void *vbuf, void *unused)
 	arc_space_return(HDR_FULL_SIZE, ARC_SPACE_HDRS);
 }
 
-/* ARGSUSED */
 static void
 hdr_full_crypt_dest(void *vbuf, void *unused)
 {
+	(void) unused;
 	arc_buf_hdr_t *hdr = vbuf;
 
 	hdr_full_dest(vbuf, unused);
 	arc_space_return(sizeof (hdr->b_crypt_hdr), ARC_SPACE_HDRS);
 }
 
-/* ARGSUSED */
 static void
 hdr_l2only_dest(void *vbuf, void *unused)
 {
-	arc_buf_hdr_t *hdr __maybe_unused = vbuf;
+	(void) unused;
+	arc_buf_hdr_t *hdr = vbuf;
 
 	ASSERT(HDR_EMPTY(hdr));
 	arc_space_return(HDR_L2ONLY_SIZE, ARC_SPACE_L2HDRS);
 }
 
-/* ARGSUSED */
 static void
 buf_dest(void *vbuf, void *unused)
 {
+	(void) unused;
 	arc_buf_t *buf = vbuf;
 
 	mutex_destroy(&buf->b_evict_lock);
@@ -1512,11 +1520,11 @@ arc_cksum_compute(arc_buf_t *buf)
 void
 arc_buf_sigsegv(int sig, siginfo_t *si, void *unused)
 {
+	(void) sig, (void) unused;
 	panic("Got SIGSEGV at address: 0x%lx\n", (long)si->si_addr);
 }
 #endif
 
-/* ARGSUSED */
 static void
 arc_buf_unwatch(arc_buf_t *buf)
 {
@@ -1525,10 +1533,11 @@ arc_buf_unwatch(arc_buf_t *buf)
 		ASSERT0(mprotect(buf->b_data, arc_buf_size(buf),
 		    PROT_READ | PROT_WRITE));
 	}
+#else
+	(void) buf;
 #endif
 }
 
-/* ARGSUSED */
 static void
 arc_buf_watch(arc_buf_t *buf)
 {
@@ -1536,6 +1545,8 @@ arc_buf_watch(arc_buf_t *buf)
 	if (arc_watch)
 		ASSERT0(mprotect(buf->b_data, arc_buf_size(buf),
 		    PROT_READ));
+#else
+	(void) buf;
 #endif
 }
 
@@ -1947,7 +1958,7 @@ arc_fill_hdr_crypt(arc_buf_hdr_t *hdr, kmutex_t *hash_lock, spa_t *spa,
  * arc_buf_fill().
  */
 static void
-arc_buf_untransform_in_place(arc_buf_t *buf, kmutex_t *hash_lock)
+arc_buf_untransform_in_place(arc_buf_t *buf)
 {
 	arc_buf_hdr_t *hdr = buf->b_hdr;
 
@@ -2051,7 +2062,7 @@ arc_buf_fill(arc_buf_t *buf, spa_t *spa, const zbookmark_phys_t *zb,
 
 			if (hash_lock != NULL)
 				mutex_enter(hash_lock);
-			arc_buf_untransform_in_place(buf, hash_lock);
+			arc_buf_untransform_in_place(buf);
 			if (hash_lock != NULL)
 				mutex_exit(hash_lock);
 
@@ -2337,6 +2348,7 @@ remove_reference(arc_buf_hdr_t *hdr, kmutex_t *hash_lock, void *tag)
 void
 arc_buf_info(arc_buf_t *ab, arc_buf_info_t *abi, int state_index)
 {
+	(void) state_index;
 	arc_buf_hdr_t *hdr = ab->b_hdr;
 	l1arc_buf_hdr_t *l1hdr = NULL;
 	l2arc_buf_hdr_t *l2hdr = NULL;
@@ -4156,6 +4168,38 @@ arc_evict_state_impl(multilist_t *ml, int idx, arc_buf_hdr_t *marker,
 	return (bytes_evicted);
 }
 
+/*
+ * Allocate an array of buffer headers used as placeholders during arc state
+ * eviction.
+ */
+static arc_buf_hdr_t **
+arc_state_alloc_markers(int count)
+{
+	arc_buf_hdr_t **markers;
+
+	markers = kmem_zalloc(sizeof (*markers) * count, KM_SLEEP);
+	for (int i = 0; i < count; i++) {
+		markers[i] = kmem_cache_alloc(hdr_full_cache, KM_SLEEP);
+
+		/*
+		 * A b_spa of 0 is used to indicate that this header is
+		 * a marker. This fact is used in arc_evict_type() and
+		 * arc_evict_state_impl().
+		 */
+		markers[i]->b_spa = 0;
+
+	}
+	return (markers);
+}
+
+static void
+arc_state_free_markers(arc_buf_hdr_t **markers, int count)
+{
+	for (int i = 0; i < count; i++)
+		kmem_cache_free(hdr_full_cache, markers[i]);
+	kmem_free(markers, sizeof (*markers) * count);
+}
+
 /*
  * Evict buffers from the given arc state, until we've removed the
  * specified number of bytes. Move the removed buffers to the
@@ -4187,19 +4231,15 @@ arc_evict_state(arc_state_t *state, uint64_t spa, uint64_t bytes,
 	 * pick up where we left off for each individual sublist, rather
 	 * than starting from the tail each time.
 	 */
-	markers = kmem_zalloc(sizeof (*markers) * num_sublists, KM_SLEEP);
+	if (zthr_iscurthread(arc_evict_zthr)) {
+		markers = arc_state_evict_markers;
+		ASSERT3S(num_sublists, <=, arc_state_evict_marker_count);
+	} else {
+		markers = arc_state_alloc_markers(num_sublists);
+	}
 	for (int i = 0; i < num_sublists; i++) {
 		multilist_sublist_t *mls;
 
-		markers[i] = kmem_cache_alloc(hdr_full_cache, KM_SLEEP);
-
-		/*
-		 * A b_spa of 0 is used to indicate that this header is
-		 * a marker. This fact is used in arc_evict_type() and
-		 * arc_evict_state_impl().
-		 */
-		markers[i]->b_spa = 0;
-
 		mls = multilist_sublist_lock(ml, i);
 		multilist_sublist_insert_tail(mls, markers[i]);
 		multilist_sublist_unlock(mls);
@@ -4281,10 +4321,9 @@ arc_evict_state(arc_state_t *state, uint64_t spa, uint64_t bytes,
 		multilist_sublist_t *mls = multilist_sublist_lock(ml, i);
 		multilist_sublist_remove(mls, markers[i]);
 		multilist_sublist_unlock(mls);
-
-		kmem_cache_free(hdr_full_cache, markers[i]);
 	}
-	kmem_free(markers, sizeof (*markers) * num_sublists);
+	if (markers != arc_state_evict_markers)
+		arc_state_free_markers(markers, num_sublists);
 
 	return (total_evicted);
 }
@@ -4803,8 +4842,6 @@ arc_kmem_reap_soon(void)
 	size_t			i;
 	kmem_cache_t		*prev_cache = NULL;
 	kmem_cache_t		*prev_data_cache = NULL;
-	extern kmem_cache_t	*zio_buf_cache[];
-	extern kmem_cache_t	*zio_data_buf_cache[];
 
 #ifdef _KERNEL
 	if ((aggsum_compare(&arc_sums.arcstat_meta_used,
@@ -4845,10 +4882,11 @@ arc_kmem_reap_soon(void)
 	abd_cache_reap_now();
 }
 
-/* ARGSUSED */
 static boolean_t
 arc_evict_cb_check(void *arg, zthr_t *zthr)
 {
+	(void) arg, (void) zthr;
+
 #ifdef ZFS_DEBUG
 	/*
 	 * This is necessary in order to keep the kstat information
@@ -4888,10 +4926,11 @@ arc_evict_cb_check(void *arg, zthr_t *zthr)
  * Keep arc_size under arc_c by running arc_evict which evicts data
  * from the ARC.
  */
-/* ARGSUSED */
 static void
 arc_evict_cb(void *arg, zthr_t *zthr)
 {
+	(void) arg, (void) zthr;
+
 	uint64_t evicted = 0;
 	fstrans_cookie_t cookie = spl_fstrans_mark();
 
@@ -4928,10 +4967,11 @@ arc_evict_cb(void *arg, zthr_t *zthr)
 	spl_fstrans_unmark(cookie);
 }
 
-/* ARGSUSED */
 static boolean_t
 arc_reap_cb_check(void *arg, zthr_t *zthr)
 {
+	(void) arg, (void) zthr;
+
 	int64_t free_memory = arc_available_memory();
 	static int reap_cb_check_counter = 0;
 
@@ -4975,10 +5015,11 @@ arc_reap_cb_check(void *arg, zthr_t *zthr)
  * target size of the cache (arc_c), causing the arc_evict_cb()
  * to free more buffers.
  */
-/* ARGSUSED */
 static void
 arc_reap_cb(void *arg, zthr_t *zthr)
 {
+	(void) arg, (void) zthr;
+
 	int64_t free_memory;
 	fstrans_cookie_t cookie = spl_fstrans_mark();
 
@@ -5593,11 +5634,12 @@ arc_buf_access(arc_buf_t *buf)
 }
 
 /* a generic arc_read_done_func_t which you can use */
-/* ARGSUSED */
 void
 arc_bcopy_func(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
     arc_buf_t *buf, void *arg)
 {
+	(void) zio, (void) zb, (void) bp;
+
 	if (buf == NULL)
 		return;
 
@@ -5606,11 +5648,11 @@ arc_bcopy_func(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
 }
 
 /* a generic arc_read_done_func_t */
-/* ARGSUSED */
 void
 arc_getbuf_func(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
     arc_buf_t *buf, void *arg)
 {
+	(void) zb, (void) bp;
 	arc_buf_t **bufp = arg;
 
 	if (buf == NULL) {
@@ -7605,53 +7647,52 @@ arc_tuning_update(boolean_t verbose)
 	WARN_IF_TUNING_IGNORED(zfs_arc_sys_free, arc_sys_free, verbose);
 }
 
+static void
+arc_state_multilist_init(multilist_t *ml,
+    multilist_sublist_index_func_t *index_func, int *maxcountp)
+{
+	multilist_create(ml, sizeof (arc_buf_hdr_t),
+	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node), index_func);
+	*maxcountp = MAX(*maxcountp, multilist_get_num_sublists(ml));
+}
+
 static void
 arc_state_init(void)
 {
-	multilist_create(&arc_mru->arcs_list[ARC_BUFC_METADATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mru->arcs_list[ARC_BUFC_DATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mru_ghost->arcs_list[ARC_BUFC_METADATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mru_ghost->arcs_list[ARC_BUFC_DATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mfu->arcs_list[ARC_BUFC_METADATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mfu->arcs_list[ARC_BUFC_DATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mfu_ghost->arcs_list[ARC_BUFC_METADATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
-	multilist_create(&arc_mfu_ghost->arcs_list[ARC_BUFC_DATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_multilist_index_func);
+	int num_sublists = 0;
+
+	arc_state_multilist_init(&arc_mru->arcs_list[ARC_BUFC_METADATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mru->arcs_list[ARC_BUFC_DATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mru_ghost->arcs_list[ARC_BUFC_METADATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mru_ghost->arcs_list[ARC_BUFC_DATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mfu->arcs_list[ARC_BUFC_METADATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mfu->arcs_list[ARC_BUFC_DATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mfu_ghost->arcs_list[ARC_BUFC_METADATA],
+	    arc_state_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_mfu_ghost->arcs_list[ARC_BUFC_DATA],
+	    arc_state_multilist_index_func, &num_sublists);
+
 	/*
 	 * L2 headers should never be on the L2 state list since they don't
 	 * have L1 headers allocated.  Special index function asserts that.
 	 */
-	multilist_create(&arc_l2c_only->arcs_list[ARC_BUFC_METADATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_l2c_multilist_index_func);
-	multilist_create(&arc_l2c_only->arcs_list[ARC_BUFC_DATA],
-	    sizeof (arc_buf_hdr_t),
-	    offsetof(arc_buf_hdr_t, b_l1hdr.b_arc_node),
-	    arc_state_l2c_multilist_index_func);
+	arc_state_multilist_init(&arc_l2c_only->arcs_list[ARC_BUFC_METADATA],
+	    arc_state_l2c_multilist_index_func, &num_sublists);
+	arc_state_multilist_init(&arc_l2c_only->arcs_list[ARC_BUFC_DATA],
+	    arc_state_l2c_multilist_index_func, &num_sublists);
+
+	/*
+	 * Keep track of the number of markers needed to reclaim buffers from
+	 * any ARC state.  The markers will be pre-allocated so as to minimize
+	 * the number of memory allocations performed by the eviction thread.
+	 */
+	arc_state_evict_marker_count = num_sublists;
 
 	zfs_refcount_create(&arc_anon->arcs_esize[ARC_BUFC_METADATA]);
 	zfs_refcount_create(&arc_anon->arcs_esize[ARC_BUFC_DATA]);
@@ -7983,9 +8024,8 @@ arc_init(void)
 	    offsetof(arc_prune_t, p_node));
 	mutex_init(&arc_prune_mtx, NULL, MUTEX_DEFAULT, NULL);
 
-	arc_prune_taskq = taskq_create("arc_prune", 100, defclsyspri,
-	    boot_ncpus, INT_MAX, TASKQ_PREPOPULATE | TASKQ_DYNAMIC |
-	    TASKQ_THREADS_CPU_PCT);
+	arc_prune_taskq = taskq_create("arc_prune", zfs_arc_prune_task_threads,
+	    defclsyspri, 100, INT_MAX, TASKQ_PREPOPULATE | TASKQ_DYNAMIC);
 
 	arc_ksp = kstat_create("zfs", 0, "arcstats", "misc", KSTAT_TYPE_NAMED,
 	    sizeof (arc_stats) / sizeof (kstat_named_t), KSTAT_FLAG_VIRTUAL);
@@ -7996,6 +8036,8 @@ arc_init(void)
 		kstat_install(arc_ksp);
 	}
 
+	arc_state_evict_markers =
+	    arc_state_alloc_markers(arc_state_evict_marker_count);
 	arc_evict_zthr = zthr_create("arc_evict",
 	    arc_evict_cb_check, arc_evict_cb, NULL, defclsyspri);
 	arc_reap_zthr = zthr_create_timer("arc_reap",
@@ -8075,6 +8117,8 @@ arc_fini(void)
 
 	(void) zthr_cancel(arc_evict_zthr);
 	(void) zthr_cancel(arc_reap_zthr);
+	arc_state_free_markers(arc_state_evict_markers,
+	    arc_state_evict_marker_count);
 
 	mutex_destroy(&arc_evict_lock);
 	list_destroy(&arc_evict_waiters);
@@ -9476,12 +9520,6 @@ l2arc_write_buffers(spa_t *spa, l2arc_dev_t *dev, uint64_t target_sz)
 				continue;
 			}
 
-			/*
-			 * We rely on the L1 portion of the header below, so
-			 * it's invalid for this header to have been evicted out
-			 * of the ghost cache, prior to being written out. The
-			 * ARC_FLAG_L2_WRITING bit ensures this won't happen.
-			 */
 			ASSERT(HDR_HAS_L1HDR(hdr));
 
 			ASSERT3U(HDR_GET_PSIZE(hdr), >, 0);
@@ -9505,12 +9543,6 @@ l2arc_write_buffers(spa_t *spa, l2arc_dev_t *dev, uint64_t target_sz)
 			 * ARC_FLAG_L2_WRITING bit ensures this won't happen.
 			 */
 			arc_hdr_set_flags(hdr, ARC_FLAG_L2_WRITING);
-			ASSERT(HDR_HAS_L1HDR(hdr));
-
-			ASSERT3U(HDR_GET_PSIZE(hdr), >, 0);
-			ASSERT(hdr->b_l1hdr.b_pabd != NULL ||
-			    HDR_HAS_RABD(hdr));
-			ASSERT3U(arc_hdr_size(hdr), >, 0);
 
 			/*
 			 * If this header has b_rabd, we can use this since it
@@ -9674,10 +9706,10 @@ l2arc_hdr_limit_reached(void)
  * This thread feeds the L2ARC at regular intervals.  This is the beating
  * heart of the L2ARC.
  */
-/* ARGSUSED */
 static void
 l2arc_feed_thread(void *unused)
 {
+	(void) unused;
 	callb_cpr_t cpr;
 	l2arc_dev_t *dev;
 	spa_t *spa;
@@ -11132,4 +11164,7 @@ ZFS_MODULE_PARAM(zfs_arc, zfs_arc_, eviction_pct, INT, ZMOD_RW,
 
 ZFS_MODULE_PARAM(zfs_arc, zfs_arc_, evict_batch_limit, INT, ZMOD_RW,
 	"The number of headers to evict per sublist before moving to the next");
+
+ZFS_MODULE_PARAM(zfs_arc, zfs_arc_, prune_task_threads, INT, ZMOD_RW,
+	"Number of arc_prune threads");
 /* END CSTYLED */
diff --git a/sys/contrib/openzfs/module/zfs/bpobj.c b/sys/contrib/openzfs/module/zfs/bpobj.c
index e75ba5cccde6..68f534c6b197 100644
--- a/sys/contrib/openzfs/module/zfs/bpobj.c
+++ b/sys/contrib/openzfs/module/zfs/bpobj.c
@@ -860,10 +860,10 @@ struct space_range_arg {
 	uint64_t uncomp;
 };
 
-/* ARGSUSED */
 static int
 space_range_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed, dmu_tx_t *tx)
 {
+	(void) bp_freed, (void) tx;
 	struct space_range_arg *sra = arg;
 
 	if (bp->blk_birth > sra->mintxg && bp->blk_birth <= sra->maxtxg) {
@@ -932,11 +932,11 @@ bpobj_space_range(bpobj_t *bpo, uint64_t mintxg, uint64_t maxtxg,
  * bpobj are designated as free or allocated that information is not preserved
  * in bplists.
  */
-/* ARGSUSED */
 int
 bplist_append_cb(void *arg, const blkptr_t *bp, boolean_t bp_freed,
     dmu_tx_t *tx)
 {
+	(void) bp_freed, (void) tx;
 	bplist_t *bpl = arg;
 	bplist_append(bpl, bp);
 	return (0);
diff --git a/sys/contrib/openzfs/module/zfs/bptree.c b/sys/contrib/openzfs/module/zfs/bptree.c
index 1827a3c4e326..4e9a4825e262 100644
--- a/sys/contrib/openzfs/module/zfs/bptree.c
+++ b/sys/contrib/openzfs/module/zfs/bptree.c
@@ -147,11 +147,11 @@ bptree_add(objset_t *os, uint64_t obj, blkptr_t *bp, uint64_t birth_txg,
 	dmu_buf_rele(db, FTAG);
 }
 
-/* ARGSUSED */
 static int
 bptree_visit_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) zilog, (void) dnp;
 	int err;
 	struct bptree_args *ba = arg;
 
diff --git a/sys/contrib/openzfs/module/zfs/dbuf.c b/sys/contrib/openzfs/module/zfs/dbuf.c
index 1a298deb1822..96dcb2564754 100644
--- a/sys/contrib/openzfs/module/zfs/dbuf.c
+++ b/sys/contrib/openzfs/module/zfs/dbuf.c
@@ -55,7 +55,7 @@
 #include <sys/wmsum.h>
 #include <sys/vdev_impl.h>
 
-kstat_t *dbuf_ksp;
+static kstat_t *dbuf_ksp;
 
 typedef struct dbuf_stats {
 	/*
@@ -225,12 +225,12 @@ typedef struct dbuf_cache {
 dbuf_cache_t dbuf_caches[DB_CACHE_MAX];
 
 /* Size limits for the caches */
-unsigned long dbuf_cache_max_bytes = ULONG_MAX;
-unsigned long dbuf_metadata_cache_max_bytes = ULONG_MAX;
+static unsigned long dbuf_cache_max_bytes = ULONG_MAX;
+static unsigned long dbuf_metadata_cache_max_bytes = ULONG_MAX;
 
 /* Set the default sizes of the caches to log2 fraction of arc size */
-int dbuf_cache_shift = 5;
-int dbuf_metadata_cache_shift = 6;
+static int dbuf_cache_shift = 5;
+static int dbuf_metadata_cache_shift = 6;
 
 static unsigned long dbuf_cache_target_bytes(void);
 static unsigned long dbuf_metadata_cache_target_bytes(void);
@@ -277,13 +277,13 @@ static unsigned long dbuf_metadata_cache_target_bytes(void);
 /*
  * The percentage above and below the maximum cache size.
  */
-uint_t dbuf_cache_hiwater_pct = 10;
-uint_t dbuf_cache_lowater_pct = 10;
+static uint_t dbuf_cache_hiwater_pct = 10;
+static uint_t dbuf_cache_lowater_pct = 10;
 
-/* ARGSUSED */
 static int
 dbuf_cons(void *vdb, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	dmu_buf_impl_t *db = vdb;
 	bzero(db, sizeof (dmu_buf_impl_t));
 
@@ -296,10 +296,10 @@ dbuf_cons(void *vdb, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 dbuf_dest(void *vdb, void *unused)
 {
+	(void) unused;
 	dmu_buf_impl_t *db = vdb;
 	mutex_destroy(&db->db_mtx);
 	rw_destroy(&db->db_rwlock);
@@ -783,10 +783,10 @@ dbuf_evict_one(void)
  * of the dbuf cache is at or below the maximum size. Once the dbuf is aged
  * out of the cache it is destroyed and becomes eligible for arc eviction.
  */
-/* ARGSUSED */
 static void
 dbuf_evict_thread(void *unused)
 {
+	(void) unused;
 	callb_cpr_t cpr;
 
 	CALLB_CPR_INIT(&cpr, &dbuf_evict_lock, callb_generic_cpr, FTAG);
@@ -1339,6 +1339,7 @@ static void
 dbuf_read_done(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
     arc_buf_t *buf, void *vdb)
 {
+	(void) zb, (void) bp;
 	dmu_buf_impl_t *db = vdb;
 
 	mutex_enter(&db->db_mtx);
@@ -1432,7 +1433,7 @@ dbuf_handle_indirect_hole(dmu_buf_impl_t *db, dnode_t *dn)
  * was taken, ENOENT if no action was taken.
  */
 static int
-dbuf_read_hole(dmu_buf_impl_t *db, dnode_t *dn, uint32_t flags)
+dbuf_read_hole(dmu_buf_impl_t *db, dnode_t *dn)
 {
 	ASSERT(MUTEX_HELD(&db->db_mtx));
 
@@ -1548,7 +1549,7 @@ dbuf_read_impl(dmu_buf_impl_t *db, zio_t *zio, uint32_t flags,
 		goto early_unlock;
 	}
 
-	err = dbuf_read_hole(db, dn, flags);
+	err = dbuf_read_hole(db, dn);
 	if (err == 0)
 		goto early_unlock;
 
@@ -2678,10 +2679,10 @@ dbuf_override_impl(dmu_buf_impl_t *db, const blkptr_t *bp, dmu_tx_t *tx)
 	dl->dr_overridden_by.blk_birth = dr->dr_txg;
 }
 
-/* ARGSUSED */
 void
 dmu_buf_fill_done(dmu_buf_t *dbuf, dmu_tx_t *tx)
 {
+	(void) tx;
 	dmu_buf_impl_t *db = (dmu_buf_impl_t *)dbuf;
 	dbuf_states_t old_state;
 	mutex_enter(&db->db_mtx);
@@ -3198,6 +3199,7 @@ static void
 dbuf_issue_final_prefetch_done(zio_t *zio, const zbookmark_phys_t *zb,
     const blkptr_t *iobp, arc_buf_t *abuf, void *private)
 {
+	(void) zio, (void) zb, (void) iobp;
 	dbuf_prefetch_arg_t *dpa = private;
 
 	dbuf_prefetch_fini(dpa, B_TRUE);
@@ -3246,6 +3248,7 @@ static void
 dbuf_prefetch_indirect_done(zio_t *zio, const zbookmark_phys_t *zb,
     const blkptr_t *iobp, arc_buf_t *abuf, void *private)
 {
+	(void) zb, (void) iobp;
 	dbuf_prefetch_arg_t *dpa = private;
 
 	ASSERT3S(dpa->dpa_zb.zb_level, <, dpa->dpa_curlevel);
@@ -4512,10 +4515,10 @@ dbuf_sync_list(list_t *list, int level, dmu_tx_t *tx)
 	}
 }
 
-/* ARGSUSED */
 static void
 dbuf_write_ready(zio_t *zio, arc_buf_t *buf, void *vdb)
 {
+	(void) buf;
 	dmu_buf_impl_t *db = vdb;
 	dnode_t *dn;
 	blkptr_t *bp = zio->io_bp;
@@ -4603,7 +4606,6 @@ dbuf_write_ready(zio_t *zio, arc_buf_t *buf, void *vdb)
 	dmu_buf_unlock_parent(db, dblt, FTAG);
 }
 
-/* ARGSUSED */
 /*
  * This function gets called just prior to running through the compression
  * stage of the zio pipeline. If we're an indirect block comprised of only
@@ -4614,6 +4616,7 @@ dbuf_write_ready(zio_t *zio, arc_buf_t *buf, void *vdb)
 static void
 dbuf_write_children_ready(zio_t *zio, arc_buf_t *buf, void *vdb)
 {
+	(void) zio, (void) buf;
 	dmu_buf_impl_t *db = vdb;
 	dnode_t *dn;
 	blkptr_t *bp;
@@ -4657,10 +4660,10 @@ dbuf_write_children_ready(zio_t *zio, arc_buf_t *buf, void *vdb)
  * so this callback allows us to retire dirty space gradually, as the physical
  * i/os complete.
  */
-/* ARGSUSED */
 static void
 dbuf_write_physdone(zio_t *zio, arc_buf_t *buf, void *arg)
 {
+	(void) buf;
 	dmu_buf_impl_t *db = arg;
 	objset_t *os = db->db_objset;
 	dsl_pool_t *dp = dmu_objset_pool(os);
@@ -4679,10 +4682,10 @@ dbuf_write_physdone(zio_t *zio, arc_buf_t *buf, void *arg)
 	dsl_pool_undirty_space(dp, delta, zio->io_txg);
 }
 
-/* ARGSUSED */
 static void
 dbuf_write_done(zio_t *zio, arc_buf_t *buf, void *vdb)
 {
+	(void) buf;
 	dmu_buf_impl_t *db = vdb;
 	blkptr_t *bp_orig = &zio->io_bp_orig;
 	blkptr_t *bp = db->db_blkptr;
diff --git a/sys/contrib/openzfs/module/zfs/ddt_zap.c b/sys/contrib/openzfs/module/zfs/ddt_zap.c
index c5c9eda0b2d0..d0127f22e5ff 100644
--- a/sys/contrib/openzfs/module/zfs/ddt_zap.c
+++ b/sys/contrib/openzfs/module/zfs/ddt_zap.c
@@ -31,8 +31,8 @@
 #include <sys/zap.h>
 #include <sys/dmu_tx.h>
 
-int ddt_zap_leaf_blockshift = 12;
-int ddt_zap_indirect_blockshift = 12;
+static const int ddt_zap_leaf_blockshift = 12;
+static const int ddt_zap_indirect_blockshift = 12;
 
 static int
 ddt_zap_create(objset_t *os, uint64_t *objectp, dmu_tx_t *tx, boolean_t prehash)
diff --git a/sys/contrib/openzfs/module/zfs/dmu.c b/sys/contrib/openzfs/module/zfs/dmu.c
index 5ce11e86dae2..d802ce557657 100644
--- a/sys/contrib/openzfs/module/zfs/dmu.c
+++ b/sys/contrib/openzfs/module/zfs/dmu.c
@@ -62,7 +62,7 @@
 /*
  * Enable/disable nopwrite feature.
  */
-int zfs_nopwrite_enabled = 1;
+static int zfs_nopwrite_enabled = 1;
 
 /*
  * Tunable to control percentage of dirtied L1 blocks from frees allowed into
@@ -70,7 +70,7 @@ int zfs_nopwrite_enabled = 1;
  * will wait until the next TXG.
  * A value of zero will disable this throttle.
  */
-unsigned long zfs_per_txg_dirty_frees_percent = 5;
+static unsigned long zfs_per_txg_dirty_frees_percent = 5;
 
 /*
  * Enable/disable forcing txg sync when dirty checking for holes with lseek().
@@ -79,14 +79,14 @@ unsigned long zfs_per_txg_dirty_frees_percent = 5;
  * Disabling this option will result in holes never being reported in dirty
  * files which is always safe.
  */
-int zfs_dmu_offset_next_sync = 1;
+static int zfs_dmu_offset_next_sync = 1;
 
 /*
  * Limit the amount we can prefetch with one call to this amount.  This
  * helps to limit the amount of memory that can be used by prefetching.
  * Larger objects should be prefetched a bit at a time.
  */
-int dmu_prefetch_max = 8 * SPA_MAXBLOCKSIZE;
+static int dmu_prefetch_max = 8 * SPA_MAXBLOCKSIZE;
 
 const dmu_object_type_info_t dmu_ot[DMU_OT_NUMTYPES] = {
 	{DMU_BSWAP_UINT8,  TRUE,  FALSE, FALSE, "unallocated"		},
@@ -816,13 +816,14 @@ get_next_chunk(dnode_t *dn, uint64_t *start, uint64_t minimum, uint64_t *l1blks)
  * otherwise return false.
  * Used below in dmu_free_long_range_impl() to enable abort when unmounting
  */
-/*ARGSUSED*/
 static boolean_t
 dmu_objset_zfs_unmounting(objset_t *os)
 {
 #ifdef _KERNEL
 	if (dmu_objset_type(os) == DMU_OST_ZFS)
 		return (zfs_get_vfs_flag_unmounted(os));
+#else
+	(void) os;
 #endif
 	return (B_FALSE);
 }
@@ -1504,10 +1505,10 @@ typedef struct {
 	dmu_tx_t		*dsa_tx;
 } dmu_sync_arg_t;
 
-/* ARGSUSED */
 static void
 dmu_sync_ready(zio_t *zio, arc_buf_t *buf, void *varg)
 {
+	(void) buf;
 	dmu_sync_arg_t *dsa = varg;
 	dmu_buf_t *db = dsa->dsa_zgd->zgd_db;
 	blkptr_t *bp = zio->io_bp;
@@ -1532,10 +1533,10 @@ dmu_sync_late_arrival_ready(zio_t *zio)
 	dmu_sync_ready(zio, NULL, zio->io_private);
 }
 
-/* ARGSUSED */
 static void
 dmu_sync_done(zio_t *zio, arc_buf_t *buf, void *varg)
 {
+	(void) buf;
 	dmu_sync_arg_t *dsa = varg;
 	dbuf_dirty_record_t *dr = dsa->dsa_dr;
 	dmu_buf_impl_t *db = dr->dr_dbuf;
@@ -1939,7 +1940,7 @@ dmu_object_set_compress(objset_t *os, uint64_t object, uint8_t compress,
  * When the "redundant_metadata" property is set to "most", only indirect
  * blocks of this level and higher will have an additional ditto block.
  */
-int zfs_redundant_metadata_most_ditto_level = 2;
+static const int zfs_redundant_metadata_most_ditto_level = 2;
 
 void
 dmu_write_policy(objset_t *os, dnode_t *dn, int level, int wp, zio_prop_t *zp)
@@ -2276,10 +2277,10 @@ byteswap_uint16_array(void *vbuf, size_t size)
 		buf[i] = BSWAP_16(buf[i]);
 }
 
-/* ARGSUSED */
 void
 byteswap_uint8_array(void *vbuf, size_t size)
 {
+	(void) vbuf, (void) size;
 }
 
 void
diff --git a/sys/contrib/openzfs/module/zfs/dmu_diff.c b/sys/contrib/openzfs/module/zfs/dmu_diff.c
index a573a2e1bd41..1382da267d8a 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_diff.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_diff.c
@@ -108,11 +108,11 @@ report_dnode(dmu_diffarg_t *da, uint64_t object, dnode_phys_t *dnp)
 	(((uint64_t)dnp->dn_datablkszsec) << (SPA_MINBLOCKSHIFT + \
 	(level) * (dnp->dn_indblkshift - SPA_BLKPTRSHIFT)))
 
-/* ARGSUSED */
 static int
 diff_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) zilog;
 	dmu_diffarg_t *da = arg;
 	int err = 0;
 
diff --git a/sys/contrib/openzfs/module/zfs/dmu_objset.c b/sys/contrib/openzfs/module/zfs/dmu_objset.c
index b30a9d619034..9a74fa9ce360 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_objset.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_objset.c
@@ -78,16 +78,16 @@ krwlock_t os_lock;
  * datasets.
  * Default is 4 times the number of leaf vdevs.
  */
-int dmu_find_threads = 0;
+static const int dmu_find_threads = 0;
 
 /*
  * Backfill lower metadnode objects after this many have been freed.
  * Backfilling negatively impacts object creation rates, so only do it
  * if there are enough holes to fill.
  */
-int dmu_rescan_dnode_threshold = 1 << DN_MAX_INDBLKSHIFT;
+static const int dmu_rescan_dnode_threshold = 1 << DN_MAX_INDBLKSHIFT;
 
-static char *upgrade_tag = "upgrade_tag";
+static const char *upgrade_tag = "upgrade_tag";
 
 static void dmu_objset_find_dp_cb(void *arg);
 
@@ -751,9 +751,9 @@ static int
 dmu_objset_own_impl(dsl_dataset_t *ds, dmu_objset_type_t type,
     boolean_t readonly, boolean_t decrypt, void *tag, objset_t **osp)
 {
-	int err;
+	(void) tag;
 
-	err = dmu_objset_from_ds(ds, osp);
+	int err = dmu_objset_from_ds(ds, osp);
 	if (err != 0) {
 		return (err);
 	} else if (type != DMU_OST_ANY && type != (*osp)->os_phys->os_type) {
@@ -1157,7 +1157,6 @@ typedef struct dmu_objset_create_arg {
 	dsl_crypto_params_t *doca_dcp;
 } dmu_objset_create_arg_t;
 
-/*ARGSUSED*/
 static int
 dmu_objset_create_check(void *arg, dmu_tx_t *tx)
 {
@@ -1353,7 +1352,6 @@ typedef struct dmu_objset_clone_arg {
 	proc_t *doca_proc;
 } dmu_objset_clone_arg_t;
 
-/*ARGSUSED*/
 static int
 dmu_objset_clone_check(void *arg, dmu_tx_t *tx)
 {
@@ -1565,10 +1563,10 @@ dmu_objset_sync_dnodes(multilist_sublist_t *list, dmu_tx_t *tx)
 	}
 }
 
-/* ARGSUSED */
 static void
 dmu_objset_write_ready(zio_t *zio, arc_buf_t *abuf, void *arg)
 {
+	(void) abuf;
 	blkptr_t *bp = zio->io_bp;
 	objset_t *os = arg;
 	dnode_phys_t *dnp = &os->os_phys->os_meta_dnode;
@@ -1596,10 +1594,10 @@ dmu_objset_write_ready(zio_t *zio, arc_buf_t *abuf, void *arg)
 		rrw_exit(&os->os_dsl_dataset->ds_bp_rwlock, FTAG);
 }
 
-/* ARGSUSED */
 static void
 dmu_objset_write_done(zio_t *zio, arc_buf_t *abuf, void *arg)
 {
+	(void) abuf;
 	blkptr_t *bp = zio->io_bp;
 	blkptr_t *bp_orig = &zio->io_bp_orig;
 	objset_t *os = arg;
diff --git a/sys/contrib/openzfs/module/zfs/dmu_recv.c b/sys/contrib/openzfs/module/zfs/dmu_recv.c
index 0ec46bdb4f47..f132219c9e1d 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_recv.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_recv.c
@@ -64,12 +64,12 @@
 #endif
 #include <sys/zfs_file.h>
 
-int zfs_recv_queue_length = SPA_MAXBLOCKSIZE;
-int zfs_recv_queue_ff = 20;
-int zfs_recv_write_batch_size = 1024 * 1024;
+static int zfs_recv_queue_length = SPA_MAXBLOCKSIZE;
+static int zfs_recv_queue_ff = 20;
+static int zfs_recv_write_batch_size = 1024 * 1024;
 
-static char *dmu_recv_tag = "dmu_recv_tag";
-const char *recv_clone_name = "%recv";
+static void *const dmu_recv_tag = "dmu_recv_tag";
+const char *const recv_clone_name = "%recv";
 
 static int receive_read_payload_and_next_header(dmu_recv_cookie_t *ra, int len,
     void *buf);
diff --git a/sys/contrib/openzfs/module/zfs/dmu_redact.c b/sys/contrib/openzfs/module/zfs/dmu_redact.c
index fdbdf7d6e868..46f4982894b5 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_redact.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_redact.c
@@ -40,13 +40,14 @@
  * This controls the number of entries in the buffer the redaction_list_update
  * synctask uses to buffer writes to the redaction list.
  */
-int redact_sync_bufsize = 1024;
+static const int redact_sync_bufsize = 1024;
 
 /*
  * Controls how often to update the redaction list when creating a redaction
  * list.
  */
-uint64_t redaction_list_update_interval_ns = 1000 * 1000 * 1000ULL; /* NS */
+static const uint64_t redaction_list_update_interval_ns =
+    1000 * 1000 * 1000ULL; /* 1s */
 
 /*
  * This tunable controls the length of the queues that zfs redact worker threads
@@ -56,7 +57,7 @@ uint64_t redaction_list_update_interval_ns = 1000 * 1000 * 1000ULL; /* NS */
  * available IO resources, or the queues are consuming too much memory, this
  * variable may need to be decreased.
  */
-int zfs_redact_queue_length = 1024 * 1024;
+static const int zfs_redact_queue_length = 1024 * 1024;
 
 /*
  * These tunables control the fill fraction of the queues by zfs redact. The
@@ -65,7 +66,7 @@ int zfs_redact_queue_length = 1024 * 1024;
  * should be tuned down.  If the queues empty before the signalled thread can
  * catch up, then these should be tuned up.
  */
-uint64_t zfs_redact_queue_ff = 20;
+static const uint64_t zfs_redact_queue_ff = 20;
 
 struct redact_record {
 	bqueue_node_t		ln;
@@ -249,11 +250,11 @@ zfs_get_deleteq(objset_t *os)
  * Third, if there is a deleted object, we need to create a redaction record for
  * all of the blocks in that object.
  */
-/*ARGSUSED*/
 static int
 redact_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const struct dnode_phys *dnp, void *arg)
 {
+	(void) spa, (void) zilog;
 	struct redact_thread_arg *rta = arg;
 	struct redact_record *record;
 
diff --git a/sys/contrib/openzfs/module/zfs/dmu_send.c b/sys/contrib/openzfs/module/zfs/dmu_send.c
index 2f2fd4c3d6c8..fbb1947a5dd3 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_send.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_send.c
@@ -67,7 +67,7 @@
 #endif
 
 /* Set this tunable to TRUE to replace corrupt data with 0x2f5baddb10c */
-int zfs_send_corrupt_data = B_FALSE;
+static int zfs_send_corrupt_data = B_FALSE;
 /*
  * This tunable controls the amount of data (measured in bytes) that will be
  * prefetched by zfs send.  If the main thread is blocking on reads that haven't
@@ -75,7 +75,7 @@ int zfs_send_corrupt_data = B_FALSE;
  * thread is issuing new reads because the prefetches have fallen out of the
  * cache, this may need to be decreased.
  */
-int zfs_send_queue_length = SPA_MAXBLOCKSIZE;
+static int zfs_send_queue_length = SPA_MAXBLOCKSIZE;
 /*
  * This tunable controls the length of the queues that zfs send worker threads
  * use to communicate.  If the send_main_thread is blocking on these queues,
@@ -83,7 +83,7 @@ int zfs_send_queue_length = SPA_MAXBLOCKSIZE;
  * at the start of a send as these threads consume all the available IO
  * resources, this variable may need to be decreased.
  */
-int zfs_send_no_prefetch_queue_length = 1024 * 1024;
+static int zfs_send_no_prefetch_queue_length = 1024 * 1024;
 /*
  * These tunables control the fill fraction of the queues by zfs send.  The fill
  * fraction controls the frequency with which threads have to be cv_signaled.
@@ -91,19 +91,19 @@ int zfs_send_no_prefetch_queue_length = 1024 * 1024;
  * down.  If the queues empty before the signalled thread can catch up, then
  * these should be tuned up.
  */
-int zfs_send_queue_ff = 20;
-int zfs_send_no_prefetch_queue_ff = 20;
+static int zfs_send_queue_ff = 20;
+static int zfs_send_no_prefetch_queue_ff = 20;
 
 /*
  * Use this to override the recordsize calculation for fast zfs send estimates.
  */
-int zfs_override_estimate_recordsize = 0;
+static int zfs_override_estimate_recordsize = 0;
 
 /* Set this tunable to FALSE to disable setting of DRR_FLAG_FREERECORDS */
-int zfs_send_set_freerecords_bit = B_TRUE;
+static const boolean_t zfs_send_set_freerecords_bit = B_TRUE;
 
 /* Set this tunable to FALSE is disable sending unmodified spill blocks. */
-int zfs_send_unmodified_spill_blocks = B_TRUE;
+static int zfs_send_unmodified_spill_blocks = B_TRUE;
 
 static inline boolean_t
 overflow_multiply(uint64_t a, uint64_t b, uint64_t *c)
@@ -1097,11 +1097,11 @@ range_alloc(enum type type, uint64_t object, uint64_t start_blkid,
  * This is the callback function to traverse_dataset that acts as a worker
  * thread for dmu_send_impl.
  */
-/*ARGSUSED*/
 static int
 send_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const struct dnode_phys *dnp, void *arg)
 {
+	(void) zilog;
 	struct send_thread_arg *sta = arg;
 	struct send_range *record;
 
@@ -2155,6 +2155,7 @@ setup_resume_points(struct dmu_send_params *dspp,
     struct send_merge_thread_arg *smt_arg, boolean_t resuming, objset_t *os,
     redaction_list_t *redact_rl, nvlist_t *nvl)
 {
+	(void) smt_arg;
 	dsl_dataset_t *to_ds = dspp->to_ds;
 	int err = 0;
 
diff --git a/sys/contrib/openzfs/module/zfs/dmu_traverse.c b/sys/contrib/openzfs/module/zfs/dmu_traverse.c
index 862c0bf404ad..3763c17de820 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_traverse.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_traverse.c
@@ -39,9 +39,9 @@
 #include <sys/callb.h>
 #include <sys/zfeature.h>
 
-int32_t zfs_pd_bytes_max = 50 * 1024 * 1024;	/* 50MB */
-int32_t send_holes_without_birth_time = 1;
-int32_t zfs_traverse_indirect_prefetch_limit = 32;
+static int32_t zfs_pd_bytes_max = 50 * 1024 * 1024;	/* 50MB */
+static int32_t send_holes_without_birth_time = 1;
+static int32_t zfs_traverse_indirect_prefetch_limit = 32;
 
 typedef struct prefetch_data {
 	kmutex_t pd_mtx;
@@ -560,11 +560,11 @@ traverse_dnode(traverse_data_t *td, const blkptr_t *bp, const dnode_phys_t *dnp,
 	return (err);
 }
 
-/* ARGSUSED */
 static int
 traverse_prefetcher(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) zilog, (void) dnp;
 	prefetch_data_t *pfd = arg;
 	int zio_flags = ZIO_FLAG_CANFAIL | ZIO_FLAG_SPECULATIVE;
 	arc_flags_t aflags = ARC_FLAG_NOWAIT | ARC_FLAG_PREFETCH |
diff --git a/sys/contrib/openzfs/module/zfs/dmu_tx.c b/sys/contrib/openzfs/module/zfs/dmu_tx.c
index 5fa516866668..b4735bb7ff54 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_tx.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_tx.c
@@ -683,8 +683,7 @@ dmu_tx_dirty_buf(dmu_tx_t *tx, dmu_buf_impl_t *db)
  * If we can't do 10 iops, something is wrong.  Let us go ahead
  * and hit zfs_dirty_data_max.
  */
-hrtime_t zfs_delay_max_ns = 100 * MICROSEC; /* 100 milliseconds */
-int zfs_delay_resolution_ns = 100 * 1000; /* 100 microseconds */
+static const hrtime_t zfs_delay_max_ns = 100 * MICROSEC; /* 100 milliseconds */
 
 /*
  * We delay transactions when we've determined that the backend storage
diff --git a/sys/contrib/openzfs/module/zfs/dmu_zfetch.c b/sys/contrib/openzfs/module/zfs/dmu_zfetch.c
index 043344a1375f..fdf0a1759716 100644
--- a/sys/contrib/openzfs/module/zfs/dmu_zfetch.c
+++ b/sys/contrib/openzfs/module/zfs/dmu_zfetch.c
@@ -43,12 +43,12 @@
  * so it can't hurt performance.
  */
 
-int zfs_prefetch_disable = B_FALSE;
+static int zfs_prefetch_disable = B_FALSE;
 
 /* max # of streams per zfetch */
-unsigned int	zfetch_max_streams = 8;
+static unsigned int	zfetch_max_streams = 8;
 /* min time before stream reclaim */
-unsigned int	zfetch_min_sec_reap = 2;
+static unsigned int	zfetch_min_sec_reap = 2;
 /* max bytes to prefetch per stream (default 8MB) */
 unsigned int	zfetch_max_distance = 8 * 1024 * 1024;
 /* max bytes to prefetch indirects for per stream (default 64MB) */
@@ -83,7 +83,7 @@ struct {
 	wmsum_add(&zfetch_sums.stat, val)
 
 
-kstat_t		*zfetch_ksp;
+static kstat_t		*zfetch_ksp;
 
 static int
 zfetch_kstats_update(kstat_t *ksp, int rw)
@@ -260,6 +260,7 @@ dmu_zfetch_stream_create(zfetch_t *zf, uint64_t blkid)
 static void
 dmu_zfetch_stream_done(void *arg, boolean_t io_issued)
 {
+	(void) io_issued;
 	zstream_t *zs = arg;
 
 	if (zfs_refcount_remove(&zs->zs_refs, NULL) == 0)
diff --git a/sys/contrib/openzfs/module/zfs/dnode.c b/sys/contrib/openzfs/module/zfs/dnode.c
index db1a5d71df3c..7b53b7cd0534 100644
--- a/sys/contrib/openzfs/module/zfs/dnode.c
+++ b/sys/contrib/openzfs/module/zfs/dnode.c
@@ -108,12 +108,11 @@ dbuf_compare(const void *x1, const void *x2)
 	return (TREE_PCMP(d1, d2));
 }
 
-/* ARGSUSED */
 static int
 dnode_cons(void *arg, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	dnode_t *dn = arg;
-	int i;
 
 	rw_init(&dn->dn_struct_rwlock, NULL, RW_NOLOCKDEP, NULL);
 	mutex_init(&dn->dn_mtx, NULL, MUTEX_DEFAULT, NULL);
@@ -139,7 +138,7 @@ dnode_cons(void *arg, void *unused, int kmflag)
 	bzero(&dn->dn_next_blksz[0], sizeof (dn->dn_next_blksz));
 	bzero(&dn->dn_next_maxblkid[0], sizeof (dn->dn_next_maxblkid));
 
-	for (i = 0; i < TXG_SIZE; i++) {
+	for (int i = 0; i < TXG_SIZE; i++) {
 		multilist_link_init(&dn->dn_dirty_link[i]);
 		dn->dn_free_ranges[i] = NULL;
 		list_create(&dn->dn_dirty_records[i],
@@ -174,11 +173,10 @@ dnode_cons(void *arg, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 dnode_dest(void *arg, void *unused)
 {
-	int i;
+	(void) unused;
 	dnode_t *dn = arg;
 
 	rw_destroy(&dn->dn_struct_rwlock);
@@ -190,7 +188,7 @@ dnode_dest(void *arg, void *unused)
 	zfs_refcount_destroy(&dn->dn_tx_holds);
 	ASSERT(!list_link_active(&dn->dn_link));
 
-	for (i = 0; i < TXG_SIZE; i++) {
+	for (int i = 0; i < TXG_SIZE; i++) {
 		ASSERT(!multilist_link_active(&dn->dn_dirty_link[i]));
 		ASSERT3P(dn->dn_free_ranges[i], ==, NULL);
 		list_destroy(&dn->dn_dirty_records[i]);
@@ -889,7 +887,6 @@ dnode_move_impl(dnode_t *odn, dnode_t *ndn)
 	odn->dn_moved = (uint8_t)-1;
 }
 
-/*ARGSUSED*/
 static kmem_cbrc_t
 dnode_move(void *buf, void *newbuf, size_t size, void *arg)
 {
@@ -1621,7 +1618,9 @@ dnode_rele_and_unlock(dnode_t *dn, void *tag, boolean_t evicting)
 	 * other direct or indirect hold on the dnode must first drop the dnode
 	 * handle.
 	 */
+#ifdef ZFS_DEBUG
 	ASSERT(refs > 0 || dnh->dnh_zrlock.zr_owner != curthread);
+#endif
 
 	/* NOTE: the DNODE_DNODE does not have a dn_dbuf */
 	if (refs == 0 && db != NULL) {
diff --git a/sys/contrib/openzfs/module/zfs/dnode_sync.c b/sys/contrib/openzfs/module/zfs/dnode_sync.c
index dd37e3af7ed5..f574130e5049 100644
--- a/sys/contrib/openzfs/module/zfs/dnode_sync.c
+++ b/sys/contrib/openzfs/module/zfs/dnode_sync.c
@@ -655,8 +655,13 @@ dnode_sync(dnode_t *dn, dmu_tx_t *tx)
 			    DNODE_FLAG_USEROBJUSED_ACCOUNTED;
 		mutex_exit(&dn->dn_mtx);
 		dmu_objset_userquota_get_ids(dn, B_FALSE, tx);
-	} else {
-		/* Once we account for it, we should always account for it */
+	} else if (!(os->os_encrypted && dmu_objset_is_receiving(os))) {
+		/*
+		 * Once we account for it, we should always account for it,
+		 * except for the case of a raw receive. We will not be able
+		 * to account for it until the receiving dataset has been
+		 * mounted.
+		 */
 		ASSERT(!(dn->dn_phys->dn_flags &
 		    DNODE_FLAG_USERUSED_ACCOUNTED));
 		ASSERT(!(dn->dn_phys->dn_flags &
diff --git a/sys/contrib/openzfs/module/zfs/dsl_bookmark.c b/sys/contrib/openzfs/module/zfs/dsl_bookmark.c
index bead7da2237f..b8e3523ffc2d 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_bookmark.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_bookmark.c
@@ -1203,7 +1203,6 @@ dsl_redaction_list_long_rele(redaction_list_t *rl, void *tag)
 	(void) zfs_refcount_remove(&rl->rl_longholds, tag);
 }
 
-/* ARGSUSED */
 static void
 redaction_list_evict_sync(void *rlu)
 {
@@ -1470,10 +1469,11 @@ dsl_bookmark_next_changed(dsl_dataset_t *head, dsl_dataset_t *origin,
  * Adjust the FBN of any bookmarks that reference this block, whose "next"
  * is the head dataset.
  */
-/* ARGSUSED */
 void
 dsl_bookmark_block_killed(dsl_dataset_t *ds, const blkptr_t *bp, dmu_tx_t *tx)
 {
+	(void) tx;
+
 	/*
 	 * Iterate over bookmarks whose "next" is the head dataset.
 	 */
diff --git a/sys/contrib/openzfs/module/zfs/dsl_crypt.c b/sys/contrib/openzfs/module/zfs/dsl_crypt.c
index 26d4c2fe7e33..1ea184de338c 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_crypt.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_crypt.c
@@ -2007,14 +2007,6 @@ dsl_crypto_recv_raw_objset_check(dsl_dataset_t *ds, dsl_dataset_t *fromds,
 	if (ret != 0)
 		return (ret);
 
-	/*
-	 * Useraccounting is not portable and must be done with the keys loaded.
-	 * Therefore, whenever we do any kind of receive the useraccounting
-	 * must not be present.
-	 */
-	ASSERT0(os->os_flags & OBJSET_FLAG_USERACCOUNTING_COMPLETE);
-	ASSERT0(os->os_flags & OBJSET_FLAG_USEROBJACCOUNTING_COMPLETE);
-
 	mdn = DMU_META_DNODE(os);
 
 	/*
@@ -2106,6 +2098,7 @@ dsl_crypto_recv_raw_objset_sync(dsl_dataset_t *ds, dmu_objset_type_t ostype,
 	arc_release(os->os_phys_buf, &os->os_phys_buf);
 	bcopy(portable_mac, os->os_phys->os_portable_mac, ZIO_OBJSET_MAC_LEN);
 	bzero(os->os_phys->os_local_mac, ZIO_OBJSET_MAC_LEN);
+	os->os_flags &= ~OBJSET_FLAG_USERACCOUNTING_COMPLETE;
 	os->os_next_write_raw[tx->tx_txg & TXG_MASK] = B_TRUE;
 
 	/* set metadnode compression and checksum */
diff --git a/sys/contrib/openzfs/module/zfs/dsl_dataset.c b/sys/contrib/openzfs/module/zfs/dsl_dataset.c
index f99964511aa6..115f3df5d539 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_dataset.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_dataset.c
@@ -79,7 +79,7 @@
  * of this setting.
  */
 int zfs_max_recordsize = 1 * 1024 * 1024;
-int zfs_allow_redacted_dataset_mount = 0;
+static int zfs_allow_redacted_dataset_mount = 0;
 
 #define	SWITCH64(x, y) \
 	{ \
@@ -896,14 +896,14 @@ dsl_dataset_own(dsl_pool_t *dp, const char *name, ds_hold_flags_t flags,
  * and accessed.
  */
 void
-dsl_dataset_long_hold(dsl_dataset_t *ds, void *tag)
+dsl_dataset_long_hold(dsl_dataset_t *ds, const void *tag)
 {
 	ASSERT(dsl_pool_config_held(ds->ds_dir->dd_pool));
 	(void) zfs_refcount_add(&ds->ds_longholds, tag);
 }
 
 void
-dsl_dataset_long_rele(dsl_dataset_t *ds, void *tag)
+dsl_dataset_long_rele(dsl_dataset_t *ds, const void *tag)
 {
 	(void) zfs_refcount_remove(&ds->ds_longholds, tag);
 }
@@ -2943,11 +2943,11 @@ typedef struct dsl_dataset_rename_snapshot_arg {
 	dmu_tx_t *ddrsa_tx;
 } dsl_dataset_rename_snapshot_arg_t;
 
-/* ARGSUSED */
 static int
 dsl_dataset_rename_snapshot_check_impl(dsl_pool_t *dp,
     dsl_dataset_t *hds, void *arg)
 {
+	(void) dp;
 	dsl_dataset_rename_snapshot_arg_t *ddrsa = arg;
 	int error;
 	uint64_t val;
@@ -4305,7 +4305,6 @@ typedef struct dsl_dataset_set_qr_arg {
 } dsl_dataset_set_qr_arg_t;
 
 
-/* ARGSUSED */
 static int
 dsl_dataset_set_refquota_check(void *arg, dmu_tx_t *tx)
 {
@@ -4512,7 +4511,6 @@ typedef struct dsl_dataset_set_compression_arg {
 	uint64_t ddsca_value;
 } dsl_dataset_set_compression_arg_t;
 
-/* ARGSUSED */
 static int
 dsl_dataset_set_compression_check(void *arg, dmu_tx_t *tx)
 {
diff --git a/sys/contrib/openzfs/module/zfs/dsl_destroy.c b/sys/contrib/openzfs/module/zfs/dsl_destroy.c
index a2748197f29d..b32929b3320c 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_destroy.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_destroy.c
@@ -699,11 +699,11 @@ struct killarg {
 	dmu_tx_t *tx;
 };
 
-/* ARGSUSED */
 static int
 kill_blkptr(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) spa, (void) dnp;
 	struct killarg *ka = arg;
 	dmu_tx_t *tx = ka->tx;
 
@@ -1246,10 +1246,10 @@ dsl_destroy_head(const char *name)
  * inconsistent datasets, even if we encounter an error trying to
  * process one of them.
  */
-/* ARGSUSED */
 int
 dsl_destroy_inconsistent(const char *dsname, void *arg)
 {
+	(void) arg;
 	objset_t *os;
 
 	if (dmu_objset_hold(dsname, FTAG, &os) == 0) {
diff --git a/sys/contrib/openzfs/module/zfs/dsl_dir.c b/sys/contrib/openzfs/module/zfs/dsl_dir.c
index 84caace4dbab..bd5e0c2f627c 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_dir.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_dir.c
@@ -764,6 +764,8 @@ dsl_enforce_ds_ss_limits(dsl_dir_t *dd, zfs_prop_t prop,
 	 */
 	if (secpolicy_zfs_proc(cr, proc) == 0)
 		return (ENFORCE_NEVER);
+#else
+	(void) proc;
 #endif
 
 	if ((obj = dsl_dir_phys(dd)->dd_head_dataset_obj) == 0)
@@ -1896,10 +1898,10 @@ typedef struct dsl_valid_rename_arg {
 	int nest_delta;
 } dsl_valid_rename_arg_t;
 
-/* ARGSUSED */
 static int
 dsl_valid_rename(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)
 {
+	(void) dp;
 	dsl_valid_rename_arg_t *dvra = arg;
 	char namebuf[ZFS_MAX_DATASET_NAME_LEN];
 
@@ -2396,6 +2398,7 @@ dsl_dir_activity_in_progress(dsl_dir_t *dd, dsl_dataset_t *ds,
 		 * The delete queue is ZPL specific, and libzpool doesn't have
 		 * it. It doesn't make sense to wait for it.
 		 */
+		(void) ds;
 		*in_progress = B_FALSE;
 		break;
 #endif
diff --git a/sys/contrib/openzfs/module/zfs/dsl_pool.c b/sys/contrib/openzfs/module/zfs/dsl_pool.c
index 1350f1329564..ef7e9d2d248a 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_pool.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_pool.c
@@ -117,7 +117,7 @@ unsigned long zfs_wrlog_data_max = 0;
  * zfs_dirty_data_max), push out a txg.  This should be less than
  * zfs_vdev_async_write_active_min_dirty_percent.
  */
-int zfs_dirty_data_sync_percent = 20;
+static int zfs_dirty_data_sync_percent = 20;
 
 /*
  * Once there is this amount of dirty data, the dmu_tx_delay() will kick in
@@ -144,7 +144,7 @@ unsigned long zfs_delay_scale = 1000 * 1000 * 1000 / 2000;
 /*
  * This determines the number of threads used by the dp_sync_taskq.
  */
-int zfs_sync_taskq_batch_pct = 75;
+static int zfs_sync_taskq_batch_pct = 75;
 
 /*
  * These tunables determine the behavior of how zil_itxg_clean() is
@@ -172,9 +172,9 @@ int zfs_sync_taskq_batch_pct = 75;
  * Additionally, the number of threads used by the taskq can be
  * configured via the "zfs_zil_clean_taskq_nthr_pct" tunable.
  */
-int zfs_zil_clean_taskq_nthr_pct = 100;
-int zfs_zil_clean_taskq_minalloc = 1024;
-int zfs_zil_clean_taskq_maxalloc = 1024 * 1024;
+static int zfs_zil_clean_taskq_nthr_pct = 100;
+static int zfs_zil_clean_taskq_minalloc = 1024;
+static int zfs_zil_clean_taskq_maxalloc = 1024 * 1024;
 
 int
 dsl_pool_open_special_dir(dsl_pool_t *dp, const char *name, dsl_dir_t **ddp)
@@ -476,8 +476,8 @@ dsl_pool_destroy_obsolete_bpobj(dsl_pool_t *dp, dmu_tx_t *tx)
 }
 
 dsl_pool_t *
-dsl_pool_create(spa_t *spa, nvlist_t *zplprops, dsl_crypto_params_t *dcp,
-    uint64_t txg)
+dsl_pool_create(spa_t *spa, nvlist_t *zplprops __attribute__((unused)),
+    dsl_crypto_params_t *dcp, uint64_t txg)
 {
 	int err;
 	dsl_pool_t *dp = dsl_pool_open_impl(spa, txg);
@@ -664,6 +664,9 @@ dsl_early_sync_task_verify(dsl_pool_t *dp, uint64_t txg)
 
 	return (B_TRUE);
 }
+#else
+#define	dsl_early_sync_task_verify(dp, txg) \
+	((void) sizeof (dp), (void) sizeof (txg), B_TRUE)
 #endif
 
 void
diff --git a/sys/contrib/openzfs/module/zfs/dsl_prop.c b/sys/contrib/openzfs/module/zfs/dsl_prop.c
index dfa04d7681be..0089edf8683a 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_prop.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_prop.c
@@ -504,10 +504,10 @@ dsl_prop_hascb(dsl_dataset_t *ds)
 	return (!list_is_empty(&ds->ds_prop_cbs));
 }
 
-/* ARGSUSED */
 static int
 dsl_prop_notify_all_cb(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)
 {
+	(void) arg;
 	dsl_dir_t *dd = ds->ds_dir;
 	dsl_prop_record_t *pr;
 	dsl_prop_cb_record_t *cbr;
diff --git a/sys/contrib/openzfs/module/zfs/dsl_scan.c b/sys/contrib/openzfs/module/zfs/dsl_scan.c
index d25c067dfbc1..677d320eddba 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_scan.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_scan.c
@@ -136,7 +136,7 @@ extern int zfs_vdev_async_write_active_min_dirty_percent;
  * this value can be set to 1 to enable checking before scanning each
  * block.
  */
-int zfs_scan_strict_mem_lim = B_FALSE;
+static int zfs_scan_strict_mem_lim = B_FALSE;
 
 /*
  * Maximum number of parallelly executed bytes per leaf vdev. We attempt
@@ -146,41 +146,42 @@ int zfs_scan_strict_mem_lim = B_FALSE;
  * overload the drives with I/O, since that is protected by
  * zfs_vdev_scrub_max_active.
  */
-unsigned long zfs_scan_vdev_limit = 4 << 20;
+static unsigned long zfs_scan_vdev_limit = 4 << 20;
 
-int zfs_scan_issue_strategy = 0;
-int zfs_scan_legacy = B_FALSE; /* don't queue & sort zios, go direct */
-unsigned long zfs_scan_max_ext_gap = 2 << 20; /* in bytes */
+static int zfs_scan_issue_strategy = 0;
+static int zfs_scan_legacy = B_FALSE; /* don't queue & sort zios, go direct */
+static unsigned long zfs_scan_max_ext_gap = 2 << 20; /* in bytes */
 
 /*
  * fill_weight is non-tunable at runtime, so we copy it at module init from
  * zfs_scan_fill_weight. Runtime adjustments to zfs_scan_fill_weight would
  * break queue sorting.
  */
-int zfs_scan_fill_weight = 3;
+static int zfs_scan_fill_weight = 3;
 static uint64_t fill_weight;
 
 /* See dsl_scan_should_clear() for details on the memory limit tunables */
-uint64_t zfs_scan_mem_lim_min = 16 << 20;	/* bytes */
-uint64_t zfs_scan_mem_lim_soft_max = 128 << 20;	/* bytes */
-int zfs_scan_mem_lim_fact = 20;		/* fraction of physmem */
-int zfs_scan_mem_lim_soft_fact = 20;	/* fraction of mem lim above */
-
-int zfs_scrub_min_time_ms = 1000; /* min millisecs to scrub per txg */
-int zfs_obsolete_min_time_ms = 500; /* min millisecs to obsolete per txg */
-int zfs_free_min_time_ms = 1000; /* min millisecs to free per txg */
-int zfs_resilver_min_time_ms = 3000; /* min millisecs to resilver per txg */
-int zfs_scan_checkpoint_intval = 7200; /* in seconds */
+static const uint64_t zfs_scan_mem_lim_min = 16 << 20;	/* bytes */
+static const uint64_t zfs_scan_mem_lim_soft_max = 128 << 20;	/* bytes */
+static int zfs_scan_mem_lim_fact = 20;		/* fraction of physmem */
+static int zfs_scan_mem_lim_soft_fact = 20;	/* fraction of mem lim above */
+
+static int zfs_scrub_min_time_ms = 1000; /* min millis to scrub per txg */
+static int zfs_obsolete_min_time_ms = 500; /* min millis to obsolete per txg */
+static int zfs_free_min_time_ms = 1000; /* min millis to free per txg */
+static int zfs_resilver_min_time_ms = 3000; /* min millis to resilver per txg */
+static int zfs_scan_checkpoint_intval = 7200; /* in seconds */
 int zfs_scan_suspend_progress = 0; /* set to prevent scans from progressing */
-int zfs_no_scrub_io = B_FALSE; /* set to disable scrub i/o */
-int zfs_no_scrub_prefetch = B_FALSE; /* set to disable scrub prefetch */
-enum ddt_class zfs_scrub_ddt_class_max = DDT_CLASS_DUPLICATE;
+static int zfs_no_scrub_io = B_FALSE; /* set to disable scrub i/o */
+static int zfs_no_scrub_prefetch = B_FALSE; /* set to disable scrub prefetch */
+static const enum ddt_class zfs_scrub_ddt_class_max = DDT_CLASS_DUPLICATE;
 /* max number of blocks to free in a single TXG */
-unsigned long zfs_async_block_max_blocks = ULONG_MAX;
+static unsigned long zfs_async_block_max_blocks = ULONG_MAX;
 /* max number of dedup blocks to free in a single TXG */
-unsigned long zfs_max_async_dedup_frees = 100000;
+static unsigned long zfs_max_async_dedup_frees = 100000;
 
-int zfs_resilver_disable_defer = 0; /* set to disable resilver deferring */
+/* set to disable resilver deferring */
+static int zfs_resilver_disable_defer = B_FALSE;
 
 /*
  * We wait a few txgs after importing a pool to begin scanning so that
@@ -201,7 +202,7 @@ int zfs_resilver_disable_defer = 0; /* set to disable resilver deferring */
 /*
  * Enable/disable the processing of the free_bpobj object.
  */
-int zfs_free_bpobj_enabled = 1;
+static int zfs_free_bpobj_enabled = 1;
 
 /* the order has to match pool_scan_type */
 static scan_cb_t *scan_funcs[POOL_SCAN_FUNCS] = {
@@ -705,10 +706,10 @@ dsl_scan_sync_state(dsl_scan_t *scn, dmu_tx_t *tx, state_sync_type_t sync_type)
 	}
 }
 
-/* ARGSUSED */
 int
 dsl_scan_setup_check(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	dsl_scan_t *scn = dmu_tx_pool(tx)->dp_scan;
 	vdev_t *rvd = scn->scn_dp->dp_spa->spa_root_vdev;
 
@@ -859,7 +860,6 @@ dsl_scan(dsl_pool_t *dp, pool_scan_func_t func)
 	    dsl_scan_setup_sync, &func, 0, ZFS_SPACE_CHECK_EXTRA_RESERVED));
 }
 
-/* ARGSUSED */
 static void
 dsl_scan_done(dsl_scan_t *scn, boolean_t complete, dmu_tx_t *tx)
 {
@@ -1006,10 +1006,10 @@ dsl_scan_done(dsl_scan_t *scn, boolean_t complete, dmu_tx_t *tx)
 	ASSERT(!dsl_scan_is_running(scn));
 }
 
-/* ARGSUSED */
 static int
 dsl_scan_cancel_check(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	dsl_scan_t *scn = dmu_tx_pool(tx)->dp_scan;
 
 	if (!dsl_scan_is_running(scn))
@@ -1017,10 +1017,10 @@ dsl_scan_cancel_check(void *arg, dmu_tx_t *tx)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 dsl_scan_cancel_sync(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	dsl_scan_t *scn = dmu_tx_pool(tx)->dp_scan;
 
 	dsl_scan_done(scn, B_FALSE, tx);
@@ -1383,11 +1383,11 @@ typedef struct zil_scan_arg {
 	zil_header_t	*zsa_zh;
 } zil_scan_arg_t;
 
-/* ARGSUSED */
 static int
 dsl_scan_zil_block(zilog_t *zilog, const blkptr_t *bp, void *arg,
     uint64_t claim_txg)
 {
+	(void) zilog;
 	zil_scan_arg_t *zsa = arg;
 	dsl_pool_t *dp = zsa->zsa_dp;
 	dsl_scan_t *scn = dp->dp_scan;
@@ -1414,11 +1414,11 @@ dsl_scan_zil_block(zilog_t *zilog, const blkptr_t *bp, void *arg,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 dsl_scan_zil_record(zilog_t *zilog, const lr_t *lrc, void *arg,
     uint64_t claim_txg)
 {
+	(void) zilog;
 	if (lrc->lrc_txtype == TX_WRITE) {
 		zil_scan_arg_t *zsa = arg;
 		dsl_pool_t *dp = zsa->zsa_dp;
@@ -1643,6 +1643,7 @@ static void
 dsl_scan_prefetch_cb(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
     arc_buf_t *buf, void *private)
 {
+	(void) zio;
 	scan_prefetch_ctx_t *spc = private;
 	dsl_scan_t *scn = spc->spc_scn;
 	spa_t *spa = scn->scn_dp->dp_spa;
@@ -1702,7 +1703,6 @@ dsl_scan_prefetch_cb(zio_t *zio, const zbookmark_phys_t *zb, const blkptr_t *bp,
 	scan_prefetch_ctx_rele(spc, scn);
 }
 
-/* ARGSUSED */
 static void
 dsl_scan_prefetch_thread(void *arg)
 {
@@ -2340,7 +2340,6 @@ dsl_scan_ds_clone_swapped(dsl_dataset_t *ds1, dsl_dataset_t *ds2, dmu_tx_t *tx)
 	dsl_scan_sync_state(scn, tx, SYNC_CACHED);
 }
 
-/* ARGSUSED */
 static int
 enqueue_clones_cb(dsl_pool_t *dp, dsl_dataset_t *hds, void *arg)
 {
@@ -2525,10 +2524,10 @@ dsl_scan_visitds(dsl_scan_t *scn, uint64_t dsobj, dmu_tx_t *tx)
 	dsl_dataset_rele(ds, FTAG);
 }
 
-/* ARGSUSED */
 static int
 enqueue_cb(dsl_pool_t *dp, dsl_dataset_t *hds, void *arg)
 {
+	(void) arg;
 	dsl_dataset_t *ds;
 	int err;
 	dsl_scan_t *scn = dp->dp_scan;
@@ -2564,16 +2563,15 @@ enqueue_cb(dsl_pool_t *dp, dsl_dataset_t *hds, void *arg)
 	return (0);
 }
 
-/* ARGSUSED */
 void
 dsl_scan_ddt_entry(dsl_scan_t *scn, enum zio_checksum checksum,
     ddt_entry_t *dde, dmu_tx_t *tx)
 {
+	(void) tx;
 	const ddt_key_t *ddk = &dde->dde_key;
 	ddt_phys_t *ddp = dde->dde_phys;
 	blkptr_t bp;
 	zbookmark_phys_t zb = { 0 };
-	int p;
 
 	if (!dsl_scan_is_running(scn))
 		return;
@@ -2592,7 +2590,7 @@ dsl_scan_ddt_entry(dsl_scan_t *scn, enum zio_checksum checksum,
 	if (scn->scn_done_txg != 0)
 		return;
 
-	for (p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {
+	for (int p = 0; p < DDT_PHYS_TYPES; p++, ddp++) {
 		if (ddp->ddp_phys_birth == 0 ||
 		    ddp->ddp_phys_birth > scn->scn_phys.scn_max_txg)
 			continue;
diff --git a/sys/contrib/openzfs/module/zfs/dsl_synctask.c b/sys/contrib/openzfs/module/zfs/dsl_synctask.c
index 148e8fff2437..9fc9d4011d11 100644
--- a/sys/contrib/openzfs/module/zfs/dsl_synctask.c
+++ b/sys/contrib/openzfs/module/zfs/dsl_synctask.c
@@ -32,10 +32,10 @@
 
 #define	DST_AVG_BLKSHIFT 14
 
-/* ARGSUSED */
 static int
 dsl_null_checkfunc(void *arg, dmu_tx_t *tx)
 {
+	(void) arg, (void) tx;
 	return (0);
 }
 
diff --git a/sys/contrib/openzfs/module/zfs/fm.c b/sys/contrib/openzfs/module/zfs/fm.c
index cdf0fcf71556..5a52a881c687 100644
--- a/sys/contrib/openzfs/module/zfs/fm.c
+++ b/sys/contrib/openzfs/module/zfs/fm.c
@@ -68,7 +68,7 @@
 #include <sys/condvar.h>
 #include <sys/zfs_ioctl.h>
 
-int zfs_zevent_len_max = 512;
+static int zfs_zevent_len_max = 512;
 
 static int zevent_len_cur = 0;
 static int zevent_waiters = 0;
@@ -483,21 +483,21 @@ zfs_zevent_destroy(zfs_zevent_t *ze)
 /*
  * Wrappers for FM nvlist allocators
  */
-/* ARGSUSED */
 static void *
 i_fm_alloc(nv_alloc_t *nva, size_t size)
 {
+	(void) nva;
 	return (kmem_zalloc(size, KM_SLEEP));
 }
 
-/* ARGSUSED */
 static void
 i_fm_free(nv_alloc_t *nva, void *buf, size_t size)
 {
+	(void) nva;
 	kmem_free(buf, size);
 }
 
-const nv_alloc_ops_t fm_mem_alloc_ops = {
+static const nv_alloc_ops_t fm_mem_alloc_ops = {
 	.nv_ao_init = NULL,
 	.nv_ao_fini = NULL,
 	.nv_ao_alloc = i_fm_alloc,
diff --git a/sys/contrib/openzfs/module/zfs/gzip.c b/sys/contrib/openzfs/module/zfs/gzip.c
index e2c6e59969d6..48191241bd7d 100644
--- a/sys/contrib/openzfs/module/zfs/gzip.c
+++ b/sys/contrib/openzfs/module/zfs/gzip.c
@@ -83,10 +83,10 @@ gzip_compress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)
 	return ((size_t)dstlen);
 }
 
-/*ARGSUSED*/
 int
 gzip_decompress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)
 {
+	(void) n;
 	zlen_t dstlen = d_len;
 
 	ASSERT(d_len >= s_len);
diff --git a/sys/contrib/openzfs/module/zfs/lz4.c b/sys/contrib/openzfs/module/zfs/lz4.c
index 9da9d9e00635..75a31bf17ea4 100644
--- a/sys/contrib/openzfs/module/zfs/lz4.c
+++ b/sys/contrib/openzfs/module/zfs/lz4.c
@@ -1,165 +1,50 @@
 /*
- * LZ4 - Fast LZ compression algorithm
- * Header File
- * Copyright (C) 2011-2013, Yann Collet.
- * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
+   LZ4 - Fast LZ compression algorithm
+   Copyright (C) 2011-present, Yann Collet.
+
+   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are
+   met:
+
+       * Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+       * Redistributions in binary form must reproduce the above
+   copyright notice, this list of conditions and the following disclaimer
+   in the documentation and/or other materials provided with the
+   distribution.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   You can contact the author at :
+    - LZ4 homepage : http://www.lz4.org
+    - LZ4 source repository : https://github.com/lz4/lz4
+*/
+
+/*
+ * This file contains unmodified code from lz4 1.9.3's decompressor, plus
+ * associated macros and constants.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * It also contains a couple of defines from the old lz4.c to make things
+ * fit together smoothly.
  *
- * You can contact the author at :
- * - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
- * - LZ4 source repository : http://code.google.com/p/lz4/
  */
 
 #include <sys/zfs_context.h>
-#include <sys/zio_compress.h>
 
-static int real_LZ4_compress(const char *source, char *dest, int isize,
-    int osize);
-static int LZ4_uncompress_unknownOutputSize(const char *source, char *dest,
+int LZ4_uncompress_unknownOutputSize(const char *source, char *dest,
     int isize, int maxOutputSize);
-static int LZ4_compressCtx(void *ctx, const char *source, char *dest,
-    int isize, int osize);
-static int LZ4_compress64kCtx(void *ctx, const char *source, char *dest,
-    int isize, int osize);
-
-static void *lz4_alloc(int flags);
-static void lz4_free(void *ctx);
-
-/*ARGSUSED*/
-size_t
-lz4_compress_zfs(void *s_start, void *d_start, size_t s_len,
-    size_t d_len, int n)
-{
-	uint32_t bufsiz;
-	char *dest = d_start;
-
-	ASSERT(d_len >= sizeof (bufsiz));
-
-	bufsiz = real_LZ4_compress(s_start, &dest[sizeof (bufsiz)], s_len,
-	    d_len - sizeof (bufsiz));
-
-	/* Signal an error if the compression routine returned zero. */
-	if (bufsiz == 0)
-		return (s_len);
-
-	/*
-	 * The exact compressed size is needed by the decompression routine,
-	 * so it is stored at the start of the buffer. Note that this may be
-	 * less than the compressed block size, which is rounded up to a
-	 * multiple of 1<<ashift.
-	 */
-	*(uint32_t *)dest = BE_32(bufsiz);
-
-	return (bufsiz + sizeof (bufsiz));
-}
-
-/*ARGSUSED*/
-int
-lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
-    size_t d_len, int n)
-{
-	const char *src = s_start;
-	uint32_t bufsiz = BE_IN32(src);
-
-	/* invalid compressed buffer size encoded at start */
-	if (bufsiz + sizeof (bufsiz) > s_len)
-		return (1);
-
-	/*
-	 * Returns 0 on success (decompression function returned non-negative)
-	 * and non-zero on failure (decompression function returned negative).
-	 */
-	return (LZ4_uncompress_unknownOutputSize(&src[sizeof (bufsiz)],
-	    d_start, bufsiz, d_len) < 0);
-}
-
-/*
- * LZ4 API Description:
- *
- * Simple Functions:
- * real_LZ4_compress() :
- * 	isize  : is the input size. Max supported value is ~1.9GB
- * 	return : the number of bytes written in buffer dest
- *		 or 0 if the compression fails (if LZ4_COMPRESSMIN is set).
- * 	note : destination buffer must be already allocated.
- * 		destination buffer must be sized to handle worst cases
- * 		situations (input data not compressible) worst case size
- * 		evaluation is provided by function LZ4_compressBound().
- *
- * real_LZ4_uncompress() :
- * 	osize  : is the output size, therefore the original size
- * 	return : the number of bytes read in the source buffer.
- * 		If the source stream is malformed, the function will stop
- * 		decoding and return a negative result, indicating the byte
- * 		position of the faulty instruction. This function never
- * 		writes beyond dest + osize, and is therefore protected
- * 		against malicious data packets.
- * 	note : destination buffer must be already allocated
- *	note : real_LZ4_uncompress() is not used in ZFS so its code
- *	       is not present here.
- *
- * Advanced Functions
- *
- * LZ4_compressBound() :
- * 	Provides the maximum size that LZ4 may output in a "worst case"
- * 	scenario (input data not compressible) primarily useful for memory
- * 	allocation of output buffer.
- *
- * 	isize  : is the input size. Max supported value is ~1.9GB
- * 	return : maximum output size in a "worst case" scenario
- * 	note : this function is limited by "int" range (2^31-1)
- *
- * LZ4_uncompress_unknownOutputSize() :
- * 	isize  : is the input size, therefore the compressed size
- * 	maxOutputSize : is the size of the destination buffer (which must be
- * 		already allocated)
- * 	return : the number of bytes decoded in the destination buffer
- * 		(necessarily <= maxOutputSize). If the source stream is
- * 		malformed, the function will stop decoding and return a
- * 		negative result, indicating the byte position of the faulty
- * 		instruction. This function never writes beyond dest +
- * 		maxOutputSize, and is therefore protected against malicious
- * 		data packets.
- * 	note   : Destination buffer must be already allocated.
- *		This version is slightly slower than real_LZ4_uncompress()
- *
- * LZ4_compressCtx() :
- * 	This function explicitly handles the CTX memory structure.
- *
- * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated
- * 	by the caller (either on the stack or using kmem_cache_alloc). Passing
- * 	NULL isn't valid.
- *
- * LZ4_compress64kCtx() :
- * 	Same as LZ4_compressCtx(), but specific to small inputs (<64KB).
- * 	isize *Must* be <64KB, otherwise the output will be corrupted.
- *
- * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated
- * 	by the caller (either on the stack or using kmem_cache_alloc). Passing
- * 	NULL isn't valid.
- */
 
 /*
  * Tuning parameters
@@ -185,26 +70,6 @@ lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
  */
 #define	NOTCOMPRESSIBLE_CONFIRMATION 6
 
-/*
- * BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE: This will provide a boost to
- * performance for big endian cpu, but the resulting compressed stream
- * will be incompatible with little-endian CPU. You can set this option
- * to 1 in situations where data will stay within closed environment.
- * This option is useless on Little_Endian CPU (such as x86).
- */
-/* #define	BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE 1 */
-
-/*
- * CPU Feature Detection
- */
-
-/* 32 or 64 bits ? */
-#if defined(_LP64)
-#define	LZ4_ARCH64 1
-#else
-#define	LZ4_ARCH64 0
-#endif
-
 /*
  * Little Endian or Big Endian?
  * Note: overwrite the below #define if you know your architecture endianness.
@@ -219,17 +84,36 @@ lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
 #undef LZ4_BIG_ENDIAN
 #endif
 
-/*
- * Unaligned memory access is automatically enabled for "common" CPU,
- * such as x86. For others CPU, the compiler will be more cautious, and
- * insert extra code to ensure aligned access is respected. If you know
- * your target CPU supports unaligned memory access, you may want to
- * force this option manually to improve performance
+/*-************************************
+*  CPU Feature Detection
+**************************************/
+/* LZ4_FORCE_MEMORY_ACCESS
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
+ * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
+ * The below switch allow to select different access method for improved performance.
+ * Method 0 (default) : use `memcpy()`. Safe and portable.
+ * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
+ *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
+ * Method 2 : direct access. This method is portable but violate C standard.
+ *            It can generate buggy code on targets which assembly generation depends on alignment.
+ *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
+ * See https://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.
+ * Prefer these methods in priority order (0 > 1 > 2)
  */
-#if defined(__ARM_FEATURE_UNALIGNED)
-#define	LZ4_FORCE_UNALIGNED_ACCESS 1
+#ifndef LZ4_FORCE_MEMORY_ACCESS   /* can be defined externally */
+#  if defined(__GNUC__) && \
+  ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) \
+  || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
+#    define LZ4_FORCE_MEMORY_ACCESS 2
+#  elif (defined(__INTEL_COMPILER) && !defined(_WIN32)) || defined(__GNUC__)
+#    define LZ4_FORCE_MEMORY_ACCESS 1
+#  endif
 #endif
 
+/*
+ * LZ4_FORCE_SW_BITCOUNT
+ * Define this parameter if your target system or compiler does not support hardware bit count
+ */
 /*
  * Illumos : we can't use GCC's __builtin_ctz family of builtins in the
  * kernel
@@ -237,7 +121,7 @@ lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
  * kernel
  */
 #undef	LZ4_FORCE_SW_BITCOUNT
-#if defined(__sparc)
+#if defined(__sunos__)
 #define	LZ4_FORCE_SW_BITCOUNT
 #endif
 
@@ -257,10 +141,50 @@ lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
 
 #define	GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
 
-#if (GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)
-#define	expect(expr, value)    (__builtin_expect((expr), (value)))
+#ifndef LZ4_FORCE_INLINE
+#  ifdef _MSC_VER    /* Visual Studio */
+#    define LZ4_FORCE_INLINE static __forceinline
+#  else
+#    if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#      ifdef __GNUC__
+#        define LZ4_FORCE_INLINE static inline __attribute__((always_inline))
+#      else
+#        define LZ4_FORCE_INLINE static inline
+#      endif
+#    else
+#      define LZ4_FORCE_INLINE static
+#    endif /* __STDC_VERSION__ */
+#  endif  /* _MSC_VER */
+#endif /* LZ4_FORCE_INLINE */
+
+/* LZ4_FORCE_O2 and LZ4_FORCE_INLINE
+ * gcc on ppc64le generates an unrolled SIMDized loop for LZ4_wildCopy8,
+ * together with a simple 8-byte copy loop as a fall-back path.
+ * However, this optimization hurts the decompression speed by >30%,
+ * because the execution does not go to the optimized loop
+ * for typical compressible data, and all of the preamble checks
+ * before going to the fall-back path become useless overhead.
+ * This optimization happens only with the -O3 flag, and -O2 generates
+ * a simple 8-byte copy loop.
+ * With gcc on ppc64le, all of the LZ4_decompress_* and LZ4_wildCopy8
+ * functions are annotated with __attribute__((optimize("O2"))),
+ * and also LZ4_wildCopy8 is forcibly inlined, so that the O2 attribute
+ * of LZ4_wildCopy8 does not affect the compression speed.
+ */
+#if defined(__PPC64__) && defined(__LITTLE_ENDIAN__) && defined(__GNUC__) && !defined(__clang__)
+#  define LZ4_FORCE_O2  __attribute__((optimize("O2")))
+#  undef LZ4_FORCE_INLINE
+#  define LZ4_FORCE_INLINE  static __inline __attribute__((optimize("O2"),always_inline))
 #else
-#define	expect(expr, value)    (expr)
+#  define LZ4_FORCE_O2
+#endif
+
+#ifndef expect
+#if (defined(__GNUC__) && (__GNUC__ >= 3)) || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) || defined(__clang__)
+#  define expect(expr,value)    (__builtin_expect ((expr),(value)) )
+#else
+#  define expect(expr,value)    (expr)
+#endif
 #endif
 
 #ifndef likely
@@ -271,814 +195,793 @@ lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
 #define	unlikely(expr)	expect((expr) != 0, 0)
 #endif
 
-#define	lz4_bswap16(x) ((unsigned short int) ((((x) >> 8) & 0xffu) | \
-	(((x) & 0xffu) << 8)))
+#ifndef _KERNEL
+#include <stdlib.h>   /* malloc, calloc, free */
+#include <string.h>   /* memset, memcpy */
+#endif
+#define ALLOC(s)          malloc(s)
+#define ALLOC_AND_ZERO(s) calloc(1,s)
+#define FREEMEM(p)        free(p)
+
+#define MEM_INIT(p,v,s)   memset((p),(v),(s))
+
+
+/*-************************************
+*  Common Constants
+**************************************/
+#define MINMATCH 4
 
-/* Basic types */
-#define	BYTE	uint8_t
-#define	U16	uint16_t
-#define	U32	uint32_t
-#define	S32	int32_t
-#define	U64	uint64_t
+#define WILDCOPYLENGTH 8
+#define LASTLITERALS   5   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
+#define MFLIMIT       12   /* see ../doc/lz4_Block_format.md#parsing-restrictions */
+#define MATCH_SAFEGUARD_DISTANCE  ((2*WILDCOPYLENGTH) - MINMATCH)   /* ensure it's possible to write 2 x wildcopyLength without overflowing output buffer */
+#define FASTLOOP_SAFE_DISTANCE 64
 
-#ifndef LZ4_FORCE_UNALIGNED_ACCESS
-#pragma pack(1)
+#define KB *(1 <<10)
+#define MB *(1 <<20)
+#define GB *(1U<<30)
+
+#ifndef LZ4_DISTANCE_MAX   /* history window size; can be user-defined at compile time */
+#  define LZ4_DISTANCE_MAX 65535   /* set to maximum value by default */
 #endif
 
-typedef struct _U16_S {
-	U16 v;
-} U16_S;
-typedef struct _U32_S {
-	U32 v;
-} U32_S;
-typedef struct _U64_S {
-	U64 v;
-} U64_S;
-
-#ifndef LZ4_FORCE_UNALIGNED_ACCESS
-#pragma pack()
+#define LZ4_DISTANCE_ABSOLUTE_MAX 65535
+#if (LZ4_DISTANCE_MAX > LZ4_DISTANCE_ABSOLUTE_MAX)   /* max supported by LZ4 format */
+#  error "LZ4_DISTANCE_MAX is too big : must be <= 65535"
 #endif
 
-#define	A64(x) (((U64_S *)(x))->v)
-#define	A32(x) (((U32_S *)(x))->v)
-#define	A16(x) (((U16_S *)(x))->v)
+#define ML_BITS  4
+#define ML_MASK  ((1U<<ML_BITS)-1)
+#define RUN_BITS (8-ML_BITS)
+#define RUN_MASK ((1U<<RUN_BITS)-1)
 
-/*
- * Constants
- */
-#define	MINMATCH 4
+#define DEBUGLOG(l, ...) {}    /* disabled */
 
-#define	HASH_LOG COMPRESSIONLEVEL
-#define	HASHTABLESIZE (1 << HASH_LOG)
-#define	HASH_MASK (HASHTABLESIZE - 1)
+#ifndef assert
+#define assert ASSERT
+#endif
 
-#define	SKIPSTRENGTH (NOTCOMPRESSIBLE_CONFIRMATION > 2 ? \
-	NOTCOMPRESSIBLE_CONFIRMATION : 2)
+/*-************************************
+*  Types
+**************************************/
+#ifndef _KERNEL
+#include <limits.h>
+#endif
+#if defined(__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
+#ifndef _KERNEL
+#include <stdint.h>
+#endif
+  typedef  uint8_t BYTE;
+  typedef uint16_t U16;
+  typedef uint32_t U32;
+  typedef  int32_t S32;
+  typedef uint64_t U64;
+  typedef uintptr_t uptrval;
+#else
+# if UINT_MAX != 4294967295UL
+#   error "LZ4 code (when not C++ or C99) assumes that sizeof(int) == 4"
+# endif
+  typedef unsigned char       BYTE;
+  typedef unsigned short      U16;
+  typedef unsigned int        U32;
+  typedef   signed int        S32;
+  typedef unsigned long long  U64;
+  typedef size_t              uptrval;   /* generally true, except OpenVMS-64 */
+#endif
 
-#define	COPYLENGTH 8
-#define	LASTLITERALS 5
-#define	MFLIMIT (COPYLENGTH + MINMATCH)
-#define	MINLENGTH (MFLIMIT + 1)
+#if defined(__x86_64__)
+  typedef U64    reg_t;   /* 64-bits in x32 mode */
+#else
+  typedef size_t reg_t;   /* 32-bits in x32 mode */
+#endif
 
-#define	MAXD_LOG 16
-#define	MAX_DISTANCE ((1 << MAXD_LOG) - 1)
+typedef enum {
+    notLimited = 0,
+    limitedOutput = 1,
+    fillOutput = 2
+} limitedOutput_directive;
 
-#define	ML_BITS 4
-#define	ML_MASK ((1U<<ML_BITS)-1)
-#define	RUN_BITS (8-ML_BITS)
-#define	RUN_MASK ((1U<<RUN_BITS)-1)
 
+/*-************************************
+*  Reading and writing into memory
+**************************************/
 
-/*
- * Architecture-specific macros
+/**
+ * LZ4 relies on memcpy with a constant size being inlined. In freestanding
+ * environments, the compiler can't assume the implementation of memcpy() is
+ * standard compliant, so it can't apply its specialized memcpy() inlining
+ * logic. When possible, use __builtin_memcpy() to tell the compiler to analyze
+ * memcpy() as if it were standard compliant, so it can inline it in freestanding
+ * environments. This is needed when decompressing the Linux Kernel, for example.
  */
-#if LZ4_ARCH64
-#define	STEPSIZE 8
-#define	UARCH U64
-#define	AARCH A64
-#define	LZ4_COPYSTEP(s, d)	A64(d) = A64(s); d += 8; s += 8;
-#define	LZ4_COPYPACKET(s, d)	LZ4_COPYSTEP(s, d)
-#define	LZ4_SECURECOPY(s, d, e)	if (d < e) LZ4_WILDCOPY(s, d, e)
-#define	HTYPE U32
-#define	INITBASE(base)		const BYTE* const base = ip
-#else /* !LZ4_ARCH64 */
-#define	STEPSIZE 4
-#define	UARCH U32
-#define	AARCH A32
-#define	LZ4_COPYSTEP(s, d)	A32(d) = A32(s); d += 4; s += 4;
-#define	LZ4_COPYPACKET(s, d)	LZ4_COPYSTEP(s, d); LZ4_COPYSTEP(s, d);
-#define	LZ4_SECURECOPY		LZ4_WILDCOPY
-#define	HTYPE const BYTE *
-#define	INITBASE(base)		const int base = 0
-#endif /* !LZ4_ARCH64 */
-
-#if (defined(LZ4_BIG_ENDIAN) && !defined(BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE))
-#define	LZ4_READ_LITTLEENDIAN_16(d, s, p) \
-	{ U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; }
-#define	LZ4_WRITE_LITTLEENDIAN_16(p, i) \
-	{ U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p += 2; }
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+#define LZ4_memcpy(dst, src, size) __builtin_memcpy(dst, src, size)
 #else
-#define	LZ4_READ_LITTLEENDIAN_16(d, s, p) { d = (s) - A16(p); }
-#define	LZ4_WRITE_LITTLEENDIAN_16(p, v)  { A16(p) = v; p += 2; }
+#define LZ4_memcpy(dst, src, size) memcpy(dst, src, size)
 #endif
 
+static unsigned LZ4_isLittleEndian(void)
+{
+    const union { U32 u; BYTE c[4]; } one = { 1 };   /* don't use static : performance detrimental */
+    return one.c[0];
+}
 
-/* Local structures */
-struct refTables {
-	HTYPE hashTable[HASHTABLESIZE];
-};
 
+#if defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==2)
+/* lie to the compiler about data alignment; use with caution */
 
-/* Macros */
-#define	LZ4_HASH_FUNCTION(i) (((i) * 2654435761U) >> ((MINMATCH * 8) - \
-	HASH_LOG))
-#define	LZ4_HASH_VALUE(p) LZ4_HASH_FUNCTION(A32(p))
-#define	LZ4_WILDCOPY(s, d, e) do { LZ4_COPYPACKET(s, d) } while (d < e);
-#define	LZ4_BLINDCOPY(s, d, l) { BYTE* e = (d) + l; LZ4_WILDCOPY(s, d, e); \
-	d = e; }
+static U16 LZ4_read16(const void* memPtr) { return *(const U16*) memPtr; }
 
+static void LZ4_write16(void* memPtr, U16 value) { *(U16*)memPtr = value; }
+static void LZ4_write32(void* memPtr, U32 value) { *(U32*)memPtr = value; }
 
-/* Private functions */
-#if LZ4_ARCH64
+#elif defined(LZ4_FORCE_MEMORY_ACCESS) && (LZ4_FORCE_MEMORY_ACCESS==1)
 
-static inline int
-LZ4_NbCommonBytes(register U64 val)
-{
-#if defined(LZ4_BIG_ENDIAN)
-#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
-	!defined(LZ4_FORCE_SW_BITCOUNT)
-	return (__builtin_clzll(val) >> 3);
-#else
-	int r;
-	if (!(val >> 32)) {
-		r = 4;
-	} else {
-		r = 0;
-		val >>= 32;
-	}
-	if (!(val >> 16)) {
-		r += 2;
-		val >>= 8;
-	} else {
-		val >>= 24;
-	}
-	r += (!val);
-	return (r);
-#endif
-#else
-#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
-	!defined(LZ4_FORCE_SW_BITCOUNT)
-	return (__builtin_ctzll(val) >> 3);
-#else
-	static const int DeBruijnBytePos[64] =
-	    { 0, 0, 0, 0, 0, 1, 1, 2, 0, 3, 1, 3, 1, 4, 2, 7, 0, 2, 3, 6, 1, 5,
-		3, 5, 1, 3, 4, 4, 2, 5, 6, 7, 7, 0, 1, 2, 3, 3, 4, 6, 2, 6, 5,
-		5, 3, 4, 5, 6, 7, 1, 2, 4, 6, 4,
-		4, 5, 7, 2, 6, 5, 7, 6, 7, 7
-	};
-	return DeBruijnBytePos[((U64) ((val & -val) * 0x0218A392CDABBD3F)) >>
-	    58];
-#endif
-#endif
-}
+/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
+/* currently only defined for gcc and icc */
+typedef union { U16 u16; U32 u32; reg_t uArch; } __attribute__((packed)) unalign;
 
-#else
+static U16 LZ4_read16(const void* ptr) { return ((const unalign*)ptr)->u16; }
+
+static void LZ4_write32(void* memPtr, U32 value) { ((unalign*)memPtr)->u32 = value; }
+
+#else  /* safe and portable access using memcpy() */
 
-static inline int
-LZ4_NbCommonBytes(register U32 val)
+static U16 LZ4_read16(const void* memPtr)
 {
-#if defined(LZ4_BIG_ENDIAN)
-#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
-	!defined(LZ4_FORCE_SW_BITCOUNT)
-	return (__builtin_clz(val) >> 3);
-#else
-	int r;
-	if (!(val >> 16)) {
-		r = 2;
-		val >>= 8;
-	} else {
-		r = 0;
-		val >>= 24;
-	}
-	r += (!val);
-	return (r);
-#endif
-#else
-#if defined(__GNUC__) && (GCC_VERSION >= 304) && \
-	!defined(LZ4_FORCE_SW_BITCOUNT)
-	return (__builtin_ctz(val) >> 3);
-#else
-	static const int DeBruijnBytePos[32] = {
-		0, 0, 3, 0, 3, 1, 3, 0,
-		3, 2, 2, 1, 3, 2, 0, 1,
-		3, 3, 1, 2, 2, 2, 2, 0,
-		3, 1, 2, 0, 1, 0, 1, 1
-	};
-	return DeBruijnBytePos[((U32) ((val & -(S32) val) * 0x077CB531U)) >>
-	    27];
-#endif
-#endif
+    U16 val; LZ4_memcpy(&val, memPtr, sizeof(val)); return val;
 }
 
-#endif
+static void LZ4_write32(void* memPtr, U32 value)
+{
+    LZ4_memcpy(memPtr, &value, sizeof(value));
+}
 
-/* Compression functions */
+#endif /* LZ4_FORCE_MEMORY_ACCESS */
 
-/*ARGSUSED*/
-static int
-LZ4_compressCtx(void *ctx, const char *source, char *dest, int isize,
-    int osize)
+static U16 LZ4_readLE16(const void* memPtr)
 {
-	struct refTables *srt = (struct refTables *)ctx;
-	HTYPE *HashTable = (HTYPE *) (srt->hashTable);
-
-	const BYTE *ip = (BYTE *) source;
-	INITBASE(base);
-	const BYTE *anchor = ip;
-	const BYTE *const iend = ip + isize;
-	const BYTE *const oend = (BYTE *) dest + osize;
-	const BYTE *const mflimit = iend - MFLIMIT;
-#define	matchlimit (iend - LASTLITERALS)
-
-	BYTE *op = (BYTE *) dest;
-
-	int len, length;
-	const int skipStrength = SKIPSTRENGTH;
-	U32 forwardH;
-
-
-	/* Init */
-	if (isize < MINLENGTH)
-		goto _last_literals;
-
-	/* First Byte */
-	HashTable[LZ4_HASH_VALUE(ip)] = ip - base;
-	ip++;
-	forwardH = LZ4_HASH_VALUE(ip);
-
-	/* Main Loop */
-	for (;;) {
-		int findMatchAttempts = (1U << skipStrength) + 3;
-		const BYTE *forwardIp = ip;
-		const BYTE *ref;
-		BYTE *token;
-
-		/* Find a match */
-		do {
-			U32 h = forwardH;
-			int step = findMatchAttempts++ >> skipStrength;
-			ip = forwardIp;
-			forwardIp = ip + step;
-
-			if (unlikely(forwardIp > mflimit)) {
-				goto _last_literals;
-			}
-
-			forwardH = LZ4_HASH_VALUE(forwardIp);
-			ref = base + HashTable[h];
-			HashTable[h] = ip - base;
-
-		} while ((ref < ip - MAX_DISTANCE) || (A32(ref) != A32(ip)));
-
-		/* Catch up */
-		while ((ip > anchor) && (ref > (BYTE *) source) &&
-		    unlikely(ip[-1] == ref[-1])) {
-			ip--;
-			ref--;
-		}
-
-		/* Encode Literal length */
-		length = ip - anchor;
-		token = op++;
-
-		/* Check output limit */
-		if (unlikely(op + length + (2 + 1 + LASTLITERALS) +
-		    (length >> 8) > oend))
-			return (0);
-
-		if (length >= (int)RUN_MASK) {
-			*token = (RUN_MASK << ML_BITS);
-			len = length - RUN_MASK;
-			for (; len > 254; len -= 255)
-				*op++ = 255;
-			*op++ = (BYTE)len;
-		} else
-			*token = (length << ML_BITS);
-
-		/* Copy Literals */
-		LZ4_BLINDCOPY(anchor, op, length);
-
-		_next_match:
-		/* Encode Offset */
-		LZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);
-
-		/* Start Counting */
-		ip += MINMATCH;
-		ref += MINMATCH;	/* MinMatch verified */
-		anchor = ip;
-		while (likely(ip < matchlimit - (STEPSIZE - 1))) {
-			UARCH diff = AARCH(ref) ^ AARCH(ip);
-			if (!diff) {
-				ip += STEPSIZE;
-				ref += STEPSIZE;
-				continue;
-			}
-			ip += LZ4_NbCommonBytes(diff);
-			goto _endCount;
-		}
-#if LZ4_ARCH64
-		if ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {
-			ip += 4;
-			ref += 4;
-		}
-#endif
-		if ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {
-			ip += 2;
-			ref += 2;
-		}
-		if ((ip < matchlimit) && (*ref == *ip))
-			ip++;
-		_endCount:
-
-		/* Encode MatchLength */
-		len = (ip - anchor);
-		/* Check output limit */
-		if (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))
-			return (0);
-		if (len >= (int)ML_MASK) {
-			*token += ML_MASK;
-			len -= ML_MASK;
-			for (; len > 509; len -= 510) {
-				*op++ = 255;
-				*op++ = 255;
-			}
-			if (len > 254) {
-				len -= 255;
-				*op++ = 255;
-			}
-			*op++ = (BYTE)len;
-		} else
-			*token += len;
-
-		/* Test end of chunk */
-		if (ip > mflimit) {
-			anchor = ip;
-			break;
-		}
-		/* Fill table */
-		HashTable[LZ4_HASH_VALUE(ip - 2)] = ip - 2 - base;
-
-		/* Test next position */
-		ref = base + HashTable[LZ4_HASH_VALUE(ip)];
-		HashTable[LZ4_HASH_VALUE(ip)] = ip - base;
-		if ((ref > ip - (MAX_DISTANCE + 1)) && (A32(ref) == A32(ip))) {
-			token = op++;
-			*token = 0;
-			goto _next_match;
-		}
-		/* Prepare next loop */
-		anchor = ip++;
-		forwardH = LZ4_HASH_VALUE(ip);
-	}
-
-	_last_literals:
-	/* Encode Last Literals */
-	{
-		int lastRun = iend - anchor;
-		if (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >
-		    oend)
-			return (0);
-		if (lastRun >= (int)RUN_MASK) {
-			*op++ = (RUN_MASK << ML_BITS);
-			lastRun -= RUN_MASK;
-			for (; lastRun > 254; lastRun -= 255) {
-				*op++ = 255;
-			}
-			*op++ = (BYTE)lastRun;
-		} else
-			*op++ = (lastRun << ML_BITS);
-		(void) memcpy(op, anchor, iend - anchor);
-		op += iend - anchor;
-	}
-
-	/* End */
-	return (int)(((char *)op) - dest);
+    if (LZ4_isLittleEndian()) {
+        return LZ4_read16(memPtr);
+    } else {
+        const BYTE* p = (const BYTE*)memPtr;
+        return (U16)((U16)p[0] + (p[1]<<8));
+    }
 }
 
+/* customized variant of memcpy, which can overwrite up to 8 bytes beyond dstEnd */
+LZ4_FORCE_INLINE
+void LZ4_wildCopy8(void* dstPtr, const void* srcPtr, void* dstEnd)
+{
+    BYTE* d = (BYTE*)dstPtr;
+    const BYTE* s = (const BYTE*)srcPtr;
+    BYTE* const e = (BYTE*)dstEnd;
 
+    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
+}
 
-/* Note : this function is valid only if isize < LZ4_64KLIMIT */
-#define	LZ4_64KLIMIT ((1 << 16) + (MFLIMIT - 1))
-#define	HASHLOG64K (HASH_LOG + 1)
-#define	HASH64KTABLESIZE (1U << HASHLOG64K)
-#define	LZ4_HASH64K_FUNCTION(i)	(((i) * 2654435761U) >> ((MINMATCH*8) - \
-	HASHLOG64K))
-#define	LZ4_HASH64K_VALUE(p)	LZ4_HASH64K_FUNCTION(A32(p))
+static const unsigned inc32table[8] = {0, 1, 2,  1,  0,  4, 4, 4};
+static const int      dec64table[8] = {0, 0, 0, -1, -4,  1, 2, 3};
+
+
+#ifndef LZ4_FAST_DEC_LOOP
+#  if defined __i386__ || defined _M_IX86 || defined __x86_64__ || defined _M_X64
+#    define LZ4_FAST_DEC_LOOP 1
+#  elif defined(__aarch64__) && !defined(__clang__)
+     /* On aarch64, we disable this optimization for clang because on certain
+      * mobile chipsets, performance is reduced with clang. For information
+      * refer to https://github.com/lz4/lz4/pull/707 */
+#    define LZ4_FAST_DEC_LOOP 1
+#  else
+#    define LZ4_FAST_DEC_LOOP 0
+#  endif
+#endif
+
+#if LZ4_FAST_DEC_LOOP
 
-/*ARGSUSED*/
-static int
-LZ4_compress64kCtx(void *ctx, const char *source, char *dest, int isize,
-    int osize)
+LZ4_FORCE_INLINE void
+LZ4_memcpy_using_offset_base(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
 {
-	struct refTables *srt = (struct refTables *)ctx;
-	U16 *HashTable = (U16 *) (srt->hashTable);
-
-	const BYTE *ip = (BYTE *) source;
-	const BYTE *anchor = ip;
-	const BYTE *const base = ip;
-	const BYTE *const iend = ip + isize;
-	const BYTE *const oend = (BYTE *) dest + osize;
-	const BYTE *const mflimit = iend - MFLIMIT;
-#define	matchlimit (iend - LASTLITERALS)
-
-	BYTE *op = (BYTE *) dest;
-
-	int len, length;
-	const int skipStrength = SKIPSTRENGTH;
-	U32 forwardH;
-
-	/* Init */
-	if (isize < MINLENGTH)
-		goto _last_literals;
-
-	/* First Byte */
-	ip++;
-	forwardH = LZ4_HASH64K_VALUE(ip);
-
-	/* Main Loop */
-	for (;;) {
-		int findMatchAttempts = (1U << skipStrength) + 3;
-		const BYTE *forwardIp = ip;
-		const BYTE *ref;
-		BYTE *token;
-
-		/* Find a match */
-		do {
-			U32 h = forwardH;
-			int step = findMatchAttempts++ >> skipStrength;
-			ip = forwardIp;
-			forwardIp = ip + step;
-
-			if (forwardIp > mflimit) {
-				goto _last_literals;
-			}
-
-			forwardH = LZ4_HASH64K_VALUE(forwardIp);
-			ref = base + HashTable[h];
-			HashTable[h] = ip - base;
-
-		} while (A32(ref) != A32(ip));
-
-		/* Catch up */
-		while ((ip > anchor) && (ref > (BYTE *) source) &&
-		    (ip[-1] == ref[-1])) {
-			ip--;
-			ref--;
-		}
-
-		/* Encode Literal length */
-		length = ip - anchor;
-		token = op++;
-
-		/* Check output limit */
-		if (unlikely(op + length + (2 + 1 + LASTLITERALS) +
-		    (length >> 8) > oend))
-			return (0);
-
-		if (length >= (int)RUN_MASK) {
-			*token = (RUN_MASK << ML_BITS);
-			len = length - RUN_MASK;
-			for (; len > 254; len -= 255)
-				*op++ = 255;
-			*op++ = (BYTE)len;
-		} else
-			*token = (length << ML_BITS);
-
-		/* Copy Literals */
-		LZ4_BLINDCOPY(anchor, op, length);
-
-		_next_match:
-		/* Encode Offset */
-		LZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);
-
-		/* Start Counting */
-		ip += MINMATCH;
-		ref += MINMATCH;	/* MinMatch verified */
-		anchor = ip;
-		while (ip < matchlimit - (STEPSIZE - 1)) {
-			UARCH diff = AARCH(ref) ^ AARCH(ip);
-			if (!diff) {
-				ip += STEPSIZE;
-				ref += STEPSIZE;
-				continue;
-			}
-			ip += LZ4_NbCommonBytes(diff);
-			goto _endCount;
-		}
-#if LZ4_ARCH64
-		if ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {
-			ip += 4;
-			ref += 4;
-		}
-#endif
-		if ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {
-			ip += 2;
-			ref += 2;
-		}
-		if ((ip < matchlimit) && (*ref == *ip))
-			ip++;
-		_endCount:
-
-		/* Encode MatchLength */
-		len = (ip - anchor);
-		/* Check output limit */
-		if (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))
-			return (0);
-		if (len >= (int)ML_MASK) {
-			*token += ML_MASK;
-			len -= ML_MASK;
-			for (; len > 509; len -= 510) {
-				*op++ = 255;
-				*op++ = 255;
-			}
-			if (len > 254) {
-				len -= 255;
-				*op++ = 255;
-			}
-			*op++ = (BYTE)len;
-		} else
-			*token += len;
-
-		/* Test end of chunk */
-		if (ip > mflimit) {
-			anchor = ip;
-			break;
-		}
-		/* Fill table */
-		HashTable[LZ4_HASH64K_VALUE(ip - 2)] = ip - 2 - base;
-
-		/* Test next position */
-		ref = base + HashTable[LZ4_HASH64K_VALUE(ip)];
-		HashTable[LZ4_HASH64K_VALUE(ip)] = ip - base;
-		if (A32(ref) == A32(ip)) {
-			token = op++;
-			*token = 0;
-			goto _next_match;
-		}
-		/* Prepare next loop */
-		anchor = ip++;
-		forwardH = LZ4_HASH64K_VALUE(ip);
-	}
-
-	_last_literals:
-	/* Encode Last Literals */
-	{
-		int lastRun = iend - anchor;
-		if (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >
-		    oend)
-			return (0);
-		if (lastRun >= (int)RUN_MASK) {
-			*op++ = (RUN_MASK << ML_BITS);
-			lastRun -= RUN_MASK;
-			for (; lastRun > 254; lastRun -= 255)
-				*op++ = 255;
-			*op++ = (BYTE)lastRun;
-		} else
-			*op++ = (lastRun << ML_BITS);
-		(void) memcpy(op, anchor, iend - anchor);
-		op += iend - anchor;
-	}
-
-	/* End */
-	return (int)(((char *)op) - dest);
+    assert(srcPtr + offset == dstPtr);
+    if (offset < 8) {
+        LZ4_write32(dstPtr, 0);   /* silence an msan warning when offset==0 */
+        dstPtr[0] = srcPtr[0];
+        dstPtr[1] = srcPtr[1];
+        dstPtr[2] = srcPtr[2];
+        dstPtr[3] = srcPtr[3];
+        srcPtr += inc32table[offset];
+        LZ4_memcpy(dstPtr+4, srcPtr, 4);
+        srcPtr -= dec64table[offset];
+        dstPtr += 8;
+    } else {
+        LZ4_memcpy(dstPtr, srcPtr, 8);
+        dstPtr += 8;
+        srcPtr += 8;
+    }
+
+    LZ4_wildCopy8(dstPtr, srcPtr, dstEnd);
 }
 
-static int
-real_LZ4_compress(const char *source, char *dest, int isize, int osize)
+/* customized variant of memcpy, which can overwrite up to 32 bytes beyond dstEnd
+ * this version copies two times 16 bytes (instead of one time 32 bytes)
+ * because it must be compatible with offsets >= 16. */
+LZ4_FORCE_INLINE void
+LZ4_wildCopy32(void* dstPtr, const void* srcPtr, void* dstEnd)
 {
-	void *ctx;
-	int result;
-
-	ctx = lz4_alloc(KM_SLEEP);
-
-	/*
-	 * out of kernel memory, gently fall through - this will disable
-	 * compression in zio_compress_data
-	 */
-	if (ctx == NULL)
-		return (0);
+    BYTE* d = (BYTE*)dstPtr;
+    const BYTE* s = (const BYTE*)srcPtr;
+    BYTE* const e = (BYTE*)dstEnd;
 
-	memset(ctx, 0, sizeof (struct refTables));
-
-	if (isize < LZ4_64KLIMIT)
-		result = LZ4_compress64kCtx(ctx, source, dest, isize, osize);
-	else
-		result = LZ4_compressCtx(ctx, source, dest, isize, osize);
+    do { LZ4_memcpy(d,s,16); LZ4_memcpy(d+16,s+16,16); d+=32; s+=32; } while (d<e);
+}
 
-	lz4_free(ctx);
-	return (result);
+/* LZ4_memcpy_using_offset()  presumes :
+ * - dstEnd >= dstPtr + MINMATCH
+ * - there is at least 8 bytes available to write after dstEnd */
+LZ4_FORCE_INLINE void
+LZ4_memcpy_using_offset(BYTE* dstPtr, const BYTE* srcPtr, BYTE* dstEnd, const size_t offset)
+{
+    BYTE v[8];
+
+    assert(dstEnd >= dstPtr + MINMATCH);
+
+    switch(offset) {
+    case 1:
+        MEM_INIT(v, *srcPtr, 8);
+        break;
+    case 2:
+        LZ4_memcpy(v, srcPtr, 2);
+        LZ4_memcpy(&v[2], srcPtr, 2);
+        LZ4_memcpy(&v[4], v, 4);
+        break;
+    case 4:
+        LZ4_memcpy(v, srcPtr, 4);
+        LZ4_memcpy(&v[4], srcPtr, 4);
+        break;
+    default:
+        LZ4_memcpy_using_offset_base(dstPtr, srcPtr, dstEnd, offset);
+        return;
+    }
+
+    LZ4_memcpy(dstPtr, v, 8);
+    dstPtr += 8;
+    while (dstPtr < dstEnd) {
+        LZ4_memcpy(dstPtr, v, 8);
+        dstPtr += 8;
+    }
 }
+#endif
 
-/* Decompression functions */
 
-/*
- * Note: The decoding functions real_LZ4_uncompress() and
- *	LZ4_uncompress_unknownOutputSize() are safe against "buffer overflow"
- *	attack type. They will never write nor read outside of the provided
- *	output buffers. LZ4_uncompress_unknownOutputSize() also insures that
- *	it will never read outside of the input buffer. A corrupted input
- *	will produce an error result, a negative int, indicating the position
- *	of the error within input stream.
+/*-************************************
+*  Local Structures and types
+**************************************/
+typedef enum { clearedTable = 0, byPtr, byU32, byU16 } tableType_t;
+
+/**
+ * This enum distinguishes several different modes of accessing previous
+ * content in the stream.
  *
- * Note[2]: real_LZ4_uncompress(), referred to above, is not used in ZFS so
- *	its code is not present here.
+ * - noDict        : There is no preceding content.
+ * - withPrefix64k : Table entries up to ctx->dictSize before the current blob
+ *                   blob being compressed are valid and refer to the preceding
+ *                   content (of length ctx->dictSize), which is available
+ *                   contiguously preceding in memory the content currently
+ *                   being compressed.
+ * - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere
+ *                   else in memory, starting at ctx->dictionary with length
+ *                   ctx->dictSize.
+ * - usingDictCtx  : Like usingExtDict, but everything concerning the preceding
+ *                   content is in a separate context, pointed to by
+ *                   ctx->dictCtx. ctx->dictionary, ctx->dictSize, and table
+ *                   entries in the current context that refer to positions
+ *                   preceding the beginning of the current compression are
+ *                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx
+ *                   ->dictSize describe the location and size of the preceding
+ *                   content, and matches are found by looking in the ctx
+ *                   ->dictCtx->hashTable.
  */
+typedef enum { noDict = 0, withPrefix64k, usingExtDict, usingDictCtx } dict_directive;
+typedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;
 
-static const int dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
-#if LZ4_ARCH64
-static const int dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};
-#endif
+/*-*******************************
+ *  Decompression functions
+ ********************************/
 
-static int
-LZ4_uncompress_unknownOutputSize(const char *source, char *dest, int isize,
-    int maxOutputSize)
-{
-	/* Local Variables */
-	const BYTE *restrict ip = (const BYTE *) source;
-	const BYTE *const iend = ip + isize;
-	const BYTE *ref;
-
-	BYTE *op = (BYTE *) dest;
-	BYTE *const oend = op + maxOutputSize;
-	BYTE *cpy;
-
-	/* Main Loop */
-	while (ip < iend) {
-		unsigned token;
-		size_t length;
-
-		/* get runlength */
-		token = *ip++;
-		if ((length = (token >> ML_BITS)) == RUN_MASK) {
-			int s = 255;
-			while ((ip < iend) && (s == 255)) {
-				s = *ip++;
-				if (unlikely(length > (size_t)(length + s)))
-					goto _output_error;
-				length += s;
-			}
-		}
-		/* copy literals */
-		cpy = op + length;
-		/* CORNER-CASE: cpy might overflow. */
-		if (cpy < op)
-			goto _output_error;	/* cpy was overflowed, bail! */
-		if ((cpy > oend - COPYLENGTH) ||
-		    (ip + length > iend - COPYLENGTH)) {
-			if (cpy > oend)
-				/* Error: writes beyond output buffer */
-				goto _output_error;
-			if (ip + length != iend)
-				/*
-				 * Error: LZ4 format requires to consume all
-				 * input at this stage
-				 */
-				goto _output_error;
-			(void) memcpy(op, ip, length);
-			op += length;
-			/* Necessarily EOF, due to parsing restrictions */
-			break;
-		}
-		LZ4_WILDCOPY(ip, op, cpy);
-		ip -= (op - cpy);
-		op = cpy;
-
-		/* get offset */
-		LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);
-		ip += 2;
-		if (ref < (BYTE * const) dest)
-			/*
-			 * Error: offset creates reference outside of
-			 * destination buffer
-			 */
-			goto _output_error;
-
-		/* get matchlength */
-		if ((length = (token & ML_MASK)) == ML_MASK) {
-			while (ip < iend) {
-				int s = *ip++;
-				if (unlikely(length > (size_t)(length + s)))
-					goto _output_error;
-				length += s;
-				if (s == 255)
-					continue;
-				break;
-			}
-		}
-		/* copy repeated sequence */
-		if (unlikely(op - ref < STEPSIZE)) {
-#if LZ4_ARCH64
-			int dec64 = dec64table[op - ref];
-#else
-			const int dec64 = 0;
-#endif
-			op[0] = ref[0];
-			op[1] = ref[1];
-			op[2] = ref[2];
-			op[3] = ref[3];
-			op += 4;
-			ref += 4;
-			ref -= dec32table[op - ref];
-			A32(op) = A32(ref);
-			op += STEPSIZE - 4;
-			ref -= dec64;
-		} else {
-			LZ4_COPYSTEP(ref, op);
-		}
-		cpy = op + length - (STEPSIZE - 4);
-		if (cpy > oend - COPYLENGTH) {
-			if (cpy > oend)
-				/*
-				 * Error: request to write outside of
-				 * destination buffer
-				 */
-				goto _output_error;
-#if LZ4_ARCH64
-			if ((ref + COPYLENGTH) > oend)
-#else
-			if ((ref + COPYLENGTH) > oend ||
-			    (op + COPYLENGTH) > oend)
-#endif
-				goto _output_error;
-			LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
-			while (op < cpy)
-				*op++ = *ref++;
-			op = cpy;
-			if (op == oend)
-				/*
-				 * Check EOF (should never happen, since
-				 * last 5 bytes are supposed to be literals)
-				 */
-				goto _output_error;
-			continue;
-		}
-		LZ4_SECURECOPY(ref, op, cpy);
-		op = cpy;	/* correction */
-	}
-
-	/* end of decoding */
-	return (int)(((char *)op) - dest);
-
-	/* write overflow error detected */
-	_output_error:
-	return (-1);
-}
+typedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;
+typedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;
 
-#ifdef __FreeBSD__
-/*
- * FreeBSD has 4, 8 and 16 KB malloc zones which can be used here.
- * Should struct refTables get resized this may need to be revisited, hence
- * compiler-time asserts.
- */
-_Static_assert(sizeof(struct refTables) <= 16384,
-    "refTables too big for malloc");
-_Static_assert((sizeof(struct refTables) % 4096) == 0,
-    "refTables not a multiple of page size");
-#else
-#define ZFS_LZ4_USE_CACHE
-#endif
+typedef enum { loop_error = -2, initial_error = -1, ok = 0 } variable_length_error;
 
-#ifdef ZFS_LZ4_USE_CACHE
-static kmem_cache_t *lz4_cache;
-
-void
-lz4_init(void)
+LZ4_FORCE_INLINE unsigned
+read_variable_length(const BYTE**ip, const BYTE* lencheck,
+                     int loop_check, int initial_check,
+                     variable_length_error* error)
 {
-	lz4_cache = kmem_cache_create("lz4_cache",
-	    sizeof (struct refTables), 0, NULL, NULL, NULL, NULL, NULL, 0);
+    U32 length = 0;
+    U32 s;
+    if (initial_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
+        *error = initial_error;
+        return length;
+    }
+    do {
+        s = **ip;
+        (*ip)++;
+        length += s;
+        if (loop_check && unlikely((*ip) >= lencheck)) {    /* overflow detection */
+            *error = loop_error;
+            return length;
+        }
+    } while (s==255);
+
+    return length;
 }
 
-void
-lz4_fini(void)
-{
-	if (lz4_cache) {
-		kmem_cache_destroy(lz4_cache);
-		lz4_cache = NULL;
-	}
-}
+#define	LZ4_STATIC_ASSERT(c)	ASSERT(c)
 
-static void *
-lz4_alloc(int flags)
-{
-	ASSERT(lz4_cache != NULL);
-	return (kmem_cache_alloc(lz4_cache, flags));
-}
 
-static void
-lz4_free(void *ctx)
-{
-	kmem_cache_free(lz4_cache, ctx);
-}
-#else
-void
-lz4_init(void)
+/*! LZ4_decompress_generic() :
+ *  This generic decompression function covers all use cases.
+ *  It shall be instantiated several times, using different sets of directives.
+ *  Note that it is important for performance that this function really get inlined,
+ *  in order to remove useless branches during compilation optimization.
+ */
+LZ4_FORCE_INLINE int
+LZ4_decompress_generic(
+                 const char* const src,
+                 char* const dst,
+                 int srcSize,
+                 int outputSize,         /* If endOnInput==endOnInputSize, this value is `dstCapacity` */
+
+                 endCondition_directive endOnInput,   /* endOnOutputSize, endOnInputSize */
+                 earlyEnd_directive partialDecoding,  /* full, partial */
+                 dict_directive dict,                 /* noDict, withPrefix64k, usingExtDict */
+                 const BYTE* const lowPrefix,  /* always <= dst, == dst when no prefix */
+                 const BYTE* const dictStart,  /* only if dict==usingExtDict */
+                 const size_t dictSize         /* note : = 0 if noDict */
+                 )
 {
-}
+    if ((src == NULL) || (outputSize < 0)) { return -1; }
+
+    {   const BYTE* ip = (const BYTE*) src;
+        const BYTE* const iend = ip + srcSize;
+
+        BYTE* op = (BYTE*) dst;
+        BYTE* const oend = op + outputSize;
+        BYTE* cpy;
+
+        const BYTE* const dictEnd = (dictStart == NULL) ? NULL : dictStart + dictSize;
+
+        const int safeDecode = (endOnInput==endOnInputSize);
+        const int checkOffset = ((safeDecode) && (dictSize < (int)(64 KB)));
+
+
+        /* Set up the "end" pointers for the shortcut. */
+        const BYTE* const shortiend = iend - (endOnInput ? 14 : 8) /*maxLL*/ - 2 /*offset*/;
+        const BYTE* const shortoend = oend - (endOnInput ? 14 : 8) /*maxLL*/ - 18 /*maxML*/;
+
+        const BYTE* match;
+        size_t offset;
+        unsigned token;
+        size_t length;
+
+
+        DEBUGLOG(5, "LZ4_decompress_generic (srcSize:%i, dstSize:%i)", srcSize, outputSize);
+
+        /* Special cases */
+        assert(lowPrefix <= op);
+        if ((endOnInput) && (unlikely(outputSize==0))) {
+            /* Empty output buffer */
+            if (partialDecoding) return 0;
+            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
+        }
+        if ((!endOnInput) && (unlikely(outputSize==0))) { return (*ip==0 ? 1 : -1); }
+        if ((endOnInput) && unlikely(srcSize==0)) { return -1; }
+
+	/* Currently the fast loop shows a regression on qualcomm arm chips. */
+#if LZ4_FAST_DEC_LOOP
+        if ((oend - op) < FASTLOOP_SAFE_DISTANCE) {
+            DEBUGLOG(6, "skip fast decode loop");
+            goto safe_decode;
+        }
+
+        /* Fast loop : decode sequences as long as output < iend-FASTLOOP_SAFE_DISTANCE */
+        while (1) {
+            /* Main fastloop assertion: We can always wildcopy FASTLOOP_SAFE_DISTANCE */
+            assert(oend - op >= FASTLOOP_SAFE_DISTANCE);
+            if (endOnInput) { assert(ip < iend); }
+            token = *ip++;
+            length = token >> ML_BITS;  /* literal length */
+
+            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */
+
+            /* decode literal length */
+            if (length == RUN_MASK) {
+                variable_length_error error = ok;
+                length += read_variable_length(&ip, iend-RUN_MASK, (int)endOnInput, (int)endOnInput, &error);
+                if (error == initial_error) { goto _output_error; }
+                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
+                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
+
+                /* copy literals */
+                cpy = op+length;
+                LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
+                if (endOnInput) {  /* LZ4_decompress_safe() */
+                    if ((cpy>oend-32) || (ip+length>iend-32)) { goto safe_literal_copy; }
+                    LZ4_wildCopy32(op, ip, cpy);
+                } else {   /* LZ4_decompress_fast() */
+                    if (cpy>oend-8) { goto safe_literal_copy; }
+                    LZ4_wildCopy8(op, ip, cpy); /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
+                                                 * it doesn't know input length, and only relies on end-of-block properties */
+                }
+                ip += length; op = cpy;
+            } else {
+                cpy = op+length;
+                if (endOnInput) {  /* LZ4_decompress_safe() */
+                    DEBUGLOG(7, "copy %u bytes in a 16-bytes stripe", (unsigned)length);
+                    /* We don't need to check oend, since we check it once for each loop below */
+                    if (ip > iend-(16 + 1/*max lit + offset + nextToken*/)) { goto safe_literal_copy; }
+                    /* Literals can only be 14, but hope compilers optimize if we copy by a register size */
+                    LZ4_memcpy(op, ip, 16);
+                } else {  /* LZ4_decompress_fast() */
+                    /* LZ4_decompress_fast() cannot copy more than 8 bytes at a time :
+                     * it doesn't know input length, and relies on end-of-block properties */
+                    LZ4_memcpy(op, ip, 8);
+                    if (length > 8) { LZ4_memcpy(op+8, ip+8, 8); }
+                }
+                ip += length; op = cpy;
+            }
+
+            /* get offset */
+            offset = LZ4_readLE16(ip); ip+=2;
+            match = op - offset;
+            assert(match <= op);
+
+            /* get matchlength */
+            length = token & ML_MASK;
+
+            if (length == ML_MASK) {
+                variable_length_error error = ok;
+                if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
+                length += read_variable_length(&ip, iend - LASTLITERALS + 1, (int)endOnInput, 0, &error);
+                if (error != ok) { goto _output_error; }
+                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) { goto _output_error; } /* overflow detection */
+                length += MINMATCH;
+                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
+                    goto safe_match_copy;
+                }
+            } else {
+                length += MINMATCH;
+                if (op + length >= oend - FASTLOOP_SAFE_DISTANCE) {
+                    goto safe_match_copy;
+                }
+
+                /* Fastpath check: Avoids a branch in LZ4_wildCopy32 if true */
+                if ((dict == withPrefix64k) || (match >= lowPrefix)) {
+                    if (offset >= 8) {
+                        assert(match >= lowPrefix);
+                        assert(match <= op);
+                        assert(op + 18 <= oend);
+
+                        LZ4_memcpy(op, match, 8);
+                        LZ4_memcpy(op+8, match+8, 8);
+                        LZ4_memcpy(op+16, match+16, 2);
+                        op += length;
+                        continue;
+            }   }   }
+
+            if (checkOffset && (unlikely(match + dictSize < lowPrefix))) { goto _output_error; } /* Error : offset outside buffers */
+            /* match starting within external dictionary */
+            if ((dict==usingExtDict) && (match < lowPrefix)) {
+                if (unlikely(op+length > oend-LASTLITERALS)) {
+                    if (partialDecoding) {
+                        DEBUGLOG(7, "partialDecoding: dictionary match, close to dstEnd");
+                        length = MIN(length, (size_t)(oend-op));
+                    } else {
+                        goto _output_error;  /* end-of-block condition violated */
+                }   }
+
+                if (length <= (size_t)(lowPrefix-match)) {
+                    /* match fits entirely within external dictionary : just copy */
+                    memmove(op, dictEnd - (lowPrefix-match), length);
+                    op += length;
+                } else {
+                    /* match stretches into both external dictionary and current block */
+                    size_t const copySize = (size_t)(lowPrefix - match);
+                    size_t const restSize = length - copySize;
+                    LZ4_memcpy(op, dictEnd - copySize, copySize);
+                    op += copySize;
+                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
+                        BYTE* const endOfMatch = op + restSize;
+                        const BYTE* copyFrom = lowPrefix;
+                        while (op < endOfMatch) { *op++ = *copyFrom++; }
+                    } else {
+                        LZ4_memcpy(op, lowPrefix, restSize);
+                        op += restSize;
+                }   }
+                continue;
+            }
+
+            /* copy match within block */
+            cpy = op + length;
+
+            assert((op <= oend) && (oend-op >= 32));
+            if (unlikely(offset<16)) {
+                LZ4_memcpy_using_offset(op, match, cpy, offset);
+            } else {
+                LZ4_wildCopy32(op, match, cpy);
+            }
+
+            op = cpy;   /* wildcopy correction */
+        }
+    safe_decode:
+#endif
 
-void
-lz4_fini(void)
-{
+        /* Main Loop : decode remaining sequences where output < FASTLOOP_SAFE_DISTANCE */
+        while (1) {
+            token = *ip++;
+            length = token >> ML_BITS;  /* literal length */
+
+            assert(!endOnInput || ip <= iend); /* ip < iend before the increment */
+
+            /* A two-stage shortcut for the most common case:
+             * 1) If the literal length is 0..14, and there is enough space,
+             * enter the shortcut and copy 16 bytes on behalf of the literals
+             * (in the fast mode, only 8 bytes can be safely copied this way).
+             * 2) Further if the match length is 4..18, copy 18 bytes in a similar
+             * manner; but we ensure that there's enough space in the output for
+             * those 18 bytes earlier, upon entering the shortcut (in other words,
+             * there is a combined check for both stages).
+             */
+            if ( (endOnInput ? length != RUN_MASK : length <= 8)
+                /* strictly "less than" on input, to re-enter the loop with at least one byte */
+              && likely((endOnInput ? ip < shortiend : 1) & (op <= shortoend)) ) {
+                /* Copy the literals */
+                LZ4_memcpy(op, ip, endOnInput ? 16 : 8);
+                op += length; ip += length;
+
+                /* The second stage: prepare for match copying, decode full info.
+                 * If it doesn't work out, the info won't be wasted. */
+                length = token & ML_MASK; /* match length */
+                offset = LZ4_readLE16(ip); ip += 2;
+                match = op - offset;
+                assert(match <= op); /* check overflow */
+
+                /* Do not deal with overlapping matches. */
+                if ( (length != ML_MASK)
+                  && (offset >= 8)
+                  && (dict==withPrefix64k || match >= lowPrefix) ) {
+                    /* Copy the match. */
+                    LZ4_memcpy(op + 0, match + 0, 8);
+                    LZ4_memcpy(op + 8, match + 8, 8);
+                    LZ4_memcpy(op +16, match +16, 2);
+                    op += length + MINMATCH;
+                    /* Both stages worked, load the next token. */
+                    continue;
+                }
+
+                /* The second stage didn't work out, but the info is ready.
+                 * Propel it right to the point of match copying. */
+                goto _copy_match;
+            }
+
+            /* decode literal length */
+            if (length == RUN_MASK) {
+                variable_length_error error = ok;
+                length += read_variable_length(&ip, iend-RUN_MASK, (int)endOnInput, (int)endOnInput, &error);
+                if (error == initial_error) { goto _output_error; }
+                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
+                if ((safeDecode) && unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
+            }
+
+            /* copy literals */
+            cpy = op+length;
+#if LZ4_FAST_DEC_LOOP
+        safe_literal_copy:
+#endif
+            LZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);
+            if ( ((endOnInput) && ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) )
+              || ((!endOnInput) && (cpy>oend-WILDCOPYLENGTH)) )
+            {
+                /* We've either hit the input parsing restriction or the output parsing restriction.
+                 * In the normal scenario, decoding a full block, it must be the last sequence,
+                 * otherwise it's an error (invalid input or dimensions).
+                 * In partialDecoding scenario, it's necessary to ensure there is no buffer overflow.
+                 */
+                if (partialDecoding) {
+                    /* Since we are partial decoding we may be in this block because of the output parsing
+                     * restriction, which is not valid since the output buffer is allowed to be undersized.
+                     */
+                    assert(endOnInput);
+                    DEBUGLOG(7, "partialDecoding: copying literals, close to input or output end")
+                    DEBUGLOG(7, "partialDecoding: literal length = %u", (unsigned)length);
+                    DEBUGLOG(7, "partialDecoding: remaining space in dstBuffer : %i", (int)(oend - op));
+                    DEBUGLOG(7, "partialDecoding: remaining space in srcBuffer : %i", (int)(iend - ip));
+                    /* Finishing in the middle of a literals segment,
+                     * due to lack of input.
+                     */
+                    if (ip+length > iend) {
+                        length = (size_t)(iend-ip);
+                        cpy = op + length;
+                    }
+                    /* Finishing in the middle of a literals segment,
+                     * due to lack of output space.
+                     */
+                    if (cpy > oend) {
+                        cpy = oend;
+                        assert(op<=oend);
+                        length = (size_t)(oend-op);
+                    }
+                } else {
+                    /* We must be on the last sequence because of the parsing limitations so check
+                     * that we exactly regenerate the original size (must be exact when !endOnInput).
+                     */
+                    if ((!endOnInput) && (cpy != oend)) { goto _output_error; }
+                     /* We must be on the last sequence (or invalid) because of the parsing limitations
+                      * so check that we exactly consume the input and don't overrun the output buffer.
+                      */
+                    if ((endOnInput) && ((ip+length != iend) || (cpy > oend))) {
+                        DEBUGLOG(6, "should have been last run of literals")
+                        DEBUGLOG(6, "ip(%p) + length(%i) = %p != iend (%p)", ip, (int)length, ip+length, iend);
+                        DEBUGLOG(6, "or cpy(%p) > oend(%p)", cpy, oend);
+                        goto _output_error;
+                    }
+                }
+                memmove(op, ip, length);  /* supports overlapping memory regions; only matters for in-place decompression scenarios */
+                ip += length;
+                op += length;
+                /* Necessarily EOF when !partialDecoding.
+                 * When partialDecoding, it is EOF if we've either
+                 * filled the output buffer or
+                 * can't proceed with reading an offset for following match.
+                 */
+                if (!partialDecoding || (cpy == oend) || (ip >= (iend-2))) {
+                    break;
+                }
+            } else {
+                LZ4_wildCopy8(op, ip, cpy);   /* may overwrite up to WILDCOPYLENGTH beyond cpy */
+                ip += length; op = cpy;
+            }
+
+            /* get offset */
+            offset = LZ4_readLE16(ip); ip+=2;
+            match = op - offset;
+
+            /* get matchlength */
+            length = token & ML_MASK;
+
+    _copy_match:
+            if (length == ML_MASK) {
+              variable_length_error error = ok;
+              length += read_variable_length(&ip, iend - LASTLITERALS + 1, (int)endOnInput, 0, &error);
+              if (error != ok) goto _output_error;
+                if ((safeDecode) && unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
+            }
+            length += MINMATCH;
+
+#if LZ4_FAST_DEC_LOOP
+        safe_match_copy:
+#endif
+            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
+            /* match starting within external dictionary */
+            if ((dict==usingExtDict) && (match < lowPrefix)) {
+                if (unlikely(op+length > oend-LASTLITERALS)) {
+                    if (partialDecoding) length = MIN(length, (size_t)(oend-op));
+                    else goto _output_error;   /* doesn't respect parsing restriction */
+                }
+
+                if (length <= (size_t)(lowPrefix-match)) {
+                    /* match fits entirely within external dictionary : just copy */
+                    memmove(op, dictEnd - (lowPrefix-match), length);
+                    op += length;
+                } else {
+                    /* match stretches into both external dictionary and current block */
+                    size_t const copySize = (size_t)(lowPrefix - match);
+                    size_t const restSize = length - copySize;
+                    LZ4_memcpy(op, dictEnd - copySize, copySize);
+                    op += copySize;
+                    if (restSize > (size_t)(op - lowPrefix)) {  /* overlap copy */
+                        BYTE* const endOfMatch = op + restSize;
+                        const BYTE* copyFrom = lowPrefix;
+                        while (op < endOfMatch) *op++ = *copyFrom++;
+                    } else {
+                        LZ4_memcpy(op, lowPrefix, restSize);
+                        op += restSize;
+                }   }
+                continue;
+            }
+            assert(match >= lowPrefix);
+
+            /* copy match within block */
+            cpy = op + length;
+
+            /* partialDecoding : may end anywhere within the block */
+            assert(op<=oend);
+            if (partialDecoding && (cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
+                size_t const mlen = MIN(length, (size_t)(oend-op));
+                const BYTE* const matchEnd = match + mlen;
+                BYTE* const copyEnd = op + mlen;
+                if (matchEnd > op) {   /* overlap copy */
+                    while (op < copyEnd) { *op++ = *match++; }
+                } else {
+                    LZ4_memcpy(op, match, mlen);
+                }
+                op = copyEnd;
+                if (op == oend) { break; }
+                continue;
+            }
+
+            if (unlikely(offset<8)) {
+                LZ4_write32(op, 0);   /* silence msan warning when offset==0 */
+                op[0] = match[0];
+                op[1] = match[1];
+                op[2] = match[2];
+                op[3] = match[3];
+                match += inc32table[offset];
+                LZ4_memcpy(op+4, match, 4);
+                match -= dec64table[offset];
+            } else {
+                LZ4_memcpy(op, match, 8);
+                match += 8;
+            }
+            op += 8;
+
+            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
+                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
+                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
+                if (op < oCopyLimit) {
+                    LZ4_wildCopy8(op, match, oCopyLimit);
+                    match += oCopyLimit - op;
+                    op = oCopyLimit;
+                }
+                while (op < cpy) { *op++ = *match++; }
+            } else {
+                LZ4_memcpy(op, match, 8);
+                if (length > 16)  { LZ4_wildCopy8(op+8, match+8, cpy); }
+            }
+            op = cpy;   /* wildcopy correction */
+        }
+
+        /* end of decoding */
+        if (endOnInput) {
+            DEBUGLOG(5, "decoded %i bytes", (int) (((char*)op)-dst));
+           return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
+       } else {
+           return (int) (((const char*)ip)-src);   /* Nb of input bytes read */
+       }
+
+        /* Overflow error detected */
+    _output_error:
+        return (int) (-(((const char*)ip)-src))-1;
+    }
 }
 
-static void *
-lz4_alloc(int flags)
-{
-	return (kmem_alloc(sizeof (struct refTables), flags));
-}
+/*
+ * LZ4_uncompress_unknownOutputSize() :
+ * 	isize  : is the input size, therefore the compressed size
+ * 	maxOutputSize : is the size of the destination buffer (which must be
+ * 		already allocated)
+ * 	return : the number of bytes decoded in the destination buffer
+ * 		(necessarily <= maxOutputSize). If the source stream is
+ * 		malformed, the function will stop decoding and return a
+ * 		negative result, indicating the byte position of the faulty
+ * 		instruction. This function never writes beyond dest +
+ * 		maxOutputSize, and is therefore protected against malicious
+ * 		data packets.
+ * 	note   : Destination buffer must be already allocated.
+ *		This version is slightly slower than real_LZ4_uncompress()
+ *
+ */
 
-static void
-lz4_free(void *ctx)
+/*
+ * Note: In upstream code, LZ4_uncompress_unknownOutputSize is now a legacy
+ *       wrapper for LZ4_decompress_safe which is a wrapper for
+ *	 LZ4_decompress_generic; this wrapper flattens that, rather than
+ *	 rewriting the callers.
+ */
+int LZ4_uncompress_unknownOutputSize(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
 {
-	kmem_free(ctx, sizeof (struct refTables));
+    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
+                                  endOnInputSize, decode_full_block, noDict,
+                                  (BYTE*)dest, NULL, 0);
 }
-#endif
diff --git a/sys/contrib/openzfs/module/zfs/lz4_zfs.c b/sys/contrib/openzfs/module/zfs/lz4_zfs.c
new file mode 100644
index 000000000000..820556effb8b
--- /dev/null
+++ b/sys/contrib/openzfs/module/zfs/lz4_zfs.c
@@ -0,0 +1,935 @@
+/*
+ * LZ4 - Fast LZ compression algorithm
+ * Header File
+ * Copyright (C) 2011-2013, Yann Collet.
+ * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at :
+ * - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
+ * - LZ4 source repository : http://code.google.com/p/lz4/
+ */
+
+/*
+ * N.B. - This file seems to be based on LZ4 r85, dated Dec 10, 2012
+ */
+
+#include <sys/zfs_context.h>
+#include <sys/zio_compress.h>
+
+static int real_LZ4_compress(const char *source, char *dest, int isize,
+    int osize);
+static int LZ4_compressCtx(void *ctx, const char *source, char *dest,
+    int isize, int osize);
+static int LZ4_compress64kCtx(void *ctx, const char *source, char *dest,
+    int isize, int osize);
+
+/* See lz4.c */
+int LZ4_uncompress_unknownOutputSize(const char *source, char *dest,
+    int isize, int maxOutputSize);
+
+static void *lz4_alloc(int flags);
+static void lz4_free(void *ctx);
+
+size_t
+lz4_compress_zfs(void *s_start, void *d_start, size_t s_len,
+    size_t d_len, int n)
+{
+	(void) n;
+	uint32_t bufsiz;
+	char *dest = d_start;
+
+	ASSERT(d_len >= sizeof (bufsiz));
+
+	bufsiz = real_LZ4_compress(s_start, &dest[sizeof (bufsiz)], s_len,
+	    d_len - sizeof (bufsiz));
+
+	/* Signal an error if the compression routine returned zero. */
+	if (bufsiz == 0)
+		return (s_len);
+
+	/*
+	 * The exact compressed size is needed by the decompression routine,
+	 * so it is stored at the start of the buffer. Note that this may be
+	 * less than the compressed block size, which is rounded up to a
+	 * multiple of 1<<ashift.
+	 */
+	*(uint32_t *)dest = BE_32(bufsiz);
+
+	return (bufsiz + sizeof (bufsiz));
+}
+
+int
+lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len,
+    size_t d_len, int n)
+{
+	(void) n;
+	const char *src = s_start;
+	uint32_t bufsiz = BE_IN32(src);
+
+	/* invalid compressed buffer size encoded at start */
+	if (bufsiz + sizeof (bufsiz) > s_len)
+		return (1);
+
+	/*
+	 * Returns 0 on success (decompression function returned non-negative)
+	 * and non-zero on failure (decompression function returned negative).
+	 */
+	return (LZ4_uncompress_unknownOutputSize(&src[sizeof (bufsiz)],
+	    d_start, bufsiz, d_len) < 0);
+}
+
+/*
+ * LZ4 API Description:
+ *
+ * Simple Functions:
+ * real_LZ4_compress() :
+ * 	isize  : is the input size. Max supported value is ~1.9GB
+ * 	return : the number of bytes written in buffer dest
+ *		 or 0 if the compression fails (if LZ4_COMPRESSMIN is set).
+ * 	note : destination buffer must be already allocated.
+ * 		destination buffer must be sized to handle worst cases
+ * 		situations (input data not compressible) worst case size
+ * 		evaluation is provided by function LZ4_compressBound().
+ *
+ * real_LZ4_uncompress() :
+ * 	osize  : is the output size, therefore the original size
+ * 	return : the number of bytes read in the source buffer.
+ * 		If the source stream is malformed, the function will stop
+ * 		decoding and return a negative result, indicating the byte
+ * 		position of the faulty instruction. This function never
+ * 		writes beyond dest + osize, and is therefore protected
+ * 		against malicious data packets.
+ * 	note : destination buffer must be already allocated
+ *	note : real_LZ4_uncompress() is not used in ZFS so its code
+ *	       is not present here.
+ *
+ * Advanced Functions
+ *
+ * LZ4_compressBound() :
+ * 	Provides the maximum size that LZ4 may output in a "worst case"
+ * 	scenario (input data not compressible) primarily useful for memory
+ * 	allocation of output buffer.
+ *
+ * 	isize  : is the input size. Max supported value is ~1.9GB
+ * 	return : maximum output size in a "worst case" scenario
+ * 	note : this function is limited by "int" range (2^31-1)
+ *
+ * LZ4_uncompress_unknownOutputSize() :
+ * 	isize  : is the input size, therefore the compressed size
+ * 	maxOutputSize : is the size of the destination buffer (which must be
+ * 		already allocated)
+ * 	return : the number of bytes decoded in the destination buffer
+ * 		(necessarily <= maxOutputSize). If the source stream is
+ * 		malformed, the function will stop decoding and return a
+ * 		negative result, indicating the byte position of the faulty
+ * 		instruction. This function never writes beyond dest +
+ * 		maxOutputSize, and is therefore protected against malicious
+ * 		data packets.
+ * 	note   : Destination buffer must be already allocated.
+ *		This version is slightly slower than real_LZ4_uncompress()
+ *
+ * LZ4_compressCtx() :
+ * 	This function explicitly handles the CTX memory structure.
+ *
+ * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated
+ * 	by the caller (either on the stack or using kmem_cache_alloc). Passing
+ * 	NULL isn't valid.
+ *
+ * LZ4_compress64kCtx() :
+ * 	Same as LZ4_compressCtx(), but specific to small inputs (<64KB).
+ * 	isize *Must* be <64KB, otherwise the output will be corrupted.
+ *
+ * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated
+ * 	by the caller (either on the stack or using kmem_cache_alloc). Passing
+ * 	NULL isn't valid.
+ */
+
+/*
+ * Tuning parameters
+ */
+
+/*
+ * COMPRESSIONLEVEL: Increasing this value improves compression ratio
+ *	 Lowering this value reduces memory usage. Reduced memory usage
+ *	typically improves speed, due to cache effect (ex: L1 32KB for Intel,
+ *	L1 64KB for AMD). Memory usage formula : N->2^(N+2) Bytes
+ *	(examples : 12 -> 16KB ; 17 -> 512KB)
+ */
+#define	COMPRESSIONLEVEL 12
+
+/*
+ * NOTCOMPRESSIBLE_CONFIRMATION: Decreasing this value will make the
+ *	algorithm skip faster data segments considered "incompressible".
+ *	This may decrease compression ratio dramatically, but will be
+ *	faster on incompressible data. Increasing this value will make
+ *	the algorithm search more before declaring a segment "incompressible".
+ *	This could improve compression a bit, but will be slower on
+ *	incompressible data. The default value (6) is recommended.
+ */
+#define	NOTCOMPRESSIBLE_CONFIRMATION 6
+
+/*
+ * BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE: This will provide a boost to
+ * performance for big endian cpu, but the resulting compressed stream
+ * will be incompatible with little-endian CPU. You can set this option
+ * to 1 in situations where data will stay within closed environment.
+ * This option is useless on Little_Endian CPU (such as x86).
+ */
+/* #define	BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE 1 */
+
+/*
+ * CPU Feature Detection
+ */
+
+/* 32 or 64 bits ? */
+#if defined(_LP64)
+#define	LZ4_ARCH64 1
+#else
+#define	LZ4_ARCH64 0
+#endif
+
+/*
+ * Little Endian or Big Endian?
+ * Note: overwrite the below #define if you know your architecture endianness.
+ */
+#if defined(_ZFS_BIG_ENDIAN)
+#define	LZ4_BIG_ENDIAN 1
+#else
+/*
+ * Little Endian assumed. PDP Endian and other very rare endian format
+ * are unsupported.
+ */
+#undef LZ4_BIG_ENDIAN
+#endif
+
+/*
+ * Unaligned memory access is automatically enabled for "common" CPU,
+ * such as x86. For others CPU, the compiler will be more cautious, and
+ * insert extra code to ensure aligned access is respected. If you know
+ * your target CPU supports unaligned memory access, you may want to
+ * force this option manually to improve performance
+ */
+#if defined(__ARM_FEATURE_UNALIGNED)
+#define	LZ4_FORCE_UNALIGNED_ACCESS 1
+#endif
+
+/*
+ * Illumos : we can't use GCC's __builtin_ctz family of builtins in the
+ * kernel
+ * Linux : we can use GCC's __builtin_ctz family of builtins in the
+ * kernel
+ */
+#undef	LZ4_FORCE_SW_BITCOUNT
+#if defined(__sparc)
+#define	LZ4_FORCE_SW_BITCOUNT
+#endif
+
+/*
+ * Compiler Options
+ */
+/* Disable restrict */
+#define	restrict
+
+/*
+ * Linux : GCC_VERSION is defined as of 3.9-rc1, so undefine it.
+ * torvalds/linux@3f3f8d2f48acfd8ed3b8e6b7377935da57b27b16
+ */
+#ifdef GCC_VERSION
+#undef GCC_VERSION
+#endif
+
+#define	GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#if (GCC_VERSION >= 302) || (__INTEL_COMPILER >= 800) || defined(__clang__)
+#define	expect(expr, value)    (__builtin_expect((expr), (value)))
+#else
+#define	expect(expr, value)    (expr)
+#endif
+
+#ifndef likely
+#define	likely(expr)	expect((expr) != 0, 1)
+#endif
+
+#ifndef unlikely
+#define	unlikely(expr)	expect((expr) != 0, 0)
+#endif
+
+#define	lz4_bswap16(x) ((unsigned short int) ((((x) >> 8) & 0xffu) | \
+	(((x) & 0xffu) << 8)))
+
+/* Basic types */
+#define	BYTE	uint8_t
+#define	U16	uint16_t
+#define	U32	uint32_t
+#define	S32	int32_t
+#define	U64	uint64_t
+
+#ifndef LZ4_FORCE_UNALIGNED_ACCESS
+#pragma pack(1)
+#endif
+
+typedef struct _U16_S {
+	U16 v;
+} U16_S;
+typedef struct _U32_S {
+	U32 v;
+} U32_S;
+typedef struct _U64_S {
+	U64 v;
+} U64_S;
+
+#ifndef LZ4_FORCE_UNALIGNED_ACCESS
+#pragma pack()
+#endif
+
+#define	A64(x) (((U64_S *)(x))->v)
+#define	A32(x) (((U32_S *)(x))->v)
+#define	A16(x) (((U16_S *)(x))->v)
+
+/*
+ * Constants
+ */
+#define	MINMATCH 4
+
+#define	HASH_LOG COMPRESSIONLEVEL
+#define	HASHTABLESIZE (1 << HASH_LOG)
+#define	HASH_MASK (HASHTABLESIZE - 1)
+
+#define	SKIPSTRENGTH (NOTCOMPRESSIBLE_CONFIRMATION > 2 ? \
+	NOTCOMPRESSIBLE_CONFIRMATION : 2)
+
+#define	COPYLENGTH 8
+#define	LASTLITERALS 5
+#define	MFLIMIT (COPYLENGTH + MINMATCH)
+#define	MINLENGTH (MFLIMIT + 1)
+
+#define	MAXD_LOG 16
+#define	MAX_DISTANCE ((1 << MAXD_LOG) - 1)
+
+#define	ML_BITS 4
+#define	ML_MASK ((1U<<ML_BITS)-1)
+#define	RUN_BITS (8-ML_BITS)
+#define	RUN_MASK ((1U<<RUN_BITS)-1)
+
+
+/*
+ * Architecture-specific macros
+ */
+#if LZ4_ARCH64
+#define	STEPSIZE 8
+#define	UARCH U64
+#define	AARCH A64
+#define	LZ4_COPYSTEP(s, d)	A64(d) = A64(s); d += 8; s += 8;
+#define	LZ4_COPYPACKET(s, d)	LZ4_COPYSTEP(s, d)
+#define	LZ4_SECURECOPY(s, d, e)	if (d < e) LZ4_WILDCOPY(s, d, e)
+#define	HTYPE U32
+#define	INITBASE(base)		const BYTE* const base = ip
+#else /* !LZ4_ARCH64 */
+#define	STEPSIZE 4
+#define	UARCH U32
+#define	AARCH A32
+#define	LZ4_COPYSTEP(s, d)	A32(d) = A32(s); d += 4; s += 4;
+#define	LZ4_COPYPACKET(s, d)	LZ4_COPYSTEP(s, d); LZ4_COPYSTEP(s, d);
+#define	LZ4_SECURECOPY		LZ4_WILDCOPY
+#define	HTYPE const BYTE *
+#define	INITBASE(base)		const int base = 0
+#endif /* !LZ4_ARCH64 */
+
+#if (defined(LZ4_BIG_ENDIAN) && !defined(BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE))
+#define	LZ4_READ_LITTLEENDIAN_16(d, s, p) \
+	{ U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; }
+#define	LZ4_WRITE_LITTLEENDIAN_16(p, i) \
+	{ U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p += 2; }
+#else
+#define	LZ4_READ_LITTLEENDIAN_16(d, s, p) { d = (s) - A16(p); }
+#define	LZ4_WRITE_LITTLEENDIAN_16(p, v)  { A16(p) = v; p += 2; }
+#endif
+
+
+/* Local structures */
+struct refTables {
+	HTYPE hashTable[HASHTABLESIZE];
+};
+
+
+/* Macros */
+#define	LZ4_HASH_FUNCTION(i) (((i) * 2654435761U) >> ((MINMATCH * 8) - \
+	HASH_LOG))
+#define	LZ4_HASH_VALUE(p) LZ4_HASH_FUNCTION(A32(p))
+#define	LZ4_WILDCOPY(s, d, e) do { LZ4_COPYPACKET(s, d) } while (d < e);
+#define	LZ4_BLINDCOPY(s, d, l) { BYTE* e = (d) + l; LZ4_WILDCOPY(s, d, e); \
+	d = e; }
+
+
+/* Private functions */
+#if LZ4_ARCH64
+
+static inline int
+LZ4_NbCommonBytes(register U64 val)
+{
+#if defined(LZ4_BIG_ENDIAN)
+#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
+	!defined(LZ4_FORCE_SW_BITCOUNT)
+	return (__builtin_clzll(val) >> 3);
+#else
+	int r;
+	if (!(val >> 32)) {
+		r = 4;
+	} else {
+		r = 0;
+		val >>= 32;
+	}
+	if (!(val >> 16)) {
+		r += 2;
+		val >>= 8;
+	} else {
+		val >>= 24;
+	}
+	r += (!val);
+	return (r);
+#endif
+#else
+#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
+	!defined(LZ4_FORCE_SW_BITCOUNT)
+	return (__builtin_ctzll(val) >> 3);
+#else
+	static const int DeBruijnBytePos[64] =
+	    { 0, 0, 0, 0, 0, 1, 1, 2, 0, 3, 1, 3, 1, 4, 2, 7, 0, 2, 3, 6, 1, 5,
+		3, 5, 1, 3, 4, 4, 2, 5, 6, 7, 7, 0, 1, 2, 3, 3, 4, 6, 2, 6, 5,
+		5, 3, 4, 5, 6, 7, 1, 2, 4, 6, 4,
+		4, 5, 7, 2, 6, 5, 7, 6, 7, 7
+	};
+	return DeBruijnBytePos[((U64) ((val & -val) * 0x0218A392CDABBD3F)) >>
+	    58];
+#endif
+#endif
+}
+
+#else
+
+static inline int
+LZ4_NbCommonBytes(register U32 val)
+{
+#if defined(LZ4_BIG_ENDIAN)
+#if ((defined(__GNUC__) && (GCC_VERSION >= 304)) || defined(__clang__)) && \
+	!defined(LZ4_FORCE_SW_BITCOUNT)
+	return (__builtin_clz(val) >> 3);
+#else
+	int r;
+	if (!(val >> 16)) {
+		r = 2;
+		val >>= 8;
+	} else {
+		r = 0;
+		val >>= 24;
+	}
+	r += (!val);
+	return (r);
+#endif
+#else
+#if defined(__GNUC__) && (GCC_VERSION >= 304) && \
+	!defined(LZ4_FORCE_SW_BITCOUNT)
+	return (__builtin_ctz(val) >> 3);
+#else
+	static const int DeBruijnBytePos[32] = {
+		0, 0, 3, 0, 3, 1, 3, 0,
+		3, 2, 2, 1, 3, 2, 0, 1,
+		3, 3, 1, 2, 2, 2, 2, 0,
+		3, 1, 2, 0, 1, 0, 1, 1
+	};
+	return DeBruijnBytePos[((U32) ((val & -(S32) val) * 0x077CB531U)) >>
+	    27];
+#endif
+#endif
+}
+
+#endif
+
+/* Compression functions */
+
+static int
+LZ4_compressCtx(void *ctx, const char *source, char *dest, int isize,
+    int osize)
+{
+	struct refTables *srt = (struct refTables *)ctx;
+	HTYPE *HashTable = (HTYPE *) (srt->hashTable);
+
+	const BYTE *ip = (BYTE *) source;
+	INITBASE(base);
+	const BYTE *anchor = ip;
+	const BYTE *const iend = ip + isize;
+	const BYTE *const oend = (BYTE *) dest + osize;
+	const BYTE *const mflimit = iend - MFLIMIT;
+#define	matchlimit (iend - LASTLITERALS)
+
+	BYTE *op = (BYTE *) dest;
+
+	int len, length;
+	const int skipStrength = SKIPSTRENGTH;
+	U32 forwardH;
+
+
+	/* Init */
+	if (isize < MINLENGTH)
+		goto _last_literals;
+
+	/* First Byte */
+	HashTable[LZ4_HASH_VALUE(ip)] = ip - base;
+	ip++;
+	forwardH = LZ4_HASH_VALUE(ip);
+
+	/* Main Loop */
+	for (;;) {
+		int findMatchAttempts = (1U << skipStrength) + 3;
+		const BYTE *forwardIp = ip;
+		const BYTE *ref;
+		BYTE *token;
+
+		/* Find a match */
+		do {
+			U32 h = forwardH;
+			int step = findMatchAttempts++ >> skipStrength;
+			ip = forwardIp;
+			forwardIp = ip + step;
+
+			if (unlikely(forwardIp > mflimit)) {
+				goto _last_literals;
+			}
+
+			forwardH = LZ4_HASH_VALUE(forwardIp);
+			ref = base + HashTable[h];
+			HashTable[h] = ip - base;
+
+		} while ((ref < ip - MAX_DISTANCE) || (A32(ref) != A32(ip)));
+
+		/* Catch up */
+		while ((ip > anchor) && (ref > (BYTE *) source) &&
+		    unlikely(ip[-1] == ref[-1])) {
+			ip--;
+			ref--;
+		}
+
+		/* Encode Literal length */
+		length = ip - anchor;
+		token = op++;
+
+		/* Check output limit */
+		if (unlikely(op + length + (2 + 1 + LASTLITERALS) +
+		    (length >> 8) > oend))
+			return (0);
+
+		if (length >= (int)RUN_MASK) {
+			*token = (RUN_MASK << ML_BITS);
+			len = length - RUN_MASK;
+			for (; len > 254; len -= 255)
+				*op++ = 255;
+			*op++ = (BYTE)len;
+		} else
+			*token = (length << ML_BITS);
+
+		/* Copy Literals */
+		LZ4_BLINDCOPY(anchor, op, length);
+
+		_next_match:
+		/* Encode Offset */
+		LZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);
+
+		/* Start Counting */
+		ip += MINMATCH;
+		ref += MINMATCH;	/* MinMatch verified */
+		anchor = ip;
+		while (likely(ip < matchlimit - (STEPSIZE - 1))) {
+			UARCH diff = AARCH(ref) ^ AARCH(ip);
+			if (!diff) {
+				ip += STEPSIZE;
+				ref += STEPSIZE;
+				continue;
+			}
+			ip += LZ4_NbCommonBytes(diff);
+			goto _endCount;
+		}
+#if LZ4_ARCH64
+		if ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {
+			ip += 4;
+			ref += 4;
+		}
+#endif
+		if ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {
+			ip += 2;
+			ref += 2;
+		}
+		if ((ip < matchlimit) && (*ref == *ip))
+			ip++;
+		_endCount:
+
+		/* Encode MatchLength */
+		len = (ip - anchor);
+		/* Check output limit */
+		if (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))
+			return (0);
+		if (len >= (int)ML_MASK) {
+			*token += ML_MASK;
+			len -= ML_MASK;
+			for (; len > 509; len -= 510) {
+				*op++ = 255;
+				*op++ = 255;
+			}
+			if (len > 254) {
+				len -= 255;
+				*op++ = 255;
+			}
+			*op++ = (BYTE)len;
+		} else
+			*token += len;
+
+		/* Test end of chunk */
+		if (ip > mflimit) {
+			anchor = ip;
+			break;
+		}
+		/* Fill table */
+		HashTable[LZ4_HASH_VALUE(ip - 2)] = ip - 2 - base;
+
+		/* Test next position */
+		ref = base + HashTable[LZ4_HASH_VALUE(ip)];
+		HashTable[LZ4_HASH_VALUE(ip)] = ip - base;
+		if ((ref > ip - (MAX_DISTANCE + 1)) && (A32(ref) == A32(ip))) {
+			token = op++;
+			*token = 0;
+			goto _next_match;
+		}
+		/* Prepare next loop */
+		anchor = ip++;
+		forwardH = LZ4_HASH_VALUE(ip);
+	}
+
+	_last_literals:
+	/* Encode Last Literals */
+	{
+		int lastRun = iend - anchor;
+		if (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >
+		    oend)
+			return (0);
+		if (lastRun >= (int)RUN_MASK) {
+			*op++ = (RUN_MASK << ML_BITS);
+			lastRun -= RUN_MASK;
+			for (; lastRun > 254; lastRun -= 255) {
+				*op++ = 255;
+			}
+			*op++ = (BYTE)lastRun;
+		} else
+			*op++ = (lastRun << ML_BITS);
+		(void) memcpy(op, anchor, iend - anchor);
+		op += iend - anchor;
+	}
+
+	/* End */
+	return (int)(((char *)op) - dest);
+}
+
+
+
+/* Note : this function is valid only if isize < LZ4_64KLIMIT */
+#define	LZ4_64KLIMIT ((1 << 16) + (MFLIMIT - 1))
+#define	HASHLOG64K (HASH_LOG + 1)
+#define	HASH64KTABLESIZE (1U << HASHLOG64K)
+#define	LZ4_HASH64K_FUNCTION(i)	(((i) * 2654435761U) >> ((MINMATCH*8) - \
+	HASHLOG64K))
+#define	LZ4_HASH64K_VALUE(p)	LZ4_HASH64K_FUNCTION(A32(p))
+
+static int
+LZ4_compress64kCtx(void *ctx, const char *source, char *dest, int isize,
+    int osize)
+{
+	struct refTables *srt = (struct refTables *)ctx;
+	U16 *HashTable = (U16 *) (srt->hashTable);
+
+	const BYTE *ip = (BYTE *) source;
+	const BYTE *anchor = ip;
+	const BYTE *const base = ip;
+	const BYTE *const iend = ip + isize;
+	const BYTE *const oend = (BYTE *) dest + osize;
+	const BYTE *const mflimit = iend - MFLIMIT;
+#define	matchlimit (iend - LASTLITERALS)
+
+	BYTE *op = (BYTE *) dest;
+
+	int len, length;
+	const int skipStrength = SKIPSTRENGTH;
+	U32 forwardH;
+
+	/* Init */
+	if (isize < MINLENGTH)
+		goto _last_literals;
+
+	/* First Byte */
+	ip++;
+	forwardH = LZ4_HASH64K_VALUE(ip);
+
+	/* Main Loop */
+	for (;;) {
+		int findMatchAttempts = (1U << skipStrength) + 3;
+		const BYTE *forwardIp = ip;
+		const BYTE *ref;
+		BYTE *token;
+
+		/* Find a match */
+		do {
+			U32 h = forwardH;
+			int step = findMatchAttempts++ >> skipStrength;
+			ip = forwardIp;
+			forwardIp = ip + step;
+
+			if (forwardIp > mflimit) {
+				goto _last_literals;
+			}
+
+			forwardH = LZ4_HASH64K_VALUE(forwardIp);
+			ref = base + HashTable[h];
+			HashTable[h] = ip - base;
+
+		} while (A32(ref) != A32(ip));
+
+		/* Catch up */
+		while ((ip > anchor) && (ref > (BYTE *) source) &&
+		    (ip[-1] == ref[-1])) {
+			ip--;
+			ref--;
+		}
+
+		/* Encode Literal length */
+		length = ip - anchor;
+		token = op++;
+
+		/* Check output limit */
+		if (unlikely(op + length + (2 + 1 + LASTLITERALS) +
+		    (length >> 8) > oend))
+			return (0);
+
+		if (length >= (int)RUN_MASK) {
+			*token = (RUN_MASK << ML_BITS);
+			len = length - RUN_MASK;
+			for (; len > 254; len -= 255)
+				*op++ = 255;
+			*op++ = (BYTE)len;
+		} else
+			*token = (length << ML_BITS);
+
+		/* Copy Literals */
+		LZ4_BLINDCOPY(anchor, op, length);
+
+		_next_match:
+		/* Encode Offset */
+		LZ4_WRITE_LITTLEENDIAN_16(op, ip - ref);
+
+		/* Start Counting */
+		ip += MINMATCH;
+		ref += MINMATCH;	/* MinMatch verified */
+		anchor = ip;
+		while (ip < matchlimit - (STEPSIZE - 1)) {
+			UARCH diff = AARCH(ref) ^ AARCH(ip);
+			if (!diff) {
+				ip += STEPSIZE;
+				ref += STEPSIZE;
+				continue;
+			}
+			ip += LZ4_NbCommonBytes(diff);
+			goto _endCount;
+		}
+#if LZ4_ARCH64
+		if ((ip < (matchlimit - 3)) && (A32(ref) == A32(ip))) {
+			ip += 4;
+			ref += 4;
+		}
+#endif
+		if ((ip < (matchlimit - 1)) && (A16(ref) == A16(ip))) {
+			ip += 2;
+			ref += 2;
+		}
+		if ((ip < matchlimit) && (*ref == *ip))
+			ip++;
+		_endCount:
+
+		/* Encode MatchLength */
+		len = (ip - anchor);
+		/* Check output limit */
+		if (unlikely(op + (1 + LASTLITERALS) + (len >> 8) > oend))
+			return (0);
+		if (len >= (int)ML_MASK) {
+			*token += ML_MASK;
+			len -= ML_MASK;
+			for (; len > 509; len -= 510) {
+				*op++ = 255;
+				*op++ = 255;
+			}
+			if (len > 254) {
+				len -= 255;
+				*op++ = 255;
+			}
+			*op++ = (BYTE)len;
+		} else
+			*token += len;
+
+		/* Test end of chunk */
+		if (ip > mflimit) {
+			anchor = ip;
+			break;
+		}
+		/* Fill table */
+		HashTable[LZ4_HASH64K_VALUE(ip - 2)] = ip - 2 - base;
+
+		/* Test next position */
+		ref = base + HashTable[LZ4_HASH64K_VALUE(ip)];
+		HashTable[LZ4_HASH64K_VALUE(ip)] = ip - base;
+		if (A32(ref) == A32(ip)) {
+			token = op++;
+			*token = 0;
+			goto _next_match;
+		}
+		/* Prepare next loop */
+		anchor = ip++;
+		forwardH = LZ4_HASH64K_VALUE(ip);
+	}
+
+	_last_literals:
+	/* Encode Last Literals */
+	{
+		int lastRun = iend - anchor;
+		if (op + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) >
+		    oend)
+			return (0);
+		if (lastRun >= (int)RUN_MASK) {
+			*op++ = (RUN_MASK << ML_BITS);
+			lastRun -= RUN_MASK;
+			for (; lastRun > 254; lastRun -= 255)
+				*op++ = 255;
+			*op++ = (BYTE)lastRun;
+		} else
+			*op++ = (lastRun << ML_BITS);
+		(void) memcpy(op, anchor, iend - anchor);
+		op += iend - anchor;
+	}
+
+	/* End */
+	return (int)(((char *)op) - dest);
+}
+
+static int
+real_LZ4_compress(const char *source, char *dest, int isize, int osize)
+{
+	void *ctx;
+	int result;
+
+	ctx = lz4_alloc(KM_SLEEP);
+
+	/*
+	 * out of kernel memory, gently fall through - this will disable
+	 * compression in zio_compress_data
+	 */
+	if (ctx == NULL)
+		return (0);
+
+	memset(ctx, 0, sizeof (struct refTables));
+
+	if (isize < LZ4_64KLIMIT)
+		result = LZ4_compress64kCtx(ctx, source, dest, isize, osize);
+	else
+		result = LZ4_compressCtx(ctx, source, dest, isize, osize);
+
+	lz4_free(ctx);
+	return (result);
+}
+
+#ifdef __FreeBSD__
+/*
+ * FreeBSD has 4, 8 and 16 KB malloc zones which can be used here.
+ * Should struct refTables get resized this may need to be revisited, hence
+ * compiler-time asserts.
+ */
+_Static_assert(sizeof(struct refTables) <= 16384,
+    "refTables too big for malloc");
+_Static_assert((sizeof(struct refTables) % 4096) == 0,
+    "refTables not a multiple of page size");
+#else
+#define ZFS_LZ4_USE_CACHE
+#endif
+
+#ifdef ZFS_LZ4_USE_CACHE
+static kmem_cache_t *lz4_cache;
+#endif
+
+#ifdef ZFS_LZ4_USE_CACHE
+void
+lz4_init(void)
+{
+	lz4_cache = kmem_cache_create("lz4_cache",
+	    sizeof (struct refTables), 0, NULL, NULL, NULL, NULL, NULL, 0);
+}
+
+void
+lz4_fini(void)
+{
+	if (lz4_cache) {
+		kmem_cache_destroy(lz4_cache);
+		lz4_cache = NULL;
+	}
+}
+
+static void *
+lz4_alloc(int flags)
+{
+	ASSERT(lz4_cache != NULL);
+	return (kmem_cache_alloc(lz4_cache, flags));
+}
+ 
+static void
+lz4_free(void *ctx)
+{
+	kmem_cache_free(lz4_cache, ctx);
+}
+#else
+void
+lz4_init(void)
+{
+}
+
+void
+lz4_fini(void)
+{
+}
+
+static void *
+lz4_alloc(int flags)
+{
+	return (kmem_alloc(sizeof (struct refTables), flags));
+}
+
+static void
+lz4_free(void *ctx)
+{
+	kmem_free(ctx, sizeof (struct refTables));
+}
+#endif
diff --git a/sys/contrib/openzfs/module/zfs/lzjb.c b/sys/contrib/openzfs/module/zfs/lzjb.c
index a478e64c5141..1c536b110318 100644
--- a/sys/contrib/openzfs/module/zfs/lzjb.c
+++ b/sys/contrib/openzfs/module/zfs/lzjb.c
@@ -45,10 +45,10 @@
 #define	OFFSET_MASK	((1 << (16 - MATCH_BITS)) - 1)
 #define	LEMPEL_SIZE	1024
 
-/*ARGSUSED*/
 size_t
 lzjb_compress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)
 {
+	(void) n;
 	uchar_t *src = s_start;
 	uchar_t *dst = d_start;
 	uchar_t *cpy;
@@ -100,10 +100,10 @@ lzjb_compress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)
 	return (dst - (uchar_t *)d_start);
 }
 
-/*ARGSUSED*/
 int
 lzjb_decompress(void *s_start, void *d_start, size_t s_len, size_t d_len, int n)
 {
+	(void) s_len, (void) n;
 	uchar_t *src = s_start;
 	uchar_t *dst = d_start;
 	uchar_t *d_end = (uchar_t *)d_start + d_len;
diff --git a/sys/contrib/openzfs/module/zfs/metaslab.c b/sys/contrib/openzfs/module/zfs/metaslab.c
index d1fee70f004b..145f79fae3df 100644
--- a/sys/contrib/openzfs/module/zfs/metaslab.c
+++ b/sys/contrib/openzfs/module/zfs/metaslab.c
@@ -51,7 +51,7 @@
  * operation, we will try to write this amount of data to a top-level vdev
  * before moving on to the next one.
  */
-unsigned long metaslab_aliquot = 512 << 10;
+static unsigned long metaslab_aliquot = 512 << 10;
 
 /*
  * For testing, make some blocks above a certain size be gang blocks.
@@ -96,7 +96,7 @@ int zfs_condense_pct = 200;
  * uncondensed size consumes greater than zfs_metaslab_condense_block_threshold
  * blocks.
  */
-int zfs_metaslab_condense_block_threshold = 4;
+static const int zfs_metaslab_condense_block_threshold = 4;
 
 /*
  * The zfs_mg_noalloc_threshold defines which metaslab groups should
@@ -111,7 +111,7 @@ int zfs_metaslab_condense_block_threshold = 4;
  * eligible to allocate on any metaslab group. The default value of 0 means
  * no metaslab group will be excluded based on this criterion.
  */
-int zfs_mg_noalloc_threshold = 0;
+static int zfs_mg_noalloc_threshold = 0;
 
 /*
  * Metaslab groups are considered eligible for allocations if their
@@ -135,7 +135,7 @@ int zfs_mg_noalloc_threshold = 0;
  * enough to avoid hitting the speed bump on pools that are being pushed
  * to the edge.
  */
-int zfs_mg_fragmentation_threshold = 95;
+static int zfs_mg_fragmentation_threshold = 95;
 
 /*
  * Allow metaslabs to keep their active state as long as their fragmentation
@@ -143,17 +143,17 @@ int zfs_mg_fragmentation_threshold = 95;
  * active metaslab that exceeds this threshold will no longer keep its active
  * status allowing better metaslabs to be selected.
  */
-int zfs_metaslab_fragmentation_threshold = 70;
+static int zfs_metaslab_fragmentation_threshold = 70;
 
 /*
  * When set will load all metaslabs when pool is first opened.
  */
-int metaslab_debug_load = 0;
+int metaslab_debug_load = B_FALSE;
 
 /*
  * When set will prevent metaslabs from being unloaded.
  */
-int metaslab_debug_unload = 0;
+static int metaslab_debug_unload = B_FALSE;
 
 /*
  * Minimum size which forces the dynamic allocator to change
@@ -184,14 +184,14 @@ int metaslab_df_free_pct = 4;
  * With the default setting of 16MB this is 16*1024 (with ashift=9) or
  * 2048 (with ashift=12).
  */
-int metaslab_df_max_search = 16 * 1024 * 1024;
+static int metaslab_df_max_search = 16 * 1024 * 1024;
 
 /*
  * Forces the metaslab_block_picker function to search for at least this many
  * segments forwards until giving up on finding a segment that the allocation
  * will fit into.
  */
-uint32_t metaslab_min_search_count = 100;
+static const uint32_t metaslab_min_search_count = 100;
 
 /*
  * If we are not searching forward (due to metaslab_df_max_search,
@@ -200,7 +200,7 @@ uint32_t metaslab_min_search_count = 100;
  * segment.  If it is not set, we will use a segment of exactly the requested
  * size (or larger).
  */
-int metaslab_df_use_largest_segment = B_FALSE;
+static int metaslab_df_use_largest_segment = B_FALSE;
 
 /*
  * Percentage of all cpus that can be used by the metaslab taskq.
@@ -215,8 +215,8 @@ int metaslab_load_pct = 50;
  * unloaded sooner.  These settings are intended to be generous -- to keep
  * metaslabs loaded for a long time, reducing the rate of metaslab loading.
  */
-int metaslab_unload_delay = 32;
-int metaslab_unload_delay_ms = 10 * 60 * 1000; /* ten minutes */
+static int metaslab_unload_delay = 32;
+static int metaslab_unload_delay_ms = 10 * 60 * 1000; /* ten minutes */
 
 /*
  * Max number of metaslabs per group to preload.
@@ -226,45 +226,45 @@ int metaslab_preload_limit = 10;
 /*
  * Enable/disable preloading of metaslab.
  */
-int metaslab_preload_enabled = B_TRUE;
+static int metaslab_preload_enabled = B_TRUE;
 
 /*
  * Enable/disable fragmentation weighting on metaslabs.
  */
-int metaslab_fragmentation_factor_enabled = B_TRUE;
+static int metaslab_fragmentation_factor_enabled = B_TRUE;
 
 /*
  * Enable/disable lba weighting (i.e. outer tracks are given preference).
  */
-int metaslab_lba_weighting_enabled = B_TRUE;
+static int metaslab_lba_weighting_enabled = B_TRUE;
 
 /*
  * Enable/disable metaslab group biasing.
  */
-int metaslab_bias_enabled = B_TRUE;
+static int metaslab_bias_enabled = B_TRUE;
 
 /*
  * Enable/disable remapping of indirect DVAs to their concrete vdevs.
  */
-boolean_t zfs_remap_blkptr_enable = B_TRUE;
+static const boolean_t zfs_remap_blkptr_enable = B_TRUE;
 
 /*
  * Enable/disable segment-based metaslab selection.
  */
-int zfs_metaslab_segment_weight_enabled = B_TRUE;
+static int zfs_metaslab_segment_weight_enabled = B_TRUE;
 
 /*
  * When using segment-based metaslab selection, we will continue
  * allocating from the active metaslab until we have exhausted
  * zfs_metaslab_switch_threshold of its buckets.
  */
-int zfs_metaslab_switch_threshold = 2;
+static int zfs_metaslab_switch_threshold = 2;
 
 /*
  * Internal switch to enable/disable the metaslab allocation tracing
  * facility.
  */
-boolean_t metaslab_trace_enabled = B_FALSE;
+static const boolean_t metaslab_trace_enabled = B_FALSE;
 
 /*
  * Maximum entries that the metaslab allocation tracing facility will keep
@@ -274,32 +274,32 @@ boolean_t metaslab_trace_enabled = B_FALSE;
  * to every exceed this value. In debug mode, the system will panic if this
  * limit is ever reached allowing for further investigation.
  */
-uint64_t metaslab_trace_max_entries = 5000;
+static const uint64_t metaslab_trace_max_entries = 5000;
 
 /*
  * Maximum number of metaslabs per group that can be disabled
  * simultaneously.
  */
-int max_disabled_ms = 3;
+static const int max_disabled_ms = 3;
 
 /*
  * Time (in seconds) to respect ms_max_size when the metaslab is not loaded.
  * To avoid 64-bit overflow, don't set above UINT32_MAX.
  */
-unsigned long zfs_metaslab_max_size_cache_sec = 3600; /* 1 hour */
+static unsigned long zfs_metaslab_max_size_cache_sec = 1 * 60 * 60; /* 1 hour */
 
 /*
  * Maximum percentage of memory to use on storing loaded metaslabs. If loading
  * a metaslab would take it over this percentage, the oldest selected metaslab
  * is automatically unloaded.
  */
-int zfs_metaslab_mem_limit = 25;
+static int zfs_metaslab_mem_limit = 25;
 
 /*
  * Force the per-metaslab range trees to use 64-bit integers to store
  * segments. Used for debugging purposes.
  */
-boolean_t zfs_metaslab_force_large_segs = B_FALSE;
+static const boolean_t zfs_metaslab_force_large_segs = B_FALSE;
 
 /*
  * By default we only store segments over a certain size in the size-sorted
@@ -308,7 +308,7 @@ boolean_t zfs_metaslab_force_large_segs = B_FALSE;
  * improves load and unload times at the cost of causing us to use slightly
  * larger segments than we would otherwise in some cases.
  */
-uint32_t metaslab_by_size_min_shift = 14;
+static const uint32_t metaslab_by_size_min_shift = 14;
 
 /*
  * If not set, we will first try normal allocation.  If that fails then
@@ -321,7 +321,7 @@ uint32_t metaslab_by_size_min_shift = 14;
  * allocation.  If that fails we will do a "try hard" gang allocation.  If
  * that fails then we will have a multi-layer gang block.
  */
-int zfs_metaslab_try_hard_before_gang = B_FALSE;
+static int zfs_metaslab_try_hard_before_gang = B_FALSE;
 
 /*
  * When not trying hard, we only consider the best zfs_metaslab_find_max_tries
@@ -337,7 +337,7 @@ int zfs_metaslab_try_hard_before_gang = B_FALSE;
  * subsequent metaslab has ms_max_size >60KB (but fewer segments in this
  * bucket, and therefore a lower weight).
  */
-int zfs_metaslab_find_max_tries = 100;
+static int zfs_metaslab_find_max_tries = 100;
 
 static uint64_t metaslab_weight(metaslab_t *, boolean_t);
 static void metaslab_set_fragmentation(metaslab_t *, boolean_t);
@@ -370,7 +370,7 @@ static metaslab_stats_t metaslab_stats = {
 	atomic_inc_64(&metaslab_stats.stat.value.ui64);
 
 
-kstat_t *metaslab_ksp;
+static kstat_t *metaslab_ksp;
 
 void
 metaslab_stat_init(void)
@@ -406,7 +406,7 @@ metaslab_stat_fini(void)
  * ==========================================================================
  */
 metaslab_class_t *
-metaslab_class_create(spa_t *spa, metaslab_ops_t *ops)
+metaslab_class_create(spa_t *spa, const metaslab_ops_t *ops)
 {
 	metaslab_class_t *mc;
 
@@ -1406,7 +1406,6 @@ metaslab_size_tree_full_load(range_tree_t *rt)
  * Create any block allocator specific components. The current allocators
  * rely on using both a size-ordered range_tree_t and an array of uint64_t's.
  */
-/* ARGSUSED */
 static void
 metaslab_rt_create(range_tree_t *rt, void *arg)
 {
@@ -1431,10 +1430,10 @@ metaslab_rt_create(range_tree_t *rt, void *arg)
 	mrap->mra_floor_shift = metaslab_by_size_min_shift;
 }
 
-/* ARGSUSED */
 static void
 metaslab_rt_destroy(range_tree_t *rt, void *arg)
 {
+	(void) rt;
 	metaslab_rt_arg_t *mrap = arg;
 	zfs_btree_t *size_tree = mrap->mra_bt;
 
@@ -1442,7 +1441,6 @@ metaslab_rt_destroy(range_tree_t *rt, void *arg)
 	kmem_free(mrap, sizeof (*mrap));
 }
 
-/* ARGSUSED */
 static void
 metaslab_rt_add(range_tree_t *rt, range_seg_t *rs, void *arg)
 {
@@ -1456,7 +1454,6 @@ metaslab_rt_add(range_tree_t *rt, range_seg_t *rs, void *arg)
 	zfs_btree_add(size_tree, rs);
 }
 
-/* ARGSUSED */
 static void
 metaslab_rt_remove(range_tree_t *rt, range_seg_t *rs, void *arg)
 {
@@ -1470,7 +1467,6 @@ metaslab_rt_remove(range_tree_t *rt, range_seg_t *rs, void *arg)
 	zfs_btree_remove(size_tree, rs);
 }
 
-/* ARGSUSED */
 static void
 metaslab_rt_vacate(range_tree_t *rt, void *arg)
 {
@@ -1482,7 +1478,7 @@ metaslab_rt_vacate(range_tree_t *rt, void *arg)
 	metaslab_rt_create(rt, arg);
 }
 
-static range_tree_ops_t metaslab_rt_ops = {
+static const range_tree_ops_t metaslab_rt_ops = {
 	.rtop_create = metaslab_rt_create,
 	.rtop_destroy = metaslab_rt_destroy,
 	.rtop_add = metaslab_rt_add,
@@ -1716,11 +1712,9 @@ metaslab_df_alloc(metaslab_t *msp, uint64_t size)
 	return (offset);
 }
 
-static metaslab_ops_t metaslab_df_ops = {
+const metaslab_ops_t zfs_metaslab_ops = {
 	metaslab_df_alloc
 };
-
-metaslab_ops_t *zfs_metaslab_ops = &metaslab_df_ops;
 #endif /* WITH_DF_BLOCK_ALLOCATOR */
 
 #if defined(WITH_CF_BLOCK_ALLOCATOR)
@@ -1766,11 +1760,9 @@ metaslab_cf_alloc(metaslab_t *msp, uint64_t size)
 	return (offset);
 }
 
-static metaslab_ops_t metaslab_cf_ops = {
+const metaslab_ops_t zfs_metaslab_ops = {
 	metaslab_cf_alloc
 };
-
-metaslab_ops_t *zfs_metaslab_ops = &metaslab_cf_ops;
 #endif /* WITH_CF_BLOCK_ALLOCATOR */
 
 #if defined(WITH_NDF_BLOCK_ALLOCATOR)
@@ -1830,11 +1822,9 @@ metaslab_ndf_alloc(metaslab_t *msp, uint64_t size)
 	return (-1ULL);
 }
 
-static metaslab_ops_t metaslab_ndf_ops = {
+const metaslab_ops_t zfs_metaslab_ops = {
 	metaslab_ndf_alloc
 };
-
-metaslab_ops_t *zfs_metaslab_ops = &metaslab_ndf_ops;
 #endif /* WITH_NDF_BLOCK_ALLOCATOR */
 
 
@@ -2240,6 +2230,8 @@ metaslab_potentially_evict(metaslab_class_t *mc)
 			inuse = spl_kmem_cache_inuse(zfs_btree_leaf_cache);
 		}
 	}
+#else
+	(void) mc, (void) zfs_metaslab_mem_limit;
 #endif
 }
 
@@ -2857,7 +2849,7 @@ metaslab_fini(metaslab_t *msp)
  * of the table. Since the fragmentation value is never stored on disk, it
  * is possible to change these calculations in the future.
  */
-int zfs_frag_table[FRAGMENTATION_TABLE_SIZE] = {
+static const int zfs_frag_table[FRAGMENTATION_TABLE_SIZE] = {
 	100,	/* 512B	*/
 	100,	/* 1K	*/
 	98,	/* 2K	*/
@@ -4721,7 +4713,6 @@ metaslab_active_mask_verify(metaslab_t *msp)
 	}
 }
 
-/* ARGSUSED */
 static uint64_t
 metaslab_group_alloc_normal(metaslab_group_t *mg, zio_alloc_list_t *zal,
     uint64_t asize, uint64_t txg, boolean_t want_unique, dva_t *dva, int d,
@@ -5347,11 +5338,11 @@ metaslab_free_concrete(vdev_t *vd, uint64_t offset, uint64_t asize,
 	mutex_exit(&msp->ms_lock);
 }
 
-/* ARGSUSED */
 void
 metaslab_free_impl_cb(uint64_t inner_offset, vdev_t *vd, uint64_t offset,
     uint64_t size, void *arg)
 {
+	(void) inner_offset;
 	boolean_t *checkpoint = arg;
 
 	ASSERT3P(checkpoint, !=, NULL);
@@ -5717,11 +5708,11 @@ typedef struct metaslab_claim_cb_arg_t {
 	int		mcca_error;
 } metaslab_claim_cb_arg_t;
 
-/* ARGSUSED */
 static void
 metaslab_claim_impl_cb(uint64_t inner_offset, vdev_t *vd, uint64_t offset,
     uint64_t size, void *arg)
 {
+	(void) inner_offset;
 	metaslab_claim_cb_arg_t *mcca_arg = arg;
 
 	if (mcca_arg->mcca_error == 0) {
@@ -5973,11 +5964,12 @@ metaslab_fastwrite_unmark(spa_t *spa, const blkptr_t *bp)
 	spa_config_exit(spa, SCL_VDEV, FTAG);
 }
 
-/* ARGSUSED */
 static void
 metaslab_check_free_impl_cb(uint64_t inner, vdev_t *vd, uint64_t offset,
     uint64_t size, void *arg)
 {
+	(void) inner, (void) arg;
+
 	if (vd->vdev_ops == &vdev_indirect_ops)
 		return;
 
diff --git a/sys/contrib/openzfs/module/zfs/mmp.c b/sys/contrib/openzfs/module/zfs/mmp.c
index f67a4eb22a2d..abdce3a32e6a 100644
--- a/sys/contrib/openzfs/module/zfs/mmp.c
+++ b/sys/contrib/openzfs/module/zfs/mmp.c
@@ -186,7 +186,7 @@ uint_t zfs_multihost_import_intervals = MMP_DEFAULT_IMPORT_INTERVALS;
  */
 uint_t zfs_multihost_fail_intervals = MMP_DEFAULT_FAIL_INTERVALS;
 
-char *mmp_tag = "mmp_write_uberblock";
+static void *const mmp_tag = "mmp_write_uberblock";
 static void mmp_thread(void *arg);
 
 void
diff --git a/sys/contrib/openzfs/module/zfs/multilist.c b/sys/contrib/openzfs/module/zfs/multilist.c
index 8bbc9b376ae0..bad1674d29f1 100644
--- a/sys/contrib/openzfs/module/zfs/multilist.c
+++ b/sys/contrib/openzfs/module/zfs/multilist.c
@@ -36,6 +36,8 @@ multilist_d2l(multilist_t *ml, void *obj)
 {
 	return ((multilist_node_t *)((char *)obj + ml->ml_offset));
 }
+#else
+#define	multilist_d2l(ml, obj) ((void) sizeof (ml), (void) sizeof (obj), NULL)
 #endif
 
 /*
diff --git a/sys/contrib/openzfs/module/zfs/range_tree.c b/sys/contrib/openzfs/module/zfs/range_tree.c
index 595918e5a742..f9fb97476b64 100644
--- a/sys/contrib/openzfs/module/zfs/range_tree.c
+++ b/sys/contrib/openzfs/module/zfs/range_tree.c
@@ -188,8 +188,8 @@ range_tree_seg_gap_compare(const void *x1, const void *x2)
 }
 
 range_tree_t *
-range_tree_create_impl(range_tree_ops_t *ops, range_seg_type_t type, void *arg,
-    uint64_t start, uint64_t shift,
+range_tree_create_impl(const range_tree_ops_t *ops, range_seg_type_t type,
+    void *arg, uint64_t start, uint64_t shift,
     int (*zfs_btree_compare) (const void *, const void *),
     uint64_t gap)
 {
@@ -232,7 +232,7 @@ range_tree_create_impl(range_tree_ops_t *ops, range_seg_type_t type, void *arg,
 }
 
 range_tree_t *
-range_tree_create(range_tree_ops_t *ops, range_seg_type_t type,
+range_tree_create(const range_tree_ops_t *ops, range_seg_type_t type,
     void *arg, uint64_t start, uint64_t shift)
 {
 	return (range_tree_create_impl(ops, type, arg, start, shift, NULL, 0));
@@ -741,7 +741,6 @@ range_tree_is_empty(range_tree_t *rt)
 	return (range_tree_space(rt) == 0);
 }
 
-/* ARGSUSED */
 void
 rt_btree_create(range_tree_t *rt, void *arg)
 {
@@ -764,35 +763,34 @@ rt_btree_create(range_tree_t *rt, void *arg)
 	zfs_btree_create(size_tree, rt->rt_btree_compare, size);
 }
 
-/* ARGSUSED */
 void
 rt_btree_destroy(range_tree_t *rt, void *arg)
 {
+	(void) rt;
 	zfs_btree_t *size_tree = arg;
 	ASSERT0(zfs_btree_numnodes(size_tree));
 
 	zfs_btree_destroy(size_tree);
 }
 
-/* ARGSUSED */
 void
 rt_btree_add(range_tree_t *rt, range_seg_t *rs, void *arg)
 {
+	(void) rt;
 	zfs_btree_t *size_tree = arg;
 
 	zfs_btree_add(size_tree, rs);
 }
 
-/* ARGSUSED */
 void
 rt_btree_remove(range_tree_t *rt, range_seg_t *rs, void *arg)
 {
+	(void) rt;
 	zfs_btree_t *size_tree = arg;
 
 	zfs_btree_remove(size_tree, rs);
 }
 
-/* ARGSUSED */
 void
 rt_btree_vacate(range_tree_t *rt, void *arg)
 {
@@ -803,7 +801,7 @@ rt_btree_vacate(range_tree_t *rt, void *arg)
 	rt_btree_create(rt, arg);
 }
 
-range_tree_ops_t rt_btree_ops = {
+const range_tree_ops_t rt_btree_ops = {
 	.rtop_create = rt_btree_create,
 	.rtop_destroy = rt_btree_destroy,
 	.rtop_add = rt_btree_add,
diff --git a/sys/contrib/openzfs/module/zfs/refcount.c b/sys/contrib/openzfs/module/zfs/refcount.c
index 35a379dded69..390b2fdedc70 100644
--- a/sys/contrib/openzfs/module/zfs/refcount.c
+++ b/sys/contrib/openzfs/module/zfs/refcount.c
@@ -26,15 +26,15 @@
 #include <sys/zfs_context.h>
 #include <sys/zfs_refcount.h>
 
+#ifdef	ZFS_DEBUG
 /*
  * Reference count tracking is disabled by default.  It's memory requirements
  * are reasonable, however as implemented it consumes a significant amount of
  * cpu time.  Until its performance is improved it should be manually enabled.
  */
-int reference_tracking_enable = FALSE;
-int reference_history = 3; /* tunable */
+int reference_tracking_enable = B_FALSE;
+static int reference_history = 3; /* tunable */
 
-#ifdef	ZFS_DEBUG
 static kmem_cache_t *reference_cache;
 static kmem_cache_t *reference_history_cache;
 
@@ -327,10 +327,10 @@ EXPORT_SYMBOL(zfs_refcount_remove);
 EXPORT_SYMBOL(zfs_refcount_held);
 
 /* BEGIN CSTYLED */
-ZFS_MODULE_PARAM(zfs, ,reference_tracking_enable, INT, ZMOD_RW,
+ZFS_MODULE_PARAM(zfs, , reference_tracking_enable, INT, ZMOD_RW,
 	"Track reference holders to refcount_t objects");
 
-ZFS_MODULE_PARAM(zfs, ,reference_history, INT, ZMOD_RW,
+ZFS_MODULE_PARAM(zfs, , reference_history, INT, ZMOD_RW,
 	"Maximum reference holders being tracked");
 /* END CSTYLED */
 #endif	/* ZFS_DEBUG */
diff --git a/sys/contrib/openzfs/module/zfs/sa.c b/sys/contrib/openzfs/module/zfs/sa.c
index 2604a7513ecf..a078af159c1f 100644
--- a/sys/contrib/openzfs/module/zfs/sa.c
+++ b/sys/contrib/openzfs/module/zfs/sa.c
@@ -141,7 +141,7 @@ static int sa_modify_attrs(sa_handle_t *hdl, sa_attr_type_t newattr,
     sa_data_op_t action, sa_data_locator_t *locator, void *datastart,
     uint16_t buflen, dmu_tx_t *tx);
 
-arc_byteswap_func_t sa_bswap_table[] = {
+static const arc_byteswap_func_t sa_bswap_table[] = {
 	byteswap_uint64_array,
 	byteswap_uint32_array,
 	byteswap_uint16_array,
@@ -178,7 +178,7 @@ do {								\
  * won't have the registry.  Only objsets of type ZFS_TYPE_FILESYSTEM will
  * use this static table.
  */
-sa_attr_reg_t sa_legacy_attrs[] = {
+static const sa_attr_reg_t sa_legacy_attrs[] = {
 	{"ZPL_ATIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 0},
 	{"ZPL_MTIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 1},
 	{"ZPL_CTIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 2},
@@ -200,32 +200,32 @@ sa_attr_reg_t sa_legacy_attrs[] = {
 /*
  * This is only used for objects of type DMU_OT_ZNODE
  */
-sa_attr_type_t sa_legacy_zpl_layout[] = {
+static const sa_attr_type_t sa_legacy_zpl_layout[] = {
     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
 };
 
 /*
  * Special dummy layout used for buffers with no attributes.
  */
-sa_attr_type_t sa_dummy_zpl_layout[] = { 0 };
+static const sa_attr_type_t sa_dummy_zpl_layout[] = { 0 };
 
-static int sa_legacy_attr_count = ARRAY_SIZE(sa_legacy_attrs);
+static const size_t sa_legacy_attr_count = ARRAY_SIZE(sa_legacy_attrs);
 static kmem_cache_t *sa_cache = NULL;
 
-/*ARGSUSED*/
 static int
 sa_cache_constructor(void *buf, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	sa_handle_t *hdl = buf;
 
 	mutex_init(&hdl->sa_lock, NULL, MUTEX_DEFAULT, NULL);
 	return (0);
 }
 
-/*ARGSUSED*/
 static void
 sa_cache_destructor(void *buf, void *unused)
 {
+	(void) unused;
 	sa_handle_t *hdl = buf;
 	mutex_destroy(&hdl->sa_lock);
 }
@@ -285,12 +285,11 @@ sa_layout_equal(sa_lot_t *tbf, sa_attr_type_t *attrs, int count)
 #define	SA_ATTR_HASH(attr) (zfs_crc64_table[(-1ULL ^ attr) & 0xFF])
 
 static uint64_t
-sa_layout_info_hash(sa_attr_type_t *attrs, int attr_count)
+sa_layout_info_hash(const sa_attr_type_t *attrs, int attr_count)
 {
-	int i;
 	uint64_t crc = -1ULL;
 
-	for (i = 0; i != attr_count; i++)
+	for (int i = 0; i != attr_count; i++)
 		crc ^= SA_ATTR_HASH(attrs[i]);
 
 	return (crc);
@@ -402,7 +401,7 @@ sa_attr_op(sa_handle_t *hdl, sa_bulk_attr_t *bulk, int count,
 }
 
 static sa_lot_t *
-sa_add_layout_entry(objset_t *os, sa_attr_type_t *attrs, int attr_count,
+sa_add_layout_entry(objset_t *os, const sa_attr_type_t *attrs, int attr_count,
     uint64_t lot_num, uint64_t hash, boolean_t zapadd, dmu_tx_t *tx)
 {
 	sa_os_t *sa = os->os_sa;
@@ -831,7 +830,7 @@ sa_free_attr_table(sa_os_t *sa)
 }
 
 static int
-sa_attr_table_setup(objset_t *os, sa_attr_reg_t *reg_attrs, int count)
+sa_attr_table_setup(objset_t *os, const sa_attr_reg_t *reg_attrs, int count)
 {
 	sa_os_t *sa = os->os_sa;
 	uint64_t sa_attr_count = 0;
@@ -992,8 +991,8 @@ sa_attr_table_setup(objset_t *os, sa_attr_reg_t *reg_attrs, int count)
 }
 
 int
-sa_setup(objset_t *os, uint64_t sa_obj, sa_attr_reg_t *reg_attrs, int count,
-    sa_attr_type_t **user_table)
+sa_setup(objset_t *os, uint64_t sa_obj, const sa_attr_reg_t *reg_attrs,
+    int count, sa_attr_type_t **user_table)
 {
 	zap_cursor_t zc;
 	zap_attribute_t za;
@@ -1218,11 +1217,11 @@ sa_attr_iter(objset_t *os, sa_hdr_phys_t *hdr, dmu_object_type_t type,
 	}
 }
 
-/*ARGSUSED*/
 static void
 sa_byteswap_cb(void *hdr, void *attr_addr, sa_attr_type_t attr,
     uint16_t length, int length_idx, boolean_t variable_length, void *userp)
 {
+	(void) hdr, (void) length_idx, (void) variable_length;
 	sa_handle_t *hdl = userp;
 	sa_os_t *sa = hdl->sa_os->os_sa;
 
@@ -1309,10 +1308,10 @@ sa_build_index(sa_handle_t *hdl, sa_buf_type_t buftype)
 	return (0);
 }
 
-/*ARGSUSED*/
 static void
 sa_evict_sync(void *dbu)
 {
+	(void) dbu;
 	panic("evicting sa dbuf\n");
 }
 
diff --git a/sys/contrib/openzfs/module/zfs/sha256.c b/sys/contrib/openzfs/module/zfs/sha256.c
index d297768eada5..c5b033cf019d 100644
--- a/sys/contrib/openzfs/module/zfs/sha256.c
+++ b/sys/contrib/openzfs/module/zfs/sha256.c
@@ -41,11 +41,11 @@ sha_incremental(void *buf, size_t size, void *arg)
 	return (0);
 }
 
-/*ARGSUSED*/
 void
 abd_checksum_SHA256(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	int ret;
 	SHA2_CTX ctx;
 	zio_cksum_t tmp;
@@ -78,11 +78,11 @@ abd_checksum_SHA256(abd_t *abd, uint64_t size,
 	zcp->zc_word[3] = BE_64(tmp.zc_word[3]);
 }
 
-/*ARGSUSED*/
 void
 abd_checksum_SHA512_native(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	SHA2_CTX	ctx;
 
 	SHA2Init(SHA512_256, &ctx);
@@ -90,7 +90,6 @@ abd_checksum_SHA512_native(abd_t *abd, uint64_t size,
 	SHA2Final(zcp, &ctx);
 }
 
-/*ARGSUSED*/
 void
 abd_checksum_SHA512_byteswap(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
diff --git a/sys/contrib/openzfs/module/zfs/spa.c b/sys/contrib/openzfs/module/zfs/spa.c
index e5c41dc2b069..01af91b7b18f 100644
--- a/sys/contrib/openzfs/module/zfs/spa.c
+++ b/sys/contrib/openzfs/module/zfs/spa.c
@@ -150,7 +150,7 @@ static const char *const zio_taskq_types[ZIO_TASKQ_TYPES] = {
  * and interrupt) and then to reserve threads for ZIO_PRIORITY_NOW I/Os that
  * need to be handled with minimum delay.
  */
-const zio_taskq_info_t zio_taskqs[ZIO_TYPES][ZIO_TASKQ_TYPES] = {
+static const zio_taskq_info_t zio_taskqs[ZIO_TYPES][ZIO_TASKQ_TYPES] = {
 	/* ISSUE	ISSUE_HIGH	INTR		INTR_HIGH */
 	{ ZTI_ONE,	ZTI_NULL,	ZTI_ONE,	ZTI_NULL }, /* NULL */
 	{ ZTI_N(8),	ZTI_NULL,	ZTI_SCALE,	ZTI_NULL }, /* READ */
@@ -167,12 +167,12 @@ static boolean_t spa_has_active_shared_spare(spa_t *spa);
 static int spa_load_impl(spa_t *spa, spa_import_type_t type, char **ereport);
 static void spa_vdev_resilver_done(spa_t *spa);
 
-uint_t		zio_taskq_batch_pct = 80;	/* 1 thread per cpu in pset */
-uint_t		zio_taskq_batch_tpq;		/* threads per taskq */
-boolean_t	zio_taskq_sysdc = B_TRUE;	/* use SDC scheduling class */
-uint_t		zio_taskq_basedc = 80;		/* base duty cycle */
+static uint_t	zio_taskq_batch_pct = 80;	  /* 1 thread per cpu in pset */
+static uint_t	zio_taskq_batch_tpq;		  /* threads per taskq */
+static const boolean_t	zio_taskq_sysdc = B_TRUE; /* use SDC scheduling class */
+static const uint_t	zio_taskq_basedc = 80;	  /* base duty cycle */
 
-boolean_t	spa_create_process = B_TRUE;	/* no process ==> no sysdc */
+static const boolean_t spa_create_process = B_TRUE; /* no process => no sysdc */
 
 /*
  * Report any spa_load_verify errors found, but do not fail spa_load.
@@ -195,7 +195,7 @@ boolean_t	spa_mode_readable_spacemaps = B_FALSE;
 /*
  * For debugging purposes: print out vdev tree during pool import.
  */
-int		spa_load_print_vdev_tree = B_FALSE;
+static int		spa_load_print_vdev_tree = B_FALSE;
 
 /*
  * A non-zero value for zfs_max_missing_tvds means that we allow importing
@@ -244,28 +244,28 @@ uint64_t	zfs_max_missing_tvds_scan = 0;
 /*
  * Debugging aid that pauses spa_sync() towards the end.
  */
-boolean_t	zfs_pause_spa_sync = B_FALSE;
+static const boolean_t	zfs_pause_spa_sync = B_FALSE;
 
 /*
  * Variables to indicate the livelist condense zthr func should wait at certain
  * points for the livelist to be removed - used to test condense/destroy races
  */
-int zfs_livelist_condense_zthr_pause = 0;
-int zfs_livelist_condense_sync_pause = 0;
+static int zfs_livelist_condense_zthr_pause = 0;
+static int zfs_livelist_condense_sync_pause = 0;
 
 /*
  * Variables to track whether or not condense cancellation has been
  * triggered in testing.
  */
-int zfs_livelist_condense_sync_cancel = 0;
-int zfs_livelist_condense_zthr_cancel = 0;
+static int zfs_livelist_condense_sync_cancel = 0;
+static int zfs_livelist_condense_zthr_cancel = 0;
 
 /*
  * Variable to track whether or not extra ALLOC blkptrs were added to a
  * livelist entry while it was being condensed (caused by the way we track
  * remapped blkptrs in dbuf_remap_impl)
  */
-int zfs_livelist_condense_new_alloc = 0;
+static int zfs_livelist_condense_new_alloc = 0;
 
 /*
  * ==========================================================================
@@ -840,7 +840,6 @@ spa_prop_clear_bootfs(spa_t *spa, uint64_t dsobj, dmu_tx_t *tx)
 	}
 }
 
-/*ARGSUSED*/
 static int
 spa_change_guid_check(void *arg, dmu_tx_t *tx)
 {
@@ -1049,6 +1048,7 @@ spa_taskqs_init(spa_t *spa, zio_type_t t, zio_taskq_type_t q)
 			if (batch)
 				flags |= TASKQ_DC_BATCH;
 
+			(void) zio_taskq_basedc;
 			tq = taskq_create_sysdc(name, value, 50, INT_MAX,
 			    spa->spa_proc, zio_taskq_basedc, flags);
 		} else {
@@ -1250,12 +1250,12 @@ spa_activate(spa_t *spa, spa_mode_t mode)
 	spa->spa_mode = mode;
 	spa->spa_read_spacemaps = spa_mode_readable_spacemaps;
 
-	spa->spa_normal_class = metaslab_class_create(spa, zfs_metaslab_ops);
-	spa->spa_log_class = metaslab_class_create(spa, zfs_metaslab_ops);
+	spa->spa_normal_class = metaslab_class_create(spa, &zfs_metaslab_ops);
+	spa->spa_log_class = metaslab_class_create(spa, &zfs_metaslab_ops);
 	spa->spa_embedded_log_class =
-	    metaslab_class_create(spa, zfs_metaslab_ops);
-	spa->spa_special_class = metaslab_class_create(spa, zfs_metaslab_ops);
-	spa->spa_dedup_class = metaslab_class_create(spa, zfs_metaslab_ops);
+	    metaslab_class_create(spa, &zfs_metaslab_ops);
+	spa->spa_special_class = metaslab_class_create(spa, &zfs_metaslab_ops);
+	spa->spa_dedup_class = metaslab_class_create(spa, &zfs_metaslab_ops);
 
 	/* Try to create a covering process */
 	mutex_enter(&spa->spa_proc_lock);
@@ -1263,6 +1263,7 @@ spa_activate(spa_t *spa, spa_mode_t mode)
 	ASSERT(spa->spa_proc == &p0);
 	spa->spa_did = 0;
 
+	(void) spa_create_process;
 #ifdef HAVE_SPA_THREAD
 	/* Only create a process if we're going to be around a while. */
 	if (spa_create_process && strcmp(spa->spa_name, TRYIMPORT_NAME) != 0) {
@@ -2282,15 +2283,16 @@ spa_load_verify_done(zio_t *zio)
  * Maximum number of inflight bytes is the log2 fraction of the arc size.
  * By default, we set it to 1/16th of the arc.
  */
-int spa_load_verify_shift = 4;
-int spa_load_verify_metadata = B_TRUE;
-int spa_load_verify_data = B_TRUE;
+static int spa_load_verify_shift = 4;
+static int spa_load_verify_metadata = B_TRUE;
+static int spa_load_verify_data = B_TRUE;
 
-/*ARGSUSED*/
 static int
 spa_load_verify_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
     const zbookmark_phys_t *zb, const dnode_phys_t *dnp, void *arg)
 {
+	(void) zilog, (void) dnp;
+
 	if (zb->zb_level == ZB_DNODE_LEVEL || BP_IS_HOLE(bp) ||
 	    BP_IS_EMBEDDED(bp) || BP_IS_REDACTED(bp))
 		return (0);
@@ -2322,10 +2324,11 @@ spa_load_verify_cb(spa_t *spa, zilog_t *zilog, const blkptr_t *bp,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 verify_dataset_name_len(dsl_pool_t *dp, dsl_dataset_t *ds, void *arg)
 {
+	(void) dp, (void) arg;
+
 	if (dsl_dataset_namelen(ds) >= ZFS_MAX_DATASET_NAME_LEN)
 		return (SET_ERROR(ENAMETOOLONG));
 
@@ -2455,10 +2458,10 @@ spa_livelist_delete_check(spa_t *spa)
 	return (spa->spa_livelists_to_delete != 0);
 }
 
-/* ARGSUSED */
 static boolean_t
 spa_livelist_delete_cb_check(void *arg, zthr_t *z)
 {
+	(void) z;
 	spa_t *spa = arg;
 	return (spa_livelist_delete_check(spa));
 }
@@ -2550,7 +2553,6 @@ livelist_delete_sync(void *arg, dmu_tx_t *tx)
  * be freed. Then, call a synctask which performs the actual frees and updates
  * the pool-wide livelist data.
  */
-/* ARGSUSED */
 static void
 spa_livelist_delete_cb(void *arg, zthr_t *z)
 {
@@ -2796,7 +2798,6 @@ spa_livelist_condense_cb(void *arg, zthr_t *t)
 		zfs_livelist_condense_zthr_cancel++;
 }
 
-/* ARGSUSED */
 /*
  * Check that there is something to condense but that a condense is not
  * already in progress and that condensing has not been cancelled.
@@ -2804,6 +2805,7 @@ spa_livelist_condense_cb(void *arg, zthr_t *t)
 static boolean_t
 spa_livelist_condense_cb_check(void *arg, zthr_t *z)
 {
+	(void) z;
 	spa_t *spa = arg;
 	if ((spa->spa_to_condense.ds != NULL) &&
 	    (spa->spa_to_condense.syncing == B_FALSE) &&
@@ -2996,6 +2998,8 @@ vdev_count_verify_zaps(vdev_t *vd)
 
 	return (total);
 }
+#else
+#define	vdev_count_verify_zaps(vd) ((void) sizeof (vd), 0)
 #endif
 
 /*
@@ -9463,6 +9467,7 @@ spa_upgrade(spa_t *spa, uint64_t version)
 static boolean_t
 spa_has_aux_vdev(spa_t *spa, uint64_t guid, spa_aux_vdev_t *sav)
 {
+	(void) spa;
 	int i;
 	uint64_t vdev_guid;
 
@@ -9826,6 +9831,8 @@ spa_event_create(spa_t *spa, vdev_t *vd, nvlist_t *hist_nvl, const char *name)
 		ev = kmem_alloc(sizeof (sysevent_t), KM_SLEEP);
 		ev->resource = resource;
 	}
+#else
+	(void) spa, (void) vd, (void) hist_nvl, (void) name;
 #endif
 	return (ev);
 }
@@ -9838,6 +9845,8 @@ spa_event_post(sysevent_t *ev)
 		zfs_zevent_post(ev->resource, NULL, zfs_zevent_post_cb);
 		kmem_free(ev, sizeof (*ev));
 	}
+#else
+	(void) ev;
 #endif
 }
 
diff --git a/sys/contrib/openzfs/module/zfs/spa_checkpoint.c b/sys/contrib/openzfs/module/zfs/spa_checkpoint.c
index 09f62996853d..68c3ae2e0c31 100644
--- a/sys/contrib/openzfs/module/zfs/spa_checkpoint.c
+++ b/sys/contrib/openzfs/module/zfs/spa_checkpoint.c
@@ -158,7 +158,7 @@
  * amount of checkpointed data that has been freed within them while
  * the pool had a checkpoint.
  */
-unsigned long zfs_spa_discard_memory_limit = 16 * 1024 * 1024;
+static unsigned long zfs_spa_discard_memory_limit = 16 * 1024 * 1024;
 
 int
 spa_checkpoint_get_stats(spa_t *spa, pool_checkpoint_stat_t *pcs)
@@ -380,10 +380,10 @@ spa_checkpoint_discard_is_done(spa_t *spa)
 	return (B_TRUE);
 }
 
-/* ARGSUSED */
 boolean_t
 spa_checkpoint_discard_thread_check(void *arg, zthr_t *zthr)
 {
+	(void) zthr;
 	spa_t *spa = arg;
 
 	if (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))
@@ -450,10 +450,10 @@ spa_checkpoint_discard_thread(void *arg, zthr_t *zthr)
 }
 
 
-/* ARGSUSED */
 static int
 spa_checkpoint_check(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	spa_t *spa = dmu_tx_pool(tx)->dp_spa;
 
 	if (!spa_feature_is_enabled(spa, SPA_FEATURE_POOL_CHECKPOINT))
@@ -474,10 +474,10 @@ spa_checkpoint_check(void *arg, dmu_tx_t *tx)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 spa_checkpoint_sync(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	dsl_pool_t *dp = dmu_tx_pool(tx);
 	spa_t *spa = dp->dp_spa;
 	uberblock_t checkpoint = spa->spa_ubsync;
@@ -571,10 +571,10 @@ spa_checkpoint(const char *pool)
 	return (error);
 }
 
-/* ARGSUSED */
 static int
 spa_checkpoint_discard_check(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	spa_t *spa = dmu_tx_pool(tx)->dp_spa;
 
 	if (!spa_feature_is_active(spa, SPA_FEATURE_POOL_CHECKPOINT))
@@ -589,10 +589,10 @@ spa_checkpoint_discard_check(void *arg, dmu_tx_t *tx)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 spa_checkpoint_discard_sync(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	spa_t *spa = dmu_tx_pool(tx)->dp_spa;
 
 	VERIFY0(zap_remove(spa_meta_objset(spa), DMU_POOL_DIRECTORY_OBJECT,
diff --git a/sys/contrib/openzfs/module/zfs/spa_config.c b/sys/contrib/openzfs/module/zfs/spa_config.c
index ad82932ce567..b9c6ac042f1f 100644
--- a/sys/contrib/openzfs/module/zfs/spa_config.c
+++ b/sys/contrib/openzfs/module/zfs/spa_config.c
@@ -68,7 +68,9 @@ static uint64_t spa_config_generation = 1;
  * userland pools when doing testing.
  */
 char *spa_config_path = ZPOOL_CACHE;
-int zfs_autoimport_disable = 1;
+#ifdef _KERNEL
+static int zfs_autoimport_disable = B_TRUE;
+#endif
 
 /*
  * Called when the module is first loaded, this routine loads the configuration
diff --git a/sys/contrib/openzfs/module/zfs/spa_errlog.c b/sys/contrib/openzfs/module/zfs/spa_errlog.c
index fa5120eb61b3..c6b28ea7d1b8 100644
--- a/sys/contrib/openzfs/module/zfs/spa_errlog.c
+++ b/sys/contrib/openzfs/module/zfs/spa_errlog.c
@@ -252,6 +252,8 @@ spa_get_errlog(spa_t *spa, void *uaddr, size_t *count)
 	mutex_exit(&spa->spa_errlist_lock);
 
 	mutex_exit(&spa->spa_errlog_lock);
+#else
+	(void) spa, (void) uaddr, (void) count;
 #endif
 
 	return (ret);
diff --git a/sys/contrib/openzfs/module/zfs/spa_log_spacemap.c b/sys/contrib/openzfs/module/zfs/spa_log_spacemap.c
index 6fd302b8df34..341917a6d402 100644
--- a/sys/contrib/openzfs/module/zfs/spa_log_spacemap.c
+++ b/sys/contrib/openzfs/module/zfs/spa_log_spacemap.c
@@ -177,7 +177,7 @@
  * block size as we expect to be writing a lot of data to them at
  * once.
  */
-unsigned long zfs_log_sm_blksz = 1ULL << 17;
+static const unsigned long zfs_log_sm_blksz = 1ULL << 17;
 
 /*
  * Percentage of the overall system's memory that ZFS allows to be
@@ -188,13 +188,13 @@ unsigned long zfs_log_sm_blksz = 1ULL << 17;
  * (thus the _ppm suffix; reads as "parts per million"). As an example,
  * the default of 1000 allows 0.1% of memory to be used.
  */
-unsigned long zfs_unflushed_max_mem_ppm = 1000;
+static unsigned long zfs_unflushed_max_mem_ppm = 1000;
 
 /*
  * Specific hard-limit in memory that ZFS allows to be used for
  * unflushed changes.
  */
-unsigned long zfs_unflushed_max_mem_amt = 1ULL << 30;
+static unsigned long zfs_unflushed_max_mem_amt = 1ULL << 30;
 
 /*
  * The following tunable determines the number of blocks that can be used for
@@ -243,28 +243,28 @@ unsigned long zfs_unflushed_max_mem_amt = 1ULL << 30;
  * provide upper and lower bounds for the log block limit.
  * [see zfs_unflushed_log_block_{min,max}]
  */
-unsigned long zfs_unflushed_log_block_pct = 400;
+static unsigned long zfs_unflushed_log_block_pct = 400;
 
 /*
  * If the number of metaslabs is small and our incoming rate is high, we could
  * get into a situation that we are flushing all our metaslabs every TXG. Thus
  * we always allow at least this many log blocks.
  */
-unsigned long zfs_unflushed_log_block_min = 1000;
+static unsigned long zfs_unflushed_log_block_min = 1000;
 
 /*
  * If the log becomes too big, the import time of the pool can take a hit in
  * terms of performance. Thus we have a hard limit in the size of the log in
  * terms of blocks.
  */
-unsigned long zfs_unflushed_log_block_max = (1ULL << 18);
+static unsigned long zfs_unflushed_log_block_max = (1ULL << 18);
 
 /*
  * Max # of rows allowed for the log_summary. The tradeoff here is accuracy and
  * stability of the flushing algorithm (longer summary) vs its runtime overhead
  * (smaller summary is faster to traverse).
  */
-unsigned long zfs_max_logsm_summary_length = 10;
+static unsigned long zfs_max_logsm_summary_length = 10;
 
 /*
  * Tunable that sets the lower bound on the metaslabs to flush every TXG.
@@ -277,7 +277,7 @@ unsigned long zfs_max_logsm_summary_length = 10;
  * The point of this tunable is to be used in extreme cases where we really
  * want to flush more metaslabs than our adaptable heuristic plans to flush.
  */
-unsigned long zfs_min_metaslabs_to_flush = 1;
+static unsigned long zfs_min_metaslabs_to_flush = 1;
 
 /*
  * Tunable that specifies how far in the past do we want to look when trying to
@@ -288,7 +288,7 @@ unsigned long zfs_min_metaslabs_to_flush = 1;
  * average over all the blocks that we walk
  * [see spa_estimate_incoming_log_blocks].
  */
-unsigned long zfs_max_log_walking = 5;
+static unsigned long zfs_max_log_walking = 5;
 
 /*
  * This tunable exists solely for testing purposes. It ensures that the log
diff --git a/sys/contrib/openzfs/module/zfs/spa_misc.c b/sys/contrib/openzfs/module/zfs/spa_misc.c
index 3f74631983c4..a04766e7e33b 100644
--- a/sys/contrib/openzfs/module/zfs/spa_misc.c
+++ b/sys/contrib/openzfs/module/zfs/spa_misc.c
@@ -235,14 +235,13 @@
 static avl_tree_t spa_namespace_avl;
 kmutex_t spa_namespace_lock;
 static kcondvar_t spa_namespace_cv;
-int spa_max_replication_override = SPA_DVAS_PER_BP;
+static const int spa_max_replication_override = SPA_DVAS_PER_BP;
 
 static kmutex_t spa_spare_lock;
 static avl_tree_t spa_spare_avl;
 static kmutex_t spa_l2cache_lock;
 static avl_tree_t spa_l2cache_avl;
 
-kmem_cache_t *spa_buffer_pool;
 spa_mode_t spa_mode_global = SPA_MODE_UNINIT;
 
 #ifdef ZFS_DEBUG
@@ -304,25 +303,25 @@ int zfs_free_leak_on_eio = B_FALSE;
  * has not completed in zfs_deadman_synctime_ms is considered "hung" resulting
  * in one of three behaviors controlled by zfs_deadman_failmode.
  */
-unsigned long zfs_deadman_synctime_ms = 600000UL;
+unsigned long zfs_deadman_synctime_ms = 600000UL;  /* 10 min. */
 
 /*
  * This value controls the maximum amount of time zio_wait() will block for an
  * outstanding IO.  By default this is 300 seconds at which point the "hung"
  * behavior will be applied as described for zfs_deadman_synctime_ms.
  */
-unsigned long zfs_deadman_ziotime_ms = 300000UL;
+unsigned long zfs_deadman_ziotime_ms = 300000UL;  /* 5 min. */
 
 /*
  * Check time in milliseconds. This defines the frequency at which we check
  * for hung I/O.
  */
-unsigned long zfs_deadman_checktime_ms = 60000UL;
+unsigned long zfs_deadman_checktime_ms = 60000UL;  /* 1 min. */
 
 /*
  * By default the deadman is enabled.
  */
-int zfs_deadman_enabled = 1;
+int zfs_deadman_enabled = B_TRUE;
 
 /*
  * Controls the behavior of the deadman when it detects a "hung" I/O.
@@ -332,7 +331,7 @@ int zfs_deadman_enabled = 1;
  * continue - Attempt to recover from a "hung" I/O
  * panic    - Panic the system
  */
-char *zfs_deadman_failmode = "wait";
+const char *zfs_deadman_failmode = "wait";
 
 /*
  * The worst case is single-sector max-parity RAID-Z blocks, in which
@@ -384,9 +383,9 @@ int spa_asize_inflation = 24;
  * See also the comments in zfs_space_check_t.
  */
 int spa_slop_shift = 5;
-uint64_t spa_min_slop = 128ULL * 1024 * 1024;
-uint64_t spa_max_slop = 128ULL * 1024 * 1024 * 1024;
-int spa_allocators = 4;
+static const uint64_t spa_min_slop = 128ULL * 1024 * 1024;
+static const uint64_t spa_max_slop = 128ULL * 1024 * 1024 * 1024;
+static const int spa_allocators = 4;
 
 
 void
@@ -420,15 +419,15 @@ spa_load_note(spa_t *spa, const char *fmt, ...)
 /*
  * By default dedup and user data indirects land in the special class
  */
-int zfs_ddt_data_is_special = B_TRUE;
-int zfs_user_indirect_is_special = B_TRUE;
+static int zfs_ddt_data_is_special = B_TRUE;
+static int zfs_user_indirect_is_special = B_TRUE;
 
 /*
  * The percentage of special class final space reserved for metadata only.
  * Once we allocate 100 - zfs_special_class_metadata_reserve_pct we only
  * let metadata into the class.
  */
-int zfs_special_class_metadata_reserve_pct = 25;
+static int zfs_special_class_metadata_reserve_pct = 25;
 
 /*
  * ==========================================================================
@@ -495,6 +494,7 @@ spa_config_tryenter(spa_t *spa, int locks, void *tag, krw_t rw)
 void
 spa_config_enter(spa_t *spa, int locks, const void *tag, krw_t rw)
 {
+	(void) tag;
 	int wlocks_held = 0;
 
 	ASSERT3U(SCL_LOCKS, <, sizeof (wlocks_held) * NBBY);
@@ -528,6 +528,7 @@ spa_config_enter(spa_t *spa, int locks, const void *tag, krw_t rw)
 void
 spa_config_exit(spa_t *spa, int locks, const void *tag)
 {
+	(void) tag;
 	for (int i = SCL_LOCKS - 1; i >= 0; i--) {
 		spa_config_lock_t *scl = &spa->spa_config_lock[i];
 		if (!(locks & (1 << i)))
diff --git a/sys/contrib/openzfs/module/zfs/spa_stats.c b/sys/contrib/openzfs/module/zfs/spa_stats.c
index 534ac72fee7b..d89f79480ce3 100644
--- a/sys/contrib/openzfs/module/zfs/spa_stats.c
+++ b/sys/contrib/openzfs/module/zfs/spa_stats.c
@@ -28,22 +28,22 @@
 /*
  * Keeps stats on last N reads per spa_t, disabled by default.
  */
-int zfs_read_history = 0;
+static int zfs_read_history = B_FALSE;
 
 /*
  * Include cache hits in history, disabled by default.
  */
-int zfs_read_history_hits = 0;
+static int zfs_read_history_hits = B_FALSE;
 
 /*
  * Keeps stats on the last 100 txgs by default.
  */
-int zfs_txg_history = 100;
+static int zfs_txg_history = 100;
 
 /*
  * Keeps stats on the last N MMP updates, disabled by default.
  */
-int zfs_multihost_history = 0;
+int zfs_multihost_history = B_FALSE;
 
 /*
  * ==========================================================================
@@ -830,7 +830,7 @@ spa_health_destroy(spa_t *spa)
 	mutex_destroy(&shk->lock);
 }
 
-static spa_iostats_t spa_iostats_template = {
+static const spa_iostats_t spa_iostats_template = {
 	{ "trim_extents_written",		KSTAT_DATA_UINT64 },
 	{ "trim_bytes_written",			KSTAT_DATA_UINT64 },
 	{ "trim_extents_skipped",		KSTAT_DATA_UINT64 },
diff --git a/sys/contrib/openzfs/module/zfs/vdev.c b/sys/contrib/openzfs/module/zfs/vdev.c
index 5784bd2a09c3..5481902f2a6c 100644
--- a/sys/contrib/openzfs/module/zfs/vdev.c
+++ b/sys/contrib/openzfs/module/zfs/vdev.c
@@ -81,22 +81,22 @@
  * 1 << (spa_slop_shift + 1), on small pools the usable space may be reduced
  * (by more than 1<<spa_slop_shift) due to the embedded slog metaslab.
  */
-int zfs_embedded_slog_min_ms = 64;
+static int zfs_embedded_slog_min_ms = 64;
 
 /* default target for number of metaslabs per top-level vdev */
-int zfs_vdev_default_ms_count = 200;
+static int zfs_vdev_default_ms_count = 200;
 
 /* minimum number of metaslabs per top-level vdev */
-int zfs_vdev_min_ms_count = 16;
+static int zfs_vdev_min_ms_count = 16;
 
 /* practical upper limit of total metaslabs per top-level vdev */
-int zfs_vdev_ms_count_limit = 1ULL << 17;
+static int zfs_vdev_ms_count_limit = 1ULL << 17;
 
 /* lower limit for metaslab size (512M) */
-int zfs_vdev_default_ms_shift = 29;
+static int zfs_vdev_default_ms_shift = 29;
 
 /* upper limit for metaslab size (16G) */
-int zfs_vdev_max_ms_shift = 34;
+static const int zfs_vdev_max_ms_shift = 34;
 
 int vdev_validate_skip = B_FALSE;
 
@@ -109,18 +109,18 @@ int zfs_vdev_dtl_sm_blksz = (1 << 12);
 /*
  * Rate limit slow IO (delay) events to this many per second.
  */
-unsigned int zfs_slow_io_events_per_second = 20;
+static unsigned int zfs_slow_io_events_per_second = 20;
 
 /*
  * Rate limit checksum events after this many checksum errors per second.
  */
-unsigned int zfs_checksum_events_per_second = 20;
+static unsigned int zfs_checksum_events_per_second = 20;
 
 /*
  * Ignore errors during scrub/resilver.  Allows to work around resilver
  * upon import when there are pool errors.
  */
-int zfs_scan_ignore_errors = 0;
+static int zfs_scan_ignore_errors = 0;
 
 /*
  * vdev-wide space maps that have lots of entries written to them at
@@ -216,7 +216,7 @@ vdev_dbgmsg_print_tree(vdev_t *vd, int indent)
  * Virtual device management.
  */
 
-static vdev_ops_t *vdev_ops_table[] = {
+static const vdev_ops_t *const vdev_ops_table[] = {
 	&vdev_root_ops,
 	&vdev_raidz_ops,
 	&vdev_draid_ops,
@@ -238,7 +238,7 @@ static vdev_ops_t *vdev_ops_table[] = {
 static vdev_ops_t *
 vdev_getops(const char *type)
 {
-	vdev_ops_t *ops, **opspp;
+	const vdev_ops_t *ops, *const *opspp;
 
 	for (opspp = vdev_ops_table; (ops = *opspp) != NULL; opspp++)
 		if (strcmp(ops->vdev_op_type, type) == 0)
@@ -263,11 +263,12 @@ vdev_get_mg(vdev_t *vd, metaslab_class_t *mc)
 		return (vd->vdev_mg);
 }
 
-/* ARGSUSED */
 void
 vdev_default_xlate(vdev_t *vd, const range_seg64_t *logical_rs,
     range_seg64_t *physical_rs, range_seg64_t *remain_rs)
 {
+	(void) vd, (void) remain_rs;
+
 	physical_rs->rs_start = logical_rs->rs_start;
 	physical_rs->rs_end = logical_rs->rs_end;
 }
@@ -1778,6 +1779,7 @@ vdev_uses_zvols(vdev_t *vd)
 static boolean_t
 vdev_default_open_children_func(vdev_t *vd)
 {
+	(void) vd;
 	return (B_TRUE);
 }
 
@@ -2859,6 +2861,8 @@ boolean_t
 vdev_default_need_resilver(vdev_t *vd, const dva_t *dva, size_t psize,
     uint64_t phys_birth)
 {
+	(void) dva, (void) psize;
+
 	/* Set by sequential resilver. */
 	if (phys_birth == TXG_UNKNOWN)
 		return (B_TRUE);
@@ -4308,6 +4312,8 @@ vdev_get_child_stat(vdev_t *cvd, vdev_stat_t *vs, vdev_stat_t *cvs)
 static void
 vdev_get_child_stat_ex(vdev_t *cvd, vdev_stat_ex_t *vsx, vdev_stat_ex_t *cvsx)
 {
+	(void) cvd;
+
 	int t, b;
 	for (t = 0; t < ZIO_TYPES; t++) {
 		for (b = 0; b < ARRAY_SIZE(vsx->vsx_disk_histo[0]); b++)
@@ -4743,6 +4749,7 @@ void
 vdev_space_update(vdev_t *vd, int64_t alloc_delta, int64_t defer_delta,
     int64_t space_delta)
 {
+	(void) defer_delta;
 	int64_t dspace_delta;
 	spa_t *spa = vd->vdev_spa;
 	vdev_t *rvd = spa->spa_root_vdev;
@@ -5469,7 +5476,10 @@ vdev_props_set_sync(void *arg, dmu_tx_t *tx)
 	vdev_guid = fnvlist_lookup_uint64(nvp, ZPOOL_VDEV_PROPS_SET_VDEV);
 	nvprops = fnvlist_lookup_nvlist(nvp, ZPOOL_VDEV_PROPS_SET_PROPS);
 	vd = spa_lookup_by_guid(spa, vdev_guid, B_TRUE);
-	VERIFY(vd != NULL);
+
+	/* this vdev could get removed while waiting for this sync task */
+	if (vd == NULL)
+		return;
 
 	mutex_enter(&spa->spa_props_lock);
 
diff --git a/sys/contrib/openzfs/module/zfs/vdev_cache.c b/sys/contrib/openzfs/module/zfs/vdev_cache.c
index 35ed1a3352fe..b6e680334d5c 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_cache.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_cache.c
@@ -83,13 +83,13 @@
  * it by setting the zfs_vdev_cache_size to zero.  Note that Solaris 11
  * has made these same changes.
  */
-int zfs_vdev_cache_max = 1<<14;			/* 16KB */
-int zfs_vdev_cache_size = 0;
-int zfs_vdev_cache_bshift = 16;
+static int zfs_vdev_cache_max = 1<<14;			/* 16KB */
+static int zfs_vdev_cache_size = 0;
+static int zfs_vdev_cache_bshift = 16;
 
 #define	VCBS (1 << zfs_vdev_cache_bshift)	/* 64KB */
 
-kstat_t	*vdc_ksp = NULL;
+static kstat_t	*vdc_ksp = NULL;
 
 typedef struct vdc_stats {
 	kstat_named_t vdc_stat_delegations;
diff --git a/sys/contrib/openzfs/module/zfs/vdev_draid.c b/sys/contrib/openzfs/module/zfs/vdev_draid.c
index 9c222feb9f06..6c765d984585 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_draid.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_draid.c
@@ -841,6 +841,53 @@ vdev_draid_map_alloc_empty(zio_t *zio, raidz_row_t *rr)
 	ASSERT3U(skip_off, ==, rr->rr_nempty * skip_size);
 }
 
+/*
+ * Verify that all empty sectors are zero filled before using them to
+ * calculate parity.  Otherwise, silent corruption in an empty sector will
+ * result in bad parity being generated.  That bad parity will then be
+ * considered authoritative and overwrite the good parity on disk.  This
+ * is possible because the checksum is only calculated over the data,
+ * thus it cannot be used to detect damage in empty sectors.
+ */
+int
+vdev_draid_map_verify_empty(zio_t *zio, raidz_row_t *rr)
+{
+	uint64_t skip_size = 1ULL << zio->io_vd->vdev_top->vdev_ashift;
+	uint64_t parity_size = rr->rr_col[0].rc_size;
+	uint64_t skip_off = parity_size - skip_size;
+	uint64_t empty_off = 0;
+	int ret = 0;
+
+	ASSERT3U(zio->io_type, ==, ZIO_TYPE_READ);
+	ASSERT3P(rr->rr_abd_empty, !=, NULL);
+	ASSERT3U(rr->rr_bigcols, >, 0);
+
+	void *zero_buf = kmem_zalloc(skip_size, KM_SLEEP);
+
+	for (int c = rr->rr_bigcols; c < rr->rr_cols; c++) {
+		raidz_col_t *rc = &rr->rr_col[c];
+
+		ASSERT3P(rc->rc_abd, !=, NULL);
+		ASSERT3U(rc->rc_size, ==, parity_size);
+
+		if (abd_cmp_buf_off(rc->rc_abd, zero_buf, skip_off,
+		    skip_size) != 0) {
+			vdev_raidz_checksum_error(zio, rc, rc->rc_abd);
+			abd_zero_off(rc->rc_abd, skip_off, skip_size);
+			rc->rc_error = SET_ERROR(ECKSUM);
+			ret++;
+		}
+
+		empty_off += skip_size;
+	}
+
+	ASSERT3U(empty_off, ==, abd_get_size(rr->rr_abd_empty));
+
+	kmem_free(zero_buf, skip_size);
+
+	return (ret);
+}
+
 /*
  * Given a logical address within a dRAID configuration, return the physical
  * address on the first drive in the group that this address maps to
@@ -2154,6 +2201,7 @@ vdev_draid_config_generate(vdev_t *vd, nvlist_t *nv)
 static int
 vdev_draid_init(spa_t *spa, nvlist_t *nv, void **tsd)
 {
+	(void) spa;
 	uint64_t ndata, nparity, nspares, ngroups;
 	int error;
 
@@ -2382,7 +2430,6 @@ vdev_draid_spare_get_child(vdev_t *vd, uint64_t physical_offset)
 	return (cvd);
 }
 
-/* ARGSUSED */
 static void
 vdev_draid_spare_close(vdev_t *vd)
 {
@@ -2641,10 +2688,10 @@ vdev_draid_spare_io_start(zio_t *zio)
 	zio_execute(zio);
 }
 
-/* ARGSUSED */
 static void
 vdev_draid_spare_io_done(zio_t *zio)
 {
+	(void) zio;
 }
 
 /*
diff --git a/sys/contrib/openzfs/module/zfs/vdev_indirect.c b/sys/contrib/openzfs/module/zfs/vdev_indirect.c
index 14ebf5514676..aa4801e67442 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_indirect.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_indirect.c
@@ -172,7 +172,7 @@
  * object.
  */
 
-int zfs_condense_indirect_vdevs_enable = B_TRUE;
+static int zfs_condense_indirect_vdevs_enable = B_TRUE;
 
 /*
  * Condense if at least this percent of the bytes in the mapping is
@@ -181,7 +181,7 @@ int zfs_condense_indirect_vdevs_enable = B_TRUE;
  * condenses.  Higher values will condense less often (causing less
  * i/o); lower values will reduce the mapping size more quickly.
  */
-int zfs_condense_indirect_obsolete_pct = 25;
+static int zfs_condense_indirect_obsolete_pct = 25;
 
 /*
  * Condense if the obsolete space map takes up more than this amount of
@@ -189,14 +189,14 @@ int zfs_condense_indirect_obsolete_pct = 25;
  * consumed by the obsolete space map; the default of 1GB is small enough
  * that we typically don't mind "wasting" it.
  */
-unsigned long zfs_condense_max_obsolete_bytes = 1024 * 1024 * 1024;
+static unsigned long zfs_condense_max_obsolete_bytes = 1024 * 1024 * 1024;
 
 /*
  * Don't bother condensing if the mapping uses less than this amount of
  * memory.  The default of 128KB is considered a "trivial" amount of
  * memory and not worth reducing.
  */
-unsigned long zfs_condense_min_mapping_bytes = 128 * 1024;
+static unsigned long zfs_condense_min_mapping_bytes = 128 * 1024;
 
 /*
  * This is used by the test suite so that it can ensure that certain
@@ -204,7 +204,7 @@ unsigned long zfs_condense_min_mapping_bytes = 128 * 1024;
  * complete too quickly).  If used to reduce the performance impact of
  * condensing in production, a maximum value of 1 should be sufficient.
  */
-int zfs_condense_indirect_commit_entry_delay_ms = 0;
+static int zfs_condense_indirect_commit_entry_delay_ms = 0;
 
 /*
  * If an indirect split block contains more than this many possible unique
@@ -637,16 +637,15 @@ spa_condense_indirect_generate_new_mapping(vdev_t *vd,
 	}
 }
 
-/* ARGSUSED */
 static boolean_t
 spa_condense_indirect_thread_check(void *arg, zthr_t *zthr)
 {
+	(void) zthr;
 	spa_t *spa = arg;
 
 	return (spa->spa_condensing_indirect != NULL);
 }
 
-/* ARGSUSED */
 static void
 spa_condense_indirect_thread(void *arg, zthr_t *zthr)
 {
@@ -941,13 +940,12 @@ vdev_obsolete_counts_are_precise(vdev_t *vd, boolean_t *are_precise)
 	return (error);
 }
 
-/* ARGSUSED */
 static void
 vdev_indirect_close(vdev_t *vd)
 {
+	(void) vd;
 }
 
-/* ARGSUSED */
 static int
 vdev_indirect_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
     uint64_t *logical_ashift, uint64_t *physical_ashift)
diff --git a/sys/contrib/openzfs/module/zfs/vdev_indirect_births.c b/sys/contrib/openzfs/module/zfs/vdev_indirect_births.c
index 99b83c392257..e8f925628d04 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_indirect_births.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_indirect_births.c
@@ -38,6 +38,8 @@ vdev_indirect_births_verify(vdev_indirect_births_t *vib)
 
 	return (B_TRUE);
 }
+#else
+#define	vdev_indirect_births_verify(vib) ((void) sizeof (vib), B_TRUE)
 #endif
 
 uint64_t
diff --git a/sys/contrib/openzfs/module/zfs/vdev_indirect_mapping.c b/sys/contrib/openzfs/module/zfs/vdev_indirect_mapping.c
index bb484a401b1b..4ade56e062f7 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_indirect_mapping.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_indirect_mapping.c
@@ -54,6 +54,8 @@ vdev_indirect_mapping_verify(vdev_indirect_mapping_t *vim)
 
 	return (B_TRUE);
 }
+#else
+#define	vdev_indirect_mapping_verify(vim) ((void) sizeof (vim), B_TRUE)
 #endif
 
 uint64_t
diff --git a/sys/contrib/openzfs/module/zfs/vdev_initialize.c b/sys/contrib/openzfs/module/zfs/vdev_initialize.c
index e9156c32f384..eda71faeacdc 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_initialize.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_initialize.c
@@ -37,16 +37,16 @@
  * Value that is written to disk during initialization.
  */
 #ifdef _ILP32
-unsigned long zfs_initialize_value = 0xdeadbeefUL;
+static unsigned long zfs_initialize_value = 0xdeadbeefUL;
 #else
-unsigned long zfs_initialize_value = 0xdeadbeefdeadbeeeULL;
+static unsigned long zfs_initialize_value = 0xdeadbeefdeadbeeeULL;
 #endif
 
 /* maximum number of I/Os outstanding per leaf vdev */
-int zfs_initialize_limit = 1;
+static const int zfs_initialize_limit = 1;
 
 /* size of initializing writes; default 1MiB, see zfs_remove_max_segment */
-unsigned long zfs_initialize_chunk_size = 1024 * 1024;
+static unsigned long zfs_initialize_chunk_size = 1024 * 1024;
 
 static boolean_t
 vdev_initialize_should_stop(vdev_t *vd)
@@ -255,10 +255,11 @@ vdev_initialize_write(vdev_t *vd, uint64_t start, uint64_t size, abd_t *data)
  * divisible by sizeof (uint64_t), and buf must be 8-byte aligned. The ABD
  * allocation will guarantee these for us.
  */
-/* ARGSUSED */
 static int
 vdev_initialize_block_fill(void *buf, size_t len, void *unused)
 {
+	(void) unused;
+
 	ASSERT0(len % sizeof (uint64_t));
 #ifdef _ILP32
 	for (uint64_t i = 0; i < len; i += sizeof (uint32_t)) {
@@ -624,6 +625,7 @@ vdev_initialize_stop_wait_impl(vdev_t *vd)
 void
 vdev_initialize_stop_wait(spa_t *spa, list_t *vd_list)
 {
+	(void) spa;
 	vdev_t *vd;
 
 	ASSERT(MUTEX_HELD(&spa_namespace_lock));
diff --git a/sys/contrib/openzfs/module/zfs/vdev_mirror.c b/sys/contrib/openzfs/module/zfs/vdev_mirror.c
index 5eb331046953..30d0e7de54b0 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_mirror.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_mirror.c
@@ -121,7 +121,7 @@ typedef struct mirror_map {
 	mirror_child_t	mm_child[];
 } mirror_map_t;
 
-static int vdev_mirror_shift = 21;
+static const int vdev_mirror_shift = 21;
 
 /*
  * The load configuration settings below are tuned by default for
@@ -880,6 +880,8 @@ static uint64_t
 vdev_mirror_rebuild_asize(vdev_t *vd, uint64_t start, uint64_t asize,
     uint64_t max_segment)
 {
+	(void) start;
+
 	uint64_t psize = MIN(P2ROUNDUP(max_segment, 1 << vd->vdev_ashift),
 	    SPA_MAXBLOCKSIZE);
 
diff --git a/sys/contrib/openzfs/module/zfs/vdev_missing.c b/sys/contrib/openzfs/module/zfs/vdev_missing.c
index e9145fd012d7..505df23c1fb2 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_missing.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_missing.c
@@ -42,7 +42,6 @@
 #include <sys/fs/zfs.h>
 #include <sys/zio.h>
 
-/* ARGSUSED */
 static int
 vdev_missing_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
     uint64_t *ashift, uint64_t *pshift)
@@ -53,6 +52,7 @@ vdev_missing_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
 	 * VDEV_AUX_BAD_GUID_SUM.  So we pretend to succeed, knowing that we
 	 * will fail the GUID sum check before ever trying to open the pool.
 	 */
+	(void) vd;
 	*psize = 0;
 	*max_psize = 0;
 	*ashift = 0;
@@ -60,13 +60,12 @@ vdev_missing_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 vdev_missing_close(vdev_t *vd)
 {
+	(void) vd;
 }
 
-/* ARGSUSED */
 static void
 vdev_missing_io_start(zio_t *zio)
 {
@@ -74,10 +73,10 @@ vdev_missing_io_start(zio_t *zio)
 	zio_execute(zio);
 }
 
-/* ARGSUSED */
 static void
 vdev_missing_io_done(zio_t *zio)
 {
+	(void) zio;
 }
 
 vdev_ops_t vdev_missing_ops = {
diff --git a/sys/contrib/openzfs/module/zfs/vdev_queue.c b/sys/contrib/openzfs/module/zfs/vdev_queue.c
index af612ba9c9c6..ae0a322f86c7 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_queue.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_queue.c
@@ -141,24 +141,24 @@ uint32_t zfs_vdev_max_active = 1000;
  * more quickly, but reads and writes to have higher latency and lower
  * throughput.
  */
-uint32_t zfs_vdev_sync_read_min_active = 10;
-uint32_t zfs_vdev_sync_read_max_active = 10;
-uint32_t zfs_vdev_sync_write_min_active = 10;
-uint32_t zfs_vdev_sync_write_max_active = 10;
-uint32_t zfs_vdev_async_read_min_active = 1;
-uint32_t zfs_vdev_async_read_max_active = 3;
-uint32_t zfs_vdev_async_write_min_active = 2;
-uint32_t zfs_vdev_async_write_max_active = 10;
-uint32_t zfs_vdev_scrub_min_active = 1;
-uint32_t zfs_vdev_scrub_max_active = 3;
-uint32_t zfs_vdev_removal_min_active = 1;
-uint32_t zfs_vdev_removal_max_active = 2;
-uint32_t zfs_vdev_initializing_min_active = 1;
-uint32_t zfs_vdev_initializing_max_active = 1;
-uint32_t zfs_vdev_trim_min_active = 1;
-uint32_t zfs_vdev_trim_max_active = 2;
-uint32_t zfs_vdev_rebuild_min_active = 1;
-uint32_t zfs_vdev_rebuild_max_active = 3;
+static uint32_t zfs_vdev_sync_read_min_active = 10;
+static uint32_t zfs_vdev_sync_read_max_active = 10;
+static uint32_t zfs_vdev_sync_write_min_active = 10;
+static uint32_t zfs_vdev_sync_write_max_active = 10;
+static uint32_t zfs_vdev_async_read_min_active = 1;
+/*  */ uint32_t zfs_vdev_async_read_max_active = 3;
+static uint32_t zfs_vdev_async_write_min_active = 2;
+/*  */ uint32_t zfs_vdev_async_write_max_active = 10;
+static uint32_t zfs_vdev_scrub_min_active = 1;
+static uint32_t zfs_vdev_scrub_max_active = 3;
+static uint32_t zfs_vdev_removal_min_active = 1;
+static uint32_t zfs_vdev_removal_max_active = 2;
+static uint32_t zfs_vdev_initializing_min_active = 1;
+static uint32_t zfs_vdev_initializing_max_active = 1;
+static uint32_t zfs_vdev_trim_min_active = 1;
+static uint32_t zfs_vdev_trim_max_active = 2;
+static uint32_t zfs_vdev_rebuild_min_active = 1;
+static uint32_t zfs_vdev_rebuild_max_active = 3;
 
 /*
  * When the pool has less than zfs_vdev_async_write_active_min_dirty_percent
@@ -178,7 +178,7 @@ int zfs_vdev_async_write_active_max_dirty_percent = 60;
  * interactive I/O, then the vdev is considered to be "idle", and the number
  * of concurrently-active non-interactive I/O's is increased to *_max_active.
  */
-uint_t zfs_vdev_nia_delay = 5;
+static uint_t zfs_vdev_nia_delay = 5;
 
 /*
  * Some HDDs tend to prioritize sequential I/O so high that concurrent
@@ -190,7 +190,7 @@ uint_t zfs_vdev_nia_delay = 5;
  * I/Os.  This enforced wait ensures the HDD services the interactive I/O
  * within a reasonable amount of time.
  */
-uint_t zfs_vdev_nia_credit = 5;
+static uint_t zfs_vdev_nia_credit = 5;
 
 /*
  * To reduce IOPs, we aggregate small adjacent I/Os into one large I/O.
@@ -198,10 +198,10 @@ uint_t zfs_vdev_nia_credit = 5;
  * we include spans of optional I/Os to aid aggregation at the disk even when
  * they aren't able to help us aggregate at this level.
  */
-int zfs_vdev_aggregation_limit = 1 << 20;
-int zfs_vdev_aggregation_limit_non_rotating = SPA_OLD_MAXBLOCKSIZE;
-int zfs_vdev_read_gap_limit = 32 << 10;
-int zfs_vdev_write_gap_limit = 4 << 10;
+static int zfs_vdev_aggregation_limit = 1 << 20;
+static int zfs_vdev_aggregation_limit_non_rotating = SPA_OLD_MAXBLOCKSIZE;
+static int zfs_vdev_read_gap_limit = 32 << 10;
+static int zfs_vdev_write_gap_limit = 4 << 10;
 
 /*
  * Define the queue depth percentage for each top-level. This percentage is
@@ -233,7 +233,7 @@ int zfs_vdev_def_queue_depth = 32;
  * TRIM I/O for extents up to zfs_trim_extent_bytes_max (128M) can be submitted
  * by the TRIM code in zfs_trim.c.
  */
-int zfs_vdev_aggregate_trim = 0;
+static int zfs_vdev_aggregate_trim = 0;
 
 static int
 vdev_queue_offset_compare(const void *x1, const void *x2)
diff --git a/sys/contrib/openzfs/module/zfs/vdev_raidz.c b/sys/contrib/openzfs/module/zfs/vdev_raidz.c
index 7e7202ec1e55..84e626b44db2 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_raidz.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_raidz.c
@@ -648,10 +648,10 @@ vdev_raidz_generate_parity(raidz_map_t *rm)
 	}
 }
 
-/* ARGSUSED */
 static int
 vdev_raidz_reconst_p_func(void *dbuf, void *sbuf, size_t size, void *private)
 {
+	(void) private;
 	uint64_t *dst = dbuf;
 	uint64_t *src = sbuf;
 	int cnt = size / sizeof (src[0]);
@@ -663,11 +663,11 @@ vdev_raidz_reconst_p_func(void *dbuf, void *sbuf, size_t size, void *private)
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 vdev_raidz_reconst_q_pre_func(void *dbuf, void *sbuf, size_t size,
     void *private)
 {
+	(void) private;
 	uint64_t *dst = dbuf;
 	uint64_t *src = sbuf;
 	uint64_t mask;
@@ -681,10 +681,10 @@ vdev_raidz_reconst_q_pre_func(void *dbuf, void *sbuf, size_t size,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 vdev_raidz_reconst_q_pre_tail_func(void *buf, size_t size, void *private)
 {
+	(void) private;
 	uint64_t *dst = buf;
 	uint64_t mask;
 	int cnt = size / sizeof (dst[0]);
@@ -1752,8 +1752,8 @@ vdev_raidz_io_start(zio_t *zio)
 /*
  * Report a checksum error for a child of a RAID-Z device.
  */
-static void
-raidz_checksum_error(zio_t *zio, raidz_col_t *rc, abd_t *bad_data)
+void
+vdev_raidz_checksum_error(zio_t *zio, raidz_col_t *rc, abd_t *bad_data)
 {
 	vdev_t *vd = zio->io_vd->vdev_child[rc->rc_devidx];
 
@@ -1823,6 +1823,13 @@ raidz_parity_verify(zio_t *zio, raidz_row_t *rr)
 		abd_copy(orig[c], rc->rc_abd, rc->rc_size);
 	}
 
+	/*
+	 * Verify any empty sectors are zero filled to ensure the parity
+	 * is calculated correctly even if these non-data sectors are damaged.
+	 */
+	if (rr->rr_nempty && rr->rr_abd_empty != NULL)
+		ret += vdev_draid_map_verify_empty(zio, rr);
+
 	/*
 	 * Regenerates parity even for !tried||rc_error!=0 columns.  This
 	 * isn't harmful but it does have the side effect of fixing stuff
@@ -1837,7 +1844,7 @@ raidz_parity_verify(zio_t *zio, raidz_row_t *rr)
 			continue;
 
 		if (abd_cmp(orig[c], rc->rc_abd) != 0) {
-			raidz_checksum_error(zio, rc, orig[c]);
+			vdev_raidz_checksum_error(zio, rc, orig[c]);
 			rc->rc_error = SET_ERROR(ECKSUM);
 			ret++;
 		}
@@ -1897,7 +1904,6 @@ vdev_raidz_io_done_verified(zio_t *zio, raidz_row_t *rr)
 	    (zio->io_flags & ZIO_FLAG_RESILVER)) {
 		int n = raidz_parity_verify(zio, rr);
 		unexpected_errors += n;
-		ASSERT3U(parity_errors + n, <=, rr->rr_firstdatacol);
 	}
 
 	if (zio->io_error == 0 && spa_writeable(zio->io_spa) &&
@@ -2023,7 +2029,7 @@ raidz_reconstruct(zio_t *zio, int *ltgts, int ntgts, int nparity)
 					 */
 					if (rc->rc_error == 0 &&
 					    c >= rr->rr_firstdatacol) {
-						raidz_checksum_error(zio,
+						vdev_raidz_checksum_error(zio,
 						    rc, rc->rc_orig_data);
 						rc->rc_error =
 						    SET_ERROR(ECKSUM);
@@ -2496,6 +2502,8 @@ static void
 vdev_raidz_xlate(vdev_t *cvd, const range_seg64_t *logical_rs,
     range_seg64_t *physical_rs, range_seg64_t *remain_rs)
 {
+	(void) remain_rs;
+
 	vdev_t *raidvd = cvd->vdev_parent;
 	ASSERT(raidvd->vdev_ops == &vdev_raidz_ops);
 
diff --git a/sys/contrib/openzfs/module/zfs/vdev_raidz_math.c b/sys/contrib/openzfs/module/zfs/vdev_raidz_math.c
index 03df2df5adaf..50b8dab74848 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_raidz_math.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_raidz_math.c
@@ -43,7 +43,7 @@ static raidz_impl_ops_t vdev_raidz_fastest_impl = {
 };
 
 /* All compiled in implementations */
-const raidz_impl_ops_t *raidz_all_maths[] = {
+static const raidz_impl_ops_t *const raidz_all_maths[] = {
 	&vdev_raidz_original_impl,
 	&vdev_raidz_scalar_impl,
 #if defined(__x86_64) && defined(HAVE_SSE2)	/* only x86_64 for now */
@@ -268,10 +268,10 @@ vdev_raidz_math_reconstruct(raidz_map_t *rm, raidz_row_t *rr,
 		return (rec_fn(rr, dt));
 }
 
-const char *raidz_gen_name[] = {
+const char *const raidz_gen_name[] = {
 	"gen_p", "gen_pq", "gen_pqr"
 };
-const char *raidz_rec_name[] = {
+const char *const raidz_rec_name[] = {
 	"rec_p", "rec_q", "rec_r",
 	"rec_pq", "rec_pr", "rec_qr", "rec_pqr"
 };
@@ -283,18 +283,15 @@ const char *raidz_rec_name[] = {
 static int
 raidz_math_kstat_headers(char *buf, size_t size)
 {
-	int i;
-	ssize_t off;
-
 	ASSERT3U(size, >=, RAIDZ_KSTAT_LINE_LEN);
 
-	off = snprintf(buf, size, "%-17s", "implementation");
+	ssize_t off = snprintf(buf, size, "%-17s", "implementation");
 
-	for (i = 0; i < ARRAY_SIZE(raidz_gen_name); i++)
+	for (int i = 0; i < ARRAY_SIZE(raidz_gen_name); i++)
 		off += snprintf(buf + off, size - off, "%-16s",
 		    raidz_gen_name[i]);
 
-	for (i = 0; i < ARRAY_SIZE(raidz_rec_name); i++)
+	for (int i = 0; i < ARRAY_SIZE(raidz_rec_name); i++)
 		off += snprintf(buf + off, size - off, "%-16s",
 		    raidz_rec_name[i]);
 
diff --git a/sys/contrib/openzfs/module/zfs/vdev_rebuild.c b/sys/contrib/openzfs/module/zfs/vdev_rebuild.c
index 4d7de0c6c44c..fd2490c0aed6 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_rebuild.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_rebuild.c
@@ -103,7 +103,7 @@
  * Size of rebuild reads; defaults to 1MiB per data disk and is capped at
  * SPA_MAXBLOCKSIZE.
  */
-unsigned long zfs_rebuild_max_segment = 1024 * 1024;
+static unsigned long zfs_rebuild_max_segment = 1024 * 1024;
 
 /*
  * Maximum number of parallelly executed bytes per leaf vdev caused by a
@@ -121,14 +121,14 @@ unsigned long zfs_rebuild_max_segment = 1024 * 1024;
  * With a value of 32MB the sequential resilver write rate was measured at
  * 800MB/s sustained while rebuilding to a distributed spare.
  */
-unsigned long zfs_rebuild_vdev_limit = 32 << 20;
+static unsigned long zfs_rebuild_vdev_limit = 32 << 20;
 
 /*
  * Automatically start a pool scrub when the last active sequential resilver
  * completes in order to verify the checksums of all blocks which have been
  * resilvered. This option is enabled by default and is strongly recommended.
  */
-int zfs_rebuild_scrub_enabled = 1;
+static int zfs_rebuild_scrub_enabled = 1;
 
 /*
  * For vdev_rebuild_initiate_sync() and vdev_rebuild_reset_sync().
diff --git a/sys/contrib/openzfs/module/zfs/vdev_removal.c b/sys/contrib/openzfs/module/zfs/vdev_removal.c
index 482b5bb0ba54..149de633dca8 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_removal.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_removal.c
@@ -94,7 +94,7 @@ typedef struct vdev_copy_arg {
  * doing a device removal.  This determines how much i/o we can have
  * in flight concurrently.
  */
-int zfs_remove_max_copy_bytes = 64 * 1024 * 1024;
+static const int zfs_remove_max_copy_bytes = 64 * 1024 * 1024;
 
 /*
  * The largest contiguous segment that we will attempt to allocate when
@@ -112,7 +112,7 @@ int zfs_remove_max_segment = SPA_MAXBLOCKSIZE;
  * not be cancelled.  This can result in a normally recoverable block
  * becoming permanently damaged and is not recommended.
  */
-int zfs_removal_ignore_errors = 0;
+static int zfs_removal_ignore_errors = 0;
 
 /*
  * Allow a remap segment to span free chunks of at most this size. The main
@@ -1820,10 +1820,10 @@ vdev_prop_allocating_off(vdev_t *vd)
 	return (allocating == 0);
 }
 
-/* ARGSUSED */
 static int
 spa_vdev_remove_cancel_check(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	spa_t *spa = dmu_tx_pool(tx)->dp_spa;
 
 	if (spa->spa_vdev_removal == NULL)
@@ -1835,10 +1835,10 @@ spa_vdev_remove_cancel_check(void *arg, dmu_tx_t *tx)
  * Cancel a removal by freeing all entries from the partial mapping
  * and marking the vdev as no longer being removing.
  */
-/* ARGSUSED */
 static void
 spa_vdev_remove_cancel_sync(void *arg, dmu_tx_t *tx)
 {
+	(void) arg;
 	spa_t *spa = dmu_tx_pool(tx)->dp_spa;
 	spa_vdev_removal_t *svr = spa->spa_vdev_removal;
 	vdev_t *vd = vdev_lookup_top(spa, svr->svr_vdev_id);
diff --git a/sys/contrib/openzfs/module/zfs/vdev_trim.c b/sys/contrib/openzfs/module/zfs/vdev_trim.c
index deea7fedd770..18aa2b3bfcb0 100644
--- a/sys/contrib/openzfs/module/zfs/vdev_trim.c
+++ b/sys/contrib/openzfs/module/zfs/vdev_trim.c
@@ -96,12 +96,12 @@
 /*
  * Maximum size of TRIM I/O, ranges will be chunked in to 128MiB lengths.
  */
-unsigned int zfs_trim_extent_bytes_max = 128 * 1024 * 1024;
+static unsigned int zfs_trim_extent_bytes_max = 128 * 1024 * 1024;
 
 /*
  * Minimum size of TRIM I/O, extents smaller than 32Kib will be skipped.
  */
-unsigned int zfs_trim_extent_bytes_min = 32 * 1024;
+static unsigned int zfs_trim_extent_bytes_min = 32 * 1024;
 
 /*
  * Skip uninitialized metaslabs during the TRIM process.  This option is
@@ -118,7 +118,7 @@ unsigned int zfs_trim_metaslab_skip = 0;
  * concurrent TRIM I/Os issued to the device is controlled by the
  * zfs_vdev_trim_min_active and zfs_vdev_trim_max_active module options.
  */
-unsigned int zfs_trim_queue_limit = 10;
+static unsigned int zfs_trim_queue_limit = 10;
 
 /*
  * The minimum number of transaction groups between automatic trims of a
@@ -134,7 +134,7 @@ unsigned int zfs_trim_queue_limit = 10;
  * has the opposite effect.  The default value of 32 was determined though
  * testing to be a reasonable compromise.
  */
-unsigned int zfs_trim_txg_batch = 32;
+static unsigned int zfs_trim_txg_batch = 32;
 
 /*
  * The trim_args are a control structure which describe how a leaf vdev
@@ -1003,6 +1003,7 @@ vdev_trim_stop_wait_impl(vdev_t *vd)
 void
 vdev_trim_stop_wait(spa_t *spa, list_t *vd_list)
 {
+	(void) spa;
 	vdev_t *vd;
 
 	ASSERT(MUTEX_HELD(&spa_namespace_lock));
diff --git a/sys/contrib/openzfs/module/zfs/zap.c b/sys/contrib/openzfs/module/zfs/zap.c
index 6f03beef3bdb..98ed284c992c 100644
--- a/sys/contrib/openzfs/module/zfs/zap.c
+++ b/sys/contrib/openzfs/module/zfs/zap.c
@@ -76,7 +76,7 @@
  *    the zfs-specific implementation of the directory's st_size (which is
  *    the number of entries).
  */
-int zap_iterate_prefetch = B_TRUE;
+static int zap_iterate_prefetch = B_TRUE;
 
 int fzap_default_block_shift = 14; /* 16k blocksize */
 
diff --git a/sys/contrib/openzfs/module/zfs/zcp.c b/sys/contrib/openzfs/module/zfs/zcp.c
index f724b44baf1d..0a79068384a5 100644
--- a/sys/contrib/openzfs/module/zfs/zcp.c
+++ b/sys/contrib/openzfs/module/zfs/zcp.c
@@ -108,7 +108,7 @@
 
 #define	ZCP_NVLIST_MAX_DEPTH 20
 
-uint64_t zfs_lua_check_instrlimit_interval = 100;
+static const uint64_t zfs_lua_check_instrlimit_interval = 100;
 unsigned long zfs_lua_max_instrlimit = ZCP_MAX_INSTRLIMIT;
 unsigned long zfs_lua_max_memlimit = ZCP_MAX_MEMLIMIT;
 
@@ -631,11 +631,11 @@ zcp_dataset_hold(lua_State *state, dsl_pool_t *dp, const char *dsname,
 }
 
 static int zcp_debug(lua_State *);
-static zcp_lib_info_t zcp_debug_info = {
+static const zcp_lib_info_t zcp_debug_info = {
 	.name = "debug",
 	.func = zcp_debug,
 	.pargs = {
-	    { .za_name = "debug string", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "debug string", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -648,7 +648,7 @@ zcp_debug(lua_State *state)
 {
 	const char *dbgstring;
 	zcp_run_info_t *ri = zcp_run_info(state);
-	zcp_lib_info_t *libinfo = &zcp_debug_info;
+	const zcp_lib_info_t *libinfo = &zcp_debug_info;
 
 	zcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);
 
@@ -661,11 +661,11 @@ zcp_debug(lua_State *state)
 }
 
 static int zcp_exists(lua_State *);
-static zcp_lib_info_t zcp_exists_info = {
+static const zcp_lib_info_t zcp_exists_info = {
 	.name = "exists",
 	.func = zcp_exists,
 	.pargs = {
-	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -678,7 +678,7 @@ zcp_exists(lua_State *state)
 {
 	zcp_run_info_t *ri = zcp_run_info(state);
 	dsl_pool_t *dp = ri->zri_pool;
-	zcp_lib_info_t *libinfo = &zcp_exists_info;
+	const zcp_lib_info_t *libinfo = &zcp_exists_info;
 
 	zcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);
 
@@ -769,10 +769,10 @@ zcp_lua_alloc(void *ud, void *ptr, size_t osize, size_t nsize)
 	}
 }
 
-/* ARGSUSED */
 static void
 zcp_lua_counthook(lua_State *state, lua_Debug *ar)
 {
+	(void) ar;
 	lua_getfield(state, LUA_REGISTRYINDEX, ZCP_RUN_INFO_KEY);
 	zcp_run_info_t *ri = lua_touserdata(state, -1);
 
@@ -974,10 +974,10 @@ zcp_pool_error(zcp_run_info_t *ri, const char *poolname)
  * The txg_wait_synced_sig will continue to wait for the txg to complete
  * after calling this callback.
  */
-/* ARGSUSED */
 static void
 zcp_eval_sig(void *arg, dmu_tx_t *tx)
 {
+	(void) tx;
 	zcp_run_info_t *ri = arg;
 
 	ri->zri_canceled = B_TRUE;
diff --git a/sys/contrib/openzfs/module/zfs/zcp_get.c b/sys/contrib/openzfs/module/zfs/zcp_get.c
index 7256e4de1915..fe712afd7ade 100644
--- a/sys/contrib/openzfs/module/zfs/zcp_get.c
+++ b/sys/contrib/openzfs/module/zfs/zcp_get.c
@@ -743,12 +743,12 @@ zcp_get_written_prop(lua_State *state, dsl_pool_t *dp,
 }
 
 static int zcp_get_prop(lua_State *state);
-static zcp_lib_info_t zcp_get_prop_info = {
+static const zcp_lib_info_t zcp_get_prop_info = {
 	.name = "get_prop",
 	.func = zcp_get_prop,
 	.pargs = {
-	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING},
-	    { .za_name = "property", .za_lua_type =  LUA_TSTRING},
+	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING },
+	    { .za_name = "property", .za_lua_type =  LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -762,7 +762,7 @@ zcp_get_prop(lua_State *state)
 	const char *dataset_name;
 	const char *property_name;
 	dsl_pool_t *dp = zcp_run_info(state)->zri_pool;
-	zcp_lib_info_t *libinfo = &zcp_get_prop_info;
+	const zcp_lib_info_t *libinfo = &zcp_get_prop_info;
 
 	zcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);
 
diff --git a/sys/contrib/openzfs/module/zfs/zcp_iter.c b/sys/contrib/openzfs/module/zfs/zcp_iter.c
index f727c56f212d..ed575738fc8b 100644
--- a/sys/contrib/openzfs/module/zfs/zcp_iter.c
+++ b/sys/contrib/openzfs/module/zfs/zcp_iter.c
@@ -107,12 +107,12 @@ zcp_clones_iter(lua_State *state)
 }
 
 static int zcp_clones_list(lua_State *);
-static zcp_list_info_t zcp_clones_list_info = {
+static const zcp_list_info_t zcp_clones_list_info = {
 	.name = "clones",
 	.func = zcp_clones_list,
 	.gc = NULL,
 	.pargs = {
-	    { .za_name = "snapshot", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "snapshot", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -194,12 +194,12 @@ zcp_snapshots_iter(lua_State *state)
 }
 
 static int zcp_snapshots_list(lua_State *);
-static zcp_list_info_t zcp_snapshots_list_info = {
+static const zcp_list_info_t zcp_snapshots_list_info = {
 	.name = "snapshots",
 	.func = zcp_snapshots_list,
 	.gc = NULL,
 	.pargs = {
-	    { .za_name = "filesystem | volume", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "filesystem | volume", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -281,12 +281,12 @@ zcp_children_iter(lua_State *state)
 }
 
 static int zcp_children_list(lua_State *);
-static zcp_list_info_t zcp_children_list_info = {
+static const zcp_list_info_t zcp_children_list_info = {
 	.name = "children",
 	.func = zcp_children_list,
 	.gc = NULL,
 	.pargs = {
-	    { .za_name = "filesystem | volume", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "filesystem | volume", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -361,13 +361,13 @@ zcp_user_props_iter(lua_State *state)
 }
 
 static int zcp_user_props_list(lua_State *);
-static zcp_list_info_t zcp_user_props_list_info = {
+static const zcp_list_info_t zcp_user_props_list_info = {
 	.name = "user_properties",
 	.func = zcp_user_props_list,
 	.gc = zcp_user_props_list_gc,
 	.pargs = {
 	    { .za_name = "filesystem | snapshot | volume",
-	    .za_lua_type = LUA_TSTRING},
+	    .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -383,13 +383,13 @@ static zcp_list_info_t zcp_user_props_list_info = {
  * versions of ZFS, we declare 'properties' as an alias for
  * 'user_properties'.
  */
-static zcp_list_info_t zcp_props_list_info = {
+static const zcp_list_info_t zcp_props_list_info = {
 	.name = "properties",
 	.func = zcp_user_props_list,
 	.gc = zcp_user_props_list_gc,
 	.pargs = {
 	    { .za_name = "filesystem | snapshot | volume",
-	    .za_lua_type = LUA_TSTRING},
+	    .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -444,11 +444,11 @@ zcp_dataset_system_props(dsl_dataset_t *ds, nvlist_t *nv)
 }
 
 static int zcp_system_props_list(lua_State *);
-static zcp_list_info_t zcp_system_props_list_info = {
+static const zcp_list_info_t zcp_system_props_list_info = {
 	.name = "system_properties",
 	.func = zcp_system_props_list,
 	.pargs = {
-	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -467,7 +467,7 @@ zcp_system_props_list(lua_State *state)
 	char errbuf[128];
 	const char *dataset_name;
 	dsl_pool_t *dp = zcp_run_info(state)->zri_pool;
-	zcp_list_info_t *libinfo = &zcp_system_props_list_info;
+	const zcp_list_info_t *libinfo = &zcp_system_props_list_info;
 	zcp_parse_args(state, libinfo->name, libinfo->pargs, libinfo->kwargs);
 	dataset_name = lua_tostring(state, 1);
 	nvlist_t *nv = fnvlist_alloc();
@@ -566,11 +566,11 @@ zcp_bookmarks_iter(lua_State *state)
 }
 
 static int zcp_bookmarks_list(lua_State *);
-static zcp_list_info_t zcp_bookmarks_list_info = {
+static const zcp_list_info_t zcp_bookmarks_list_info = {
 	.name = "bookmarks",
 	.func = zcp_bookmarks_list,
 	.pargs = {
-	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "dataset", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -654,12 +654,12 @@ zcp_holds_iter(lua_State *state)
 }
 
 static int zcp_holds_list(lua_State *);
-static zcp_list_info_t zcp_holds_list_info = {
+static const zcp_list_info_t zcp_holds_list_info = {
 	.name = "holds",
 	.func = zcp_holds_list,
 	.gc = NULL,
 	.pargs = {
-	    { .za_name = "snapshot", .za_lua_type = LUA_TSTRING},
+	    { .za_name = "snapshot", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -710,8 +710,7 @@ zcp_list_func(lua_State *state)
 int
 zcp_load_list_lib(lua_State *state)
 {
-	int i;
-	zcp_list_info_t *zcp_list_funcs[] = {
+	const zcp_list_info_t *zcp_list_funcs[] = {
 		&zcp_children_list_info,
 		&zcp_snapshots_list_info,
 		&zcp_user_props_list_info,
@@ -725,8 +724,8 @@ zcp_load_list_lib(lua_State *state)
 
 	lua_newtable(state);
 
-	for (i = 0; zcp_list_funcs[i] != NULL; i++) {
-		zcp_list_info_t *info = zcp_list_funcs[i];
+	for (int i = 0; zcp_list_funcs[i] != NULL; i++) {
+		const zcp_list_info_t *info = zcp_list_funcs[i];
 
 		if (info->gc != NULL) {
 			/*
@@ -741,10 +740,9 @@ zcp_load_list_lib(lua_State *state)
 			lua_pop(state, 1);
 		}
 
-		lua_pushlightuserdata(state, info);
+		lua_pushlightuserdata(state, (void *)(uintptr_t)info);
 		lua_pushcclosure(state, &zcp_list_func, 1);
 		lua_setfield(state, -2, info->name);
-		info++;
 	}
 
 	return (1);
diff --git a/sys/contrib/openzfs/module/zfs/zcp_synctask.c b/sys/contrib/openzfs/module/zfs/zcp_synctask.c
index c6ade59b9ced..403856ae3571 100644
--- a/sys/contrib/openzfs/module/zfs/zcp_synctask.c
+++ b/sys/contrib/openzfs/module/zfs/zcp_synctask.c
@@ -114,25 +114,25 @@ zcp_sync_task(lua_State *state, dsl_checkfunc_t *checkfunc,
 
 
 static int zcp_synctask_destroy(lua_State *, boolean_t, nvlist_t *);
-static zcp_synctask_info_t zcp_synctask_destroy_info = {
+static const zcp_synctask_info_t zcp_synctask_destroy_info = {
 	.name = "destroy",
 	.func = zcp_synctask_destroy,
 	.pargs = {
-	    {.za_name = "filesystem | snapshot", .za_lua_type = LUA_TSTRING},
+	    {.za_name = "filesystem | snapshot", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
-	    {.za_name = "defer", .za_lua_type = LUA_TBOOLEAN},
+	    {.za_name = "defer", .za_lua_type = LUA_TBOOLEAN },
 	    {NULL, 0}
 	},
 	.space_check = ZFS_SPACE_CHECK_DESTROY,
 	.blocks_modified = 0
 };
 
-/* ARGSUSED */
 static int
 zcp_synctask_destroy(lua_State *state, boolean_t sync, nvlist_t *err_details)
 {
+	(void) err_details;
 	int err;
 	const char *dsname = lua_tostring(state, 1);
 
@@ -167,11 +167,11 @@ zcp_synctask_destroy(lua_State *state, boolean_t sync, nvlist_t *err_details)
 }
 
 static int zcp_synctask_promote(lua_State *, boolean_t, nvlist_t *);
-static zcp_synctask_info_t zcp_synctask_promote_info = {
+static const zcp_synctask_info_t zcp_synctask_promote_info = {
 	.name = "promote",
 	.func = zcp_synctask_promote,
 	.pargs = {
-	    {.za_name = "clone", .za_lua_type = LUA_TSTRING},
+	    {.za_name = "clone", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -205,13 +205,13 @@ zcp_synctask_promote(lua_State *state, boolean_t sync, nvlist_t *err_details)
 }
 
 static int zcp_synctask_rollback(lua_State *, boolean_t, nvlist_t *err_details);
-static zcp_synctask_info_t zcp_synctask_rollback_info = {
+static const zcp_synctask_info_t zcp_synctask_rollback_info = {
 	.name = "rollback",
 	.func = zcp_synctask_rollback,
 	.space_check = ZFS_SPACE_CHECK_RESERVED,
 	.blocks_modified = 1,
 	.pargs = {
-	    {.za_name = "filesystem", .za_lua_type = LUA_TSTRING},
+	    {.za_name = "filesystem", .za_lua_type = LUA_TSTRING },
 	    {0, 0}
 	},
 	.kwargs = {
@@ -236,12 +236,12 @@ zcp_synctask_rollback(lua_State *state, boolean_t sync, nvlist_t *err_details)
 }
 
 static int zcp_synctask_snapshot(lua_State *, boolean_t, nvlist_t *);
-static zcp_synctask_info_t zcp_synctask_snapshot_info = {
+static const zcp_synctask_info_t zcp_synctask_snapshot_info = {
 	.name = "snapshot",
 	.func = zcp_synctask_snapshot,
 	.pargs = {
 	    {.za_name = "filesystem@snapname | volume@snapname",
-	    .za_lua_type = LUA_TSTRING},
+	    .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -251,10 +251,10 @@ static zcp_synctask_info_t zcp_synctask_snapshot_info = {
 	.blocks_modified = 3
 };
 
-/* ARGSUSED */
 static int
 zcp_synctask_snapshot(lua_State *state, boolean_t sync, nvlist_t *err_details)
 {
+	(void) err_details;
 	int err;
 	dsl_dataset_snapshot_arg_t ddsa = { 0 };
 	const char *dsname = lua_tostring(state, 1);
@@ -304,7 +304,7 @@ zcp_synctask_snapshot(lua_State *state, boolean_t sync, nvlist_t *err_details)
 
 static int zcp_synctask_inherit_prop(lua_State *, boolean_t,
     nvlist_t *err_details);
-static zcp_synctask_info_t zcp_synctask_inherit_prop_info = {
+static const zcp_synctask_info_t zcp_synctask_inherit_prop_info = {
 	.name = "inherit",
 	.func = zcp_synctask_inherit_prop,
 	.space_check = ZFS_SPACE_CHECK_RESERVED,
@@ -354,6 +354,7 @@ static int
 zcp_synctask_inherit_prop(lua_State *state, boolean_t sync,
     nvlist_t *err_details)
 {
+	(void) err_details;
 	int err;
 	zcp_inherit_prop_arg_t zipa = { 0 };
 	dsl_props_set_arg_t *dpsa = &zipa.zipa_dpsa;
@@ -381,12 +382,12 @@ zcp_synctask_inherit_prop(lua_State *state, boolean_t sync,
 }
 
 static int zcp_synctask_bookmark(lua_State *, boolean_t, nvlist_t *);
-static zcp_synctask_info_t zcp_synctask_bookmark_info = {
+static const zcp_synctask_info_t zcp_synctask_bookmark_info = {
 	.name = "bookmark",
 	.func = zcp_synctask_bookmark,
 	.pargs = {
-	    {.za_name = "snapshot | bookmark", .za_lua_type = LUA_TSTRING},
-	    {.za_name = "bookmark", .za_lua_type = LUA_TSTRING},
+	    {.za_name = "snapshot | bookmark", .za_lua_type = LUA_TSTRING },
+	    {.za_name = "bookmark", .za_lua_type = LUA_TSTRING },
 	    {NULL, 0}
 	},
 	.kwargs = {
@@ -396,10 +397,10 @@ static zcp_synctask_info_t zcp_synctask_bookmark_info = {
 	.blocks_modified = 1,
 };
 
-/* ARGSUSED */
 static int
 zcp_synctask_bookmark(lua_State *state, boolean_t sync, nvlist_t *err_details)
 {
+	(void) err_details;
 	int err;
 	const char *source = lua_tostring(state, 1);
 	const char *new = lua_tostring(state, 2);
@@ -424,15 +425,15 @@ zcp_synctask_bookmark(lua_State *state, boolean_t sync, nvlist_t *err_details)
 }
 
 static int zcp_synctask_set_prop(lua_State *, boolean_t, nvlist_t *err_details);
-static zcp_synctask_info_t zcp_synctask_set_prop_info = {
+static const zcp_synctask_info_t zcp_synctask_set_prop_info = {
 	.name = "set_prop",
 	.func = zcp_synctask_set_prop,
 	.space_check = ZFS_SPACE_CHECK_RESERVED,
 	.blocks_modified = 2,
 	.pargs = {
-		{ .za_name = "dataset", .za_lua_type = LUA_TSTRING},
-		{ .za_name = "property", .za_lua_type =  LUA_TSTRING},
-		{ .za_name = "value", .za_lua_type =  LUA_TSTRING},
+		{ .za_name = "dataset", .za_lua_type = LUA_TSTRING },
+		{ .za_name = "property", .za_lua_type =  LUA_TSTRING },
+		{ .za_name = "value", .za_lua_type =  LUA_TSTRING },
 		{ NULL, 0 }
 	},
 	.kwargs = {
@@ -443,6 +444,7 @@ static zcp_synctask_info_t zcp_synctask_set_prop_info = {
 static int
 zcp_synctask_set_prop(lua_State *state, boolean_t sync, nvlist_t *err_details)
 {
+	(void) err_details;
 	int err;
 	zcp_set_prop_arg_t args = { 0 };
 
@@ -522,8 +524,7 @@ zcp_synctask_wrapper(lua_State *state)
 int
 zcp_load_synctask_lib(lua_State *state, boolean_t sync)
 {
-	int i;
-	zcp_synctask_info_t *zcp_synctask_funcs[] = {
+	const zcp_synctask_info_t *zcp_synctask_funcs[] = {
 		&zcp_synctask_destroy_info,
 		&zcp_synctask_promote_info,
 		&zcp_synctask_rollback_info,
@@ -536,13 +537,12 @@ zcp_load_synctask_lib(lua_State *state, boolean_t sync)
 
 	lua_newtable(state);
 
-	for (i = 0; zcp_synctask_funcs[i] != NULL; i++) {
-		zcp_synctask_info_t *info = zcp_synctask_funcs[i];
-		lua_pushlightuserdata(state, info);
+	for (int i = 0; zcp_synctask_funcs[i] != NULL; i++) {
+		const zcp_synctask_info_t *info = zcp_synctask_funcs[i];
+		lua_pushlightuserdata(state, (void *)(uintptr_t)info);
 		lua_pushboolean(state, sync);
 		lua_pushcclosure(state, &zcp_synctask_wrapper, 2);
 		lua_setfield(state, -2, info->name);
-		info++;
 	}
 
 	return (1);
diff --git a/sys/contrib/openzfs/module/zfs/zfs_fm.c b/sys/contrib/openzfs/module/zfs/zfs_fm.c
index 007f31b4e7b3..828385b430b4 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_fm.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_fm.c
@@ -59,7 +59,7 @@
  * read I/Os, there  are basically three 'types' of I/O, which form a roughly
  * layered diagram:
  *
- *      +---------------+
+ * 	+---------------+
  * 	| Aggregate I/O |	No associated logical data or device
  * 	+---------------+
  *              |
@@ -124,14 +124,14 @@ static taskqid_t recent_events_cleaner_tqid;
  * This setting can be changed dynamically and setting it to zero
  * disables duplicate detection.
  */
-unsigned int zfs_zevent_retain_max = 2000;
+static unsigned int zfs_zevent_retain_max = 2000;
 
 /*
  * The lifespan for a recent ereport entry. The default of 15 minutes is
  * intended to outlive the zfs diagnosis engine's threshold of 10 errors
  * over a period of 10 minutes.
  */
-unsigned int zfs_zevent_retain_expire_secs = 900;
+static unsigned int zfs_zevent_retain_expire_secs = 900;
 
 typedef enum zfs_subclass {
 	ZSC_IO,
@@ -205,7 +205,6 @@ static void zfs_ereport_schedule_cleaner(void);
 /*
  * background task to clean stale recent event nodes.
  */
-/*ARGSUSED*/
 static void
 zfs_ereport_cleaner(void *arg)
 {
@@ -826,9 +825,6 @@ annotate_ecksum(nvlist_t *ereport, zio_bad_cksum_t *info,
 	const uint64_t *good;
 	const uint64_t *bad;
 
-	uint64_t allset = 0;
-	uint64_t allcleared = 0;
-
 	size_t nui64s = size / sizeof (uint64_t);
 
 	size_t inline_size;
@@ -930,9 +926,6 @@ annotate_ecksum(nvlist_t *ereport, zio_bad_cksum_t *info,
 			// bits set in good, but not in bad
 			cleared = (good[idx] & (~bad[idx]));
 
-			allset |= set;
-			allcleared |= cleared;
-
 			if (!no_inline) {
 				ASSERT3U(offset, <, inline_size);
 				eip->zei_bits_set[offset] = set;
@@ -992,10 +985,10 @@ annotate_ecksum(nvlist_t *ereport, zio_bad_cksum_t *info,
 	return (eip);
 }
 #else
-/*ARGSUSED*/
 void
 zfs_ereport_clear(spa_t *spa, vdev_t *vd)
 {
+	(void) spa, (void) vd;
 }
 #endif
 
@@ -1072,6 +1065,8 @@ zfs_ereport_is_valid(const char *subclass, spa_t *spa, vdev_t *vd, zio_t *zio)
 	    (zio != NULL) && (!zio->io_timestamp)) {
 		return (B_FALSE);
 	}
+#else
+	(void) subclass, (void) spa, (void) vd, (void) zio;
 #endif
 	return (B_TRUE);
 }
@@ -1112,6 +1107,9 @@ zfs_ereport_post(const char *subclass, spa_t *spa, vdev_t *vd,
 
 	/* Cleanup is handled by the callback function */
 	rc = zfs_zevent_post(ereport, detector, zfs_zevent_post_cb);
+#else
+	(void) subclass, (void) spa, (void) vd, (void) zb, (void) zio,
+	    (void) state;
 #endif
 	return (rc);
 }
@@ -1141,6 +1139,8 @@ zfs_ereport_start_checksum(spa_t *spa, vdev_t *vd, const zbookmark_phys_t *zb,
 
 	if (zfs_is_ratelimiting_event(FM_EREPORT_ZFS_CHECKSUM, vd))
 		return (SET_ERROR(EBUSY));
+#else
+	(void) zb, (void) offset;
 #endif
 
 	report = kmem_zalloc(sizeof (*report), KM_SLEEP);
@@ -1193,6 +1193,9 @@ zfs_ereport_finish_checksum(zio_cksum_report_t *report, const abd_t *good_data,
 	report->zcr_ereport = report->zcr_detector = NULL;
 	if (info != NULL)
 		kmem_free(info, sizeof (*info));
+#else
+	(void) report, (void) good_data, (void) bad_data,
+	    (void) drop_if_identical;
 #endif
 }
 
@@ -1257,6 +1260,9 @@ zfs_ereport_post_checksum(spa_t *spa, vdev_t *vd, const zbookmark_phys_t *zb,
 		rc = zfs_zevent_post(ereport, detector, zfs_zevent_post_cb);
 		kmem_free(info, sizeof (*info));
 	}
+#else
+	(void) spa, (void) vd, (void) zb, (void) zio, (void) offset,
+	    (void) length, (void) good_data, (void) bad_data, (void) zbc;
 #endif
 	return (rc);
 }
@@ -1321,7 +1327,8 @@ zfs_event_create(spa_t *spa, vdev_t *vd, const char *type, const char *name,
 		while ((elem = nvlist_next_nvpair(aux, elem)) != NULL)
 			(void) nvlist_add_nvpair(resource, elem);
 	}
-
+#else
+	(void) spa, (void) vd, (void) type, (void) name, (void) aux;
 #endif
 	return (resource);
 }
@@ -1336,6 +1343,8 @@ zfs_post_common(spa_t *spa, vdev_t *vd, const char *type, const char *name,
 	resource = zfs_event_create(spa, vd, type, name, aux);
 	if (resource)
 		zfs_zevent_post(resource, NULL, zfs_zevent_post_cb);
+#else
+	(void) spa, (void) vd, (void) type, (void) name, (void) aux;
 #endif
 }
 
@@ -1399,6 +1408,8 @@ zfs_post_state_change(spa_t *spa, vdev_t *vd, uint64_t laststate)
 
 	if (aux)
 		fm_nvlist_destroy(aux, FM_NVA_FREE);
+#else
+	(void) spa, (void) vd, (void) laststate;
 #endif
 }
 
diff --git a/sys/contrib/openzfs/module/zfs/zfs_ioctl.c b/sys/contrib/openzfs/module/zfs/zfs_ioctl.c
index ca2da561220b..e592734eea09 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_ioctl.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_ioctl.c
@@ -222,7 +222,7 @@
 #include <sys/zfs_ioctl_impl.h>
 
 kmutex_t zfsdev_state_lock;
-zfsdev_state_t *zfsdev_state_list;
+static zfsdev_state_t *zfsdev_state_list;
 
 /*
  * Limit maximum nvlist size.  We don't want users passing in insane values
@@ -236,7 +236,7 @@ unsigned long zfs_max_nvlist_src_size = 0;
  * the logged size to this many bytes.  This must be less than DMU_MAX_ACCESS.
  * This applies primarily to zfs_ioc_channel_program().
  */
-unsigned long zfs_history_output_max = 1024 * 1024;
+static unsigned long zfs_history_output_max = 1024 * 1024;
 
 uint_t zfs_fsyncer_key;
 uint_t zfs_allow_log_key;
@@ -6095,10 +6095,6 @@ zfs_ioc_share(zfs_cmd_t *zc)
 	return (SET_ERROR(ENOSYS));
 }
 
-ace_t full_access[] = {
-	{(uid_t)-1, ACE_ALL_PERMS, ACE_EVERYONE, 0}
-};
-
 /*
  * inputs:
  * zc_name		name of containing filesystem
diff --git a/sys/contrib/openzfs/module/zfs/zfs_log.c b/sys/contrib/openzfs/module/zfs/zfs_log.c
index e248dc3cc4e8..2f3eab67993e 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_log.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_log.c
@@ -530,7 +530,7 @@ zfs_log_rename(zilog_t *zilog, dmu_tx_t *tx, uint64_t txtype, znode_t *sdzp,
  * called as soon as the write is on stable storage (be it via a DMU sync or a
  * ZIL commit).
  */
-long zfs_immediate_write_sz = 32768;
+static long zfs_immediate_write_sz = 32768;
 
 void
 zfs_log_write(zilog_t *zilog, dmu_tx_t *tx, int txtype,
diff --git a/sys/contrib/openzfs/module/zfs/zfs_replay.c b/sys/contrib/openzfs/module/zfs/zfs_replay.c
index e6ed3e738e40..f76725f0b716 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_replay.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_replay.c
@@ -967,7 +967,7 @@ zfs_replay_acl(void *arg1, void *arg2, boolean_t byteswap)
 /*
  * Callback vectors for replaying records
  */
-zil_replay_func_t *zfs_replay_vector[TX_MAX_TYPE] = {
+zil_replay_func_t *const zfs_replay_vector[TX_MAX_TYPE] = {
 	zfs_replay_error,	/* no such type */
 	zfs_replay_create,	/* TX_CREATE */
 	zfs_replay_create,	/* TX_MKDIR */
diff --git a/sys/contrib/openzfs/module/zfs/zfs_sa.c b/sys/contrib/openzfs/module/zfs/zfs_sa.c
index 67be131da63b..817f63048789 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_sa.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_sa.c
@@ -43,7 +43,7 @@
  * this version of ZFS won't change or delete them.
  */
 
-sa_attr_reg_t zfs_attr_table[ZPL_END+1] = {
+const sa_attr_reg_t zfs_attr_table[ZPL_END+1] = {
 	{"ZPL_ATIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 0},
 	{"ZPL_MTIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 1},
 	{"ZPL_CTIME", sizeof (uint64_t) * 2, SA_UINT64_ARRAY, 2},
diff --git a/sys/contrib/openzfs/module/zfs/zfs_vnops.c b/sys/contrib/openzfs/module/zfs/zfs_vnops.c
index 7cbb70f499af..b7fdae926520 100644
--- a/sys/contrib/openzfs/module/zfs/zfs_vnops.c
+++ b/sys/contrib/openzfs/module/zfs/zfs_vnops.c
@@ -338,7 +338,7 @@ zfs_read(struct znode *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)
 int
 zfs_write(znode_t *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)
 {
-	int error = 0;
+	int error = 0, error1;
 	ssize_t start_resid = zfs_uio_resid(uio);
 
 	/*
@@ -576,7 +576,11 @@ zfs_write(znode_t *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)
 				continue;
 			}
 #endif
-			if (error != 0) {
+			/*
+			 * On FreeBSD, EFAULT should be propagated back to the
+			 * VFS, which will handle faulting and will retry.
+			 */
+			if (error != 0 && error != EFAULT) {
 				dmu_tx_commit(tx);
 				break;
 			}
@@ -660,7 +664,7 @@ zfs_write(znode_t *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)
 		while ((end_size = zp->z_size) < zfs_uio_offset(uio)) {
 			(void) atomic_cas_64(&zp->z_size, end_size,
 			    zfs_uio_offset(uio));
-			ASSERT(error == 0);
+			ASSERT(error == 0 || error == EFAULT);
 		}
 		/*
 		 * If we are replaying and eof is non zero then force
@@ -670,7 +674,10 @@ zfs_write(znode_t *zp, zfs_uio_t *uio, int ioflag, cred_t *cr)
 		if (zfsvfs->z_replay && zfsvfs->z_replay_eof != 0)
 			zp->z_size = zfsvfs->z_replay_eof;
 
-		error = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);
+		error1 = sa_bulk_update(zp->z_sa_hdl, bulk, count, tx);
+		if (error1 != 0)
+			/* Avoid clobbering EFAULT. */
+			error = error1;
 
 		zfs_log_write(zilog, tx, TX_WRITE, zp, woff, tx_bytes, ioflag,
 		    NULL, NULL);
diff --git a/sys/contrib/openzfs/module/zfs/zil.c b/sys/contrib/openzfs/module/zfs/zil.c
index 640e805d093a..85a17f10b38f 100644
--- a/sys/contrib/openzfs/module/zfs/zil.c
+++ b/sys/contrib/openzfs/module/zfs/zil.c
@@ -89,12 +89,12 @@
  * committed to stable storage. Please refer to the zil_commit_waiter()
  * function (and the comments within it) for more details.
  */
-int zfs_commit_timeout_pct = 5;
+static int zfs_commit_timeout_pct = 5;
 
 /*
  * See zil.h for more information about these fields.
  */
-zil_stats_t zil_stats = {
+static zil_stats_t zil_stats = {
 	{ "zil_commit_count",			KSTAT_DATA_UINT64 },
 	{ "zil_commit_writer_count",		KSTAT_DATA_UINT64 },
 	{ "zil_itx_count",			KSTAT_DATA_UINT64 },
@@ -123,14 +123,14 @@ int zil_replay_disable = 0;
  * will cause ZIL corruption on power loss if a volatile out-of-order
  * write cache is enabled.
  */
-int zil_nocacheflush = 0;
+static int zil_nocacheflush = 0;
 
 /*
  * Limit SLOG write size per commit executed with synchronous priority.
  * Any writes above that will be executed with lower (asynchronous) priority
  * to limit potential SLOG device abuse by single active ZIL writer.
  */
-unsigned long zil_slog_bulk = 768 * 1024;
+static unsigned long zil_slog_bulk = 768 * 1024;
 
 static kmem_cache_t *zil_lwb_cache;
 static kmem_cache_t *zil_zcw_cache;
@@ -432,11 +432,11 @@ zil_parse(zilog_t *zilog, zil_parse_blk_func_t *parse_blk_func,
 	return (error);
 }
 
-/* ARGSUSED */
 static int
 zil_clear_log_block(zilog_t *zilog, const blkptr_t *bp, void *tx,
     uint64_t first_txg)
 {
+	(void) tx;
 	ASSERT(!BP_IS_HOLE(bp));
 
 	/*
@@ -455,11 +455,11 @@ zil_clear_log_block(zilog_t *zilog, const blkptr_t *bp, void *tx,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 zil_noop_log_record(zilog_t *zilog, const lr_t *lrc, void *tx,
     uint64_t first_txg)
 {
+	(void) zilog, (void) lrc, (void) tx, (void) first_txg;
 	return (0);
 }
 
@@ -507,11 +507,12 @@ zil_claim_log_record(zilog_t *zilog, const lr_t *lrc, void *tx,
 	return (zil_claim_log_block(zilog, &lr->lr_blkptr, tx, first_txg));
 }
 
-/* ARGSUSED */
 static int
 zil_free_log_block(zilog_t *zilog, const blkptr_t *bp, void *tx,
     uint64_t claim_txg)
 {
+	(void) claim_txg;
+
 	zio_free(zilog->zl_spa, dmu_tx_get_txg(tx), bp);
 
 	return (0);
@@ -911,10 +912,10 @@ zil_claim(dsl_pool_t *dp, dsl_dataset_t *ds, void *txarg)
  * Checksum errors are ok as they indicate the end of the chain.
  * Any other error (no device or read failure) returns an error.
  */
-/* ARGSUSED */
 int
 zil_check_log_chain(dsl_pool_t *dp, dsl_dataset_t *ds, void *tx)
 {
+	(void) dp;
 	zilog_t *zilog;
 	objset_t *os;
 	blkptr_t *bp;
@@ -1450,7 +1451,7 @@ zil_lwb_write_open(zilog_t *zilog, lwb_t *lwb)
  * aligned to 4KB) actually gets written. However, we can't always just
  * allocate SPA_OLD_MAXBLOCKSIZE as the slog space could be exhausted.
  */
-struct {
+static const struct {
 	uint64_t	limit;
 	uint64_t	blksz;
 } zil_block_buckets[] = {
@@ -1468,7 +1469,7 @@ struct {
  * initialized.  Otherwise this should not be used directly; see
  * zl_max_block_size instead.
  */
-int zil_maxblocksize = SPA_OLD_MAXBLOCKSIZE;
+static int zil_maxblocksize = SPA_OLD_MAXBLOCKSIZE;
 
 /*
  * Start a log block write and advance to the next log block.
@@ -3127,10 +3128,10 @@ zil_sync(zilog_t *zilog, dmu_tx_t *tx)
 	mutex_exit(&zilog->zl_lock);
 }
 
-/* ARGSUSED */
 static int
 zil_lwb_cons(void *vbuf, void *unused, int kmflag)
 {
+	(void) unused, (void) kmflag;
 	lwb_t *lwb = vbuf;
 	list_create(&lwb->lwb_itxs, sizeof (itx_t), offsetof(itx_t, itx_node));
 	list_create(&lwb->lwb_waiters, sizeof (zil_commit_waiter_t),
@@ -3141,10 +3142,10 @@ zil_lwb_cons(void *vbuf, void *unused, int kmflag)
 	return (0);
 }
 
-/* ARGSUSED */
 static void
 zil_lwb_dest(void *vbuf, void *unused)
 {
+	(void) unused;
 	lwb_t *lwb = vbuf;
 	mutex_destroy(&lwb->lwb_vdev_lock);
 	avl_destroy(&lwb->lwb_vdev_tree);
@@ -3508,7 +3509,7 @@ zil_resume(void *cookie)
 }
 
 typedef struct zil_replay_arg {
-	zil_replay_func_t **zr_replay;
+	zil_replay_func_t *const *zr_replay;
 	void		*zr_arg;
 	boolean_t	zr_byteswap;
 	char		*zr_lr;
@@ -3615,10 +3616,11 @@ zil_replay_log_record(zilog_t *zilog, const lr_t *lr, void *zra,
 	return (0);
 }
 
-/* ARGSUSED */
 static int
 zil_incr_blks(zilog_t *zilog, const blkptr_t *bp, void *arg, uint64_t claim_txg)
 {
+	(void) bp, (void) arg, (void) claim_txg;
+
 	zilog->zl_replay_blks++;
 
 	return (0);
@@ -3628,7 +3630,8 @@ zil_incr_blks(zilog_t *zilog, const blkptr_t *bp, void *arg, uint64_t claim_txg)
  * If this dataset has a non-empty intent log, replay it and destroy it.
  */
 void
-zil_replay(objset_t *os, void *arg, zil_replay_func_t *replay_func[TX_MAX_TYPE])
+zil_replay(objset_t *os, void *arg,
+    zil_replay_func_t *const replay_func[TX_MAX_TYPE])
 {
 	zilog_t *zilog = dmu_objset_zil(os);
 	const zil_header_t *zh = zilog->zl_header;
@@ -3677,13 +3680,12 @@ zil_replaying(zilog_t *zilog, dmu_tx_t *tx)
 	return (B_FALSE);
 }
 
-/* ARGSUSED */
 int
 zil_reset(const char *osname, void *arg)
 {
-	int error;
+	(void) arg;
 
-	error = zil_suspend(osname, NULL);
+	int error = zil_suspend(osname, NULL);
 	/* EACCES means crypto key not loaded */
 	if ((error == EACCES) || (error == EBUSY))
 		return (SET_ERROR(error));
diff --git a/sys/contrib/openzfs/module/zfs/zio.c b/sys/contrib/openzfs/module/zfs/zio.c
index 2079a1e0a9d8..92115488c544 100644
--- a/sys/contrib/openzfs/module/zfs/zio.c
+++ b/sys/contrib/openzfs/module/zfs/zio.c
@@ -57,7 +57,7 @@
  * I/O type descriptions
  * ==========================================================================
  */
-const char *zio_type_name[ZIO_TYPES] = {
+const char *const zio_type_name[ZIO_TYPES] = {
 	/*
 	 * Note: Linux kernel thread name length is limited
 	 * so these names will differ from upstream open zfs.
@@ -66,24 +66,24 @@ const char *zio_type_name[ZIO_TYPES] = {
 };
 
 int zio_dva_throttle_enabled = B_TRUE;
-int zio_deadman_log_all = B_FALSE;
+static int zio_deadman_log_all = B_FALSE;
 
 /*
  * ==========================================================================
  * I/O kmem caches
  * ==========================================================================
  */
-kmem_cache_t *zio_cache;
-kmem_cache_t *zio_link_cache;
+static kmem_cache_t *zio_cache;
+static kmem_cache_t *zio_link_cache;
 kmem_cache_t *zio_buf_cache[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
 kmem_cache_t *zio_data_buf_cache[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
 #if defined(ZFS_DEBUG) && !defined(_KERNEL)
-uint64_t zio_buf_cache_allocs[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
-uint64_t zio_buf_cache_frees[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
+static uint64_t zio_buf_cache_allocs[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
+static uint64_t zio_buf_cache_frees[SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT];
 #endif
 
 /* Mark IOs as "slow" if they take longer than 30 seconds */
-int zio_slow_io_ms = (30 * MILLISEC);
+static int zio_slow_io_ms = (30 * MILLISEC);
 
 #define	BP_SPANB(indblkshift, level) \
 	(((uint64_t)1) << ((level) * ((indblkshift) - SPA_BLKPTRSHIFT)))
@@ -115,8 +115,8 @@ int zio_slow_io_ms = (30 * MILLISEC);
  * and may need to load new metaslabs to satisfy 128K allocations.
  */
 int zfs_sync_pass_deferred_free = 2; /* defer frees starting in this pass */
-int zfs_sync_pass_dont_compress = 8; /* don't compress starting in this pass */
-int zfs_sync_pass_rewrite = 2; /* rewrite new bps starting in this pass */
+static int zfs_sync_pass_dont_compress = 8; /* don't compress s. i. t. p. */
+static int zfs_sync_pass_rewrite = 2; /* rewrite new bps s. i. t. p. */
 
 /*
  * An allocating zio is one that either currently has the DVA allocate
@@ -129,12 +129,12 @@ int zfs_sync_pass_rewrite = 2; /* rewrite new bps starting in this pass */
  * allocations as well.
  */
 int zio_exclude_metadata = 0;
-int zio_requeue_io_start_cut_in_line = 1;
+static int zio_requeue_io_start_cut_in_line = 1;
 
 #ifdef ZFS_DEBUG
-int zio_buf_debug_limit = 16384;
+static const int zio_buf_debug_limit = 16384;
 #else
-int zio_buf_debug_limit = 0;
+static const int zio_buf_debug_limit = 0;
 #endif
 
 static inline void __zio_execute(zio_t *zio);
@@ -369,6 +369,7 @@ zio_data_buf_free(void *buf, size_t size)
 static void
 zio_abd_free(void *abd, size_t size)
 {
+	(void) size;
 	abd_free((abd_t *)abd);
 }
 
@@ -1072,6 +1073,7 @@ zfs_blkptr_verify(spa_t *spa, const blkptr_t *bp, boolean_t config_held,
 boolean_t
 zfs_dva_valid(spa_t *spa, const dva_t *dva, const blkptr_t *bp)
 {
+	(void) bp;
 	uint64_t vdevid = DVA_GET_VDEV(dva);
 
 	if (vdevid >= spa->spa_root_vdev->vdev_children)
@@ -2143,6 +2145,8 @@ zio_execute_stack_check(zio_t *zio)
 	    !zio_taskq_member(zio, ZIO_TASKQ_ISSUE) &&
 	    !zio_taskq_member(zio, ZIO_TASKQ_ISSUE_HIGH))
 		return (B_TRUE);
+#else
+	(void) zio;
 #endif /* HAVE_LARGE_STACKS */
 
 	return (B_FALSE);
@@ -2555,11 +2559,12 @@ zio_rewrite_gang(zio_t *pio, blkptr_t *bp, zio_gang_node_t *gn, abd_t *data,
 	return (zio);
 }
 
-/* ARGSUSED */
 static zio_t *
 zio_free_gang(zio_t *pio, blkptr_t *bp, zio_gang_node_t *gn, abd_t *data,
     uint64_t offset)
 {
+	(void) gn, (void) data, (void) offset;
+
 	zio_t *zio = zio_free_sync(pio, pio->io_spa, pio->io_txg, bp,
 	    ZIO_GANG_CHILD_FLAGS(pio));
 	if (zio == NULL) {
@@ -2569,11 +2574,11 @@ zio_free_gang(zio_t *pio, blkptr_t *bp, zio_gang_node_t *gn, abd_t *data,
 	return (zio);
 }
 
-/* ARGSUSED */
 static zio_t *
 zio_claim_gang(zio_t *pio, blkptr_t *bp, zio_gang_node_t *gn, abd_t *data,
     uint64_t offset)
 {
+	(void) gn, (void) data, (void) offset;
 	return (zio_claim(pio, pio->io_spa, pio->io_txg, bp,
 	    NULL, NULL, ZIO_GANG_CHILD_FLAGS(pio)));
 }
@@ -3964,7 +3969,6 @@ zio_vsd_default_cksum_finish(zio_cksum_report_t *zcr,
 	zfs_ereport_finish_checksum(zcr, good_buf, zcr->zcr_cbdata, B_FALSE);
 }
 
-/*ARGSUSED*/
 void
 zio_vsd_default_cksum_report(zio_t *zio, zio_cksum_report_t *zcr)
 {
diff --git a/sys/contrib/openzfs/module/zfs/zio_checksum.c b/sys/contrib/openzfs/module/zfs/zio_checksum.c
index e6b5c9588939..4dbab68dd7aa 100644
--- a/sys/contrib/openzfs/module/zfs/zio_checksum.c
+++ b/sys/contrib/openzfs/module/zfs/zio_checksum.c
@@ -91,29 +91,29 @@
  * invocation and passed to the checksum function.
  */
 
-/*ARGSUSED*/
 static void
 abd_checksum_off(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) abd, (void) size, (void) ctx_template;
 	ZIO_SET_CHECKSUM(zcp, 0, 0, 0, 0);
 }
 
-/*ARGSUSED*/
 static void
 abd_fletcher_2_native(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_init(zcp);
 	(void) abd_iterate_func(abd, 0, size,
 	    fletcher_2_incremental_native, zcp);
 }
 
-/*ARGSUSED*/
 static void
 abd_fletcher_2_byteswap(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_init(zcp);
 	(void) abd_iterate_func(abd, 0, size,
 	    fletcher_2_incremental_byteswap, zcp);
@@ -127,11 +127,11 @@ abd_fletcher_4_impl(abd_t *abd, uint64_t size, zio_abd_checksum_data_t *acdp)
 	fletcher_4_abd_ops.acf_fini(acdp);
 }
 
-/*ARGSUSED*/
 void
 abd_fletcher_4_native(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_4_ctx_t ctx;
 
 	zio_abd_checksum_data_t acd = {
@@ -144,11 +144,11 @@ abd_fletcher_4_native(abd_t *abd, uint64_t size,
 
 }
 
-/*ARGSUSED*/
 void
 abd_fletcher_4_byteswap(abd_t *abd, uint64_t size,
     const void *ctx_template, zio_cksum_t *zcp)
 {
+	(void) ctx_template;
 	fletcher_4_ctx_t ctx;
 
 	zio_abd_checksum_data_t acd = {
diff --git a/sys/contrib/openzfs/module/zfs/zio_compress.c b/sys/contrib/openzfs/module/zfs/zio_compress.c
index 1ff1e76d7f22..cded11f4cbd5 100644
--- a/sys/contrib/openzfs/module/zfs/zio_compress.c
+++ b/sys/contrib/openzfs/module/zfs/zio_compress.c
@@ -74,6 +74,7 @@ uint8_t
 zio_complevel_select(spa_t *spa, enum zio_compress compress, uint8_t child,
     uint8_t parent)
 {
+	(void) spa;
 	uint8_t result;
 
 	if (!ZIO_COMPRESS_HASLEVEL(compress))
@@ -110,10 +111,11 @@ zio_compress_select(spa_t *spa, enum zio_compress child,
 	return (result);
 }
 
-/*ARGSUSED*/
 static int
 zio_compress_zeroed_cb(void *data, size_t len, void *private)
 {
+	(void) private;
+
 	uint64_t *end = (uint64_t *)((char *)data + len);
 	for (uint64_t *word = (uint64_t *)data; word < end; word++)
 		if (*word != 0)
diff --git a/sys/contrib/openzfs/module/zfs/zthr.c b/sys/contrib/openzfs/module/zfs/zthr.c
index 33fdda7b68d1..52ddffae7aaa 100644
--- a/sys/contrib/openzfs/module/zfs/zthr.c
+++ b/sys/contrib/openzfs/module/zfs/zthr.c
@@ -469,6 +469,12 @@ zthr_iscancelled(zthr_t *t)
 	return (cancelled);
 }
 
+boolean_t
+zthr_iscurthread(zthr_t *t)
+{
+	return (t->zthr_thread == curthread);
+}
+
 /*
  * Wait for the zthr to finish its current function. Similar to
  * zthr_iscancelled, you can use zthr_has_waiters to have the zthr_func end
diff --git a/sys/contrib/openzfs/module/zfs/zvol.c b/sys/contrib/openzfs/module/zfs/zvol.c
index cb5ee483c1c1..e7010e77a83a 100644
--- a/sys/contrib/openzfs/module/zfs/zvol.c
+++ b/sys/contrib/openzfs/module/zfs/zvol.c
@@ -90,9 +90,9 @@ unsigned int zvol_inhibit_dev = 0;
 unsigned int zvol_volmode = ZFS_VOLMODE_GEOM;
 
 struct hlist_head *zvol_htable;
-list_t zvol_state_list;
+static list_t zvol_state_list;
 krwlock_t zvol_state_lock;
-const zvol_platform_ops_t *ops;
+static const zvol_platform_ops_t *ops;
 
 typedef enum {
 	ZVOL_ASYNC_REMOVE_MINORS,
@@ -486,6 +486,7 @@ zvol_replay_write(void *arg1, void *arg2, boolean_t byteswap)
 static int
 zvol_replay_err(void *arg1, void *arg2, boolean_t byteswap)
 {
+	(void) arg1, (void) arg2, (void) byteswap;
 	return (SET_ERROR(ENOTSUP));
 }
 
@@ -493,7 +494,7 @@ zvol_replay_err(void *arg1, void *arg2, boolean_t byteswap)
  * Callback vectors for replaying records.
  * Only TX_WRITE and TX_TRUNCATE are needed for zvol.
  */
-zil_replay_func_t *zvol_replay_vector[TX_MAX_TYPE] = {
+zil_replay_func_t *const zvol_replay_vector[TX_MAX_TYPE] = {
 	zvol_replay_err,	/* no such transaction type */
 	zvol_replay_err,	/* TX_CREATE */
 	zvol_replay_err,	/* TX_MKDIR */
@@ -521,7 +522,7 @@ zil_replay_func_t *zvol_replay_vector[TX_MAX_TYPE] = {
  * We store data in the log buffers if it's small enough.
  * Otherwise we will later flush the data out via dmu_sync().
  */
-ssize_t zvol_immediate_write_sz = 32768;
+static const ssize_t zvol_immediate_write_sz = 32768;
 
 void
 zvol_log_write(zvol_state_t *zv, dmu_tx_t *tx, uint64_t offset,
@@ -1311,13 +1312,12 @@ static void
 zvol_rename_minors_impl(const char *oldname, const char *newname)
 {
 	zvol_state_t *zv, *zv_next;
-	int oldnamelen, newnamelen;
+	int oldnamelen;
 
 	if (zvol_inhibit_dev)
 		return;
 
 	oldnamelen = strlen(oldname);
-	newnamelen = strlen(newname);
 
 	rw_enter(&zvol_state_lock, RW_READER);
 
diff --git a/sys/contrib/openzfs/rpm/generic/zfs.spec.in b/sys/contrib/openzfs/rpm/generic/zfs.spec.in
index 25beadce7c1f..9ee36b20491e 100644
--- a/sys/contrib/openzfs/rpm/generic/zfs.spec.in
+++ b/sys/contrib/openzfs/rpm/generic/zfs.spec.in
@@ -3,7 +3,7 @@
 
 # Set the default udev directory based on distribution.
 %if %{undefined _udevdir}
-%if 0%{?fedora} >= 17 || 0%{?rhel} >= 7 || 0%{?centos} >= 7
+%if 0%{?fedora}%{?rhel}%{?centos}
 %global _udevdir    %{_prefix}/lib/udev
 %else
 %global _udevdir    /lib/udev
@@ -12,7 +12,7 @@
 
 # Set the default udevrule directory based on distribution.
 %if %{undefined _udevruledir}
-%if 0%{?fedora} >= 17 || 0%{?rhel} >= 7 || 0%{?centos} >= 7
+%if 0%{?fedora}%{?rhel}%{?centos}
 %global _udevruledir    %{_prefix}/lib/udev/rules.d
 %else
 %global _udevruledir    /lib/udev/rules.d
@@ -21,7 +21,7 @@
 
 # Set the default dracut directory based on distribution.
 %if %{undefined _dracutdir}
-%if 0%{?fedora} >= 17 || 0%{?rhel} >= 7 || 0%{?centos} >= 7
+%if 0%{?fedora}%{?rhel}%{?centos}
 %global _dracutdir  %{_prefix}/lib/dracut
 %else
 %global _dracutdir  %{_prefix}/share/dracut
@@ -57,59 +57,28 @@
 %bcond_with    asan
 %bcond_with    systemd
 %bcond_with    pam
+%bcond_without pyzfs
 
 # Generic enable switch for systemd
 %if %{with systemd}
 %define _systemd 1
 %endif
 
-# RHEL >= 7 comes with systemd
-%if 0%{?rhel} >= 7
+# Distros below support systemd
+%if 0%{?rhel}%{?fedora}%{?centos}%{?suse_version}
 %define _systemd 1
 %endif
 
-# Fedora >= 15 comes with systemd, but only >= 18 has
-# the proper macros
-%if 0%{?fedora} >= 18
-%define _systemd 1
-%endif
-
-# opensuse >= 12.1 comes with systemd, but only >= 13.1
-# has the proper macros
-%if 0%{?suse_version} >= 1310
-%define _systemd 1
-%endif
-
-# When not specified default to distribution provided version.  This
-# is normally Python 3, but for RHEL <= 7 only Python 2 is provided.
+# When not specified default to distribution provided version.
 %if %{undefined __use_python}
-%if 0%{?rhel} && 0%{?rhel} <= 7
-%define __python                  /usr/bin/python2
-%define __python_pkg_version      2
-%define __python_cffi_pkg         python-cffi
-%define __python_setuptools_pkg   python-setuptools
-%else
 %define __python                  /usr/bin/python3
 %define __python_pkg_version      3
-%define __python_cffi_pkg         python3-cffi
-%define __python_setuptools_pkg   python3-setuptools
-%endif
 %else
 %define __python                  %{__use_python}
 %define __python_pkg_version      %{__use_python_pkg_version}
-%define __python_cffi_pkg         python%{__python_pkg_version}-cffi
-%define __python_setuptools_pkg   python%{__python_pkg_version}-setuptools
 %endif
 %define __python_sitelib          %(%{__python} -Esc "from distutils.sysconfig import get_python_lib; print(get_python_lib())")
 
-# By default python-pyzfs is enabled, with the exception of
-# RHEL 6 which by default uses Python 2.6 which is too old.
-%if 0%{?rhel} == 6
-%bcond_with    pyzfs
-%else
-%bcond_without pyzfs
-%endif
-
 Name:           @PACKAGE@
 Version:        @VERSION@
 Release:        @RELEASE@%{?dist}
@@ -132,7 +101,7 @@ Obsoletes:      spl
 # Renaming those on either side would conflict with all available documentation.
 Conflicts:      zfs-fuse
 
-%if 0%{?rhel}%{?fedora}%{?suse_version}
+%if 0%{?rhel}%{?centos}%{?fedora}%{?suse_version}
 BuildRequires:  gcc, make
 BuildRequires:  zlib-devel
 BuildRequires:  libuuid-devel
@@ -144,7 +113,7 @@ BuildRequires:  openssl-devel
 # crash+corrupt rpmdb
 # See issue #12071
 BuildRequires:  ncompress
-%if 0%{?fedora} >= 28 || 0%{?rhel} >= 8 || 0%{?centos} >= 8
+%if 0%{?fedora} || 0%{?rhel} >= 8 || 0%{?centos} >= 8
 BuildRequires:  libtirpc-devel
 %endif
 
@@ -277,7 +246,7 @@ Requires:       sudo
 Requires:       sysstat
 Requires:       libaio
 Requires:       python%{__python_pkg_version}
-%if 0%{?rhel}%{?fedora}%{?suse_version}
+%if 0%{?rhel}%{?centos}%{?fedora}%{?suse_version}
 BuildRequires:  libaio-devel
 %endif
 AutoReqProv:    no
@@ -300,6 +269,8 @@ This package contains a dracut module used to construct an initramfs
 image which is ZFS aware.
 
 %if %{with pyzfs}
+# Enforce `python36-` package prefix for CentOS 7
+# since dependencies come from EPEL and are named this way
 %package -n python%{__python_pkg_version}-pyzfs
 Summary:        Python %{python_version} wrapper for libzfs_core
 Group:          Development/Languages/Python
@@ -309,16 +280,26 @@ Requires:       libzfs5 = %{version}
 Requires:       libnvpair3 = %{version}
 Requires:       libffi
 Requires:       python%{__python_pkg_version}
-Requires:       %{__python_cffi_pkg}
-%if 0%{?rhel}%{?fedora}%{?suse_version}
-%if 0%{?rhel} >= 8 || 0%{?centos} >= 8 || 0%{?fedora} >= 28
-BuildRequires:  python3-packaging
+
+%if 0%{?centos} == 7
+Requires:       python36-cffi
 %else
-BuildRequires:  python-packaging
+Requires:       python%{__python_pkg_version}-cffi
 %endif
+
+%if 0%{?rhel}%{?centos}%{?fedora}%{?suse_version}
+%if 0%{?centos} == 7
+BuildRequires:  python36-packaging
+BuildRequires:  python36-devel
+BuildRequires:  python36-cffi
+BuildRequires:  python36-setuptools
+%else
+BuildRequires:  python%{__python_pkg_version}-packaging
 BuildRequires:  python%{__python_pkg_version}-devel
-BuildRequires:  %{__python_cffi_pkg}
-BuildRequires:  %{__python_setuptools_pkg}
+BuildRequires:  python%{__python_pkg_version}-cffi
+BuildRequires:  python%{__python_pkg_version}-setuptools
+%endif
+
 BuildRequires:  libffi-devel
 %endif
 
@@ -478,7 +459,7 @@ systemctl --system daemon-reload >/dev/null || true
 %{_bindir}/raidz_test
 %{_sbindir}/zgenhostid
 %{_bindir}/zvol_wait
-# Optional Python 2/3 scripts
+# Optional Python 3 scripts
 %{_bindir}/arc_summary
 %{_bindir}/arcstat
 %{_bindir}/dbufstat
diff --git a/sys/contrib/openzfs/scripts/Makefile.am b/sys/contrib/openzfs/scripts/Makefile.am
index 77b1269a9de4..a5107e6fc872 100644
--- a/sys/contrib/openzfs/scripts/Makefile.am
+++ b/sys/contrib/openzfs/scripts/Makefile.am
@@ -28,6 +28,7 @@ EXTRA_DIST = \
 	$(EXTRA_SCRIPTS)
 
 SHELLCHECKSCRIPTS = $(EXTRA_SCRIPTS)
+SHELLCHECK_OPTS = --enable=all
 
 define EXTRA_ENVIRONMENT
 
diff --git a/sys/contrib/openzfs/scripts/commitcheck.sh b/sys/contrib/openzfs/scripts/commitcheck.sh
index cb9fd66c6f46..1b1d097501db 100755
--- a/sys/contrib/openzfs/scripts/commitcheck.sh
+++ b/sys/contrib/openzfs/scripts/commitcheck.sh
@@ -51,7 +51,7 @@ new_change_commit()
         error=1
     fi
 
-    return $error
+    return "$error"
 }
 
 is_coverity_fix()
@@ -99,7 +99,7 @@ coverity_fix_commit()
         error=1
     fi
 
-    return $error
+    return "$error"
 }
 
 if [ -n "$1" ]; then
diff --git a/sys/contrib/openzfs/scripts/kmodtool b/sys/contrib/openzfs/scripts/kmodtool
index b1021596997e..afbb6ab3b03c 100755
--- a/sys/contrib/openzfs/scripts/kmodtool
+++ b/sys/contrib/openzfs/scripts/kmodtool
@@ -54,9 +54,9 @@ error_out()
 print_rpmtemplate_header()
 {
 	echo
-	echo '%global kmodinstdir_prefix  '${prefix}/lib/modules/
-	echo '%global kmodinstdir_postfix '/extra/${kmodname}/
-	echo '%global kernel_versions     '${kernel_versions}
+	echo "%global kmodinstdir_prefix  ${prefix}/lib/modules/"
+	echo "%global kmodinstdir_postfix /extra/${kmodname}/"
+	echo "%global kernel_versions     ${kernel_versions}"
 	echo
 }
 
@@ -82,7 +82,7 @@ Requires: 	${kmodname}-kmod-common >= %{?epoch:%{epoch}:}%{version}
 Provides: 	${kmodname}-kmod = %{?epoch:%{epoch}:}%{version}-%{release}
 EOF
 
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "Provides:   akmod-${obsolete_name} = ${obsolete_version}"
 		echo "Obsoletes:  akmod-${obsolete_name} < ${obsolete_version}"
 	fi
@@ -116,7 +116,7 @@ Provides:        kmod-${kmodname}-PAE = %{?epoch:%{epoch}:}%{version}-%{release}
 Requires:        akmod-${kmodname} = %{?epoch:%{epoch}:}%{version}-%{release}
 EOF
 
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "Provides:        kmod-${obsolete_name} = ${obsolete_version}"
 		echo "Obsoletes:       kmod-${obsolete_name} < ${obsolete_version}"
 	fi
@@ -134,10 +134,10 @@ EOF
 
 print_rpmtemplate_per_kmodpkg ()
 {
-	if [[ "${1}" == "--custom" ]]; then
+	if [ "${1}" = "--custom" ]; then
 		shift
 		local customkernel=true
-	elif [[ "${1}" == "--redhat" ]]; then
+	elif [ "${1}" = "--redhat" ]; then
 		# this is needed for akmods
 		shift
 		local redhatkernel=true
@@ -148,7 +148,7 @@ print_rpmtemplate_per_kmodpkg ()
 
 	# Detect depmod install location
 	local depmod_path=/sbin/depmod
-	if [ ! -f ${depmod_path} ]; then
+	if [ ! -f "${depmod_path}" ]; then
 		depmod_path=/usr/sbin/depmod
 	fi
 
@@ -171,30 +171,30 @@ Requires(postun): kmod
 %endif
 EOF
 
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "Provides:        kmod-${obsolete_name}-${kernel_uname_r} = ${obsolete_version}"
 		echo "Obsoletes:       kmod-${obsolete_name}-${kernel_uname_r} < ${obsolete_version}"
 	fi
 
 	# second part
-	if [[ ! "${customkernel}" ]]; then
+	if [ -z "${customkernel}" ]; then
 	     cat <<EOF
 Requires:         kernel-uname-r = ${kernel_uname_r}
 BuildRequires:	  kernel-devel-uname-r = ${kernel_uname_r}
 %{?KmodsRequires:Requires: %{KmodsRequires}-uname-r = ${kernel_uname_r}}
 %{?KmodsRequires:BuildRequires: %{KmodsRequires}-uname-r = ${kernel_uname_r}}
 %post          -n kmod-${kmodname}-${kernel_uname_r}
-if [[ -f "/boot/System.map-${kernel_uname_r}" ]]; then
+if [ -f "/boot/System.map-${kernel_uname_r}" ]; then
 	${prefix}${depmod_path} -aeF /boot/System.map-${kernel_uname_r} ${kernel_uname_r} > /dev/null || :
-elif [[ -f "/lib/modules/${kernel_uname_r}/System.map" ]]; then
+elif [ -f "/lib/modules/${kernel_uname_r}/System.map" ]; then
 	${prefix}${depmod_path} -aeF /lib/modules/${kernel_uname_r}/System.map ${kernel_uname_r} > /dev/null || :
 else
 	${prefix}${depmod_path} -ae ${kernel_uname_r} &> /dev/null || :
 fi
 %postun        -n kmod-${kmodname}-${kernel_uname_r}
-if [[ -f "/boot/System.map-${kernel_uname_r}" ]]; then
+if [ -f "/boot/System.map-${kernel_uname_r}" ]; then
 	${prefix}${depmod_path} -aF /boot/System.map-${kernel_uname_r} ${kernel_uname_r} &> /dev/null || :
-elif [[ -f "/lib/modules/${kernel_uname_r}/System.map" ]]; then
+elif [ -f "/lib/modules/${kernel_uname_r}/System.map" ]; then
 	${prefix}${depmod_path} -aF /lib/modules/${kernel_uname_r}/System.map ${kernel_uname_r} &> /dev/null || :
 else
 	${prefix}${depmod_path} -a ${kernel_uname_r} &> /dev/null || :
@@ -204,9 +204,9 @@ EOF
 	else
 	  cat <<EOF
 %post          -n kmod-${kmodname}-${kernel_uname_r}
-[[ "\$(uname -r)" == "${kernel_uname_r}"  ]] && ${prefix}${depmod_path} -a > /dev/null || :
+[ "\$(uname -r)" = "${kernel_uname_r}"  ] && ${prefix}${depmod_path} -a > /dev/null || :
 %postun        -n kmod-${kmodname}-${kernel_uname_r}
-[[ "\$(uname -r)" == "${kernel_uname_r}"  ]] && ${prefix}${depmod_path} -a > /dev/null || :
+[ "\$(uname -r)" = "${kernel_uname_r}"  ] && ${prefix}${depmod_path} -a > /dev/null || :
 
 EOF
 	fi
@@ -227,10 +227,10 @@ EOF
 
 print_rpmtemplate_kmoddevelpkg ()
 {
-	if [[ "${1}" == "--custom" ]]; then
+	if [ "${1}" = "--custom" ]; then
 		shift
 		local customkernel=true
-	elif [[ "${1}" == "--redhat" ]]; then
+	elif [ "${1}" = "--redhat" ]; then
 		shift
 		local redhatkernel=true
 	fi
@@ -244,11 +244,11 @@ Group:            System Environment/Kernel
 Provides:         ${kmodname}-devel-kmod = %{?epoch:%{epoch}:}%{version}-%{release}
 EOF
 
-	if [[ ! ${customkernel} ]] && [[ ! ${redhatkernel} ]]; then
+	if [ -z "${customkernel}" ] && [ -z "${redhatkernel}" ]; then
 		echo "Requires:        kmod-${kmodname}-devel-${kernel_uname_r} >= %{?epoch:%{epoch}:}%{version}-%{release}"
 	fi
 
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "Provides:        kmod-${obsolete_name}-devel = ${obsolete_version}"
 		echo "Obsoletes:       kmod-${obsolete_name}-devel < ${obsolete_version}"
 	fi
@@ -263,14 +263,14 @@ the ${kmodname}-devel-<kernel> objects for the newest kernel.
 %defattr(644,root,root,755)
 %{_usrsrc}/${kmodname}-%{version}
 EOF
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "%{_usrsrc}/${obsolete_name}-%{version}"
 	fi
 
 	for kernel in ${1}; do
 		local kernel_uname_r=${kernel}
 		echo "%exclude %{_usrsrc}/${kmodname}-%{version}/${kernel_uname_r}"
-		if [[ ${obsolete_name} ]]; then
+		if [ -n "${obsolete_name}" ]; then
 			echo "%exclude %{_usrsrc}/${obsolete_name}-%{version}/${kernel_uname_r}"
 		fi
 	done
@@ -281,10 +281,10 @@ EOF
 
 print_rpmtemplate_per_kmoddevelpkg ()
 {
-	if [[ "${1}" == "--custom" ]]; then
+	if [ "${1}" = "--custom" ]; then
 		shift
 		local customkernel=true
-	elif [[ "${1}" == "--redhat" ]]; then
+	elif [ "${1}" = "--redhat" ]; then
 		# this is needed for akmods
 		shift
 		local redhatkernel=true
@@ -303,13 +303,13 @@ Provides:         ${kmodname}-devel-kmod = %{?epoch:%{epoch}:}%{version}-%{relea
 Provides:         kmod-${kmodname}-devel-uname-r = ${kernel_uname_r}
 EOF
 
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "Provides:        kmod-${obsolete_name}-devel-${kernel_uname_r} = ${obsolete_version}"
 		echo "Obsoletes:       kmod-${obsolete_name}-devel-${kernel_uname_r} < ${obsolete_version}"
 	fi
 
 	# second part
-	if [[ ! "${customkernel}" ]]; then
+	if [ -z "${customkernel}" ]; then
 		cat <<EOF
 Requires:         kernel-devel-uname-r = ${kernel_uname_r}
 BuildRequires:    kernel-devel-uname-r = ${kernel_uname_r}
@@ -328,7 +328,7 @@ kernel ${kernel_uname_r} for the %{_target_cpu} family of processors.
 %defattr(644,root,root,755)
 %{_usrsrc}/${kmodname}-%{version}/${kernel_uname_r}
 EOF
-	if [[ ${obsolete_name} ]]; then
+	if [ -n "${obsolete_name}" ]; then
 		echo "%{_usrsrc}/${obsolete_name}-%{version}/${kernel_uname_r}"
 	fi
 }
@@ -348,7 +348,7 @@ Requires:        kmod-${kmodname}-${kernel_uname_r} >= %{?epoch:%{epoch}:}%{vers
 %{?KmodsMetaRequires:Requires: %{?KmodsMetaRequires}}
 EOF
 
-		if [[ ${obsolete_name} ]]; then
+		if [ -n "${obsolete_name}" ]; then
 			echo "Provides:        kmod-${obsolete_name}${kernel_variant} = ${obsolete_version}"
 			echo "Obsoletes:       kmod-${obsolete_name}${kernel_variant} < ${obsolete_version}"
 		fi
@@ -371,7 +371,7 @@ print_customrpmtemplate ()
 {
 	for kernel in ${1}
 	do
-		if [[ -e "${buildroot}/usr/src/kernels/${kernel}" ]] ; then
+		if [ -e "${buildroot}/usr/src/kernels/${kernel}" ] ; then
 			# this looks like a Fedora/RH kernel -- print a normal template (which includes the proper BR) and be happy :)
 			kernel_versions="${kernel_versions}${kernel}___${buildroot}%{_usrsrc}/kernels/${kernel} "
 
@@ -380,14 +380,14 @@ print_customrpmtemplate ()
 			print_rpmtemplate_per_kmodpkg --redhat ${kernel} ${kernel##${kernel_verrelarch}}
 
 			# create development package
-			if [[ "${devel}" ]]; then
+			if [ -n "${devel}" ]; then
 				# create devel package including common headers
 				print_rpmtemplate_kmoddevelpkg --redhat ${kernel} ${kernel##${kernel_verrelarch}}
 
 				# create devel package
 				print_rpmtemplate_per_kmoddevelpkg --redhat ${kernel} ${kernel##${kernel_verrelarch}}
 			fi
-		elif [[ -e ${prefix}/lib/modules/"${kernel}"/build/Makefile ]] ; then 
+		elif [ -e "${prefix}/lib/modules/${kernel}/build/Makefile" ]; then 
 			# likely a user-build-kernel with available buildfiles
 			# fixme: we should check if uname from Makefile is the same as ${kernel}
 
@@ -395,7 +395,7 @@ print_customrpmtemplate ()
 			print_rpmtemplate_per_kmodpkg --custom "${kernel}"
 
 			# create development package
-			if [[ "${devel}" ]]; then
+			if [ -n "${devel}" ]; then
 				# create devel package including common headers
 				print_rpmtemplate_kmoddevelpkg --custom "${kernel}"
 
@@ -429,17 +429,17 @@ print_rpmtemplate ()
 		local kernel_verrelarch=${kernel%%${kernels_known_variants}}
 
 		# create metapackage 
-		print_rpmtemplate_kmodmetapkg ${kernel} ${kernel##${kernel_verrelarch}}
+		print_rpmtemplate_kmodmetapkg "${kernel}" "${kernel##${kernel_verrelarch}}"
 
 		# create package
-		print_rpmtemplate_per_kmodpkg ${kernel} ${kernel##${kernel_verrelarch}}
+		print_rpmtemplate_per_kmodpkg "${kernel}" "${kernel##${kernel_verrelarch}}"
 
-		if [[ "${devel}" ]]; then
+		if [ -n "${devel}" ]; then
 			# create devel package including common headers
-			print_rpmtemplate_kmoddevelpkg ${kernel} ${kernel##${kernel_verrelarch}}
+			print_rpmtemplate_kmoddevelpkg "${kernel}" "${kernel##${kernel_verrelarch}}"
 
 			# create devel package
-			print_rpmtemplate_per_kmoddevelpkg ${kernel} ${kernel##${kernel_verrelarch}}
+			print_rpmtemplate_per_kmoddevelpkg "${kernel}" "${kernel##${kernel_verrelarch}}"
 		fi
 	done
 }
@@ -447,8 +447,10 @@ print_rpmtemplate ()
 myprog_help ()
 {
 	echo "Usage: ${0##*/} [OPTIONS]"
-	echo $'\n'"Creates a template to be used during kmod building"
-	echo $'\n'"Available options:"
+	echo
+	echo "Creates a template to be used during kmod building"
+	echo
+	echo "Available options:"
 	echo " --filterfile <file>  -- filter the results with grep --file <file>"
 	echo " --for-kernels <list> -- created templates only for these kernels"
 	echo " --kmodname <file>    -- name of the kmod (required)"
@@ -459,13 +461,13 @@ myprog_help ()
 	echo " --buildroot <dir>    -- Build root (place to look for build files)"
 }
 
-while [ "${1}" ] ; do
+while [ -n "${1}" ] ; do
 	case "${1}" in
 		--filterfile)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide path to a filter-file together with --filterfile" >&2
-			elif [[ ! -e "${1}" ]]; then	
+			elif [ ! -e "${1}" ]; then	
 				error_out 2 "Filterfile ${1} not found" >&2
 			fi
 			filterfile="${1}"
@@ -473,7 +475,7 @@ while [ "${1}" ] ; do
 			;;
 		--kmodname)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide the name of the kmod together with --kmodname" >&2
 	 	    fi
 			# strip pending -kmod
@@ -486,7 +488,7 @@ while [ "${1}" ] ; do
 			;;
 		--prefix)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide a prefix with --prefix" >&2
 		    fi
 			prefix="${1}"
@@ -494,7 +496,7 @@ while [ "${1}" ] ; do
 			;;
 		--repo)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide the name of the repo together with --repo" >&2
 	 	    fi
 			repo=${1}
@@ -502,7 +504,7 @@ while [ "${1}" ] ; do
 			;;
 		--for-kernels)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide the name of the kmod together with --kmodname" >&2
 	 		fi
 			for_kernels="${1}"
@@ -514,7 +516,7 @@ while [ "${1}" ] ; do
 			;;
 		--obsolete-name)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide the name of the kmod to obsolete together with --obsolete-name" >&2
 	 		fi
 			obsolete_name="${1}"
@@ -522,7 +524,7 @@ while [ "${1}" ] ; do
 			;;
 		--obsolete-version)
 			shift
-			if [[ ! "${1}" ]] ; then
+			if [ -z "${1}" ] ; then
 				error_out 2 "Please provide the version of the kmod to obsolete together with --obsolete-version" >&2
 	 		fi
 			obsolete_version="${1}"
@@ -566,30 +568,30 @@ while [ "${1}" ] ; do
 	esac
 done
 
-if [[ -e ./kmodtool-kernel-variants ]]; then
+if [ -e ./kmodtool-kernel-variants ]; then
 	kernels_known_variants="$(cat ./kmodtool-kernel-variants)"
-elif [[ -e /usr/share/kmodtool/kernel-variants ]] ; then
+elif [ -e /usr/share/kmodtool/kernel-variants ] ; then
 	kernels_known_variants="$(cat /usr/share/kmodtool/kernel-variants)"
 else
 	kernels_known_variants="@(smp?(-debug)|PAE?(-debug)|debug|kdump|xen|kirkwood|highbank|imx|omap|tegra)"
 fi
 
 # general sanity checks
-if [[ ! "${target}" ]]; then
+if [ -z "${target}" ]; then
 		error_out 2 "please pass target arch with --target"
-elif [[ ! "${kmodname}" ]]; then
+elif [ -z "${kmodname}" ]; then
 		error_out 2 "please pass kmodname with --kmodname"
-elif [[ ! "${kernels_known_variants}" ]] ; then
+elif [ -z "${kernels_known_variants}" ] ; then
 		error_out 2 "could not determine known variants"
-elif { [[ "${obsolete_name}" ]] && [[ ! "${obsolete_version}" ]]; } ||  { [[ ! "${obsolete_name}" ]] && [[ "${obsolete_version}" ]]; } ; then
+elif { [ -n "${obsolete_name}" ] && [ -z "${obsolete_version}" ]; } ||  { [ -z "${obsolete_name}" ] && [ -n "${obsolete_version}" ]; } ; then
 		error_out 2 "you need to provide both --obsolete-name and --obsolete-version"
 fi
 
 # go
-if [[ "${for_kernels}" ]]; then
+if [ -n "${for_kernels}" ]; then
 	# this is easy:
 	print_customrpmtemplate "${for_kernels}"
-elif [[ "${build_kernels}" == "akmod" ]]; then
+elif [ "${build_kernels}" = "akmod" ]; then
 	# do only a akmod package
 	print_akmodtemplate
 	print_akmodmeta
@@ -597,9 +599,9 @@ else
 	# seems we are on out own to decide for which kernels to build
 
 	# we need more sanity checks in this case
-	if [[ ! "${repo}" ]]; then
+	if [ -z "${repo}" ]; then
 		error_out 2 "please provide repo name with --repo"
-	elif ! command -v "buildsys-build-${repo}-kerneldevpkgs" &> /dev/null ; then
+	elif ! command -v "buildsys-build-${repo}-kerneldevpkgs" > /dev/null 2>&1; then
 		error_out 2 "buildsys-build-${repo}-kerneldevpkgs not found"
 	fi
 
@@ -607,17 +609,18 @@ else
 	cmdoptions="--target ${target}"
 
 	# filterfile to filter list of kernels?	
-	if [[ "${filterfile}" ]] ; then
+	if [ -n "${filterfile}" ] ; then
 		 cmdoptions="${cmdoptions} --filterfile ${filterfile}"
 	fi
 
-	kernel_versions_to_build_for="$(buildsys-build-${repo}-kerneldevpkgs --${build_kernels} ${cmdoptions})"
+	kernel_versions_to_build_for=$(buildsys-build-${repo}-kerneldevpkgs "--${build_kernels}" ${cmdoptions})
 	returncode=$?
-	if (( returncode != 0 )); then
-		error_out 2 "buildsys-build-${repo}-kerneldevpkgs failed: $(buildsys-build-${repo}-kerneldevpkgs --${build_kernels} ${cmdoptions})"
+	if [ "$returncode" -ne 0 ]; then
+		
+		error_out 2 "buildsys-build-${repo}-kerneldevpkgs failed: ${kernel_versions_to_build_for}"
 	fi
 
-	if [[ "${build_kernels}" == "current" ]] && [[ ! "${noakmod}" ]]; then
+	if [ "${build_kernels}" = "current" ] && [ -z "${noakmod}" ]; then
 		print_akmodtemplate
 	fi
 
diff --git a/sys/contrib/openzfs/scripts/make_gitrev.sh b/sys/contrib/openzfs/scripts/make_gitrev.sh
index e7f4ce8844d5..4a6a98f52929 100755
--- a/sys/contrib/openzfs/scripts/make_gitrev.sh
+++ b/sys/contrib/openzfs/scripts/make_gitrev.sh
@@ -25,7 +25,7 @@
 # `configure` is run.
 #
 
-set -e -u
+set -eu
 
 dist=no
 distdir=.
@@ -34,6 +34,7 @@ do
 	case $flag in
 		\?) echo "Usage: $0 [-D distdir] [file]" >&2; exit 1;;
 		D)  dist=yes; distdir=${OPTARG};;
+		*)  ;;
 	esac
 done
 shift $((OPTIND - 1))
@@ -45,6 +46,7 @@ GITREV="${1:-include/zfs_gitrev.h}"
 case "${GITREV}" in
 	/*) echo "Error: ${GITREV} should be a relative path" >&2
 	    exit 1;;
+	*) ;;
 esac
 
 ZFS_GITREV=$({ cd "${top_srcdir}" &&
@@ -60,7 +62,7 @@ then
 			'1s/^#define[[:blank:]]ZFS_META_GITREV "\([^"]*\)"$/\1/p' \
 			"${top_srcdir}/${GITREV}")
 	fi
-elif [ ${dist} = yes ]
+elif [ "${dist}" = yes ]
 then
 	# Append -dist when creating distributed sources from a git repository
 	ZFS_GITREV="${ZFS_GITREV}-dist"
diff --git a/sys/contrib/openzfs/scripts/paxcheck.sh b/sys/contrib/openzfs/scripts/paxcheck.sh
index 27acc95364aa..aba770e9e6f3 100755
--- a/sys/contrib/openzfs/scripts/paxcheck.sh
+++ b/sys/contrib/openzfs/scripts/paxcheck.sh
@@ -40,4 +40,4 @@ if [ x"${OUT}" != x ]; then
     echo
 fi
 
-exit $RET
+exit "$RET"
diff --git a/sys/contrib/openzfs/scripts/zfs-helpers.sh b/sys/contrib/openzfs/scripts/zfs-helpers.sh
index 02b4922006f2..a86a6eb61a60 100755
--- a/sys/contrib/openzfs/scripts/zfs-helpers.sh
+++ b/sys/contrib/openzfs/scripts/zfs-helpers.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # This script is designed to facilitate in-tree development and testing
 # by installing symlinks on your system which refer to in-tree helper
@@ -85,6 +86,8 @@ while getopts 'hdirv' OPTION; do
 		usage
 		exit
 		;;
+	*)
+		;;
 	esac
 done
 
diff --git a/sys/contrib/openzfs/scripts/zfs-tests.sh b/sys/contrib/openzfs/scripts/zfs-tests.sh
index f871a51d34c2..aaaf9ddfc25d 100755
--- a/sys/contrib/openzfs/scripts/zfs-tests.sh
+++ b/sys/contrib/openzfs/scripts/zfs-tests.sh
@@ -1,4 +1,5 @@
 #!/bin/sh
+# shellcheck disable=SC2154
 #
 # CDDL HEADER START
 #
@@ -422,6 +423,8 @@ while getopts 'hvqxkfScRn:d:s:r:?t:T:u:I:' OPTION; do
 		usage
 		exit
 		;;
+	*)
+		;;
 	esac
 done
 
@@ -442,7 +445,7 @@ if [ -n "$SINGLETEST" ]; then
 		SINGLEQUIET="True"
 	fi
 
-	cat >$RUNFILE_DIR/$RUNFILES << EOF
+	cat >"${RUNFILE_DIR}/${RUNFILES}" << EOF
 [DEFAULT]
 pre =
 quiet = $SINGLEQUIET
@@ -466,7 +469,7 @@ EOF
 		CLEANUPSCRIPT="cleanup"
 	fi
 
-	cat >>$RUNFILE_DIR/$RUNFILES << EOF
+	cat >>"${RUNFILE_DIR}/${RUNFILES}" << EOF
 
 [$SINGLETESTDIR]
 tests = ['$SINGLETESTFILE']
@@ -745,4 +748,4 @@ if [ -n "$SINGLETEST" ]; then
 	rm -f "$RUNFILES" >/dev/null 2>&1
 fi
 
-exit ${RESULT}
+exit "${RESULT}"
diff --git a/sys/contrib/openzfs/scripts/zfs.sh b/sys/contrib/openzfs/scripts/zfs.sh
index 940c83ffa28f..0561092a089f 100755
--- a/sys/contrib/openzfs/scripts/zfs.sh
+++ b/sys/contrib/openzfs/scripts/zfs.sh
@@ -75,6 +75,8 @@ while getopts 'hvruS' OPTION; do
 		usage
 		exit
 		;;
+	*)
+		;;
 	esac
 done
 
@@ -271,6 +273,10 @@ if [ "$UNLOAD" = "yes" ]; then
 	           stack_check_linux
 	           unload_modules_linux
 		   ;;
+		*)
+	           echo "unknown system: $UNAME" >&2
+	           exit 1
+		   ;;
 	esac
 fi
 if [ "$LOAD" = "yes" ]; then
@@ -285,6 +291,10 @@ if [ "$LOAD" = "yes" ]; then
 		   udevadm trigger
 		   udevadm settle
 		   ;;
+		*)
+	           echo "unknown system: $UNAME" >&2
+	           exit 1
+		   ;;
 	esac
 fi
 
diff --git a/sys/contrib/openzfs/scripts/zimport.sh b/sys/contrib/openzfs/scripts/zimport.sh
index 03c766cf36c2..14d2813ce268 100755
--- a/sys/contrib/openzfs/scripts/zimport.sh
+++ b/sys/contrib/openzfs/scripts/zimport.sh
@@ -69,7 +69,7 @@ KEEP="no"
 VERBOSE="no"
 COLOR="yes"
 REPO="https://github.com/openzfs"
-IMAGES_DIR="$SCRIPTDIR/zfs-images/"
+IMAGES_DIR="${BASE_DIR}/zfs-images/"
 IMAGES_TAR="https://github.com/openzfs/zfs-images/tarball/master"
 ERROR=0
 
@@ -140,7 +140,7 @@ while getopts 'hvckr:s:i:p:f:o:?' OPTION; do
 	o)
 		POOL_CREATE_OPTIONS="$OPTARG"
 		;;
-	?)
+	*)
 		usage
 		exit 1
 		;;
@@ -170,7 +170,7 @@ populate() {
 	for DIR in $DIRS; do
 		COUNT=$((RANDOM % MAX_DIR_SIZE))
 
-		for _ in $(seq $COUNT); do
+		for _ in $(seq "$COUNT"); do
 			FILE=$(mktemp -p "$DIR")
 			SIZE=$((RANDOM % MAX_FILE_SIZE))
 			dd if=/dev/urandom of="$FILE" bs=1k \
@@ -471,7 +471,7 @@ for TAG in $POOL_TAGS; do
 	# Verify 'zpool import' works for all listed source versions.
 	for SRC_TAG in $SRC_TAGS; do
 
-		if [ $SKIP -eq 1 ]; then
+		if [ "$SKIP" -eq 1 ]; then
 			skip_nonewline
 			continue
 		fi
@@ -509,4 +509,4 @@ if [ "$KEEP" = "no" ]; then
 	rm -Rf "$TEST_DIR"
 fi
 
-exit $ERROR
+exit "$ERROR"
diff --git a/sys/contrib/openzfs/scripts/zloop.sh b/sys/contrib/openzfs/scripts/zloop.sh
index 4a572ebab1fc..1a512657be69 100755
--- a/sys/contrib/openzfs/scripts/zloop.sh
+++ b/sys/contrib/openzfs/scripts/zloop.sh
@@ -102,10 +102,12 @@ function core_file
 
 function core_prog
 {
+	# shellcheck disable=SC2154
 	prog=$ZTEST
 	core_id=$($GDB --batch -c "$1" | grep "Core was generated by" | \
 	    tr  \' ' ')
 	if [[ "$core_id" == *"zdb "* ]]; then
+		# shellcheck disable=SC2154
 		prog=$ZDB
 	fi
 	printf "%s" "$prog"
@@ -130,7 +132,7 @@ function store_core
 		or_die mkdir -p "$dest/vdev"
 
 		if [[ $symlink -ne 0 ]]; then
-			or_die ln -sf "$dest" ztest.core.$foundcrashes
+			or_die ln -sf "$dest" "ztest.core.${foundcrashes}"
 		fi
 
 		echo "*** ztest crash found - moving logs to $dest"
@@ -195,10 +197,10 @@ while getopts ":ht:m:I:s:c:f:l" opt; do
 	case $opt in
 		t ) [[ $OPTARG -gt 0 ]] && timeout=$OPTARG ;;
 		m ) [[ $OPTARG -gt 0 ]] && coremax=$OPTARG ;;
-		I ) [[ $OPTARG ]] && iterations=$OPTARG ;;
-		s ) [[ $OPTARG ]] && size=$OPTARG ;;
-		c ) [[ $OPTARG ]] && coredir=$OPTARG ;;
-		f ) [[ $OPTARG ]] && basedir=$(readlink -f "$OPTARG") ;;
+		I ) [[ -n $OPTARG ]] && iterations=$OPTARG ;;
+		s ) [[ -n $OPTARG ]] && size=$OPTARG ;;
+		c ) [[ -n $OPTARG ]] && coredir=$OPTARG ;;
+		f ) [[ -n $OPTARG ]] && basedir=$(readlink -f "$OPTARG") ;;
 		l ) symlink=1 ;;
 		h ) usage
 		    exit 2
diff --git a/sys/contrib/openzfs/tests/runfiles/common.run b/sys/contrib/openzfs/tests/runfiles/common.run
index d5052172d269..1c0042af1858 100644
--- a/sys/contrib/openzfs/tests/runfiles/common.run
+++ b/sys/contrib/openzfs/tests/runfiles/common.run
@@ -874,6 +874,10 @@ tags = ['functional', 'snapused']
 tests = ['sparse_001_pos']
 tags = ['functional', 'sparse']
 
+[tests/functional/stat]
+tests = ['stat_001_pos']
+tags = ['functional', 'stat']
+
 [tests/functional/suid]
 tests = ['suid_write_to_suid', 'suid_write_to_sgid', 'suid_write_to_suid_sgid',
     'suid_write_to_none']
@@ -902,7 +906,8 @@ tests = [
     'userquota_004_pos', 'userquota_005_neg', 'userquota_006_pos',
     'userquota_007_pos', 'userquota_008_pos', 'userquota_009_pos',
     'userquota_010_pos', 'userquota_011_pos', 'userquota_012_neg',
-    'userspace_001_pos', 'userspace_002_pos', 'userspace_encrypted']
+    'userspace_001_pos', 'userspace_002_pos', 'userspace_encrypted',
+    'userspace_send_encrypted']
 tags = ['functional', 'userquota']
 
 [tests/functional/vdev_zaps]
diff --git a/sys/contrib/openzfs/tests/test-runner/bin/test-runner.py.in b/sys/contrib/openzfs/tests/test-runner/bin/test-runner.py.in
index d32e05c45392..3c0b82a311bb 100755
--- a/sys/contrib/openzfs/tests/test-runner/bin/test-runner.py.in
+++ b/sys/contrib/openzfs/tests/test-runner/bin/test-runner.py.in
@@ -15,19 +15,14 @@
 # Copyright (c) 2012, 2018 by Delphix. All rights reserved.
 # Copyright (c) 2019 Datto Inc.
 #
-# This script must remain compatible with Python 2.6+ and Python 3.4+.
+# This script must remain compatible with Python 3.6+.
 #
 
-# some python 2.7 system don't have a configparser shim
-try:
-    import configparser
-except ImportError:
-    import ConfigParser as configparser
-
 import os
 import sys
 import ctypes
 import re
+import configparser
 
 from datetime import datetime
 from optparse import OptionParser
@@ -37,7 +32,7 @@ from select import select
 from subprocess import PIPE
 from subprocess import Popen
 from threading import Timer
-from time import time
+from time import time, CLOCK_MONOTONIC
 
 BASEDIR = '/var/tmp/test_results'
 TESTDIR = '/usr/share/zfs/'
@@ -49,9 +44,6 @@ LOG_OUT = 'LOG_OUT'
 LOG_ERR = 'LOG_ERR'
 LOG_FILE_OBJ = None
 
-# some python 2.7 system don't have a concept of monotonic time
-CLOCK_MONOTONIC_RAW = 4  # see <linux/time.h>
-
 
 class timespec(ctypes.Structure):
     _fields_ = [
@@ -67,7 +59,7 @@ clock_gettime.argtypes = [ctypes.c_int, ctypes.POINTER(timespec)]
 
 def monotonic_time():
     t = timespec()
-    if clock_gettime(CLOCK_MONOTONIC_RAW, ctypes.pointer(t)) != 0:
+    if clock_gettime(CLOCK_MONOTONIC, ctypes.pointer(t)) != 0:
         errno_ = ctypes.get_errno()
         raise OSError(errno_, os.strerror(errno_))
     return t.tv_sec + t.tv_nsec * 1e-9
diff --git a/sys/contrib/openzfs/tests/test-runner/bin/zts-report.py.in b/sys/contrib/openzfs/tests/test-runner/bin/zts-report.py.in
index e14472e2f4f5..9f00ec11b437 100755
--- a/sys/contrib/openzfs/tests/test-runner/bin/zts-report.py.in
+++ b/sys/contrib/openzfs/tests/test-runner/bin/zts-report.py.in
@@ -15,7 +15,7 @@
 # Copyright (c) 2017 by Delphix. All rights reserved.
 # Copyright (c) 2018 by Lawrence Livermore National Security, LLC.
 #
-# This script must remain compatible with Python 2.6+ and Python 3.4+.
+# This script must remain compatible with Python 3.6+.
 #
 
 import os
@@ -62,13 +62,13 @@ known_reason = 'Known issue'
 exec_reason = 'Test user execute permissions required for utilities'
 
 #
-# Some tests require a minimum python version of 3.5 and will be skipped when
+# Some tests require a minimum python version of 3.6 and will be skipped when
 # the default system version is too old.  There may also be tests which require
-# additional python modules be installed, for example python-cffi is required
+# additional python modules be installed, for example python3-cffi is required
 # by the pyzfs tests.
 #
-python_reason = 'Python v3.5 or newer required'
-python_deps_reason = 'Python modules missing: python-cffi'
+python_reason = 'Python v3.6 or newer required'
+python_deps_reason = 'Python modules missing: python3-cffi'
 
 #
 # Some tests require the O_TMPFILE flag which was first introduced in the
@@ -250,12 +250,6 @@ maybe = {
     'removal/removal_condense_export': ['FAIL', known_reason],
     'reservation/reservation_008_pos': ['FAIL', '7741'],
     'reservation/reservation_018_pos': ['FAIL', '5642'],
-    'rsend/rsend_019_pos': ['FAIL', '6086'],
-    'rsend/rsend_020_pos': ['FAIL', '6446'],
-    'rsend/rsend_021_pos': ['FAIL', '6446'],
-    'rsend/rsend_024_pos': ['FAIL', '5665'],
-    'rsend/send-c_volume': ['FAIL', '6087'],
-    'rsend/send_partial_dataset': ['FAIL', known_reason],
     'snapshot/clone_001_pos': ['FAIL', known_reason],
     'snapshot/snapshot_009_pos': ['FAIL', '7961'],
     'snapshot/snapshot_010_pos': ['FAIL', '7961'],
@@ -289,11 +283,6 @@ if sys.platform.startswith('freebsd'):
     })
 elif sys.platform.startswith('linux'):
     maybe.update({
-        'alloc_class/alloc_class_009_pos': ['FAIL', known_reason],
-        'alloc_class/alloc_class_010_pos': ['FAIL', known_reason],
-        'alloc_class/alloc_class_011_neg': ['FAIL', known_reason],
-        'alloc_class/alloc_class_012_pos': ['FAIL', known_reason],
-        'alloc_class/alloc_class_013_pos': ['FAIL', '11888'],
         'cli_root/zfs_rename/zfs_rename_002_pos': ['FAIL', known_reason],
         'cli_root/zpool_expand/zpool_expand_001_pos': ['FAIL', known_reason],
         'cli_root/zpool_expand/zpool_expand_005_pos': ['FAIL', known_reason],
@@ -305,11 +294,6 @@ elif sys.platform.startswith('linux'):
         'mmp/mmp_active_import': ['FAIL', known_reason],
         'mmp/mmp_exported_import': ['FAIL', known_reason],
         'mmp/mmp_inactive_import': ['FAIL', known_reason],
-        'refreserv/refreserv_raidz': ['FAIL', known_reason],
-        'rsend/rsend_007_pos': ['FAIL', known_reason],
-        'rsend/rsend_010_pos': ['FAIL', known_reason],
-        'rsend/rsend_011_pos': ['FAIL', known_reason],
-        'snapshot/rollback_003_pos': ['FAIL', known_reason],
         'zvol/zvol_misc/zvol_misc_snapdev': ['FAIL', '12621'],
         'zvol/zvol_misc/zvol_misc_volmode': ['FAIL', known_reason],
     })
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/Makefile.am b/sys/contrib/openzfs/tests/zfs-tests/cmd/Makefile.am
index d1c29fcd1c62..2470397a90a3 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/Makefile.am
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/Makefile.am
@@ -32,6 +32,7 @@ SUBDIRS = \
 
 if BUILD_LINUX
 SUBDIRS += \
+	getversion \
 	randfree_file \
 	user_ns_exec \
 	xattrtest
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/btree_test/btree_test.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/btree_test/btree_test.c
index 8de14ff2a266..aaad4e47e464 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/btree_test/btree_test.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/btree_test/btree_test.c
@@ -294,6 +294,7 @@ drain_tree(zfs_btree_t *bt, char *why)
 static int
 stress_tree(zfs_btree_t *bt, char *why)
 {
+	(void) why;
 	avl_tree_t avl;
 	int_node_t *node;
 	struct timeval tp;
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/.gitignore b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/.gitignore
new file mode 100644
index 000000000000..b347c417aa13
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/.gitignore
@@ -0,0 +1 @@
+/getversion
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/Makefile.am b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/Makefile.am
new file mode 100644
index 000000000000..d6b5e84082b2
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/Makefile.am
@@ -0,0 +1,6 @@
+include $(top_srcdir)/config/Rules.am
+
+pkgexecdir = $(datadir)/@PACKAGE@/zfs-tests/bin
+
+pkgexec_PROGRAMS = getversion
+getversion_SOURCES = getversion.c
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/getversion.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/getversion.c
new file mode 100644
index 000000000000..62c1c5b6abc0
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/getversion/getversion.c
@@ -0,0 +1,48 @@
+/*
+ * This file and its contents are supplied under the terms of the
+ * Common Development and Distribution License ("CDDL"), version 1.0.
+ * You may only use this file in accordance with the terms of version
+ * 1.0 of the CDDL.
+ *
+ * A full copy of the text of the CDDL should have accompanied this
+ * source.  A copy of the CDDL is also available via the Internet at
+ * http://www.illumos.org/license/CDDL.
+ */
+
+/*
+ * Copyright 2021 iXsystems, Inc.
+ */
+
+/*
+ * FreeBSD and macOS expose file generation number through stat(2) and stat(1).
+ * Linux exposes it instead through an ioctl.
+ */
+
+#include <sys/ioctl.h>
+#include <sys/fcntl.h>
+#include <linux/fs.h>
+#include <err.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+int
+main(int argc, const char * const argv[])
+{
+	if (argc != 2)
+		errx(EXIT_FAILURE, "usage: %s filename", argv[0]);
+
+	int fd = open(argv[1], O_RDONLY);
+	if (fd == -1)
+		err(EXIT_FAILURE, "failed to open %s", argv[1]);
+
+	int gen = 0;
+	if (ioctl(fd, FS_IOC_GETVERSION, &gen) == -1)
+		err(EXIT_FAILURE, "FS_IOC_GETVERSION failed");
+
+	(void) close(fd);
+
+	(void) printf("%d\n", gen);
+
+	return (EXIT_SUCCESS);
+}
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/largest_file/largest_file.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/largest_file/largest_file.c
index 00e1019cc8e4..912607640965 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/largest_file/largest_file.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/largest_file/largest_file.c
@@ -137,9 +137,9 @@ usage(char *name)
 	exit(1);
 }
 
-/* ARGSUSED */
 static void
 sigxfsz(int signo)
 {
+	(void) signo;
 	(void) printf("\nlargest_file: sigxfsz() caught SIGXFSZ\n");
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_libaio/mmap_libaio.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_libaio/mmap_libaio.c
index 21119ebca9d6..a02f46d91b30 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_libaio/mmap_libaio.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_libaio/mmap_libaio.c
@@ -52,6 +52,7 @@ do_sync_io(struct iocb *iocb)
 int
 main(int argc, char **argv)
 {
+	(void) argc;
 	char *buf;
 	int page_size = getpagesize();
 	int buf_size = strtol(argv[2], NULL, 0);
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_seek/mmap_seek.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_seek/mmap_seek.c
index f476e1dba9a4..bb36527aafee 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_seek/mmap_seek.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/mmap_seek/mmap_seek.c
@@ -29,7 +29,11 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <sys/sysmacros.h>
 #include <errno.h>
+#ifdef __linux__
+#include <linux/fs.h>
+#endif
 
 static void
 seek_data(int fd, off_t offset, off_t expected)
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/rename_dir/rename_dir.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/rename_dir/rename_dir.c
index 5f80f7229462..897ec7b84148 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/rename_dir/rename_dir.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/rename_dir/rename_dir.c
@@ -49,7 +49,7 @@
 #include <strings.h>
 
 int
-main(int argc, char *argvp[])
+main(void)
 {
 	int i = 1;
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/rm_lnkcnt_zero_file/rm_lnkcnt_zero_file.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/rm_lnkcnt_zero_file/rm_lnkcnt_zero_file.c
index e262ecefea92..f8b6e3e808bb 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/rm_lnkcnt_zero_file/rm_lnkcnt_zero_file.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/rm_lnkcnt_zero_file/rm_lnkcnt_zero_file.c
@@ -55,10 +55,10 @@ pickidx(void)
 	return (random() % 1000);
 }
 
-/* ARGSUSED */
 static void *
 mover(void *a)
 {
+	(void) a;
 	char buf[256];
 	int idx, len, ret;
 
@@ -75,10 +75,10 @@ mover(void *a)
 	return (NULL);
 }
 
-/* ARGSUSED */
 static void *
 cleaner(void *a)
 {
+	(void) a;
 	char buf[256];
 	int idx, len, ret;
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/cmd/xattrtest/xattrtest.c b/sys/contrib/openzfs/tests/zfs-tests/cmd/xattrtest/xattrtest.c
index 0b68126c0327..49b6629ba056 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/cmd/xattrtest/xattrtest.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/cmd/xattrtest/xattrtest.c
@@ -96,12 +96,12 @@ static char script[PATH_MAX] = "/bin/true";
 static char xattrbytes[XATTR_SIZE_MAX];
 
 static int
-usage(int argc, char **argv)
+usage(char *argv0)
 {
 	fprintf(stderr,
 	    "usage: %s [-hvycdrRk] [-n <nth>] [-f <files>] [-x <xattrs>]\n"
 	    "       [-s <bytes>] [-p <path>] [-t <script> ] [-o <phase>]\n",
-	    argv[0]);
+	    argv0);
 
 	fprintf(stderr,
 	    "  --help        -h           This help\n"
@@ -136,7 +136,7 @@ parse_args(int argc, char **argv)
 	while ((c = getopt_long(argc, argv, shortopts, longopts, NULL)) != -1) {
 		switch (c) {
 		case 'h':
-			return (usage(argc, argv));
+			return (usage(argv[0]));
 		case 'v':
 			verbose++;
 			break;
diff --git a/sys/contrib/openzfs/tests/zfs-tests/include/blkdev.shlib b/sys/contrib/openzfs/tests/zfs-tests/include/blkdev.shlib
index 18fc6b3524a0..7159b92c080f 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/include/blkdev.shlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/include/blkdev.shlib
@@ -595,7 +595,7 @@ function list_file_blocks # input_file
 	else
 		AWK='awk'
 	fi
-	log_must zpool sync -f
+	sync_all_pools true
 	zdb -dddddd $ds $objnum | $AWK -v pad=$((4<<20)) -v bs=512 '
 	    /^$/ { looking = 0 }
 	    looking {
diff --git a/sys/contrib/openzfs/tests/zfs-tests/include/commands.cfg b/sys/contrib/openzfs/tests/zfs-tests/include/commands.cfg
index 4497a6248b4b..ca7628855d66 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/include/commands.cfg
+++ b/sys/contrib/openzfs/tests/zfs-tests/include/commands.cfg
@@ -71,8 +71,6 @@ export SYSTEM_FILES_COMMON='arp
     printf
     ps
     pwd
-    python
-    python2
     python3
     quotaon
     readlink
@@ -201,6 +199,7 @@ export ZFSTEST_FILES='badsend
     file_trunc
     file_write
     get_diff
+    getversion
     largest_file
     libzfs_input_check
     mkbusy
diff --git a/sys/contrib/openzfs/tests/zfs-tests/include/libtest.shlib b/sys/contrib/openzfs/tests/zfs-tests/include/libtest.shlib
index 2e6ec7601db3..24010d9f3732 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/include/libtest.shlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/include/libtest.shlib
@@ -3104,6 +3104,7 @@ function datasetcksum
 {
 	typeset cksum
 	sync
+	sync_all_pools
 	cksum=$(zdb -vvv $1 | grep "^Dataset $1 \[" | grep "cksum" \
 		| awk -F= '{print $7}')
 	echo $cksum
@@ -3519,6 +3520,24 @@ function sync_pool #pool <force>
 	return 0
 }
 
+#
+# Sync all pools
+#
+# $1 boolean to force uberblock (and config including zpool cache file) update
+#
+function sync_all_pools #<force>
+{
+	typeset force=${1:-false}
+
+	if [[ $force == true ]]; then
+		log_must zpool sync -f
+	else
+		log_must zpool sync
+	fi
+
+	return 0
+}
+
 #
 # Wait for zpool 'freeing' property drops to zero.
 #
@@ -4051,6 +4070,20 @@ function stat_crtime #<path>
 	esac
 }
 
+function stat_generation #<path>
+{
+	typeset path=$1
+
+	case $(uname) in
+	Linux)
+		getversion "${path}"
+		;;
+	*)
+		stat -f %v "${path}"
+		;;
+	esac
+}
+
 # Run a command as if it was being run in a TTY.
 #
 # Usage:
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/Makefile.am b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/Makefile.am
index 137cddd5f784..1412e3d8132e 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/Makefile.am
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/Makefile.am
@@ -73,6 +73,7 @@ SUBDIRS = \
 	snapshot \
 	snapused \
 	sparse \
+	stat \
 	suid \
 	threadsappend \
 	trim \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class.kshlib
index 4c64cff69643..e204f43b3bcd 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class.kshlib
@@ -62,6 +62,7 @@ function display_status
 	((ret |= $?))
 
 	kill -9 $pid
+	wait $pid 2> /dev/null
 
 	return $ret
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_012_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_012_pos.ksh
index b49a8919ed8c..2bce471a7f30 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_012_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_012_pos.ksh
@@ -85,7 +85,7 @@ function check_removal
 		    bs=1M count=$blocks
 		((blocks = blocks + 25))
 	done
-	log_must sync_pool $TESTPOOL
+	sync_pool $TESTPOOL
 	log_must zpool list -v $TESTPOOL
 
 	# Verify the files were written in the special class vdevs
@@ -98,7 +98,7 @@ function check_removal
 	log_must zpool remove $TESTPOOL $CLASS_DISK0
 
 	sleep 5
-	log_must sync_pool $TESTPOOL
+	sync_pool $TESTPOOL
 	sleep 1
 
 	log_must zdb -bbcc $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_013_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_013_pos.ksh
index 2ce22a624291..7a0eb53436a1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_013_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/alloc_class/alloc_class_013_pos.ksh
@@ -53,7 +53,7 @@ log_must zpool list -v $TESTPOOL
 log_must zpool remove $TESTPOOL $CLASS_DISK0
 
 sleep 5
-log_must sync_pool $TESTPOOL
+sync_pool $TESTPOOL
 sleep 1
 
 log_must zdb -bbcc $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_001_pos.ksh
index 0577a6b80c04..712309eda72f 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_001_pos.ksh
@@ -75,7 +75,7 @@ log_assert "dbufstats produces correct statistics"
 log_onexit cleanup
 
 log_must file_write -o create -f "$TESTDIR/file" -b 1048576 -c 20 -d R
-log_must zpool sync
+sync_all_pools
 
 log_must eval "kstat dbufs > $DBUFS_FILE"
 log_must eval "kstat dbufstats '' > $DBUFSTATS_FILE"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_002_pos.ksh
index 58d401539ed1..e253553f07c0 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/arc/dbufstats_002_pos.ksh
@@ -56,7 +56,7 @@ log_assert "dbufs move from mru to mfu list"
 log_onexit cleanup
 
 log_must file_write -o create -f "$TESTDIR/file" -b 1048576 -c 1 -d R
-log_must zpool sync
+sync_all_pools
 
 objid=$(get_objnum "$TESTDIR/file")
 log_note "Object ID for $TESTDIR/file is $objid"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/channel_program/synctask_core/tst.get_written.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/channel_program/synctask_core/tst.get_written.ksh
index 9755e6f82e58..74fdffdce4fd 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/channel_program/synctask_core/tst.get_written.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/channel_program/synctask_core/tst.get_written.ksh
@@ -46,7 +46,7 @@ log_must_program $TESTPOOL - <<-EOF
 EOF
 
 log_must mkdir $dir
-sync
+sync_all_pools
 
 log_must_program $TESTPOOL - <<-EOF
 	ans, setpoint = zfs.get_prop("$fs", "written@$TESTSNAP")
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_args_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_args_neg.ksh
index ae948bb9b755..cb88def7cc3e 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_args_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_args_neg.ksh
@@ -58,7 +58,7 @@ set -A args "create" "add" "destroy" "import fakepool" \
     "setvprop" "blah blah" "-%" "--?" "-*" "-=" \
     "-a" "-f" "-g" "-j" "-n" "-o" "-p" "-p /tmp" \
     "-t" "-w" "-z" "-E" "-H" "-I" "-J" "-K" \
-    "-N" "-Q" "-R" "-T" "-W"
+    "-Q" "-R" "-T" "-W"
 
 log_assert "Execute zdb using invalid parameters."
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_block_size_histogram.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_block_size_histogram.ksh
index 8d677affb9fe..6ad93d87ca9a 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_block_size_histogram.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_block_size_histogram.ksh
@@ -128,7 +128,7 @@ function histo_populate_test_pool
 	# to the device.  This 'sync' command prevents that from 
 	# happening.
 	####################
-	log_must zpool sync ${pool}
+	sync_pool ${pool}
 }
 function histo_check_test_pool
 {
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_neg.ksh
index 430180788044..e2014405853d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_neg.ksh
@@ -40,7 +40,7 @@ verify_runnable "both"
 verify_disk_count "$DISKS" 2
 default_mirror_setup_noexit $DISKS
 
-log_must zpool sync
+sync_all_pools
 
 set -A bad_flags a b c   e   g h i j k l   n o p q r s t u v w x y   \
                    B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_pos.ksh
index b7f47d11ad2f..61c031a0ce5b 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_object_range_pos.ksh
@@ -76,7 +76,7 @@ for x in $(seq 0 7); do
 	mkdir $TESTDIR/dir$x
 done
 
-log_must zpool sync
+sync_all_pools
 
 # Get list of all objects, but filter out user/group objects which don't
 # appear when using object or object range arguments
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_objset_id.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_objset_id.ksh
index d23cc43c90ef..27d3d61fbbad 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_objset_id.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_objset_id.ksh
@@ -30,10 +30,16 @@
 # 6. Confirm names
 # 7. Run zdb -dddddd pool/objsetID objectID (hex) 
 # 8. Confirm names
-# 9. Obtain objsetID from /proc/spl/kstat/zfs/testpool/obset-0x<ID>
+# 9. Repeat with zdb -NNNNNN pool/objsetID objectID
+# 10. Obtain objsetID from /proc/spl/kstat/zfs/testpool/obset-0x<ID>
 #    (linux only)
-# 10. Run zdb -dddddd pool/objsetID (hex)
-# 11. Match name from zdb against proc entry
+# 11. Run zdb -dddddd pool/objsetID (hex)
+# 12. Match name from zdb against proc entry
+# 13. Create dataset with hex numeric name
+# 14. Create dataset with decimal numeric name
+# 15. zdb -d for numeric datasets succeeds
+# 16. zdb -N for numeric datasets fails
+# 17. zdb -dN for numeric datasets fails
 #
 
 function cleanup
@@ -78,6 +84,17 @@ do
 	(( $? != 0 )) && log_fail \
 	    "zdb -dddddd $TESTPOOL/$id $obj failed $reason"
 	obj=$(printf "0x%X" $obj)
+
+	log_note "zdb -NNNNNN $TESTPOOL/$id $obj"
+        output=$(zdb -NNNNNN $TESTPOOL/$id $obj)
+        reason="($TESTPOOL/$TESTFS not in zdb output)"
+        echo $output |grep "$TESTPOOL/$TESTFS" > /dev/null
+        (( $? != 0 )) && log_fail \
+            "zdb -NNNNNN $TESTPOOL/$id $obj failed $reason"
+        reason="(file1 not in zdb output)"
+        echo $output |grep "file1" > /dev/null
+        (( $? != 0 )) && log_fail \
+            "zdb -NNNNNN $TESTPOOL/$id $obj failed $reason"
 done
 
 if is_linux; then
@@ -94,4 +111,23 @@ if is_linux; then
 	    "zdb -dddddd $TESTPOOL/$objset_hex failed $reason"
 fi
 
+log_must zfs create $TESTPOOL/0x400
+log_must zfs create $TESTPOOL/100
+output=$(zdb -d $TESTPOOL/0x400)
+reason="($TESTPOOL/0x400 not in zdb output)"
+echo $output |grep "$TESTPOOL/0x400" > /dev/null
+(( $? != 0 )) && log_fail \
+    "zdb -d $TESTPOOL/0x400 failed $reason"
+output=$(zdb -d $TESTPOOL/100)
+reason="($TESTPOOL/100 not in zdb output)"
+echo $output |grep "$TESTPOOL/100" > /dev/null
+(( $? != 0 )) && log_fail \
+    "zdb -d $TESTPOOL/100 failed $reason"
+
+# force numeric interpretation, should fail
+log_mustnot zdb -N $TESTPOOL/0x400
+log_mustnot zdb -N $TESTPOOL/100
+log_mustnot zdb -Nd $TESTPOOL/0x400
+log_mustnot zdb -Nd $TESTPOOL/100
+
 log_pass "zdb -d <pool>/<objset ID> generates the correct names."
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover.ksh
index d51edf3763d4..b39856141305 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover.ksh
@@ -47,7 +47,7 @@ verify_disk_count "$DISKS" 2
 
 default_mirror_setup_noexit $DISKS
 file_write -o create -w -f $init_data -b $blksize -c $write_count
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 output=$(zdb -r $TESTPOOL/$TESTFS file1 $tmpfile)
 log_must cmp $init_data $tmpfile
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover_2.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover_2.ksh
index 91f04c795638..6470327a1765 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover_2.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zdb/zdb_recover_2.ksh
@@ -49,7 +49,7 @@ verify_disk_count "$DISKS" 2
 default_mirror_setup_noexit $DISKS
 file_write -o create -w -f $init_data -b $blksize -c $write_count
 log_must echo "zfs" >> $init_data
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 output=$(zdb -r $TESTPOOL/$TESTFS file1 $tmpfile)
 log_must cmp $init_data $tmpfile
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_copies/zfs_copies_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_copies/zfs_copies_002_pos.ksh
index b644fcae3cf8..5774fb873f33 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_copies/zfs_copies_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_copies/zfs_copies_002_pos.ksh
@@ -67,7 +67,7 @@ done
 #
 # Sync up the filesystem
 #
-sync
+sync_all_pools
 
 #
 # Verify 'zfs list' can correctly list the space charged
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_and_disable.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_and_disable.ksh
index ab506debe9eb..2f328ceac4ae 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_and_disable.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_and_disable.ksh
@@ -66,7 +66,7 @@ function test_condense
 	# sync between each write to make sure a new entry is created
 	for i in {0..4}; do
 	    log_must mkfile 5m /$TESTPOOL/$TESTCLONE/testfile$i
-	    log_must zpool sync $TESTPOOL
+	    sync_pool $TESTPOOL
 	done
 
 	check_ll_len "5 entries" "Unexpected livelist size"
@@ -74,7 +74,7 @@ function test_condense
 	# sync between each write to allow for a condense of the previous entry
 	for i in {0..4}; do
 	    log_must mkfile 5m /$TESTPOOL/$TESTCLONE/testfile$i
-	    log_must zpool sync $TESTPOOL
+	    sync_pool $TESTPOOL
 	done
 
 	check_ll_len "6 entries" "Condense did not occur"
@@ -91,7 +91,7 @@ function test_deactivated
 
 	log_must mkfile 5m /$TESTPOOL/$TESTCLONE/$TESTFILE0
 	log_must mkfile 5m /$TESTPOOL/$TESTCLONE/$TESTFILE1
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	# snapshot and clone share 'atestfile', 33 percent
 	check_livelist_gone
 	log_must zfs destroy -R $TESTPOOL/$TESTCLONE
@@ -103,7 +103,7 @@ function test_deactivated
 	log_must mkfile 5m /$TESTPOOL/$TESTCLONE/$TESTFILE0
 	log_must mkfile 5m /$TESTPOOL/$TESTCLONE/$TESTFILE1
 	log_must mkfile 5m /$TESTPOOL/$TESTCLONE/$TESTFILE2
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	# snapshot and clone share 'atestfile', 25 percent
 	check_livelist_exists $TESTCLONE
 	log_must rm /$TESTPOOL/$TESTCLONE/atestfile
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_races.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_races.ksh
index 453b502416ed..d83280e32dea 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_races.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_condense_races.ksh
@@ -49,11 +49,11 @@ function delete_race
 	set_tunable32 "$1" 0
 	log_must zfs clone $TESTPOOL/$TESTFS1@snap $TESTPOOL/$TESTCLONE
 	for i in {1..5}; do
-		log_must zpool sync $TESTPOOL
+		sync_pool $TESTPOOL
 		log_must mkfile 5m /$TESTPOOL/$TESTCLONE/out
 	done
 	log_must zfs destroy $TESTPOOL/$TESTCLONE
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	[[ "1" == "$(get_tunable "$1")" ]] || \
 	    log_fail "delete/condense race test failed"
 }
@@ -63,7 +63,7 @@ function export_race
 	set_tunable32 "$1" 0
 	log_must zfs clone $TESTPOOL/$TESTFS1@snap $TESTPOOL/$TESTCLONE
 	for i in {1..5}; do
-		log_must zpool sync $TESTPOOL
+		sync_pool $TESTPOOL
 		log_must mkfile 5m /$TESTPOOL/$TESTCLONE/out
 	done
 	log_must zpool export $TESTPOOL
@@ -78,12 +78,12 @@ function disable_race
 	set_tunable32 "$1" 0
 	log_must zfs clone $TESTPOOL/$TESTFS1@snap $TESTPOOL/$TESTCLONE
 	for i in {1..5}; do
-		log_must zpool sync $TESTPOOL
+		sync_pool $TESTPOOL
 		log_must mkfile 5m /$TESTPOOL/$TESTCLONE/out
 	done
 	# overwrite the file shared with the origin to trigger disable
 	log_must mkfile 100m /$TESTPOOL/$TESTCLONE/atestfile
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	[[ "1" == "$(get_tunable "$1")" ]] || \
 	    log_fail "disable/condense race test failed"
 	log_must zfs destroy $TESTPOOL/$TESTCLONE
@@ -95,7 +95,7 @@ log_onexit cleanup
 
 log_must zfs create $TESTPOOL/$TESTFS1
 log_must mkfile 100m /$TESTPOOL/$TESTFS1/atestfile
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 log_must zfs snapshot $TESTPOOL/$TESTFS1@snap
 
 # Reduce livelist size to trigger condense more easily
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_dedup.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_dedup.ksh
index 5f356967a457..00583402db89 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_dedup.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_clone_livelist_dedup.ksh
@@ -54,12 +54,12 @@ function test_dedup
 	# Note: We sync before and after so all dedup blocks belong to the
 	#       same TXG, otherwise they won't look identical to the livelist
 	#       iterator due to their logical birth TXG being different.
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	log_must cp /$TESTPOOL/$TESTCLONE/data /$TESTPOOL/$TESTCLONE/data-dup-0
 	log_must cp /$TESTPOOL/$TESTCLONE/data /$TESTPOOL/$TESTCLONE/data-dup-1
 	log_must cp /$TESTPOOL/$TESTCLONE/data /$TESTPOOL/$TESTCLONE/data-dup-2
 	log_must cp /$TESTPOOL/$TESTCLONE/data /$TESTPOOL/$TESTCLONE/data-dup-3
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	check_livelist_exists $TESTCLONE
 
 	# Introduce "double frees"
@@ -67,10 +67,10 @@ function test_dedup
 	#   was what triggered past panics.
 	# Note: Similarly to the previouys step we sync before and after our
 	#       our deletions so all the entries end up in the same TXG.
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	log_must rm /$TESTPOOL/$TESTCLONE/data-dup-2
 	log_must rm /$TESTPOOL/$TESTCLONE/data-dup-3
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 	check_livelist_exists $TESTCLONE
 
 	log_must zfs destroy $TESTPOOL/$TESTCLONE
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_clone_livelist.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_clone_livelist.ksh
index e7663ef7973c..9165b03a1647 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_clone_livelist.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_clone_livelist.ksh
@@ -47,7 +47,7 @@ function cleanup
 function clone_write_file
 {
 	log_must mkfile 1m /$TESTPOOL/$1/$2
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 }
 
 function test_one_empty
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_common.kshlib
index 1a20b7a33131..51b3d2e513cc 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_common.kshlib
@@ -153,7 +153,7 @@ function check_livelist_exists
 function check_livelist_gone
 {
 	log_must zpool wait -t free $TESTPOOL
-	zpool sync
+	sync_all_pools
 	zdb -vvvvv $TESTPOOL | grep "Livelist" && \
 		log_fail "zdb found Livelist after the clone is deleted."
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_dev_removal_condense.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_dev_removal_condense.ksh
index ab646daecedc..b4f2740c7aa2 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_dev_removal_condense.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_destroy/zfs_destroy_dev_removal_condense.ksh
@@ -65,7 +65,7 @@ log_must zfs clone $TESTPOOL2/$TESTFS@snap $TESTPOOL2/$TESTCLONE
 # Create initial files and pause condense zthr on next execution
 log_must mkfile 10m /$TESTPOOL2/$TESTCLONE/A
 log_must mkfile 1m /$TESTPOOL2/$TESTCLONE/B
-log_must zpool sync $TESTPOOL2
+sync_pool $TESTPOOL2
 set_tunable32 LIVELIST_CONDENSE_SYNC_PAUSE 1
 
 # Add a new dev and remove the old one
@@ -76,15 +76,15 @@ wait_for_removal $TESTPOOL2
 set_tunable32 LIVELIST_CONDENSE_NEW_ALLOC 0
 # Trigger a condense
 log_must mkfile 10m /$TESTPOOL2/$TESTCLONE/A
-log_must zpool sync $TESTPOOL2
+sync_pool $TESTPOOL2
 log_must mkfile 10m /$TESTPOOL2/$TESTCLONE/A
-log_must zpool sync $TESTPOOL2
+sync_pool $TESTPOOL2
 # Write remapped blkptrs which will modify the livelist mid-condense
 log_must mkfile 1m /$TESTPOOL2/$TESTCLONE/B
 
 # Resume condense thr
 set_tunable32 LIVELIST_CONDENSE_SYNC_PAUSE 0
-log_must zpool sync $TESTPOOL2
+sync_pool $TESTPOOL2
 # Check that we've added new ALLOC blkptrs during the condense
 [[ "0" < "$(get_tunable LIVELIST_CONDENSE_NEW_ALLOC)" ]] || \
     log_fail "removal/condense test failed"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_mount/zfs_mount_remount.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_mount/zfs_mount_remount.ksh
index ac6103ebc7bf..259f0e99b65c 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_mount/zfs_mount_remount.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_mount/zfs_mount_remount.ksh
@@ -155,7 +155,7 @@ CRYPT_MNTPFS="$(get_prop mountpoint $TESTFS/crypt)"
 log_must touch $CRYPT_MNTPFS/file.dat
 log_must mount $RO $TESTFS/crypt $CRYPT_MNTPFS
 log_must umount -f $CRYPT_MNTPFS
-zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 # 6. Re-import the pool readonly
 log_must zpool export $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_program/zfs_program_json.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_program/zfs_program_json.ksh
index 3788543b0b2f..b0265c5ee4a1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_program/zfs_program_json.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_program/zfs_program_json.ksh
@@ -92,27 +92,13 @@ typeset -a pos_cmds_out=(
     }
 }")
 
-#
-# N.B. json.tool is needed to guarantee consistent ordering of fields,
-# sed is needed to trim trailing space in CentOS 6's json.tool output
-#
-# As of Python 3.5 the behavior of json.tool changed to keep the order
-# the same as the input and the --sort-keys option was added.  Detect when
-# --sort-keys is supported and apply the option to ensure the expected order.
-#
-if python -m json.tool --sort-keys <<< "{}"; then
-	JSON_TOOL_CMD="python -m json.tool --sort-keys"
-else
-	JSON_TOOL_CMD="python -m json.tool"
-fi
-
 typeset -i cnt=0
 typeset cmd
 for cmd in ${pos_cmds[@]}; do
 	log_must zfs program $TESTPOOL $TESTZCP $TESTDS $cmd 2>&1
 	log_must zfs program -j $TESTPOOL $TESTZCP $TESTDS $cmd 2>&1
 	OUTPUT=$(zfs program -j $TESTPOOL $TESTZCP $TESTDS $cmd 2>&1 |
-	    $JSON_TOOL_CMD | sed 's/[[:space:]]*$//')
+	    python3 -m json.tool --sort-keys)
 	if [ "$OUTPUT" != "${pos_cmds_out[$cnt]}" ]; then
 		log_note "Got     :$OUTPUT"
 		log_note "Expected:${pos_cmds_out[$cnt]}"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_004_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_004_neg.ksh
index 7c115ee33b96..2860cab2b679 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_004_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_004_neg.ksh
@@ -87,7 +87,7 @@ log_must zfs snapshot $inc_snap
 log_must eval "zfs send -i $init_snap $inc_snap > $inc_bkup"
 log_must touch /$TESTDIR/bar
 
-sync
+sync_all_pools
 
 set -A badargs \
     "" "nonexistent-snap" "blah@blah" "-d" "-d nonexistent-dataset" \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_011_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_011_pos.ksh
index afae804a15c2..7de2c1834807 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_011_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_receive/zfs_receive_011_pos.ksh
@@ -65,14 +65,14 @@ origdir=$(get_prop mountpoint $orig)
 #	2. Create two equal-sized large files.
 log_must mkfile 5M $origdir/file1
 log_must mkfile 5M $origdir/file2
-log_must sync
+sync_all_pools
 
 #	3. Snapshot the filesystem.
 log_must zfs snapshot $orig@1
 
 #	4. Remove one of the two large files.
 log_must rm $origdir/file2
-log_must sync
+sync_all_pools
 
 #	5. Create a refquota larger than one file, but smaller than both.
 log_must zfs set refquota=8M $orig
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_rollback/zfs_rollback_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_rollback/zfs_rollback_common.kshlib
index 433f240675f3..2eadb68c372d 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_rollback/zfs_rollback_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_rollback/zfs_rollback_common.kshlib
@@ -116,6 +116,7 @@ function setup_snap_env
 			if datasetnonexists $snap; then
 				log_must cp /etc/passwd $fname
 				if is_linux || is_freebsd; then
+					sync_all_pools
 					log_must sync
 				else
 					#
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_send/zfs_send_007_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_send/zfs_send_007_pos.ksh
index da0aebe6b581..675afa72f5af 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_send/zfs_send_007_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zfs_send/zfs_send_007_pos.ksh
@@ -62,9 +62,9 @@ test_pool ()
 	log_must zfs snapshot $POOL/fs@a
 	while true; do
 		log_must find $mntpnt/ -type f -delete
-		sync
+		sync_all_pools
 		log_must mkfiles "$mntpnt/" 4000
-		sync
+		sync_all_pools
 		# check if we started reusing objects
 		object=$(ls -i $mntpnt | sort -n | awk -v object=$object \
 		    '{if ($1 <= object) {exit 1}} END {print $1}')
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool/zpool_colors.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool/zpool_colors.ksh
index 18f238386374..8c7f40ba9c0b 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool/zpool_colors.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool/zpool_colors.ksh
@@ -44,7 +44,7 @@ DISK3="$(echo $DISKS | cut -d' ' -f3)"
 
 log_must dd if=/dev/urandom of=/$TESTDIR/testfile bs=10M count=1
 
-log_must zpool sync
+sync_all_pools
 
 log_must zpool offline -f $TESTPOOL $DISK3
 log_must wait_for_degraded $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_clear/zpool_clear_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_clear/zpool_clear_001_pos.ksh
index 98b4140727c0..1188ca10d14d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_clear/zpool_clear_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_clear/zpool_clear_001_pos.ksh
@@ -175,7 +175,8 @@ function do_testing #<clear type> <vdevs>
 	esac
 	dd if=/dev/zero of=$fbase.$i seek=512 bs=1024 count=$wcount conv=notrunc \
 			> /dev/null 2>&1
-	log_must sync
+	sync_all_pools
+	log_must sync #ensure the vdev files are written out
 	log_must zpool scrub -w $TESTPOOL1
 
 	check_err $TESTPOOL1 && \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/ereports.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/ereports.c
index f825240000f7..bff3bb1ee808 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/ereports.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/ereports.c
@@ -146,9 +146,8 @@ ereports_dump(libzfs_handle_t *zhdl, int zevent_fd)
 	}
 }
 
-/* ARGSUSED */
 int
-main(int argc, char **argv)
+main(void)
 {
 	libzfs_handle_t *hdl;
 	int fd;
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_clear_retained.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_clear_retained.ksh
index fdf56b2cf9a6..22212a8f50a5 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_clear_retained.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_clear_retained.ksh
@@ -111,7 +111,7 @@ log_must zpool create -f -m $MOUNTDIR -o failmode=continue $POOL raidz $VDEV1 $V
 log_must zfs set compression=off recordsize=16k $POOL
 # create a file full of zeros
 log_must mkfile -v $FILESIZE $FILEPATH
-log_must zpool sync $POOL
+sync_pool $POOL
 
 # run once and observe the checksum errors
 damage_and_repair 1
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_duplicates.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_duplicates.ksh
index 595eacf5b4b0..7023c49e51f2 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_duplicates.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_duplicates.ksh
@@ -112,7 +112,7 @@ function do_dup_test
 
 	if [ "$RW" == "write" ] ; then
 		log_must mkfile $FILESIZE $FILEPATH
-		log_must zpool sync $POOL
+		sync_pool $POOL
 	fi
 
 	log_must zinject -c all
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_errors.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_errors.ksh
index 4645e245c973..f26c65f9db2c 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_errors.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_events/zpool_events_errors.ksh
@@ -28,11 +28,12 @@
 #	in zpool status.
 #
 # STRATEGY:
-#	1. Create a raidz or mirror pool
+#	1. Create a mirror, raidz, or draid pool
 #	2. Inject read/write IO errors or checksum errors
 #	3. Verify the number of errors in zpool status match the corresponding
 #	   number of error events.
-#	4. Repeat for all combinations of raidz/mirror and io/checksum errors.
+#	4. Repeat for all combinations of mirror/raidz/draid and io/checksum
+#	   errors.
 #
 
 . $STF_SUITE/include/libtest.shlib
@@ -74,7 +75,7 @@ log_must mkdir -p $MOUNTDIR
 
 # Run error test on a specific type of pool
 #
-# $1: pool - raidz, mirror
+# $1: pool - mirror, raidz, draid
 # $2: test type - corrupt (checksum error), io
 # $3: read, write
 function do_test
@@ -96,7 +97,7 @@ function do_test
 
 	if [ "$RW" == "write" ] ; then
 		log_must mkfile $FILESIZE $MOUNTDIR/file
-		log_must zpool sync $POOL
+		sync_pool $POOL
 	else
 		log_must zpool scrub $POOL
 		wait_scrubbed $POOL
@@ -142,8 +143,8 @@ function do_test
 	log_must zpool destroy $POOL
 }
 
-# Test all types of errors on mirror and raidz pools
-for pooltype in mirror raidz ; do
+# Test all types of errors on mirror, raidz, and draid pools
+for pooltype in mirror raidz draid; do
 	do_test $pooltype corrupt read
 	do_test $pooltype io read
 	do_test $pooltype io write
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_initialize/zpool_initialize_verify_checksums.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_initialize/zpool_initialize_verify_checksums.ksh
index 9be752ff83f2..2ccc57b475b7 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_initialize/zpool_initialize_verify_checksums.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_initialize/zpool_initialize_verify_checksums.ksh
@@ -42,7 +42,7 @@ DISK1=${DISKS%% *}
 
 log_must zpool create -f $TESTPOOL $DISK1
 log_must dd if=/dev/urandom of=/$TESTPOOL/file1 bs=1M count=30
-log_must sync
+sync_all_pools
 
 log_must zpool initialize $TESTPOOL
 
@@ -52,7 +52,7 @@ log_must zdb -cc $TESTPOOL
     log_fail "Initializing did not start"
 
 log_must dd if=/dev/urandom of=/$TESTPOOL/file2 bs=1M count=30
-log_must sync
+sync_all_pools
 
 log_must zdb -cc $TESTPOOL
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_labelclear/zpool_labelclear_removed.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_labelclear/zpool_labelclear_removed.ksh
index f93de6e22445..bd8917b3cd66 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_labelclear/zpool_labelclear_removed.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_labelclear/zpool_labelclear_removed.ksh
@@ -49,12 +49,12 @@ log_must truncate -s $SPA_MINDEVSIZE $DEVICE2 $DEVICE3 $DEVICE4 $DEVICE5
 
 log_must zpool create -f $TESTPOOL $DEVICE1 $DEVICE2 \
     log $DEVICE3 cache $DEVICE4 spare $DEVICE5
-log_must zpool sync
+sync_all_pools
 
 # Remove each type of vdev and verify the label can be cleared.
 for dev in $DEVICE5 $DEVICE4 $DEVICE3 $DEVICE2; do
 	log_must zpool remove $TESTPOOL $dev
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL true
 	log_must zpool labelclear $dev
 	log_mustnot zdb -lq $dev
 done
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_online/zpool_online_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_online/zpool_online_001_pos.ksh
index 7ba301e2b56b..8489fddb4109 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_online/zpool_online_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_online/zpool_online_001_pos.ksh
@@ -77,7 +77,7 @@ for disk in $DISKLIST; do
 	i=0
 	while [[ $i -lt ${#args[*]} ]]; do
 
-		log_must sync_pool $TESTPOOL
+		sync_pool $TESTPOOL
 		log_must zpool offline $TESTPOOL $disk
 		check_state $TESTPOOL $disk "offline"
 		if [[ $? != 0 ]]; then
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen.shlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen.shlib
index 075ad85e9f96..3d142fdf70ca 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen.shlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen.shlib
@@ -68,11 +68,11 @@ function wait_for_action #pool timeout function
 {
 	typeset pool=$1
 	typeset -i timeout=$2
-	typeset func=$3
+	typeset funct=$3
 
 	while [ $timeout -gt 0 ]; do
 		(( --timeout ))
-		if ( $func $pool ); then
+		if ( $funct $pool ); then
 			return 0
 		fi
 		sleep 1
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_001_pos.ksh
index 68ebf669c9f5..5a1b94db3dcb 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_001_pos.ksh
@@ -55,6 +55,7 @@ log_must zpool reopen
 log_must check_state $TESTPOOL "$REMOVED_DISK_ID" "unavail"
 # Write some data to the pool
 log_must generate_random_file /$TESTPOOL/data $SMALL_FILE_SIZE
+sync_pool $TESTPOOL
 # 4. "Plug back" disk.
 insert_disk $REMOVED_DISK $scsi_host
 # 5. Reopen a pool and verify if removed disk is marked online again.
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_002_pos.ksh
index 444c8a68523f..95f6f7dcbba4 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_002_pos.ksh
@@ -55,6 +55,7 @@ log_must zpool reopen $TESTPOOL
 log_must check_state $TESTPOOL "$REMOVED_DISK_ID" "unavail"
 # Write some data to the pool
 log_must generate_random_file /$TESTPOOL/data $SMALL_FILE_SIZE
+sync_pool $TESTPOOL
 # 4. "Plug back" disk.
 insert_disk $REMOVED_DISK $scsi_host
 # 5. Reopen a pool and verify if removed disk is marked online again.
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_003_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_003_pos.ksh
index 097dd3c71d1c..6ce054cdb4a1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_003_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_003_pos.ksh
@@ -64,6 +64,7 @@ log_must check_state $TESTPOOL "$REMOVED_DISK_ID" "unavail"
 # 3. Write a test file to the pool and calculate its checksum.
 TESTFILE=/$TESTPOOL/data
 log_must generate_random_file /$TESTPOOL/data $LARGE_FILE_SIZE
+sync_pool $TESTPOOL
 TESTFILE_MD5=$(md5digest $TESTFILE)
 
 # 4. Execute scrub.
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_004_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_004_pos.ksh
index 956ceebafbc6..3180eddc094d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_004_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_004_pos.ksh
@@ -62,6 +62,7 @@ log_must zpool reopen -n $TESTPOOL
 log_must check_state $TESTPOOL "$REMOVED_DISK_ID" "unavail"
 # 3. Write test file to pool.
 log_must generate_random_file /$TESTPOOL/data $LARGE_FILE_SIZE
+sync_pool $TESTPOOL
 # 4. Execute scrub.
 # add delay to I/O requests for remaining disk in pool
 log_must zinject -d $DISK2 -D125:1 $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_005_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_005_pos.ksh
index fc298d01061e..095f3bc05e66 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_005_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_reopen/zpool_reopen_005_pos.ksh
@@ -60,6 +60,7 @@ log_must zpool reopen $TESTPOOL
 log_must check_state $TESTPOOL "$REMOVED_DISK_ID" "unavail"
 # 3. Write test file to pool.
 log_must generate_random_file /$TESTPOOL/data $LARGE_FILE_SIZE
+sync_pool $TESTPOOL
 # 4. "Plug back" disk.
 insert_disk $REMOVED_DISK $scsi_host
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_resilver/zpool_resilver_restart.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_resilver/zpool_resilver_restart.ksh
index 80fc169126d2..e487afd8ae4d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_resilver/zpool_resilver_restart.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_resilver/zpool_resilver_restart.ksh
@@ -58,12 +58,12 @@ mntpnt=$(get_prop mountpoint $TESTPOOL/$TESTFS)
 
 # 1. Write some data and detach the first drive so it has resilver work to do
 log_must file_write -b 524288 -c 1024 -o create -d 0 -f $mntpnt/biggerfile1
-log_must sync
+sync_all_pools
 log_must zpool detach $TESTPOOL $DISK2
 
 # 2. Repeat the process with a second disk
 log_must file_write -b 524288 -c 1024 -o create -d 0 -f $mntpnt/biggerfile2
-log_must sync
+sync_all_pools
 log_must zpool detach $TESTPOOL $DISK3
 
 # 3. Reattach the drives, causing the second drive's resilver to be deferred
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_002_pos.ksh
index 449bb9a82277..116d622960f9 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_002_pos.ksh
@@ -61,7 +61,7 @@ log_assert "Verify scrub, scrub -p, and scrub -s show the right status."
 # Create 1G of additional data
 mntpnt=$(get_prop mountpoint $TESTPOOL/$TESTFS)
 log_must file_write -b 1048576 -c 1024 -o create -d 0 -f $mntpnt/biggerfile
-log_must sync
+sync_all_pools
 
 log_must set_tunable32 SCAN_SUSPEND_PROGRESS 1
 log_must zpool scrub $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_multiple_copies.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_multiple_copies.ksh
index 2dd33c99c554..1abef573883d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_multiple_copies.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_scrub/zpool_scrub_multiple_copies.ksh
@@ -50,7 +50,7 @@ log_assert "Scrubs and self healing must work with additional copies"
 log_must zfs create -o copies=3 $TESTPOOL/$TESTFS2
 typeset mntpnt=$(get_prop mountpoint $TESTPOOL/$TESTFS2)
 log_must mkfile 10m $mntpnt/file
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 log_must zinject -a -t data -C 0,1 -e io $mntpnt/file
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_split/zpool_split_resilver.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_split/zpool_split_resilver.ksh
index 99a40ecf2b74..b50963bbe2ad 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_split/zpool_split_resilver.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_split/zpool_split_resilver.ksh
@@ -66,7 +66,7 @@ function zpool_split #disk_to_be_offline/online
 	# Create 2G of additional data
 	mntpnt=$(get_prop mountpoint $TESTPOOL)
 	log_must file_write -b 2097152 -c 1024 -o create -d 0 -f $mntpnt/biggerfile
-	log_must sync
+	sync_all_pools
 
 	# temporarily prevent resilvering progress, so it will not finish too early
 	log_must set_tunable32 SCAN_SUSPEND_PROGRESS 1
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_partial.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_partial.ksh
index 5d14b74ecc15..f3b3b0f272a7 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_partial.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_partial.ksh
@@ -66,7 +66,7 @@ log_must mkdir "$TESTDIR"
 log_must truncate -s $LARGESIZE "$LARGEFILE"
 log_must zpool create $TESTPOOL "$LARGEFILE"
 log_must mkfile $(( floor(LARGESIZE * 0.80) )) /$TESTPOOL/file
-log_must zpool sync
+sync_all_pools
 
 new_size=$(du -B1 "$LARGEFILE" | cut -f1)
 log_must test $new_size -le $LARGESIZE
@@ -89,7 +89,7 @@ log_must set_tunable64 TRIM_METASLAB_SKIP 1
 log_must zpool trim $TESTPOOL
 log_must set_tunable64 TRIM_METASLAB_SKIP 0
 
-log_must zpool sync
+sync_all_pools
 while [[ "$(trim_progress $TESTPOOL $LARGEFILE)" -lt "100" ]]; do
 	sleep 0.5
 done
@@ -102,7 +102,7 @@ log_must test $new_size -gt $LARGESIZE
 # space usage of the new metaslabs.
 log_must zpool trim $TESTPOOL
 
-log_must zpool sync
+sync_all_pools
 while [[ "$(trim_progress $TESTPOOL $LARGEFILE)" -lt "100" ]]; do
 	sleep 0.5
 done
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_verify_checksums.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_verify_checksums.ksh
index 093dc3fb9e76..a12acce44a44 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_verify_checksums.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_trim/zpool_trim_verify_checksums.ksh
@@ -54,14 +54,14 @@ log_must truncate -s $LARGESIZE "$LARGEFILE"
 log_must zpool create $TESTPOOL "$LARGEFILE"
 
 log_must dd if=/dev/urandom of=/$TESTPOOL/file1 bs=1048576 count=64
-log_must zpool sync
+sync_all_pools
 log_must zpool trim $TESTPOOL
 
 [[ -z "$(trim_progress $TESTPOOL $DISK1)" ]] && \
     log_fail "Trimming did not start"
 
 log_must dd if=/dev/urandom of=/$TESTPOOL/file2 bs=1048576 count=64
-log_must zpool sync
+sync_all_pools
 
 log_must zpool export $TESTPOOL
 log_must zdb -e -p "$TESTDIR" -cc $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/scan/zpool_wait_replace_cancel.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/scan/zpool_wait_replace_cancel.ksh
index a899e9f99f14..f50b2d8e9a74 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/scan/zpool_wait_replace_cancel.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/scan/zpool_wait_replace_cancel.ksh
@@ -41,7 +41,7 @@ function cleanup
 	    log_must zpool detach $TESTPOOL $DISK2
 	get_disklist $TESTPOOL | grep $DISK3 >/dev/null && \
 	    log_must zpool detach $TESTPOOL $DISK3
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 }
 
 typeset pid
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/zpool_wait_freeing.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/zpool_wait_freeing.ksh
index 7f5a9e6a8d6c..73ec6a27bcc7 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/zpool_wait_freeing.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/cli_root/zpool_wait/zpool_wait_freeing.ksh
@@ -104,7 +104,7 @@ log_must zfs clone "$SNAP" "$CLONE"
 for i in {1..50}; do
 	log_must dd if=/dev/urandom of="/$CLONE/testfile$i" bs=1k count=512
 	# Force each new file to be tracked by a new livelist
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 done
 log_must zfs destroy "$CLONE"
 test_wait
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/ctime/ctime.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/ctime/ctime.c
index b755be2feb29..41dcf6abc9c2 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/ctime/ctime.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/ctime/ctime.c
@@ -303,9 +303,8 @@ static timetest_t timetest_table[] = {
 
 #define	NCOMMAND (sizeof (timetest_table) / sizeof (timetest_table[0]))
 
-/* ARGSUSED */
 int
-main(int argc, char *argv[])
+main(void)
 {
 	int i, ret, fd;
 	char *penv[] = {"TESTDIR", "TESTFILE0"};
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_sync.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_sync.ksh
index fd6e8c858edd..7b18ebdcb859 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_sync.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_sync.ksh
@@ -70,7 +70,7 @@ log_must file_write -b 1048576 -c 8 -o create -d 0 -f $mntpnt/file
 sleep 10
 
 log_must zinject -c all
-log_must zpool sync
+sync_all_pools
 
 # Log txg sync times for reference and the zpool event summary.
 if is_freebsd; then
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_zio.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_zio.ksh
index c1cfc1151239..f0774c4b29d9 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_zio.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/deadman/deadman_zio.ksh
@@ -83,7 +83,7 @@ log_must zinject -d $DISK1 -D10000:1 $TESTPOOL
 log_must eval "dd if=/$mntpnt/file1 of=/dev/null bs=1048576 &"
 sleep 10
 log_must zinject -c all
-log_must zpool sync
+sync_all_pools
 wait
 
 # 5. Verify a "deadman" event is posted.  The first appears after 5
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/delegate/delegate_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/delegate/delegate_common.kshlib
index e39b015b21b8..a78b390aa18e 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/delegate/delegate_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/delegate/delegate_common.kshlib
@@ -483,7 +483,7 @@ function verify_userprop
 	typeset stamp=${perm}.${user}.$RANDOM
 
 	user_run $user zfs set "$user:ts=$stamp" $dtst
-	zpool sync ${dtst%%/*}
+	sync_pool ${dtst%%/*}
 	if [[ $stamp != $(get_prop "$user:ts" $dtst) ]]; then
 		return 1
 	fi
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/events/events_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/events/events_common.kshlib
index 9c5879183b15..cc600c4ed510 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/events/events_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/events/events_common.kshlib
@@ -110,7 +110,7 @@ function run_and_verify
 	log_must eval "$fullcmd"
 
 	# Collect the new events and verify there are some.
-	log_must zpool sync -f
+	sync_all_pools true
 	log_must eval "zpool events >$TMP_EVENTS 2>/dev/null"
 	log_must eval "zpool events -v > $TMP_EVENTS_FULL 2>/dev/null"
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/auto_offline_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/auto_offline_001_pos.ksh
index 86916bf906fe..ef2ce24e097b 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/auto_offline_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/auto_offline_001_pos.ksh
@@ -102,7 +102,7 @@ do
 	# 2. Simulate physical removal of one device
 	remove_disk $removedev
 	log_must mkfile 1m $mntpnt/file
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 
 	# 3. Verify the device is unavailable.
 	log_must wait_vdev_state $TESTPOOL $removedev "UNAVAIL"
@@ -134,7 +134,7 @@ do
 	# 2. Simulate physical removal of one device
 	remove_disk $removedev
 	log_must mkfile 1m $mntpnt/file
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 
 	# 3. Verify the device is handled by the spare.
 	log_must wait_hotspare_state $TESTPOOL $sparedev "INUSE"
@@ -171,7 +171,7 @@ do
 	# 3. Simulate physical removal of one device
 	remove_disk $removedev
 	log_must mkfile 1m $mntpnt/file
-	log_must zpool sync $TESTPOOL
+	sync_pool $TESTPOOL
 
 	# 4. Verify the device is unavailable
 	log_must wait_vdev_state $TESTPOOL $removedev "UNAVAIL"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/decompress_fault.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/decompress_fault.ksh
index 81eab5666627..bcb7d8d1281c 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/decompress_fault.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/decompress_fault.ksh
@@ -45,7 +45,7 @@ log_must set_tunable64 COMPRESSED_ARC_ENABLED 0
 log_must zfs create -o compression=on $TESTPOOL/fs
 mntpt=$(get_prop mountpoint $TESTPOOL/fs)
 write_compressible $mntpt 32m 1 1024k "testfile"
-log_must sync
+sync_all_pools
 log_must zfs umount $TESTPOOL/fs
 log_must zfs mount $TESTPOOL/fs
 log_must zinject -a -t data -e decompress -f 20 $mntpt/testfile.0
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/zpool_status_-s.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/zpool_status_-s.ksh
index 85f0083a0eb6..a290053fd269 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/zpool_status_-s.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/fault/zpool_status_-s.ksh
@@ -64,7 +64,7 @@ log_must set_tunable64 SLOW_IO_EVENTS_PER_SECOND 1000
 # Create 20ms IOs
 log_must zinject -d $DISK -D20:100 $TESTPOOL
 log_must mkfile 1048576 /$TESTPOOL/testfile
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 log_must zinject -c all
 SLOW_IOS=$(zpool status -sp | grep "$DISK" | awk '{print $6}')
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/features/async_destroy/async_destroy_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/features/async_destroy/async_destroy_001_pos.ksh
index ad0e49f8fb40..e0617961ba15 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/features/async_destroy/async_destroy_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/features/async_destroy/async_destroy_001_pos.ksh
@@ -66,7 +66,7 @@ log_must dd bs=1024k count=128 if=/dev/zero of=/$TEST_FS/file
 #
 log_must set_tunable64 ASYNC_BLOCK_MAX_BLOCKS 100
 
-log_must sync
+sync_all_pools
 log_must zfs destroy $TEST_FS
 
 #
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/history/history_006_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/history/history_006_neg.ksh
index 19b7114faf5b..c3a5e092d02d 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/history/history_006_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/history/history_006_neg.ksh
@@ -75,7 +75,9 @@ if ! is_linux; then
 	log_must zfs share $fs
 	log_must zfs unshare $fs
 fi
-log_must zfs send -i $snap1 $snap2 > /dev/null
+# https://github.com/openzfs/zfs/issues/11445
+set -o pipefail
+log_must zfs send -i $snap1 $snap2 | cat > /dev/null
 log_must zfs holds $snap1
 
 log_must eval "zpool history $TESTPOOL > $NEW_HISTORY"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/hkdf/hkdf_test.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/hkdf/hkdf_test.c
index dd23da332c9a..5fff3e09ed04 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/hkdf/hkdf_test.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/hkdf/hkdf_test.c
@@ -211,7 +211,7 @@ run_test(int i, hkdf_tv_t *tv)
 }
 
 int
-main(int argc, char **argv)
+main(void)
 {
 	int ret, i;
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/libzfs/many_fds.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/libzfs/many_fds.c
index e09ed60eef9a..6def57c5a51a 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/libzfs/many_fds.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/libzfs/many_fds.c
@@ -35,9 +35,8 @@
 /*
  * Check if libzfs works with more than 255 held file handles.
  */
-/* ARGSUSED */
 int
-main(int argc, char **argv)
+main(void)
 {
 	int i;
 	struct rlimit limit;
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/log_spacemap/log_spacemap_import_logs.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/log_spacemap/log_spacemap_import_logs.ksh
index fca0e8e4a1b4..d1d283376bbb 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/log_spacemap/log_spacemap_import_logs.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/log_spacemap/log_spacemap_import_logs.ksh
@@ -63,9 +63,9 @@ log_must zpool create -o cachefile=none -f $LOGSM_POOL $TESTDISK
 log_must zfs create $LOGSM_POOL/fs
 
 log_must dd if=/dev/urandom of=/$LOGSM_POOL/fs/00 bs=128k count=10
-log_must sync
+sync_all_pools
 log_must dd if=/dev/urandom of=/$LOGSM_POOL/fs/00 bs=128k count=10
-log_must sync
+sync_all_pools
 
 log_must set_tunable64 KEEP_LOG_SPACEMAPS_AT_EXPORT 1
 log_must zpool export $LOGSM_POOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/mmp/mmp_reset_interval.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/mmp/mmp_reset_interval.ksh
index 6e3d1fe34d4b..6063c6a3796b 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/mmp/mmp_reset_interval.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/mmp/mmp_reset_interval.ksh
@@ -71,7 +71,7 @@ for fails in $(seq $MMP_FAIL_INTERVALS_MIN $((MMP_FAIL_INTERVALS_MIN*2))); do
 	for interval in $(seq $MMP_INTERVAL_MIN 200 $MMP_INTERVAL_DEFAULT); do
 		log_must set_tunable64 MULTIHOST_FAIL_INTERVALS $fails
 		log_must set_tunable64 MULTIHOST_INTERVAL $interval
-		log_must sync_pool $TESTPOOL
+		sync_pool $TESTPOOL
 		typeset mmp_fail=$(zdb $TESTPOOL 2>/dev/null |
 		    awk '/mmp_fail/ {print $NF}')
 		if [ $fails -ne $mmp_fail ]; then
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/no_space/enospc_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/no_space/enospc_002_pos.ksh
index db6ee6ba7ca5..081157cdc719 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/no_space/enospc_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/no_space/enospc_002_pos.ksh
@@ -49,14 +49,14 @@ log_must zfs snapshot $TESTPOOL/$TESTFS@snap
 #
 log_note "Writing files until ENOSPC."
 
-for i in $(seq 30); do
+for i in $(seq 100); do
 	file_write -o create -f $TESTDIR/file.$i -b $BLOCKSZ \
 	    -c $NUM_WRITES -d $DATA
 	ret=$?
 	(( $ret != $ENOSPC )) && \
 	    log_fail "file.$i returned: $ret rather than ENOSPC."
 
-	log_must zpool sync -f
+	sync_all_pools true
 done
 
 log_mustnot_expect space zfs create $TESTPOOL/$TESTFS/subfs
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_001_pos.ksh
index 2fd913f40338..5050447c000a 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_001_pos.ksh
@@ -90,7 +90,8 @@ for disk in $DISKLIST; do
 done
 
 log_must kill $killpid
-sync
+sync_all_pools
+log_must sync
 
 typeset dir=$(get_device_dir $DISKS)
 verify_filesys "$TESTPOOL" "$TESTPOOL/$TESTFS" "$dir"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_002_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_002_neg.ksh
index 19576a82100b..e66e7e10fedc 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_002_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_002_neg.ksh
@@ -129,7 +129,8 @@ while [[ $i -lt ${#disks[*]} ]]; do
 done
 
 log_must kill $killpid
-sync
+sync_all_pools
+log_must sync
 
 typeset dir=$(get_device_dir $DISKS)
 verify_filesys "$TESTPOOL" "$TESTPOOL/$TESTFS" "$dir"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_003_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_003_neg.ksh
index 0d763ee1b882..e33db28f8ddb 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_003_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/online_offline/online_offline_003_neg.ksh
@@ -76,6 +76,6 @@ for i in 0 1 2; do
 done
 
 log_must kill $killpid
-sync
+sync_all_pools
 
 log_pass
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_basic.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_basic.ksh
index dfc1f1ee0497..9104e4ba2ac3 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_basic.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_basic.ksh
@@ -65,7 +65,7 @@ log_must zfs create $FS
 for i in {1..20}; do
 	log_must zfs snapshot "$FS@testsnapshot$i"
 done
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 #
 # Read the debug message file in small chunks to make sure that the read is
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_concurrent_readers.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_concurrent_readers.ksh
index 1af1c2c07089..a24452ed5892 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_concurrent_readers.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_concurrent_readers.ksh
@@ -60,7 +60,7 @@ log_must zfs create $FS
 for i in {1..20}; do
 	log_must zfs snapshot "$FS@testsnapshot$i"
 done
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 
 msgs1=$(mktemp) || log_fail
 msgs2=$(mktemp) || log_fail
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_stale_read.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_stale_read.ksh
index 95a5e5c1ebc6..b3958b345d2a 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_stale_read.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/procfs/procfs_list_stale_read.ksh
@@ -50,7 +50,7 @@ function cleanup
 function sync_n
 {
 	for i in {1..$1}; do
-		log_must zpool sync $TESTPOOL
+		sync_pool $TESTPOOL
 	done
 	return 0
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_006_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_006_pos.ksh
index 6b375d407e23..73554df6a42a 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_006_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_006_pos.ksh
@@ -65,7 +65,7 @@ mkmount_writable $QFS
 log_must user_run $PUSER mkdir $PRJDIR
 log_must chattr +P -p $PRJID1 $PRJDIR
 log_must user_run $PUSER mkfile 100m $PRJDIR/qf
-sync
+sync_all_pools
 
 log_note "set projectquota at a smaller size than it current usage"
 log_must zfs set projectquota@$PRJID1=90m $QFS
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_common.kshlib
index 23f7c2a50663..0582164f9d6c 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectquota_common.kshlib
@@ -51,7 +51,7 @@ function cleanup_projectquota
 	[[ -d $PRJDIR1 ]] && log_must rm -rf $PRJDIR1
 	[[ -d $PRJDIR2 ]] && log_must rm -rf $PRJDIR2
 	[[ -d $PRJDIR3 ]] && log_must rm -rf $PRJDIR3
-	sync
+	sync_all_pools
 
 	return 0
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_001_pos.ksh
index b7707ea522c4..4005c2a408c6 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_001_pos.ksh
@@ -70,7 +70,7 @@ mkmount_writable $QFS
 log_must user_run $PUSER mkdir $PRJDIR
 log_must chattr +P -p $PRJID1 $PRJDIR
 log_must user_run $PUSER mkfile 50m $PRJDIR/qf
-sync
+sync_all_pools
 
 log_must zfs snapshot $snap_fs
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_002_pos.ksh
index 10edae771e99..1d48eccf22d0 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/projectquota/projectspace_002_pos.ksh
@@ -63,7 +63,7 @@ mkmount_writable $QFS
 log_must user_run $PUSER mkdir $PRJDIR
 log_must chattr +P -p $PRJID1 $PRJDIR
 log_must user_run $PUSER mkfile 50m $PRJDIR/qf
-sync
+sync_all_pools
 
 typeset snapfs=$QFS@snap
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/pyzfs/pyzfs_unittest.ksh.in b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/pyzfs/pyzfs_unittest.ksh.in
index 4ca610e5f1e9..1f58d8116b68 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/pyzfs/pyzfs_unittest.ksh.in
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/pyzfs/pyzfs_unittest.ksh.in
@@ -30,7 +30,7 @@ verify_runnable "global"
 # Verify that the required dependencies for testing are installed.
 @PYTHON@ -c "import cffi" 2>/dev/null
 if [ $? -eq 1 ]; then
-	log_unsupported "python-cffi not found by Python"
+	log_unsupported "python3-cffi not found by Python"
 fi
 
 # We don't just try to "import libzfs_core" because we want to skip these tests
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refquota/refquota_007_neg.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refquota/refquota_007_neg.ksh
index 4f0393883b6a..484203549a96 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refquota/refquota_007_neg.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refquota/refquota_007_neg.ksh
@@ -53,7 +53,7 @@ log_must mkfile 20M $mntpnt/$TESTFILE
 log_must zfs snapshot $FS@snap20M
 log_must rm $mntpnt/$TESTFILE
 
-log_must sync
+sync_all_pools
 
 log_must zfs set refquota=10M $FS
 log_mustnot zfs rollback $FS@snap20M
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refreserv/refreserv_raidz.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refreserv/refreserv_raidz.ksh
index 22891ef1d513..056c7916d990 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refreserv/refreserv_raidz.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/refreserv/refreserv_raidz.ksh
@@ -110,7 +110,7 @@ for parity in 1 2 3; do
 			block_device_wait "/dev/zvol/$vol"
 			log_must dd if=/dev/zero of=/dev/zvol/$vol \
 			    bs=1024k count=$volsize
-			sync
+			sync_pool $TESTPOOL
 
 			ref=$(zfs get -Hpo value referenced "$vol")
 			refres=$(zfs get -Hpo value refreservation "$vol")
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/removal.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/removal.kshlib
index 140ac38ad898..5752575a8bb1 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/removal.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/removal.kshlib
@@ -69,7 +69,7 @@ function attempt_during_removal # pool disk callback [args]
 	# We want to make sure that the removal started
 	# before issuing the callback.
 	#
-	sync
+	sync_pool $pool
 	log_must is_pool_removing $pool
 
 	log_must $callback "$@"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/remove_expanded.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/remove_expanded.ksh
index e7e63b705575..5ee55e9a9d3e 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/remove_expanded.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/removal/remove_expanded.ksh
@@ -79,7 +79,7 @@ log_must wait_for_removal $TESTPOOL
 # Run sync once to ensure that the config actually changed.
 #
 log_must zpool add $TESTPOOL $DISK2
-log_must sync
+sync_all_pools
 
 #
 # Ensure that zdb does not find any problems with this.
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/rebuild_multiple.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/rebuild_multiple.ksh
index 7775cbff4db8..2cb971a1caf1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/rebuild_multiple.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/rebuild_multiple.ksh
@@ -73,7 +73,7 @@ log_must zfs create $TESTPOOL1/$TESTFS
 
 mntpnt=$(get_prop mountpoint $TESTPOOL1/$TESTFS)
 log_must dd if=/dev/urandom of=$mntpnt/file bs=1M count=32
-log_must zpool sync $TESTPOOL1
+sync_pool $TESTPOOL1
 
 log_must set_tunable32 SCAN_SUSPEND_PROGRESS 1
 
@@ -99,7 +99,7 @@ log_must zfs create $TESTPOOL1/$TESTFS
 
 mntpnt=$(get_prop mountpoint $TESTPOOL1/$TESTFS)
 log_must dd if=/dev/urandom of=$mntpnt/file bs=1M count=32
-log_must zpool sync $TESTPOOL1
+sync_pool $TESTPOOL1
 
 log_must set_tunable32 SCAN_SUSPEND_PROGRESS 1
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_001.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_001.ksh
index 7e96ab518773..269d31bf8905 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_001.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_001.ksh
@@ -153,9 +153,9 @@ do
 	# offline then online a vdev to introduce a new DTL range after current
 	# scan, which should restart (or defer) the resilver
 	log_must zpool offline $TESTPOOL1 ${VDEV_FILES[2]}
-	log_must zpool sync $TESTPOOL1
+	sync_pool $TESTPOOL1
 	log_must zpool online $TESTPOOL1 ${VDEV_FILES[2]}
-	log_must zpool sync $TESTPOOL1
+	sync_pool $TESTPOOL1
 
 	# there should now be 2 resilver starts w/o defer, 1 with defer
 	verify_restarts ' after offline/online' "${RESTARTS[1]}" "${VDEVS[1]}"
@@ -177,8 +177,8 @@ do
 	log_must is_pool_resilvered $TESTPOOL1
 
 	# wait for a few txg's to see if a resilver happens
-	log_must zpool sync $TESTPOOL1
-	log_must zpool sync $TESTPOOL1
+	sync_pool $TESTPOOL1
+	sync_pool $TESTPOOL1
 
 	# there should now be 2 resilver starts
 	verify_restarts ' after resilver' "${RESTARTS[3]}" "${VDEVS[3]}"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_002.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_002.ksh
index 48763f9b2dfa..4f2707693d13 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_002.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/resilver_restart_002.ksh
@@ -73,7 +73,7 @@ log_must zpool attach $TESTPOOL1 ${VDEV_FILES[0]} $SPARE_VDEV_FILE
 log_note "waiting for read errors to start showing up"
 for iter in {0..59}
 do
-	zpool sync $TESTPOOL1
+	sync_pool $TESTPOOL1
 	err=$(zpool status $TESTPOOL1 | grep ${VDEV_FILES[0]} | awk '{print $3}')
 	(( $err > 0 )) && break
 	sleep 1
@@ -92,8 +92,8 @@ done
 (( $finish == 0 )) && log_fail "resilver took too long to finish"
 
 # wait a few syncs to ensure that zfs does not restart the resilver
-log_must zpool sync $TESTPOOL1
-log_must zpool sync $TESTPOOL1
+sync_pool $TESTPOOL1
+sync_pool $TESTPOOL1
 
 # check if resilver was restarted
 start=$(zpool events | grep "sysevent.fs.zfs.resilver_start" | wc -l)
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/scrub_cancel.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/scrub_cancel.ksh
index da8a0a26e333..a1b48680c202 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/scrub_cancel.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/replacement/scrub_cancel.ksh
@@ -60,7 +60,7 @@ log_must zfs create $TESTPOOL1/$TESTFS
 
 mntpnt=$(get_prop mountpoint $TESTPOOL1/$TESTFS)
 log_must dd if=/dev/urandom of=$mntpnt/file bs=1M count=64
-log_must zpool sync $TESTPOOL1
+sync_pool $TESTPOOL1
 
 # Request a healing or sequential resilver
 for replace_mode in "healing" "sequential"; do
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/rsend.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/rsend.kshlib
index d06bd39b4d49..516d41263294 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/rsend.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/rsend.kshlib
@@ -121,6 +121,14 @@ function cleanup_pool
 	log_must rm -rf $BACKDIR/*
 
 	if is_global_zone ; then
+		#
+		# Linux: Issuing a `df` seems to properly force any negative
+		# dcache entries to be invalidated preventing failures when
+		# accessing the mount point. Additional investigation required.
+		#
+		# https://github.com/openzfs/zfs/issues/6143
+		#
+		log_must df >/dev/null
 		log_must_busy zfs destroy -Rf $pool
 	else
 		typeset list=$(zfs list -H -r -t all -o name $pool)
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-c_verify_ratio.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-c_verify_ratio.ksh
index b7d978624f2b..845349a95873 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-c_verify_ratio.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-c_verify_ratio.ksh
@@ -36,7 +36,7 @@ log_assert "Verify send -c streams are compressed"
 log_onexit cleanup_pool $POOL2
 
 typeset sendfs=$POOL2/$FS
-typeset megs=128
+typeset megs=64
 
 for prop in "${compress_prop_vals[@]}"; do
 	for compressible in 'yes' 'no'; do
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-wR_encrypted_zvol.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-wR_encrypted_zvol.ksh
index b95fc3da30c3..64ee6293c7a4 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-wR_encrypted_zvol.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send-wR_encrypted_zvol.ksh
@@ -88,7 +88,7 @@ for ((i = 1; i <= $snap_count; i++)); do
 		log_must cp $mntpnt/file $mntpnt/file$j
 	done
 
-	log_must sync
+	sync_all_pools
 	log_must mount $remount_ro $zdev $mntpnt
 	log_must zfs snap $TESTPOOL/$TESTVOL@snap$i
 	log_must mount $remount_rw $zdev $mntpnt
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_files.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_files.ksh
index 370f5382ebae..0212bd144fb8 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_files.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_files.ksh
@@ -87,7 +87,7 @@ log_must xattrtest -f 10 -x 3 -s 32768 -r -k -p /$TESTPOOL/$TESTFS2/xattrsadir
 # OpenZFS issue #7432
 log_must zfs set compression=on xattr=sa $TESTPOOL/$TESTFS2
 log_must touch /$TESTPOOL/$TESTFS2/attrs
-log_must eval "python -c 'print \"a\" * 4096' | \
+log_must eval "python3 -c 'print \"a\" * 4096' | \
 	set_xattr_stdin bigval /$TESTPOOL/$TESTFS2/attrs"
 log_must zfs set compression=off xattr=on $TESTPOOL/$TESTFS2
 
@@ -97,7 +97,7 @@ log_must zfs snapshot $TESTPOOL/$TESTFS2@snap1
 for i in {1..1000}; do
 	log_must rm /$TESTPOOL/$TESTFS2/dir/file-$i
 done
-sync
+sync_all_pools
 
 log_must zfs snapshot $TESTPOOL/$TESTFS2@snap2
 expected_cksum=$(recursive_cksum /$TESTPOOL/$TESTFS2)
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_truncated_files.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_truncated_files.ksh
index 5760bf9b902a..aa19847e0695 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_truncated_files.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_encrypted_truncated_files.ksh
@@ -100,7 +100,7 @@ log_must truncate -s 131072 /$TESTPOOL/$TESTFS2/truncated
 log_must truncate -s 393216 /$TESTPOOL/$TESTFS2/truncated2
 log_must rm -f /$TESTPOOL/$TESTFS2/truncated3
 log_must rm -f /$TESTPOOL/$TESTFS2/truncated4
-log_must zpool sync $TESTPOOL
+sync_pool $TESTPOOL
 log_must zfs umount $TESTPOOL/$TESTFS2
 log_must zfs mount $TESTPOOL/$TESTFS2
 log_must dd if=/dev/urandom of=/$TESTPOOL/$TESTFS2/truncated3 \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_dnode_size.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_dnode_size.ksh
index 551ed15db254..bd30488eaab0 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_dnode_size.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_dnode_size.ksh
@@ -88,7 +88,7 @@ log_must zfs snapshot $POOL/fs@c
 # 4. Create an empty file and add xattrs to it to exercise reclaiming a
 #    dnode that requires more than 1 slot for its bonus buffer (Zol #7433)
 log_must zfs set compression=on xattr=sa $POOL/fs
-log_must eval "python -c 'print \"a\" * 512' |
+log_must eval "python3 -c 'print \"a\" * 512' |
     set_xattr_stdin bigval /$POOL/fs/attrs"
 log_must zfs snapshot $POOL/fs@d
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_encrypted_files.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_encrypted_files.ksh
index a653f8b3f15e..361f6b375ea1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_encrypted_files.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_encrypted_files.ksh
@@ -72,12 +72,8 @@ if is_kmemleak; then
 	# to avoid timeout due to reduced performance.
 	nr_files=100
 	passes=2
-elif is_freebsd; then
-	# Use fewer files and passes on FreeBSD to avoid timeout.
-	nr_files=500
-	passes=2
 else
-	nr_files=1000
+	nr_files=300
 	passes=3
 fi
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_files.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_files.ksh
index 083a2bec9daa..187a899a23c6 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_files.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/rsend/send_realloc_files.ksh
@@ -64,12 +64,8 @@ if is_kmemleak; then
 	# to avoid timeout due to reduced performance.
 	nr_files=100
 	passes=2
-elif is_freebsd; then
-	# Use fewer passes and files on FreeBSD to avoid timeout.
-	nr_files=500
-	passes=2
 else
-	nr_files=1000
+	nr_files=300
 	passes=3
 fi
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_014_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_014_pos.ksh
index f8530a623d47..dbdf1f1ce527 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_014_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_014_pos.ksh
@@ -58,7 +58,7 @@ for type in "mirror" "raidz" "raidz2"; do
                 # Ensure the file has been synced out before attempting to
                 # corrupt its contents.
                 #
-                sync
+                sync_all_pools
 
 		#
 		# Corrupt a pool device to make the pool DEGRADED
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_replay_volume.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_replay_volume.ksh
index d39c6ded557a..35cb4b696965 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_replay_volume.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/slog/slog_replay_volume.ksh
@@ -102,7 +102,7 @@ else
 	log_must mount $VOLUME $MNTPNT
 	FSTYPE=$NEWFS_DEFAULT_FS
 fi
-log_must zpool sync
+sync_all_pools
 
 #
 # 2. Freeze TESTVOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_001_pos.ksh
index 8894c3a65287..97194f4fe4a0 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_001_pos.ksh
@@ -93,6 +93,7 @@ while [[ $i -le $COUNT ]]; do
 
         (( i = i + 1 ))
 done
+sync_pool $TESTPOOL
 
 #
 # Now rollback to latest snapshot
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_003_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_003_pos.ksh
index 59e7c110ddd7..766de990ecdb 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_003_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/snapshot/rollback_003_pos.ksh
@@ -82,6 +82,7 @@ log_must zfs rollback $SNAPPOOL
 log_mustnot zfs snapshot $SNAPPOOL
 
 log_must touch /$TESTPOOL/$TESTFILE
+sync_pool $TESTPOOL
 
 log_must zfs rollback $SNAPPOOL
 log_must zfs create $TESTPOOL/$TESTFILE
@@ -92,6 +93,15 @@ log_note "Verify rollback of multiple nested file systems succeeds."
 log_must zfs snapshot $TESTPOOL/$TESTFILE@$TESTSNAP
 log_must zfs snapshot $SNAPPOOL.1
 
+#
+# Linux: Issuing a `df` seems to properly force any negative dcache entries to
+# be invalidated preventing failures when accessing the mount point. Additional
+# investigation required.
+#
+# https://github.com/openzfs/zfs/issues/6143
+#
+log_must df >/dev/null
+
 export __ZFS_POOL_RESTRICT="$TESTPOOL"
 log_must zfs unmount -a
 log_must zfs mount -a
@@ -100,12 +110,6 @@ unset __ZFS_POOL_RESTRICT
 log_must touch /$TESTPOOL/$TESTFILE/$TESTFILE.1
 
 log_must zfs rollback $SNAPPOOL.1
-
-#
-# Workaround for issue #6143.  Issuing a `df` seems to properly force any
-# negative dcache entries to be invalidated preventing subsequent failures
-# when accessing the mount point.  Additional investigation required.
-#
-log_must df
+log_must df >/dev/null
 
 log_pass "Rollbacks succeed when nested file systems are present."
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/Makefile.am b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/Makefile.am
new file mode 100644
index 000000000000..1a861a655cb1
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/Makefile.am
@@ -0,0 +1,8 @@
+include $(top_srcdir)/config/Rules.am
+
+pkgdatadir = $(datadir)/@PACKAGE@/zfs-tests/tests/functional/stat
+
+dist_pkgdata_SCRIPTS = \
+	cleanup.ksh \
+	setup.ksh \
+	stat_001_pos.ksh
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/cleanup.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/cleanup.ksh
new file mode 100755
index 000000000000..3166bd6ec16e
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/cleanup.ksh
@@ -0,0 +1,34 @@
+#!/bin/ksh -p
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+#
+# Copyright (c) 2013 by Delphix. All rights reserved.
+#
+
+. $STF_SUITE/include/libtest.shlib
+
+default_cleanup
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/setup.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/setup.ksh
new file mode 100755
index 000000000000..4fc55cd47803
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/setup.ksh
@@ -0,0 +1,36 @@
+#!/bin/ksh -p
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+# Use is subject to license terms.
+#
+
+#
+# Copyright (c) 2013 by Delphix. All rights reserved.
+#
+
+. $STF_SUITE/include/libtest.shlib
+
+DISK=${DISKS%% *}
+
+default_setup ${DISK}
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/stat_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/stat_001_pos.ksh
new file mode 100755
index 000000000000..e6f9775f4b8e
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/stat/stat_001_pos.ksh
@@ -0,0 +1,57 @@
+#! /bin/ksh -p
+#
+# CDDL HEADER START
+#
+# The contents of this file are subject to the terms of the
+# Common Development and Distribution License (the "License").
+# You may not use this file except in compliance with the License.
+#
+# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+# or http://www.opensolaris.org/os/licensing.
+# See the License for the specific language governing permissions
+# and limitations under the License.
+#
+# When distributing Covered Code, include this CDDL HEADER in each
+# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+# If applicable, add the following below this CDDL HEADER, with the
+# fields enclosed by brackets "[]" replaced with your own identifying
+# information: Portions Copyright [yyyy] [name of copyright owner]
+#
+# CDDL HEADER END
+#
+
+#
+# Copyright 2021 iXsystems, Inc.
+#
+
+. $STF_SUITE/include/libtest.shlib
+
+#
+# DESCRIPTION:
+#
+# Ensure znode generation number is accessible.
+#
+# STRATEGY:
+#	1) Create a file
+#	2) Verify that the znode generation number can be obtained
+#	3) Verify that the znode generation number is not empty
+#
+
+verify_runnable "both"
+
+function cleanup
+{
+	rm -f ${TESTFILE}
+}
+
+log_onexit cleanup
+
+log_assert "Ensure znode generation number is accessible."
+
+TESTFILE=${TESTDIR}/${TESTFILE0}
+
+log_must touch ${TESTFILE}
+log_must stat_generation ${TESTFILE}
+log_must test $(stat_generation ${TESTFILE}) -ne 0
+
+log_pass "Successfully obtained file znode generation number."
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_001_pos.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_001_pos.c
index b0c236081928..d40da0d2ba62 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_001_pos.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_001_pos.c
@@ -31,15 +31,13 @@
 static void
 fill_random(char *buf, int len)
 {
-	int i;
 	srand(time(NULL));
-	for (i = 0; i < len; i++) {
+	for (int i = 0; i < len; i++)
 		buf[i] = (char)rand();
-	}
 }
 
 int
-main(int argc, char *argv[])
+main(void)
 {
 	int i, fd;
 	char buf1[BSZ], buf2[BSZ] = {};
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_002_pos.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_002_pos.c
index c92e6127d6a3..55d939abd23b 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_002_pos.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_002_pos.c
@@ -25,7 +25,7 @@
  */
 
 int
-main(int argc, char *argv[])
+main(void)
 {
 	int i, fd, ret;
 	char spath[1024], dpath[1024];
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_003_pos.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_003_pos.c
index 477ef3f81948..58aa9051215e 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_003_pos.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_003_pos.c
@@ -24,7 +24,7 @@
  */
 
 int
-main(int argc, char *argv[])
+main(void)
 {
 	int i, fd;
 	char spath[1024], dpath[1024];
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_stat_mode.c b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_stat_mode.c
index bf71d429c3fd..c72ea2bb6ad7 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_stat_mode.c
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/tmpfile/tmpfile_stat_mode.c
@@ -110,7 +110,7 @@ test_stat_mode(mode_t mask)
 }
 
 int
-main(int argc, char *argv[])
+main(void)
 {
 	fprintf(stdout, "Verify stat(2) for O_TMPFILE file considers umask.\n");
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_integrity.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_integrity.ksh
index 78fe18fa6946..e25390339b6c 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_integrity.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_integrity.ksh
@@ -73,7 +73,7 @@ for type in "" "mirror" "raidz" "draid"; do
 		filesize=$((4096 + ((RANDOM * 691) % 131072) ))
 		log_must rm -rf $dir
 		log_must fill_fs $dir 10 10 $filesize 1 R
-		zpool sync
+		sync_all_pools
 	done
 	log_must du -hs /$TESTPOOL
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_trim_integrity.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_trim_integrity.ksh
index 13c9b95e0661..ae7ad8d73dd8 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_trim_integrity.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/autotrim_trim_integrity.ksh
@@ -74,7 +74,7 @@ for type in "" "mirror" "raidz" "raidz2" "draid" "draid2"; do
 		filesize=$((4096 + ((RANDOM * 691) % 131072) ))
 		log_must rm -rf $dir
 		log_must fill_fs $dir 10 10 $filesize 1 R
-		zpool sync
+		sync_all_pools
 
 		if [[ $((n % 4)) -eq 0 ]]; then
 			log_must timeout 120 zpool trim -w $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim.kshlib
index bede946a09c5..dc1a60a5ee9d 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim.kshlib
@@ -91,7 +91,7 @@ function wait_trim_io # pool type txgs
 			return
 		fi
 
-		zpool sync -f
+		sync_all_pools true
 		((i = i + 1))
 	done
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim_integrity.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim_integrity.ksh
index 38f226d7f8e7..2dff0924f7b1 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim_integrity.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/trim/trim_integrity.ksh
@@ -72,7 +72,7 @@ for type in "" "mirror" "raidz" "draid"; do
 		filesize=$((4096 + ((RANDOM * 691) % 131072) ))
 		log_must rm -rf $dir
 		log_must fill_fs $dir 10 10 $filesize 1 R
-		zpool sync
+		sync_all_pools
 	done
 	log_must du -hs /$TESTPOOL
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/truncate/truncate_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/truncate/truncate_002_pos.ksh
index 2a4996a1d926..cff740e5fbba 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/truncate/truncate_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/truncate/truncate_002_pos.ksh
@@ -58,7 +58,7 @@ log_must dd if=/dev/urandom of=$srcfile bs=1024k count=1
 log_onexit cleanup
 log_must cp $srcfile $TESTDIR/$TESTFILE
 log_must cp /dev/null $TESTDIR/$TESTFILE
-log_must sync
+sync_all_pools
 if [[ -s $TESTDIR/$TESTFILE ]]; then
 	log_note "$(ls -l $TESTDIR/$TESTFILE)"
 	log_fail "testfile not truncated"
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/Makefile.am b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/Makefile.am
index 9100e4adadca..2c94d3e1521c 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/Makefile.am
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/Makefile.am
@@ -21,7 +21,8 @@ dist_pkgdata_SCRIPTS = \
 	userspace_001_pos.ksh \
 	userspace_002_pos.ksh \
 	userspace_003_pos.ksh \
-	userspace_encrypted.ksh
+	userspace_encrypted.ksh \
+	userspace_send_encrypted.ksh
 
 dist_pkgdata_DATA = \
 	userquota.cfg \
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_001_pos.ksh
index 762f561b834f..b2c48a6424c4 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_001_pos.ksh
@@ -65,7 +65,7 @@ log_must zfs set groupquota@$QGROUP=500m $QFS
 mkmount_writable $QFS
 log_must user_run $QUSER1 mkfile 50m $QFILE
 
-sync
+sync_all_pools
 
 log_must zfs snapshot $snap_fs
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_002_pos.ksh
index 27feafa2b6a2..3e9262831229 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_002_pos.ksh
@@ -57,7 +57,7 @@ log_must zfs set groupquota@$QGROUP=500m $QFS
 mkmount_writable $QFS
 log_must user_run $QUSER1 mkfile 100m $QFILE
 
-sync
+sync_all_pools
 
 typeset snapfs=$QFS@snap
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_003_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_003_pos.ksh
index 37fd389377ec..6d7f5bad3f35 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_003_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/groupspace_003_pos.ksh
@@ -78,7 +78,7 @@ log_must zfs set xattr=sa $QFS
 log_must user_run $QUSER1 mkfiles ${QFILE}_1 $user1_cnt
 log_must user_run $QUSER2 mkfiles ${QFILE}_2 $user2_cnt
 ((grp_cnt = user1_cnt + user2_cnt))
-sync_pool
+sync_all_pools
 
 typeset snapfs=$QFS@snap
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_007_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_007_pos.ksh
index 1dea4006618c..61cfb4661567 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_007_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_007_pos.ksh
@@ -63,7 +63,7 @@ log_must zfs get groupquota@$QGROUP $QFS
 log_note "write some data to the $QFS"
 mkmount_writable $QFS
 log_must user_run $QUSER1 mkfile 100m $QFILE
-sync
+sync_all_pools
 
 log_note "set user|group quota at a smaller size than it current usage"
 log_must zfs set userquota@$QUSER1=90m $QFS
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_common.kshlib b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_common.kshlib
index 70b935d7fe19..cee3c6fb3269 100644
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_common.kshlib
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userquota_common.kshlib
@@ -48,7 +48,7 @@ function cleanup_quota
 
 	[[ -f $QFILE ]] && log_must rm -f $QFILE
 	[[ -f $OFILE ]] && log_must rm -f $OFILE
-	sync
+	sync_all_pools
 
 	return 0
 }
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_001_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_001_pos.ksh
index 9b8919344582..137dd68662cc 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_001_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_001_pos.ksh
@@ -64,7 +64,7 @@ typeset snap_fs=$QFS@snap
 log_must zfs set userquota@$QUSER1=100m $QFS
 mkmount_writable $QFS
 log_must user_run $QUSER1 mkfile 50m $QFILE
-sync
+sync_all_pools
 
 log_must zfs snapshot $snap_fs
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_002_pos.ksh
index 94593ed21ae1..0821bd075f60 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_002_pos.ksh
@@ -59,7 +59,7 @@ log_must zfs set userquota@$QUSER1=100m $QFS
 mkmount_writable $QFS
 
 log_must user_run $QUSER1 mkfile 50m $QFILE
-sync
+sync_all_pools
 
 typeset snapfs=$QFS@snap
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_003_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_003_pos.ksh
index 70ef78e7ddbb..de7c117af3ab 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_003_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_003_pos.ksh
@@ -79,7 +79,7 @@ log_must zfs set xattr=sa $QFS
 
 log_must user_run $QUSER1 mkfiles ${QFILE}_1 $user1_cnt
 log_must user_run $QUSER2 mkfiles ${QFILE}_2 $user2_cnt
-sync_pool
+sync_all_pools
 
 typeset snapfs=$QFS@snap
 
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_send_encrypted.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_send_encrypted.ksh
new file mode 100755
index 000000000000..e9ef0c4262e7
--- /dev/null
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/userquota/userspace_send_encrypted.ksh
@@ -0,0 +1,119 @@
+#!/bin/ksh -p
+#
+# This file and its contents are supplied under the terms of the
+# Common Development and Distribution License ("CDDL"), version 1.0.
+# You may only use this file in accordance with the terms of version
+# 1.0 of the CDDL.
+#
+# A full copy of the text of the CDDL should have accompanied this
+# source.  A copy of the CDDL is also available via the Internet at
+# http://www.illumos.org/license/CDDL.
+#
+
+#
+# Copyright 2021, George Amanakis <gamanakis@gmail.com>. All rights reserved.
+#
+
+. $STF_SUITE/include/libtest.shlib
+. $STF_SUITE/tests/functional/userquota/userquota_common.kshlib
+
+#
+# DESCRIPTION:
+# Sending raw encrypted datasets back to the source dataset succeeds.
+#
+#
+# STRATEGY:
+# 1. Create encrypted source dataset, set userquota and write a file
+# 2. Create base snapshot
+# 3. Write new file, snapshot, get userspace
+# 4. Raw send both snapshots
+# 5. Destroy latest snapshot at source and rollback
+# 6. Unmount, unload key from source
+# 7. Raw send latest snapshot back to source
+# 8. Mount both source and target datasets
+# 9. Verify encrypted datasets support 'zfs userspace' and 'zfs groupspace'
+#	and the accounting is done correctly
+#
+
+function cleanup
+{
+	destroy_pool $POOLNAME
+	rm -f $FILEDEV
+}
+
+log_onexit cleanup
+
+FILEDEV="$TEST_BASE_DIR/userspace_encrypted"
+POOLNAME="testpool$$"
+ENC_SOURCE="$POOLNAME/source"
+ENC_TARGET="$POOLNAME/target"
+
+log_assert "Sending raw encrypted datasets back to the source dataset succeeds."
+
+# Setup pool and create source
+truncate -s 200m $FILEDEV
+log_must zpool create -o feature@encryption=enabled $POOLNAME \
+	$FILEDEV
+log_must eval "echo 'password' | zfs create -o encryption=on" \
+	"-o keyformat=passphrase -o keylocation=prompt " \
+	"$ENC_SOURCE"
+
+# Set user quota and write file
+log_must zfs set userquota@$QUSER1=50m $ENC_SOURCE
+mkmount_writable $ENC_SOURCE
+mntpnt=$(get_prop mountpoint $ENC_SOURCE)
+log_must user_run $QUSER1 mkfile 10m /$mntpnt/file1
+sync
+
+# Snapshot
+log_must zfs snap $ENC_SOURCE@base
+
+# Write new file, snapshot, get userspace
+log_must user_run $QUSER1 mkfile 20m /$mntpnt/file2
+log_must zfs snap $ENC_SOURCE@s1
+
+# Raw send both snapshots
+log_must eval "zfs send -w $ENC_SOURCE@base | zfs recv " \
+	"$ENC_TARGET"
+log_must eval "zfs send -w -i @base $ENC_SOURCE@s1 | zfs recv " \
+	"$ENC_TARGET"
+
+# Destroy latest snapshot at source and rollback
+log_must zfs destroy $ENC_SOURCE@s1
+log_must zfs rollback $ENC_SOURCE@base
+rollback_uspace=$(zfs userspace -Hp $ENC_SOURCE | \
+	awk "/$QUSER1/"' {printf "%d\n", $4 / 1024 / 1024}')
+
+# Unmount, unload key
+log_must zfs umount $ENC_SOURCE
+log_must zfs unload-key -a
+
+# Raw send latest snapshot back to source
+log_must eval "zfs send -w -i @base $ENC_TARGET@s1 | zfs recv " \
+	"$ENC_SOURCE"
+
+#  Mount encrypted datasets and verify they support 'zfs userspace' and
+# 'zfs groupspace' and the accounting is done correctly
+log_must eval "echo 'password' | zfs load-key $ENC_SOURCE"
+log_must eval "echo 'password' | zfs load-key $ENC_TARGET"
+log_must zfs mount $ENC_SOURCE
+log_must zfs mount $ENC_TARGET
+sync
+
+sleep 5
+
+src_uspace=$(zfs userspace -Hp $ENC_SOURCE | \
+	awk "/$QUSER1/"' {printf "%d\n", $4 / 1024 / 1024}')
+tgt_uspace=$(zfs userspace -Hp $ENC_TARGET | \
+	awk "/$QUSER1/"' {printf "%d\n", $4 / 1024 / 1024}')
+log_must test "$src_uspace" -eq "$tgt_uspace"
+log_must test "$rollback_uspace" -ne "$src_uspace"
+
+src_uquota=$(zfs userspace -Hp $ENC_SOURCE | awk "/$QUSER1/"' {print $5}')
+tgt_uquota=$(zfs userspace -Hp $ENC_TARGET | awk "/$QUSER1/"' {print $5}')
+log_must test "$src_uquota" -eq "$tgt_uquota"
+
+# Cleanup
+cleanup
+
+log_pass "Sending raw encrypted datasets back to the source dataset succeeds."
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/vdev_zaps/vdev_zaps_005_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/vdev_zaps/vdev_zaps_005_pos.ksh
index 066be917e436..7a40d8f0c565 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/vdev_zaps/vdev_zaps_005_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/vdev_zaps/vdev_zaps_005_pos.ksh
@@ -41,7 +41,7 @@ orig_top=$(get_top_vd_zap $DISK $conf)
 orig_leaf=$(get_leaf_vd_zap $DISK $conf)
 assert_zap_common $TESTPOOL $DISK "top" $orig_top
 assert_zap_common $TESTPOOL $DISK "leaf" $orig_leaf
-log_must zpool sync
+sync_all_pools
 
 # Export the pool.
 log_must zpool export $TESTPOOL
diff --git a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/zvol/zvol_misc/zvol_misc_002_pos.ksh b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/zvol/zvol_misc/zvol_misc_002_pos.ksh
index 2ecb00da92e1..297ad242fe25 100755
--- a/sys/contrib/openzfs/tests/zfs-tests/tests/functional/zvol/zvol_misc/zvol_misc_002_pos.ksh
+++ b/sys/contrib/openzfs/tests/zfs-tests/tests/functional/zvol/zvol_misc/zvol_misc_002_pos.ksh
@@ -84,7 +84,7 @@ while (( 1 )); do
 done
 
 if is_linux || is_freebsd ; then
-	log_must sync
+	sync_all_pools
 else
 	log_must lockfs -f $TESTDIR
 fi
diff --git a/sys/modules/zfs/Makefile b/sys/modules/zfs/Makefile
index 54d53c87a7c5..b83a9a985fe2 100644
--- a/sys/modules/zfs/Makefile
+++ b/sys/modules/zfs/Makefile
@@ -200,6 +200,7 @@ SRCS+=	abd.c \
 	gzip.c \
 	lzjb.c \
 	lz4.c \
+	lz4_zfs.c \
 	metaslab.c \
 	mmp.c \
 	multilist.c \
@@ -321,6 +322,7 @@ CFLAGS.dsl_prop.c= -Wno-cast-qual
 CFLAGS.edonr.c= -Wno-cast-qual
 CFLAGS.fm.c= -Wno-cast-qual
 CFLAGS.lz4.c= -Wno-cast-qual
+CFLAGS.lz4_zfs.c= -Wno-cast-qual
 CFLAGS.spa.c= -Wno-cast-qual
 CFLAGS.spa_misc.c= -Wno-cast-qual
 CFLAGS.sysctl_os.c= -include ${SRCTOP}/sys/modules/zfs/zfs_config.h
diff --git a/sys/modules/zfs/zfs_config.h b/sys/modules/zfs/zfs_config.h
index eec0dc9bb9d0..fe01c65dfc19 100644
--- a/sys/modules/zfs/zfs_config.h
+++ b/sys/modules/zfs/zfs_config.h
@@ -845,7 +845,7 @@
 /* #undef ZFS_IS_GPL_COMPATIBLE */
 
 /* Define the project alias string. */
-#define ZFS_META_ALIAS "zfs-2.1.99-FreeBSD_gf291fa658"
+#define ZFS_META_ALIAS "zfs-2.1.99-FreeBSD_g17b2ae0b2"
 
 /* Define the project author. */
 #define ZFS_META_AUTHOR "OpenZFS"
@@ -875,7 +875,7 @@
 #define ZFS_META_NAME "zfs"
 
 /* Define the project release. */
-#define ZFS_META_RELEASE "FreeBSD_gf291fa658"
+#define ZFS_META_RELEASE "FreeBSD_g17b2ae0b2"
 
 /* Define the project version. */
 #define ZFS_META_VERSION "2.1.99"
diff --git a/sys/modules/zfs/zfs_gitrev.h b/sys/modules/zfs/zfs_gitrev.h
index e3c1dae475d4..f052d4047999 100644
--- a/sys/modules/zfs/zfs_gitrev.h
+++ b/sys/modules/zfs/zfs_gitrev.h
@@ -2,4 +2,4 @@
  * $FreeBSD$
  */
 
-#define ZFS_META_GITREV "zfs-2.1.99-577-gf291fa658"
+#define ZFS_META_GITREV "zfs-2.1.99-694-g17b2ae0b2"
diff --git a/usr.sbin/fstyp/Makefile b/usr.sbin/fstyp/Makefile
index 161cd0cf3764..e2758de95519 100644
--- a/usr.sbin/fstyp/Makefile
+++ b/usr.sbin/fstyp/Makefile
@@ -35,6 +35,7 @@ CFLAGS.zfs.c+= -I${SRCTOP}/sys/contrib/openzfs/module/icp/include
 CFLAGS.zfs.c+= -include ${SRCTOP}/sys/contrib/openzfs/include/os/freebsd/spl/sys/ccompile.h
 CFLAGS.zfs.c+= -DHAVE_ISSETUGID
 CFLAGS.zfs.c+= -include ${SRCTOP}/sys/modules/zfs/zfs_config.h
+CFLAGS.zfs.c+= -Wno-cast-qual
 .endif
 
 .for src in ${SRCS}
