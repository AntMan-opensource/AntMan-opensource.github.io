commit 3420e63a9d15f4012966c02097573dd215c21e9f
Author: Nickolay Olshevsky <o.nickolay@gmail.com>
Date:   Fri Mar 31 12:23:54 2023 +0300

    Fix typo with unnamed variable in stream-parse and update tests.

diff --git a/src/librepgp/stream-write.cpp b/src/librepgp/stream-write.cpp
index 87e06986..88b0f0b9 100644
--- a/src/librepgp/stream-write.cpp
+++ b/src/librepgp/stream-write.cpp
@@ -1126,7 +1126,7 @@ signed_fill_signature(pgp_dest_signed_param_t &param,
     }
 
     /* decrypt the secret key if needed */
-    rnp::KeyLocker(*signer.key);
+    rnp::KeyLocker keylock(*signer.key);
     if (signer.key->encrypted() &&
         !signer.key->unlock(*param.password_provider, PGP_OP_SIGN)) {
         RNP_LOG("wrong secret key password");
diff --git a/src/tests/ffi-enc.cpp b/src/tests/ffi-enc.cpp
index f61069fd..7ecc1f4c 100644
--- a/src/tests/ffi-enc.cpp
+++ b/src/tests/ffi-enc.cpp
@@ -670,6 +670,28 @@ TEST_F(rnp_tests, test_ffi_encrypt_and_sign)
     // make sure the output file was created
     assert_true(rnp_file_exists("encrypted"));
 
+    // check whether keys are locked
+    rnp_identifier_iterator_t it = NULL;
+    assert_rnp_success(rnp_identifier_iterator_create(ffi, &it, "fingerprint"));
+    const char *fp = NULL;
+    while (!rnp_identifier_iterator_next(it, &fp)) {
+        if (!fp) {
+            break;
+        }
+        SCOPED_TRACE(fp);
+        rnp_key_handle_t skey = NULL;
+        assert_rnp_success(rnp_locate_key(ffi, "fingerprint", fp, &skey));
+        bool secret = true;
+        assert_rnp_success(rnp_key_have_secret(skey, &secret));
+        if (secret) {
+            bool locked = false;
+            assert_rnp_success(rnp_key_is_locked(skey, &locked));
+            assert_true(locked);
+        }
+        rnp_key_handle_destroy(skey);
+    }
+    rnp_identifier_iterator_destroy(it);
+
     // cleanup
     assert_rnp_success(rnp_input_destroy(input));
     input = NULL;
@@ -762,6 +784,25 @@ TEST_F(rnp_tests, test_ffi_encrypt_and_sign)
     assert_string_equal(hname, "SHA512");
     rnp_buffer_destroy(hname);
     hname = NULL;
+    // make sure keys are locked
+    assert_rnp_success(rnp_identifier_iterator_create(ffi, &it, "fingerprint"));
+    while (!rnp_identifier_iterator_next(it, &fp)) {
+        if (!fp) {
+            break;
+        }
+        SCOPED_TRACE(fp);
+        rnp_key_handle_t skey = NULL;
+        assert_rnp_success(rnp_locate_key(ffi, "fingerprint", fp, &skey));
+        bool secret = true;
+        assert_rnp_success(rnp_key_have_secret(skey, &secret));
+        if (secret) {
+            bool locked = false;
+            assert_rnp_success(rnp_key_is_locked(skey, &locked));
+            assert_true(locked);
+        }
+        rnp_key_handle_destroy(skey);
+    }
+    rnp_identifier_iterator_destroy(it);
     // cleanup
     rnp_op_verify_destroy(verify);
     rnp_input_destroy(input);
