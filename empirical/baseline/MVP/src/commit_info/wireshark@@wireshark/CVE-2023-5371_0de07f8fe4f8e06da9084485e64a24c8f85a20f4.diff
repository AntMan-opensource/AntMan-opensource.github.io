commit 0de07f8fe4f8e06da9084485e64a24c8f85a20f4
Author: John Thacker <johnthacker@gmail.com>
Date:   Wed Sep 6 06:13:23 2023 -0400

    RTPS: Check for signed overflow
    
    The offset is a signed integer, and we use negative offsets
    to mean "offset counting from the end of the tvb." That means
    that we can still have an excessive loop without unsigned overflow
    or running off the end of the tvb, if the result of adding a large
    unsigned integer to the offset results in a small negative number.
    
    Just check if the result of the addition makes the offset move
    backwards.
    
    Fix #19322

diff --git a/epan/dissectors/packet-rtps.c b/epan/dissectors/packet-rtps.c
index 3c5bf53c42..d160c11e5d 100644
--- a/epan/dissectors/packet-rtps.c
+++ b/epan/dissectors/packet-rtps.c
@@ -2802,13 +2802,14 @@ static const fragment_items rtps_frag_items = {
 
 static const true_false_string tfs_little_big_endianness = { "Little-Endian", "Big-Endian" };
 
-static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
+static gint check_offset_addition(gint offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb)
 {
-    if (offset > G_MAXUINT32 - value) {
+    gint new_offset = offset + (gint)value;
+    if (new_offset < offset) {
         proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, "Offset value too large: %u", value);
         THROW(ReportedBoundsError);
     }
-    return offset + value;
+    return new_offset;
 }
 
 static void rtps_util_dissect_parameter_header(tvbuff_t * tvb, gint * offset,
