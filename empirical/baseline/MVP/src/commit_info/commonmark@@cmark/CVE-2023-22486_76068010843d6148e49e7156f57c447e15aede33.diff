commit 76068010843d6148e49e7156f57c447e15aede33
Author: John MacFarlane <jgm@berkeley.edu>
Date:   Mon Jan 23 10:25:21 2023 -0800

    Fix quadratic complexity bug.
    
    Previously in parsing the repeated pattern `![[]()` the parser
    repeatedly scanned to the beginning of the increasingly large
    stack of bracketed delimiters, trying to set the link delimiters
    to "inactive" to prevent links inside links.
    
    This commit removes the `active` flag from the bracketed delimiters, and
    adds a new boolean flag `no_link_openers` on subject. This can be
    set to true after a link is matched, telling the parser not to
    bother forming a link if it matches an open bracket. It is set
    to false when a new link open bracket is added to the stack of
    openers. This new approach avoids the need to traverse the stack
    of open brackets.
    
    Resolves CVE-2023-22486.
    Ref: https://github.com/github/cmark-gfm/security/advisories/GHSA-r572-jvj2-3m8p#event-87337

diff --git a/src/inlines.c b/src/inlines.c
index e8bf024..96f4d45 100644
--- a/src/inlines.c
+++ b/src/inlines.c
@@ -67,6 +67,7 @@ typedef struct {
   bracket *last_bracket;
   bufsize_t backticks[MAXBACKTICKS + 1];
   bool scanned_for_backticks;
+  bool no_link_openers;
 } subject;
 
 static CMARK_INLINE bool S_is_line_end_char(char c) {
@@ -208,6 +209,7 @@ static void subject_from_buf(cmark_mem *mem, int line_number, int block_offset,
     e->backticks[i] = 0;
   }
   e->scanned_for_backticks = false;
+  e->no_link_openers = true;
 }
 
 static CMARK_INLINE int isbacktick(int c) { return (c == '`'); }
@@ -553,6 +555,9 @@ static void push_bracket(subject *subj, bool image, cmark_node *inl_text) {
   b->position = subj->pos;
   b->bracket_after = false;
   subj->last_bracket = b;
+  if (!image) {
+    subj->no_link_openers = false;
+  }
 }
 
 // Assumes the subject has a c at the current position.
@@ -1121,16 +1126,16 @@ static cmark_node *handle_close_bracket(subject *subj) {
     return make_str(subj, subj->pos - 1, subj->pos - 1, cmark_chunk_literal("]"));
   }
 
-  if (!opener->active) {
+  // If we got here, we matched a potential link/image text.
+  // Now we check to see if it's a link/image.
+  is_image = opener->image;
+
+  if (!is_image && subj->no_link_openers) {
     // take delimiter off stack
     pop_bracket(subj);
     return make_str(subj, subj->pos - 1, subj->pos - 1, cmark_chunk_literal("]"));
   }
 
-  // If we got here, we matched a potential link/image text.
-  // Now we check to see if it's a link/image.
-  is_image = opener->image;
-
   after_link_text_pos = subj->pos;
 
   // First, look for an inline link.
@@ -1226,21 +1231,11 @@ match:
   process_emphasis(subj, opener->position);
   pop_bracket(subj);
 
-  // Now, if we have a link, we also want to deactivate earlier link
-  // delimiters. (This code can be removed if we decide to allow links
+  // Now, if we have a link, we also want to deactivate links until
+  // we get a new opener. (This code can be removed if we decide to allow links
   // inside links.)
   if (!is_image) {
-    opener = subj->last_bracket;
-    while (opener != NULL) {
-      if (!opener->image) {
-        if (!opener->active) {
-          break;
-        } else {
-          opener->active = false;
-        }
-      }
-      opener = opener->previous;
-    }
+    subj->no_link_openers = true;
   }
 
   return NULL;
