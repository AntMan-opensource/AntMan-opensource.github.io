commit 1d4b091abdf15ad7b2312535b5b95ad70f6dbd08
Author: Matthias Schiffer <mschiffer@universe-factory.net>
Date:   Wed Apr 20 22:04:07 2022 +0200

    verify: fix signature verification (CVE-2022-24884)
    
    Verify that r and s are non-zero. Without these checks, an all-zero
    signature is always considered valid.
    
    While it would be nicer to error out in ecdsa_verify_prepare_legacy()
    already, that would require users of libecdsautil to check a return value
    of the prepare step. To be safe, implement the fix in an API/ABI-compatible
    way that doesn't need changes to the users.

diff --git a/src/lib/ecdsa.c b/src/lib/ecdsa.c
index 8cd7722..a661b56 100644
--- a/src/lib/ecdsa.c
+++ b/src/lib/ecdsa.c
@@ -135,6 +135,12 @@ regenerate:
 void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {
   ecc_int256_t w, u1, tmp;
 
+  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r)) {
+    // Signature is invalid, mark by setting ctx->r to an invalid value
+    memset(&ctx->r, 0, sizeof(ctx->r));
+    return;
+  }
+
   ctx->r = signature->r;
 
   ecc_25519_gf_recip(&w, &signature->s);
@@ -149,6 +155,10 @@ bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work
   ecc_25519_work_t s2, work;
   ecc_int256_t w, tmp;
 
+  // Signature was detected as invalid in prepare step
+  if (ecc_25519_gf_is_zero(&ctx->r))
+    return false;
+
   ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);
   ecc_25519_add(&work, &ctx->s1, &s2);
   ecc_25519_store_xy_legacy(&w, NULL, &work);
