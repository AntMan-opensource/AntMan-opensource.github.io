package com.sun.glass.ui;
import com.sun.glass.events.MouseEvent;
import com.sun.glass.events.WindowEvent;
import com.sun.prism.impl.PrismSettings;
import java.lang.annotation.Native;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
public abstract class Window {
    public static class EventHandler {
        public void handleWindowEvent(Window window, long time, int type) {
        }
        
        public void handleScreenChangedEvent(Window window, long time, Screen oldScreen, Screen newScreen) {
        }
        
        public void handleLevelEvent(int level) {
        }
        
    }
    
    private long ptr;
    private volatile long delegatePtr = 0L;
    static private final LinkedList<Window> visibleWindows = new LinkedList<>();
    static public synchronized List<Window> getWindows() {
        Application.checkEventThread();
        return Collections.unmodifiableList(Window.visibleWindows);
    }
    
    static public List<Window> getWindowsClone() {
        Application.checkEventThread();
        return (List<Window>)visibleWindows.clone();
    }
    
    static protected void add(Window window) {
        visibleWindows.add(window);
    }
    
    static protected void addFirst(Window window) {
        visibleWindows.addFirst(window);
    }
    
    static protected void remove(Window window) {
        visibleWindows.remove(window);
    }
    
    public static final int UNTITLED        = 0;
    public static final int TITLED          = 1 << 0;
    public static final int TRANSPARENT     = 1 << 1;
    public static final int NORMAL          = 0;
    @Native public static final int UTILITY         = 1 << 2;
    @Native public static final int POPUP           = 1 << 3;
    @Native public static final int CLOSABLE        = 1 << 4;
    @Native public static final int MINIMIZABLE     = 1 << 5;
    @Native public static final int MAXIMIZABLE     = 1 << 6;
    @Native public static final int RIGHT_TO_LEFT     = 1 << 7;
    @Native public static final int UNIFIED = 1 << 8;
    @Native public static final int MODAL = 1 << 9;
    final static public class State {
        @Native public static final int NORMAL = 1;
        @Native public static final int MINIMIZED = 2;
        @Native public static final int MAXIMIZED = 3; }
    public static final class Level {
        @Native private static final int _MIN = 1;
        @Native public static final int NORMAL = 1;
        @Native public static final int FLOATING = 2;
        @Native public static final int TOPMOST = 3;
        @Native private static final int _MAX = 3; }
    private final Window owner;
    private final int styleMask;
    private final boolean isDecorated;
    private boolean shouldStartUndecoratedMove = false;
    protected View view = null;
    protected Screen screen = null;
    private MenuBar menubar = null;
    private String title = "";
    private UndecoratedMoveResizeHelper helper = null;
    private int state = State.NORMAL;
    private int level = Level.NORMAL;
    protected int x = 0;
    protected int y = 0;
    protected int width = 0;
    protected int height = 0;
    private float alpha = 1.0f;
    protected float platformScaleX = 1.0f;
    protected float platformScaleY = 1.0f;
    private float outputScaleX = 1.0f;
    private float outputScaleY = 1.0f;
    private float renderScaleX = 1.0f;
    private float renderScaleY = 1.0f;
    private volatile boolean isResizable = false;
    private volatile boolean isVisible = false;
    private volatile boolean isFocused = false;
    private volatile boolean isFocusable = true;
    private volatile boolean isModal = false;
    private volatile int disableCount = 0;
    private int minimumWidth = 0, minimumHeight = 0;
    private int maximumWidth = Integer.MAX_VALUE, maximumHeight = Integer.MAX_VALUE;
    private EventHandler eventHandler;
    protected abstract long _createWindow(long ownerPtr, long screenPtr, int mask);
    protected Window(Window owner, Screen screen, int styleMask) {
        Application.checkEventThread();
        switch (styleMask & (TITLED | TRANSPARENT)) {
            case UNTITLED:
            case TITLED:
            case TRANSPARENT:
                break;
            default: throw new RuntimeException("The visual kind should be UNTITLED, TITLED, or TRANSPARENT, but not a combination of these");
        }
        
        switch (styleMask & (POPUP | UTILITY)) {
            case NORMAL:
            case POPUP:
            case UTILITY:
                break;
            default: throw new RuntimeException("The functional type should be NORMAL, POPUP, or UTILITY, but not a combination of these");
        }
        
        if (((styleMask & UNIFIED) != 0) && !Application.GetApplication().supportsUnifiedWindows()) {
           styleMask &= ~UNIFIED;
        }
        
        if (((styleMask & TRANSPARENT) != 0) && !Application.GetApplication().supportsTransparentWindows()) {
            styleMask &= ~TRANSPARENT;
        }
        
        this.owner = owner;
        this.styleMask = styleMask;
        this.isDecorated = (this.styleMask & Window.TITLED) != 0;
        this.screen = screen != null ? screen : Screen.getMainScreen();
        if (PrismSettings.allowHiDPIScaling) {
            this.platformScaleX = this.screen.getPlatformScaleX();
            this.platformScaleY = this.screen.getPlatformScaleY();
            this.outputScaleX = this.screen.getRecommendedOutputScaleX();
            this.outputScaleY = this.screen.getRecommendedOutputScaleY();
        }
        
        this.ptr = _createWindow(owner != null ? owner.getNativeHandle() : 0L, this.screen.getNativeScreen(), this.styleMask);
        if (this.ptr == 0L) {
            throw new RuntimeException("could not create platform window");
        }
        
    }
    
    public boolean isClosed() {
        Application.checkEventThread();
        return this.ptr == 0L;
    }
    
    private void checkNotClosed() {
        if (this.ptr == 0L) {
            throw new IllegalStateException("The window has already been closed");
        }
        
    }
    
    protected abstract boolean _close(long ptr);
    public void close() {
        Application.checkEventThread();
        if (this.view != null) {
            if (this.ptr != 0L) {
                _setView(this.ptr, null);
            }
            
            this.view.setWindow(null);
            this.view.close();
            this.view = null;
        }
        
        if (this.ptr != 0L) {
            _close(this.ptr);
        }
        
    }
    
    public long getNativeWindow() {
        Application.checkEventThread();
        checkNotClosed();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }
    
    public long getNativeHandle() {
        Application.checkEventThread();
        return this.delegatePtr != 0L ? this.delegatePtr : this.ptr;
    }
    
    public long getRawHandle() {
        return ptr;
    }
    
    public Window getOwner() {
        Application.checkEventThread();
        return this.owner;
    }
    
    public View getView() {
        Application.checkEventThread();
        return this.view;
    }
    
    protected abstract boolean _setView(long ptr, View view);
    public void setView(final View view) {
        Application.checkEventThread();
        checkNotClosed();
        View oldView = getView();
        if (oldView == view) {
            return;
        }
        
        if (oldView != null) {
            oldView.setWindow(null);
        }
        
        if (view != null) {
            Window host = view.getWindow();
            if (host != null) {
                host.setView(null);
            }
            
        }
        
        if (view != null && _setView(this.ptr, view)) {
            this.view = view;
            this.view.setWindow(this);
            if (this.isDecorated == false) {
                this.helper = new UndecoratedMoveResizeHelper();
            }
            
        }
         else {
            _setView(this.ptr, null);
            this.view = null;
        }
        
    }
    
    public Screen getScreen() {
        Application.checkEventThread();
        return this.screen;
    }
    
    protected void setScreen(Screen screen) {
        Application.checkEventThread();
        final Screen old = this.screen;
        this.screen = screen;
        if (this.eventHandler != null) {
            if ((old == null && this.screen != null) || (old != null && !old.equals(this.screen))) {
                this.eventHandler.handleScreenChangedEvent(this, System.nanoTime(), old, this.screen);
            }
            
        }
        
    }
    
    public int getStyleMask() {
        Application.checkEventThread();
        return this.styleMask;
    }
    
    public MenuBar getMenuBar() {
        Application.checkEventThread();
        return this.menubar;
    }
    
    protected abstract boolean _setMenubar(long ptr, long menubarPtr);
    public void setMenuBar(final MenuBar menubar) {
        Application.checkEventThread();
        checkNotClosed();
        if (_setMenubar(this.ptr, menubar.getNativeMenu())) {
            this.menubar = menubar;
        }
        
    }
    
    public boolean isDecorated() {
        Application.checkEventThread();
        return this.isDecorated;
    }
    
    public boolean isMinimized() {
        Application.checkEventThread();
        return (this.state == State.MINIMIZED);
    }
    
    protected abstract boolean _minimize(long ptr, boolean minimize);
    public boolean minimize(final boolean minimize) {
        Application.checkEventThread();
        checkNotClosed();
        _minimize(this.ptr, minimize);
        return isMinimized();
    }
    
    public boolean isMaximized() {
        Application.checkEventThread();
        return (this.state == State.MAXIMIZED);
    }
    
    protected abstract boolean _maximize(long ptr, boolean maximize, boolean wasMaximized);
    public boolean maximize(final boolean maximize) {
        Application.checkEventThread();
        checkNotClosed();
        _maximize(ptr, maximize, isMaximized());
        return isMaximized();
    }
    
    protected void notifyScaleChanged(float platformScaleX, float platformScaleY, float outputScaleX, float outputScaleY) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.platformScaleX = platformScaleX;
        this.platformScaleY = platformScaleY;
        this.outputScaleX = outputScaleX;
        this.outputScaleY = outputScaleY;
        notifyRescale();
    }
    
    public final float getPlatformScaleX() {
        return platformScaleX;
    }
    
    public final float getPlatformScaleY() {
        return platformScaleY;
    }
    
    public void setRenderScaleX(float renderScaleX) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleX = renderScaleX;
    }
    
    public void setRenderScaleY(float renderScaleY) {
        if (!PrismSettings.allowHiDPIScaling) return;
        this.renderScaleY = renderScaleY;
    }
    
    public final float getRenderScaleX() {
        return renderScaleX;
    }
    
    public final float getRenderScaleY() {
        return renderScaleY;
    }
    
    public float getOutputScaleX() {
        return outputScaleX;
    }
    
    public float getOutputScaleY() {
        return outputScaleY;
    }
    
    public int getX() {
        Application.checkEventThread();
        return this.x;
    }
    
    public int getY() {
        Application.checkEventThread();
        return this.y;
    }
    
    public int getWidth() {
        Application.checkEventThread();
        return this.width;
    }
    
    public int getHeight() {
        Application.checkEventThread();
        return this.height;
    }
    
    protected abstract void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet, int w, int h, int cw, int ch, float xGravity, float yGravity);
    public void setBounds(float x, float y, boolean xSet, boolean ySet, float w, float h, float cw, float ch, float xGravity, float yGravity) {
        Application.checkEventThread();
        checkNotClosed();
        float pScaleX = platformScaleX;
        float pScaleY = platformScaleY;
        int px = screen.getPlatformX() + Math.round((x - screen.getX()) * pScaleX);
        int py = screen.getPlatformY() + Math.round((y - screen.getY()) * pScaleY);
        int pw = (int) (w > 0 ? Math.ceil(w * pScaleX) : w);
        int ph = (int) (h > 0 ? Math.ceil(h * pScaleY) : h);
        int pcw = (int) (cw > 0 ? Math.ceil(cw * pScaleX) : cw);
        int pch = (int) (ch > 0 ? Math.ceil(ch * pScaleY) : ch);
        _setBounds(ptr, px, py, xSet, ySet, pw, ph, pcw, pch, xGravity, yGravity);
    }
    
    public void setPosition(int x, int y) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, x, y, true, true, 0, 0, 0, 0, 0, 0);
    }
    
    public void setSize(int w, int h) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, w, h, 0, 0, 0, 0);
    }
    
    public void setContentSize(int cw, int ch) {
        Application.checkEventThread();
        checkNotClosed();
        _setBounds(ptr, 0, 0, false, false, 0, 0, cw, ch, 0, 0);
    }
    
    public boolean isVisible() {
        Application.checkEventThread();
        return this.isVisible;
    }
    
    private void synthesizeViewMoveEvent() {
        final View view = getView();
        if (view != null) {
            view.notifyView(com.sun.glass.events.ViewEvent.MOVE);
        }
        
    }
    
    protected abstract boolean _setVisible(long ptr, boolean visible);
    public void setVisible(final boolean visible) {
        Application.checkEventThread();
        if (this.isVisible != visible) {
            if (!visible) {
                if (getView() != null) {
                    getView().setVisible(visible);
                }
                
                if (this.ptr != 0L) {
                    this.isVisible = _setVisible(this.ptr, visible);
                }
                 else {
                    this.isVisible = visible;
                }
                
                remove(this);
            }
             else {
                checkNotClosed();
                this.isVisible = _setVisible(this.ptr, visible);
                if (getView() != null) {
                    getView().setVisible(this.isVisible);
                }
                
                add(this);
                synthesizeViewMoveEvent();
            }
            
        }
        
    }
    
    protected abstract boolean _setResizable(long ptr, boolean resizable);
    public boolean setResizable(final boolean resizable) {
        Application.checkEventThread();
        checkNotClosed();
        if (this.isResizable != resizable) {
            if (_setResizable(this.ptr, resizable)) {
                this.isResizable = resizable;
                synthesizeViewMoveEvent();
            }
            
        }
        
        return isResizable;
    }
    
    public boolean isResizable() {
        Application.checkEventThread();
        return this.isResizable;
    }
    
    public boolean isUnifiedWindow() {
        return (this.styleMask & Window.UNIFIED) != 0;
    }
    
    public boolean isTransparentWindow() {
        return (this.styleMask & Window.TRANSPARENT) != 0;
    }
    
    public boolean isFocused() {
        Application.checkEventThread();
        return this.isFocused;
    }
    
    protected abstract boolean _requestFocus(long ptr, int event);
    public boolean requestFocus(int event) {
        Application.checkEventThread();
        checkNotClosed();
        if (event != WindowEvent.FOCUS_GAINED) {
            throw new IllegalArgumentException("Invalid focus event ID for top-level window");
        }
        
        if (event == WindowEvent.FOCUS_LOST && !isFocused()) {
            return true;
        }
        
        if (!this.isFocusable) {
            return false;
        }
        
        return _requestFocus(this.ptr, event);
    }
    
    public boolean requestFocus() {
        Application.checkEventThread();
        return requestFocus(WindowEvent.FOCUS_GAINED);
    }
    
    protected abstract void _setFocusable(long ptr, boolean isFocusable);
    public void setFocusable(final boolean isFocusable) {
        Application.checkEventThread();
        checkNotClosed();
        this.isFocusable = isFocusable;
        if (isEnabled()) {
            _setFocusable(this.ptr, isFocusable);
        }
        
    }
    
    protected abstract boolean _grabFocus(long ptr);
    protected abstract void _ungrabFocus(long ptr);
    public boolean grabFocus() {
        Application.checkEventThread();
        checkNotClosed();
        if (!isFocused()) {
            throw new IllegalStateException("The window must be focused when calling grabFocus()");
        }
        
        return _grabFocus(this.ptr);
    }
    
    public void ungrabFocus() {
        Application.checkEventThread();
        checkNotClosed();
        _ungrabFocus(this.ptr);
    }
    
    public String getTitle() {
        Application.checkEventThread();
        return this.title;
    }
    
    protected abstract boolean _setTitle(long ptr, String title);
    public void setTitle(String title) {
        Application.checkEventThread();
        checkNotClosed();
        if (title == null) {
            title = "";
        }
        
        if (!title.equals(this.title)) {
            if (_setTitle(this.ptr, title)) {
                this.title = title;
            }
            
        }
        
    }
    
    protected abstract void _setLevel(long ptr, int level);
    public void setLevel(final int level) {
        Application.checkEventThread();
        checkNotClosed();
        if (level < Level._MIN || level > Level._MAX) {
            throw new IllegalArgumentException("Level should be in the range [" + Level._MIN + ".." + Level._MAX + "]");
        }
        
        if (this.level != level) {
            _setLevel(this.ptr, level);
            this.level = level;
        }
        
    }
    
    public int getLevel() {
        Application.checkEventThread();
        return this.level;
    }
    
    private boolean isInFullscreen() {
        final View view = getView();
        return view == null ? false : view.isInFullscreen();
    }
    
    void notifyFullscreen(boolean entered) {
        final float alpha = getAlpha();
        if (alpha < 1f) {
            if (entered) {
                _setAlpha(this.ptr, 1f);
            }
             else {
                setAlpha(alpha);
            }
            
        }
        
    }
    
    protected abstract void _setAlpha(long ptr, float alpha);
    public void setAlpha(final float alpha) {
        Application.checkEventThread();
        checkNotClosed();
        if (alpha < 0f || alpha > 1f) {
            throw new IllegalArgumentException("Alpha should be in the range [0f..1f]");
        }
        
        this.alpha = alpha;
        if (alpha < 1f && isInFullscreen()) {
            return;
        }
        
        _setAlpha(this.ptr, this.alpha);
    }
    
    public float getAlpha() {
        Application.checkEventThread();
        return this.alpha;
    }
    
    protected abstract boolean _setBackground(long ptr, float r, float g, float b);
    public boolean setBackground(final float r, final float g, final float b) {
        Application.checkEventThread();
        checkNotClosed();
        return _setBackground(this.ptr, r, g, b);
    }
    
    public boolean isEnabled() {
        Application.checkEventThread();
        return this.disableCount == 0;
    }
    
    protected abstract void _setEnabled(long ptr, boolean enabled);
    public void setEnabled(boolean enabled) {
        Application.checkEventThread();
        checkNotClosed();
        if (!enabled) {
            if (++this.disableCount > 1) {
                return;
            }
            
        }
         else {
            if (this.disableCount == 0) {
                return;
            }
            
            if (--this.disableCount > 0) {
                return;
            }
            
        }
        
        _setEnabled(this.ptr, isEnabled());
    }
    
    public int getMinimumWidth() {
        Application.checkEventThread();
        return this.minimumWidth;
    }
    
    public int getMinimumHeight() {
        Application.checkEventThread();
        return this.minimumHeight;
    }
    
    public int getMaximumWidth() {
        Application.checkEventThread();
        return this.maximumWidth;
    }
    
    public int getMaximumHeight() {
        Application.checkEventThread();
        return this.maximumHeight;
    }
    
    protected abstract boolean _setMinimumSize(long ptr, int width, int height);
    public void setMinimumSize(int width, int height) {
        Application.checkEventThread();
        if (width < 0 || height < 0) {
            throw new IllegalArgumentException("The width and height must be >= 0. Got: width=" + width + "; height=" + height);
        }
        
        checkNotClosed();
        if (_setMinimumSize(this.ptr, width, height)) {
            this.minimumWidth = width;
            this.minimumHeight = height;
        }
        
    }
    
    protected abstract boolean _setMaximumSize(long ptr, int width, int height);
    public void setMaximumSize(int width, int height) {
        Application.checkEventThread();
        if (width < 0 || height < 0) {
            throw new IllegalArgumentException("The width and height must be >= 0. Got: width=" + width + "; height=" + height);
        }
        
        checkNotClosed();
        if (_setMaximumSize(this.ptr, width == Integer.MAX_VALUE ? -1 : width, height == Integer.MAX_VALUE ? -1 : height)){
            this.maximumWidth = width;
            this.maximumHeight = height;
        }
        
    }
    
    protected abstract void _setIcon(long ptr, Pixels pixels);
    public void setIcon(final Pixels pixels) {
        Application.checkEventThread();
        checkNotClosed();
        _setIcon(this.ptr, pixels);
    }
    
    protected abstract void _setCursor(long ptr, Cursor cursor);
    public void setCursor(Cursor cursor) {
        Application.checkEventThread();
        _setCursor(this.ptr, cursor);
    }
    
    protected abstract void _toFront(long ptr);
    public void toFront() {
        Application.checkEventThread();
        checkNotClosed();
        _toFront(ptr);
    }
    
    protected abstract void _toBack(long ptr);
    public void toBack() {
        Application.checkEventThread();
        checkNotClosed();
        _toBack(this.ptr);
    }
    
    protected abstract void _enterModal(long ptr);
    public void enterModal() {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModal(this.ptr);
        }
        
    }
    
    protected abstract void _enterModalWithWindow(long dialog, long window);
    public void enterModal(final Window window) {
        checkNotClosed();
        if (this.isModal == false) {
            this.isModal = true;
            _enterModalWithWindow(this.ptr, window.getNativeHandle());
        }
        
    }
    
    protected abstract void _exitModal(long ptr);
    public void exitModal() {
        checkNotClosed();
        if (this.isModal == true) {
            _exitModal(this.ptr);
            this.isModal = false;
        }
        
    }
    
    public boolean isModal() {
        return this.isModal;
    }
    
    public EventHandler getEventHandler() {
        Application.checkEventThread();
        return eventHandler;
    }
    
    public void setEventHandler(EventHandler eventHandler) {
        Application.checkEventThread();
        this.eventHandler = eventHandler;
    }
    
    public void setShouldStartUndecoratedMove(boolean v) {
        Application.checkEventThread();
        this.shouldStartUndecoratedMove = v;
    }
    
    protected void notifyClose() {
        handleWindowEvent(System.nanoTime(), WindowEvent.CLOSE);
    }
    
    protected void notifyDestroy() {
        if (this.ptr == 0) {
            return;
        }
        
        handleWindowEvent(System.nanoTime(), WindowEvent.DESTROY);
        this.ptr = 0;
        setVisible(false);
    }
    
    protected void notifyMove(final int x, final int y) {
        this.x = x;
        this.y = y;
        handleWindowEvent(System.nanoTime(), WindowEvent.MOVE);
    }
    
    protected void notifyRescale() {
        handleWindowEvent(System.nanoTime(), WindowEvent.RESCALE);
    }
    
    protected void notifyMoveToAnotherScreen(Screen newScreen) {
        setScreen(newScreen);
    }
    
    protected void setState(int state) {
        this.state = state;
    }
    
    protected void notifyResize(final int type, final int width, final int height) {
        if (type == WindowEvent.MINIMIZE) {
            this.state = State.MINIMIZED;
        }
         else {
            if (type == WindowEvent.MAXIMIZE) {
                this.state = State.MAXIMIZED;
            }
             else { 
                this.state = State.NORMAL;
            }
            
            this.width = width;
            this.height = height;
            if (this.helper != null){
                this.helper.updateRectangles();
            }
            
        }
        
        handleWindowEvent(System.nanoTime(), type);
        if (type == WindowEvent.MAXIMIZE || type == WindowEvent.RESTORE) {
            handleWindowEvent(System.nanoTime(), WindowEvent.RESIZE);
        }
        
    }
    
    protected void notifyFocus(int event) {
        final boolean focused = event != WindowEvent.FOCUS_LOST;
        if (this.isFocused != focused) {
            this.isFocused = focused;
            handleWindowEvent(System.nanoTime(), event);
        }
        
    }
    
    protected void notifyFocusDisabled() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_DISABLED);
    }
    
    protected void notifyFocusUngrab() {
        handleWindowEvent(System.nanoTime(), WindowEvent.FOCUS_UNGRAB);
    }
    
    protected void notifyDelegatePtr(long ptr) {
        this.delegatePtr = ptr;
    }
    
    protected void handleWindowEvent(long time, int type) {
        if (this.eventHandler != null) {
            this.eventHandler.handleWindowEvent(this, time, type);
        }
        
    }
    
    public void setUndecoratedMoveRectangle(int size) {
        Application.checkEventThread();
        if (this.isDecorated == true) {
            System.err.println("Glass Window.setUndecoratedMoveRectangle is only valid for Undecorated Window. In the future this will be hard error.");
            Thread.dumpStack();
            return;
        }
        
        if (this.helper != null) {
            this.helper.setMoveRectangle(size);
        }
        
    }
    
    public boolean shouldStartUndecoratedMove(final int x, final int y) {
        Application.checkEventThread();
        if (this.shouldStartUndecoratedMove == true) {
            return true;
        }
        
        if (this.isDecorated == true) {
            return false;
        }
        
        if (this.helper != null) {
            return this.helper.shouldStartMove(x, y);
        }
         else {
            return false;
        }
        
    }
    
    public void setUndecoratedResizeRectangle(int size) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            System.err.println("Glass Window.setUndecoratedResizeRectangle is only valid for Undecorated Resizable Window. In the future this will be hard error.");
            Thread.dumpStack();
            return;
        }
        
        if (this.helper != null) {
            this.helper.setResizeRectangle(size);
        }
        
    }
    
    public boolean shouldStartUndecoratedResize(final int x, final int y) {
        Application.checkEventThread();
        if ((this.isDecorated == true) || (this.isResizable == false)) {
            return false;
        }
        
        if (this.helper != null) {
            return this.helper.shouldStartResize(x, y);
        }
          else {
            return false;
        }
        
    }
    
    boolean handleMouseEvent(int type, int button, int x, int y, int xAbs, int yAbs) {
        if (this.isDecorated == false) {
            return this.helper.handleMouseEvent(type, button, x, y, xAbs, yAbs);
        }
        
        return false;
    }
    
    public String toString() {
        Application.checkEventThread();
        return  "Window:"+"\n" + "    ptr: " + getNativeWindow() + "\n" + "    screen ptr: " + (screen != null ? screen.getNativeScreen() : "null") + "\n" + "    isDecorated: " + isDecorated() + "\n" + "    title: " + getTitle() + "\n" + "    visible: " + isVisible() + "\n" + "    focused: " + isFocused() + "\n" + "    modal: " + isModal() + "\n" + "    state: " + state + "\n" + "    x: " + getX() + ", y: " + getY() + ", w: " + getWidth() + ", h: " + getHeight() + "\n" + "";
    }
    
    static private class TrackingRectangle {
        int size = 0;
        int x = 0, y = 0, width = 0, height = 0;
        boolean contains(final int x, final int y) {
            return ((size > 0) && (x >= this.x) && (x < (this.x + this.width)) && (y >= this.y) && (y < (this.y + this.height)));
        }
        
    }
    
    protected void notifyLevelChanged(int level) {
        this.level = level;
        if (this.eventHandler != null) {
            this.eventHandler.handleLevelEvent(level);
        }
        
    }
    
    private class UndecoratedMoveResizeHelper {
        TrackingRectangle moveRect = null;
        TrackingRectangle resizeRect = null;
        boolean inMove = false;         
        boolean inResize = false;       
        int startMouseX, startMouseY;   
        int startX, startY;             
        int startWidth, startHeight;    
        UndecoratedMoveResizeHelper() {
            this.moveRect = new TrackingRectangle();
            this.resizeRect = new TrackingRectangle();
        }
        
        void setMoveRectangle(final int size) {
            this.moveRect.size = size;
            this.moveRect.x = 0;
            this.moveRect.y = 0;
            this.moveRect.width = getWidth();
            this.moveRect.height = this.moveRect.size;
        }
        
        boolean shouldStartMove(final int x, final int y) {
            return this.moveRect.contains(x, y);
        }
        
        boolean inMove() {
            return this.inMove;
        }
        
        void startMove(final int x, final int y) {
            this.inMove = true;
            this.startMouseX = x;
            this.startMouseY = y;
            this.startX = getX();
            this.startY = getY();
        }
        
        void deltaMove(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;
            setPosition(this.startX + deltaX, this.startY + deltaY);
        }
        
        void stopMove() {
            this.inMove = false;
        }
        
        void setResizeRectangle(final int size) {
            this.resizeRect.size = size;
            this.resizeRect.x = getWidth() - this.resizeRect.size;
            this.resizeRect.y = getHeight() - this.resizeRect.size;
            this.resizeRect.width = this.resizeRect.size;
            this.resizeRect.height = this.resizeRect.size;
        }
        
        boolean shouldStartResize(final int x, final int y) {
            return this.resizeRect.contains(x, y);
        }
        
        boolean inResize() {
            return this.inResize;
        }
        
        void startResize(final int x, final int y) {
            this.inResize = true;
            this.startMouseX = x;
            this.startMouseY = y;
            this.startWidth = getWidth();
            this.startHeight = getHeight();
        }
        
        void deltaResize(final int x, final int y) {
            int deltaX = x - this.startMouseX;
            int deltaY = y - this.startMouseY;
            setSize(this.startWidth + deltaX, this.startHeight + deltaY);
        }
        
        protected void stopResize() {
            this.inResize = false;
        }
        
        void updateRectangles() {
            if (this.moveRect.size > 0) {
                setMoveRectangle(this.moveRect.size);
            }
            
            if (this.resizeRect.size > 0) {
                setResizeRectangle(this.resizeRect.size);
            }
            
        }
        
        boolean handleMouseEvent(final int type, final int button, final int x, final int y, final int xAbs, final int yAbs) {
            switch (type) {
                case MouseEvent.DOWN:
                    if (button == MouseEvent.BUTTON_LEFT) {
                        if (shouldStartUndecoratedMove(x, y) == true) {
                            startMove(xAbs, yAbs);
                            return true;
                        }
                         else if (shouldStartUndecoratedResize(x, y) == true) {
                            startResize(xAbs, yAbs);
                            return true;
                        }
                        
                    }
                    
                    break;
                case MouseEvent.MOVE:
                case MouseEvent.DRAG:
                    if (inMove() == true) {
                        deltaMove(xAbs, yAbs);
                        return true;
                    }
                     else if (inResize() == true) {
                        deltaResize(xAbs, yAbs);
                        return true;
                    }
                    
                    break;
                case MouseEvent.UP:
                    boolean wasProcessed = inMove() || inResize();
                    stopResize();
                    stopMove();
                    return wasProcessed;
            }
            
            return false;
        }
        
    }
    
    public void requestInput(String text, int type, double width, double height, double Mxx, double Mxy, double Mxz, double Mxt, double Myx, double Myy, double Myz, double Myt, double Mzx, double Mzy, double Mzz, double Mzt) {
        Application.checkEventThread();
        _requestInput(this.ptr, text, type, width, height, Mxx, Mxy, Mxz, Mxt, Myx, Myy, Myz, Myt, Mzx, Mzy, Mzz, Mzt);
    }
    
    public void releaseInput() {
        Application.checkEventThread();
        _releaseInput(this.ptr);
    }
    
    protected abstract void _requestInput(long ptr, String text, int type, double width, double height, double Mxx, double Mxy, double Mxz, double Mxt, double Myx, double Myy, double Myz, double Myt, double Mzx, double Mzy, double Mzz, double Mzt);
    protected abstract void _releaseInput(long ptr);
}


