package org.csanchez.jenkins.plugins.kubernetes.pipeline;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import hudson.Extension;
import hudson.remoting.Channel;
import hudson.util.LogTaskListener;
import io.fabric8.kubernetes.api.model.Container;
import io.fabric8.kubernetes.api.model.EnvVar;
import io.fabric8.kubernetes.api.model.EnvVarSource;
import io.fabric8.kubernetes.api.model.Pod;
import io.fabric8.kubernetes.api.model.SecretKeySelector;
import io.fabric8.kubernetes.client.dsl.ExecListener;
import io.fabric8.kubernetes.client.dsl.ExecWatch;
import io.fabric8.kubernetes.client.utils.Serialization;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.WeakHashMap;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.csanchez.jenkins.plugins.kubernetes.KubernetesComputer;
import org.csanchez.jenkins.plugins.kubernetes.KubernetesSlave;
import org.csanchez.jenkins.plugins.kubernetes.PodTemplate;
import org.jenkinsci.plugins.credentialsbinding.masking.SecretPatterns;
import org.jenkinsci.plugins.kubernetes.auth.KubernetesAuthException;
import org.jenkinsci.plugins.workflow.log.TaskListenerDecorator;
import org.jenkinsci.plugins.workflow.steps.DynamicContext;
public final class SecretsMasker extends TaskListenerDecorator {
    private static final Logger LOGGER = Logger.getLogger(SecretsMasker.class.getName());
    private static final long serialVersionUID = 1;
    private final Set<String> values;
    private SecretsMasker(Set<String> values) {
        assert !values.isEmpty();
        this.values = values;
    }
    
    public OutputStream decorate(OutputStream logger) throws IOException, InterruptedException {
        return new SecretPatterns.MaskingOutputStream(logger, () -> SecretPatterns.getAggregateSecretPattern(values), "UTF-8");
    }
    
    public static final class Factory extends DynamicContext.Typed<TaskListenerDecorator> {
        private final Map<KubernetesComputer, Set<String>> secrets = new WeakHashMap<>();
        protected Class<TaskListenerDecorator> type() {
            return TaskListenerDecorator.class;
        }
        
        protected TaskListenerDecorator get(DelegatedContext context) throws IOException, InterruptedException {
            KubernetesComputer c;
            try {
                c = context.get(KubernetesComputer.class);
            }
             catch (IOException | InterruptedException x) {
                LOGGER.log(Level.FINE, "Unable to look up KubernetesComputer", x);
                return null;
            }
            
            if (c == null) {
                return null;
            }
            
            synchronized (secrets) {
                if (secrets.containsKey(c)) {
                    Set<String> values = secrets.get(c);
                    if (values != null) {
                        LOGGER.log(Level.FINE, "Using cached secrets for {0}", c);
                        return TaskListenerDecorator.merge(context.get(TaskListenerDecorator.class), new SecretsMasker(values));
                    }
                     else {
                        LOGGER.log(Level.FINE, "Cached absence of secrets for {0}", c);
                        return null;
                    }
                    
                }
                
            }
            
            Set<String> values = secretsOf(c);
            synchronized (secrets) {
                secrets.put(c, values);
            }
            
            if (values != null) {
                LOGGER.fine("masking " + values.size() + " values");
                return TaskListenerDecorator.merge(context.get(TaskListenerDecorator.class), new SecretsMasker(values));
            }
             else {
                LOGGER.fine("no values to mask");
                return null;
            }
            
        }
        
        private static @CheckForNull Set<String> secretsOf(KubernetesComputer c) throws IOException, InterruptedException {
            Channel ch = c.getChannel();
            if (ch == null) {
                return null;
            }
            
            KubernetesSlave slave = c.getNode();
            if (slave == null) {
                return null;
            }
            
            PodTemplate template = slave.getTemplateOrNull();
            if (template == null) {
                return null;
            }
            
            Pod pod = template.build(slave);
            Set<String> values = new HashSet<>();
            values.add(c.getJnlpMac());
            LOGGER.finer(() -> "inspecting " + Serialization.asYaml(pod));
            for (Container container : pod.getSpec().getContainers()) {
                Set<String> secretContainerKeys = new TreeSet<>();
                List<EnvVar> env = container.getEnv();
                if (env != null) {
                    for (EnvVar envVar : env) {
                        EnvVarSource envVarSource = envVar.getValueFrom();
                        if (envVarSource != null) {
                            SecretKeySelector secretKeySelector = envVarSource.getSecretKeyRef();
                            if (secretKeySelector != null) {
                                secretContainerKeys.add(envVar.getName());
                            }
                            
                        }
                        
                    }
                    
                }
                
                if (!secretContainerKeys.isEmpty()) {
                    String containerName = container.getName();
                    LOGGER.fine(() -> "looking for " + slave.getNamespace() + "/" + slave.getPodName() + "/" + containerName + " secrets named " + secretContainerKeys);
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    Semaphore semaphore = new Semaphore(0);
                    Boolean unix = c.isUnix();
                    if (unix == null) {
                        return null;
                    }
                    
                    try (OutputStream errs = new LogTaskListener(LOGGER, Level.FINE).getLogger(); ExecWatch exec = slave.getKubernetesCloud().connect().pods().inNamespace(slave.getNamespace()).withName(slave.getPodName()).inContainer(containerName) .writingOutput(baos).writingError(errs).writingErrorChannel(errs) .usingListener(new ExecListener() { @Override public void onFailure(Throwable t, Response response) { semaphore.release(); } @Override public void onClose(int code, String reason) { semaphore.release(); } }) .exec(unix ? new String[] {"env"} : new String[] {"cmd", "/c", "set"})) {
                        if (!semaphore.tryAcquire(10, TimeUnit.SECONDS)) {
                            LOGGER.fine(() -> "time out trying to find environment from " + slave.getNamespace() + "/" + slave.getPodName() + "/" + containerName);
                        }
                        
                    }
                     catch (RuntimeException | KubernetesAuthException x) {
                        LOGGER.log(Level.FINE, "failed to find environment from " + slave.getNamespace() + "/" + slave.getPodName() + "/" + containerName, x);
                    }
                    
                    for (String line : baos.toString(StandardCharsets.UTF_8.name()).split("\r?\n")) {
                        int equals = line.indexOf('=');
                        if (equals != -1) {
                            String key = line.substring(0, equals);
                            if (secretContainerKeys.contains(key)) {
                                LOGGER.fine(() -> "found value for " + key);
                                String value = line.substring(equals + 1);
                                if (!value.isEmpty()) {
                                    values.add(value);
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
            return values;
        }
        
    }
    
}


