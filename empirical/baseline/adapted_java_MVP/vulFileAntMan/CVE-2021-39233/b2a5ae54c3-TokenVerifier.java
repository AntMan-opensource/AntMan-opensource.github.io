package org.apache.hadoop.hdds.security.token;
import com.google.common.base.Strings;
import org.apache.hadoop.hdds.annotation.InterfaceAudience;
import org.apache.hadoop.hdds.annotation.InterfaceStability;
import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerCommandRequestProto;
import org.apache.hadoop.hdds.security.exception.SCMSecurityException;
import org.apache.hadoop.hdds.security.x509.SecurityConfig;
import org.apache.hadoop.hdds.security.x509.certificate.client.CertificateClient;
import org.apache.hadoop.security.token.Token;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
public interface TokenVerifier {
  void verify(String user, Token<?> token, ContainerCommandRequestProto cmd) throws SCMSecurityException;
  default void verify(ContainerCommandRequestProto cmd, String user, String encodedToken) throws SCMSecurityException {
    if (Strings.isNullOrEmpty(encodedToken)) {
      throw new BlockTokenException("Failed to find any token (empty or " + "null.)");
    }
    
    final Token<?> token = new Token<>();
    try {
      token.decodeFromUrlString(encodedToken);
    }
     catch (IOException ex) {
      throw new BlockTokenException("Failed to decode token : " + encodedToken);
    }
    
    verify(user, token, cmd);
  }
  
  static TokenVerifier create(SecurityConfig conf, CertificateClient certClient) {
    if (!conf.isBlockTokenEnabled() && !conf.isContainerTokenEnabled()) {
      return new NoopTokenVerifier();
    }
    
    List<TokenVerifier> list = new LinkedList<>();
    list.add(new BlockTokenVerifier(conf, certClient));
    list.add(new ContainerTokenVerifier(conf, certClient));
    return new CompositeTokenVerifier(list);
  }
  
}


