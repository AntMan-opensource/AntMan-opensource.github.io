package com.hazelcast.client.impl.protocol.task.cache;
import com.hazelcast.cache.impl.CacheContext;
import com.hazelcast.cache.impl.CacheService;
import com.hazelcast.client.impl.ClientEndpoint;
import com.hazelcast.client.impl.protocol.ClientMessage;
import com.hazelcast.client.impl.protocol.codec.CacheAddNearCacheInvalidationListenerCodec;
import com.hazelcast.client.impl.protocol.task.AbstractAddListenerMessageTask;
import com.hazelcast.instance.impl.Node;
import com.hazelcast.internal.nearcache.impl.invalidation.Invalidation;
import com.hazelcast.internal.nio.Connection;
import com.hazelcast.internal.serialization.Data;
import java.security.Permission;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;
public class CacheAddNearCacheInvalidationListenerTask extends AbstractAddListenerMessageTask<CacheAddNearCacheInvalidationListenerCodec.RequestParameters> {
    public CacheAddNearCacheInvalidationListenerTask(ClientMessage clientMessage, Node node, Connection connection) {
        super(clientMessage, node, connection);
    }
    
    protected CompletableFuture<UUID> processInternal() {
        CacheService cacheService = getService(CacheService.SERVICE_NAME);
        CacheContext cacheContext = cacheService.getOrCreateCacheContext(parameters.name);
        NearCacheInvalidationListener listener = new NearCacheInvalidationListener(endpoint, cacheContext, nodeEngine.getLocalMember().getUuid(), clientMessage.getCorrelationId());
        return parameters.localOnly ? newCompletedFuture( cacheService.registerLocalListener(parameters.name, listener)) : (CompletableFuture<UUID>) cacheService .registerListenerAsync(parameters.name, listener);
    }
    
    private final class NearCacheInvalidationListener extends AbstractCacheClientNearCacheInvalidationListener {
        NearCacheInvalidationListener(ClientEndpoint endpoint, CacheContext cacheContext, UUID localMemberUuid, long correlationId) {
            super(endpoint, cacheContext, localMemberUuid, correlationId);
        }
        
        protected ClientMessage encodeBatchInvalidation(String name, List<Data> keys, List<UUID> sourceUuids, List<UUID> partitionUuids, List<Long> sequences) {
            return CacheAddNearCacheInvalidationListenerCodec.encodeCacheBatchInvalidationEvent(name, keys, sourceUuids, partitionUuids, sequences);
        }
        
        protected ClientMessage encodeSingleInvalidation(String name, Data key, UUID sourceUuid, UUID partitionUuid, long sequence) {
            return CacheAddNearCacheInvalidationListenerCodec.encodeCacheInvalidationEvent(name, key, sourceUuid, partitionUuid, sequence);
        }
        
        protected void sendMessageWithOrderKey(ClientMessage clientMessage, Object orderKey) {
            sendClientMessage(orderKey, clientMessage);
        }
        
        protected boolean canSendInvalidation(Invalidation invalidation) {
            return true;
        }
        
    }
    
    protected CacheAddNearCacheInvalidationListenerCodec.RequestParameters decodeClientMessage(ClientMessage clientMessage) {
        return CacheAddNearCacheInvalidationListenerCodec.decodeRequest(clientMessage);
    }
    
    protected ClientMessage encodeResponse(Object response) {
        return CacheAddNearCacheInvalidationListenerCodec.encodeResponse((UUID) response);
    }
    
    public String getDistributedObjectName() {
        return parameters.name;
    }
    
    public String getMethodName() {
        return null;
    }
    
    public Object[] getParameters() {
        return null;
    }
    
    public String getServiceName() {
        return CacheService.SERVICE_NAME;
    }
    
    public Permission getRequiredPermission() {
        return null;
    }
    
}


