package org.opensearch.index.store.remote.filecache;
import org.opensearch.index.store.remote.utils.cache.CacheUsage;
import org.opensearch.index.store.remote.utils.cache.RefCountedCache;
import org.opensearch.index.store.remote.utils.cache.SegmentedCache;
import org.opensearch.index.store.remote.utils.cache.stats.CacheStats;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.function.BiFunction;
import static org.opensearch.index.store.remote.directory.RemoteSnapshotDirectoryFactory.LOCAL_STORE_LOCATION;
public class FileCache implements RefCountedCache<Path, CachedIndexInput> {
    private final SegmentedCache<Path, CachedIndexInput> theCache;
    public FileCache(SegmentedCache<Path, CachedIndexInput> cache) {
        this.theCache = cache;
    }
    
    public long capacity() {
        return theCache.capacity();
    }
    
    public CachedIndexInput put(Path filePath, CachedIndexInput indexInput) {
        return theCache.put(filePath, indexInput);
    }
    
    public void putAll(Map<? extends Path, ? extends CachedIndexInput> m) {
        theCache.putAll(m);
    }
    
    public CachedIndexInput computeIfPresent( Path key, BiFunction<? super Path, ? super CachedIndexInput, ? extends CachedIndexInput> remappingFunction ) {
        return theCache.computeIfPresent(key, remappingFunction);
    }
    
    public CachedIndexInput get(Path filePath) {
        return theCache.get(filePath);
    }
    
    public void remove(final Path filePath) {
        theCache.remove(filePath);
    }
    
    public void removeAll(Iterable<? extends Path> keys) {
        theCache.removeAll(keys);
    }
    
    public void clear() {
        theCache.clear();
    }
    
    public long size() {
        return theCache.size();
    }
    
    public void incRef(Path key) {
        theCache.incRef(key);
    }
    
    public void decRef(Path key) {
        theCache.decRef(key);
    }
    
    public long prune() {
        return theCache.prune();
    }
    
    public CacheUsage usage() {
        return theCache.usage();
    }
    
    public CacheStats stats() {
        return theCache.stats();
    }
    
    public void restoreFromDirectory(List<Path> fileCacheDataPaths) {
        fileCacheDataPaths.stream() .filter(Files::isDirectory) .map(path -> path.resolve(LOCAL_STORE_LOCATION)) .filter(Files::isDirectory) .flatMap(dir -> {
                try {
                    return Files.list(dir);
                }
                 catch (IOException e) {
                    throw new UncheckedIOException( "Unable to process file cache directory. Please clear the file cache for node startup.", e );
                }
                
            }
) .filter(Files::isRegularFile) .forEach(path -> {
                try {
                    put(path.toAbsolutePath(), new FileCachedIndexInput.ClosedIndexInput(Files.size(path)));
                }
                 catch (IOException e) {
                    throw new UncheckedIOException( "Unable to retrieve cache file details. Please clear the file cache for node startup.", e );
                }
                
            }
            
);
    }
    
}


