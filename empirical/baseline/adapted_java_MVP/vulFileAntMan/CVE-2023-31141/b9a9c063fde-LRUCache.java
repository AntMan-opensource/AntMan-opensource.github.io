package org.opensearch.index.store.remote.utils.cache;
import org.opensearch.common.cache.RemovalListener;
import org.opensearch.common.cache.RemovalNotification;
import org.opensearch.common.cache.RemovalReason;
import org.opensearch.common.cache.Weigher;
import org.opensearch.index.store.remote.utils.cache.stats.CacheStats;
import org.opensearch.index.store.remote.utils.cache.stats.DefaultStatsCounter;
import org.opensearch.index.store.remote.utils.cache.stats.StatsCounter;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiFunction;
class LRUCache<K, V> implements RefCountedCache<K, V> {
    private final long capacity;
    private final HashMap<K, Node<K, V>> data;
    private final LinkedDeque<Node<K, V>> lru;
    private final RemovalListener<K, V> listener;
    private final Weigher<V> weigher;
    private final StatsCounter<K> statsCounter;
    private volatile ReentrantLock lock;
    private long usage;
    private long activeUsage;
    static class Node<K, V> implements Linked<Node<K, V>> {
        final K key;
        V value;
        long weight;
        Node<K, V> prev;
        Node<K, V> next;
        int refCount;
        Node(K key, V value, long weight) {
            this.key = key;
            this.value = value;
            this.weight = weight;
            this.prev = null;
            this.next = null;
            this.refCount = 0;
        }
        
        public Node<K, V> getPrevious() {
            return prev;
        }
        
        public void setPrevious(Node<K, V> prev) {
            this.prev = prev;
        }
        
        public Node<K, V> getNext() {
            return next;
        }
        
        public void setNext(Node<K, V> next) {
            this.next = next;
        }
        
        public boolean evictable() {
            return (refCount == 0);
        }
        
        V getValue() {
            return value;
        }
        
    }
    
    public LRUCache(long capacity, RemovalListener<K, V> listener, Weigher<V> weigher) {
        this.capacity = capacity;
        this.listener = listener;
        this.weigher = weigher;
        this.data = new HashMap<>();
        this.lru = new LinkedDeque<>();
        this.lock = new ReentrantLock();
        this.statsCounter = new DefaultStatsCounter<>();
    }
    
    public V get(K key) {
        Objects.requireNonNull(key);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.get(key);
            if (node == null) {
                statsCounter.recordMisses(key, 1);
                return null;
            }
            
            if (node.evictable()) {
                lru.moveToBack(node);
            }
            
            statsCounter.recordHits(key, 1);
            return node.value;
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public V put(K key, V value) {
        Objects.requireNonNull(key);
        Objects.requireNonNull(value);
        final long weight = weigher.weightOf(value);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.get(key);
            if (node != null) {
                final V oldValue = node.value;
                final long oldWeight = node.weight;
                node.value = value;
                node.weight = weight;
                final long weightDiff = weight - oldWeight;
                if (node.refCount > 0) {
                    activeUsage += weightDiff;
                }
                
                if (node.evictable()) {
                    lru.moveToBack(node);
                }
                
                usage += weightDiff;
                statsCounter.recordReplacement();
                listener.onRemoval(new RemovalNotification<>(key, oldValue, RemovalReason.REPLACED));
                evict();
                return oldValue;
            }
             else {
                Node<K, V> newNode = new Node<>(key, value, weight);
                data.put(key, newNode);
                lru.add(newNode);
                usage += weight;
                evict();
                return null;
            }
            
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()){
            put(e.getKey(), e.getValue());
}
    }
    
    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        Objects.requireNonNull(key);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.get(key);
            if (node != null && node.value != null) {
                V v = remappingFunction.apply(key, node.value);
                if (v != null) {
                    final V oldValue = node.value;
                    final long oldWeight = node.weight;
                    final long weight = weigher.weightOf(v);
                    node.value = v;
                    node.weight = weight;
                    final long weightDiff = weight - oldWeight;
                    if (node.evictable()) {
                        lru.moveToBack(node);
                    }
                    
                    if (node.refCount > 0) {
                        activeUsage += weightDiff;
                    }
                    
                    usage += weightDiff;
                    statsCounter.recordHits(key, 1);
                    if (oldValue != node.value) {
                        statsCounter.recordReplacement();
                        listener.onRemoval(new RemovalNotification<>(node.key, oldValue, RemovalReason.REPLACED));
                    }
                    
                    evict();
                    return v;
                }
                 else {
                    data.remove(key);
                    if (node.refCount > 0) {
                        activeUsage -= node.weight;
                    }
                    
                    usage -= node.weight;
                    if (node.evictable()) {
                        lru.remove(node);
                    }
                    
                    statsCounter.recordRemoval(node.weight);
                    listener.onRemoval(new RemovalNotification<>(node.key, node.value, RemovalReason.EXPLICIT));
                }
                
            }
            
            statsCounter.recordMisses(key, 1);
            return null;
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public void remove(K key) {
        Objects.requireNonNull(key);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.remove(key);
            if (node != null) {
                if (node.refCount > 0) {
                    activeUsage -= node.weight;
                }
                
                usage -= node.weight;
                if (node.evictable()) {
                    lru.remove(node);
                }
                
                statsCounter.recordRemoval(node.weight);
                listener.onRemoval(new RemovalNotification<>(node.key, node.value, RemovalReason.EXPLICIT));
            }
            
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public void removeAll(Iterable<? extends K> keys) {
        for (K key : keys) {
            remove(key);
        }
        
    }
    
    public void clear() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            usage = 0L;
            activeUsage = 0L;
            lru.clear();
            for (Node<K, V> node : data.values()) {
                data.remove(node.key);
                statsCounter.recordRemoval(node.weight);
                listener.onRemoval(new RemovalNotification<>(node.key, node.value, RemovalReason.EXPLICIT));
            }
            
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public long size() {
        return data.size();
    }
    
    public void incRef(K key) {
        Objects.requireNonNull(key);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.get(key);
            if (node != null) {
                if (node.refCount == 0) {
                    activeUsage += node.weight;
                }
                
                if (node.evictable()) {
                    lru.remove(node);
                }
                
                node.refCount++;
            }
            
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public void decRef(K key) {
        Objects.requireNonNull(key);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = data.get(key);
            if (node != null && node.refCount > 0) {
                node.refCount--;
                if (node.evictable()) {
                    lru.add(node);
                }
                
                if (node.refCount == 0) {
                    activeUsage -= node.weight;
                }
                
            }
            
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public long prune() {
        long sum = 0L;
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Node<K, V> node = lru.peek();
            while (node != null) {
                data.remove(node.key, node);
                sum += node.weight;
                statsCounter.recordRemoval(node.weight);
                listener.onRemoval(new RemovalNotification<>(node.key, node.value, RemovalReason.EXPLICIT));
                Node<K, V> tmp = node;
                node = node.getNext();
                lru.remove(tmp);
            }
            
            usage -= sum;
        }
         finally {
            lock.unlock();
        }
        
        return sum;
    }
    
    public CacheUsage usage() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return new CacheUsage(usage, activeUsage);
        }
         finally {
            lock.unlock();
        }
        
    }
    
    public CacheStats stats() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return statsCounter.snapshot();
        }
         finally {
            lock.unlock();
        }
        
    }
    
    boolean hasOverflowed() {
        return usage >= capacity;
    }
    
    void evict() {
        while (hasOverflowed()) {
            final Node<K, V> node = lru.poll();
            if (node == null) {
                return;
            }
            
            data.remove(node.key, node);
            usage -= node.weight;
            statsCounter.recordEviction(node.weight);
            listener.onRemoval(new RemovalNotification<>(node.key, node.value, RemovalReason.CAPACITY));
        }
        
    }
    
}


