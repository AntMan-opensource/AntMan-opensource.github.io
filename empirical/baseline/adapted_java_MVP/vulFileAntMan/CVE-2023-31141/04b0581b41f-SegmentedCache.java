package org.opensearch.index.store.remote.utils.cache;
import org.opensearch.common.cache.RemovalListener;
import org.opensearch.common.cache.RemovalNotification;
import org.opensearch.common.cache.Weigher;
import org.opensearch.index.store.remote.utils.cache.stats.CacheStats;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
public class SegmentedCache<K, V> implements RefCountedCache<K, V> {
    private static final int HASH_BITS = 0x7fffffff;
    private static final int ceilingNextPowerOfTwo(int x) {
        return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
    }
    
    private final long capacity;
    private final long perSegmentCapacity;
    private final RefCountedCache<K, V>[] table;
    private final int segmentMask;
    private final Weigher<V> weigher;
    public SegmentedCache(Builder<K, V> builder) {
        this.capacity = builder.capacity;
        final int segments = ceilingNextPowerOfTwo(builder.concurrencyLevel);
        this.segmentMask = segments - 1;
        this.table = newSegmentArray(segments);
        this.perSegmentCapacity = (capacity + (segments - 1)) / segments;
        this.weigher = builder.weigher;
        for (int i = 0; i < table.length; i++) {
            table[i] = new LRUCache<>(perSegmentCapacity, builder.listener, builder.weigher);
        }
        
    }
    
    @SuppressWarnings("unchecked")
    final RefCountedCache<K, V>[] newSegmentArray(int size) {
        return new RefCountedCache[size];
    }
    
    RefCountedCache<K, V> segmentFor(K key) {
        int h = key.hashCode();
        h = ((h >>> 16) ^ h) * 0x45d9f3b;
        h = ((h >>> 16) ^ h) * 0x45d9f3b;
        h = (h >>> 16) ^ h;
        return table[h & HASH_BITS & segmentMask];
    }
    
    public long capacity() {
        return capacity;
    }
    
    public V get(K key) {
        if (key == null) throw new NullPointerException();
        return segmentFor(key).get(key);
    }
    
    public V put(K key, V value) {
        if (key == null || value == null) throw new NullPointerException();
        return segmentFor(key).put(key, value);
    }
    
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()){
            put(e.getKey(), e.getValue());
}
    }
    
    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null) throw new NullPointerException();
        return segmentFor(key).computeIfPresent(key, remappingFunction);
    }
    
    public void remove(K key) {
        if (key == null) throw new NullPointerException();
        segmentFor(key).remove(key);
    }
    
    public void removeAll(Iterable<? extends K> keys) {
        for (K k : keys){
            remove(k);
}
    }
    
    public void clear() {
        for (RefCountedCache<K, V> cache : table) {
            cache.clear();
        }
        
    }
    
    public long size() {
        long size = 0;
        for (RefCountedCache<K, V> cache : table) {
            size += cache.size();
        }
        
        return size;
    }
    
    public void incRef(K key) {
        if (key == null) throw new NullPointerException();
        segmentFor(key).incRef(key);
    }
    
    public void decRef(K key) {
        if (key == null) throw new NullPointerException();
        segmentFor(key).decRef(key);
    }
    
    public long prune() {
        long sum = 0L;
        for (RefCountedCache<K, V> cache : table) {
            sum += cache.prune();
        }
        
        return sum;
    }
    
    public CacheUsage usage() {
        long usage = 0L;
        long activeUsage = 0L;
        for (RefCountedCache<K, V> cache : table) {
            CacheUsage c = cache.usage();
            usage += c.usage();
            activeUsage += c.activeUsage();
        }
        
        return new CacheUsage(usage, activeUsage);
    }
    
    public CacheStats stats() {
        long hitCount = 0L;
        long missCount = 0L;
        long removeCount = 0L;
        long removeWeight = 0L;
        long replaceCount = 0L;
        long evictionCount = 0L;
        long evictionWeight = 0L;
        for (RefCountedCache<K, V> cache : table) {
            CacheStats c = cache.stats();
            hitCount += c.hitCount();
            missCount += c.missCount();
            removeCount += c.removeCount();
            removeWeight += c.removeWeight();
            replaceCount += c.replaceCount();
            evictionCount += c.evictionCount();
            evictionWeight += c.evictionWeight();
        }
        
        return new CacheStats(hitCount, missCount, removeCount, removeWeight, replaceCount, evictionCount, evictionWeight);
    }
    
    enum SingletonWeigher implements Weigher<Object> {
        INSTANCE;
        public long weightOf(Object value) {
            return 1;
        }
        
    }
    
    enum DiscardingListener implements RemovalListener<Object, Object> {
        INSTANCE;
        public void onRemoval(RemovalNotification<Object, Object> notification) {
        }
        
    }
    
    public long getPerSegmentCapacity() {
        return perSegmentCapacity;
    }
    
    public Weigher<V> getWeigher() {
        return weigher;
    }
    
    public static final class Builder<K, V> {
        static final int DEFAULT_CONCURRENCY_LEVEL = Runtime.getRuntime().availableProcessors();
        RemovalListener<K, V> listener;
        Weigher<V> weigher;
        int concurrencyLevel;
        long capacity;
        @SuppressWarnings("unchecked")
        Builder() {
            capacity = -1;
            weigher = (Weigher<V>) SingletonWeigher.INSTANCE;
            concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;
            listener = (RemovalListener<K, V>) DiscardingListener.INSTANCE;
        }
        
        public Builder<K, V> capacity(long capacity) {
            checkArgument(capacity >= 0, "capacity has to be greater or equal to 0");
            this.capacity = capacity;
            return this;
        }
        
        public Builder<K, V> concurrencyLevel(int concurrencyLevel) {
            checkArgument(concurrencyLevel > 0, "concurrencyLevel has to be greater than 0");
            this.concurrencyLevel = concurrencyLevel;
            return this;
        }
        
        public Builder<K, V> listener(RemovalListener<K, V> listener) {
            Objects.requireNonNull(listener);
            this.listener = listener;
            return this;
        }
        
        public Builder<K, V> weigher(Weigher<V> weigher) {
            Objects.requireNonNull(weigher);
            this.weigher = weigher;
            return this;
        }
        
        private static void checkArgument(boolean expression, String message) {
            if (!expression) {
                throw new IllegalArgumentException(message);
            }
            
        }
        
        public SegmentedCache<K, V> build() {
            return new SegmentedCache<>(this);
        }
        
    }
    
    public static <K, V> Builder<K, V> builder() {
        return new Builder<>();
    }
    
}


