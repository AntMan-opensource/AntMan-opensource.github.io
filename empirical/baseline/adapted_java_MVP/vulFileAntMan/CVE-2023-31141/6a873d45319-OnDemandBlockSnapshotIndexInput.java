package org.opensearch.index.store.remote.file;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.lucene.store.FSDirectory;
import org.apache.lucene.store.IndexInput;
import org.opensearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo;
import org.opensearch.index.store.remote.utils.BlobFetchRequest;
import org.opensearch.index.store.remote.utils.TransferManager;
import java.io.IOException;
public class OnDemandBlockSnapshotIndexInput extends OnDemandBlockIndexInput {
    private static final Logger logger = LogManager.getLogger(OnDemandBlockSnapshotIndexInput.class);
    final TransferManager transferManager;
    protected final FileInfo fileInfo;
    protected final FSDirectory directory;
    protected final String fileName;
    protected final long partSize;
    protected final long originalFileSize;
    public OnDemandBlockSnapshotIndexInput(FileInfo fileInfo, FSDirectory directory, TransferManager transferManager) {
        this( "BlockedSnapshotIndexInput(path=\"" + directory.getDirectory().toString() + "/" + fileInfo.physicalName() + "\", " + "offset=" + 0 + ", length= " + fileInfo.length() + ")", fileInfo, 0L, fileInfo.length(), false, directory, transferManager );
    }
    
    public OnDemandBlockSnapshotIndexInput( String resourceDescription, FileInfo fileInfo, long offset, long length, boolean isClone, FSDirectory directory, TransferManager transferManager ) {
        this( OnDemandBlockIndexInput.builder().resourceDescription(resourceDescription).isClone(isClone).offset(offset).length(length), fileInfo, directory, transferManager );
    }
    
    OnDemandBlockSnapshotIndexInput( OnDemandBlockIndexInput.Builder builder, FileInfo fileInfo, FSDirectory directory, TransferManager transferManager ) {
        super(builder);
        this.transferManager = transferManager;
        this.fileInfo = fileInfo;
        this.partSize = fileInfo.partSize().getBytes();
        this.fileName = fileInfo.physicalName();
        this.directory = directory;
        this.originalFileSize = fileInfo.length();
    }
    
    protected OnDemandBlockSnapshotIndexInput buildSlice(String sliceDescription, long offset, long length) {
        return new OnDemandBlockSnapshotIndexInput( OnDemandBlockIndexInput.builder() .blockSizeShift(blockSizeShift) .isClone(true) .offset(this.offset + offset) .length(length) .resourceDescription(sliceDescription), fileInfo, directory, transferManager );
    }
    
    protected IndexInput fetchBlock(int blockId) throws IOException {
        final String blockFileName = fileName + "." + blockId;
        final long blockStart = getBlockStart(blockId);
        final long blockEnd = blockStart + getActualBlockSize(blockId);
        final int part = (int) (blockStart / partSize);
        final long partStart = part * partSize;
        final long position = blockStart - partStart;
        final long length = blockEnd - blockStart;
        BlobFetchRequest blobFetchRequest = BlobFetchRequest.builder() .position(position) .length(length) .blobName(fileInfo.partName(part)) .directory(directory) .fileName(blockFileName) .build();
        try {
            return transferManager.fetchBlob(blobFetchRequest);
        }
         catch (InterruptedException e) {
            logger.error("Interrupted while fetching [{}]", blobFetchRequest);
            Thread.currentThread().interrupt();
            throw new IllegalStateException(e);
        }
        
    }
    
    public OnDemandBlockSnapshotIndexInput clone() {
        OnDemandBlockSnapshotIndexInput clone = buildSlice("clone", 0L, this.length);
        clone.cloneBlock(this);
        return clone;
    }
    
    protected long getActualBlockSize(int blockId) {
        return (blockId != getBlock(originalFileSize - 1)) ? blockSize : getBlockOffset(originalFileSize - 1) + 1;
    }
    
}


