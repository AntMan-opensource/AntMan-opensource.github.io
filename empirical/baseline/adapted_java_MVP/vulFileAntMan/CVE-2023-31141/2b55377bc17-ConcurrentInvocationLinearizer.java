package org.opensearch.index.store.remote.utils;
import java.io.IOException;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import org.opensearch.common.CheckedFunction;
class ConcurrentInvocationLinearizer<METHOD_PARAM_TYPE, RET_TYPE> {
    private final ConcurrentMap<METHOD_PARAM_TYPE, CompletableFuture<RET_TYPE>> invokeOnceCache = new ConcurrentHashMap<>();
    RET_TYPE linearize(METHOD_PARAM_TYPE input, CheckedFunction<METHOD_PARAM_TYPE, RET_TYPE, IOException> function) throws InterruptedException, IOException {
        try {
            return linearizeInternal(input, function).get();
        }
         catch (ExecutionException e) {
            if (e.getCause() instanceof IOException) {
                throw (IOException) e.getCause();
            }
             else if (e.getCause() instanceof RuntimeException) {
                throw (RuntimeException) e.getCause();
            }
             else if (e.getCause() instanceof Error) {
                throw (Error) e.getCause();
            }
            
            throw new RuntimeException("Unknown exception cause", e.getCause());
        }
        
    }
    
    CompletableFuture<RET_TYPE> linearizeInternal( METHOD_PARAM_TYPE input, CheckedFunction<METHOD_PARAM_TYPE, RET_TYPE, IOException> function ) {
        final CompletableFuture<RET_TYPE> newFuture = new CompletableFuture<>();
        final CompletableFuture<RET_TYPE> existing = invokeOnceCache.putIfAbsent(input, newFuture);
        if (existing == null) {
            try {
                newFuture.complete(function.apply(input));
            }
             catch (Throwable e) {
                newFuture.completeExceptionally(e);
            }
             finally {
                invokeOnceCache.remove(input);
            }
            
            return newFuture;
        }
         else {
            return existing;
        }
        
    }
    
    Map<METHOD_PARAM_TYPE, CompletableFuture<RET_TYPE>> getInvokeOnceCache() {
        return Collections.unmodifiableMap(invokeOnceCache);
    }
    
}


