package org.eclipse.lemminx.uriresolver;
import static org.eclipse.lemminx.utils.ExceptionUtils.getRootCause;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.eclipse.lemminx.uriresolver.CacheResourceDownloadingException.CacheResourceDownloadingError;
import org.eclipse.lemminx.uriresolver.InvalidURIException.InvalidURIError;
import org.eclipse.lemminx.utils.FilesUtils;
import org.eclipse.lemminx.utils.StringUtils;
import org.eclipse.lemminx.utils.platform.Platform;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.io.MoreFiles;
import com.google.common.io.RecursiveDeleteOption;
public class CacheResourcesManager {
	private static final String USER_AGENT_KEY = "User-Agent";
	private static final String USER_AGENT_VALUE = "LemMinX/"+Platform.getVersion().getVersionNumber() + " ("+Platform.getOS().getName() + " "+ Platform.getOS().getVersion()+")";
	protected final Cache<String, CacheResourceDownloadedException> unavailableURICache;
	private static final String CACHE_PATH = "cache";
	private static final Logger LOGGER = Logger.getLogger(CacheResourcesManager.class.getName());
	private final Map<String, CompletableFuture<Path>> resourcesLoading;
	private boolean useCache;
	private boolean downloadExternalResources;
	private final Set<String> protocolsForCahe;
	class ResourceInfo {
		String resourceURI;
		CompletableFuture<Path> future;
	}
	
	 public static class ResourceToDeploy {
		private final Path resourceCachePath;
		private final String resourceFromClasspath;
		 public ResourceToDeploy(String resourceURI, String resourceFromClasspath) {
			this(URI.create(resourceURI), resourceFromClasspath);
		}
		
		 public ResourceToDeploy(URI resourceURI, String resourceFromClasspath) {
			this.resourceCachePath = Paths.get(CACHE_PATH, resourceURI.getScheme(), resourceURI.getHost(), resourceURI.getPath());
			this.resourceFromClasspath = resourceFromClasspath.startsWith("/") ? resourceFromClasspath : "/" + resourceFromClasspath;
		}
		
		 public Path getDeployedPath() throws IOException {
			return FilesUtils.getDeployedPath(resourceCachePath);
		}
		
		 public String getResourceFromClasspath() {
			return resourceFromClasspath;
		}
		
	}
	
	public CacheResourcesManager() {
		this(CacheBuilder.newBuilder().maximumSize(100).expireAfterWrite(30, TimeUnit.SECONDS).build());
	}
	
	public CacheResourcesManager(Cache<String, CacheResourceDownloadedException> cache) {
		resourcesLoading = new HashMap<>();
		protocolsForCahe = new HashSet<>();
		unavailableURICache = cache;
		addDefaultProtocolsForCache();
		setDownloadExternalResources(true);
	}
	
	public Path getResource(final String resourceURI) throws IOException {
		Path resourceCachePath = getResourceCachePath(resourceURI);
		if (Files.exists(resourceCachePath)) {
			return resourceCachePath;
		}
		
		if (!isDownloadExternalResources()) {
			throw new CacheResourceDownloadingException(resourceURI, resourceCachePath, CacheResourceDownloadingError.DOWNLOAD_DISABLED, null, null);
		}
		
		if (!FilesUtils.isIncludedInDeployedPath(resourceCachePath)) {
			throw new CacheResourceDownloadingException(resourceURI, resourceCachePath, CacheResourceDownloadingError.RESOURCE_NOT_IN_DEPLOYED_PATH, null, null);
		}
		
		CacheResourceDownloadedException cacheException = unavailableURICache.getIfPresent(resourceURI);
		if (cacheException != null) {
			 throw cacheException;
		}
		
		CompletableFuture<Path> f = null;
		synchronized (resourcesLoading) {
			if (resourcesLoading.containsKey(resourceURI)) {
				CompletableFuture<Path> future = resourcesLoading.get(resourceURI);
				throw new CacheResourceDownloadingException(resourceURI, resourceCachePath, CacheResourceDownloadingError.RESOURCE_LOADING, future, null);
			}
			
			f = downloadResource(resourceURI, resourceCachePath);
			resourcesLoading.put(resourceURI, f);
		}
		
		if (f.getNow(null) == null) {
			throw new CacheResourceDownloadingException(resourceURI, resourceCachePath, CacheResourceDownloadingError.RESOURCE_LOADING, f, null);
		}
		
		return resourceCachePath;
	}
	
	private CompletableFuture<Path> downloadResource(final String resourceURI, Path resourceCachePath) {
		return CompletableFuture.supplyAsync(() -> {
			LOGGER.info("Downloading " + resourceURI + " to " + resourceCachePath + "...");
			long start = System.currentTimeMillis();
			URLConnection conn = null;
			try {
				String actualURI = resourceURI;
				URL url = new URL(actualURI);
				conn = url.openConnection();
				conn.setRequestProperty(USER_AGENT_KEY, USER_AGENT_VALUE);
				 int allowedRedirects = 5;
				while (conn.getHeaderField("Location") != null && allowedRedirects > 0)  {
					allowedRedirects--;
					url = new URL(actualURI = conn.getHeaderField("Location")); 
					conn = url.openConnection();
					conn.setRequestProperty(USER_AGENT_KEY, USER_AGENT_VALUE);
				}
				
				 Path path = Files.createTempFile(resourceCachePath.getFileName().toString(), ".lemminx");
				try (ReadableByteChannel rbc = Channels.newChannel(conn.getInputStream()); FileOutputStream fos = new FileOutputStream(path.toFile())) {
					fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
				}
				
				 Path dir = resourceCachePath.getParent();
				if (!Files.exists(dir)) {
					Files.createDirectories(dir);
				}
				
				Files.move(path, resourceCachePath);
				long elapsed = System.currentTimeMillis() - start;
				LOGGER.info("Downloaded " + resourceURI + " to " + resourceCachePath + " in " + elapsed + "ms");
			}
			 catch (Exception e) {
				 Throwable rootCause = getRootCause(e);
				String error = "[" + rootCause.getClass().getTypeName() + "] " + rootCause.getMessage();
				LOGGER.log(Level.SEVERE, "Error while downloading " + resourceURI + " to " + resourceCachePath + " : " + error);
				CacheResourceDownloadedException cacheException = new CacheResourceDownloadedException(resourceURI, resourceCachePath, e);
				unavailableURICache.put(resourceURI, cacheException);
				throw cacheException;
			}
			 finally {
				synchronized (resourcesLoading) {
					resourcesLoading.remove(resourceURI);
				}
				
				if (conn != null && conn instanceof HttpURLConnection) {
					((HttpURLConnection) conn).disconnect();
				}
				
			}
			
			return resourceCachePath;
		}
		
);
	}
	
	public static Path getResourceCachePath(String resourceURI) throws IOException {
		URI uri = null;
		try {
			uri = URI.create(resourceURI);
		}
		 catch (Exception e) {
			throw new InvalidURIException(resourceURI, InvalidURIError.ILLEGAL_SYNTAX, e);
		}
		
		return getResourceCachePath(uri);
	}
	
	public static Path getResourceCachePath(URI uri) throws IOException {
		 URI normalizedUri = uri.normalize();
		 if (normalizedUri.getPath().contains("/../")) {
			throw new InvalidURIException(uri.toString(), InvalidURIError.INVALID_PATH);
		}
		
		Path resourceCachePath = normalizedUri.getPort() > 0 ? Paths.get(CACHE_PATH, normalizedUri.getScheme(), normalizedUri.getHost(), String.valueOf(normalizedUri.getPort()), normalizedUri.getPath()) : Paths.get(CACHE_PATH, normalizedUri.getScheme(), normalizedUri.getHost(), normalizedUri.getPath());
		return FilesUtils.getDeployedPath(resourceCachePath);
	}
	
	 public static Path getResourceCachePath(ResourceToDeploy resource) throws IOException {
		Path outFile = resource.getDeployedPath();
		if (!outFile.toFile().exists()) {
			try (InputStream in = CacheResourcesManager.class .getResourceAsStream(resource.getResourceFromClasspath())) {
				FilesUtils.saveToFile(in, outFile);
			}
			
		}
		
		return outFile;
	}
	
	 public boolean canUseCache(String url) {
		return isUseCache() && isUseCacheFor(url);
	}
	
	 public void setUseCache(boolean useCache) {
		this.useCache = useCache;
	}
	
	 public boolean isUseCache() {
		return useCache;
	}
	
	public boolean isDownloadExternalResources() {
		return downloadExternalResources;
	}
	
	public void setDownloadExternalResources(boolean downloadExternalResources) {
		this.downloadExternalResources = downloadExternalResources;
	}
	
	 public void evictCache() throws IOException {
		 Path cachePath = FilesUtils.getDeployedPath(Paths.get(CACHE_PATH));
		if (Files.exists(cachePath)) {
			 MoreFiles.deleteDirectoryContents(cachePath, RecursiveDeleteOption.ALLOW_INSECURE);
		}
		
	}
	
	 public void addProtocolForCahe(String protocol) {
		protocolsForCahe.add(formatProtocol(protocol));
	}
	
	 public void removeProtocolForCahe(String protocol) {
		protocolsForCahe.remove(formatProtocol(protocol));
	}
	
	 private static String formatProtocol(String protocol) {
		if (!protocol.endsWith(":")) {
			return protocol + ":";
		}
		
		return protocol;
	}
	
	 private boolean isUseCacheFor(String url) {
		if (StringUtils.isEmpty(url)) {
			return false;
		}
		
		for (String protocol : protocolsForCahe) {
			if (url.startsWith(protocol)) {
				return true;
			}
			
		}
		
		return false;
	}
	
	 private void addDefaultProtocolsForCache() {
		addProtocolForCahe("http");
		addProtocolForCahe("https");
		addProtocolForCahe("ftp");
	}
	
}


