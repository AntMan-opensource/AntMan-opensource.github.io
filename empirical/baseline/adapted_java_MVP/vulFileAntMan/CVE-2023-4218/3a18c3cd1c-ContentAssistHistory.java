package org.eclipse.jdt.internal.ui.text.java;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Preferences;
import org.eclipse.jdt.core.Flags;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.ITypeHierarchy;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.ui.JavaPlugin;
import org.eclipse.jdt.internal.ui.JavaUIException;
import org.eclipse.jdt.internal.ui.JavaUIStatus;
public final class ContentAssistHistory {
	 private static final class ReaderWriter {
		private static final String NODE_ROOT= "history"; 
		private static final String NODE_LHS= "lhs"; 
		private static final String NODE_RHS= "rhs"; 
		private static final String ATTRIBUTE_NAME= "name"; 
		private static final String ATTRIBUTE_MAX_LHS= "maxLHS"; 
		private static final String ATTRIBUTE_MAX_RHS= "maxRHS"; 
		public void store(ContentAssistHistory history, StreamResult result) throws CoreException {
			try {
				DocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();
				DocumentBuilder builder= factory.newDocumentBuilder();
				Document document= builder.newDocument();
				Element rootElement = document.createElement(NODE_ROOT);
				rootElement.setAttribute(ATTRIBUTE_MAX_LHS, Integer.toString(history.fMaxLHS));
				rootElement.setAttribute(ATTRIBUTE_MAX_RHS, Integer.toString(history.fMaxRHS));
				document.appendChild(rootElement);
				for (Entry<String, MRUSet<String>> entry : history.fLHSCache.entrySet()) {
					String lhs = entry.getKey();
					Element lhsElement= document.createElement(NODE_LHS);
					lhsElement.setAttribute(ATTRIBUTE_NAME, lhs);
					rootElement.appendChild(lhsElement);
					for (String rhs : entry.getValue()) {
						Element rhsElement= document.createElement(NODE_RHS);
						rhsElement.setAttribute(ATTRIBUTE_NAME, rhs);
						lhsElement.appendChild(rhsElement);
					}
					
				}
				
				Transformer transformer=TransformerFactory.newInstance().newTransformer();
				transformer.setOutputProperty(OutputKeys.METHOD, "xml"); 
				transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); 
				transformer.setOutputProperty(OutputKeys.INDENT, "no"); 
				DOMSource source = new DOMSource(document);
				transformer.transform(source, result);
			}
			 catch (TransformerException | ParserConfigurationException e) {
				throw createException(e, JavaTextMessages.ContentAssistHistory_serialize_error);
			}
			
		}
		
		public ContentAssistHistory load(InputSource source) throws CoreException {
			Element root;
			try {
				DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();
				parser.setErrorHandler(new DefaultHandler());
				root = parser.parse(source).getDocumentElement();
			}
			 catch (SAXException | ParserConfigurationException | IOException e) {
				throw createException(e, JavaTextMessages.ContentAssistHistory_deserialize_error);
			}
			
			if (root == null || !NODE_ROOT.equalsIgnoreCase(root.getNodeName())){
				return null;
}
			int maxLHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_LHS), DEFAULT_TRACKED_LHS);
			int maxRHS= parseNaturalInt(root.getAttribute(ATTRIBUTE_MAX_RHS), DEFAULT_TRACKED_RHS);
			ContentAssistHistory history= new ContentAssistHistory(maxLHS, maxRHS);
			NodeList list= root.getChildNodes();
			int length= list.getLength();
			for (int i= 0; i < length; ++i) {
				Node lhsNode= list.item(i);
				if (lhsNode.getNodeType() == Node.ELEMENT_NODE) {
					Element lhsElement= (Element) lhsNode;
					if (NODE_LHS.equalsIgnoreCase(lhsElement.getNodeName())) {
						String lhs= lhsElement.getAttribute(ATTRIBUTE_NAME);
						if (lhs != null) {
							Set<String> cache= history.getCache(lhs);
							NodeList children= lhsElement.getChildNodes();
							int nRHS= children.getLength();
							for (int j= 0; j < nRHS; j++) {
								Node rhsNode= children.item(j);
								if (rhsNode.getNodeType() == Node.ELEMENT_NODE) {
									Element rhsElement= (Element) rhsNode;
									if (NODE_RHS.equalsIgnoreCase(rhsElement.getNodeName())) {
										String rhs= rhsElement.getAttribute(ATTRIBUTE_NAME);
										if (rhs != null) {
											cache.add(rhs);
										}
										
									}
									
								}
								
							}
							
						}
						
					}
					
				}
				
			}
			
			return history;
		}
		
		private int parseNaturalInt(String attribute, int defaultValue) {
			try {
				int integer= Integer.parseInt(attribute);
				if (integer > 0){
					return integer;
}
				return defaultValue;
			}
			 catch (NumberFormatException e) {
				return defaultValue;
			}
			
		}
		
		private JavaUIException createException(Exception e, String message) {
			return new JavaUIException(JavaUIStatus.createError(IStatus.ERROR, message, e));
		}
		
	}
	
	 private static final class MRUMap<K, V> extends LinkedHashMap<K, V> {
		private static final long serialVersionUID= 1L;
		private final int fMaxSize;
		 public MRUMap(int maxSize) {
			Assert.isLegal(maxSize > 0);
			fMaxSize= maxSize;
		}
		
		public V put(K key, V value) {
			V object= remove(key);
			super.put(key, value);
			return object;
		}
		
		protected boolean removeEldestEntry(Entry<K, V> eldest) {
			return size() > fMaxSize;
		}
		
	}
	
	 private static final class MRUSet<E> extends LinkedHashSet<E> {
		private static final long serialVersionUID= 1L;
		private final int fMaxSize;
		 public MRUSet(int maxSize) {
			Assert.isLegal(maxSize > 0);
			fMaxSize= maxSize;
		}
		
		public boolean add(E o) {
			if (remove(o)) {
				super.add(o);
				return false;
			}
			
			if (size() >= fMaxSize){
				remove(this.iterator().next());
}
			super.add(o);
			return true;
		}
		
	}
	
	 public static final class RHSHistory {
		private final LinkedHashMap<String, Integer> fHistory;
		private List<String> fList;
		RHSHistory(LinkedHashMap<String, Integer> history) {
			fHistory= history;
		}
		
		 public float getRank(String type) {
			if (fHistory == null){
				return 0.0F;
}
			Integer integer= fHistory.get(type);
			return integer == null ? 0.0F : integer.floatValue() / fHistory.size();
		}
		
		 public int size() {
			return fHistory == null ? 0 : fHistory.size();
		}
		
		 public List<String> getTypes() {
			if (fHistory == null){
				return Collections.emptyList();
}
			if (fList == null) {
				fList= Collections.unmodifiableList(new ArrayList<>(fHistory.keySet()));
			}
			
			return fList;
		}
		
	}
	
	private static final RHSHistory EMPTY_HISTORY= new RHSHistory(null);
	private static final int DEFAULT_TRACKED_LHS= 100;
	private static final int DEFAULT_TRACKED_RHS= 10;
	private static final Set<String> UNCACHEABLE;
	static {
		Set<String> uncacheable= new HashSet<>();
		uncacheable.add("java.lang.Object"); 
		uncacheable.add("java.lang.Comparable"); 
		uncacheable.add("java.io.Serializable"); 
		uncacheable.add("java.io.Externalizable"); 
		UNCACHEABLE= Collections.unmodifiableSet(uncacheable);
	}
	
	private final LinkedHashMap<String, MRUSet<String>> fLHSCache;
	private final int fMaxLHS;
	private final int fMaxRHS;
	 public ContentAssistHistory(int maxLHS, int maxRHS) {
		Assert.isLegal(maxLHS > 0);
		Assert.isLegal(maxRHS > 0);
		fMaxLHS= maxLHS;
		fMaxRHS= maxRHS;
		fLHSCache= new MRUMap<>(fMaxLHS);
	}
	
	 public ContentAssistHistory() {
		this(DEFAULT_TRACKED_LHS, DEFAULT_TRACKED_RHS);
	}
	
	 public void remember(IType lhs, IType rhs) {
		Assert.isLegal(lhs != null);
		Assert.isLegal(rhs != null);
		try {
			if (!isCacheableRHS(rhs)){
				return;
}
			ITypeHierarchy hierarchy= rhs.newSupertypeHierarchy(getProgressMonitor());
			if (hierarchy.contains(lhs)) {
				 String rhsQualifiedName= rhs.getFullyQualifiedName();
				for (IType lhSide : hierarchy.getAllSupertypes(lhs)) {
					rememberInternal(lhSide, rhsQualifiedName);
				}
				
				rememberInternal(lhs, rhsQualifiedName);
			}
			
		}
		 catch (JavaModelException x) {
			JavaPlugin.log(x);
		}
		
	}
	
	 public RHSHistory getHistory(String lhs) {
		MRUSet<String> rhsCache= fLHSCache.get(lhs);
		if (rhsCache != null) {
			int count= rhsCache.size();
			LinkedHashMap<String, Integer> history= new LinkedHashMap<>((int) (count / 0.75));
			int rank= 1;
			for (Iterator<String> it= rhsCache.iterator(); it.hasNext(); rank++) {
				String type= it.next();
				history.put(type, rank);
			}
			
			return new RHSHistory(history);
		}
		
		return EMPTY_HISTORY;
	}
	
	 public Map<String, RHSHistory> getEntireHistory() {
		HashMap<String, RHSHistory> map= new HashMap<>((int) (fLHSCache.size() / 0.75));
		for (Entry<String, MRUSet<String>> entry : fLHSCache.entrySet()) {
			String lhs= entry.getKey();
			map.put(lhs, getHistory(lhs));
		}
		
		return Collections.unmodifiableMap(map);
	}
	
	private void rememberInternal(IType lhs, String rhsQualifiedName) throws JavaModelException {
		String lhsQualifiedName= lhs.getFullyQualifiedName();
		if (isCacheableLHS(lhs, lhsQualifiedName)){
			getCache(lhsQualifiedName).add(rhsQualifiedName);
}
	}
	
	private boolean isCacheableLHS(IType type, String qualifiedName) throws JavaModelException {
		return !Flags.isFinal(type.getFlags()) && !UNCACHEABLE.contains(qualifiedName);
	}
	
	private boolean isCacheableRHS(IType type) throws JavaModelException {
		return !type.isInterface() && !Flags.isAbstract(type.getFlags());
	}
	
	private Set<String> getCache(String lhs) {
		MRUSet<String> rhsCache= fLHSCache.get(lhs);
		if (rhsCache == null) {
			rhsCache= new MRUSet<>(fMaxRHS);
			fLHSCache.put(lhs, rhsCache);
		}
		
		return rhsCache;
	}
	
	private IProgressMonitor getProgressMonitor() {
		return new NullProgressMonitor();
	}
	
	 public static void store(ContentAssistHistory history, Preferences preferences, String key) throws CoreException {
		StringWriter writer= new StringWriter();
		new ReaderWriter().store(history, new StreamResult(writer));
		preferences.setValue(key, writer.toString());
	}
	
	 public static ContentAssistHistory load(Preferences preferences, String key) throws CoreException {
		String value= preferences.getString(key);
		if (value != null && value.length() > 0) {
			return new ReaderWriter().load(new InputSource(new StringReader(value)));
		}
		
		return null;
	}
	
}


