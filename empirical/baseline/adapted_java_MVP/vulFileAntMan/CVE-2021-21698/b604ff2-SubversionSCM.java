package hudson.scm;
import static hudson.Util.fixEmptyAndTrim;
import static hudson.scm.PollingResult.BUILD_NOW;
import static hudson.scm.PollingResult.NO_CHANGES;
import static java.util.logging.Level.FINE;
import static java.util.logging.Level.WARNING;
import com.cloudbees.jenkins.plugins.sshcredentials.SSHUserPrivateKey;
import com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey;
import com.cloudbees.plugins.credentials.Credentials;
import com.cloudbees.plugins.credentials.CredentialsMatchers;
import com.cloudbees.plugins.credentials.CredentialsNameProvider;
import com.cloudbees.plugins.credentials.CredentialsProvider;
import com.cloudbees.plugins.credentials.CredentialsScope;
import com.cloudbees.plugins.credentials.CredentialsStore;
import com.cloudbees.plugins.credentials.common.StandardCertificateCredentials;
import com.cloudbees.plugins.credentials.common.StandardCredentials;
import com.cloudbees.plugins.credentials.common.StandardListBoxModel;
import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;
import com.cloudbees.plugins.credentials.domains.Domain;
import com.cloudbees.plugins.credentials.domains.DomainRequirement;
import com.cloudbees.plugins.credentials.domains.DomainSpecification;
import com.cloudbees.plugins.credentials.domains.HostnameRequirement;
import com.cloudbees.plugins.credentials.domains.HostnameSpecification;
import com.cloudbees.plugins.credentials.domains.SchemeRequirement;
import com.cloudbees.plugins.credentials.domains.SchemeSpecification;
import com.cloudbees.plugins.credentials.domains.URIRequirementBuilder;
import com.cloudbees.plugins.credentials.impl.CertificateCredentialsImpl;
import com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.BulkChange;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.FilePath.FileCallable;
import hudson.Launcher;
import hudson.Util;
import hudson.init.InitMilestone;
import java.io.ByteArrayOutputStream;
import java.nio.charset.UnsupportedCharsetException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import hudson.model.AbstractBuild;
import hudson.model.AbstractDescribableImpl;
import hudson.model.AbstractProject;
import hudson.model.Descriptor;
import hudson.model.Item;
import hudson.model.ItemGroup;
import hudson.model.Job;
import hudson.model.JobProperty;
import hudson.model.ModelObject;
import hudson.model.Node;
import hudson.model.ParameterDefinition;
import hudson.model.ParameterValue;
import hudson.model.ParametersAction;
import hudson.model.ParametersDefinitionProperty;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.security.ACL;
import hudson.security.ACLContext;
import hudson.security.Permission;
import hudson.util.ListBoxModel;
import jenkins.model.Jenkins;
import hudson.remoting.Channel;
import hudson.remoting.VirtualChannel;
import hudson.scm.UserProvidedCredential.AuthenticationManagerImpl;
import hudson.scm.subversion.CheckoutUpdater;
import hudson.scm.subversion.Messages;
import hudson.scm.subversion.SvnHelper;
import hudson.scm.subversion.UpdateUpdater;
import hudson.scm.subversion.UpdateWithRevertUpdater;
import hudson.scm.subversion.WorkspaceUpdater;
import hudson.scm.subversion.WorkspaceUpdater.UpdateTask;
import hudson.scm.subversion.WorkspaceUpdaterDescriptor;
import hudson.util.FormValidation;
import hudson.util.LogTaskListener;
import hudson.util.MultipartFormDataParser;
import hudson.util.Scrambler;
import hudson.util.Secret;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.UUID;
import java.util.WeakHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.servlet.ServletException;
import javax.xml.transform.stream.StreamResult;
import jenkins.scm.impl.subversion.RemotableSVNErrorMessage;
import net.sf.json.JSONObject;
import org.apache.commons.beanutils.PropertyUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Chmod;
import org.kohsuke.stapler.AncestorInPath;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.export.Exported;
import org.kohsuke.stapler.export.ExportedBean;
import org.tmatesoft.svn.core.*;
import org.tmatesoft.svn.core.auth.*;
import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.dav.http.DefaultHTTPConnectionFactory;
import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;
import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;
import org.tmatesoft.svn.core.internal.wc.DefaultSVNOptions;
import org.tmatesoft.svn.core.internal.wc.SVNPath;
import org.tmatesoft.svn.core.internal.wc.admin.SVNAdminAreaFactory;
import org.tmatesoft.svn.core.io.SVNCapability;
import org.tmatesoft.svn.core.io.SVNRepository;
import org.tmatesoft.svn.core.io.SVNRepositoryFactory;
import org.tmatesoft.svn.core.io.ISVNSession;
import org.tmatesoft.svn.core.wc.SVNClientManager;
import org.tmatesoft.svn.core.wc.SVNInfo;
import org.tmatesoft.svn.core.wc.SVNRevision;
import org.tmatesoft.svn.core.wc.SVNWCClient;
import org.tmatesoft.svn.core.wc.SVNWCUtil;
import com.trilead.ssh2.DebugLogger;
import com.trilead.ssh2.SCPClient;
import com.trilead.ssh2.crypto.Base64;
import static java.util.stream.Collectors.toList;
import javax.annotation.Nonnull;
import jenkins.MasterToSlaveFileCallable;
import jenkins.security.Roles;
import jenkins.security.SlaveToMasterCallable;
import org.apache.commons.collections.CollectionUtils;
import org.jenkinsci.remoting.RoleChecker;
import org.kohsuke.stapler.interceptor.RequirePOST;
public class SubversionSCM extends SCM implements Serializable {
    private ModuleLocation[] locations = new ModuleLocation[0];
    private List<AdditionalCredentials> additionalCredentials;
    private final SubversionRepositoryBrowser browser;
    private String excludedRegions;
    private String includedRegions;
    private String excludedUsers;
    private String excludedRevprop;
    private String excludedCommitMessages;
    private WorkspaceUpdater workspaceUpdater;
    private String modules;
    private Boolean useUpdate;
    private Boolean doRevert;
    private boolean ignoreDirPropChanges;
    private boolean filterChangelog;
    private boolean quietOperation;
    private transient Map<Job, List<External>> projectExternalsCache;
    private transient boolean pollFromMaster = POLL_FROM_MASTER;
    public SubversionSCM(String[] remoteLocations, String[] localLocations, boolean useUpdate, SubversionRepositoryBrowser browser) {
        this(remoteLocations,localLocations, useUpdate, browser, null, null, null);
    }
    
    public SubversionSCM(String[] remoteLocations, String[] localLocations, boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {
        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, null, null, null);
    }
    
     public SubversionSCM(String[] remoteLocations, String[] localLocations, boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {
        this(ModuleLocation.parse(remoteLocations,localLocations,null,null), useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions) {
        this(locations, useUpdate, false, browser, excludedRegions, null, null, null);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop) {
        this(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, null);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, boolean useUpdate, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {
    	this(locations, useUpdate, false, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages) {
        this(locations, useUpdate, doRevert, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, null);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, boolean useUpdate, boolean doRevert, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages, String includedRegions) {
        this(locations, useUpdate?(doRevert?new UpdateWithRevertUpdater():new UpdateUpdater()):new CheckoutUpdater(), browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages, String includedRegions) {
      this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, false);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages, String includedRegions, boolean ignoreDirPropChanges) {
        this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages, includedRegions, ignoreDirPropChanges, false, null);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages, String includedRegions, boolean ignoreDirPropChanges, boolean filterChangelog, List<AdditionalCredentials> additionalCredentials) {
        this(locations, workspaceUpdater, browser, excludedRegions, excludedUsers, excludedRevprop, excludedCommitMessages,  includedRegions, ignoreDirPropChanges, filterChangelog, additionalCredentials, false);
    }
    
    public SubversionSCM(List<ModuleLocation> locations, WorkspaceUpdater workspaceUpdater, SubversionRepositoryBrowser browser, String excludedRegions, String excludedUsers, String excludedRevprop, String excludedCommitMessages, String includedRegions, boolean ignoreDirPropChanges, boolean filterChangelog, List<AdditionalCredentials> additionalCredentials, boolean quietOperation) {
        for (Iterator<ModuleLocation> itr = locations.iterator(); itr.hasNext(); ) {
            ModuleLocation ml = itr.next();
            String remote = Util.fixEmptyAndTrim(ml.remote);
            if (remote == null) {
                itr.remove();
            }
            
        }
        
        this.locations = locations.toArray(new ModuleLocation[0]);
        if (additionalCredentials == null) {
            this.additionalCredentials = null;
        }
         else {
            this.additionalCredentials = new ArrayList<>(additionalCredentials);
        }
        
        this.workspaceUpdater = workspaceUpdater;
        this.browser = browser;
        this.excludedRegions = excludedRegions;
        this.excludedUsers = excludedUsers;
        this.excludedRevprop = excludedRevprop;
        this.excludedCommitMessages = excludedCommitMessages;
        this.includedRegions = includedRegions;
        this.ignoreDirPropChanges = ignoreDirPropChanges;
        this.filterChangelog = filterChangelog;
        this.quietOperation = quietOperation;
    }
    
    public SubversionSCM(String svnUrl) {
        this(svnUrl, null, ".");
    }
    
    public SubversionSCM(String svnUrl, String local) {
        this(svnUrl, null, local);
    }
    
    public SubversionSCM(String svnUrl, String credentialId, String local) {
        this(new String[]{svnUrl}, new String[]{credentialId}, new String[]{local});
    }
    
    public SubversionSCM(String svnUrl, String credentialId, String local, WorkspaceUpdater workspaceUpdater, SubversionRepositoryBrowser browser) {
        this(ModuleLocation.parse(new String[]{svnUrl}, new String[]{credentialId}, new String[]{local}, null,null,null), workspaceUpdater, browser, null, null, null, null, null, false, false, null, false);
    }
    
    public SubversionSCM(String[] svnUrls, String[] locals) {
        this(svnUrls, null, locals);
    }
    
    public SubversionSCM(String[] svnUrls, String[] credentialIds, String[] locals) {
        this(ModuleLocation.parse(svnUrls, credentialIds, locals, null,null,null), true, false, null, null, null, null, null);
    }
    
    public String getModules() {
        return null;
    }
    
    public ModuleLocation[] getLocations() {
    	return getLocations(null, null);
    }
    
 public String getKey() {
        StringBuilder b = new StringBuilder("svn");
        for (ModuleLocation loc : getLocations()) {
            b.append(' ').append(loc.getURL());
        }
        
        return b.toString();
    }
    
    public List<AdditionalCredentials> getAdditionalCredentials() {
        List<AdditionalCredentials> result = new ArrayList<>();
        if (additionalCredentials != null) {
            result.addAll(additionalCredentials);
        }
        
        return result;
    }
    
    public WorkspaceUpdater getWorkspaceUpdater() {
        if (workspaceUpdater!=null){
            return workspaceUpdater;
}
        if (useUpdate!=null && !useUpdate){
            return new CheckoutUpdater();
}
        if (doRevert!=null && doRevert){
            return new UpdateWithRevertUpdater();
}
        return new UpdateUpdater();
    }
    
    public void setWorkspaceUpdater(WorkspaceUpdater workspaceUpdater) {
        this.workspaceUpdater = workspaceUpdater;
    }
    
    public ModuleLocation[] getLocations(AbstractBuild<?,?> build) {
        return getLocations(null, build);
    }
    
    public ModuleLocation[] getLocations(EnvVars env, Run<?,?> build) {
        if (modules != null) {
            List<ModuleLocation> oldLocations = new ArrayList<>();
            StringTokenizer tokens = new StringTokenizer(modules);
            while (tokens.hasMoreTokens()) {
                String remoteLoc = Util.removeTrailingSlash(tokens.nextToken());
                oldLocations.add(new ModuleLocation(remoteLoc, null));
            }
            
            locations = oldLocations.toArray(new ModuleLocation[0]);
            modules = null;
        }
        
        if(env == null && build == null) return locations;
        ModuleLocation[] outLocations = new ModuleLocation[locations.length];
        EnvVars env2 = env != null ? new EnvVars(env) : new EnvVars();
        if (build instanceof AbstractBuild) {
            env2.putAll(((AbstractBuild<?,?>) build).getBuildVariables());
        }
        
        EnvVars.resolve(env2);
        for (int i = 0; i < outLocations.length; i++) {
            outLocations[i] = locations[i].getExpandedLocation(env2);
        }
        
        return outLocations;
    }
    
    public ModuleLocation[] getProjectLocations(Job project) throws IOException {
        List<External> projectExternals = getExternals(project);
        ModuleLocation[] configuredLocations = getLocations();
        if (projectExternals.isEmpty()) {
            return configuredLocations;
        }
        
        List<ModuleLocation> allLocations = new ArrayList<>(configuredLocations.length + projectExternals.size());
        allLocations.addAll(Arrays.asList(configuredLocations));
        for (External external : projectExternals) {
            allLocations.add(new ModuleLocation(external.url, external.path));
        }
        
        return allLocations.toArray(new ModuleLocation[0]);
    }
    
    private List<External> getExternals(Job context) throws IOException {
        Map<Job, List<External>> projectExternalsCache = getProjectExternalsCache();
        List<External> projectExternals;
        synchronized (projectExternalsCache) {
            projectExternals = projectExternalsCache.get(context);
        }
        
        if (projectExternals == null) {
            projectExternals = SvnExternalsFileManager.parseExternalsFile(context);
            synchronized (projectExternalsCache) {
                if (!projectExternalsCache.containsKey(context)) {
                    projectExternalsCache.put(context, projectExternals);
                }
                
            }
            
        }
        
        return projectExternals;
    }
    
    public SubversionRepositoryBrowser getBrowser() {
        return browser;
    }
    
    public String getExcludedRegions() {
        return excludedRegions;
    }
    
    public String[] getExcludedRegionsNormalized() {
        return (excludedRegions == null || excludedRegions.trim().equals("")) ? null : excludedRegions.split("[\\r\\n]+");
    }
    
    private Pattern[] getExcludedRegionsPatterns() {
        String[] excluded = getExcludedRegionsNormalized();
        if (excluded != null) {
            Pattern[] patterns = new Pattern[excluded.length];
            int i = 0;
            for (String excludedRegion : excluded) {
                patterns[i++] = Pattern.compile(excludedRegion);
            }
            
            return patterns;
        }
        
        return new Pattern[0];
    }
    
    public String getIncludedRegions() {
        return includedRegions;
    }
    
    public String[] getIncludedRegionsNormalized() {
        return (includedRegions == null || includedRegions.trim().equals("")) ? null : includedRegions.split("[\\r\\n]+");
    }
    
    private Pattern[] getIncludedRegionsPatterns() {
        String[] included = getIncludedRegionsNormalized();
        if (included != null) {
            Pattern[] patterns = new Pattern[included.length];
            int i = 0;
            for (String includedRegion : included) {
                patterns[i++] = Pattern.compile(includedRegion);
            }
            
            return patterns;
        }
        
        return new Pattern[0];
    }
    
    public String getExcludedUsers() {
        return excludedUsers;
    }
    
    public Set<String> getExcludedUsersNormalized() {
        String s = fixEmptyAndTrim(excludedUsers);
        if (s==null){
            return Collections.emptySet();
}
        Set<String> users = new HashSet<>();
        for (String user : s.split("[\\r\\n]+")){
            users.add(user.trim());
}
        return users;
    }
    
    public String getExcludedRevprop() {
        return excludedRevprop;
    }
    
    private String getExcludedRevpropNormalized() {
        String s = fixEmptyAndTrim(getExcludedRevprop());
        if (s!=null)        return s;
        return getDescriptor().getGlobalExcludedRevprop();
    }
    
    public String getExcludedCommitMessages() {
        return excludedCommitMessages;
    }
    
    public String[] getExcludedCommitMessagesNormalized() {
        String s = fixEmptyAndTrim(excludedCommitMessages);
        return s == null ? new String[0] : s.split("[\\r\\n]+");
    }
    
    private Pattern[] getExcludedCommitMessagesPatterns() {
        String[] excluded = getExcludedCommitMessagesNormalized();
        Pattern[] patterns = new Pattern[excluded.length];
        int i = 0;
        for (String excludedCommitMessage : excluded) {
            patterns[i++] = Pattern.compile(excludedCommitMessage);
        }
        
        return patterns;
    }
    
    public boolean isIgnoreDirPropChanges() {
      return ignoreDirPropChanges;
    }
    
    public boolean isFilterChangelog() {
      return filterChangelog;
    }
    
    public boolean isQuietOperation() {
      return quietOperation;
    }
    
    public void setQuietOperation(boolean quietOperation) {
        this.quietOperation = quietOperation;
    }
    
    public void buildEnvironment(Run<?, ?> build, Map<String, String> env) {
        ModuleLocation[] svnLocations = getLocations(new EnvVars(env), build);
        try {
            Map<String,Long> revisions = parseSvnRevisionFile(build);
            Set<String> knownURLs = revisions.keySet();
            if(svnLocations.length==1) {
                String url = svnLocations[0].getURL();
                Long rev = revisions.get(url);
                if(rev!=null) {
                    env.put("SVN_REVISION",rev.toString());
                    env.put("SVN_URL",url);
                }
                 else if (!knownURLs.isEmpty()) {
                    LOGGER.log(WARNING, "no revision found corresponding to {0}; known: {1}", new Object[] {url, knownURLs});
                }
                
            }
            
            for(int i=0;i<svnLocations.length;i++) {
                String url = svnLocations[i].getURL();
                Long rev = revisions.get(url);
                if(rev!=null) {
                    env.put("SVN_REVISION_"+(i+1),rev.toString());
                    env.put("SVN_URL_"+(i+1),url);
                }
                 else if (!knownURLs.isEmpty()) {
                    LOGGER.log(WARNING, "no revision found corresponding to {0}; known: {1}", new Object[] {url, knownURLs});
                }
                
            }
            
        }
         catch (IOException e) {
            LOGGER.log(WARNING, "error building environment variables", e);
        }
        
    }
    
    private void calcChangeLog(Run<?,?> build, FilePath workspace, File changelogFile, SCMRevisionState baseline, TaskListener listener, Map<String, List<SubversionSCM.External>> externalsMap, EnvVars env) throws IOException, InterruptedException {
        if (baseline == null) {
            createEmptyChangeLog(changelogFile, listener, "log");
            return;
        }
        
        boolean created;
        try (OutputStream os = new BufferedOutputStream(new FileOutputStream(changelogFile))) {
            created = new SubversionChangeLogBuilder(build, workspace, (SVNRevisionState) baseline, env, listener, this).run(externalsMap, new StreamResult(os));
        }
        
        if(!created) createEmptyChangeLog(changelogFile, listener, "log");
    }
    
     static Map<String,Long> parseRevisionFile(Run<?,?> build) throws IOException {
        return parseRevisionFile(build,true,false);
    }
    
     Map<String,Long> parseSvnRevisionFile(Run<?,?> build) throws IOException {
        return parseRevisionFile(build);
    }
    
     static Map<String,Long> parseRevisionFile(Run<?,?> build, boolean findClosest, boolean prunePinnedExternals) throws IOException {
        Map<String,Long> revisions = new HashMap<>(); 
        Map<String,Long> pinnedRevisions = new HashMap<>(); 
        if (findClosest) {
            for (Run<?,?> b=build; b!=null; b=b.getPreviousBuild()) {
                if(getRevisionFile(b).exists()) {
                    build = b;
                    break;
                }
                
            }
            
        }
        {
            File file = getRevisionFile(build);
            if(!file.exists()) return revisions;
            try (BufferedReader br = new BufferedReader(new FileReader(file))) {
                String line;
                while((line=br.readLine())!=null) {
                	boolean isPinned = false;
                	int indexLast = line.length();
                	if (line.lastIndexOf("::p") == indexLast-3) {
                		isPinned = true;
                		indexLast -= 3;
                	}
                	
                	int index = line.lastIndexOf('/');
                    if(index<0) {
                        continue;   
                    }
                    
                    try {
                    	String url = line.substring(0, index);
                    	long revision = Long.parseLong(line.substring(index+1,indexLast));
                    	if (isPinned) {
                    		if (!prunePinnedExternals) {
                                Long oldRevision = pinnedRevisions.get(url);
                    			if (oldRevision == null){
                                    pinnedRevisions.put(url, revision);
}
                    		}
                    		
                    	}
                    	 else {
                            Long oldRevision = revisions.get(url);
                    		 if (oldRevision == null || oldRevision > revision) {
                                revisions.put(url, revision);
                            }
                            
                    	}
                    	
                	}
                	 catch (NumberFormatException e) {
                	     LOGGER.log(WARNING, "Error parsing line " + line, e);
                	}
                	
                }
                
                for( Map.Entry<String,Long> rev : pinnedRevisions.entrySet() ){
                    if(!revisions.containsKey(rev.getKey())){
                        revisions.put(rev.getKey(),rev.getValue());
                    }
                    
                }
                
            }
            
        }
        
        return revisions;
    }
    
    public boolean requiresWorkspaceForPolling() {
        return false;
    }
    
 public void checkout(Run build, Launcher launcher, FilePath workspace, final TaskListener listener, File changelogFile, SCMRevisionState baseline) throws IOException, InterruptedException {
        EnvVars env = build.getEnvironment(listener);
        if (build instanceof AbstractBuild) {
            EnvVarsUtils.overrideAll(env, ((AbstractBuild) build).getBuildVariables());
        }
        
        Map<String, List<External>> externalsMap = checkout(build,workspace,listener,env);
        List<External> externalsForAll = new ArrayList<>();
        if (externalsMap != null) {
          for (String moduleLocationRemote : externalsMap.keySet()) {
            externalsForAll.addAll(externalsMap.get(moduleLocationRemote));
          }
          
        }
        
        List<SvnInfoP> pList = workspace.act(new BuildRevisionMapTask(build, this, listener, externalsForAll, env));
        List<SvnInfo> revList = pList.stream().map(svnInfoP -> svnInfoP.info).collect(toList());
        try (PrintWriter w = new PrintWriter(new FileOutputStream(getRevisionFile(build)))) {
            for (SvnInfoP p: pList) {
                if (p.pinned) {
                    w.println( p.info.url +'/'+ p.info.revision + "::p");
                }
                 else {
                    w.println( p.info.url +'/'+ p.info.revision);
                }
                                        
            }
            
        }
        
        SvnExternalsFileManager.writeExternalsFile(build.getParent(), externalsForAll);
        Map<Job, List<External>> projectExternalsCache = getProjectExternalsCache();
        synchronized (projectExternalsCache) {
            projectExternalsCache.put(build.getParent(), externalsForAll);
        }
        
        boolean scmChangesAlreadyProcessed = build.getActions(SubversionTagAction.class).stream() .anyMatch(existingTagAction -> CollectionUtils.isEqualCollection(existingTagAction.getTags().keySet(), revList));
        if(changelogFile != null && !scmChangesAlreadyProcessed) {    
            build.addAction(new SubversionTagAction(build,revList));            
            calcChangeLog(build, workspace, changelogFile, baseline, listener, externalsMap, env);         
        }
        
    }
    
    private Map<String, List<External>> checkout(Run build, FilePath workspace, TaskListener listener, EnvVars env) throws IOException, InterruptedException {
        if (repositoryLocationsNoLongerExist(build, listener, env)) {
            Run lsb = build.getParent().getLastSuccessfulBuild();
            if (build instanceof AbstractBuild && lsb != null && build.getNumber()-lsb.getNumber()>10 && build.getTimestamp().getTimeInMillis()-lsb.getTimestamp().getTimeInMillis() > TimeUnit.DAYS.toMillis(1)) {
                listener.getLogger().println("One or more repository locations do not exist anymore for " + build.getParent().getName() + ", project will be disabled.");
                disableProject(((AbstractBuild) build).getProject(), listener);
            }
            
            return null;
        }
        
        Map<String, List<External>> externalsMap = new HashMap<>();
        Set<String> unauthenticatedRealms = new LinkedHashSet<>();
        for (ModuleLocation location : getLocations(env, build)) {
            CheckOutTask checkOutTask = new CheckOutTask(build, this, location, build.getTimestamp().getTime(), listener, env, quietOperation);
            List<External> externals = new ArrayList<>(workspace.act(checkOutTask));
            externalsMap.put(location.remote, externals);
            unauthenticatedRealms.addAll(checkOutTask.getUnauthenticatedRealms());
        }
        
        if (additionalCredentials != null) {
            for (AdditionalCredentials c : additionalCredentials) {
                unauthenticatedRealms.remove(c.getRealm());
            }
            
        }
        
        if (!unauthenticatedRealms.isEmpty()) {
            listener.getLogger().println("WARNING: The following realms could not be authenticated:");
            for (String realm : unauthenticatedRealms) {
                listener.getLogger().println(" * " + realm);
            }
            
            if (build == build.getParent().getLastBuild()) {
                if (additionalCredentials == null) {
                    additionalCredentials = new ArrayList<>();
                }
                
                for (String realm : unauthenticatedRealms) {
                    additionalCredentials.add(new AdditionalCredentials(realm, null));
                }
                
                try {
                    listener.getLogger().println("Adding missing realms to configuration...");
                    build.getParent().save();
                    listener.getLogger().println("Updated project configuration saved.");
                }
                 catch (IOException e) {
                    listener.getLogger().println("Could not update project configuration: " + e.getMessage());
                }
                
            }
            
        }
        
        return externalsMap;
    }
    
    private synchronized Map<Job, List<External>> getProjectExternalsCache() {
        if (projectExternalsCache == null) {
            projectExternalsCache = new WeakHashMap<>();
        }
        
        return projectExternalsCache;
    }
    
    private static class CheckOutTask extends UpdateTask implements FileCallable<List<External>> {
        private final UpdateTask task;
        CheckOutTask(Run<?, ?> build, SubversionSCM parent, ModuleLocation location, Date timestamp, TaskListener listener, EnvVars env, boolean quietOperation) {
            this.authProvider = parent.createAuthenticationProvider(build.getParent(), location, listener);
            this.timestamp = timestamp;
            this.listener = listener;
            this.location = location;
            this.revisions = build.getAction(RevisionParameterAction.class);
            this.task = parent.getWorkspaceUpdater().createTask();
            this.quietOperation = quietOperation;
        }
        
        Set<String> getUnauthenticatedRealms() {
            if (authProvider instanceof CredentialsSVNAuthenticationProviderImpl) {
                return ((CredentialsSVNAuthenticationProviderImpl) authProvider).getUnauthenticatedRealms();
            }
            
            return Collections.emptySet();
        }
        
        public List<External> invoke(File ws, VirtualChannel channel) throws IOException {
            clientManager = createClientManager(authProvider);
            manager = clientManager.getCore();
            this.ws = ws;
            try {
                List<External> externals = perform();
                checkClockOutOfSync();
                return externals;
            }
             catch (InterruptedException e) {
                throw (InterruptedIOException)new InterruptedIOException().initCause(e);
            }
             finally {
                clientManager.dispose();
            }
            
        }
        
        public void checkRoles(RoleChecker checker) throws SecurityException {
            checker.check(this, Roles.SLAVE);
        }
        
        public List<External> perform() throws IOException, InterruptedException {
            return delegateTo(task);
        }
        
        private void checkClockOutOfSync() {
            try {
                SVNDirEntry dir = clientManager.createRepository(location.getSVNURL(), true).info("/", -1);
                if (dir != null) {
                    if (dir.getDate() != null && dir.getDate().after(new Date())) {
                        listener.getLogger().println(Messages.SubversionSCM_ClockOutOfSync());
                    }
                    
                }
                
            }
             catch (SVNAuthenticationException e) {
                LOGGER.log(Level.FINE,"Failed to estimate the remote time stamp",e);
            }
             catch (SVNException e) {
                LOGGER.log(Level.INFO,"Failed to estimate the remote time stamp",e);
            }
            
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    public static SVNClientManager createSvnClientManager(ISVNAuthenticationProvider authProvider) {
        return createClientManager(authProvider).getCore();
    }
    
    public static SvnClientManager createClientManager(ISVNAuthenticationProvider authProvider) {
        ISVNAuthenticationManager sam = createSvnAuthenticationManager(authProvider);
        return new SvnClientManager(SVNClientManager.newInstance(createDefaultSVNOptions(), sam));
    }
    
    public static DefaultSVNOptions createDefaultSVNOptions() {
        DefaultSVNOptions defaultOptions = SVNWCUtil.createDefaultOptions(true);
        DescriptorImpl descriptor = descriptor();
        if (defaultOptions != null && descriptor != null) { 
            defaultOptions.setAuthStorageEnabled(descriptor.isStoreAuthToDisk());
        }
        
        return defaultOptions;
    }
    
    public static ISVNAuthenticationManager createSvnAuthenticationManager(ISVNAuthenticationProvider authProvider) {
        File configDir;
        if (CONFIG_DIR!=null){
            configDir = new File(CONFIG_DIR);
}
        else{
            configDir = SVNWCUtil.getDefaultConfigurationDirectory();
}
        ISVNAuthenticationManager sam = new SVNAuthenticationManager(configDir, null, null);
        sam.setAuthenticationProvider(authProvider);
        SVNAuthStoreHandlerImpl.install(sam);
        return sam;
    }
    
    public static SVNClientManager createSvnClientManager(AbstractProject context) {
        return createClientManager(context).getCore();
    }
    
    public static SvnClientManager createClientManager(AbstractProject context) {
        return new SvnClientManager(createSvnClientManager(descriptor().createAuthenticationProvider(context)));
    }
    
    public ISVNAuthenticationProvider createAuthenticationProvider(Job<?, ?> inContextOf, ModuleLocation location, TaskListener listener) {
        return CredentialsSVNAuthenticationProviderImpl.createAuthenticationProvider(inContextOf, this, location, listener);
    }
    
    public ISVNAuthenticationProvider createAuthenticationProvider(Job<?, ?> inContextOf, ModuleLocation location) {
        return createAuthenticationProvider(inContextOf, location, TaskListener.NULL);
    }
    
    public static final class SvnInfo implements Serializable, Comparable<SvnInfo> {
        public final String url;
        public final long revision;
        public SvnInfo(String url, long revision) {
            this.url = url;
            this.revision = revision;
        }
        
        public SvnInfo(SVNInfo info) {
            this( info.getURL().toDecodedString(), info.getCommittedRevision().getNumber() );
        }
        
        public SVNURL getSVNURL() throws SVNException {
            return SVNURL.parseURIDecoded(url);
        }
        
        public int compareTo(SvnInfo that) {
            int r = this.url.compareTo(that.url);
            if(r!=0)    return r;
            if(this.revision<that.revision) return -1;
            if(this.revision>that.revision) return +1;
            return 0;
        }
        
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            SvnInfo svnInfo = (SvnInfo) o;
            return revision==svnInfo.revision && url.equals(svnInfo.url);
        }
        
        public int hashCode() {
            int result;
            result = url.hashCode();
            result = 31 * result + (int) (revision ^ (revision >>> 32));
            return result;
        }
        
        public String toString() {
            return String.format("%s (rev.%s)",url,revision);
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    private static final class SvnInfoP implements Serializable {
        public final SvnInfo info;
        public final boolean pinned;
        public SvnInfoP(SvnInfo info, boolean pinned) {
            this.info = info;
            this.pinned = pinned;
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    public static final class External implements Serializable {
        public final String path;
        public final String url;
        public final long revision;
        public External(String path, SVNURL url, long revision) {
            this.path = path;
            this.url = url.toDecodedString();
            this.revision = revision;
        }
        
        public boolean isRevisionFixed() {
            return revision!=-1;
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    static SVNInfo parseSvnInfo(SVNURL remoteUrl, ISVNAuthenticationProvider authProvider) throws SVNException {
        final SvnClientManager manager = createClientManager(authProvider);
        try {
            final SVNWCClient svnWc = manager.getWCClient();
            return svnWc.doInfo(remoteUrl, SVNRevision.HEAD, SVNRevision.HEAD);
        }
         finally {
            manager.dispose();
        }
        
    }
    
    private static class BuildRevisionMapTask extends MasterToSlaveFileCallable<List<SvnInfoP>> {
        private final ISVNAuthenticationProvider defaultAuthProvider;
        private final Map<String,ISVNAuthenticationProvider> authProviders;
        private final TaskListener listener;
        private final List<External> externals;
        private final ModuleLocation[] locations;
        public BuildRevisionMapTask(Run<?, ?> build, SubversionSCM parent, TaskListener listener, List<External> externals, EnvVars env) {
            this.listener = listener;
            this.externals = externals;
            this.locations = parent.getLocations(env, build);
            this.defaultAuthProvider = parent.createAuthenticationProvider(build.getParent(), null, listener);
            this.authProviders = new LinkedHashMap<>();
            for (ModuleLocation loc: locations) {
                authProviders.put(loc.remote, parent.createAuthenticationProvider(build.getParent(), loc, listener));
            }
            
        }
        
        public List<SvnInfoP> invoke(File ws, VirtualChannel channel) throws IOException {
            List<SvnInfoP> revisions = new ArrayList<>();
            for (ModuleLocation module : locations) {
                ISVNAuthenticationProvider authProvider = authProviders.get(module.remote);
                if (authProvider == null) {
                    authProvider = defaultAuthProvider;
                }
                
                final SvnClientManager manager = createClientManager(authProvider);
                try {
                    final SVNWCClient svnWc = manager.getWCClient();
                    try {
                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws, module.getLocalDir()), SVNRevision.WORKING));
                        revisions.add(new SvnInfoP(info, false));
                    }
                     catch (SVNException e) {
                        e.printStackTrace(listener.error("Failed to parse svn info for " + module.remote));
                    }
                    
                }
                 finally {
                    manager.dispose();
                }
                
            }
            
            final SvnClientManager manager = createClientManager(defaultAuthProvider);
            try {
                final SVNWCClient svnWc = manager.getWCClient();
                for (External ext : externals) {
                    try {
                        SvnInfo info = new SvnInfo(svnWc.doInfo(new File(ws, ext.path), SVNRevision.WORKING));
                        revisions.add(new SvnInfoP(info, ext.isRevisionFixed()));
                    }
                     catch (SVNException e) {
                        e.printStackTrace( listener.error("Failed to parse svn info for external " + ext.url + " at " + ext.path));
                    }
                    
                }
                
                return revisions;
            }
             finally {
                manager.dispose();
            }
            
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    public static File getRevisionFile(Run build) {
        return new File(build.getRootDir(),"revision.txt");
    }
    
    public static File getRevisionFile(AbstractBuild build) {
        return getRevisionFile((Run) build);
    }
    
    public SCMRevisionState calcRevisionsFromBuild(Run<?, ?> build, FilePath workspace, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {
        Map<String,Long> wsRev = parseRevisionFile(build,true,true);
        return new SVNRevisionState(wsRev);
    }
    
    private boolean isPollFromMaster() {
        return pollFromMaster;
    }
    
    void setPollFromMaster(boolean pollFromMaster) {
        this.pollFromMaster = pollFromMaster;
    }
    
    public PollingResult compareRemoteRevisionWith(Job<?, ?> project, Launcher launcher, FilePath workspace, final TaskListener listener, SCMRevisionState _baseline) throws IOException, InterruptedException {
        final SVNRevisionState baseline;
        if (_baseline instanceof SVNRevisionState) {
            baseline = (SVNRevisionState) _baseline;
        }
         else if (project.getLastBuild() != null) {
            baseline = (SVNRevisionState) calcRevisionsFromBuild(project.getLastBuild(), launcher != null ? workspace : null, launcher, listener);
        }
         else {
            baseline = new SVNRevisionState(null);
        }
        
        if (project.getLastBuild() == null) {
            listener.getLogger().println(Messages.SubversionSCM_pollChanges_noBuilds());
            return BUILD_NOW;
        }
        
        String nodeName = "master";
        VirtualChannel channel = null;
        if (workspace != null && !isPollFromMaster()) {
            channel = workspace.getChannel();
            if (channel != null && channel instanceof Channel) {
                nodeName = ((Channel) channel).getName();
            }
            
        }
        
        if (channel == null) {
            channel = FilePath.localChannel;
        }
        
        Node node;
        if (nodeName.equals("master")) {
            node = Jenkins.getInstance();
        }
         else {
            node = Jenkins.getInstance().getNode(nodeName);
        }
        
        EnvVars env = project.getEnvironment(node, listener);
        Run<?, ?> lastCompletedBuild = project.getLastCompletedBuild();
        if (lastCompletedBuild != null) {
            if (project instanceof AbstractProject && repositoryLocationsNoLongerExist(lastCompletedBuild, listener, env)) {
                listener.getLogger().println(Messages.SubversionSCM_pollChanges_locationsNoLongerExist(project));
                disableProject((AbstractProject) project, listener);
                return NO_CHANGES;
            }
            
            for (ModuleLocation loc : getLocations(env, lastCompletedBuild)) {
                String url;
                try {
                    url = loc.getSVNURL().toDecodedString();
                }
                 catch (SVNException ex) {
                    listener.error(Messages.SubversionSCM_pollChanges_exception(loc.getURL()));
                    return BUILD_NOW;
                }
                
                if (!baseline.revisions.containsKey(url)) {
                    listener.getLogger().println(Messages.SubversionSCM_pollChanges_locationNotInWorkspace(url));
                    return BUILD_NOW;
                }
                
            }
            
        }
        
        final SVNLogHandler logHandler = new SVNLogHandler(createSVNLogFilter(), listener);
        final Map<String, ISVNAuthenticationProvider> authProviders = new LinkedHashMap<>();
        for (ModuleLocation loc : getLocations(env, null)) {
            String url;
            try {
                url = loc.getExpandedLocation(project).getSVNURL().toDecodedString();
            }
             catch (SVNException ex) {
                ex.printStackTrace(listener.error(Messages.SubversionSCM_pollChanges_exception(loc.getURL())));
                return BUILD_NOW;
            }
            
            authProviders.put(url, createAuthenticationProvider(project, loc, listener));
        }
        
        final ISVNAuthenticationProvider defaultAuthProvider = createAuthenticationProvider(project, null, listener);
        return channel.call(new CompareAgainstBaselineCallable(baseline, logHandler, project.getName(), listener, defaultAuthProvider, authProviders, nodeName));
    }
    
    public SVNLogFilter createSVNLogFilter() {
        return new DefaultSVNLogFilter(getExcludedRegionsPatterns(), getIncludedRegionsPatterns(), getExcludedUsersNormalized(), getExcludedRevpropNormalized(), getExcludedCommitMessagesPatterns(), isIgnoreDirPropChanges());
    }
    
    static final class SVNLogHandler implements ISVNLogEntryHandler, Serializable {
        private boolean changesFound = false;
        private SVNLogFilter filter;
        SVNLogHandler(SVNLogFilter svnLogFilter, TaskListener listener) {
            this.filter = svnLogFilter;
            this.filter.setTaskListener(listener);
        }
        
        public boolean isChangesFound() {
            return changesFound;
        }
        
        public boolean findNonExcludedChanges(SVNURL url, long from, long to, ISVNAuthenticationProvider authProvider) throws SVNException {
            if (from>to)        return false; 
            if (!filter.hasExclusionRule())    return true;
            final SvnClientManager manager = createClientManager(authProvider);
            try {
                manager.getLogClient().doLog(url, null, SVNRevision.UNDEFINED, SVNRevision.create(from),  SVNRevision.create(to),  false,  true,  false,  0,  null,  this);
            }
             finally {
                manager.dispose();
            }
            
            return isChangesFound();
        }
        
        public void handleLogEntry(SVNLogEntry logEntry) throws SVNException {
            if (filter.isIncluded(logEntry)) {
                changesFound = true;
            }
            
        }
        
        private static final long serialVersionUID = 1L;
    }
    
    public ChangeLogParser createChangeLogParser() {
        return new SubversionChangeLogParser(ignoreDirPropChanges);
    }
    
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl)super.getDescriptor();
    }
    
    public FilePath getModuleRoot(FilePath workspace) {
        if (getLocations().length > 0){
            return workspace.child(getLocations()[0].getLocalDir());
}
        return workspace;
    }
    
    public FilePath getModuleRoot(FilePath workspace, AbstractBuild build) {
        if (build == null) {
            return getModuleRoot(workspace);
        }
        
        TaskListener listener = new LogTaskListener(LOGGER, WARNING);
        final EnvVars env;
        try {
            env = build.getEnvironment(listener);
        }
         catch (IOException e) {
            throw new RuntimeException(e);
        }
         catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
        
        if (getLocations().length > 0){
            return _getModuleRoot(workspace, getLocations()[0].getLocalDir(), env);
}
        return workspace;
    }
    
    public FilePath[] getModuleRoots(FilePath workspace) {
        final ModuleLocation[] moduleLocations = getLocations();
        if (moduleLocations.length > 0) {
            FilePath[] moduleRoots = new FilePath[moduleLocations.length];
            for (int i = 0; i < moduleLocations.length; i++) {
                moduleRoots[i] = workspace.child(moduleLocations[i].getLocalDir());
            }
            
            return moduleRoots;
        }
        
        return new FilePath[] { getModuleRoot(workspace) };
    }
    
    public FilePath[] getModuleRoots(FilePath workspace, AbstractBuild build) {
        if (build == null) {
            return getModuleRoots(workspace);
        }
        
        TaskListener listener = new LogTaskListener(LOGGER, WARNING);
        final EnvVars env;
        try {
            env = build.getEnvironment(listener);
        }
         catch (IOException e) {
            throw new RuntimeException(e);
        }
         catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
        
        final ModuleLocation[] moduleLocations = getLocations();
        if (moduleLocations.length > 0) {
            FilePath[] moduleRoots = new FilePath[moduleLocations.length];
            for (int i = 0; i < moduleLocations.length; i++) {
                moduleRoots[i] = _getModuleRoot(workspace, moduleLocations[i].getLocalDir(), env);
            }
            
            return moduleRoots;
        }
        
        return new FilePath[] { getModuleRoot(workspace, build) };
    }
    
    FilePath _getModuleRoot(FilePath workspace, String localDir, EnvVars env) {
        return workspace.child( env.expand(localDir));
    }
    
    private static String getLastPathComponent(String s) {
        String[] tokens = s.split("/");
        return tokens[tokens.length-1]; 
    }
    
    @hudson.init.Initializer(after = InitMilestone.JOB_LOADED, before = InitMilestone.COMPLETED)
    public static void perJobCredentialsMigration() {
        DescriptorImpl descriptor = descriptor();
        if (descriptor != null) {
            descriptor.migratePerJobCredentials();
        }
        
    }
    
    public static class DescriptorImpl extends SCMDescriptor<SubversionSCM> implements hudson.model.ModelObject {
        private transient Map<String,Credential> credentials;
        private boolean mayHaveLegacyPerJobCredentials;
        private String globalExcludedRevprop = null;
        private int workspaceFormat = SVNAdminAreaFactory.WC_FORMAT_14;
        private boolean validateRemoteUpToVar = false;
        private boolean storeAuthToDisk = true;
        public void load() {
            super.load();
            if (credentials != null && !credentials.isEmpty()) {
                try (ACLContext oldContext = ACL.as(ACL.SYSTEM)) {
                    BulkChange bc = new BulkChange(this);
                    try {
                        mayHaveLegacyPerJobCredentials = true;
                        CredentialsStore store = CredentialsProvider.lookupStores(Jenkins.getInstance()).iterator().next();
                        for (Map.Entry<String, Credential> e : credentials.entrySet()) {
                            migrateCredentials(store, e.getKey(), e.getValue());
                        }
                        
                        save();
                        bc.commit();
                    }
                     catch (IOException e) {
                        LOGGER.log(Level.WARNING, "Could not migrate stored credentials", e);
                    }
                     finally {
                        bc.abort();
                    }
                    
                }
                
            }
            
        }
        
         void migratePerJobCredentials() {
            if (credentials == null && !mayHaveLegacyPerJobCredentials ) {
                return;
            }
            
            boolean allOk = true;
            for (AbstractProject<?, ?> job : Jenkins.getInstance().getAllItems(AbstractProject.class)) {
                File jobCredentials = new File(job.getRootDir(), "subversion.credentials");
                if (jobCredentials.isFile()) {
                    try {
                        if (job.getScm() instanceof SubversionSCM) {
                            new PerJobCredentialStore(job).migrateCredentials(this);
                            job.save();
                        }
                         
                        if (!jobCredentials.delete()) {
                            LOGGER.log(Level.WARNING, "Could not remove legacy per-job credentials store file: {0}", jobCredentials);
                            allOk = false;
                        }
                        
                    }
                     catch (IOException e) {
                        LOGGER.log(Level.WARNING, "Could not migrate per-job credentials for " + job.getFullName(), e);
                        allOk = false;
                    }
                    
                }
                
            }
            
            mayHaveLegacyPerJobCredentials = !allOk;
            save();
        }
        
         StandardCredentials migrateCredentials(CredentialsStore store, String legacyRealm, Credential legacyCredential) throws IOException {
            StandardCredentials credential = legacyCredential.toCredentials(null, legacyRealm);
            if (credential != null) {
                return credential;
            }
            
            credential = legacyCredential.toCredentials(legacyRealm);
            if (store.isDomainsModifiable()) {
                Matcher matcher = Pattern.compile("\\s*<([^>]+)>.*").matcher(legacyRealm);
                if (matcher.matches()) {
                    String url = matcher.group(1);
                    if (url.startsWith("http:") || url.startsWith("svn:") || url.startsWith("https:") || url .startsWith("svn+ssh:")) {
                        List<DomainRequirement> requirements = URIRequirementBuilder.fromUri(url).build();
                        HostnameRequirement hostnameRequirement = null;
                        SchemeRequirement schemeRequirement = null;
                        for (DomainRequirement r : requirements) {
                            if (hostnameRequirement == null && r instanceof HostnameRequirement) {
                                hostnameRequirement = (HostnameRequirement) r;
                            }
                            
                            if (schemeRequirement == null && r instanceof SchemeRequirement) {
                                schemeRequirement = (SchemeRequirement) r;
                            }
                            
                            if (schemeRequirement != null && hostnameRequirement != null) {
                                break;
                            }
                            
                        }
                        
                        Domain domain = null;
                        if (hostnameRequirement != null) {
                            for (Domain d : store.getDomains()) {
                                HostnameSpecification spec = null;
                                for (DomainSpecification s : d.getSpecifications()) {
                                    if (s instanceof HostnameSpecification) {
                                        spec = (HostnameSpecification) s;
                                        break;
                                    }
                                    
                                }
                                
                                if (spec != null && spec.test(hostnameRequirement).isMatch() && d.test(requirements)) {
                                    domain = d;
                                    break;
                                }
                                
                            }
                            
                        }
                        
                        if (domain == null) {
                            if (hostnameRequirement != null) {
                                List<DomainSpecification> specs = new ArrayList<>();
                                specs.add( new HostnameSpecification(hostnameRequirement.getHostname(), null));
                                if (schemeRequirement != null) {
                                    specs.add(new SchemeSpecification(schemeRequirement.getScheme()));
                                }
                                
                                domain = new Domain(hostnameRequirement.getHostname(), null, specs);
                                if (store.addDomain(domain, credential)) {
                                    return credential;
                                }
                                
                            }
                            
                        }
                         else {
                            if (store.addCredentials(domain, credential)) {
                                return credential;
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
            store.addCredentials(Domain.global(), credential);
            return credential;
        }
        
        public static abstract class Credential implements Serializable {
            private static final long serialVersionUID = -3707951427730113110L;
            public abstract SVNAuthentication createSVNAuthentication(String kind) throws SVNException;
            public abstract StandardCredentials toCredentials(String description) throws IOException;
            public abstract StandardCredentials toCredentials(ModelObject context, String description) throws IOException;
            protected ItemGroup findItemGroup(ModelObject context) {
                if (context instanceof ItemGroup) return (ItemGroup) context;
                if (context instanceof Item) return ((Item) context).getParent();
                return Jenkins.getInstance();
            }
            
        }
        
        public static final class PasswordCredential extends Credential {
            private static final long serialVersionUID = -1676145651108866745L;
            private final String userName;
            private final Secret password; 
            public PasswordCredential(String userName, String password) {
                this.userName = userName;
                this.password = Secret.fromString(Scrambler.scramble(password));
            }
            
            public SVNAuthentication createSVNAuthentication(String kind) {
                if(kind.equals(ISVNAuthenticationManager.SSH)) return new SVNSSHAuthentication(userName, getPassword(),-1,false);
                else{
                    return new SVNPasswordAuthentication(userName, getPassword(),false);
}
            }
            
            public StandardCredentials toCredentials(String description) {
                return new UsernamePasswordCredentialsImpl(CredentialsScope.GLOBAL, null, description, userName, getPassword());
            }
            
            public StandardCredentials toCredentials(ModelObject context, String description) throws IOException {
                for (StandardUsernamePasswordCredentials c : CredentialsProvider.lookupCredentials( StandardUsernamePasswordCredentials.class, findItemGroup(context), ACL.SYSTEM, Collections.emptyList())) {
                    if (userName.equals(c.getUsername()) && getPassword().equals(c.getPassword().getPlainText())) {
                        return c;
                    }
                    
                }
                
                return null;
            }
            
            private String getPassword() {
                return Scrambler.descramble(Secret.toString(password));
            }
            
        }
        
        public static final class SshPublicKeyCredential extends Credential {
            private static final long serialVersionUID = -4649332611621900514L;
            private final String userName;
            private final Secret passphrase; 
            private final String id;
            public SshPublicKeyCredential(String userName, String passphrase, File keyFile) throws SVNException {
                this.userName = userName;
                this.passphrase = Secret.fromString(Scrambler.scramble(passphrase));
                Random r = new Random();
                StringBuilder buf = new StringBuilder();
                for(int i=0;i<16;i++) buf.append(Integer.toHexString(r.nextInt(16)));
                this.id = buf.toString();
                try {
                    File savedKeyFile = getKeyFile();
                    FileUtils.copyFile(keyFile,savedKeyFile);
                    setFilePermissions(savedKeyFile, "600");
                }
                 catch (IOException e) {
                    throw new SVNException( new RemotableSVNErrorMessage(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE, "Unable to save private key"), e);
                }
                
            }
            
            private File getKeyFile() {
                File dir = new File(Jenkins.getInstance().getRootDir(),"subversion-credentials");
                if(dir.mkdirs()) {
                    setFilePermissions(dir, "600");
                }
                
                return new File(dir,id);
            }
            
            private boolean setFilePermissions(File file, String perms) {
                try {
                    Chmod chmod = new Chmod();
                    chmod.setProject(new Project());
                    chmod.setFile(file);
                    chmod.setPerm(perms);
                    chmod.execute();
                }
                 catch (BuildException e) {
                    LOGGER.log(Level.WARNING, "Failed to set permission of "+file,e);
                    return false;
                }
                
                return true;
            }
            
            public SVNSSHAuthentication createSVNAuthentication(String kind) throws SVNException {
                if(kind.equals(ISVNAuthenticationManager.SSH)) {
                    try {
                        Channel channel = Channel.current();
                        String privateKey;
                        if(channel!=null) {
                            privateKey = channel.call(new SlaveToMasterCallable<String,IOException>() {
                                private static final long serialVersionUID = -3088632649290496373L;
                                public String call() throws IOException {
                                    return FileUtils.readFileToString(getKeyFile(),"iso-8859-1");
                                }
                                
                            }
                            
);
                        }
                         else {
                            privateKey = FileUtils.readFileToString(getKeyFile(),"iso-8859-1");
                        }
                        
                        return new SVNSSHAuthentication(userName, privateKey.toCharArray(), Scrambler.descramble(Secret.toString(passphrase)),-1,false);
                    }
                     catch (IOException | InterruptedException e) {
                        throw new SVNException( new RemotableSVNErrorMessage(SVNErrorCode.AUTHN_CREDS_UNAVAILABLE, "Unable to load private key"), e);
                    }
                    
                }
                 else return null; 
            }
            
            public StandardCredentials toCredentials(String description) throws IOException {
                try {
                    return new BasicSSHUserPrivateKey(CredentialsScope.GLOBAL, null, userName, new BasicSSHUserPrivateKey.DirectEntryPrivateKeySource( FileUtils.readFileToString(getKeyFile(), "iso-8859-1") ), Scrambler.descramble(Secret.toString(passphrase)), description);
                }
                 catch (UnsupportedCharsetException e) {
                    throw new IllegalStateException( "Java Language Specification lists ISO-8859-1 as a required standard charset", e );
                }
                
            }
            
            public StandardCredentials toCredentials(ModelObject context, String description) throws IOException {
                String key = FileUtils.readFileToString(getKeyFile(), "iso-8859-1");
                for (SSHUserPrivateKey c : CredentialsProvider.lookupCredentials( SSHUserPrivateKey.class, findItemGroup(context), ACL.SYSTEM, Collections.emptyList())) {
                    if (userName.equals(c.getUsername()) && c.getPrivateKeys().contains(key)) {
                        return c;
                    }
                    
                }
                
                return null;
            }
            
        }
        
        public static final class SslClientCertificateCredential extends Credential {
            private static final long serialVersionUID = 5455755079546887446L;
            private final Secret certificate;
            private final Secret password; 
            public SslClientCertificateCredential(File certificate, String password) throws IOException {
                this.password = Secret.fromString(Scrambler.scramble(password));
                this.certificate = Secret.fromString(new String(Base64.encode(FileUtils.readFileToByteArray(certificate))));
            }
            
            public SVNAuthentication createSVNAuthentication(String kind) {
                if(kind.equals(ISVNAuthenticationManager.SSL)) try {
                        return SVNSSLAuthentication.newInstance( Base64.decode(certificate.getPlainText().toCharArray()), Scrambler.descramble(Secret.toString(password)).toCharArray(), false, null, false);
                    }
                     catch (IOException e) {
                        throw new Error(e); 
                    }
                    
                else{
                    return null; 
}
            }
            
            public StandardCertificateCredentials toCredentials(String description) {
                return new CertificateCredentialsImpl(CredentialsScope.GLOBAL, null, description, Scrambler.descramble(Secret.toString(password)), new CertificateCredentialsImpl.UploadedKeyStoreSource(certificate.getEncryptedValue()));
            }
            
            public StandardCredentials toCredentials(ModelObject context, String description) throws IOException {
                StandardCertificateCredentials result = toCredentials(description);
                for (StandardCertificateCredentials c : CredentialsProvider.lookupCredentials( StandardCertificateCredentials.class, findItemGroup(context), ACL.SYSTEM, Collections.emptyList())) {
                    if (c.getPassword().equals(result.getPassword())) {
                        KeyStore s1 = c.getKeyStore();
                        KeyStore s2 = result.getKeyStore();
                        try {
                            Set<String> a1 = new HashSet<>(Collections.list(s1.aliases()));
                            Set<String> a2 = new HashSet<>(Collections.list(s2.aliases()));
                            if (!a1.equals(a2)) {
                                continue;
                            }
                            
                            ByteArrayOutputStream bos1 = new ByteArrayOutputStream();
                            ByteArrayOutputStream bos2 = new ByteArrayOutputStream();
                            s1.store(bos1, c.getPassword().getPlainText().toCharArray());
                            s2.store(bos2, c.getPassword().getPlainText().toCharArray());
                            if (Arrays.equals(bos1.toByteArray(), bos2.toByteArray())) {
                                return c;
                            }
                            
                        }
                         catch (KeyStoreException | CertificateException | NoSuchAlgorithmException e) {
                            continue;
                        }
                        
                    }
                    
                }
                
                return null;
            }
            
        }
        
        interface RemotableSVNAuthenticationProvider extends Serializable {
            Credential getCredential(SVNURL url, String realm);
            void acknowledgeAuthentication(String realm, Credential credential);
        }
        
        private transient final RemotableSVNAuthenticationProviderImpl remotableProvider = new RemotableSVNAuthenticationProviderImpl();
        private final class RemotableSVNAuthenticationProviderImpl implements RemotableSVNAuthenticationProvider {
            private static final long serialVersionUID = 1243451839093253666L;
            public Credential getCredential(SVNURL url, String realm) {
                for (SubversionCredentialProvider p : SubversionCredentialProvider.all()) {
                    Credential c = p.getCredential(url,realm);
                    if(c!=null) {
                        LOGGER.fine(String.format("getCredential(%s)=>%s by %s",realm,c,p));
                        return c;
                    }
                    
                }
                
                LOGGER.fine(String.format("getCredential(%s)=>%s",realm,credentials.get(realm)));
                return credentials.get(realm);
            }
            
            public void acknowledgeAuthentication(String realm, Credential credential) {
            }
            
            private Object writeReplace() {
                return Channel.current().export(RemotableSVNAuthenticationProvider.class, this);
            }
            
        }
        
        public SCM newInstance(StaplerRequest staplerRequest, JSONObject jsonObject) throws FormException {
            return super.newInstance(staplerRequest, jsonObject);
        }
        
 public boolean isApplicable(Job project) {
            return true;
        }
        
        public DescriptorImpl() {
            super(SubversionRepositoryBrowser.class);
            load();
        }
        
        protected DescriptorImpl(Class clazz, Class<? extends RepositoryBrowser> repositoryBrowser) {
            super(clazz, repositoryBrowser);
        }
        
        public String getDisplayName() {
            return "Subversion";
        }
        
        public void setGlobalExcludedRevprop(String globalExcludedRevprop) {
            this.globalExcludedRevprop = globalExcludedRevprop;
        }
        
        public String getGlobalExcludedRevprop() {
            return this.globalExcludedRevprop;
        }
        
        public int getWorkspaceFormat() {
            if (workspaceFormat == 0){
                return SVNAdminAreaFactory.WC_FORMAT_14; 
}
            return workspaceFormat;
        }
        
        public void setWorkspaceFormat(int workspaceFormat) {
            this.workspaceFormat = workspaceFormat;
        }
        
        public boolean isValidateRemoteUpToVar() {
            return validateRemoteUpToVar;
        }
        
        public boolean isStoreAuthToDisk() {
            return storeAuthToDisk;
        }
        
        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
            globalExcludedRevprop = fixEmptyAndTrim( req.getParameter("svn.global_excluded_revprop"));
            workspaceFormat = Integer.parseInt(req.getParameter("svn.workspaceFormat"));
            validateRemoteUpToVar = formData.containsKey("validateRemoteUpToVar");
            storeAuthToDisk = formData.containsKey("storeAuthToDisk");
            save();
            return super.configure(req, formData);
        }
        
        public boolean isBrowserReusable(SubversionSCM x, SubversionSCM y) {
            ModuleLocation[] xl = x.getLocations(), yl = y.getLocations();
            if (xl.length != yl.length) return false;
            for (int i = 0; i < xl.length; i++){
}
                if (!xl[i].getURL().equals(yl[i].getURL())) return false;
            return true;
        }
        
        public Permission getRequiredGlobalConfigPagePermission() {
            return Jenkins.MANAGE;
        }
        
        public ISVNAuthenticationProvider createAuthenticationProvider(AbstractProject<?,?> inContextOf) {
            SubversionSCM scm = null;
            if (inContextOf != null && inContextOf.getScm() instanceof SubversionSCM) {
                scm = (SubversionSCM)inContextOf.getScm();
            }
            
            return CredentialsSVNAuthenticationProviderImpl.createAuthenticationProvider(inContextOf, scm, null);
        }
        
        public ISVNAuthenticationProvider createAuthenticationProvider() {
            return CredentialsSVNAuthenticationProviderImpl.createAuthenticationProvider(null, null, null);
        }
        
        public void doPostCredential(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
            Jenkins.getInstance().checkPermission(Item.CONFIGURE);
            MultipartFormDataParser parser = new MultipartFormDataParser(req);
            StringWriter log = new StringWriter();
            PrintWriter logWriter = new PrintWriter(log);
            try (UserProvidedCredential upc = UserProvidedCredential.fromForm(req, parser)) {
                postCredential(parser.get("url"), upc, logWriter);
                rsp.sendRedirect("credentialOK");
            }
             catch (SVNException e) {
                logWriter.println("FAILED: "+e.getErrorMessage());
                req.setAttribute("message",log.toString());
                req.setAttribute("pre",true);
                req.setAttribute("exception",e);
                rsp.forward(Jenkins.getInstance(),"error",req);
            }
            
        }
        
        public void postCredential(String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {
            postCredential(null,url,username,password,keyFile,logWriter);
        }
        
        public void postCredential(AbstractProject inContextOf, String url, String username, String password, File keyFile, PrintWriter logWriter) throws SVNException, IOException {
            postCredential(url,new UserProvidedCredential(username,password,keyFile,inContextOf),logWriter);
        }
        
        public void postCredential(String url, final UserProvidedCredential upc, PrintWriter logWriter) throws SVNException, IOException {
            SVNRepository repository = null;
            try {
                repository = SVNRepositoryFactory.create(SVNURL.parseURIDecoded(url));
                repository.setTunnelProvider( createDefaultSVNOptions() );
                AuthenticationManagerImpl authManager = upc.new AuthenticationManagerImpl(logWriter);
                authManager.setAuthenticationForced(true);
                repository.setAuthenticationManager(authManager);
                repository.testConnection();
                authManager.checkIfProtocolCompleted();
            }
             finally {
                if (repository != null){
                    repository.closeSession();
}
            }
            
        }
        
        public FormValidation doCheckRemote(StaplerRequest req, @AncestorInPath AbstractProject context, @QueryParameter String value, @QueryParameter String credentialsId) {
            Jenkins instance = Jenkins.getInstance();
            if (instance != null) {
                ModuleLocation.DescriptorImpl d = instance.getDescriptorByType(ModuleLocation.DescriptorImpl.class);
                if (d != null) {
                    return d.doCheckCredentialsId(req, context, value, credentialsId);
                }
                
            }
            
            return FormValidation.warning("Unable to check remote.");
        }
        
        public SVNNodeKind checkRepositoryPath(AbstractProject context, SVNURL repoURL) throws SVNException {
            return checkRepositoryPath(context, repoURL, null);
        }
        
        public SVNNodeKind checkRepositoryPath(Job context, SVNURL repoURL, StandardCredentials credentials) throws SVNException {
            return checkRepositoryPath((Item) context, repoURL, credentials);
        }
        
        public SVNNodeKind checkRepositoryPath(Item context, SVNURL repoURL, StandardCredentials credentials) throws SVNException {
            SVNRepository repository = null;
            try {
                repository = getRepository(context, repoURL, credentials, Collections.emptyMap(), null);
                repository.testConnection();
                long rev = repository.getLatestRevision();
                String repoPath = getRelativePath(repoURL, repository);
                return repository.checkPath(repoPath, rev);
            }
             catch (SVNException e) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LogRecord lr = new LogRecord(Level.FINE, "Could not check repository path {0} using credentials {1} ({2})");
                    lr.setThrown(e);
                    lr.setParameters(new Object[]{
                            repoURL, credentials == null ? null : CredentialsNameProvider.name(credentials), credentials }
);
                    LOGGER.log(lr);
                }
                
                throw e;
            }
             finally {
                if (repository != null) {
                    repository.closeSession();
                }
                
            }
            
        }
        
        protected SVNRepository getRepository(AbstractProject context, SVNURL repoURL) throws SVNException {
            return getRepository(context, repoURL, null, Collections.emptyMap(), null);
        }
        
        protected SVNRepository getRepository(AbstractProject context, SVNURL repoURL, ISVNSession session) throws SVNException {
            return getRepository(context, repoURL, null, Collections.emptyMap(), null);
        }
        
        protected SVNRepository getRepository(AbstractProject context, SVNURL repoURL, StandardCredentials credentials, Map<String, Credentials> additionalCredentials) throws SVNException {
            return getRepository(context, repoURL, credentials, additionalCredentials, null);
        }
        
        protected SVNRepository getRepository(Job context, SVNURL repoURL, StandardCredentials credentials, Map<String, Credentials> additionalCredentials, ISVNSession session) throws SVNException {
            return getRepository((Item) context, repoURL, credentials, additionalCredentials, session);
        }
        
        protected SVNRepository getRepository(Item context, SVNURL repoURL, StandardCredentials credentials, Map<String, Credentials> additionalCredentials, ISVNSession session) throws SVNException {
            SVNRepository repository = SVNRepositoryFactory.create(repoURL, session);
            ISVNAuthenticationManager sam = createSvnAuthenticationManager( new CredentialsSVNAuthenticationProviderImpl(credentials, additionalCredentials,  TaskListener.NULL) );
            sam = new FilterSVNAuthenticationManager(sam) {                  
                public int getReadTimeout(SVNRepository repository) {
                    int r = super.getReadTimeout(repository);
                    if(r<=0)    r = DEFAULT_TIMEOUT;
                    return r;
                }
                
            };
            repository.setTunnelProvider(createDefaultSVNOptions());
            repository.setAuthenticationManager(sam);
            return repository;
        }
        
        public static String getRelativePath(SVNURL repoURL, SVNRepository repository) throws SVNException {
            String repoPath = repoURL.getPath().substring(repository.getRepositoryRoot(true).getPath().length());
            if(!repoPath.startsWith("/"))    repoPath="/"+repoPath;
            return repoPath;
        }
        
        public FormValidation doCheckExcludedRegions(@QueryParameter String value) throws IOException, ServletException {
            for (String region : Util.fixNull(value).trim().split("[\\r\\n]+")){
                try {
                    Pattern.compile(region);
                }
                 catch (PatternSyntaxException e) {
                    return FormValidation.error("Invalid regular expression. " + e.getMessage());
                }
                
}
            return FormValidation.ok();
        }
        
        public FormValidation doCheckIncludedRegions(@QueryParameter String value) throws IOException, ServletException {
            return  doCheckExcludedRegions(value);
        }
        
        private static final Pattern USERNAME_PATTERN = Pattern.compile("([a-zA-Z0-9_-]+\\\\)?+([a-zA-Z0-9_-]+)");
        public FormValidation doCheckExcludedUsers(@QueryParameter String value) throws IOException, ServletException {
            for (String user : Util.fixNull(value).trim().split("[\\r\\n]+")) {
                user = user.trim();
                if ("".equals(user)) {
                    continue;
                }
                
                if (!USERNAME_PATTERN.matcher(user).matches()) {
                    return FormValidation.error("Invalid username: " + user);
                }
                
            }
            
            return FormValidation.ok();
        }
        
        public List<WorkspaceUpdaterDescriptor> getWorkspaceUpdaterDescriptors() {
            return WorkspaceUpdaterDescriptor.all();
        }
        
        public FormValidation doCheckExcludedCommitMessages(@QueryParameter String value) throws IOException, ServletException {
            for (String message : Util.fixNull(value).trim().split("[\\r\\n]+")) {
                try {
                    Pattern.compile(message);
                }
                 catch (PatternSyntaxException e) {
                    return FormValidation.error("Invalid regular expression. " + e.getMessage());
                }
                
            }
            
            return FormValidation.ok();
        }
        
        public FormValidation doCheckRevisionPropertiesSupported(@AncestorInPath Item context, @QueryParameter String value, @QueryParameter String credentialsId, @QueryParameter String excludedRevprop) throws IOException, ServletException {
              String v = Util.fixNull(value).trim();
            if (v.length() == 0){
                return FormValidation.ok();
}
            String revprop = Util.fixNull(excludedRevprop).trim();
            if (revprop.length() == 0){
                return FormValidation.ok();
}
            if (!Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER)){
                return FormValidation.ok();
}
            try {
                SVNURL repoURL = SVNURL.parseURIDecoded(new EnvVars(EnvVars.masterEnvVars).expand(v));
                StandardCredentials credentials = lookupCredentials(context, credentialsId, repoURL);
                SVNNodeKind node = null;
                try {
                    node = checkRepositoryPath(context,repoURL, credentials);
                }
                 catch (SVNCancelException ce) {
                    if (isAuthenticationFailedError(ce)) {
                        return FormValidation.ok();
                    }
                    
                    throw ce;
                }
                
                if (node!=SVNNodeKind.NONE){
                    return FormValidation.ok();
}
                SVNRepository repository = null;
                try {
                    repository = getRepository(context,repoURL, credentials, Collections.emptyMap(), null);
                    if (repository.hasCapability(SVNCapability.LOG_REVPROPS)){
                        return FormValidation.ok();
}
                }
                 finally {
                    if (repository != null){
                        repository.closeSession();
}
                }
                
            }
             catch (SVNException e) {
                String message="";
                message += "Unable to access "+Util.escape(v)+" : "+Util.escape(e.getErrorMessage().getFullMessage());
                LOGGER.log(Level.INFO, "Failed to access subversion repository "+v,e);
                return FormValidation.errorWithMarkup(message);
            }
            
            return FormValidation.warning(Messages.SubversionSCM_excludedRevprop_notSupported(v));
        }
        
        static {
            new Initializer();
        }
        
    }
    
    private static boolean isAuthenticationFailedError(SVNCancelException e) {
      if (String.valueOf(e.getMessage()).contains("No credential to try")) {
        return true;
      }
      
      Throwable cause = e.getCause();
      if (cause instanceof SVNCancelException) {
        return isAuthenticationFailedError((SVNCancelException) cause);
      }
       else {
        return false;
      }
      
    }
    
    private static DescriptorImpl descriptor() {
        Jenkins instance = Jenkins.getInstanceOrNull();
        return instance == null ? null : instance.getDescriptorByType(DescriptorImpl.class);
    }
    
    public boolean repositoryLocationsNoLongerExist(AbstractBuild<?,?> build, TaskListener listener) {
        return repositoryLocationsNoLongerExist(build, listener, null);
    }
    
    public boolean repositoryLocationsNoLongerExist(Run<?,?> build, TaskListener listener, EnvVars env) {
        PrintStream out = listener.getLogger();
        for (ModuleLocation l : getLocations(env, build)){
            try {
                if (getDescriptor().checkRepositoryPath(build.getParent(), l.getSVNURL(), lookupCredentials(build.getParent(), l.credentialsId, l.getSVNURL())) == SVNNodeKind.NONE) {

                    out.println("Location '" + l.remote + "' does not exist");
                    ParametersAction params = build.getAction(ParametersAction.class);
                    if (params != null) {

                        LOGGER.fine("Location could be expanded on build '" + build + "' parameters values:");
                        return false;
                    }
                    
                    return true;
                }
                
            }
             catch (SVNException e) {
                LOGGER.log(FINE, "Location check failed",e);
            }
            
}
        return false;
    }
    
    private void disableProject(@NonNull AbstractProject project, @NonNull TaskListener listener) throws IOException {
        if (project.supportsMakeDisabled()) {
            project.makeDisabled(true);
            listener.getLogger().println(Messages.SubversionSCM_disableProject_disabled());
        }
         else {
            listener.getLogger().println(Messages.SubversionSCM_disableProject_unsupported());
        }
        
    }
    
    static final Pattern URL_PATTERN = Pattern.compile("(https?|svn(\\+[a-z0-9]+)?|file)://.+");
    private static final long serialVersionUID = 1L;
    public static void init() {}
    static {
        new Initializer();
    }
    
    private static final class Initializer {
        static {
            if(Boolean.getBoolean("hudson.spool-svn")) DAVRepositoryFactory.setup(new DefaultHTTPConnectionFactory(null,true,null));
            else{
                DAVRepositoryFactory.setup();   
}
            SVNRepositoryFactoryImpl.setup();   
            FSRepositoryFactory.setup();    
            if(System.getProperty("svnkit.ssh2.persistent")==null) System.setProperty("svnkit.ssh2.persistent","false");
            if(System.getProperty("svnkit.http.methods")==null) System.setProperty("svnkit.http.methods","Digest,Basic,NTLM,Negotiate");
            SVNAdminAreaFactory.setSelector(new SubversionWorkspaceSelector());
        }
        
    }
    
    public static final class ModuleLocation extends AbstractDescribableImpl<ModuleLocation> implements Serializable {
        public final String remote;
        public String credentialsId;
        public final String local;
        public final String depthOption;
        public boolean ignoreExternalsOption;
        public boolean cancelProcessOnExternalsFail;
        private transient volatile UUID repositoryUUID;
        private transient volatile SVNURL repositoryRoot;
        public ModuleLocation(String remote, String local) {
            this(remote, null, local, null, false, false);
        }
        
        void setCredentialsId (final String id) {
            credentialsId = id;
        }
        
        public ModuleLocation(String remote, String local, String depthOption, boolean ignoreExternalsOption) {
            this(remote,null,local,depthOption,ignoreExternalsOption, false);
        }
        
        public ModuleLocation(String remote, String credentialsId, String local, String depthOption, boolean ignoreExternalsOption) {
          this(remote,credentialsId,local,depthOption,ignoreExternalsOption, false);
        }
        
        public ModuleLocation(String remote, String credentialsId, String local, String depthOption, boolean ignoreExternalsOption, boolean cancelProcessOnExternalsFail) {
            this.remote = Util.removeTrailingSlash(Util.fixNull(remote).trim());
            this.credentialsId = credentialsId;
            this.local = fixEmptyAndTrim(local);
            this.depthOption = StringUtils.isEmpty(depthOption) ? SVNDepth.INFINITY.getName() : depthOption;
            this.ignoreExternalsOption = ignoreExternalsOption;
            this.cancelProcessOnExternalsFail = cancelProcessOnExternalsFail;
        }
        
        public ModuleLocation withRemote(String remote) {
            return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFail);
        }
        
        public ModuleLocation withCredentialsId(String credentialsId) {
            return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFail);
        }
        
        public ModuleLocation withLocal(String local) {
            return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFail);
        }
        
        public ModuleLocation withDepthOption(String depthOption) {
            return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFail);
        }
        
        public ModuleLocation withIgnoreExternalsOption(boolean ignoreExternalsOption) {
            return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFail);
        }
        
        public ModuleLocation withCancelProcessOnExternalsFailed(boolean cancelProcessOnExternalsFailed) {
          return new ModuleLocation(remote, credentialsId, local, depthOption, ignoreExternalsOption, cancelProcessOnExternalsFailed);
        }
        
        public String getLocalDir() {
            if(local==null) return getLastPathComponent(getURL());
            return local;
        }
        
        public String getURL() {
        	return SvnHelper.getUrlWithoutRevision(remote);
        }
        
        public SVNURL getSVNURL() throws SVNException {
            return SVNURL.parseURIEncoded(getURL());
        }
        
        public UUID getUUID(Job context, SCM scm) throws SVNException {
            if(repositoryUUID==null || repositoryRoot==null) {
                LOGGER.fine("UUID of " + remote + " not cached for " + context);
                synchronized (this) {
                    SVNRepository r = openRepository(context, scm, false);
                    if (r.getRepositoryUUID(false) == null){
                        r.testConnection(); 
}
                    repositoryUUID = UUID.fromString(r.getRepositoryUUID(false));
                    repositoryRoot = r.getRepositoryRoot(true);
                }
                
            }
            
            return repositoryUUID;
        }
        
        public UUID getUUID(AbstractProject context) throws SVNException {
            return getUUID(context, context.getScm());
        }
        
        public SVNRepository openRepository(AbstractProject context) throws SVNException {
            return openRepository(context, true);
        }
        
        public SVNRepository openRepository(AbstractProject context, boolean keepConnection) throws SVNException {
            return openRepository(context, context.getScm(), true);
        }
        
        public SVNRepository openRepository(Job context, SCM scm, boolean keepConnection) throws SVNException {
            SVNURL repoURL = getSVNURL();
            StandardCredentials creds = lookupCredentials(context, credentialsId, repoURL);
            Map<String, Credentials> additional = new HashMap<>();
            if (creds == null) {
                List<AdditionalCredentials> additionalCredentialsList = ((SubversionSCM) scm).getAdditionalCredentials();
                for (AdditionalCredentials c : additionalCredentialsList) {
                    String credentialsId = c.getCredentialsId();
                    if (credentialsId != null) {
                        StandardCredentials cred = CredentialsMatchers .firstOrNull(CredentialsProvider.lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM, Collections.emptyList()), CredentialsMatchers.allOf(CredentialsMatchers.withId(credentialsId), CredentialsMatchers.anyOf(CredentialsMatchers.instanceOf( StandardCredentials.class), CredentialsMatchers.instanceOf( SSHUserPrivateKey.class))));
                        if (cred != null) {
                            additional.put(c.getRealm(), cred);
                        }
                        
                    }
                    
                }
                
            }
            
            if (keepConnection) {
                return descriptor().getRepository(context, repoURL, creds, additional, null);
            }
            
            return descriptor().getRepository(context, repoURL, creds, additional, new ISVNSession() {                 public boolean keepConnection(SVNRepository repository) { return false;
                }
                
                public void saveCommitMessage(SVNRepository repository, long revision, String message) {
                }
                
                public String getCommitMessage(SVNRepository repository, long revision) {
                    return null;
                }
                
                public boolean hasCommitMessage(SVNRepository repository, long revision) {
                    return false;
                }
                
            }
            
);
        }
        
        public SVNURL getRepositoryRoot(AbstractProject context) throws SVNException {
            return getRepositoryRoot(context, context.getScm());
        }
        
        public @Nonnull SVNURL getRepositoryRoot(Job context, SCM scm) throws SVNException {
            getUUID(context, scm);
            return repositoryRoot;
        }
        
        public SVNRevision getRevision(SVNRevision defaultValue) {
            SVNRevision revision = getRevisionFromRemoteUrl(remote);
            return revision != null ? revision : defaultValue;
        }
        
        private String getExpandedRemote(AbstractBuild<?,?> build) {
            String outRemote = remote;
            ParametersAction parameters = build.getAction(ParametersAction.class);
            if (parameters != null){
                outRemote = parameters.substitute(build, remote);
}
            return outRemote;
        }
        
        private String getExpandedLocalDir(AbstractBuild<?,?> build) {
            String outLocalDir = getLocalDir();
            ParametersAction parameters = build.getAction(ParametersAction.class);
            if (parameters != null){
                outLocalDir = parameters.substitute(build, getLocalDir());
}
            return outLocalDir;
        }
        
        public String getDepthOption() {
            return depthOption;
        }
        
        private static SVNDepth getSvnDepth(String name) {
            return SVNDepth.fromString(name);
        }
        
        public SVNDepth getSvnDepthForUpdate() {
            return getSvnDepth(getDepthOption());
        }
        
        public SVNDepth getSvnDepthForCheckout() {
            if("unknown".equals(getDepthOption())) {
                return SVNDepth.FILES;
            }
             else if ("as-it-is-infinity".equals(getDepthOption())){
                return SVNDepth.INFINITY;
            }
             else {
                return getSvnDepth(getDepthOption());
            }
            
        }
        
        public SVNDepth getSvnDepthForRevert() {
            if("unknown".equals(getDepthOption()) || "as-it-is-infinity".equals(getDepthOption())){
                return SVNDepth.INFINITY;
            }
            else {
                return getSvnDepth(getDepthOption());
            }
            
        }
        
        public boolean isIgnoreExternalsOption() {
            return ignoreExternalsOption;
        }
        
        public boolean isCancelProcessOnExternalsFail() {
          return cancelProcessOnExternalsFail;
        }
        
        public ModuleLocation getExpandedLocation(AbstractBuild<?, ?> build) {
            EnvVars env = new EnvVars(EnvVars.masterEnvVars);
            env.putAll(build.getBuildVariables());
            return getExpandedLocation(env);
        }
        
        public ModuleLocation getExpandedLocation(EnvVars env) {
            return new ModuleLocation(env.expand(remote), credentialsId, env.expand(getLocalDir()), getDepthOption(), isIgnoreExternalsOption(), isCancelProcessOnExternalsFail());
        }
        
        public String toString() {
            return remote;
        }
        
        private static final long serialVersionUID = 1L;
        public static List<ModuleLocation> parse(String[] remoteLocations, String[] localLocations, String[] depthOptions, boolean[] isIgnoreExternals) {
            return parse(remoteLocations, null, localLocations, depthOptions, isIgnoreExternals, null);
        }
        
        public static List<ModuleLocation> parse(String[] remoteLocations, String[] credentialIds, String[] localLocations, String[] depthOptions, boolean[] isIgnoreExternals) {
          return parse(remoteLocations, credentialIds, localLocations, depthOptions, isIgnoreExternals, null);
        }
        
        public static List<ModuleLocation> parse(String[] remoteLocations, String[] credentialIds, String[] localLocations, String[] depthOptions, boolean[] isIgnoreExternals, boolean[] cancelProcessOnExternalsFails) {
            List<ModuleLocation> modules = new ArrayList<>();
            if (remoteLocations != null && localLocations != null) {
                int entries = Math.min(remoteLocations.length, localLocations.length);
                for (int i = 0; i < entries; i++) {
                    String remoteLoc = Util.nullify(remoteLocations[i]);
                    if (remoteLoc != null) {
                        remoteLoc = Util.removeTrailingSlash(remoteLoc.trim());
                        modules.add(new ModuleLocation(remoteLoc, credentialIds != null && credentialIds.length > i ? credentialIds[i] : null, Util.nullify(localLocations[i]), depthOptions != null ? depthOptions[i] : null, isIgnoreExternals != null && isIgnoreExternals[i], cancelProcessOnExternalsFails != null && cancelProcessOnExternalsFails[i]));
                    }
                    
                }
                
            }
            
            return modules;
        }
        
        public ModuleLocation getExpandedLocation(Job<?, ?> project) {
            String url = this.getURL();
            String returnURL = url;
            for (JobProperty property : project.getProperties().values()) {
                if (property instanceof ParametersDefinitionProperty) {
                    ParametersDefinitionProperty pdp = (ParametersDefinitionProperty) property;
                    for (String propertyName : pdp.getParameterDefinitionNames()) {
                        if (url.contains(propertyName)) {
                            ParameterDefinition pd = pdp.getParameterDefinition(propertyName);
                            if (pd != null) {
                                ParameterValue pv = pd.getDefaultParameterValue();
                                String replacement = "";
                                if (pv != null) {
                                    replacement = String.valueOf(pv.createVariableResolver(null).resolve(propertyName));
                                }
                                
                                returnURL = returnURL.replace("${" + propertyName + "}", replacement);
                                returnURL = returnURL.replace("$" + propertyName, replacement);
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
            return new ModuleLocation(returnURL, credentialsId, getLocalDir(), getDepthOption(), isIgnoreExternalsOption(), isCancelProcessOnExternalsFail());
        }
        
        public static class DescriptorImpl extends Descriptor<ModuleLocation> {
            public String getDisplayName() {
                return null;
            }
            
            public ListBoxModel doFillCredentialsIdItems(@AncestorInPath Item context, @QueryParameter String remote) {
                if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) || context != null && !context.hasPermission(Item.EXTENDED_READ)) {
                    return new StandardListBoxModel();
                }
                
                return fillCredentialsIdItems(context, remote);
            }
            
            public ListBoxModel fillCredentialsIdItems(@CheckForNull Item context, String remote) {
                List<DomainRequirement> domainRequirements;
                if (remote == null) {
                    domainRequirements = Collections.emptyList();
                }
                 else {
                    domainRequirements = URIRequirementBuilder.fromUri(remote.trim()).build();
                }
                
                return new StandardListBoxModel() .withEmptySelection() .withMatching( CredentialsMatchers.anyOf( CredentialsMatchers.instanceOf(StandardUsernamePasswordCredentials.class), CredentialsMatchers.instanceOf(StandardCertificateCredentials.class), CredentialsMatchers.instanceOf(SSHUserPrivateKey.class) ), CredentialsProvider.lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM, domainRequirements) );
            }
            
            public FormValidation doCheckRemote(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remote) {
                String url = Util.fixEmptyAndTrim(remote);
                if (url == null) {
                    return FormValidation.error(Messages.SubversionSCM_doCheckRemote_required());
                }
                
                if (url.indexOf('$') != -1) {
                    return FormValidation.warning("This repository URL is parameterized, syntax validation skipped");
                }
                
                try {
                    SVNURL.parseURIEncoded(url);
                }
                 catch (SVNException svne) {
                    LOGGER.log(Level.SEVERE, svne.getMessage());
                    return FormValidation.error(Messages.SubversionSCM_doCheckRemote_invalidUrl());
                }
                
                return FormValidation.ok();
            }
            
            public FormValidation doCheckCredentialsId(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remote, @QueryParameter String value) {
                if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) || context != null && !context.hasPermission(CredentialsProvider.USE_ITEM)) {
                    return FormValidation.ok();
                }
                
                return checkCredentialsId(req, context, remote, value);
            }
            
            public FormValidation checkCredentialsId(StaplerRequest req, @Nonnull Item context, String remote, String value) {
                String url = Util.fixEmptyAndTrim(remote);
                if (url == null) {
                    return FormValidation.ok();
                }
                
                if (remote.indexOf('$') != -1) {
                    return FormValidation.warning("The repository URL is parameterized, connection check skipped");
                }
                
                try {
                    SVNURL repoURL = SVNURL.parseURIEncoded(remote);
                    StandardCredentials credentials = lookupCredentials(context, value, repoURL);
                    SVNRepository repo = descriptor().getRepository(context, repoURL, credentials, Collections.emptyMap(), null);
                    String repoRoot = repo.getRepositoryRoot(true).toDecodedString();
                    String repoPath = repo.getLocation().toDecodedString().substring(repoRoot.length());
                    SVNPath path = new SVNPath(repoPath, true, true);
                    SVNNodeKind svnNodeKind = repo.checkPath(path.getTarget(), path.getPegRevision().getNumber());
                    if (svnNodeKind != SVNNodeKind.DIR) {
                        return FormValidation.error("Credentials looks fine but the repository URL is invalid");
                    }
                    
                }
                 catch (SVNException e) {
                    LOGGER.log(Level.SEVERE, e.getErrorMessage().getMessage());
                    return FormValidation.error("Unable to access the repository");
                }
                
                return FormValidation.ok();
            }
            
            public FormValidation doCheckLocal(@QueryParameter String value) throws IOException, ServletException {
                String v = Util.nullify(value);
                if (v == null){
                    return FormValidation.ok();
}
                v = v.trim();
                if (v.startsWith("/") || v.startsWith("\\") || v.startsWith("..") || v.matches("^[A-Za-z]:.*")){
                    return FormValidation.error("absolute path is not allowed");
}
                return FormValidation.ok();
            }
            
        }
        
    }
    
    private static final Logger LOGGER = Logger.getLogger(SubversionSCM.class.getName());
    public static final int DEFAULT_TIMEOUT = Integer.getInteger(SubversionSCM.class.getName() + ".timeout", 3600 * 1000);
    private static boolean POLL_FROM_MASTER = Boolean.getBoolean(SubversionSCM.class.getName() + ".pollFromMaster");
    public static final String CONFIG_DIR = System.getProperty(SubversionSCM.class.getName() + ".configDir");
    public static void enableSshDebug(Level level) {
        if(level==null)     level= Level.FINEST; 
        final Level lv = level;
        com.trilead.ssh2.log.Logger.enabled=true;
        com.trilead.ssh2.log.Logger.logger = new DebugLogger() {             private final Logger LOGGER = Logger.getLogger(SCPClient.class.getPackage().getName());
            public void log(int level, String className, String message) {
                LOGGER.log(lv,className+' '+message);
            }
            
        };
    }
    
     static boolean compareSVNAuthentications(SVNAuthentication a1, SVNAuthentication a2) {
        if (a1==null && a2==null)       return true;
        if (a1==null || a2==null)       return false;
        if (a1.getClass()!=a2.getClass())    return false;
        try {
            return describeBean(a1).equals(describeBean(a2));
        }
         catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            return false;
        }
        
    }
    
    private static Map describeBean(Object o) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        Map<?,?> m = PropertyUtils.describe(o);
        for (Entry e : m.entrySet()) {
            Object v = e.getValue();
            if (v instanceof char[]) {
                char[] chars = (char[]) v;
                e.setValue(new String(chars));
            }
            
        }
        
        return m;
    }
    
    private static SVNRevision getRevisionFromRemoteUrl(String remoteUrlPossiblyWithRevision) {
        int idx = remoteUrlPossiblyWithRevision.lastIndexOf('@');
        int slashIdx = remoteUrlPossiblyWithRevision.lastIndexOf('/');
        if (idx > 0 && idx > slashIdx) {
            String n = remoteUrlPossiblyWithRevision.substring(idx + 1);
            return SVNRevision.parse(n);
        }
        
        return null;
    }
    
    private static StandardCredentials lookupCredentials(Item context, String credentialsId, SVNURL repoURL) {
        return credentialsId == null ? null : CredentialsMatchers.firstOrNull(CredentialsProvider .lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM, URIRequirementBuilder.fromUri(repoURL.toString()).build()), CredentialsMatchers.withId(credentialsId));
    }
    
    public static class AdditionalCredentials extends AbstractDescribableImpl<AdditionalCredentials> {
        private final String realm;
        private final String credentialsId;
        public AdditionalCredentials(@NonNull String realm, @CheckForNull String credentialsId) {
            realm.getClass(); 
            this.realm = realm;
            this.credentialsId = credentialsId;
        }
        
        public String getRealm() {
            return realm;
        }
        
        public String getCredentialsId() {
            return credentialsId;
        }
        
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            
            if (!(o instanceof AdditionalCredentials)) {
                return false;
            }
            
            AdditionalCredentials that = (AdditionalCredentials) o;
            if (!realm.equals(that.realm)) {
                return false;
            }
            
            if (!Objects.equals(credentialsId, that.credentialsId)) {
                return false;
            }
            
            return true;
        }
        
        public int hashCode() {
            int result = realm.hashCode();
            result = 31 * result + (credentialsId != null ? credentialsId.hashCode() : 0);
            return result;
        }
        
        public static class DescriptorImpl extends Descriptor<AdditionalCredentials> {
            public String getDisplayName() {
                return null;
            }
            
            public ListBoxModel doFillCredentialsIdItems(@AncestorInPath Item context, @QueryParameter String realm) {
                if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) || context != null && !context.hasPermission(Item.EXTENDED_READ)) {
                    return new StandardListBoxModel();
                }
                
                List<DomainRequirement> domainRequirements;
                if (realm == null) {
                    domainRequirements = Collections.emptyList();
                }
                 else {
                    if (realm.startsWith("<") && realm.contains(">")) {
                        int index = realm.indexOf('>');
                        assert index > 1;
                        domainRequirements = URIRequirementBuilder.fromUri(realm.substring(1, index).trim()).build();
                    }
                     else {
                        domainRequirements = Collections.emptyList();
                    }
                    
                }
                
                return new StandardListBoxModel() .withEmptySelection() .withMatching( CredentialsMatchers.anyOf( CredentialsMatchers.instanceOf(StandardUsernamePasswordCredentials.class), CredentialsMatchers.instanceOf(StandardCertificateCredentials.class), CredentialsMatchers.instanceOf(SSHUserPrivateKey.class) ), CredentialsProvider.lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM, domainRequirements) );
            }
            
        }
        
    }
    
}


