package org.geotools.filter;
import com.google.re2j.Matcher;
import com.google.re2j.Pattern;
import java.util.Collection;
import java.util.Objects;
import org.opengis.filter.FilterVisitor;
import org.opengis.filter.PropertyIsLike;
public class LikeFilterImpl extends AbstractFilter implements PropertyIsLike {
    private org.opengis.filter.expression.Expression attribute = null;
    private String pattern = null;
    private String wildcardSingle = ".?";
    private String wildcardMulti = ".*";
    private String escape = "\\";
    private Pattern compPattern = null;
    boolean matchingCase;
    protected MatchAction matchAction;
    public static String convertToSQL92( char escape, char multi, char single, boolean matchCase, String pattern) throws IllegalArgumentException {
        if ((escape == '\'') || (multi == '\'') || (single == '\'')){
            throw new IllegalArgumentException("do not use single quote (') as special char!");
}
        StringBuffer result = new StringBuffer(pattern.length() + 5);
        for (int i = 0; i < pattern.length(); i++) {
            char chr = pattern.charAt(i);
            if (chr == escape) {
                if (i != (pattern.length() - 1)) result.append(pattern.charAt(i + 1)); 
                i++; 
            }
             else if (chr == single) {
                result.append('_');
            }
             else if (chr == multi) {
                result.append('%');
            }
             else if (chr == '\'') {
                result.append('\'');
                result.append('\'');
            }
             else {
                result.append(matchCase ? chr : Character.toUpperCase(chr));
            }
            
        }
        
        return result.toString();
    }
    
    public String getSQL92LikePattern() throws IllegalArgumentException {
        if (escape.length() != 1) {
            throw new IllegalArgumentException( "Like Pattern --> escape char should be of length exactly 1");
        }
        
        if (wildcardSingle.length() != 1) {
            throw new IllegalArgumentException( "Like Pattern --> wildcardSingle char should be of length exactly 1");
        }
        
        if (wildcardMulti.length() != 1) {
            throw new IllegalArgumentException( "Like Pattern --> wildcardMulti char should be of length exactly 1");
        }
        
        return LikeFilterImpl.convertToSQL92( escape.charAt(0), wildcardMulti.charAt(0), wildcardSingle.charAt(0), matchingCase, pattern);
    }
    
    public void setWildCard(String wildCard) {
        if (wildCard == null || wildCard.isEmpty() || wildCard.length() > 1) {
            throw new IllegalArgumentException( "Like Pattern --> wildcardMulti char should be of length exactly 1");
        }
        
        this.wildcardMulti = wildCard;
        compPattern = null;
    }
    
    public void setSingleChar(String singleChar) {
        if (singleChar == null || singleChar.length() != 1) {
            throw new IllegalArgumentException( "Like Pattern --> wildcardSingle char should be of length exactly 1");
        }
        
        this.wildcardSingle = singleChar;
        compPattern = null;
    }
    
    public void setEscape(String escape) {
        if (escape.startsWith("\\")) {
            if (escape.length() < 1 || escape.length() > 3) {
                throw new IllegalArgumentException( "Like Pattern --> escape char should be of length exactly 1, not " + escape.length());
            }
            
        }
         else if (!escape.isEmpty() && escape.length() > 1) {
            throw new IllegalArgumentException( "Like Pattern --> escape char should be of length exactly 1, not " + escape.length());
        }
        
        this.escape = escape;
        compPattern = null;
    }
    
    public void setMatchCase(boolean matchingCase) {
        this.matchingCase = matchingCase;
        compPattern = null;
    }
    
    public boolean isMatchingCase() {
        return matchingCase;
    }
    
    public MatchAction getMatchAction() {
        return matchAction;
    }
    
    public void setMatchingCase(boolean matchingCase) {
        this.matchingCase = matchingCase;
    }
    
    private Matcher getMatcher(String string) {
        if (compPattern == null) {
            String pattern = new LikeToRegexConverter(this).getPattern();
            compPattern = isMatchingCase() ? Pattern.compile(pattern) : Pattern.compile( pattern, Pattern.CASE_INSENSITIVE );
        }
        
        return compPattern.matcher(string);
    }
    
    protected LikeFilterImpl() {
        this(MatchAction.ANY);
    }
    
    public LikeFilterImpl( org.opengis.filter.expression.Expression expr, String pattern, String wildcardMulti, String wildcardSingle, String escape) {
        this();
        setExpression(expr);
        setLiteral(pattern);
        setWildCard(wildcardMulti);
        setSingleChar(wildcardSingle);
        setEscape(escape);
    }
    
    protected LikeFilterImpl(MatchAction matchAction) {
        this.matchAction = matchAction;
    }
    
    public LikeFilterImpl( org.opengis.filter.expression.Expression expr, String pattern, String wildcardMulti, String wildcardSingle, String escape, MatchAction matchAction) {
        this(matchAction);
        setExpression(expr);
        setLiteral(pattern);
        setWildCard(wildcardMulti);
        setSingleChar(wildcardSingle);
        setEscape(escape);
    }
    
    public org.opengis.filter.expression.Expression getExpression() {
        return attribute;
    }
    
    public void setExpression(org.opengis.filter.expression.Expression e) {
        this.attribute = e;
    }
    
    public String getLiteral() {
        return this.pattern;
    }
    
    public void setLiteral(String literal) {
        this.pattern = literal;
        compPattern = null;
    }
    
    public boolean evaluate(Object feature) {
        if (attribute == null) {
            return false;
        }
        
        Object value = eval(attribute, feature);
        if (null == value) {
            return false;
        }
        
        if (value instanceof Collection) {
            int count = 0;
            for (Object element : (Collection) value) {
                Matcher matcher = getMatcher(element.toString());
                boolean temp = matcher.matches();
                if (temp) {
                    count++;
                }
                
                switch (matchAction) {
                    case ONE:
                        if (count > 1) return false;
                        break;
                    case ALL:
                        if (!temp) return false;
                        break;
                    case ANY:
                        if (temp) return true;
                        break;
                }
                
            }
            
            switch (matchAction) {
                case ONE:
                    return (count == 1);
                case ALL:
                    return true;
                case ANY:
                    return false;
                default: return false;
            }
            
        }
         else {
            Matcher matcher = getMatcher(value.toString());
            return matcher.matches();
        }
        
    }
    
    public String toString() {
        return "[ " + attribute.toString() + " is like " + pattern + " ]";
    }
    
    public java.lang.String getEscape() {
        return escape;
    }
    
    public String getWildCard() {
        return wildcardMulti;
    }
    
    public String getSingleChar() {
        return wildcardSingle;
    }
    
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LikeFilterImpl that = (LikeFilterImpl) o;
        return Objects.equals(attribute, that.attribute) && Objects.equals(pattern, that.pattern);
    }
    
    public int hashCode() {
        int result = 17;
        result = (37 * result) + ((attribute == null) ? 0 : attribute.hashCode());
        result = (37 * result) + ((pattern == null) ? 0 : pattern.hashCode());
        return result;
    }
    
    public Object accept(FilterVisitor visitor, Object extraData) {
        return visitor.visit(this, extraData);
    }
    
}


