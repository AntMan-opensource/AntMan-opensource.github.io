package org.geotools.data.postgis;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sql.DataSource;
import org.geotools.data.Parameter;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.jdbc.JDBCDataStoreFactory;
import org.geotools.jdbc.SQLDialect;
import org.geotools.util.KVP;
import org.geotools.util.logging.Logging;
import org.postgresql.jdbc.SslMode;
public class PostgisNGDataStoreFactory extends JDBCDataStoreFactory {
    static final Logger LOGGER = Logging.getLogger(PostgisNGDataStoreFactory.class);
    public static final Param DBTYPE = new Param( "dbtype", String.class, "Type", true, "postgis", Collections.singletonMap(Parameter.LEVEL, "program"));
    public static final Param LOOSEBBOX = new Param( "Loose bbox", Boolean.class, "Perform only primary filter on bbox", false, Boolean.TRUE);
    public static final Param ESTIMATED_EXTENTS = new Param( "Estimated extends", Boolean.class, "Use the spatial index information to quickly get an estimate of the data bounds", false, Boolean.TRUE);
    public static final Param PORT = new Param("port", Integer.class, "Port", true, 5432);
    public static final Param SCHEMA = new Param("schema", String.class, "Schema", false, "public");
    public static final Param CREATE_DB_IF_MISSING = new Param( "create database", Boolean.class, "Creates the database if it does not exist yet", false, false, Param.LEVEL, "advanced");
    public static final Param CREATE_PARAMS = new Param( "create database params", String.class, "Extra specifications appeneded to the CREATE DATABASE command", false, "", Param.LEVEL, "advanced");
    public static final Param PREPARED_STATEMENTS = new Param( "preparedStatements", Boolean.class, "Use prepared statements", false, Boolean.FALSE);
    public static final Param ENCODE_FUNCTIONS = new Param( "encode functions", Boolean.class, "set to true to have a set of filter functions be translated directly in SQL. " + "Due to differences in the type systems the result might not be the same as evaluating " + "them in memory, including the SQL failing with errors while the in memory version works fine. " + "However this allows to push more of the filter into the database, increasing performance." + "the postgis table.", false, Boolean.TRUE, new KVP(Param.LEVEL, "advanced"));
    public static final Param SIMPLIFY = new Param( "Support on the fly geometry simplification", Boolean.class, "When enabled, operations such as map rendering will pass a hint that will enable the usage of a simplification function", false, Boolean.TRUE);
    public static final Param SIMPLIFICATION_METHOD = new Param( "Method used to simplify geometries", SimplificationMethod.class, "Allows choosing the PostGIS simplification function to use, between ST_Simplify and ST_SimplifyPreserveTopology", false, SimplificationMethod.FAST, new KVP(Param.OPTIONS, Arrays.asList(SimplificationMethod.values())));
    public static final Param SSL_MODE = new Param( "SSL mode", SslMode.class, "The connectin SSL mode", false, SslMode.DISABLE, new KVP(Param.OPTIONS, Arrays.asList(SslMode.values())));
    protected SQLDialect createSQLDialect(JDBCDataStore dataStore, Map<String, ?> params) {
        PostGISDialect dialect = new PostGISDialect(dataStore);
        try {
            if (Boolean.TRUE.equals(PREPARED_STATEMENTS.lookUp(params))) {
                return new PostGISPSDialect(dataStore, dialect);
            }
            
        }
         catch (IOException e) {
            if (LOGGER.isLoggable(Level.FINE)){
                LOGGER.log( Level.FINE, "Failed to lookup prepared statement parameter, continuining with non prepared dialect", e);
}
        }
        
        return dialect;
    }
    
    protected SQLDialect createSQLDialect(JDBCDataStore dataStore) {
        return new PostGISDialect(dataStore);
    }
    
    protected String getDatabaseID() {
        return (String) DBTYPE.sample;
    }
    
    public String getDisplayName() {
        return "PostGIS";
    }
    
    public String getDescription() {
        return "PostGIS Database";
    }
    
    protected String getDriverClassName() {
        return "org.postgresql.Driver";
    }
    
    protected boolean checkDBType(Map<String, ?> params) {
        if (super.checkDBType(params)) {
            try {
                Class.forName("org.geotools.data.postgis.PostgisDataStoreFactory");
                return false;
            }
             catch (ClassNotFoundException e) {
                return true;
            }
            
        }
         else {
            return checkDBType(params, "postgisng");
        }
        
    }
    
    protected JDBCDataStore createDataStoreInternal(JDBCDataStore dataStore, Map<String, ?> params) throws IOException {
        SQLDialect genericDialect = dataStore.getSQLDialect();
        PostGISDialect dialect;
        if (genericDialect instanceof PostGISPSDialect) {
            dialect = ((PostGISPSDialect) genericDialect).getDelegate();
        }
         else {
            dialect = (PostGISDialect) dataStore.getSQLDialect();
        }
        
        Boolean loose = (Boolean) LOOSEBBOX.lookUp(params);
        dialect.setLooseBBOXEnabled(loose == null || Boolean.TRUE.equals(loose));
        Boolean estimated = (Boolean) ESTIMATED_EXTENTS.lookUp(params);
        dialect.setEstimatedExtentsEnabled(estimated == null || Boolean.TRUE.equals(estimated));
        Boolean encodeFunctions = (Boolean) ENCODE_FUNCTIONS.lookUp(params);
        dialect.setFunctionEncodingEnabled(encodeFunctions == null || encodeFunctions);
        Boolean usePs = (Boolean) PREPARED_STATEMENTS.lookUp(params);
        if (Boolean.TRUE.equals(usePs)) {
            dataStore.setSQLDialect(new PostGISPSDialect(dataStore, dialect));
        }
        
        Boolean simplify = (Boolean) SIMPLIFY.lookUp(params);
        dialect.setSimplifyEnabled(simplify == null || simplify);
        SimplificationMethod simplificationMethod = (SimplificationMethod) SIMPLIFICATION_METHOD.lookUp(params);
        dialect.setTopologyPreserved( SimplificationMethod.PRESERVETOPOLOGY.equals(simplificationMethod));
        Boolean encodeBBOXAsEnvelope = false;
        String largeGeometriesOptimized = System.getProperty("org.geotools.data.postgis.largeGeometriesOptimize");
        if (largeGeometriesOptimized != null) {
            encodeBBOXAsEnvelope = largeGeometriesOptimized.toLowerCase().equals("true");
        }
        
        dialect.setEncodeBBOXFilterAsEnvelope(Boolean.TRUE.equals(encodeBBOXAsEnvelope));
        return dataStore;
    }
    
    protected void setupParameters(Map<String, Object> parameters) {
        super.setupParameters(parameters);
        parameters.put(DBTYPE.key, DBTYPE);
        parameters.put(SCHEMA.key, SCHEMA);
        parameters.put(LOOSEBBOX.key, LOOSEBBOX);
        parameters.put(ESTIMATED_EXTENTS.key, ESTIMATED_EXTENTS);
        parameters.put(PORT.key, PORT);
        parameters.put(SSL_MODE.key, SSL_MODE);
        parameters.put(PREPARED_STATEMENTS.key, PREPARED_STATEMENTS);
        parameters.put(MAX_OPEN_PREPARED_STATEMENTS.key, MAX_OPEN_PREPARED_STATEMENTS);
        parameters.put(ENCODE_FUNCTIONS.key, ENCODE_FUNCTIONS);
        parameters.put(SIMPLIFY.key, SIMPLIFY);
        parameters.put(SIMPLIFICATION_METHOD.key, SIMPLIFICATION_METHOD);
        parameters.put(CREATE_DB_IF_MISSING.key, CREATE_DB_IF_MISSING);
        parameters.put(CREATE_PARAMS.key, CREATE_PARAMS);
    }
    
    protected String getValidationQuery() {
        return "select now()";
    }
    
    protected String getJDBCUrl(Map<String, ?> params) throws IOException {
        String host = (String) HOST.lookUp(params);
        String db = (String) DATABASE.lookUp(params);
        int port = (Integer) PORT.lookUp(params);
        String url = "jdbc:postgresql" + "://" + host + ":" + port + "/" + db;
        SslMode mode = (SslMode) SSL_MODE.lookUp(params);
        if (mode != null) {
            url = url + "?sslmode=" + mode + "&binaryTransferEnable=bytea";
        }
        
        return url;
    }
    
    protected DataSource createDataSource(Map<String, ?> params, SQLDialect dialect) throws IOException {
        DataSource ds = super.createDataSource(params, dialect);
        JDBCDataStore store = new JDBCDataStore();
        if (Boolean.TRUE.equals(CREATE_DB_IF_MISSING.lookUp(params))) {
            Connection cx = null;
            boolean canConnect = true;
            try {
                cx = ds.getConnection();
            }
             catch (SQLException e) {
                canConnect = false;
            }
             finally {
                store.closeSafe(cx);
            }
            
            if (!canConnect) {
                String host = (String) HOST.lookUp(params);
                int port = (Integer) PORT.lookUp(params);
                String db = (String) DATABASE.lookUp(params);
                String user = (String) USER.lookUp(params);
                String password = (String) PASSWD.lookUp(params);
                Statement st = null;
                try {
                    String url = "jdbc:postgresql" + "://" + host + ":" + port + "/template1";
                    cx = getConnection(user, password, url);
                    String createParams = (String) CREATE_PARAMS.lookUp(params);
                    String sql = "CREATE DATABASE \"" + db + "\" " + (createParams == null ? "" : createParams);
                    st = cx.createStatement();
                    st.execute(sql);
                }
                 catch (SQLException e) {
                    throw new IOException("Failed to create the target database", e);
                }
                 finally {
                    store.closeSafe(st);
                    store.closeSafe(cx);
                }
                
                ResultSet rs = null;
                try {
                    String url = "jdbc:postgresql" + "://" + host + ":" + port + "/" + db;
                    cx = DriverManager.getConnection(url, user, password);
                    st = cx.createStatement();
                    try {
                        rs = st.executeQuery("select PostGIS_version()");
                    }
                     catch (SQLException e) {
                        st.execute("create extension postgis");
                    }
                     finally {
                        store.closeSafe(rs);
                    }
                    
                }
                 catch (SQLException e) {
                    throw new IOException("Failed to create the target database", e);
                }
                 finally {
                    store.closeSafe(st);
                    store.closeSafe(cx);
                }
                
                ds = super.createDataSource(params, dialect);
            }
            
        }
        
        return ds;
    }
    
    private Connection getConnection(String user, String password, String url) throws SQLException {
        Connection cx;
        if (user != null) {
            cx = DriverManager.getConnection(url, user, password);
        }
         else {
            cx = DriverManager.getConnection(url);
        }
        
        return cx;
    }
    
    public void dropDatabase(Map<String, Object> params) throws IOException {
        JDBCDataStore store = new JDBCDataStore();
        String host = (String) HOST.lookUp(params);
        int port = (Integer) PORT.lookUp(params);
        String db = (String) DATABASE.lookUp(params);
        String user = (String) USER.lookUp(params);
        String password = (String) PASSWD.lookUp(params);
        Connection cx = null;
        Statement st = null;
        try {
            String url = "jdbc:postgresql" + "://" + host + ":" + port + "/template1";
            cx = getConnection(user, password, url);
            String sql = "DROP DATABASE \"" + db + "\"";
            st = cx.createStatement();
            st.execute(sql);
        }
         catch (SQLException e) {
            throw new IOException("Failed to drop the target database", e);
        }
         finally {
            store.closeSafe(st);
            store.closeSafe(cx);
        }
        
    }
    
}


