package org.geotools.data.jdbc;
import static org.geotools.filter.capability.FunctionNameImpl.parameter;
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Array;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.measure.Unit;
import javax.measure.UnitConverter;
import javax.measure.quantity.Length;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.filter.FilterCapabilities;
import org.geotools.filter.FunctionImpl;
import org.geotools.filter.LikeFilterImpl;
import org.geotools.filter.capability.FunctionNameImpl;
import org.geotools.filter.function.InFunction;
import org.geotools.filter.spatial.BBOXImpl;
import org.geotools.jdbc.EnumMapper;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.jdbc.JoinId;
import org.geotools.jdbc.JoinPropertyName;
import org.geotools.jdbc.PrimaryKey;
import org.geotools.jdbc.PrimaryKeyColumn;
import org.geotools.referencing.CRS;
import org.geotools.util.ConverterFactory;
import org.geotools.util.Converters;
import org.geotools.util.factory.Hints;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.filter.And;
import org.opengis.filter.BinaryComparisonOperator;
import org.opengis.filter.BinaryLogicOperator;
import org.opengis.filter.ExcludeFilter;
import org.opengis.filter.Filter;
import org.opengis.filter.FilterFactory;
import org.opengis.filter.FilterVisitor;
import org.opengis.filter.Id;
import org.opengis.filter.IncludeFilter;
import org.opengis.filter.NativeFilter;
import org.opengis.filter.Not;
import org.opengis.filter.Or;
import org.opengis.filter.PropertyIsBetween;
import org.opengis.filter.PropertyIsEqualTo;
import org.opengis.filter.PropertyIsGreaterThan;
import org.opengis.filter.PropertyIsGreaterThanOrEqualTo;
import org.opengis.filter.PropertyIsLessThan;
import org.opengis.filter.PropertyIsLessThanOrEqualTo;
import org.opengis.filter.PropertyIsLike;
import org.opengis.filter.PropertyIsNil;
import org.opengis.filter.PropertyIsNotEqualTo;
import org.opengis.filter.PropertyIsNull;
import org.opengis.filter.expression.Add;
import org.opengis.filter.expression.BinaryExpression;
import org.opengis.filter.expression.Divide;
import org.opengis.filter.expression.Expression;
import org.opengis.filter.expression.ExpressionVisitor;
import org.opengis.filter.expression.Function;
import org.opengis.filter.expression.Literal;
import org.opengis.filter.expression.Multiply;
import org.opengis.filter.expression.NilExpression;
import org.opengis.filter.expression.PropertyName;
import org.opengis.filter.expression.Subtract;
import org.opengis.filter.identity.Identifier;
import org.opengis.filter.spatial.BBOX;
import org.opengis.filter.spatial.Beyond;
import org.opengis.filter.spatial.BinarySpatialOperator;
import org.opengis.filter.spatial.Contains;
import org.opengis.filter.spatial.Crosses;
import org.opengis.filter.spatial.DWithin;
import org.opengis.filter.spatial.Disjoint;
import org.opengis.filter.spatial.DistanceBufferOperator;
import org.opengis.filter.spatial.Equals;
import org.opengis.filter.spatial.Intersects;
import org.opengis.filter.spatial.Overlaps;
import org.opengis.filter.spatial.Touches;
import org.opengis.filter.spatial.Within;
import org.opengis.filter.temporal.After;
import org.opengis.filter.temporal.AnyInteracts;
import org.opengis.filter.temporal.Before;
import org.opengis.filter.temporal.Begins;
import org.opengis.filter.temporal.BegunBy;
import org.opengis.filter.temporal.BinaryTemporalOperator;
import org.opengis.filter.temporal.During;
import org.opengis.filter.temporal.EndedBy;
import org.opengis.filter.temporal.Ends;
import org.opengis.filter.temporal.Meets;
import org.opengis.filter.temporal.MetBy;
import org.opengis.filter.temporal.OverlappedBy;
import org.opengis.filter.temporal.TContains;
import org.opengis.filter.temporal.TEquals;
import org.opengis.filter.temporal.TOverlaps;
import org.opengis.parameter.Parameter;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.crs.GeographicCRS;
import org.opengis.temporal.Instant;
import org.opengis.temporal.Period;
import si.uom.SI;
public class FilterToSQL implements FilterVisitor, ExpressionVisitor {
    private static final Map<String, Double> UNITS_MAP = new HashMap<String, Double>() {                 { put("kilometers", 1000.0);
                    put("kilometer", 1000.0);
                    put("km", 1000.0);
                    put("m", 1.0);
                    put("meter", 1.0);
                    put("mm", 0.001);
                    put("millimeter", 0.001);
                    put("mi", 1609.344);
                    put("miles", 1609.344);
                    put("nm", 1852d);
                    put("feet", 0.3048);
                    put("ft", 0.3048);
                    put("in", 0.0254);
                }
                
            };
    protected static final String IO_ERROR = "io problem writing filter";
    protected static FilterFactory filterFactory = CommonFactoryFinder.getFilterFactory(null);
    protected FilterCapabilities capabilities = null;
    protected static Logger LOGGER = org.geotools.util.logging.Logging.getLogger(FilterToSQL.class);
    protected String sqlNameEscape = "";
    protected Writer out;
    protected PrimaryKey primaryKey;
    protected String databaseSchema;
    protected SimpleFeatureType featureType;
    protected boolean encodingFunction = false;
    protected GeometryDescriptor currentGeometry;
    protected Integer currentSRID;
    protected Integer currentDimension;
    protected boolean inline = false;
    protected boolean inEncodingEnabled = true;
    public FilterToSQL() {}
    public FilterToSQL(Writer out) {
        this.out = out;
    }
    
    public void setWriter(Writer out) {
        this.out = out;
    }
    
    public void setInline(boolean inline) {
        this.inline = inline;
    }
    
    public boolean isInEncodingEnabled() {
        return inEncodingEnabled;
    }
    
    public void setInEncodingEnabled(boolean inEncodingEnabled) {
        this.inEncodingEnabled = inEncodingEnabled;
    }
    
    public void encode(Filter filter) throws FilterToSQLException {
        if (out == null) throw new FilterToSQLException("Can't encode to a null writer.");
        if (getCapabilities().fullySupports(filter)) {
            try {
                if (!inline) {
                    out.write("WHERE ");
                }
                
                filter.accept(this, null);
            }
             catch (java.io.IOException ioe) {
                LOGGER.warning("Unable to export filter" + ioe);
                throw new FilterToSQLException("Problem writing filter: ", ioe);
            }
            
        }
         else {
            throw new FilterToSQLException("Filter type not supported: " + filter);
        }
        
    }
    
    public String encodeToString(Filter filter) throws FilterToSQLException {
        StringWriter out = new StringWriter();
        this.out = out;
        this.encode(filter);
        return out.getBuffer().toString();
    }
    
    public void encode(Expression expression) throws FilterToSQLException {
        if (out == null) throw new FilterToSQLException("Can't encode to a null writer.");
        expression.accept(this, null);
    }
    
    public String encodeToString(Expression expression) throws FilterToSQLException {
        StringWriter out = new StringWriter();
        this.out = out;
        this.encode(expression);
        return out.getBuffer().toString();
    }
    
    public void setFeatureType(SimpleFeatureType featureType) {
        this.featureType = featureType;
    }
    
    public SimpleFeatureType getFeatureType() {
        return this.featureType;
    }
    
    public PrimaryKey getPrimaryKey() {
        return primaryKey;
    }
    
    public void setPrimaryKey(PrimaryKey primaryKey) {
        this.primaryKey = primaryKey;
    }
    
    public String getDatabaseSchema() {
        return databaseSchema;
    }
    
    public void setDatabaseSchema(String databaseSchema) {
        this.databaseSchema = databaseSchema;
    }
    
    protected FilterCapabilities createFilterCapabilities() {
        FilterCapabilities capabilities = new FilterCapabilities();
        if (inEncodingEnabled) {
            capabilities.addAll(InFunction.getInCapabilities());
        }
        
        capabilities.addType(Add.class);
        capabilities.addType(Subtract.class);
        capabilities.addType(Divide.class);
        capabilities.addType(Multiply.class);
        capabilities.addType(PropertyName.class);
        capabilities.addType(Literal.class);
        capabilities.addAll(FilterCapabilities.LOGICAL_OPENGIS);
        capabilities.addAll(FilterCapabilities.SIMPLE_COMPARISONS_OPENGIS);
        capabilities.addType(PropertyIsNull.class);
        capabilities.addType(PropertyIsBetween.class);
        capabilities.addType(PropertyIsLike.class);
        capabilities.addType(Id.class);
        capabilities.addType(IncludeFilter.class);
        capabilities.addType(ExcludeFilter.class);
        capabilities.addType(After.class);
        capabilities.addType(Before.class);
        capabilities.addType(Begins.class);
        capabilities.addType(BegunBy.class);
        capabilities.addType(During.class);
        capabilities.addType(Ends.class);
        capabilities.addType(EndedBy.class);
        capabilities.addType(TContains.class);
        capabilities.addType(TEquals.class);
        return capabilities;
    }
    
    public final synchronized FilterCapabilities getCapabilities() {
        if (capabilities == null) {
            capabilities = createFilterCapabilities();
        }
        
        return capabilities; 
    }
    
    public void setCapabilities(FilterCapabilities capabilities) {
        this.capabilities = capabilities;
    }
    
    public Object visit(ExcludeFilter filter, Object extraData) {
        try {
            out.write("0 = 1");
        }
         catch (IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(IncludeFilter filter, Object extraData) {
        try {
            out.write("1 = 1");
        }
         catch (IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(PropertyIsBetween filter, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting PropertyIsBetween");
        Expression expr = filter.getExpression();
        Expression lowerbounds = filter.getLowerBoundary();
        Expression upperbounds = filter.getUpperBoundary();
        Class context;
        AttributeDescriptor attType = (AttributeDescriptor) expr.evaluate(featureType);
        if (attType != null) {
            context = attType.getType().getBinding();
        }
         else {
            context = String.class;
        }
        
        try {
            expr.accept(this, extraData);
            out.write(" BETWEEN ");
            lowerbounds.accept(this, context);
            out.write(" AND ");
            upperbounds.accept(this, context);
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(PropertyIsLike filter, Object extraData) {
        char esc = filter.getEscape().charAt(0);
        char multi = filter.getWildCard().charAt(0);
        char single = filter.getSingleChar().charAt(0);
        boolean matchCase = filter.isMatchingCase();
        String literal = filter.getLiteral();
        Expression att = filter.getExpression();
        Class attributeType = getExpressionType(att);
        if (attributeType != null && Date.class.isAssignableFrom(attributeType)) {
            literal += multi;
        }
        
        String pattern = LikeFilterImpl.convertToSQL92(esc, multi, single, matchCase, literal);
        try {
            if (!matchCase) {
                out.write(" UPPER(");
            }
            
            att.accept(this, extraData);
            if (!matchCase) {
                out.write(") LIKE '");
            }
             else {
                out.write(" LIKE '");
            }
            
            out.write(pattern);
            out.write("' ");
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(And filter, Object extraData) {
        return visit((BinaryLogicOperator) filter, "AND");
    }
    
    public Object visit(Not filter, Object extraData) {
        try {
            if (filter.getFilter() instanceof PropertyIsNull) {
                Expression expr = ((PropertyIsNull) filter.getFilter()).getExpression();
                if (isEnumerated(expr)) {
                    writeEncodedField( Integer.class, (PropertyName) expr, (AttributeDescriptor) expr.evaluate(featureType));
                }
                 else {
                    expr.accept(this, extraData);
                }
                
                out.write(" IS NOT NULL ");
            }
             else {
                out.write("NOT (");
                filter.getFilter().accept(this, extraData);
                out.write(")");
            }
            
            return extraData;
        }
         catch (IOException e) {
            throw new RuntimeException(IO_ERROR, e);
        }
        
    }
    
    public Object visit(Or filter, Object extraData) {
        LinkedHashMap<Object, List<Literal>> grouped = new LinkedHashMap<>();
        int maxGroupSize = 0;
        for (Filter child : filter.getChildren()) {
            Expression[] nameLiteral = getNameLiteralFromEquality(child);
            if (nameLiteral == null) {
                grouped.put(child, null);
            }
             else {
                PropertyName name = (PropertyName) nameLiteral[0];
                Literal value = (Literal) nameLiteral[1];
                List<Literal> values = grouped.get(name);
                if (values == null) {
                    values = new ArrayList<>();
                    grouped.put(name, values);
                }
                
                values.add(value);
                maxGroupSize = Math.max(maxGroupSize, values.size());
            }
            
        }
        
        if (maxGroupSize < 2) {
            return visit((BinaryLogicOperator) filter, "OR");
        }
        
        try {
            Iterator<Map.Entry<Object, List<Literal>>> iterator = grouped.entrySet().iterator();
            if (grouped.size() > 1) {
                out.write("(");
            }
            
            while (iterator.hasNext()) {
                Map.Entry<Object, List<Literal>> entry = iterator.next();
                if (entry.getKey() instanceof PropertyName) {
                    PropertyName pn = (PropertyName) entry.getKey();
                    List<Literal> literals = entry.getValue();
                    pn.accept(this, extraData);
                    Class binding = getExpressionType(pn);
                    int literalsSize = literals.size();
                    if (literalsSize == 1) {
                        out.write(" = ");
                        literals.get(0).accept(this, binding);
                    }
                     else {
                        out.write(" IN (");
                        for (int i = 0; i < literalsSize; i++) {
                            literals.get(i).accept(this, binding);
                            if (i < literalsSize - 1) {
                                out.write(", ");
                            }
                            
                        }
                        
                        out.write(")");
                    }
                    
                }
                 else {
                    ((Filter) entry.getKey()).accept(this, extraData);
                }
                
                if (iterator.hasNext()) {
                    out.write(" OR ");
                }
                
            }
            
            if (grouped.size() > 1) {
                out.write(")");
            }
            
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    private Expression[] getNameLiteralFromEquality(Filter child) {
        if (child instanceof PropertyIsEqualTo) {
            PropertyIsEqualTo equal = (PropertyIsEqualTo) child;
            Expression ex1 = equal.getExpression1();
            Expression ex2 = equal.getExpression2();
            if (ex1 instanceof PropertyName && ex2 instanceof Literal) {
                return new Expression[] {ex1, ex2};
            }
             else if (ex2 instanceof PropertyName && ex1 instanceof Literal) {
                return new Expression[] {ex2, ex1};
            }
            
        }
        
        return null;
    }
    
    protected Object visit(BinaryLogicOperator filter, Object extraData) {
        LOGGER.finer("exporting LogicFilter");
        String type = (String) extraData;
        try {
            java.util.Iterator list = filter.getChildren().iterator();
            out.write("(");
            while (list.hasNext()) {
                ((Filter) list.next()).accept(this, extraData);
                if (list.hasNext()) {
                    out.write(" " + type + " ");
                }
                
            }
            
            out.write(")");
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(PropertyIsEqualTo filter, Object extraData) {
        visitBinaryComparisonOperator(filter, "=");
        return extraData;
    }
    
    public Object visit(PropertyIsGreaterThanOrEqualTo filter, Object extraData) {
        visitBinaryComparisonOperator(filter, ">=");
        return extraData;
    }
    
    public Object visit(PropertyIsGreaterThan filter, Object extraData) {
        visitBinaryComparisonOperator(filter, ">");
        return extraData;
    }
    
    public Object visit(PropertyIsLessThan filter, Object extraData) {
        visitBinaryComparisonOperator(filter, "<");
        return extraData;
    }
    
    public Object visit(PropertyIsLessThanOrEqualTo filter, Object extraData) {
        visitBinaryComparisonOperator(filter, "<=");
        return extraData;
    }
    
    public Object visit(PropertyIsNotEqualTo filter, Object extraData) {
        visitBinaryComparisonOperator(filter, "!=");
        return extraData;
    }
    
    protected void visitBinaryComparisonOperator(BinaryComparisonOperator filter, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting SQL ComparisonFilter");
        Expression left = filter.getExpression1();
        Expression right = filter.getExpression2();
        if (inEncodingEnabled && ("=".equals(extraData) || "!=".equals(extraData))) {
            if (right instanceof Literal && InFunction.isInFunction(left) && right.evaluate(null, Boolean.class) != null) {
                encodeInComparison((Function) left, (Literal) right, extraData);
                return;
            }
             else if (left instanceof Literal && InFunction.isInFunction(right) && left.evaluate(null, Boolean.class) != null) {
                encodeInComparison((Function) right, (Literal) left, extraData);
                return;
            }
            
        }
        
        Class rightContext = getExpressionType(left);
        Class leftContext = getExpressionType(right);
        encodeBinaryComparisonOperator(filter, extraData, left, right, leftContext, rightContext);
    }
    
    protected void encodeBinaryComparisonOperator( BinaryComparisonOperator filter, Object extraData, Expression left, Expression right, Class leftContext, Class rightContext) {
        boolean matchCase = true;
        if (!filter.isMatchingCase()) {
            if (filter instanceof PropertyIsEqualTo || filter instanceof PropertyIsNotEqualTo) {
                if (String.class.equals(leftContext) || String.class.equals(rightContext)) {
                    matchCase = false;
                }
                
            }
            
        }
        
        String type = (String) extraData;
        try {
            if (isEnumerated(right) || isEnumerated(left)) {
                encodeEnumeratedComparison(right, left, type, matchCase);
                return;
            }
            
            if (matchCase) {
                writeBinaryExpressionMember(left, leftContext);
                out.write(" " + type + " ");
                writeBinaryExpressionMember(right, rightContext);
            }
             else {
                FunctionImpl f = new FunctionImpl() {                             { functionName = new FunctionNameImpl( "lower", parameter("lowercase", String.class), parameter("string", String.class));
                            }
                            
                        };
                f.setName("lower");
                f.setParameters(Arrays.asList(left));
                f.accept(this, Arrays.asList(leftContext));
                out.write(" " + type + " ");
                f.setParameters(Arrays.asList(right));
                f.accept(this, Arrays.asList(rightContext));
            }
            
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
    }
    
    private void encodeEnumeratedComparison( Expression right, Expression left, String type, boolean matchCase) throws IOException {
        EnumMapper mapper = getEnumMapper(right);
        if (mapper != null) {
            PropertyName rightName = (PropertyName) right;
            if (left instanceof Literal) {
                String value = left.evaluate(null, String.class);
                Integer code = mapper.fromString(value, matchCase);
                if (code == null) {
                    out.write("FALSE");
                }
                 else {
                    out.write(String.valueOf(code));
                    out.write(" " + type + " ");
                    writeEncodedField( Integer.class, rightName, (AttributeDescriptor) right.evaluate(featureType));
                }
                
            }
             else {
                out.write("CASE ");
                if (!matchCase) {
                    out.write("lower(");
                    writeBinaryExpressionMember(left, Integer.class);
                    out.write(")");
                }
                
                for (Map.Entry<String, Integer> entry : mapper.getStringToInteger().entrySet()) {
                    out.write("WHEN '" + entry.getKey() + "' THEN " + entry.getValue() + "\n");
                }
                
                out.write("END");
                out.write(" " + type + " ");
                writeEncodedField( Integer.class, rightName, (AttributeDescriptor) right.evaluate(featureType));
            }
            
        }
         else {
            mapper = getEnumMapper(left);
            PropertyName leftName = (PropertyName) left;
            if (right instanceof Literal) {
                String value = right.evaluate(null, String.class);
                Integer code = mapper.fromString(value, matchCase);
                if (code == null) {
                    out.write("FALSE");
                }
                 else {
                    writeEncodedField( Integer.class, leftName, (AttributeDescriptor) left.evaluate(featureType));
                    out.write(" " + type + " ");
                    out.write(String.valueOf(code));
                }
                
            }
             else {
                writeEncodedField( Integer.class, leftName, (AttributeDescriptor) left.evaluate(featureType));
                out.write(" " + type + " ");
                out.write("CASE ");
                if (!matchCase) {
                    out.write("lower(");
                    writeBinaryExpressionMember(right, Integer.class);
                    out.write(")");
                }
                
                for (Map.Entry<String, Integer> entry : mapper.getStringToInteger().entrySet()) {
                    out.write("WHEN '" + entry.getKey() + "' THEN " + entry.getValue() + "\n");
                }
                
                out.write("END");
            }
            
        }
        
    }
    
    private boolean isEnumerated(Expression ex) {
        return getEnumMapper(ex) != null;
    }
    
    private EnumMapper getEnumMapper(Expression ex) {
        if (ex instanceof PropertyName) {
            AttributeDescriptor ad = (AttributeDescriptor) ex.evaluate(featureType);
            if (ad != null) {
                Object o = ad.getUserData().get(JDBCDataStore.JDBC_ENUM_MAP);
                if (o instanceof EnumMapper) {
                    return (EnumMapper) o;
                }
                
            }
            
        }
        
        return null;
    }
    
    protected void writeBinaryExpressionMember(Expression exp, Class context) throws IOException {
        if (context != null && isBinaryExpression(exp)) {
            writeBinaryExpression(exp, context);
        }
         else {
            exp.accept(this, context);
        }
        
    }
    
    public Class getExpressionType(Expression expression) {
        Class binding = null;
        if (expression instanceof PropertyName) {
            AttributeDescriptor attType = (AttributeDescriptor) expression.evaluate(featureType);
            if (attType != null) {
                binding = attType.getType().getBinding();
            }
            
        }
         else if (expression instanceof Function) {
            Class ret = getFunctionReturnType((Function) expression);
            if (ret != null) {
                binding = ret;
            }
            
        }
        
        return binding;
    }
    
    private void encodeInComparison(Function in, Literal bool, Object extraData) {
        boolean negated = "!=".equals(extraData);
        if (bool.evaluate(null, Boolean.class) == Boolean.FALSE) {
            negated = !negated;
        }
        
        visitInFunction(in, false, negated, null);
    }
    
    protected void writeBinaryExpression(Expression e, Class context) throws IOException {
        Writer tmp = out;
        try {
            out = new StringWriter();
            out.write("(");
            e.accept(this, null);
            out.write(")");
            tmp.write(cast(out.toString(), context));
        }
         finally {
            out = tmp;
        }
        
    }
    
    protected Class getFunctionReturnType(Function f) {
        Class clazz = Object.class;
        if (f.getFunctionName() != null && f.getFunctionName().getReturn() != null) {
            clazz = f.getFunctionName().getReturn().getType();
        }
        
        if (clazz == Object.class) {
            clazz = null;
        }
        
        return clazz;
    }
    
    protected boolean isBinaryExpression(Expression e) {
        return e instanceof BinaryExpression;
    }
    
    public Object visit(PropertyIsNull filter, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting NullFilter");
        Expression expr = filter.getExpression();
        try {
            if (isEnumerated(expr)) {
                writeEncodedField( Integer.class, (PropertyName) expr, (AttributeDescriptor) expr.evaluate(featureType));
            }
             else {
                expr.accept(this, extraData);
            }
            
            out.write(" IS NULL ");
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
        
        return extraData;
    }
    
    public Object visit(PropertyIsNil filter, Object extraData) {
        throw new UnsupportedOperationException("isNil not supported");
    }
    
    public Object visit(Id filter, Object extraData) {
        if (primaryKey == null) {
            throw new RuntimeException("Must set primary key before trying to encode FIDFilters");
        }
        
        Set ids = filter.getIdentifiers();
        LOGGER.finer("Exporting FID=" + ids);
        try {
            if (ids.size() > 1) {
                out.write("(");
            }
            
            List<PrimaryKeyColumn> columns = primaryKey.getColumns();
            for (Iterator i = ids.iterator(); i.hasNext(); ) {
                Identifier id = (Identifier) i.next();
                List<Object> attValues = JDBCDataStore.decodeFID(primaryKey, id.toString(), false);
                out.write("(");
                for (int j = 0; j < attValues.size(); j++) {
                    if (filter instanceof JoinId) {
                        out.write(escapeName(((JoinId) filter).getAlias()));
                        out.write(".");
                    }
                    
                    out.write(escapeName(columns.get(j).getName()));
                    out.write(" = '");
                    out.write( attValues.get(j).toString()); 
                    out.write("'");
                    if (j < (attValues.size() - 1)) {
                        out.write(" AND ");
                    }
                    
                }
                
                out.write(")");
                if (i.hasNext()) {
                    out.write(" OR ");
                }
                
            }
            
            if (ids.size() > 1) {
                out.write(")");
            }
            
        }
         catch (java.io.IOException e) {
            throw new RuntimeException(IO_ERROR, e);
        }
        
        return extraData;
    }
    
    public Object visit(BBOX filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Beyond filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Contains filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Crosses filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Disjoint filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(DWithin filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Equals filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Intersects filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Overlaps filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Touches filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    public Object visit(Within filter, Object extraData) {
        return visitBinarySpatialOperator(filter, extraData);
    }
    
    protected Object visitBinarySpatialOperator(BinarySpatialOperator filter, Object extraData) {
        if (filter == null) throw new NullPointerException("Filter to be encoded cannot be null");
        if (!(filter instanceof BinarySpatialOperator)){
            throw new IllegalArgumentException( "This filter is not a binary spatial operator, " + "can't do SDO relate against it: " + filter.getClass());
}
        BinarySpatialOperator op = filter;
        Expression e1 = op.getExpression1();
        Expression e2 = op.getExpression2();
        if (e1 instanceof Literal && e2 instanceof PropertyName) {
            e1 = op.getExpression2();
            e2 = op.getExpression1();
        }
        
        if (e1 instanceof PropertyName) {
            currentGeometry = null;
            currentSRID = null;
            currentDimension = null;
            if (featureType != null) {
                AttributeDescriptor descriptor = (AttributeDescriptor) e1.evaluate(featureType);
                if (descriptor instanceof GeometryDescriptor) {
                    currentGeometry = (GeometryDescriptor) descriptor;
                    currentSRID = (Integer) descriptor.getUserData().get(JDBCDataStore.JDBC_NATIVE_SRID);
                    currentDimension = (Integer) descriptor.getUserData().get(Hints.COORDINATE_DIMENSION);
                }
                
            }
            
        }
        
        if (e1 instanceof PropertyName && e2 instanceof Literal) {
            return visitBinarySpatialOperator( filter, (PropertyName) e1, (Literal) e2, filter.getExpression1() instanceof Literal, extraData);
        }
         else {
            return visitBinarySpatialOperator(filter, e1, e2, extraData);
        }
        
    }
    
    protected Object visitBinarySpatialOperator( BinarySpatialOperator filter, PropertyName property, Literal geometry, boolean swapped, Object extraData) {
        throw new RuntimeException( "Subclasses must implement this method in order to handle geometries");
    }
    
    protected Object visitBinarySpatialOperator( BinarySpatialOperator filter, Expression e1, Expression e2, Object extraData) {
        throw new RuntimeException( "Subclasses must implement this method in order to handle geometries");
    }
    
    protected Object visitBinaryTemporalOperator(BinaryTemporalOperator filter, Object extraData) {
        if (filter == null) {
            throw new NullPointerException("Null filter");
        }
        
        Expression e1 = filter.getExpression1();
        Expression e2 = filter.getExpression2();
        if (e1 instanceof Literal && e2 instanceof PropertyName) {
            e1 = filter.getExpression2();
            e2 = filter.getExpression1();
        }
        
        if (e1 instanceof PropertyName && e2 instanceof Literal) {
            return visitBinaryTemporalOperator( filter, (PropertyName) e1, (Literal) e2, filter.getExpression1() instanceof Literal, extraData);
        }
         else {
            return visitBinaryTemporalOperator(filter, e1, e2, extraData);
        }
        
    }
    
    protected Object visitBinaryTemporalOperator( BinaryTemporalOperator filter, PropertyName property, Literal temporal, boolean swapped, Object extraData) {
        Class typeContext = null;
        AttributeDescriptor attType = (AttributeDescriptor) property.evaluate(featureType);
        if (attType != null) {
            typeContext = attType.getType().getBinding();
        }
        
        Period period = null;
        if (temporal.evaluate(null) instanceof Period) {
            period = (Period) temporal.evaluate(null);
        }
        
        if ((filter instanceof Begins || filter instanceof BegunBy || filter instanceof Ends || filter instanceof EndedBy || filter instanceof During || filter instanceof TContains) && period == null) {
            throw new IllegalArgumentException("Filter requires a time period");
        }
        
        if (filter instanceof TEquals && period != null) {
            throw new IllegalArgumentException("TEquals filter does not accept time period");
        }
        
        if ((filter instanceof Begins || filter instanceof Ends || filter instanceof During) && swapped) {
            throw new IllegalArgumentException("Time period must be second argument of Filter");
        }
        
        if ((filter instanceof BegunBy || filter instanceof EndedBy || filter instanceof TContains) && !swapped) {
            throw new IllegalArgumentException("Time period must be first argument of Filter");
        }
        
        try {
            if (filter instanceof After || filter instanceof Before) {
                String op = filter instanceof After ? " > " : " < ";
                String inv = filter instanceof After ? " < " : " > ";
                if (period != null) {
                    out.write("(");
                    property.accept(this, extraData);
                    out.write(swapped ? inv : op);
                    visitBegin(period, extraData);
                    out.write(" AND ");
                    property.accept(this, extraData);
                    out.write(swapped ? inv : op);
                    visitEnd(period, extraData);
                    out.write(")");
                }
                 else {
                    if (swapped) {
                        temporal.accept(this, typeContext);
                    }
                     else {
                        property.accept(this, extraData);
                    }
                    
                    out.write(op);
                    if (swapped) {
                        property.accept(this, extraData);
                    }
                     else {
                        temporal.accept(this, typeContext);
                    }
                    
                }
                
            }
             else if (filter instanceof Begins || filter instanceof Ends || filter instanceof BegunBy || filter instanceof EndedBy) {
                property.accept(this, extraData);
                out.write(" = ");
                if (filter instanceof Begins || filter instanceof BegunBy) {
                    visitBegin(period, extraData);
                }
                 else {
                    visitEnd(period, extraData);
                }
                
            }
             else if (filter instanceof During || filter instanceof TContains) {
                property.accept(this, extraData);
                out.write(" BETWEEN ");
                visitBegin(period, extraData);
                out.write(" AND ");
                visitEnd(period, extraData);
            }
             else if (filter instanceof TEquals) {
                property.accept(this, extraData);
                out.write(" = ");
                temporal.accept(this, typeContext);
            }
            
        }
         catch (IOException e) {
            throw new RuntimeException("Error encoding temporal filter", e);
        }
        
        return extraData;
    }
    
    void visitBegin(Period p, Object extraData) {
        filterFactory.literal(p.getBeginning().getPosition().getDate()).accept(this, extraData);
    }
    
    void visitEnd(Period p, Object extraData) {
        filterFactory.literal(p.getEnding().getPosition().getDate()).accept(this, extraData);
    }
    
    protected Object visitBinaryTemporalOperator( BinaryTemporalOperator filter, Expression e1, Expression e2, Object extraData) {
        if (!(filter instanceof After || filter instanceof Before || filter instanceof TEquals)) {
            throw new IllegalArgumentException( "Unsupported filter: " + filter + ". Only After,Before,TEquals supported");
        }
        
        String op = filter instanceof After ? ">" : filter instanceof Before ? "<" : "=";
        try {
            e1.accept(this, extraData);
            out.write(" " + op + " ");
            e2.accept(this, extraData);
        }
         catch (IOException e) {
            return new RuntimeException("Error encoding temporal filter", e);
        }
        
        return extraData;
    }
    
    public Object visitNullFilter(Object extraData) {
        return extraData;
    }
    
    public Object visit(PropertyName expression, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting PropertyName");
        Class target = null;
        if (extraData instanceof Class) {
            target = (Class) extraData;
        }
        
        try {
            SimpleFeatureType featureType = this.featureType;
            if (expression instanceof JoinPropertyName) {
                out.write(escapeName(((JoinPropertyName) expression).getAlias()));
                out.write(".");
            }
            
            AttributeDescriptor attribute = null;
            EnumMapper mapper = null;
            try {
                attribute = (AttributeDescriptor) expression.evaluate(featureType);
                if (attribute != null) {
                    mapper = (EnumMapper) attribute.getUserData().get(JDBCDataStore.JDBC_ENUM_MAP);
                }
                
            }
             catch (Exception e) {
                String msg = "Error occured mapping " + expression + " to feature type";
                LOGGER.log(Level.WARNING, msg, e);
            }
            
            if (mapper != null) {
                out.write("CASE ");
            }
            
            writeEncodedField(target, expression, attribute);
            if (mapper != null) {
                out.write("\n ");
                for (Map.Entry<Integer, String> entry : mapper.getIntegerToString().entrySet()) {
                    out.write("WHEN " + entry.getKey() + " THEN '" + entry.getValue() + "'\n");
                }
                
                out.write("END");
            }
            
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException("IO problems writing attribute exp", ioe);
        }
        
        return extraData;
    }
    
    private void writeEncodedField( Class<?> target, PropertyName expression, AttributeDescriptor attribute) throws IOException {
        String encodedField;
        if (attribute != null) {
            encodedField = fieldEncoder.encode(escapeName(attribute.getLocalName()));
            if (target != null && target.isAssignableFrom(attribute.getType().getBinding())) {
                target = null;
            }
            
        }
         else {
            encodedField = fieldEncoder.encode(escapeName(expression.getPropertyName()));
        }
        
        if (target != null) {
            out.write(cast(encodedField, target));
        }
         else {
            out.write(encodedField);
        }
        
    }
    
    protected String cast(String encodedProperty, Class target) throws IOException {
        return encodedProperty;
    }
    
    public Object visit(Literal expression, Object context) throws RuntimeException {
        LOGGER.finer("exporting LiteralExpression");
        Class target = null;
        if (context instanceof Class) {
            target = (Class) context;
        }
        
        try {
            Object literal = evaluateLiteral(expression, target);
            if (literal instanceof Geometry) {
                visitLiteralGeometry(filterFactory.literal(literal));
            }
             else if (literal instanceof Envelope) {
                visitLiteralGeometry( filterFactory.literal(BBOXImpl.boundingPolygon((Envelope) literal)));
            }
             else {
                writeLiteral(literal);
            }
            
        }
         catch (IOException e) {
            throw new RuntimeException("IO problems writing literal", e);
        }
        
        return context;
    }
    
    public Object evaluateLiteral(Literal expression, Class<?> target) {
        Object literal = null;
        if (target != null) {
            if (Number.class.isAssignableFrom(target)) {
                literal = safeConvertToNumber(expression, target);
                if (literal == null) {
                    literal = safeConvertToNumber(expression, Number.class);
                }
                
            }
             else {
                literal = expression.evaluate(null, target);
            }
            
        }
        
        if (target == null) {
            Number number = safeConvertToNumber(expression, Number.class);
            if (number != null) {
                literal = number;
            }
            
        }
        
        if (literal == null) literal = expression.evaluate(null);
        if (literal == null) literal = expression.getValue();
        return literal;
    }
    
    Number safeConvertToNumber(Expression expression, Class<?> target) {
        Object evaluated = expression.evaluate(null);
        if (evaluated != null && evaluated.getClass().isArray()) {
            return null;
        }
        
        return (Number) Converters.convert( evaluated, target, new Hints(ConverterFactory.SAFE_CONVERSION, true));
    }
    
    protected void writeLiteral(Object literal) throws IOException {
        if (literal == null) {
            out.write("NULL");
        }
         else if (literal instanceof Number || literal instanceof Boolean) {
            out.write(String.valueOf(literal));
        }
         else if (literal instanceof java.sql.Date || literal instanceof java.sql.Timestamp) {
            out.write("'" + literal + "'");
        }
         else if (literal instanceof java.util.Date) {
            Timestamp ts = new java.sql.Timestamp(((Date) literal).getTime());
            out.write("'" + ts + "'");
        }
         else if (literal instanceof Instant) {
            java.util.Date date = ((Instant) literal).getPosition().getDate();
            Timestamp ts = new java.sql.Timestamp(date.getTime());
            out.write("'" + ts + "'");
        }
         else if (literal.getClass().isArray()) {
            out.write("ARRAY[");
            int length = Array.getLength(literal);
            for (int i = 0; i < length; i++) {
                writeLiteral(Array.get(literal, i));
                if (i < length - 1) {
                    out.write(", ");
                }
                
            }
            
            out.write("]");
        }
         else {
            String encoding = Converters.convert(literal, String.class, null);
            if (encoding == null) {
                encoding = literal.toString();
            }
            
            String escaped = encoding.replaceAll("'", "''");
            out.write("'" + escaped + "'");
        }
        
    }
    
    protected void visitLiteralGeometry(Literal expression) throws IOException {
        throw new RuntimeException( "Subclasses must implement this method in order to handle geometries");
    }
    
    protected void visitLiteralTimePeriod(Period expression) {
        throw new RuntimeException( "Time periods not supported, subclasses must implement this " + "method to support encoding timeperiods");
    }
    
    public Object visit(Add expression, Object extraData) {
        return visit(expression, "+", extraData);
    }
    
    public Object visit(Divide expression, Object extraData) {
        return visit(expression, "/", extraData);
    }
    
    public Object visit(Multiply expression, Object extraData) {
        return visit(expression, "*", extraData);
    }
    
    public Object visit(Subtract expression, Object extraData) {
        return visit(expression, "-", extraData);
    }
    
    protected Object visit(BinaryExpression expression, String operator, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting Expression Math");
        try {
            encodeBinaryExpressionChild(expression.getExpression1(), extraData);
            out.write(" " + operator + " ");
            encodeBinaryExpressionChild(expression.getExpression2(), extraData);
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException("IO problems writing expression", ioe);
        }
        
        return extraData;
    }
    
    private void encodeBinaryExpressionChild(Expression expression, Object extraData) throws IOException {
        boolean needsParens = expression instanceof BinaryExpression;
        if (needsParens) out.write("(");
        expression.accept(this, extraData);
        if (needsParens) out.write(")");
    }
    
    public Object visit(Function function, Object extraData) throws RuntimeException {
        if (inEncodingEnabled && InFunction.isInFunction(function)) {
            visitInFunction(function, true, false, extraData);
        }
         else {
            try {
                List<Expression> parameters = function.getParameters();
                encodingFunction = true;
                out.write(getFunctionName(function));
                out.write("(");
                List<Parameter<?>> arguments = function.getFunctionName().getArguments();
                Parameter<?> lastArgument = arguments.isEmpty() ? null : arguments.get(arguments.size() - 1);
                for (int i = 0; i < parameters.size(); i++) {
                    Expression e = parameters.get(i);
                    Object context;
                    if (arguments.size() <= i && (lastArgument.getMaxOccurs() > 0 || lastArgument.getMaxOccurs() == -1)) {
                        context = lastArgument.getType();
                    }
                     else {
                        context = arguments.get(i).getType();
                    }
                    
                    e.accept(this, context);
                    if (i < parameters.size() - 1) {
                        out.write(",");
                    }
                    
                }
                
                out.write(")");
                encodingFunction = false;
            }
             catch (IOException e) {
                throw new RuntimeException(e);
            }
            
        }
        
        return extraData;
    }
    
    protected void visitInFunction( Function function, boolean encodeAsExpression, boolean negate, Object extraData) {
        try {
            if (encodeAsExpression) {
                out.write("(");
            }
            
            List<Expression> parameters = function.getParameters();
            Class context = function.getParameters().stream() .filter(p -> p instanceof PropertyName) .map(p -> p.evaluate(featureType)) .filter(o -> o instanceof AttributeDescriptor) .map(o -> ((AttributeDescriptor) o).getType().getBinding()) .findFirst() .orElse(null);
            function.getParameters().get(0).accept(this, context);
            if (negate) {
                out.write(" NOT IN (");
            }
             else {
                out.write(" IN (");
            }
            
            int size = parameters.size();
            for (int i = 1; i < size; i++) {
                Expression e = function.getParameters().get(i);
                e.accept(this, context);
                if (i < size - 1) {
                    out.write(", ");
                }
                
            }
            
            out.write(")");
            if (encodeAsExpression) {
                out.write(")");
            }
            
        }
         catch (IOException e) {
            throw new RuntimeException(e);
        }
        
    }
    
    protected Expression getParameter(Function function, int idx, boolean mandatory) {
        final List<Expression> params = function.getParameters();
        if (params == null || params.size() <= idx) {
            if (mandatory) {
                throw new IllegalArgumentException( "Missing parameter number " + (idx + 1) + " for function " + function.getName() + ", cannot encode in SQL");
            }
             else {
                return null;
            }
            
        }
        
        return params.get(idx);
    }
    
    protected String getFunctionName(Function function) {
        return function.getName();
    }
    
    public Object visit(NilExpression expression, Object extraData) {
        try {
            out.write(" ");
        }
         catch (java.io.IOException ioe) {
            throw new RuntimeException("IO problems writing expression", ioe);
        }
        
        return extraData;
    }
    
    public Object visit(After after, Object extraData) {
        return visitBinaryTemporalOperator(after, extraData);
    }
    
    public Object visit(AnyInteracts anyInteracts, Object extraData) {
        return visitBinaryTemporalOperator(anyInteracts, extraData);
    }
    
    public Object visit(Before before, Object extraData) {
        return visitBinaryTemporalOperator(before, extraData);
    }
    
    public Object visit(Begins begins, Object extraData) {
        return visitBinaryTemporalOperator(begins, extraData);
    }
    
    public Object visit(BegunBy begunBy, Object extraData) {
        return visitBinaryTemporalOperator(begunBy, extraData);
    }
    
    public Object visit(During during, Object extraData) {
        return visitBinaryTemporalOperator(during, extraData);
    }
    
    public Object visit(EndedBy endedBy, Object extraData) {
        return visitBinaryTemporalOperator(endedBy, extraData);
    }
    
    public Object visit(Ends ends, Object extraData) {
        return visitBinaryTemporalOperator(ends, extraData);
    }
    
    public Object visit(Meets meets, Object extraData) {
        return visitBinaryTemporalOperator(meets, extraData);
    }
    
    public Object visit(MetBy metBy, Object extraData) {
        return visitBinaryTemporalOperator(metBy, extraData);
    }
    
    public Object visit(OverlappedBy overlappedBy, Object extraData) {
        return visitBinaryTemporalOperator(overlappedBy, extraData);
    }
    
    public Object visit(TContains contains, Object extraData) {
        return visitBinaryTemporalOperator(contains, extraData);
    }
    
    public Object visit(TEquals equals, Object extraData) {
        return visitBinaryTemporalOperator(equals, extraData);
    }
    
    public Object visit(TOverlaps contains, Object extraData) {
        return visitBinaryTemporalOperator(contains, extraData);
    }
    
    public void setSqlNameEscape(String escape) {
        sqlNameEscape = escape;
    }
    
    public String getSqlNameEscape() {
        return sqlNameEscape;
    }
    
    public String escapeName(String name) {
        if (sqlNameEscape.isEmpty()) return name;
        StringBuilder sb = new StringBuilder();
        sb.append(sqlNameEscape);
        int offset = 0;
        int escapeOffset;
        while ((escapeOffset = name.indexOf(sqlNameEscape, offset)) != -1) {
            sb.append(name.substring(offset, escapeOffset));
            sb.append(sqlNameEscape);
            sb.append(sqlNameEscape);
            offset = escapeOffset + sqlNameEscape.length();
        }
        
        sb.append(name.substring(offset));
        sb.append(sqlNameEscape);
        return sb.toString();
    }
    
    public static interface FieldEncoder {
        public String encode(String s);
    }
    
    private static class DefaultFieldEncoder implements FieldEncoder {
        public static DefaultFieldEncoder DEFAULT_FIELD_ENCODER = new DefaultFieldEncoder();
        private DefaultFieldEncoder() {};
        public String encode(String s) {
            return s;
        }
        
    }
    
    protected FieldEncoder fieldEncoder = DefaultFieldEncoder.DEFAULT_FIELD_ENCODER;
    public void setFieldEncoder(FieldEncoder fieldEncoder) {
        this.fieldEncoder = fieldEncoder;
    }
    
    protected double getDistanceInMeters(DistanceBufferOperator operator) {
        double distance = operator.getDistance();
        String units = operator.getDistanceUnits();
        if (units == null || UNITS_MAP.get(units.toLowerCase()) == null) {
            return distance;
        }
        
        double factor = UNITS_MAP.get(units.toLowerCase());
        return distance * factor;
    }
    
    protected double getDistanceInNativeUnits(DistanceBufferOperator operator) {
        if (currentSRID == null) {
            return operator.getDistance();
        }
        
        try {
            CoordinateReferenceSystem crs = CRS.getHorizontalCRS(CRS.decode("EPSG:" + currentSRID));
            double distanceMeters = getDistanceInMeters(operator);
            if (crs instanceof GeographicCRS) {
                double sizeDegree = 110574.2727;
                Coordinate center = getReferenceGeometryCentroid(operator);
                if (center != null) {
                    double cosLat = Math.cos(Math.PI * center.y / 180.0);
                    double latAdjustment = Math.sqrt(1 + cosLat * cosLat) / Math.sqrt(2.0);
                    sizeDegree *= latAdjustment;
                }
                
                return distanceMeters / sizeDegree;
            }
             else {
                @SuppressWarnings("unchecked")
                Unit<Length> unit = (Unit<Length>) crs.getCoordinateSystem().getAxis(0).getUnit();
                if (unit == null) {
                    return distanceMeters;
                }
                 else {
                    UnitConverter converter = SI.METRE.getConverterTo(unit);
                    return converter.convert(distanceMeters);
                }
                
            }
            
        }
         catch (Exception e) {
            LOGGER.log( Level.FINE, "Failed to turn the distance of spatial " + "filter into native units, using it as a pure number instead", e);
            return operator.getDistance();
        }
        
    }
    
    protected Coordinate getReferenceGeometryCentroid(DistanceBufferOperator operator) {
        Geometry geom = operator.getExpression1().evaluate(null, Geometry.class);
        if (geom == null) {
            geom = operator.getExpression2().evaluate(null, Geometry.class);
        }
        
        if (geom == null) {
            return null;
        }
        
        return geom.getCentroid().getCoordinate();
    }
    
    public Object visit(NativeFilter filter, Object data) {
        try {
            out.write("(" + filter.getNative() + ")");
        }
         catch (Exception exception) {
            throw new RuntimeException( String.format("Error encoding native filter '%s'.", filter.getNative()), exception);
        }
        
        return data;
    }
    
}


