package org.geotools.jdbc;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.geotools.data.Join.Type;
import org.geotools.data.Query;
import org.geotools.feature.visitor.AverageVisitor;
import org.geotools.feature.visitor.CountVisitor;
import org.geotools.feature.visitor.FeatureAttributeVisitor;
import org.geotools.feature.visitor.MaxVisitor;
import org.geotools.feature.visitor.MinVisitor;
import org.geotools.feature.visitor.StandardDeviationVisitor;
import org.geotools.feature.visitor.SumVisitor;
import org.geotools.feature.visitor.UniqueVisitor;
import org.geotools.filter.FilterCapabilities;
import org.geotools.filter.function.InFunction;
import org.geotools.filter.visitor.ExpressionTypeVisitor;
import org.geotools.filter.visitor.PostPreProcessFilterSplittingVisitor;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.geotools.util.Converters;
import org.geotools.util.factory.Hints;
import org.geotools.util.logging.Logging;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.opengis.feature.FeatureVisitor;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.filter.ExcludeFilter;
import org.opengis.filter.Filter;
import org.opengis.filter.Id;
import org.opengis.filter.IncludeFilter;
import org.opengis.filter.NativeFilter;
import org.opengis.filter.PropertyIsBetween;
import org.opengis.filter.PropertyIsLike;
import org.opengis.filter.PropertyIsNull;
import org.opengis.filter.expression.Add;
import org.opengis.filter.expression.Divide;
import org.opengis.filter.expression.Expression;
import org.opengis.filter.expression.Literal;
import org.opengis.filter.expression.Multiply;
import org.opengis.filter.expression.PropertyName;
import org.opengis.filter.expression.Subtract;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public abstract class SQLDialect {
    protected static final Logger LOGGER = Logging.getLogger(SQLDialect.class);
    public static FilterCapabilities BASE_DBMS_CAPABILITIES = new FilterCapabilities() {                 { addAll(FilterCapabilities.LOGICAL_OPENGIS);
                    addAll(FilterCapabilities.SIMPLE_COMPARISONS_OPENGIS);
                    addAll(InFunction.getInCapabilities());
                    addType(Add.class);
                    addType(Subtract.class);
                    addType(Multiply.class);
                    addType(Divide.class);
                    addType(PropertyName.class);
                    addType(Literal.class);
                    addType(PropertyIsNull.class);
                    addType(PropertyIsBetween.class);
                    addType(Id.class);
                    addType(IncludeFilter.class);
                    addType(ExcludeFilter.class);
                    addType(PropertyIsLike.class);
                    addType(NativeFilter.class);
                }
                
            };
    protected JDBCDataStore dataStore;
    protected boolean forceLongitudeFirst = false;
    protected SQLDialect(JDBCDataStore dataStore) {
        this.dataStore = dataStore;
    }
    
    public void initializeConnection(Connection cx) throws SQLException {}
    public boolean includeTable(String schemaName, String tableName, Connection cx) throws SQLException {
        return true;
    }
    
    public void registerSqlTypeNameToClassMappings(Map<String, Class<?>> mappings) {
    }
    
    public Class<?> getMapping(ResultSet columnMetaData, Connection cx) throws SQLException {
        return null;
    }
    
    public Filter getRestrictions(ResultSet columnMetaData, Connection cx) throws SQLException {
        return null;
    }
    
    public void handleUserDefinedType( ResultSet columnMetaData, ColumnMetadata metadata, Connection cx) throws SQLException {}
    public void registerSqlTypeToClassMappings(Map<Integer, Class<?>> mappings) {
        mappings.put(Integer.valueOf(Types.VARCHAR), String.class);
        mappings.put(Integer.valueOf(Types.CHAR), String.class);
        mappings.put(Integer.valueOf(Types.LONGVARCHAR), String.class);
        mappings.put(Integer.valueOf(Types.NVARCHAR), String.class);
        mappings.put(Integer.valueOf(Types.NCHAR), String.class);
        mappings.put(Integer.valueOf(Types.BIT), Boolean.class);
        mappings.put(Integer.valueOf(Types.BOOLEAN), Boolean.class);
        mappings.put(Integer.valueOf(Types.TINYINT), Short.class);
        mappings.put(Integer.valueOf(Types.SMALLINT), Short.class);
        mappings.put(Integer.valueOf(Types.INTEGER), Integer.class);
        mappings.put(Integer.valueOf(Types.BIGINT), Long.class);
        mappings.put(Integer.valueOf(Types.REAL), Float.class);
        mappings.put(Integer.valueOf(Types.FLOAT), Double.class);
        mappings.put(Integer.valueOf(Types.DOUBLE), Double.class);
        mappings.put(Integer.valueOf(Types.DECIMAL), BigDecimal.class);
        mappings.put(Integer.valueOf(Types.NUMERIC), BigDecimal.class);
        mappings.put(Integer.valueOf(Types.DATE), Date.class);
        mappings.put(Integer.valueOf(Types.TIME), Time.class);
        mappings.put(Integer.valueOf(Types.TIMESTAMP), Timestamp.class);
        mappings.put(Integer.valueOf(Types.BLOB), byte[].class);
        mappings.put(Integer.valueOf(Types.BINARY), byte[].class);
        mappings.put(Integer.valueOf(Types.CLOB), String.class);
        mappings.put(Integer.valueOf(Types.VARBINARY), byte[].class);
    }
    
    public void registerClassToSqlMappings(Map<Class<?>, Integer> mappings) {
        mappings.put(String.class, Integer.valueOf(Types.VARCHAR));
        mappings.put(Boolean.class, Integer.valueOf(Types.BOOLEAN));
        mappings.put(boolean.class, Integer.valueOf(Types.BOOLEAN));
        mappings.put(Short.class, Integer.valueOf(Types.SMALLINT));
        mappings.put(short.class, Integer.valueOf(Types.SMALLINT));
        mappings.put(Integer.class, Integer.valueOf(Types.INTEGER));
        mappings.put(int.class, Integer.valueOf(Types.INTEGER));
        mappings.put(Long.class, Integer.valueOf(Types.BIGINT));
        mappings.put(long.class, Integer.valueOf(Types.BIGINT));
        mappings.put(Float.class, Integer.valueOf(Types.REAL));
        mappings.put(float.class, Integer.valueOf(Types.REAL));
        mappings.put(Double.class, Integer.valueOf(Types.DOUBLE));
        mappings.put(double.class, Integer.valueOf(Types.DOUBLE));
        mappings.put(BigDecimal.class, Integer.valueOf(Types.NUMERIC));
        mappings.put(Date.class, Integer.valueOf(Types.DATE));
        mappings.put(Time.class, Integer.valueOf(Types.TIME));
        mappings.put(java.util.Date.class, Integer.valueOf(Types.TIMESTAMP));
        mappings.put(Timestamp.class, Integer.valueOf(Types.TIMESTAMP));
        mappings.put(byte[].class, Integer.valueOf(Types.BLOB));
    }
    
    public void registerSqlTypeToSqlTypeNameOverrides(Map<Integer, String> overrides) {}
    public void registerAggregateFunctions( Map<Class<? extends FeatureVisitor>, String> aggregates) {
        aggregates.put(UniqueVisitor.class, "distinct");
        aggregates.put(CountVisitor.class, "count");
        aggregates.put(MinVisitor.class, "min");
        aggregates.put(MaxVisitor.class, "max");
        aggregates.put(SumVisitor.class, "sum");
        aggregates.put(AverageVisitor.class, "avg");
        aggregates.put(StandardDeviationVisitor.class, "stddev_pop");
    }
    
    public String getNameEscape() {
        return "\"";
    }
    
    protected final String ne() {
        return getNameEscape();
    }
    
    public String escapeName(String name) {
        String nameEscape = getNameEscape();
        if (nameEscape.isEmpty()) return name;
        StringBuilder sb = new StringBuilder();
        sb.append(nameEscape);
        int offset = 0;
        int escapeOffset;
        while ((escapeOffset = name.indexOf(nameEscape, offset)) != -1) {
            sb.append(name.substring(offset, escapeOffset));
            sb.append(nameEscape);
            sb.append(nameEscape);
            offset = escapeOffset + nameEscape.length();
        }
        
        sb.append(name.substring(offset));
        sb.append(nameEscape);
        return sb.toString();
    }
    
    public void encodeColumnName(String prefix, String raw, StringBuffer sql) {
        if (prefix != null) {
            sql.append(escapeName(prefix)).append(".");
        }
        
        sql.append(escapeName(raw));
    }
    
    public void encodeColumnType(String sqlTypeName, StringBuffer sql) {
        sql.append(sqlTypeName);
    }
    
    public void encodeColumnAlias(String raw, StringBuffer sql) {
        sql.append(" as ");
        encodeColumnName(null, raw, sql);
    }
    
    public void encodeTableAlias(String raw, StringBuffer sql) {
        sql.append(" as ");
        encodeColumnName(null, raw, sql);
    }
    
    public void encodeTableName(String raw, StringBuffer sql) {
        sql.append(escapeName(raw));
    }
    
    public void encodeSchemaName(String raw, StringBuffer sql) {
        sql.append(escapeName(raw));
    }
    
    public String getGeometryTypeName(Integer type) {
        return null;
    }
    
    public Integer getGeometrySRID( String schemaName, String tableName, String columnName, Connection cx) throws SQLException {
        return null;
    }
    
    public int getGeometryDimension( String schemaName, String tableName, String columnName, Connection cx) throws SQLException {
        return 2;
    }
    
    public CoordinateReferenceSystem createCRS(int srid, Connection cx) throws SQLException {
        try {
            return CRS.decode("EPSG:" + srid, forceLongitudeFirst);
        }
         catch (Exception e) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log( Level.FINE, "Could not decode EPSG:" + srid + " using the EPSG plugins.");
            }
            
            return null;
        }
        
    }
    
    public List<ReferencedEnvelope> getOptimizedBounds( String schema, SimpleFeatureType featureType, Connection cx) throws SQLException, IOException {
        return null;
    }
    
    public abstract void encodeGeometryEnvelope( String tableName, String geometryColumn, StringBuffer sql);
    public abstract Envelope decodeGeometryEnvelope(ResultSet rs, int column, Connection cx) throws SQLException, IOException;
    public void encodeGeometryColumn( GeometryDescriptor gatt, String prefix, int srid, Hints hints, StringBuffer sql) {
        encodeColumnName(prefix, gatt.getLocalName(), sql);
    }
    
    public void encodeGeometryColumnGeneralized( GeometryDescriptor gatt, String prefix, int srid, StringBuffer sql, Double distance) {
        throw new UnsupportedOperationException("Geometry generalization not supported");
    }
    
    public void encodeGeometryColumnSimplified( GeometryDescriptor gatt, String prefix, int srid, StringBuffer sql, Double distance) {
        throw new UnsupportedOperationException("Geometry simplification not supported");
    }
    
    public abstract Geometry decodeGeometryValue( GeometryDescriptor descriptor, ResultSet rs, String column, GeometryFactory factory, Connection cx, Hints hints) throws IOException, SQLException;
    public Geometry decodeGeometryValue( GeometryDescriptor descriptor, ResultSet rs, int column, GeometryFactory factory, Connection cx, Hints hints) throws IOException, SQLException {
        String columnName = rs.getMetaData().getColumnName(column);
        return decodeGeometryValue(descriptor, rs, columnName, factory, cx, hints);
    }
    
    public void encodePrimaryKey(String column, StringBuffer sql) {
        encodeColumnName(null, column, sql);
        sql.append(" INTEGER PRIMARY KEY");
    }
    
    public void encodeJoin(Type joinType, StringBuffer sql) {
        switch (joinType) {
            case INNER:
                sql.append("INNER");
                break;
            case OUTER:
                sql.append("LEFT OUTER");
                break;
            default: throw new IllegalArgumentException("Join type " + joinType + " not supported");
        }
        
        sql.append(" JOIN");
    }
    
    public void encodeCreateTable(StringBuffer sql) {
        sql.append("CREATE TABLE ");
    }
    
    public void encodePostColumnCreateTable(AttributeDescriptor att, StringBuffer sql) {}
    public void encodePostCreateTable(String tableName, StringBuffer sql) {}
    public void encodePostSelect(SimpleFeatureType featureType, StringBuffer sql) {}
    public void postCreateTable(String schemaName, SimpleFeatureType featureType, Connection cx) throws SQLException, IOException {}
    public void postCreateAttribute( AttributeDescriptor att, String tableName, String schemaName, Connection cx) throws SQLException {}
    public void postCreateFeatureType( SimpleFeatureType featureType, DatabaseMetaData metadata, String schemaName, Connection cx) throws SQLException {}
    public void preDropTable(String schemaName, SimpleFeatureType featureType, Connection cx) throws SQLException {}
    public void postDropTable(String schemaName, SimpleFeatureType featureType, Connection cx) throws SQLException {}
    public boolean lookupGeneratedValuesPostInsert() {
        return false;
    }
    
    public Object getNextAutoGeneratedValue( String schemaName, String tableName, String columnName, Connection cx) throws SQLException {
        return null;
    }
    
    public Object getLastAutoGeneratedValue( String schemaName, String tableName, String columnName, Connection cx, Statement st) throws SQLException {
        return getLastAutoGeneratedValue(schemaName, tableName, columnName, cx);
    }
    
    public Object getLastAutoGeneratedValue( String schemaName, String tableName, String columnName, Connection cx) throws SQLException {
        return null;
    }
    
    public String getSequenceForColumn( String schemaName, String tableName, String columnName, Connection cx) throws SQLException {
        return null;
    }
    
    public Object getNextSequenceValue(String schemaName, String sequenceName, Connection cx) throws SQLException {
        return null;
    }
    
    public String encodeNextSequenceValue(String schemaName, String sequenceName) {
        return null;
    }
    
    public boolean isLimitOffsetSupported() {
        return false;
    }
    
    public boolean isAggregatedSortSupported(String function) {
        return false;
    }
    
    public boolean isGroupBySupported() {
        return true;
    }
    
    public void applyLimitOffset(StringBuffer sql, int limit, int offset) {
        throw new UnsupportedOperationException( "Ovveride this method when isLimitOffsetSupported returns true");
    }
    
    protected void addSupportedHints(Set<Hints.Key> hints) {}
    public int getDefaultVarcharSize() {
        return 255;
    }
    
    public boolean isAutoCommitQuery() {
        return false;
    }
    
    protected boolean supportsSchemaForIndex() {
        return false;
    }
    
    public void createIndex( Connection cx, SimpleFeatureType schema, String databaseSchema, Index index) throws SQLException {
        StringBuffer sql = new StringBuffer();
        sql.append("CREATE ");
        if (index.isUnique()) {
            sql.append("UNIQUE ");
        }
        
        sql.append("INDEX ");
        if (supportsSchemaForIndex() && databaseSchema != null) {
            encodeSchemaName(databaseSchema, sql);
            sql.append(".");
        }
        
        sql.append(escapeName(index.getIndexName()));
        sql.append(" ON ");
        if (databaseSchema != null) {
            encodeSchemaName(databaseSchema, sql);
            sql.append(".");
        }
        
        sql.append(escapeName(index.getTypeName())).append("(");
        for (String attribute : index.getAttributes()) {
            sql.append(escapeName(attribute)).append(", ");
        }
        
        sql.setLength(sql.length() - 2);
        sql.append(")");
        Statement st = null;
        try {
            st = cx.createStatement();
            st.execute(sql.toString());
            if (!cx.getAutoCommit()) {
                cx.commit();
            }
            
        }
         finally {
            dataStore.closeSafe(st);
            dataStore.closeSafe(cx);
        }
        
    }
    
    public void dropIndex( Connection cx, SimpleFeatureType schema, String databaseSchema, String indexName) throws SQLException {
        StringBuffer sql = new StringBuffer();
        sql.append("DROP INDEX ");
        if (supportsSchemaForIndex() && databaseSchema != null) {
            encodeSchemaName(databaseSchema, sql);
            sql.append(".");
        }
        
        sql.append(escapeName(indexName));
        Statement st = null;
        try {
            st = cx.createStatement();
            st.execute(sql.toString());
            if (!cx.getAutoCommit()) {
                cx.commit();
            }
            
        }
         finally {
            dataStore.closeSafe(st);
            dataStore.closeSafe(cx);
        }
        
    }
    
    public List<Index> getIndexes(Connection cx, String databaseSchema, String typeName) throws SQLException {
        DatabaseMetaData md = cx.getMetaData();
        ResultSet indexInfo = null;
        try {
            indexInfo = md.getIndexInfo(cx.getCatalog(), databaseSchema, typeName, false, true);
            Map<String, Index> indexes = new LinkedHashMap<>();
            while (indexInfo.next()) {
                short type = indexInfo.getShort("TYPE");
                if (type != DatabaseMetaData.tableIndexStatistic) {
                    String indexName = indexInfo.getString("INDEX_NAME");
                    String columnName = indexInfo.getString("COLUMN_NAME");
                    Index index = indexes.get(indexName);
                    if (index != null) {
                        index.attributes.add(columnName);
                    }
                     else {
                        boolean unique = !indexInfo.getBoolean("NON_UNIQUE");
                        index = new Index(typeName, indexName, unique, columnName);
                        indexes.put(indexName, index);
                    }
                    
                }
                
            }
            
            return new ArrayList<>(indexes.values());
        }
         finally {
            dataStore.closeSafe(indexInfo);
        }
        
    }
    
    public void handleSelectHints(StringBuffer sql, SimpleFeatureType featureType, Query query) {
    }
    
    public boolean applyHintsOnVirtualTables() {
        return false;
    }
    
    public String[] getDesiredTablesType() {
        return new String[] {"TABLE", "VIEW", "MATERIALIZED VIEW", "SYNONYM"};
    }
    
    public Filter[] splitFilter(Filter filter, SimpleFeatureType schema) {
        PostPreProcessFilterSplittingVisitor splitter = new PostPreProcessFilterSplittingVisitor( dataStore.getFilterCapabilities(), schema, null);
        filter.accept(splitter, null);
        Filter[] split = new Filter[2];
        split[0] = splitter.getFilterPre();
        split[1] = splitter.getFilterPost();
        return split;
    }
    
    protected PrimaryKey getPrimaryKey(String typeName) throws IOException {
        SimpleFeatureType featureType = dataStore.getSchema(typeName);
        return dataStore.getPrimaryKey(featureType);
    }
    
    public String getPkColumnValue(ResultSet rs, PrimaryKeyColumn pkey, int columnIdx) throws SQLException {
        return rs.getString(columnIdx);
    }
    
    public boolean canSimplifyPoints() {
        return false;
    }
    
    protected Optional<List<Class>> getResultTypes( FeatureVisitor visitor, SimpleFeatureType featureType) {
        if (!(visitor instanceof FeatureAttributeVisitor)) {
            return Optional.empty();
        }
        
        FeatureAttributeVisitor fav = (FeatureAttributeVisitor) visitor;
        List<Expression> expressions = fav.getExpressions();
        if (expressions == null || expressions.isEmpty()) {
            return Optional.empty();
        }
        
        List<Class> inputTypes = new ArrayList<>();
        for (Expression ex : expressions) {
            ExpressionTypeVisitor etv = new ExpressionTypeVisitor(featureType);
            Class expressionType = (Class) ex.accept(etv, null);
            if (expressionType == null) {
                return Optional.empty();
            }
            
            inputTypes.add(expressionType);
        }
        
        return fav.getResultType(inputTypes);
    }
    
    public Function<Object, Object> getAggregateConverter( FeatureVisitor visitor, SimpleFeatureType featureType) {
        return Function.identity();
    }
    
    public Integer getSQLType(AttributeDescriptor ad) {
        return null;
    }
    
    public boolean isArray(AttributeDescriptor att) {
        Integer nativeType = (Integer) att.getUserData().get(JDBCDataStore.JDBC_NATIVE_TYPE);
        return Objects.equals(Types.ARRAY, nativeType);
    }
    
    public Object convertValue(Object value, AttributeDescriptor ad) {
        Class<?> binding = ad.getType().getBinding();
        return Converters.convert(value, binding);
    }
    
    public boolean canGroupOnGeometry() {
        return false;
    }
    
    public Class<?> getMapping(String sqlTypeName) {
        return null;
    }
    
}


