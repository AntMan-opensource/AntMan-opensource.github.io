package org.eclipse.californium.scandium.dtls;
import java.security.GeneralSecurityException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import org.eclipse.californium.elements.util.DatagramReader;
import org.eclipse.californium.elements.util.DatagramWriter;
import org.eclipse.californium.elements.util.NoPublicAPI;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.scandium.dtls.AlertMessage.AlertDescription;
import org.eclipse.californium.scandium.dtls.AlertMessage.AlertLevel;
import org.eclipse.californium.scandium.dtls.cipher.RandomManager;
import org.eclipse.californium.scandium.dtls.cipher.ThreadLocalSignature;
import org.eclipse.californium.scandium.dtls.cipher.XECDHECryptography;
import org.eclipse.californium.scandium.dtls.cipher.XECDHECryptography.SupportedGroup;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
	private static final Logger LOGGER = LoggerFactory.getLogger(EcdhEcdsaServerKeyExchange.class);
	 private static final int HASH_ALGORITHM_BITS = 8;
	private static final int SIGNATURE_ALGORITHM_BITS = 8;
	private static final int SIGNATURE_LENGTH_BITS = 16;
	 private final byte[] signatureEncoded;
	 private final SignatureAndHashAlgorithm signatureAndHashAlgorithm;
	 public EcdhEcdsaServerKeyExchange(SignatureAndHashAlgorithm signatureAndHashAlgorithm, XECDHECryptography ecdhe, PrivateKey serverPrivateKey, Random clientRandom, Random serverRandom) throws HandshakeException {
		super(ecdhe.getSupportedGroup(), ecdhe.getEncodedPoint());
		if (signatureAndHashAlgorithm == null) {
			throw new NullPointerException("signature and hash algorithm cannot be null");
		}
		
		this.signatureAndHashAlgorithm = signatureAndHashAlgorithm;
		 ThreadLocalSignature localSignature = signatureAndHashAlgorithm.getThreadLocalSignature();
		try {
			Signature signature = localSignature.currentWithCause();
			signature.initSign(serverPrivateKey, RandomManager.currentSecureRandom());
			updateSignature(signature, clientRandom, serverRandom);
			signatureEncoded = signature.sign();
		}
		 catch (GeneralSecurityException e) {
			throw new HandshakeException( String.format("Server failed to sign key exchange: %s", e.getMessage()), new AlertMessage(AlertLevel.FATAL, AlertDescription.ILLEGAL_PARAMETER));
		}
		
	}
	
	 private EcdhEcdsaServerKeyExchange(SignatureAndHashAlgorithm signatureAndHashAlgorithm, SupportedGroup supportedGroup, byte[] encodedPoint, byte[] signatureEncoded) {
		super(supportedGroup, encodedPoint);
		if (signatureAndHashAlgorithm == null) {
			throw new NullPointerException("signature and hash algorithm cannot be null");
		}
		
		this.signatureAndHashAlgorithm = signatureAndHashAlgorithm;
		this.signatureEncoded = signatureEncoded;
	}
	
	public int getMessageLength() {
		 int signatureLength = (signatureEncoded == null) ? 0 : 2 + 2 + signatureEncoded.length;
		return getNamedCurveLength() + signatureLength;
	}
	
	public byte[] fragmentToByteArray() {
		DatagramWriter writer = new DatagramWriter();
		writeNamedCurve(writer);
		 if (signatureEncoded != null) {
			 writer.write(signatureAndHashAlgorithm.getHash().getCode(), HASH_ALGORITHM_BITS);
			writer.write(signatureAndHashAlgorithm.getSignature().getCode(), SIGNATURE_ALGORITHM_BITS);
			writer.writeVarBytes(signatureEncoded, SIGNATURE_LENGTH_BITS);
		}
		
		return writer.toByteArray();
	}
	
	public static HandshakeMessage fromReader(DatagramReader reader) throws HandshakeException {
		EcdhData ecdhData = readNamedCurve(reader);
		 SignatureAndHashAlgorithm signAndHash = new SignatureAndHashAlgorithm(SignatureAndHashAlgorithm.HashAlgorithm.SHA256, SignatureAndHashAlgorithm.SignatureAlgorithm.ECDSA);
		byte[] signatureEncoded = null;
		if (reader.bytesAvailable()) {
			int hashAlgorithm = reader.read(HASH_ALGORITHM_BITS);
			int signatureAlgorithm = reader.read(SIGNATURE_ALGORITHM_BITS);
			signAndHash = new SignatureAndHashAlgorithm(hashAlgorithm, signatureAlgorithm);
			signatureEncoded = reader.readVarBytes(SIGNATURE_LENGTH_BITS);
		}
		
		return new EcdhEcdsaServerKeyExchange(signAndHash, ecdhData.supportedGroup, ecdhData.encodedPoint, signatureEncoded);
	}
	
	 public void verifySignature(PublicKey serverPublicKey, Random clientRandom, Random serverRandom) throws HandshakeException {
		if (signatureEncoded == null) {
			 return;
		}
		
		boolean verified = false;
		try {
			ThreadLocalSignature localSignature = signatureAndHashAlgorithm.getThreadLocalSignature();
			Signature signature = localSignature.currentWithCause();
			signature.initVerify(serverPublicKey);
			updateSignature(signature, clientRandom, serverRandom);
			verified = signature.verify(signatureEncoded);
		}
		 catch (GeneralSecurityException e) {
			LOGGER.error("Could not verify the server's signature.",e);
		}
		
		if (!verified) {
			String message = "The server's ECDHE key exchange message's signature could not be verified.";
			AlertMessage alert = new AlertMessage(AlertLevel.FATAL, AlertDescription.DECRYPT_ERROR);
			throw new HandshakeException(message, alert);
		}
		
	}
	
	 private void updateSignature(Signature signature, Random clientRandom, Random serverRandom) throws SignatureException {
		signature.update(clientRandom.getBytes());
		signature.update(serverRandom.getBytes());
		updateSignatureForNamedCurve(signature);
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(super.toString());
		if (signatureEncoded != null){
		sb.append("\t\tSignature: ");
}
		sb.append(signatureAndHashAlgorithm.toString()).append("-").append(StringUtil.byteArray2HexString(signatureEncoded, StringUtil.NO_SEPARATOR, 10));
		sb.append(StringUtil.lineSeparator());
		return sb.toString();
	}
	
}


