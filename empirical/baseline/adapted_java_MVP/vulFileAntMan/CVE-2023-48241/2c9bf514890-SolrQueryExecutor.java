package org.xwiki.query.solr.internal;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map.Entry;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;
import org.apache.commons.lang3.StringUtils;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;
import org.slf4j.Logger;
import org.xwiki.component.annotation.Component;
import org.xwiki.job.event.status.JobProgressManager;
import org.xwiki.model.reference.DocumentReference;
import org.xwiki.model.reference.DocumentReferenceResolver;
import org.xwiki.query.Query;
import org.xwiki.query.QueryException;
import org.xwiki.query.QueryExecutor;
import org.xwiki.query.SecureQuery;
import org.xwiki.search.solr.internal.api.SolrInstance;
import org.xwiki.security.authorization.AuthorizationManager;
import org.xwiki.security.authorization.Right;
import com.xpn.xwiki.XWikiContext;
public class SolrQueryExecutor implements QueryExecutor {
    public static final String SOLR = "solr";
    private static final String PARAM_SUPPORTED_LOCALES = "xwiki.supportedLocales";
    protected Logger logger;
    protected AuthorizationManager authorization;
    protected SolrInstance solrInstance;
    private Provider<XWikiContext> xcontextProvider;
    private DocumentReferenceResolver<SolrDocument> solrDocumentReferenceResolver;
    private JobProgressManager progress;
    public <T> List<T> execute(Query query) throws QueryException {
        this.progress.startStep(query, "query.solr.progress.execute", "Execute Solr query [{}]", query);
        this.progress.pushLevelProgress(3, query);
        try {
            this.progress.startStep(query, "query.solr.progress.execute.prepare", "Prepare");
            SolrQuery solrQuery = createSolrQuery(query);
            this.progress.startStep(query, "query.solr.progress.execute.execute", "Execute");
            QueryResponse response = this.solrInstance.query(solrQuery);
            this.progress.startStep(query, "query.solr.progress.execute.filter", "Filter");
            List<DocumentReference> usersToCheck = new ArrayList<>(2);
            if (query instanceof SecureQuery) {
                if (((SecureQuery) query).isCurrentUserChecked()) {
                    usersToCheck.add(xcontextProvider.get().getUserReference());
                }
                
                if (((SecureQuery) query).isCurrentAuthorChecked()) {
                    usersToCheck.add(xcontextProvider.get().getAuthorReference());
                }
                
            }
             else {
                usersToCheck.add(xcontextProvider.get().getUserReference());
                usersToCheck.add(xcontextProvider.get().getAuthorReference());
            }
            
            if (!usersToCheck.isEmpty()) {
                filterResponse(response, usersToCheck);
            }
            
            return (List<T>) Arrays.asList(response);
        }
         catch (Exception e) {
            throw new QueryException("Exception while executing query", query, e);
        }
         finally {
            this.progress.popLevelProgress(query);
            this.progress.endStep(query);
        }
        
    }
    
    private SolrQuery createSolrQuery(Query query) {
        SolrQuery solrQuery = new SolrQuery(query.getStatement());
        if (query.getOffset() > 0) {
            solrQuery.setStart(query.getOffset());
        }
        
        if (query.getLimit() > 0) {
            solrQuery.setRows(query.getLimit());
        }
        
        for (Entry<String, Object> entry : query.getNamedParameters().entrySet()) {
            Object value = entry.getValue();
            if (value instanceof Iterable) {
                solrQuery.set(entry.getKey(), toStringArray((Iterable) value));
            }
             else if (value != null && value.getClass().isArray()) {
                solrQuery.set(entry.getKey(), toStringArray(value));
            }
             else {
                solrQuery.set(entry.getKey(), String.valueOf(value));
            }
            
        }
        
        if (!solrQuery.getParameterNames().contains(PARAM_SUPPORTED_LOCALES)) {
            XWikiContext xcontext = this.xcontextProvider.get();
            solrQuery.set(PARAM_SUPPORTED_LOCALES, StringUtils.join(xcontext.getWiki().getAvailableLocales(xcontext), ","));
        }
        
        return solrQuery;
    }
    
    private String[] toStringArray(Object array) {
        int length = Array.getLength(array);
        String[] args = new String[length];
        for (int i = 0; i < length; i++) {
            args[i] = String.valueOf(Array.get(array, i));
        }
        
        return args;
    }
    
    private String[] toStringArray(Iterable iterable) {
        List<String> args = new ArrayList<String>();
        for (Object obj : iterable) {
            args.add(String.valueOf(obj));
        }
        
        return args.toArray(new String[args.size()]);
    }
    
    protected void filterResponse(QueryResponse response, List<DocumentReference> usersToCheck) {
        SolrDocumentList results = response.getResults();
        long numFound = results.getNumFound();
        for (SolrDocument result : new ArrayList<SolrDocument>(results)) {             try { DocumentReference resultDocumentReference = this.solrDocumentReferenceResolver.resolve(result);
                if (!isAllowed(resultDocumentReference, usersToCheck)) {
                    results.remove(result);
                    numFound--;
                }
                
            }
             catch (Exception e) {
                this.logger.warn("Skipping bad result: {}", result, e);
            }
            
        }
        
        if (numFound < 0) {
            numFound = 0;
        }
        
        results.setNumFound(numFound);
    }
    
    protected boolean isAllowed(DocumentReference resultDocumentReference, List<DocumentReference> usersToCheck) {
        for (DocumentReference user : usersToCheck) {
            if (!this.authorization.hasAccess(Right.VIEW, user, resultDocumentReference)) {
                return false;
            }
            
        }
        
        return true;
    }
    
}


