package org.apache.james.imapserver.netty;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import org.apache.james.imap.api.ImapMessage;
import org.apache.james.imap.api.ImapSessionState;
import org.apache.james.imap.api.process.ImapSession;
import org.apache.james.imap.decode.ImapDecoder;
import org.apache.james.imap.decode.ImapRequestLineReader;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFutureListener;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelStateEvent;
import org.jboss.netty.handler.codec.frame.FrameDecoder;
import com.google.common.annotations.VisibleForTesting;
public class ImapRequestFrameDecoder extends FrameDecoder implements NettyConstants {
    private final ImapDecoder decoder;
    private final int inMemorySizeLimit;
    private final int literalSizeLimit;
    @VisibleForTesting
    static final String NEEDED_DATA = "NEEDED_DATA";
    private static final String STORED_DATA = "STORED_DATA";
    private static final String WRITTEN_DATA = "WRITTEN_DATA";
    private static final String OUTPUT_STREAM = "OUTPUT_STREAM";
    public ImapRequestFrameDecoder(ImapDecoder decoder, int inMemorySizeLimit, int literalSizeLimit) {
        this.decoder = decoder;
        this.inMemorySizeLimit = inMemorySizeLimit;
        this.literalSizeLimit = literalSizeLimit;
    }
    
    public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
        ctx.setAttachment(new HashMap<String, Object>());
        super.channelOpen(ctx, e);
    }
    
    protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
        buffer.markReaderIndex();
        boolean retry = false;
        ImapRequestLineReader reader;
        Map<String, Object> attachment = (Map<String, Object>) ctx.getAttachment();
        int size = -1;
        if (attachment.containsKey(NEEDED_DATA)) {
            retry = true;
            size = (Integer) attachment.get(NEEDED_DATA);
            if (size != NettyImapRequestLineReader.NotEnoughDataException.UNKNOWN_SIZE && size > buffer.readableBytes()) {
                if (inMemorySizeLimit > 0 && inMemorySizeLimit < size) {
                    final File f;
                    int written;
                    OutputStream out;
                    if (attachment.containsKey(STORED_DATA)) {
                        f = (File) attachment.get(STORED_DATA);
                        written = (Integer) attachment.get(WRITTEN_DATA);
                        out = (OutputStream) attachment.get(OUTPUT_STREAM);
                    }
                     else {
                        f = File.createTempFile("imap-literal", ".tmp");
                        attachment.put(STORED_DATA, f);
                        written = 0;
                        attachment.put(WRITTEN_DATA, written);
                        out = new FileOutputStream(f, true);
                        attachment.put(OUTPUT_STREAM, out);
                    }
                    
                    try {
                        int amount = Math.min(buffer.readableBytes(), size - written);
                        buffer.readBytes(out, amount);
                        written += amount;
                    }
                     catch (Exception e) {
                        try {
                            out.close();
                        }
                         catch (IOException ignored) {
                        }
                        
                        throw e;
                    }
                    
                    if (written == size) {
                        try {
                            out.close();
                        }
                         catch (IOException ignored) {
                        }
                        
                        reader = new NettyStreamImapRequestLineReader(channel, f, retry);
                    }
                     else {
                        attachment.put(WRITTEN_DATA, written);
                        return null;
                    }
                    
                }
                 else {
                    buffer.resetReaderIndex();
                    return null;
                }
                
            }
             else {
                reader = new NettyImapRequestLineReader(channel, buffer, retry, literalSizeLimit);
            }
            
        }
         else {
            reader = new NettyImapRequestLineReader(channel, buffer, retry, literalSizeLimit);
        }
        
        ImapSession session = (ImapSession) attributes.get(channel);
        if (session != null && session.getState() != ImapSessionState.LOGOUT) {
            try {
                ImapMessage message = decoder.decode(reader, session);
                if (size == -1) {
                    reader.consumeLine();
                }
                
                ((SwitchableLineBasedFrameDecoder) channel.getPipeline().get(FRAMER)).enableFraming();
                attachment.clear();
                return message;
            }
             catch (NettyImapRequestLineReader.NotEnoughDataException e) {
                int neededData = e.getNeededSize();
                attachment.put(NEEDED_DATA, neededData);
                final ChannelPipeline pipeline = channel.getPipeline();
                final ChannelHandlerContext framerContext = pipeline.getContext(FRAMER);
                final SwitchableLineBasedFrameDecoder framer = (SwitchableLineBasedFrameDecoder) pipeline.get(FRAMER);
                framer.disableFraming(framerContext);
                buffer.resetReaderIndex();
                return null;
            }
            
        }
         else {
            if (channel.isConnected()) {
                channel.write(ChannelBuffers.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
            }
            
            return null;
        }
        
    }
    
    protected synchronized ChannelBuffer newCumulationBuffer(ChannelHandlerContext ctx, int minimumCapacity) {
        Map<String, Object> attachment = (Map<String, Object>) ctx.getAttachment();
        Object sizeAsObject = attachment.get(NEEDED_DATA);
        if (sizeAsObject != null) {
            @SuppressWarnings("unchecked")
            int size = (Integer) sizeAsObject;
            if (size > 0) {
                int sanitizedInMemorySizeLimit = Math.max(0, inMemorySizeLimit);
                int sanitizedSize = Math.min(sanitizedInMemorySizeLimit, size);
                return ChannelBuffers.dynamicBuffer(sanitizedSize, ctx.getChannel().getConfig().getBufferFactory());
            }
            
        }
        
        return super.newCumulationBuffer(ctx, minimumCapacity);
    }
    
}


