package com.cloudbees.hudson.plugins.folder.computed;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import com.jcraft.jzlib.GZIPInputStream;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import hudson.AbortException;
import hudson.BulkChange;
import hudson.Functions;
import hudson.Util;
import hudson.XmlFile;
import hudson.console.AnnotatedLargeText;
import hudson.console.PlainTextConsoleOutputStream;
import hudson.model.Actionable;
import hudson.model.BallColor;
import hudson.model.Cause;
import hudson.model.CauseAction;
import hudson.model.Executor;
import hudson.model.Items;
import hudson.model.Queue;
import hudson.model.Result;
import hudson.model.Saveable;
import hudson.model.StreamBuildListener;
import hudson.model.TaskListener;
import hudson.model.TopLevelItem;
import hudson.model.listeners.SaveableListener;
import hudson.model.queue.QueueTaskDispatcher;
import hudson.util.AlternativeUiTextProvider;
import hudson.util.AlternativeUiTextProvider.Message;
import hudson.util.HttpResponses;
import hudson.util.StreamTaskListener;
import hudson.util.io.RewindableRotatingFileOutputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import javax.servlet.ServletException;
import net.jcip.annotations.GuardedBy;
import java.nio.charset.StandardCharsets;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.jelly.XMLOutput;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.framework.io.ByteBuffer;
import org.kohsuke.stapler.interceptor.RequirePOST;
public class FolderComputation<I extends TopLevelItem> extends Actionable implements Queue.Executable, Saveable {
    private static final Logger LOGGER = Logger.getLogger(FolderComputation.class.getName());
    private static @CheckForNull Integer BACKUP_LOG_COUNT = Integer.getInteger(FolderComputation.class.getName() + ".BACKUP_LOG_COUNT");
    private static int EVENT_LOG_MAX_SIZE = Math.max(1,Integer.getInteger(FolderComputation.class.getName() + ".EVENT_LOG_MAX_SIZE", 150));
    private transient final ComputedFolder<I> folder;
    private transient final Result previousResult;
    private transient EventOutputStreams eventStreams;
    private volatile Result result;
    private List<Long> durations;
    private long timestamp;
    private long duration;
    protected FolderComputation(@NonNull ComputedFolder<I> folder, @CheckForNull FolderComputation<I> previous) {
        this.folder = folder;
        this.previousResult = previous == null ? null : previous.getResult();
    }
    
    public void run() {
        StreamBuildListener listener;
        try {
            File logFile = getLogFile();
            FileUtils.forceMkdir(logFile.getParentFile());
            OutputStream os;
            if (BACKUP_LOG_COUNT != null) {
                os = new RewindableRotatingFileOutputStream(logFile, BACKUP_LOG_COUNT);
                ((RewindableRotatingFileOutputStream) os).rewind();
            }
             else {
                os = new FileOutputStream(logFile);
            }
            
            listener = new StreamBuildListener(os, StandardCharsets.UTF_8);
        }
         catch (IOException x) {
            LOGGER.log(Level.WARNING, null, x);
            result = Result.FAILURE;
            return;
        }
        
        timestamp = System.currentTimeMillis();
        listener.started(getCauses());
        Result _result = Result.NOT_BUILT; 
        try {
            folder.updateChildren(listener);
            _result = Result.SUCCESS;
        }
         catch (InterruptedException x) {
            LOGGER.log(Level.FINE, "recomputation of " + folder.getFullName() + " was aborted", x);
            listener.getLogger().println("Aborted");
            _result = Result.ABORTED;
        }
         catch (Exception x) {
            LOGGER.log(Level.FINE, "recomputation of " + folder.getFullName() + " failed", x);
            if (x instanceof AbortException) {
                listener.fatalError(x.getMessage());
            }
             else {
                Functions.printStackTrace(x, listener.fatalError("Failed to recompute children of " + folder.getFullDisplayName()));
            }
            
            _result = Result.FAILURE;
        }
         finally {
            duration = System.currentTimeMillis() - timestamp;
            if (durations == null) {
                durations = new ArrayList<Long>();
            }
            
            while (durations.size() > 32) {
                durations.remove(0);
            }
            
            durations.add(duration);
            listener.finished(_result);
            listener.closeQuietly();
            result = _result;
            try {
                save();
            }
             catch (IOException x) {
                LOGGER.log(Level.WARNING, null, x);
            }
            
        }
        
    }
    
    public void save() throws IOException {
        if (BulkChange.contains(this)) {
            return;
        }
        
        XmlFile dataFile = getDataFile();
        dataFile.write(this);
        SaveableListener.fireOnChange(this, dataFile);
    }
    
    public File getLogFile() {
        return new File(folder.getComputationDir(), "computation.log");
    }
    
    public File getEventsFile() {
        return new File(folder.getComputationDir(), "events.log");
    }
    
    public synchronized StreamTaskListener createEventsListener() {
        File eventsFile = getEventsFile();
        if (!eventsFile.getParentFile().isDirectory() && !eventsFile.getParentFile().mkdirs()) {
            LOGGER.log(Level.WARNING, "Could not create directory {0} for {1}", new Object[]{eventsFile.getParentFile(), folder.getFullName()});
        }
        
        if (eventStreams == null) {
            eventStreams = new EventOutputStreams(new EventOutputStreams.OutputFile() {
                public File get() {
                    return getEventsFile();
                }
                
                public boolean canWriteNow() {
                    GregorianCalendar timestamp = new GregorianCalendar();
                    timestamp.setTimeInMillis(System.currentTimeMillis() - 10000L);
                    Queue.Item probe = new Queue.WaitingItem(timestamp, folder, Collections.emptyList());
                    for (QueueTaskDispatcher d: QueueTaskDispatcher.all()) {
                        if (d.canRun(probe) != null) {
                            return false;
                        }
                        
                    }
                    
                    return true;
                }
                
            }, 250, TimeUnit.MILLISECONDS, 1024, true, EVENT_LOG_MAX_SIZE * 1024, BACKUP_LOG_COUNT == null ? 0 : Math.max(0, BACKUP_LOG_COUNT) );
        }
        
        return new StreamTaskListener(eventStreams.get(), StandardCharsets.UTF_8);
    }
    
    protected XmlFile getDataFile() {
        return new XmlFile(Items.XSTREAM, new File(folder.getComputationDir(), "computation.xml"));
    }
    
    public List<Cause> getCauses() {
        CauseAction a = getAction(CauseAction.class);
        if (a == null) {
            return Collections.emptyList();
        }
        
        return Collections.unmodifiableList(a.getCauses());
    }
    
    public String getDisplayName() {
        return AlternativeUiTextProvider.get(DISPLAY_NAME, this, Messages.FolderComputation_DisplayName());
    }
    
    public String getSearchUrl() {
        return "computation/";
    }
    
    public ComputedFolder<I> getParent() {
        return folder;
    }
    
    public long getEstimatedDuration() {
        if (durations == null || durations.isEmpty()) {
            return -1;
        }
        
        long total = 0;
        for (Long d : durations) {
            total += d;
        }
        
        return total / durations.size();
    }
    
    public boolean isBuilding() {
        return Executor.of(this) != null;
    }
    
    public boolean isLogUpdated() {
        return result == null;
    }
    
    public AnnotatedLargeText<FolderComputation<I>> getLogText() {
        return new AnnotatedLargeText<FolderComputation<I>>(getLogFile(), StandardCharsets.UTF_8, !isLogUpdated(), this);
    }
    
    public AnnotatedLargeText<FolderComputation<I>> getEventsText() {
        File eventsFile = getEventsFile();
        if (eventsFile.length() <= 0) {
            ByteBuffer buffer = new ByteBuffer();
            try {
                buffer.write( String.format("No events as of %tc, waiting for events...%n", new Date()) .getBytes(StandardCharsets.UTF_8) );
                return new AnnotatedLargeText<FolderComputation<I>>(buffer, StandardCharsets.UTF_8, false, this);
            }
             catch (IOException e) {
            }
            
        }
        
        return new AnnotatedLargeText<FolderComputation<I>>(eventsFile, StandardCharsets.UTF_8, false, this);
    }
    
    @SuppressFBWarnings(value = "RV_RETURN_VALUE_IGNORED", justification = "Only one page is ever written here")
    public void writeLogTo(long offset, XMLOutput out) throws IOException {
        getLogText().writeHtmlTo(offset, out.asWriter());
    }
    
    public void writeWholeLogTo(@NonNull OutputStream out) throws IOException, InterruptedException {
        long pos = 0;
        AnnotatedLargeText<?> logText;
        do {
            logText = getLogText();
            pos = logText.writeLogTo(pos, out);
        }
         while (!logText.isComplete());
    }
    
    public void doConsoleText(StaplerRequest req, StaplerResponse rsp) throws IOException {
        rsp.setContentType("text/plain;charset=UTF-8");
        try (PlainTextConsoleOutputStream out = new PlainTextConsoleOutputStream(rsp.getCompressedOutputStream(req)); InputStream input = getLogInputStream()) {
                    IOUtils.copy(input, out);
                    out.flush();
        }
        
    }
    
    public synchronized HttpResponse doStop() throws IOException, ServletException {
        Executor e = Executor.of(this);
        if (e != null) {
            return e.doStop();
        }
         else {
            return HttpResponses.forwardToPreviousPage();
        }
        
    }
    
    public InputStream getLogInputStream() throws IOException {
        File logFile = getLogFile();
        if (logFile.exists()) {
            FileInputStream fis = new FileInputStream(logFile);
            if (logFile.getName().endsWith(".gz")) {
                return new GZIPInputStream(fis);
            }
             else {
                return fis;
            }
            
        }
        
        String message = "No such file: " + logFile;
        return new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8));
    }
    
    public Result getResult() {
        return result;
    }
    
    public Calendar getTimestamp() {
        GregorianCalendar c = new GregorianCalendar();
        c.setTimeInMillis(timestamp);
        return c;
    }
    
    public String getDurationString() {
        if (isBuilding()) {
            return Messages.Run_InProgressDuration(Util.getTimeSpanString(System.currentTimeMillis() - timestamp));
        }
         else {
            return Util.getTimeSpanString(duration);
        }
        
    }
    
    public String getUrl() {
        return folder.getUrl() + "computation/";
    }
    
    public Result getPreviousResult() {
        return previousResult;
    }
    
    public BallColor getIconColor() {
        Result _result = result;
        if (_result != null) {
            return _result.color;
        }
        
        Result previousResult = getPreviousResult();
        if (previousResult == null) {
            return isBuilding() ? BallColor.NOTBUILT_ANIME : BallColor.NOTBUILT;
        }
        
        return isBuilding() ? previousResult.color.anime() : previousResult.color;
    }
    
    public String getBuildStatusIconClassName() {
        return getIconColor().getIconClassName();
    }
    
    public String toString() {
        return getClass().getSimpleName() + "[" + folder.getFullName() + "]";
    }
    
    static {
        Items.XSTREAM.alias("folder-computation", FolderComputation.class);
    }
    
    public static final Message<FolderComputation> DISPLAY_NAME = new Message<FolderComputation>();
}


