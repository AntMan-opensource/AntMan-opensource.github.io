package org.apache.james.imap.processor;
import java.io.Closeable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.StringTokenizer;
import org.apache.james.core.Username;
import org.apache.james.imap.api.display.HumanReadableText;
import org.apache.james.imap.api.message.Capability;
import org.apache.james.imap.api.message.request.ImapRequest;
import org.apache.james.imap.api.message.response.StatusResponseFactory;
import org.apache.james.imap.api.process.ImapProcessor;
import org.apache.james.imap.api.process.ImapSession;
import org.apache.james.imap.message.request.AuthenticateRequest;
import org.apache.james.imap.message.request.IRAuthenticateRequest;
import org.apache.james.imap.message.response.AuthenticateResponse;
import org.apache.james.mailbox.MailboxManager;
import org.apache.james.metrics.api.MetricFactory;
import org.apache.james.util.MDCBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.common.collect.ImmutableList;
public class AuthenticateProcessor extends AbstractAuthProcessor<AuthenticateRequest> implements CapabilityImplementingProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(AuthenticateProcessor.class);
    private static final String PLAIN = "PLAIN";
    public AuthenticateProcessor(ImapProcessor next, MailboxManager mailboxManager, StatusResponseFactory factory, MetricFactory metricFactory) {
        super(AuthenticateRequest.class, next, mailboxManager, factory, metricFactory);
    }
    
    protected void processRequest(AuthenticateRequest request, ImapSession session, final Responder responder) {
        final String authType = request.getAuthType();
        if (authType.equalsIgnoreCase(PLAIN)) {
            if (session.isPlainAuthDisallowed() && session.isTLSActive() == false) {
                no(request, responder, HumanReadableText.DISABLED_LOGIN);
            }
             else {
                if (request instanceof IRAuthenticateRequest) {
                    IRAuthenticateRequest irRequest = (IRAuthenticateRequest) request;
                    doPlainAuth(irRequest.getInitialClientResponse(), session, request, responder);
                }
                 else {
                    responder.respond(new AuthenticateResponse());
                    session.pushLineHandler((requestSession, data) -> {
                        String initialClientResponse = new String(data, 0, data.length - 2, StandardCharsets.US_ASCII);
                        doPlainAuth(initialClientResponse, requestSession, request, responder);
                        requestSession.popLineHandler();
                    }
                    
);
                }
                
            }
            
        }
         else {
            LOGGER.debug("Unsupported authentication mechanism '{}'", authType);
            no(request, responder, HumanReadableText.UNSUPPORTED_AUTHENTICATION_MECHANISM);
        }
        
    }
    
    protected void doPlainAuth(String initialClientResponse, ImapSession session, ImapRequest request, Responder responder) {
        AuthenticationAttempt authenticationAttempt = parseDelegationAttempt(initialClientResponse);
        if (authenticationAttempt.isDelegation()) {
            doAuthWithDelegation(authenticationAttempt, session, request, responder, HumanReadableText.AUTHENTICATION_FAILED);
        }
         else {
            doAuth(authenticationAttempt, session, request, responder, HumanReadableText.AUTHENTICATION_FAILED);
        }
        
    }
    
    private AuthenticationAttempt parseDelegationAttempt(String initialClientResponse) {
        String token2;
        try {
            String userpass = new String(Base64.getDecoder().decode(initialClientResponse));
            StringTokenizer authTokenizer = new StringTokenizer(userpass, "\0");
            String token1 = authTokenizer.nextToken();  
            token2 = authTokenizer.nextToken();                 
            try {
                return delegation(Username.of(token1), Username.of(token2), authTokenizer.nextToken());
            }
             catch (java.util.NoSuchElementException ignored) {
                return noDelegation(Username.of(token1), token2);
            }
             finally {
                authTokenizer = null;
            }
            
        }
         catch (Exception e) {
            return noDelegation(null, null);
        }
        
    }
    
    public List<Capability> getImplementedCapabilities(ImapSession session) {
        List<Capability> caps = new ArrayList<>();
        if (session.isPlainAuthDisallowed()  == false || session.isTLSActive()) {
            caps.add(Capability.of("AUTH=PLAIN"));
        }
        
        caps.add(Capability.of("SASL-IR"));
        return ImmutableList.copyOf(caps);
    }
    
    protected Closeable addContextToMDC(AuthenticateRequest request) {
        return MDCBuilder.create() .addToContext(MDCBuilder.ACTION, "AUTHENTICATE") .addToContext("authType", request.getAuthType()) .build();
    }
    
}


