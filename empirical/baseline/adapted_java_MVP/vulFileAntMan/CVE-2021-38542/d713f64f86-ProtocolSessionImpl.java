package org.apache.james.protocols.api;
import static java.nio.charset.StandardCharsets.US_ASCII;
import java.net.InetSocketAddress;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import org.apache.james.core.Username;
import org.apache.james.protocols.api.handler.LineHandler;
import com.google.common.base.Preconditions;
public class ProtocolSessionImpl implements ProtocolSession {
    private final ProtocolTransport transport;
    private final Map<AttachmentKey<?>, Object> connectionState;
    private final Map<AttachmentKey<?>, Object> sessionState;
    private Username username;
    protected final ProtocolConfiguration config;
    private static final String DELIMITER = "\r\n";
    public ProtocolSessionImpl(ProtocolTransport transport, ProtocolConfiguration config) {
        this.transport = transport;
        this.connectionState = new HashMap<>();
        this.sessionState = new HashMap<>();
        this.config = config;
    }
    
    public InetSocketAddress getLocalAddress() {
        return transport.getLocalAddress();
    }
    
    public InetSocketAddress getRemoteAddress() {
        return transport.getRemoteAddress();
    }
    
    public Username getUsername() {
        return username;
    }
    
    public void setUsername(Username username) {
        this.username = username;
    }
    
    public ProtocolTransport getProtocolTransport() {
        return transport;
    }
    
    public boolean isStartTLSSupported() {
        return transport.isStartTLSSupported();
    }
    
    public boolean isTLSStarted() {
        return transport.isTLSStarted();
    }
    
    public String getSessionID() {
        return transport.getId();
    }
    
    public Map<AttachmentKey<?>, Object> getConnectionState() {
        return connectionState;
    }
    
    public Map<AttachmentKey<?>, Object> getState() {
        return sessionState;
    }
    
    public Response newLineTooLongResponse() {
        return null;
    }
    
    public Response newFatalErrorResponse() {
        return null;
    }
    
    public Response newCommandNotFoundErrorResponse() {
        return null;
    }
    
    public void resetState() {
        sessionState.clear();
    }
    
    public ProtocolConfiguration getConfiguration() {
        return config;
    }
    
    public <T> Optional<T> setAttachment(AttachmentKey<T> key, T value, State state) {
        Preconditions.checkNotNull(key, "key cannot be null");
        Preconditions.checkNotNull(value, "value cannot be null");
        if (state == State.Connection) {
            return key.convert(connectionState.put(key, value));
        }
         else {
            return key.convert(sessionState.put(key, value));
        }
        
    }
    
    public <T> Optional<T> removeAttachment(AttachmentKey<T> key, State state) {
        Preconditions.checkNotNull(key, "key cannot be null");
        if (state == State.Connection) {
            return key.convert(connectionState.remove(key));
        }
         else {
            return key.convert(sessionState.remove(key));
        }
        
    }
    
    public <T> Optional<T> getAttachment(AttachmentKey<T> key, State state) {
        if (state == State.Connection) {
            return key.convert(connectionState.get(key));
        }
         else {
            return key.convert(sessionState.get(key));
        }
        
    }
    
    public Charset getCharset() {
        return US_ASCII;
    }
    
    public String getLineDelimiter() {
        return DELIMITER;
    }
    
    public void popLineHandler() {
        transport.popLineHandler();
    }
    
    public int getPushedLineHandlerCount() {
        return transport.getPushedLineHandlerCount();
    }
    
    public <T extends ProtocolSession> void pushLineHandler(LineHandler<T> overrideCommandHandler) {
        transport.pushLineHandler(overrideCommandHandler, this);
    }
    
}


