package net.opentsdb.tsd;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import net.opentsdb.core.Const;
import net.opentsdb.core.TSDB;
import net.opentsdb.graph.Plot;
import net.opentsdb.stats.Histogram;
import net.opentsdb.stats.StatsCollector;
import net.opentsdb.utils.PluginLoader;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelFutureListener;
import org.jboss.netty.channel.DefaultFileRegion;
import org.jboss.netty.handler.codec.http.HttpHeaders;
import org.jboss.netty.handler.codec.http.HttpMethod;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.netty.util.CharsetUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ch.qos.logback.classic.spi.ThrowableProxy;
import ch.qos.logback.classic.spi.ThrowableProxyUtil;
import com.stumbleupon.async.Deferred;
final class HttpQuery extends AbstractHttpQuery {
  private static final Logger LOG = LoggerFactory.getLogger(HttpQuery.class);
  private static final String HTML_CONTENT_TYPE = "text/html; charset=UTF-8";
  private static final int MAX_API_VERSION = 1;
  private static final Histogram httplatency = new Histogram(16000, (short) 2, 100);
  private static HashMap<String, Constructor<? extends HttpSerializer>> serializer_map_content_type = null;
  private static HashMap<String, Constructor<? extends HttpSerializer>> serializer_map_query_string = null;
  private static ArrayList<HashMap<String, Object>> serializer_status = null;
  private int api_version = 0;
  private HttpSerializer serializer = null;
  private final boolean show_stack_trace;
  public HttpQuery(final TSDB tsdb, final HttpRequest request, final Channel chan) {
    super(tsdb, request, chan);
    this.show_stack_trace = tsdb.getConfig().getBoolean("tsd.http.show_stack_trace");
    this.serializer = new HttpJsonSerializer(this);
  }
  
  public static void collectStats(final StatsCollector collector) {
    collector.record("http.latency", httplatency, "type=all");
  }
  
  public int apiVersion() {
    return this.api_version;
  }
  
  public boolean showStackTrace() {
    return this.show_stack_trace;
  }
  
  public Deferred<Object> getDeferred() {
    return deferred;
  }
  
  public HttpSerializer serializer() {
    return this.serializer;
  }
  
  public String[] explodeAPIPath() {
    final String[] split = this.explodePath();
    int index = 1;
    if (split.length < 1 || !split[0].toLowerCase().equals("api")) {
      throw new IllegalArgumentException("The URI does not start with \"/api\"");
    }
    
    if (split.length < 2) {
      final String[] root = { "" };
      return root;
    }
    
    if (split[1].toLowerCase().startsWith("v") && split[1].length() > 1 && Character.isDigit(split[1].charAt(1))) {
      index = 2;
    }
    
    if (split.length - index == 0) {
      final String[] root = { "" };
      return root;
    }
    
    final String[] path = new String[split.length - index];
    int path_idx = 0;
    for (int i = index; i < split.length; i++) {
      path[path_idx] = split[i];
      path_idx++;
    }
    
    return path;
  }
  
  public String getQueryBaseRoute() {
    final String[] split = explodePath();
    if (split.length < 1) {
      return "";
    }
    
    if (!split[0].toLowerCase().equals("api")) {
      return split[0].toLowerCase();
    }
    
    this.api_version = MAX_API_VERSION;
    if (split.length < 2) {
      return "api";
    }
    
    if (split[1].toLowerCase().startsWith("v") && split[1].length() > 1 && Character.isDigit(split[1].charAt(1))) {
      try {
        final int version = Integer.parseInt(split[1].substring(1));
        if (version > MAX_API_VERSION) {
          throw new BadRequestException(HttpResponseStatus.NOT_IMPLEMENTED, "Requested API version is greater than the max implemented", "API version [" + version + "] is greater than the max [" + MAX_API_VERSION + "]");
        }
        
        this.api_version = version;
      }
       catch (NumberFormatException nfe) {
        throw new BadRequestException(HttpResponseStatus.BAD_REQUEST, "Invalid API version format supplied", "API version [" + split[1].substring(1) + "] cannot be parsed to an integer");
      }
      
    }
     else {
      return "api/" + split[1].toLowerCase();
    }
    
    if (split.length < 3){
      return "api";
    }
    
    return "api/" + split[2].toLowerCase();
  }
  
  public HttpMethod getAPIMethod() {
    if (this.method() != HttpMethod.GET) {
      return this.method();
    }
     else {
      if (this.hasQueryStringParam("method_override")) {
        final String qs_method = this.getQueryStringParam("method_override");
        if (qs_method == null || qs_method.isEmpty()) {
          throw new BadRequestException(HttpResponseStatus.METHOD_NOT_ALLOWED, "Missing method override value");
        }
        
        if (qs_method.toLowerCase().equals("get")) {
          return HttpMethod.GET;
        }
         else if (qs_method.toLowerCase().equals("post")){
          return HttpMethod.POST;
        }
         else if (qs_method.toLowerCase().equals("put")){
          return HttpMethod.PUT;
        }
         else if (qs_method.toLowerCase().equals("delete")){
          return HttpMethod.DELETE;
        }
         else {
          throw new BadRequestException(HttpResponseStatus.METHOD_NOT_ALLOWED, "Unknown or unsupported method override value");
        }
        
      }
      
      return this.method();
    }
    
  }
  
  public void setSerializer() throws InvocationTargetException, IllegalArgumentException, InstantiationException, IllegalAccessException {
    if (this.hasQueryStringParam("serializer")) {
      final String qs = this.getQueryStringParam("serializer");
      Constructor<? extends HttpSerializer> ctor = serializer_map_query_string.get(qs);
      if (ctor == null) {
        this.serializer = new HttpJsonSerializer(this);
        throw new BadRequestException(HttpResponseStatus.BAD_REQUEST, "Requested serializer was not found", "Could not find a serializer with the name: " + qs);
      }
      
      this.serializer = ctor.newInstance(this);
      return;
    }
    
    String content_type = request().headers().get("Content-Type");
    if (content_type == null || content_type.isEmpty()) {
      return;
    }
    
    if (content_type.indexOf(";") > -1) {
      content_type = content_type.substring(0, content_type.indexOf(";"));
    }
    
    Constructor<? extends HttpSerializer> ctor = serializer_map_content_type.get(content_type);
    if (ctor == null) {
      return;
    }
    
    this.serializer = ctor.newInstance(this);
  }
  
  public void internalError(final Exception cause) {
    logError("Internal Server Error on " + request().getUri(), cause);
    if (this.api_version > 0) {
      switch (this.api_version) {
        case 1:
        default: sendReply(HttpResponseStatus.INTERNAL_SERVER_ERROR, serializer.formatErrorV1(cause));
      }
      
      return;
    }
    
    ThrowableProxy tp = new ThrowableProxy(cause);
    tp.calculatePackagingData();
    final String pretty_exc = ThrowableProxyUtil.asString(tp);
    tp = null;
    if (hasQueryStringParam("json")) {
      final StringBuilder buf = new StringBuilder(32 + pretty_exc.length());
      buf.append("{\"err\":\"");
      HttpQuery.escapeJson(pretty_exc, buf);
      buf.append("\"}");
      sendReply(HttpResponseStatus.INTERNAL_SERVER_ERROR, buf);
    }
     else {
      sendReply(HttpResponseStatus.INTERNAL_SERVER_ERROR, makePage("Internal Server Error", "Houston, we have a problem", "<blockquote>" + "<h1>Internal Server Error</h1>" + "Oops, sorry but your request failed due to a" + " server error.<br/><br/>" + "Please try again in 30 seconds.<pre>" + pretty_exc + "</pre></blockquote>"));
    }
    
  }
  
  public void badRequest(final String explain) {
    badRequest(new BadRequestException(explain));
  }
  
  public void badRequest(final BadRequestException exception) {
    logWarn("Bad Request on " + request().getUri() + ": " + exception.getMessage());
    if (this.api_version > 0) {
      switch (this.api_version) {
        case 1:
        default: sendReply(exception.getStatus(), serializer.formatErrorV1(exception));
      }
      
      return;
    }
    
    if (hasQueryStringParam("json")) {
      final StringBuilder buf = new StringBuilder(10 + exception.getDetails().length());
      buf.append("{\"err\":\"");
      HttpQuery.escapeJson(exception.getMessage(), buf);
      buf.append("\"}");
      sendReply(HttpResponseStatus.BAD_REQUEST, buf);
    }
     else {
      sendReply(HttpResponseStatus.BAD_REQUEST, makePage("Bad Request", "Looks like it's your fault this time", "<blockquote>" + "<h1>Bad Request</h1>" + "Sorry but your request was rejected as being" + " invalid.<br/><br/>" + "The reason provided was:<blockquote>" + exception.getMessage() + "</blockquote></blockquote>"));
    }
    
  }
  
  public void notFound() {
    logWarn("Not Found: " + request().getUri());
    if (this.api_version > 0) {
      switch (this.api_version) {
        case 1:
        default: sendReply(HttpResponseStatus.NOT_FOUND, serializer.formatNotFoundV1());
      }
      
      return;
    }
    
    if (hasQueryStringParam("json")) {
      sendReply(HttpResponseStatus.NOT_FOUND, new StringBuilder("{\"err\":\"Page Not Found\"}"));
    }
     else {
      sendReply(HttpResponseStatus.NOT_FOUND, PAGE_NOT_FOUND);
    }
    
  }
  
  public void redirect(final String location) {
    response().headers().set("Location", location);
    sendReply(HttpResponseStatus.OK, new StringBuilder( "<html></head><meta http-equiv=\"refresh\" content=\"0; url=" + location + "\"></head></html>") .toString().getBytes(this.getCharset()) );
  }
  
  static void escapeJson(final String s, final StringBuilder buf) {
    final int length = s.length();
    int extra = 0;
    for (int i = 0; i < length; i++) {
      final char c = s.charAt(i);
      switch (c) {
        case '"':
        case '\\':
        case '\b':
        case '\f':
        case '\n':
        case '\r':
        case '\t':
          extra++;
          continue;
      }
      
      if (c < 0x001F) {
        extra += 4;
      }
      
    }
    
    if (extra == 0) {
      buf.append(s);  
      return;
    }
    
    buf.ensureCapacity(buf.length() + length + extra);
    for (int i = 0; i < length; i++) {
      final char c = s.charAt(i);
      switch (c) {
        case '"':  buf.append('\\').append('"');  continue;
        case '\\': buf.append('\\').append('\\'); continue;
        case '\b': buf.append('\\').append('b');  continue;
        case '\f': buf.append('\\').append('f');  continue;
        case '\n': buf.append('\\').append('n');  continue;
        case '\r': buf.append('\\').append('r');  continue;
        case '\t': buf.append('\\').append('t');  continue;
      }
      
      if (c < 0x001F) {
        buf.append('\\').append('u').append('0').append('0') .append((char) Const.HEX[(c >>> 4) & 0x0F]) .append((char) Const.HEX[c & 0x0F]);
      }
       else {
        buf.append(c);
      }
      
    }
    
  }
  
  public void sendReply(final byte[] data) {
    sendBuffer(HttpResponseStatus.OK, ChannelBuffers.wrappedBuffer(data));
  }
  
  public void sendReply(final HttpResponseStatus status, final byte[] data) {
    sendBuffer(status, ChannelBuffers.wrappedBuffer(data));
  }
  
  public void sendReply(final StringBuilder buf) {
    sendReply(HttpResponseStatus.OK, buf);
  }
  
  public void sendReply(final String buf) {
    sendBuffer(HttpResponseStatus.OK, ChannelBuffers.copiedBuffer(buf, CharsetUtil.UTF_8));
  }
  
  public void sendReply(final HttpResponseStatus status, final StringBuilder buf) {
    sendBuffer(status, ChannelBuffers.copiedBuffer(buf.toString(), CharsetUtil.UTF_8));
  }
  
  public void sendReply(final ChannelBuffer buf) {
    sendBuffer(HttpResponseStatus.OK, buf);
  }
  
  public void sendReply(final HttpResponseStatus status, final ChannelBuffer buf) {
    sendBuffer(status, buf);
  }
  
  public void sendFile(final String path, final int max_age) throws IOException {
    sendFile(HttpResponseStatus.OK, path, max_age);
  }
  
  public void sendFile(final HttpResponseStatus status, final String path, final int max_age) throws IOException {
    if (max_age < 0) {
      throw new IllegalArgumentException("Negative max_age=" + max_age + " for path=" + path);
    }
    
    if (!channel().isConnected()) {
      done();
      return;
    }
    
    RandomAccessFile file;
    try {
      file = new RandomAccessFile(path, "r");
    }
     catch (FileNotFoundException e) {
      logWarn("File not found: " + e.getMessage());
      if (getQueryString() != null && !getQueryString().isEmpty()) {
        getQueryString().remove("png");  
      }
      
      this.sendReply(HttpResponseStatus.NOT_FOUND, serializer.formatNotFoundV1());
      return;
    }
    
    final long length = file.length();{
      final String mimetype = guessMimeTypeFromUri(path);
      response().headers().set(HttpHeaders.Names.CONTENT_TYPE, mimetype == null ? "text/plain" : mimetype);
      final long mtime = new File(path).lastModified();
      if (mtime > 0) {
        response().headers().set(HttpHeaders.Names.AGE, (System.currentTimeMillis() - mtime) / 1000);
      }
       else {
        logWarn("Found a file with mtime=" + mtime + ": " + path);
      }
      
      response().headers().set(HttpHeaders.Names.CACHE_CONTROL, "max-age=" + max_age);
      HttpHeaders.setContentLength(response(), length);
      channel().write(response());
    }
    
    final DefaultFileRegion region = new DefaultFileRegion(file.getChannel(), 0, length);
    final ChannelFuture future = channel().write(region);
    future.addListener(new ChannelFutureListener() {
      public void operationComplete(final ChannelFuture future) {
        region.releaseExternalResources();
        done();
      }
      
    }
    
);
    if (!HttpHeaders.isKeepAlive(request())) {
      future.addListener(ChannelFutureListener.CLOSE);
    }
    
  }
  
  public void done() {
    final int processing_time = processingTimeMillis();
    httplatency.add(processing_time);
    logInfo("HTTP " + request().getUri() + " done in " + processing_time + "ms");
    deferred.callback(null);
  }
  
  private void sendBuffer(final HttpResponseStatus status, final ChannelBuffer buf) {
    final String contentType = (api_version < 1 ? guessMimeType(buf) : serializer.responseContentType());
    sendBuffer(status, buf, contentType);
  }
  
  private String guessMimeType(final ChannelBuffer buf) {
    final String mimetype = guessMimeTypeFromUri(request().getUri());
    return mimetype == null ? guessMimeTypeFromContents(buf) : mimetype;
  }
  
  private static String guessMimeTypeFromUri(final String uri) {
    final int questionmark = uri.indexOf('?', 1);  
    final int end = (questionmark > 0 ? questionmark : uri.length()) - 1;
    if (end < 5) {  
      return null;
    }
    
    final char a = uri.charAt(end - 3);
    final char b = uri.charAt(end - 2);
    final char c = uri.charAt(end - 1);
    switch (uri.charAt(end)) {
      case 'g':
        return a == '.' && b == 'p' && c == 'n' ? "image/png" : null;
      case 'l':
        return a == 'h' && b == 't' && c == 'm' ? HTML_CONTENT_TYPE : null;
      case 's':
        if (a == '.' && b == 'c' && c == 's') {
          return "text/css";
        }
         else if (b == '.' && c == 'j') {
          return "text/javascript";
        }
         else {
          break;
        }
        
      case 'f':
        return a == '.' && b == 'g' && c == 'i' ? "image/gif" : null;
      case 'o':
        return a == '.' && b == 'i' && c == 'c' ? "image/x-icon" : null;
    }
    
    return null;
  }
  
  private String guessMimeTypeFromContents(final ChannelBuffer buf) {
    if (!buf.readable()) {
      logWarn("Sending an empty result?! buf=" + buf);
      return "text/plain";
    }
    
    final int firstbyte = buf.getUnsignedByte(buf.readerIndex());
    switch (firstbyte) {
      case '<':  
        return HTML_CONTENT_TYPE;
      case '{':  
      case '[':  
        return "application/json";  
      case 0x89:  
        return "image/png";
    }
    
    return "text/plain";  
  }
  
  public static void initializeSerializerMaps(final TSDB tsdb) throws SecurityException, NoSuchMethodException, ClassNotFoundException {
    List<HttpSerializer> serializers = PluginLoader.loadPlugins(HttpSerializer.class);
    if (serializers == null) {
      serializers = new ArrayList<HttpSerializer>(1);
    }
    
    final HttpSerializer default_serializer = new HttpJsonSerializer();
    serializers.add(default_serializer);
    serializer_map_content_type = new HashMap<String, Constructor<? extends HttpSerializer>>();
    serializer_map_query_string = new HashMap<String, Constructor<? extends HttpSerializer>>();
    serializer_status = new ArrayList<HashMap<String, Object>>();
    for (HttpSerializer serializer : serializers) {
      final Constructor<? extends HttpSerializer> ctor = serializer.getClass().getDeclaredConstructor(HttpQuery.class);
      Constructor<? extends HttpSerializer> map_ctor = serializer_map_content_type.get(serializer.requestContentType());
      if (map_ctor != null) {
        final String err = "Serializer content type collision between \"" + serializer.getClass().getCanonicalName() + "\" and \"" + map_ctor.getClass().getCanonicalName() + "\"";
        LOG.error(err);
        throw new IllegalStateException(err);
      }
      
      serializer_map_content_type.put(serializer.requestContentType(), ctor);
      map_ctor = serializer_map_query_string.get(serializer.shortName());
      if (map_ctor != null) {
        final String err = "Serializer name collision between \"" + serializer.getClass().getCanonicalName() + "\" and \"" + map_ctor.getClass().getCanonicalName() + "\"";
        LOG.error(err);
        throw new IllegalStateException(err);
      }
      
      serializer_map_query_string.put(serializer.shortName(), ctor);
      serializer.initialize(tsdb);
      if (serializer.shortName().equals("json")) {
        continue;
      }
      
      HashMap<String, Object> status = new HashMap<String, Object>();
      status.put("version", serializer.version());
      status.put("class", serializer.getClass().getCanonicalName());
      status.put("serializer", serializer.shortName());
      status.put("request_content_type", serializer.requestContentType());
      status.put("response_content_type", serializer.responseContentType());
      HashSet<String> parsers = new HashSet<String>();
      HashSet<String> formats = new HashSet<String>();
      Method[] methods = serializer.getClass().getDeclaredMethods();
      for (Method m : methods) {
        if (Modifier.isPublic(m.getModifiers())) {
          if (m.getName().startsWith("parse")) {
            parsers.add(m.getName().substring(5));
          }
           else if (m.getName().startsWith("format")) {
            formats.add(m.getName().substring(6));
          }
          
        }
        
      }
      
      status.put("parsers", parsers);
      status.put("formatters", formats);
      serializer_status.add(status);
    }
    
    HashMap<String, Object> status = new HashMap<String, Object>();
    final Class<?> base_serializer = Class.forName("net.opentsdb.tsd.HttpSerializer");
    status.put("class", default_serializer.getClass().getCanonicalName());
    status.put("serializer", default_serializer.shortName());
    status.put("request_content_type", default_serializer.requestContentType());
    status.put("response_content_type", default_serializer.responseContentType());
    ArrayList<String> parsers = new ArrayList<String>();
    ArrayList<String> formats = new ArrayList<String>();
    Method[] methods = base_serializer.getDeclaredMethods();
    for (Method m : methods) {
      if (Modifier.isPublic(m.getModifiers())) {
        if (m.getName().startsWith("parse")) {
          parsers.add(m.getName().substring(5));
        }
        
        if (m.getName().startsWith("format")) {
          formats.add(m.getName().substring(6));
        }
        
      }
      
    }
    
    status.put("parsers", parsers);
    status.put("formatters", formats);
    serializer_status.add(status);
  }
  
  public static ArrayList<HashMap<String, Object>> getSerializerStatus() {
    return serializer_status;
  }
  
  public static StringBuilder makePage(final String title, final String subtitle, final String body) {
    return makePage(null, title, subtitle, body);
  }
  
  public static StringBuilder makePage(final String htmlheader, final String title, final String subtitle, final String body) {
    final StringBuilder buf = new StringBuilder( BOILERPLATE_LENGTH + (htmlheader == null ? 0 : htmlheader.length()) + title.length() + subtitle.length() + body.length());
    buf.append(PAGE_HEADER_START) .append(title) .append(PAGE_HEADER_MID);
    if (htmlheader != null) {
      buf.append(htmlheader);
    }
    
    buf.append(PAGE_HEADER_END_BODY_START) .append(subtitle) .append(PAGE_BODY_MID) .append(body) .append(PAGE_FOOTER);
    return buf;
  }
  
  protected Logger logger() {
    return LOG;
  }
  
  private static final String PAGE_HEADER_START = "<!DOCTYPE html>" + "<html><head>" + "<meta http-equiv=content-type content=\"text/html;charset=utf-8\">" + "<title>";
  private static final String PAGE_HEADER_MID = "</title>\n" + "<style><!--\n" + "body{font-family:arial,sans-serif;margin-left:2em}" + "A.l:link{color:#6f6f6f}" + "A.u:link{color:green}" + ".fwf{font-family:monospace;white-space:pre-wrap}" + "//--></style>";
  private static final String PAGE_HEADER_END_BODY_START = "</head>\n" + "<body text=#000000 bgcolor=#ffffff>" + "<table border=0 cellpadding=2 cellspacing=0 width=100%>" + "<tr><td rowspan=3 width=1% nowrap>" + "<img src=s/opentsdb_header.jpg>" + "<td>&nbsp;</td></tr>" + "<tr><td><font color=#507e9b><b>";
  private static final String PAGE_BODY_MID = "</b></td></tr>" + "<tr><td>&nbsp;</td></tr></table>";
  private static final String PAGE_FOOTER = "<table width=100% cellpadding=0 cellspacing=0>" + "<tr><td class=subg><img alt=\"\" width=1 height=6></td></tr>" + "</table></body></html>";
  private static final int BOILERPLATE_LENGTH = PAGE_HEADER_START.length() + PAGE_HEADER_MID.length() + PAGE_HEADER_END_BODY_START.length() + PAGE_BODY_MID.length() + PAGE_FOOTER.length();
  private static final StringBuilder PAGE_NOT_FOUND = makePage("Page Not Found", "Error 404", "<blockquote>" + "<h1>Page Not Found</h1>" + "The requested URL was not found on this server." + "</blockquote>");
}


