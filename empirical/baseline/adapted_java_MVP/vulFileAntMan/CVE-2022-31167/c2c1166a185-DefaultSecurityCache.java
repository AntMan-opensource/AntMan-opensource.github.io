package org.xwiki.security.authorization.cache.internal;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.HashSet;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import javax.inject.Inject;
import javax.inject.Singleton;
import org.apache.commons.collections.CollectionUtils;
import org.slf4j.Logger;
import org.xwiki.cache.Cache;
import org.xwiki.cache.CacheManager;
import org.xwiki.cache.DisposableCacheValue;
import org.xwiki.cache.config.CacheConfiguration;
import org.xwiki.cache.eviction.EntryEvictionConfiguration;
import org.xwiki.cache.eviction.LRUEvictionConfiguration;
import org.xwiki.component.annotation.Component;
import org.xwiki.component.phase.Initializable;
import org.xwiki.component.phase.InitializationException;
import org.xwiki.model.reference.EntityReferenceSerializer;
import org.xwiki.security.GroupSecurityReference;
import org.xwiki.security.SecurityReference;
import org.xwiki.security.UserSecurityReference;
import org.xwiki.security.authorization.SecurityAccessEntry;
import org.xwiki.security.authorization.SecurityEntry;
import org.xwiki.security.authorization.SecurityRuleEntry;
import org.xwiki.security.authorization.cache.ConflictingInsertionException;
import org.xwiki.security.authorization.cache.ParentEntryEvictedException;
import org.xwiki.security.authorization.cache.SecurityShadowEntry;
import org.xwiki.security.internal.GroupSecurityEntry;
public class DefaultSecurityCache implements SecurityCache, Initializable {
    private static final int DEFAULT_CAPACITY = 10000;
    private static final String KEY_CACHE_SEPARATOR = "@@";
    private Logger logger;
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);
    private final Lock readLock = readWriteLock.readLock();
    private final Lock writeLock = readWriteLock.writeLock();
    private final ReadWriteLock invalidationReadWriteLock = new ReentrantReadWriteLock(true);
    private final Lock invalidationReadLock = invalidationReadWriteLock.readLock();
    private final Lock invalidationWriteLock = invalidationReadWriteLock.writeLock();
    private EntityReferenceSerializer<String> keySerializer;
    private CacheManager cacheManager;
    private Cache<SecurityCacheEntry> cache;
    private SecurityCacheEntry newEntry;
    private Cache<SecurityCacheEntry> newCache() throws InitializationException {
        CacheConfiguration cacheConfig = new CacheConfiguration();
        cacheConfig.setConfigurationId("platform.security.authorization.cache");
        LRUEvictionConfiguration lru = new LRUEvictionConfiguration();
        lru.setMaxEntries(DEFAULT_CAPACITY);
        cacheConfig.put(EntryEvictionConfiguration.CONFIGURATIONID, lru);
        try {
            return cacheManager.createNewCache(cacheConfig);
        }
         catch (Exception e) {
            throw new InitializationException(String .format("Unable to create the security cache with a capacity of [%d] entries", lru.getMaxEntries()), e);
        }
        
    }
    
    public void initialize() throws InitializationException {
        cache = newCache();
    }
    
    private class SecurityCacheEntry implements DisposableCacheValue {
        private SecurityEntry entry;
        private Collection<SecurityCacheEntry> parents;
        private Collection<SecurityCacheEntry> children;
        private boolean disposed;
        SecurityCacheEntry(SecurityRuleEntry entry) throws ParentEntryEvictedException {
            this.entry = entry;
            SecurityReference parentReference = entry.getReference().getParentSecurityReference();
            if (parentReference != null) {
                SecurityCacheEntry parent = DefaultSecurityCache.this.getEntry(parentReference);
                if (parent == null) {
                    throw new ParentEntryEvictedException(String.format( "The parent with reference [%s] for entry [%s] is no longer available in the cache", parentReference, entry));
                }
                
                this.parents = Arrays.asList(parent);
                parent.addChild(this);
                logNewEntry();
            }
             else {
                this.parents = null;
                logNewEntry();
            }
            
        }
        
        SecurityCacheEntry(SecurityShadowEntry entry) throws ParentEntryEvictedException {
            this.entry = entry;
            SecurityCacheEntry parent1 = DefaultSecurityCache.this.getEntry(entry.getReference());
            if (parent1 == null) {
                throw new ParentEntryEvictedException(String.format( "The parent entry with reference [%s] for entry [%s] is no longer available in the cache", parent1, entry));
            }
            
            SecurityCacheEntry parent2 = DefaultSecurityCache.this.getEntry(entry.getWikiReference());
            if (parent2 == null) {
                throw new ParentEntryEvictedException(String.format( "The wiki entry with reference [%s] for entry [%s] is no longer available in the cache", parent2, entry));
            }
            
            this.parents = Arrays.asList(parent1, parent2);
            parent1.addChild(this);
            parent2.addChild(this);
            logNewEntry();
        }
        
        SecurityCacheEntry(SecurityAccessEntry entry, SecurityReference wiki) throws ParentEntryEvictedException {
            this.entry = entry;
            boolean isSelf = entry.getReference().equals(entry.getUserReference());
            SecurityCacheEntry parent1 = DefaultSecurityCache.this.getEntry(entry.getReference());
            if (parent1 == null) {
                throw new ParentEntryEvictedException(String.format( "The first parent with reference [%s] for the entry [%s] with wiki [%s] is no longer " + "available in the cache.", parent1, entry, wiki));
            }
            
            SecurityCacheEntry parent2 = (isSelf) ? parent1 : (wiki != null) ? DefaultSecurityCache.this.getShadowEntry(entry.getUserReference(), wiki) : DefaultSecurityCache.this.getEntry(entry.getUserReference());
            if (parent2 == null) {
                throw new ParentEntryEvictedException(String.format( "The second parent with reference [%s] for the entry [%s] with wiki [%s] is no longer available " + "in the cache.", parent2, entry, wiki));
            }
            
            this.parents = (isSelf) ? Arrays.asList(parent1) : Arrays.asList(parent1, parent2);
            parent1.addChild(this);
            if (!isSelf) {
                parent2.addChild(this);
            }
            
            logNewEntry();
        }
        
        SecurityCacheEntry(SecurityRuleEntry entry, Collection<GroupSecurityReference> groups) throws ParentEntryEvictedException {
            this(entry, groups, entry.getReference().getParentSecurityReference());
        }
        
        SecurityCacheEntry(SecurityShadowEntry entry, Collection<GroupSecurityReference> groups) throws ParentEntryEvictedException {
            this(entry, groups, entry.getReference());
        }
        
        private SecurityCacheEntry(SecurityEntry entry, Collection<GroupSecurityReference> groups, SecurityReference parentReference) throws ParentEntryEvictedException {
            this.entry = entry;
            int parentSize = groups.size() + ((parentReference == null) ? 0 : 1);
            if (parentSize > 0) {
                this.parents = new ArrayList<>(parentSize);
                if (parentReference != null) {
                    SecurityCacheEntry parent = DefaultSecurityCache.this.getEntry(parentReference);
                    if (parent == null) {
                        throw new ParentEntryEvictedException(String.format( "The parent with reference [%s] required by entry [%s] with groups [%s]" + " is no longer available in the cache.", parentReference, entry, groups));
                    }
                    
                    this.parents.add(parent);
                    parent.addChild(this);
                }
                
                addParentGroups(groups, parentReference);
                logNewEntry();
            }
             else {
                this.parents = null;
                logNewEntry();
            }
            
        }
        
        private void addParentGroups(Collection<GroupSecurityReference> groups, SecurityReference parentReference) throws ParentEntryEvictedException {
            for (GroupSecurityReference group : groups) {
                if (group.equals(parentReference)) {
                    continue;
                }
                
                SecurityCacheEntry parent = (entry instanceof SecurityShadowEntry && group.isGlobal()) ? DefaultSecurityCache.this.getShadowEntry(group, ((SecurityShadowEntry) entry).getWikiReference()) : DefaultSecurityCache.this.getEntry(group);
                if (parent == null) {
                    throw new ParentEntryEvictedException(String .format("The parent with reference [%s] is no longer available in the cache", parentReference));
                }
                
                if (!(parent.getEntry().getReference() instanceof GroupSecurityReference) && parent.getEntry() instanceof GroupSecurityEntry) {
                    ((GroupSecurityEntry) parent.getEntry()).setGroupReference(group);
                }
                
                this.parents.add(parent);
                parent.addChild(this);
            }
            
        }
        
        boolean updateParentGroups(Collection<GroupSecurityReference> groups) throws ParentEntryEvictedException {
            if (isUser() || !(entry instanceof SecurityRuleEntry)) {
                return false;
            }
            
            if (groups != null && !groups.isEmpty()) {
                if (this.parents == null) {
                    this.parents = new ArrayList<>(groups.size());
                    addParentGroups(groups, null);
                }
                 else {
                    SecurityCacheEntry parent = this.parents.iterator().next();
                    this.parents = new ArrayList<>(groups.size() + 1);
                    this.parents.add(parent);
                    addParentGroups(groups, parent.entry.getReference());
                }
                
            }
            
            return true;
        }
        
        private void logNewEntry() {
            if (logger.isDebugEnabled()) {
                if (CollectionUtils.isEmpty(parents)) {
                    logger.debug("New orphan entry [{}].", getKey());
                    return;
                }
                
                StringBuilder sb = new StringBuilder("New entry [");
                sb.append(getKey()).append("] as child of ");
                boolean first = true;
                for (SecurityCacheEntry parent : parents) {
                    if (!first) {
                        sb.append(", ");
                    }
                     else {
                        first = false;
                    }
                    
                    sb.append('[').append(parent.getKey()).append(']');
                }
                
                sb.append(".");
                logger.debug(sb.toString());
            }
            
        }
        
        SecurityEntry getEntry() {
            return this.entry;
        }
        
        String getKey() {
            return DefaultSecurityCache.this.getEntryKey(entry);
        }
        
        public void dispose() {
            if (!disposed) {
                disposed = true;
                suspendInvalidation();
                try {
                    disconnectFromParents();
                    disposeChildren();
                }
                 finally {
                    resumeInvalidation();
                }
                
            }
            
        }
        
        protected void disconnectFromParents() {
            if (parents != null) {
                for (SecurityCacheEntry parent : parents) {
                    if (!parent.disposed) {
                        parent.removeChild(this);
                    }
                    
                }
                
            }
            
        }
        
        private void disposeChildren() {
            if (children != null) {
                for (SecurityCacheEntry child : children) {
                    if (!child.disposed) {
                        if (logger.isDebugEnabled()) {
                            logger.debug("Cascaded removal of entry [{}] from cache.", child.getKey());
                        }
                        
                        if (child == newEntry) {
                            child.dispose();
                        }
                         else {
                            try {
                                DefaultSecurityCache.this.cache.remove(child.getKey());
                            }
                             catch (Throwable e) {
                                logger.error("Security cache failure during eviction of entry [{}]", child.getKey(), e);
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        private void addChild(SecurityCacheEntry entry) {
            if (this.children == null) {
                this.children = new ArrayList<>();
            }
            
            this.children.add(entry);
        }
        
        private void removeChild(SecurityCacheEntry entry) {
            if (this.children != null) {
                this.children.remove(entry);
                if (logger.isDebugEnabled()) {
                    logger.debug("Remove child [{}] from [{}].", entry.getKey(), getKey());
                }
                
            }
            
        }
        
        public boolean isUser() {
            return entry.getReference() instanceof UserSecurityReference && !(entry instanceof SecurityAccessEntry);
        }
        
        public String toString() {
            return this.entry.toString();
        }
        
    }
    
    private String getEntryKey(SecurityReference reference) {
        return keySerializer.serialize(reference);
    }
    
    private String getEntryKey(UserSecurityReference userReference, SecurityReference reference) {
        return keySerializer.serialize(userReference) + KEY_CACHE_SEPARATOR + keySerializer.serialize(reference);
    }
    
    private String getShadowEntryKey(SecurityReference userReference, SecurityReference root) {
        return keySerializer.serialize(root) + KEY_CACHE_SEPARATOR + keySerializer.serialize(userReference);
    }
    
    private String getEntryKey(SecurityEntry entry) {
        if (entry instanceof SecurityAccessEntry) {
            return getEntryKey((SecurityAccessEntry) entry);
        }
         else if (entry instanceof SecurityRuleEntry) {
            return getEntryKey((SecurityRuleEntry) entry);
        }
         else {
            return getEntryKey((SecurityShadowEntry) entry);
        }
        
    }
    
    private String getEntryKey(SecurityShadowEntry entry) {
        return getShadowEntryKey(entry.getReference(), entry.getWikiReference());
    }
    
    private String getEntryKey(SecurityRuleEntry entry) {
        return getEntryKey(entry.getReference());
    }
    
    private String getEntryKey(SecurityAccessEntry entry) {
        return getEntryKey(entry.getUserReference(), entry.getReference());
    }
    
    private SecurityCacheEntry getEntry(SecurityReference reference) {
        readLock.lock();
        try {
            return cache.get(getEntryKey(reference));
        }
         finally {
            readLock.unlock();
        }
        
    }
    
    private SecurityCacheEntry getEntry(UserSecurityReference userReference, SecurityReference reference) {
        readLock.lock();
        try {
            return cache.get(getEntryKey(userReference, reference));
        }
         finally {
            readLock.unlock();
        }
        
    }
    
    private SecurityCacheEntry getShadowEntry(SecurityReference userReference, SecurityReference wiki) {
        readLock.lock();
        try {
            return cache.get(getShadowEntryKey(userReference, wiki));
        }
         finally {
            readLock.unlock();
        }
        
    }
    
    private boolean isAlreadyInserted(String key, SecurityEntry entry) throws ConflictingInsertionException {
        try {
            return isAlreadyInserted(key, entry, null);
        }
         catch (ParentEntryEvictedException e) {
            return true;
        }
        
    }
    
    private boolean isAlreadyInserted(String key, SecurityEntry entry, Collection<GroupSecurityReference> groups) throws ConflictingInsertionException, ParentEntryEvictedException {
        SecurityCacheEntry oldEntry = cache.get(key);
        if (oldEntry != null) {
            if (!oldEntry.getEntry().equals(entry)) {
                throw new ConflictingInsertionException( String.format( "Another thread has inserted an entry [%s] which is different from entry [%s]" + " with key [%s] and groups [%s]", oldEntry, entry, key, groups));
            }
            
            if (oldEntry.updateParentGroups(groups)) {
                oldEntry.entry = entry;
            }
            
            return true;
        }
        
        return false;
    }
    
    private void addEntry(String key, SecurityCacheEntry entry) throws ConflictingInsertionException {
        try {
            newEntry = entry;
            cache.set(key, newEntry);
            if (entry.disposed) {
                cache.remove(key);
                throw new ConflictingInsertionException(String.format( "The cache entry [%s] with key [%s] has been disposed by another thread while being added.", entry, key));
            }
            
        }
         finally {
            newEntry = null;
        }
        
    }
    
    public void add(SecurityRuleEntry entry) throws ParentEntryEvictedException, ConflictingInsertionException {
        add(entry, null);
    }
    
    public void add(SecurityRuleEntry entry, Collection<GroupSecurityReference> groups) throws ConflictingInsertionException, ParentEntryEvictedException {
        add((SecurityEntry) entry, groups);
    }
    
    public void add(SecurityShadowEntry entry, Collection<GroupSecurityReference> groups) throws ConflictingInsertionException, ParentEntryEvictedException {
        add((SecurityEntry) entry, groups);
    }
    
    private void add(SecurityEntry entry, Collection<GroupSecurityReference> groups) throws ConflictingInsertionException, ParentEntryEvictedException {
        String key = getEntryKey(entry);
        writeLock.lock();
        try {
            if (isAlreadyInserted(key, entry, groups)) {
                return;
            }
            
            addEntry(key, newSecurityCacheEntry(entry, groups));
            logger.debug("Added rule/shadow entry [{}] into the cache.", key);
        }
         finally {
            writeLock.unlock();
        }
        
    }
    
    private SecurityCacheEntry newSecurityCacheEntry(SecurityEntry entry, Collection<GroupSecurityReference> groups) throws ParentEntryEvictedException {
        if (entry instanceof SecurityRuleEntry) {
            return (groups == null) ? new SecurityCacheEntry((SecurityRuleEntry) entry) : new SecurityCacheEntry((SecurityRuleEntry) entry, groups);
        }
         else {
            return (groups == null) ? new SecurityCacheEntry((SecurityShadowEntry) entry) : new SecurityCacheEntry((SecurityShadowEntry) entry, groups);
        }
        
    }
    
    public void add(SecurityAccessEntry entry) throws ParentEntryEvictedException, ConflictingInsertionException {
        internalAdd(entry, null);
    }
    
    public void add(SecurityAccessEntry entry, SecurityReference wiki) throws ParentEntryEvictedException, ConflictingInsertionException {
        internalAdd(entry, wiki);
    }
    
    private void internalAdd(SecurityAccessEntry entry, SecurityReference wiki) throws ParentEntryEvictedException, ConflictingInsertionException {
        String key = getEntryKey(entry);
        writeLock.lock();
        try {
            if (isAlreadyInserted(key, entry)) {
                return;
            }
            
            addEntry(key, new SecurityCacheEntry(entry, wiki));
            logger.debug("Added access entry [{}] into the cache.", key);
        }
         finally {
            newEntry = null;
            writeLock.unlock();
        }
        
    }
    
    SecurityEntry get(String entryKey) {
        SecurityCacheEntry entry = cache.get(entryKey);
        return (entry != null) ? entry.getEntry() : null;
    }
    
    public SecurityAccessEntry get(UserSecurityReference user, SecurityReference entity) {
        SecurityCacheEntry entry = getEntry(user, entity);
        if (entry == null) {
            if (logger.isDebugEnabled()) {
                logger.debug("Miss read access entry for [{}].", getEntryKey(user, entity));
            }
            
            return null;
        }
        
        if (logger.isDebugEnabled()) {
            logger.debug("Success read access entry for [{}].", getEntryKey(user, entity));
        }
        
        return (SecurityAccessEntry) entry.getEntry();
    }
    
    public SecurityRuleEntry get(SecurityReference entity) {
        SecurityCacheEntry entry = getEntry(entity);
        if (entry == null) {
            if (logger.isDebugEnabled()) {
                logger.debug("Miss read rule entry for [{}].", getEntryKey(entity));
            }
            
            return null;
        }
        
        if (logger.isDebugEnabled()) {
            logger.debug("Success read rule entry for [{}].", getEntryKey(entity));
        }
        
        return (SecurityRuleEntry) entry.getEntry();
    }
    
    public void remove(UserSecurityReference user, SecurityReference entity) {
        this.invalidationWriteLock.lock();
        try {
            writeLock.lock();
            try {
                SecurityCacheEntry entry = getEntry(user, entity);
                if (entry != null) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Remove outdated access entry for [{}].", getEntryKey(user, entity));
                    }
                    
                    this.cache.remove(entry.getKey());
                }
                
            }
             finally {
                writeLock.unlock();
            }
            
        }
         finally {
            this.invalidationWriteLock.unlock();
        }
        
    }
    
    public void remove(SecurityReference entity) {
        this.invalidationWriteLock.lock();
        try {
            writeLock.lock();
            try {
                SecurityCacheEntry entry = getEntry(entity);
                if (entry != null) {
                    if (logger.isDebugEnabled()) {
                        logger.debug("Remove outdated rule entry for [{}].", getEntryKey(entity));
                    }
                    
                    this.cache.remove(entry.getKey());
                }
                
            }
             finally {
                writeLock.unlock();
            }
            
        }
         finally {
            this.invalidationWriteLock.unlock();
        }
        
    }
    
    public Collection<GroupSecurityReference> getImmediateGroupsFor(UserSecurityReference user) {
        Collection<GroupSecurityReference> groups = new HashSet<>();
        SecurityCacheEntry userEntry = getEntry(user);
        if (userEntry == null || !userEntry.isUser()) {
            return null;
        }
        
        for (SecurityCacheEntry parent : userEntry.parents) {
            SecurityReference parentRef = parent.getEntry().getReference();
            if (parentRef instanceof GroupSecurityReference) {
                groups.add((GroupSecurityReference) parentRef);
            }
            
        }
        
        return groups;
    }
    
    public Collection<GroupSecurityReference> getGroupsFor(UserSecurityReference user, SecurityReference entityWiki) {
        Collection<GroupSecurityReference> groups = new HashSet<>();
        SecurityCacheEntry userEntry = (entityWiki != null) ? getShadowEntry(user, entityWiki) : getEntry(user);
        if (userEntry == null || !userEntry.isUser()) {
            return null;
        }
        
        Deque<SecurityCacheEntry> entriesToExplore = new ArrayDeque<>();
        if (entityWiki != null) {
            addParentsWhenEntryIsShadow(userEntry, user, groups, entriesToExplore);
        }
         else {
            entriesToExplore.add(userEntry);
        }
        
        while (!entriesToExplore.isEmpty()) {
            SecurityCacheEntry entry = entriesToExplore.pop();
            addParentsToTheListOfEntriesToExplore(entry.parents, groups, entriesToExplore);
            if (entityWiki != null) {
                GroupSecurityReference entryRef = (GroupSecurityReference) entry.getEntry().getReference();
                if (entryRef.isGlobal()) {
                    SecurityCacheEntry shadow = getShadowEntry(entryRef, entityWiki);
                    if (shadow != null) {
                        addParentsToTheListOfEntriesToExplore(shadow.parents, groups, entriesToExplore, entry);
                    }
                    
                }
                
            }
            
        }
        
        return groups;
    }
    
    private void addParentsWhenEntryIsShadow(SecurityCacheEntry shadow, UserSecurityReference user, Collection<GroupSecurityReference> groups, Deque<SecurityCacheEntry> entriesToExplore) {
        SecurityCacheEntry originalEntry = getEntry(user);
        addParentsToTheListOfEntriesToExplore(originalEntry.parents, groups, entriesToExplore);
        addParentsToTheListOfEntriesToExplore(shadow.parents, groups, entriesToExplore, originalEntry);
    }
    
    private void addParentsToTheListOfEntriesToExplore(Collection<SecurityCacheEntry> parents, Collection<GroupSecurityReference> groups, Deque<SecurityCacheEntry> entriesToExplore) {
        addParentsToTheListOfEntriesToExplore(parents, groups, entriesToExplore, null);
    }
    
    private void addParentsToTheListOfEntriesToExplore(Collection<SecurityCacheEntry> parents, Collection<GroupSecurityReference> groups, Deque<SecurityCacheEntry> entriesToExplore, SecurityCacheEntry originalEntry) {
        if (parents == null) {
            return;
        }
        
        for (SecurityCacheEntry parent : parents) {
            if (originalEntry != null && parent == originalEntry) {
                continue;
            }
            
            SecurityReference parentRef = parent.getEntry().getReference();
            if (parentRef instanceof GroupSecurityReference && groups.add((GroupSecurityReference) parentRef)) {
                entriesToExplore.add(parent);
            }
            
        }
        
    }
    
    public void suspendInvalidation() {
        this.invalidationReadLock.lock();
    }
    
    public void resumeInvalidation() {
        this.invalidationReadLock.unlock();
    }
    
}


