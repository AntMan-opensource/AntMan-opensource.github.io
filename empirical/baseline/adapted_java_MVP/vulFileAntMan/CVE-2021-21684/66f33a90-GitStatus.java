package hudson.plugins.git;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import hudson.Extension;
import hudson.ExtensionPoint;
import hudson.Util;
import hudson.model.*;
import hudson.plugins.git.extensions.impl.IgnoreNotifyCommit;
import hudson.scm.SCM;
import hudson.security.ACL;
import hudson.security.ACLContext;
import hudson.triggers.SCMTrigger;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URISyntaxException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
import static javax.servlet.http.HttpServletResponse.SC_OK;
import jenkins.model.Jenkins;
import jenkins.scm.api.SCMEvent;
import jenkins.triggers.SCMTriggerItem;
import org.apache.commons.lang.StringUtils;
import static org.apache.commons.lang.StringUtils.isNotEmpty;
import org.eclipse.jgit.transport.RemoteConfig;
import org.eclipse.jgit.transport.URIish;
import org.kohsuke.stapler.*;
public class GitStatus implements UnprotectedRootAction {
    public String getDisplayName() {
        return "Git";
    }
    
    public String getIconFileName() {
        return null;
    }
    
    public String getUrlName() {
        return "git";
    }
    
    static void setAllowNotifyCommitParameters(boolean allowed) {
        allowNotifyCommitParameters = allowed;
    }
    
    private String lastURL = "";        
    private String lastBranches = null; 
    private String lastSHA1 = null;     
    private List<ParameterValue> lastBuildParameters = null;
    private static List<ParameterValue> lastStaticBuildParameters = null;
    private static void clearLastStaticBuildParameters() {
        lastStaticBuildParameters = null;
    }
    
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append("URL: ");
        s.append(lastURL);
        if (lastSHA1 != null) {
            s.append(" SHA1: ");
            s.append(lastSHA1);
        }
        
        if (lastBranches != null) {
            s.append(" Branches: ");
            s.append(lastBranches);
        }
        
        if (lastBuildParameters != null && !lastBuildParameters.isEmpty()) {
            s.append(" Parameters: ");
            for (ParameterValue buildParameter : lastBuildParameters) {
                s.append(buildParameter.getName());
                s.append("='");
                s.append(buildParameter.getValue());
                s.append("',");
            }
            
            s.delete(s.length() - 1, s.length());
        }
        
        if (lastStaticBuildParameters != null && !lastStaticBuildParameters.isEmpty()) {
            s.append(" More parameters: ");
            for (ParameterValue buildParameter : lastStaticBuildParameters) {
                s.append(buildParameter.getName());
                s.append("='");
                s.append(buildParameter.getValue());
                s.append("',");
            }
            
            s.delete(s.length() - 1, s.length());
        }
        
        return s.toString();
    }
    
    public HttpResponse doNotifyCommit(HttpServletRequest request, @QueryParameter(required=true) String url, @QueryParameter(required=false) String branches, @QueryParameter(required=false) String sha1) throws ServletException, IOException {
        lastURL = url;
        lastBranches = branches;
        lastSHA1 = sha1;
        lastBuildParameters = null;
        GitStatus.clearLastStaticBuildParameters();
        URIish uri;
        List<ParameterValue> buildParameters = new ArrayList<>();
        try {
            uri = new URIish(url);
        }
         catch (URISyntaxException e) {
            return HttpResponses.error(SC_BAD_REQUEST, new Exception("Illegal URL: " + url, e));
        }
        
        if (allowNotifyCommitParameters || !safeParameters.isEmpty()) { 
            final Map<String, String[]> parameterMap = request.getParameterMap();
            for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
                if (!(entry.getKey().equals("url")) && !(entry.getKey().equals("branches")) && !(entry.getKey().equals("sha1"))){
                    if (entry.getValue()[0] != null && (allowNotifyCommitParameters || safeParameters.contains(entry.getKey()))){
                        buildParameters.add(new StringParameterValue(entry.getKey(), entry.getValue()[0]));
}
}
            }
            
        }
        
        lastBuildParameters = buildParameters;
        branches = Util.fixEmptyAndTrim(branches);
        String[] branchesArray;
        if (branches == null) {
            branchesArray = new String[0];
        }
         else {
            branchesArray = branches.split(",");
        }
        
        final List<ResponseContributor> contributors = new ArrayList<>();
        Jenkins jenkins = Jenkins.get();
        String origin = SCMEvent.originOf(request);
        for (Listener listener : jenkins.getExtensionList(Listener.class)) {
            contributors.addAll(listener.onNotifyCommit(origin, uri, sha1, buildParameters, branchesArray));
        }
        
        return (StaplerRequest req, StaplerResponse rsp, Object node) -> {
            rsp.setStatus(SC_OK);
            rsp.setContentType("text/plain");
            for (int i = 0; i < contributors.size(); i++) {
                if (i == MAX_REPORTED_CONTRIBUTORS) {
                    rsp.addHeader("Triggered", "<" + (contributors.size() - i) + " more>");
                    break;
                }
                 else {
                    contributors.get(i).addHeaders(req, rsp);
                }
                
            }
            
            PrintWriter w = rsp.getWriter();
            for (ResponseContributor c : contributors) {
                c.writeBody(req, rsp, w);
            }
            
        };
    }
    
    public static boolean looselyMatches(URIish lhs, URIish rhs) {
        return StringUtils.equals(lhs.getHost(),rhs.getHost()) && StringUtils.equals(normalizePath(lhs.getPath()), normalizePath(rhs.getPath()));
    }
    
    private static String normalizePath(String path) {
        if (path.startsWith("/"))   path=path.substring(1);
        if (path.endsWith("/"))     path=path.substring(0,path.length()-1);
        if (path.endsWith(".git"))  path=path.substring(0,path.length()-4);
        return path;
    }
    
    public static class ResponseContributor {
        public void addHeaders(StaplerRequest req, StaplerResponse rsp) {
        }
        
        public void writeBody(StaplerRequest req, StaplerResponse rsp, PrintWriter w) {
            writeBody(w);
        }
        
        public void writeBody(PrintWriter w) {
        }
        
    }
    
    public static abstract class Listener implements ExtensionPoint {
        public List<ResponseContributor> onNotifyCommit(URIish uri, String[] branches) {
            throw new AbstractMethodError();
        }
        
        public List<ResponseContributor> onNotifyCommit(URIish uri, @Nullable String sha1, String... branches) {
            return onNotifyCommit(uri, branches);
        }
        
        public List<ResponseContributor> onNotifyCommit(URIish uri, @Nullable String sha1, List<ParameterValue> buildParameters, String... branches) {
            return onNotifyCommit(uri, sha1, branches);
        }
        
        public List<ResponseContributor> onNotifyCommit(@CheckForNull String origin, URIish uri, @Nullable String sha1, List<ParameterValue> buildParameters, String... branches) {
            return onNotifyCommit(uri, sha1, buildParameters, branches);
        }
        
    }
    
    public static class JenkinsAbstractProjectListener extends Listener {
        public List<ResponseContributor> onNotifyCommit(String origin, URIish uri, String sha1, List<ParameterValue> buildParameters, String... branches) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "Received notification from {0} for uri = {1} ; sha1 = {2} ; branches = {3}", new Object[]{StringUtils.defaultIfBlank(origin, "?"), uri, sha1, Arrays.toString(branches)});
            }
            
            GitStatus.clearLastStaticBuildParameters();
            List<ParameterValue> allBuildParameters = new ArrayList<>(buildParameters);
            List<ResponseContributor> result = new ArrayList<>();
            try (ACLContext ctx = ACL.as(ACL.SYSTEM)) {
                boolean scmFound = false, urlFound = false;
                Jenkins jenkins = Jenkins.getInstanceOrNull();
                if (jenkins == null) {
                    LOGGER.severe("Jenkins.getInstance() is null in GitStatus.onNotifyCommit");
                    return result;
                }
                
                for (final Item project : jenkins.getAllItems()) {
                    SCMTriggerItem scmTriggerItem = SCMTriggerItem.SCMTriggerItems.asSCMTriggerItem(project);
                    if (scmTriggerItem == null) {
                        continue;
                    }
                    
                    SCMS: for (SCM scm : scmTriggerItem.getSCMs()) {
                        if (!(scm instanceof GitSCM)) {
                            continue;
                        }
                        
                        GitSCM git = (GitSCM) scm;
                        scmFound = true;
                        for (RemoteConfig repository : git.getRepositories()) {
                            boolean repositoryMatches = false, branchMatches = false;
                            URIish matchedURL = null;
                            for (URIish remoteURL : repository.getURIs()) {
                                if (looselyMatches(uri, remoteURL)) {
                                    repositoryMatches = true;
                                    matchedURL = remoteURL;
                                    break;
                                }
                                
                            }
                            
                            if (!repositoryMatches || git.getExtensions().get(IgnoreNotifyCommit.class)!=null) {
                                continue;
                            }
                            
                            SCMTrigger trigger = scmTriggerItem.getSCMTrigger();
                            if (trigger == null || trigger.isIgnorePostCommitHooks()) {
                                LOGGER.log(Level.INFO, "no trigger, or post-commit hooks disabled, on {0}", project.getFullDisplayName());
                                continue;
                            }
                            
                            boolean branchFound = false, parametrizedBranchSpec = false;
                            if (branches.length == 0) {
                                branchFound = true;
                            }
                             else {
                                OUT: for (BranchSpec branchSpec : git.getBranches()) {
                                    if (branchSpec.getName().contains("$")) {
                                        if (LOGGER.isLoggable(Level.FINE)) {
                                            LOGGER.log(Level.FINE, "Branch Spec is parametrized for {0}", project.getFullDisplayName());
                                        }
                                        
                                        branchFound = true;
                                        parametrizedBranchSpec = true;
                                    }
                                     else {
                                        for (String branch : branches) {
                                            if (branchSpec.matchesRepositoryBranch(repository.getName(), branch)) {
                                                if (LOGGER.isLoggable(Level.FINE)) {
                                                    LOGGER.log(Level.FINE, "Branch Spec {0} matches modified branch {1} for {2}", new Object[]{branchSpec, branch, project.getFullDisplayName()});
                                                }
                                                
                                                branchFound = true;
                                                break OUT;
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                }
                                
                            }
                            
                            if (!branchFound) continue;
                            urlFound = true;
                            if (!(project instanceof AbstractProject && ((AbstractProject) project).isDisabled())) {
                                if (project instanceof Job) {
                                    Set<String> buildParametersNames = new HashSet<>();
                                    if (allowNotifyCommitParameters || !safeParameters.isEmpty()) {
                                        for (ParameterValue parameterValue: allBuildParameters) {
                                            if (allowNotifyCommitParameters || safeParameters.contains(parameterValue.getName())) {
                                                buildParametersNames.add(parameterValue.getName());
                                            }
                                            
                                        }
                                        
                                    }
                                    
                                    List<ParameterValue> jobParametersValues = getDefaultParametersValues((Job) project);
                                    for (ParameterValue defaultParameterValue : jobParametersValues) {
                                        if (!buildParametersNames.contains(defaultParameterValue.getName())) {
                                            allBuildParameters.add(defaultParameterValue);
                                        }
                                        
                                    }
                                    
                                }
                                
                                if (!parametrizedBranchSpec && isNotEmpty(sha1)) {
                                    LOGGER.log(Level.INFO, "Scheduling {0} to build commit {1}", new Object[]{project.getFullDisplayName(), sha1});
                                    scmTriggerItem.scheduleBuild2(scmTriggerItem.getQuietPeriod(), new CauseAction(new CommitHookCause(sha1)), new RevisionParameterAction(sha1, matchedURL), new ParametersAction(allBuildParameters));
                                    result.add(new ScheduledResponseContributor(project));
                                }
                                 else {
                                    LOGGER.log(Level.INFO, "Triggering the polling of {0}", project.getFullDisplayName());
                                    trigger.run();
                                    result.add(new PollingScheduledResponseContributor(project));
                                    break SCMS; 
                                }
                                
                            }
                            
                            break;
                        }
                        
                    }
                    
                }
                
                if (!scmFound) {
                    result.add(new MessageResponseContributor("No git jobs found"));
                }
                 else if (!urlFound) {
                    result.add(new MessageResponseContributor( "No git jobs using repository: " + uri.toString() + " and branches: " + StringUtils .join(branches, ",")));
                }
                
                lastStaticBuildParameters = allBuildParameters;
                return result;
            }
            
        }
        
        private ArrayList<ParameterValue> getDefaultParametersValues(Job<?,?> job) {
            ArrayList<ParameterValue> defValues;
            ParametersDefinitionProperty paramDefProp = job.getProperty(ParametersDefinitionProperty.class);
            if (paramDefProp != null) {
                List <ParameterDefinition> parameterDefinition = paramDefProp.getParameterDefinitions();
                defValues = new ArrayList<>(parameterDefinition.size());
            }
             else {
                defValues = new ArrayList<>();
                return defValues;
            }
            
            for (ParameterDefinition paramDefinition : paramDefProp.getParameterDefinitions()) {
                ParameterValue defaultValue  = paramDefinition.getDefaultParameterValue();
                if (defaultValue != null) {
                    defValues.add(defaultValue);
                }
                
            }
            
            return defValues;
        }
        
        private static class PollingScheduledResponseContributor extends ResponseContributor {
            private final Item project;
            public PollingScheduledResponseContributor(Item project) {
                this.project = project;
            }
            
            public void addHeaders(StaplerRequest req, StaplerResponse rsp) {
                rsp.addHeader("Triggered", project.getAbsoluteUrl());
            }
            
            public void writeBody(PrintWriter w) {
                w.println("Scheduled polling of " + project.getFullDisplayName());
            }
            
        }
        
        private static class ScheduledResponseContributor extends ResponseContributor {
            private final Item project;
            public ScheduledResponseContributor(Item project) {
                this.project = project;
            }
            
            public void addHeaders(StaplerRequest req, StaplerResponse rsp) {
                rsp.addHeader("Triggered", project.getAbsoluteUrl());
            }
            
            public void writeBody(PrintWriter w) {
                w.println("Scheduled " + project.getFullDisplayName());
            }
            
        }
        
    }
    
    public static class MessageResponseContributor extends ResponseContributor {
        private final String msg;
        public MessageResponseContributor(String msg) {
            this.msg = msg;
        }
        
        public void writeBody(PrintWriter w) {
            w.println(msg);
        }
        
    }
    
    public static class CommitHookCause extends Cause {
        public final String sha1;
        public CommitHookCause(String sha1) {
            this.sha1 = sha1;
        }
        
        public String getShortDescription() {
            return "commit notification " + sha1;
        }
        
    }
    
    private static final Logger LOGGER = Logger.getLogger(GitStatus.class.getName());
    private static final int MAX_REPORTED_CONTRIBUTORS = 10;
    public static final boolean ALLOW_NOTIFY_COMMIT_PARAMETERS = Boolean.valueOf(System.getProperty(GitStatus.class.getName() + ".allowNotifyCommitParameters", "false")) || Boolean.valueOf(System.getProperty("hudson.model.ParametersAction.keepUndefinedParameters", "false"));
    private static boolean allowNotifyCommitParameters = ALLOW_NOTIFY_COMMIT_PARAMETERS;
    static void setSafeParametersForTest(String parameters) {
        safeParameters = csvToSet(parameters != null ? parameters : SAFE_PARAMETERS);
    }
    
    private static Set<String> csvToSet(String csvLine) {
        String[] tokens = csvLine.split(",");
        Set<String> set = new HashSet<>(Arrays.asList(tokens));
        return set;
    }
    
    private static String getSafeParameters() {
        String globalSafeParameters = System.getProperty("hudson.model.ParametersAction.safeParameters", "").trim();
        String gitStatusSafeParameters = System.getProperty(GitStatus.class.getName() + ".safeParameters", "").trim();
        if (globalSafeParameters.isEmpty()) {
            return gitStatusSafeParameters;
        }
        
        if (gitStatusSafeParameters.isEmpty()) {
            return globalSafeParameters;
        }
        
        return globalSafeParameters + "," + gitStatusSafeParameters;
    }
    
    public static final String SAFE_PARAMETERS = getSafeParameters();
    private static Set<String> safeParameters = csvToSet(SAFE_PARAMETERS);
}


