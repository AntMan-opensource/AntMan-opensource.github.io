package net.opentsdb.tsd;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.google.common.base.Strings;
import com.google.common.collect.Sets;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.opentsdb.core.Const;
import net.opentsdb.core.DataPoint;
import net.opentsdb.core.DataPoints;
import net.opentsdb.core.Query;
import net.opentsdb.core.TSDB;
import net.opentsdb.core.TSQuery;
import net.opentsdb.graph.Plot;
import net.opentsdb.meta.Annotation;
import net.opentsdb.stats.Histogram;
import net.opentsdb.stats.StatsCollector;
import net.opentsdb.tools.GnuplotInstaller;
import net.opentsdb.utils.DateTime;
import net.opentsdb.utils.JSON;
import com.stumbleupon.async.Callback;
final class GraphHandler implements HttpRpc {
  private static final Logger LOG = LoggerFactory.getLogger(GraphHandler.class);
  private static final boolean IS_WINDOWS = System.getProperty("os.name", "").contains("Windows");
  private static final String RANGE_COMPONENT = "\\\"?-?\\d*\\.?(\\d+)?([eE]-?\\d+)?\\\"?";
  private static Pattern RANGE_VALIDATOR = Pattern.compile( "^\\["+RANGE_COMPONENT+":"+RANGE_COMPONENT+"]$");
  private static Pattern LABEL_VALIDATOR = Pattern.compile("^[a-zA-z0-9 \\-_]+$");
  private static Pattern KEY_VALIDATOR = Pattern.compile( "^out|left|top|center|right|horiz|box|bottom$");
  private static Pattern STYLE_VALIDATOR = Pattern.compile("^linespoint|points|circles|dots$");
  private static Pattern COLOR_VALIDATOR = Pattern.compile("^(x|X)[a-fA-F0-9]{6}$");
  private static Pattern SMOOTH_VALIDATOR = Pattern.compile("^unique|frequency|fnormal|cumulative|cnormal|bins|csplines|acsplines|mcsplines|bezier|sbezier|unwrap|zsort$");
  private static Pattern FORMAT_VALIDATOR = Pattern.compile("^[%0-9.a-zA-Z \\-]+$");
  private static Pattern WXH_VALIDATOR = Pattern.compile("^\\d+x\\d+$");
  private static final AtomicInteger graphs_generated = new AtomicInteger();
  private static final AtomicInteger graphs_diskcache_hit = new AtomicInteger();
  private static final Histogram graphlatency = new Histogram(16000, (short) 2, 100);
  private static final Histogram gnuplotlatency = new Histogram(16000, (short) 2, 100);
  private final ThreadPoolExecutor gnuplot;
  public GraphHandler() {
    final int ncores = Runtime.getRuntime().availableProcessors();
    gnuplot = new ThreadPoolExecutor( ncores, ncores,   300000, MILLISECONDS,         new ArrayBlockingQueue<Runnable>(20 * ncores),   thread_factory);
  }
  
  public void execute(final TSDB tsdb, final HttpQuery query) {
    if (!query.hasQueryStringParam("json") && !query.hasQueryStringParam("png") && !query.hasQueryStringParam("ascii")) {
      String uri = query.request().getUri();
      if (uri.length() < 4) {  
        uri = "/";             
      }
       else {
        uri = "/#" + uri.substring(3);  
      }
      
      query.redirect(uri);
      return;
    }
    
    try {
      doGraph(tsdb, query);
    }
     catch (IOException e) {
      query.internalError(e);
    }
     catch (IllegalArgumentException e) {
      query.badRequest(e.getMessage());
    }
    
  }
  
  private void doGraph(final TSDB tsdb, final HttpQuery query) throws IOException {
    final String basepath = getGnuplotBasePath(tsdb, query);
    long start_time = DateTime.parseDateTimeString( query.getRequiredQueryStringParam("start"), query.getQueryStringParam("tz"));
    final boolean nocache = query.hasQueryStringParam("nocache");
    if (start_time == -1) {
      throw BadRequestException.missingParameter("start");
    }
     else {
      start_time /= 1000;
    }
    
    long end_time = DateTime.parseDateTimeString( query.getQueryStringParam("end"), query.getQueryStringParam("tz"));
    final long now = System.currentTimeMillis() / 1000;
    if (end_time == -1) {
      end_time = now;
    }
     else {
      end_time /= 1000;
    }
    
    final int max_age = computeMaxAge(query, start_time, end_time, now);
    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {
      return;
    }
    
    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);
    tsquery.validateAndSetQuery();
    Query[] tsdbqueries = tsquery.buildQueries(tsdb);
    List<String> options = null;
    final String options_allow_list = tsdb.getConfig().getString( "tsd.gnuplot.options.allowlist");
    if (!Strings.isNullOrEmpty(options_allow_list)) {
      String[] allow_list_strings = options_allow_list.split(";");
      Set<String> allow_list = Sets.newHashSet();
      for (int i = 0; i < allow_list_strings.length; i++) {
        String allow = allow_list_strings[i];
        if (allow != null) {
          allow = URLDecoder.decode(allow.trim());
          allow_list.add(allow);
        }
        
      }
      
      options = query.getQueryStringParams("o");
      for (int i = 0; i < options.size(); i++) {
        if (!allow_list.contains(options.get(i))) {
          throw new BadRequestException("Query option at index " + i  + " was not in the allow list.");
        }
        
      }
      
    }
    
    if (options == null) {
      options = new ArrayList<String>(tsdbqueries.length);
      for (int i = 0; i < tsdbqueries.length; i++) {
        options.add("");
      }
      
    }
     else if (options.size() != tsdbqueries.length) {
      throw new BadRequestException(options.size() + " `o' parameters, but " + tsdbqueries.length + " `m' parameters.");
    }
    
    for (final Query tsdbquery : tsdbqueries) {
      try {
        tsdbquery.setStartTime(start_time);
      }
       catch (IllegalArgumentException e) {
        throw new BadRequestException("start time: " + e.getMessage());
      }
      
      try {
        tsdbquery.setEndTime(end_time);
      }
       catch (IllegalArgumentException e) {
        throw new BadRequestException("end time: " + e.getMessage());
      }
      
    }
    
    final Plot plot = new Plot(start_time, end_time, DateTime.timezones.get(query.getQueryStringParam("tz")));
    setPlotDimensions(query, plot);
    setPlotParams(query, plot);
    final int nqueries = tsdbqueries.length;
    @SuppressWarnings("unchecked")
    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];
    int npoints = 0;
    for (int i = 0; i < nqueries; i++) {
      try {  
        final DataPoints[] series = tsdbqueries[i].run();
        for (final DataPoints datapoints : series) {
          plot.add(datapoints, options.get(i));
          aggregated_tags[i] = new HashSet<String>();
          aggregated_tags[i].addAll(datapoints.getAggregatedTags());
          npoints += datapoints.aggregatedSize();
        }
        
      }
       catch (RuntimeException e) {
        logInfo(query, "Query failed (stack trace coming): " + tsdbqueries[i]);
        throw e;
      }
      
      tsdbqueries[i] = null;  
    }
    
    tsdbqueries = null;  
    if (query.hasQueryStringParam("ascii")) {
      respondAsciiQuery(query, max_age, basepath, plot);
      return;
    }
    
    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath, aggregated_tags, npoints);
    class ErrorCB implements Callback<Object, Exception> {
      public Object call(final Exception e) throws Exception {
        LOG.warn("Failed to retrieve global annotations: ", e);
        throw e;
      }
      
    }
    
    class GlobalCB implements Callback<Object, List<Annotation>> {
      public Object call(final List<Annotation> global_annotations) throws Exception {
        rungnuplot.plot.setGlobals(global_annotations);
        execGnuplot(rungnuplot, query);
        return null;
      }
      
    }
    
    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {
      Annotation.getGlobalAnnotations(tsdb, start_time, end_time) .addCallback(new GlobalCB()).addErrback(new ErrorCB());
    }
     else {
      execGnuplot(rungnuplot, query);
    }
    
  }
  
  private void execGnuplot(RunGnuplot rungnuplot, HttpQuery query) {
    try {
      gnuplot.execute(rungnuplot);
    }
     catch (RejectedExecutionException e) {
      query.internalError(new Exception("Too many requests pending," + " please try again later", e));
    }
    
  }
  
  private static int computeMaxAge(final HttpQuery query, final long start_time, final long end_time, final long now) {
    if (end_time > now) {                            
      return 0;
    }
     else if (end_time < now - Const.MAX_TIMESPAN    && !DateTime.isRelativeDate( query.getQueryStringParam("start"))     && !DateTime.isRelativeDate( query.getQueryStringParam("end"))) {
      return 86400;
    }
     else {                                         
      return (int) (end_time - start_time) >> 10;
    }
    
  }
  
  private static final class RunGnuplot implements Runnable {
    private final HttpQuery query;
    private final int max_age;
    private final Plot plot;
    private final String basepath;
    private final HashSet<String>[] aggregated_tags;
    private final int npoints;
    public RunGnuplot(final HttpQuery query, final int max_age, final Plot plot, final String basepath, final HashSet<String>[] aggregated_tags, final int npoints) {
      this.query = query;
      this.max_age = max_age;
      this.plot = plot;
      if (IS_WINDOWS){
        this.basepath = basepath.replace("\\", "\\\\").replace("/", "\\\\");
}
      else{
        this.basepath = basepath;
}
      this.aggregated_tags = aggregated_tags;
      this.npoints = npoints;
    }
    
    public void run() {
      try {
        execute();
      }
       catch (BadRequestException e) {
        query.badRequest(e.getMessage());
      }
       catch (GnuplotException e) {
        query.badRequest("<pre>" + e.getMessage() + "</pre>");
      }
       catch (RuntimeException e) {
        query.internalError(e);
      }
       catch (IOException e) {
        query.internalError(e);
      }
      
    }
    
    private void execute() throws IOException {
      final int nplotted = runGnuplot(query, basepath, plot);
      if (query.hasQueryStringParam("json")) {
        final HashMap<String, Object> results = new HashMap<String, Object>();
        results.put("plotted", nplotted);
        results.put("points", npoints);
        if (aggregated_tags != null && aggregated_tags.length > 0 && aggregated_tags[0] == null) {
          aggregated_tags[0] = new HashSet<String>();
        }
        
        results.put("etags", aggregated_tags);
        results.put("timing", query.processingTimeMillis());
        query.sendReply(JSON.serializeToBytes(results));
        writeFile(query, basepath + ".json", JSON.serializeToBytes(results));
      }
       else if (query.hasQueryStringParam("png")) {
        query.sendFile(basepath + ".png", max_age);
      }
       else {
        query.internalError(new Exception("Should never be here!"));
      }
      
      graphlatency.add(query.processingTimeMillis());
      graphs_generated.incrementAndGet();
    }
    
  }
  
  public void shutdown() {
    gnuplot.shutdown();
  }
  
  public static void collectStats(final StatsCollector collector) {
    collector.record("http.latency", graphlatency, "type=graph");
    collector.record("http.latency", gnuplotlatency, "type=gnuplot");
    collector.record("http.graph.requests", graphs_diskcache_hit, "cache=disk");
    collector.record("http.graph.requests", graphs_generated, "cache=miss");
  }
  
  private String getGnuplotBasePath(final TSDB tsdb, final HttpQuery query) {
    final Map<String, List<String>> q = query.getQueryString();
    q.remove("ignore");
    final HashMap<String, List<String>> qs = new HashMap<String, List<String>>(q);
    qs.remove("png");
    qs.remove("json");
    qs.remove("ascii");
    return tsdb.getConfig().getDirectoryName("tsd.http.cachedir") + Integer.toHexString(qs.hashCode());
  }
  
  private boolean isDiskCacheHit(final HttpQuery query, final long end_time, final int max_age, final String basepath) throws IOException {
    final String cachepath = basepath + (query.hasQueryStringParam("ascii") ? ".txt" : ".png");
    final File cachedfile = new File(cachepath);
    if (cachedfile.exists()) {
      final long bytes = cachedfile.length();
      if (bytes < 21) {  
        logWarn(query, "Cached " + cachepath + " is too small (" + bytes + " bytes) to be valid.  Ignoring it.");
        return false;
      }
      
      if (staleCacheFile(query, end_time, max_age, cachedfile)) {
        return false;
      }
      
      if (query.hasQueryStringParam("json")) {
        HashMap<String, Object> map = loadCachedJson(query, end_time, max_age, basepath);
        if (map == null) {
          map = new HashMap<String, Object>();
        }
        
        map.put("timing", query.processingTimeMillis());
        map.put("cachehit", "disk");
        query.sendReply(JSON.serializeToBytes(map));
      }
       else if (query.hasQueryStringParam("png") || query.hasQueryStringParam("ascii")) {
        query.sendFile(cachepath, max_age);
      }
       else {
        query.sendReply(HttpQuery.makePage("TSDB Query", "Your graph is ready", "<img src=\"" + query.request().getUri() + "&amp;png\"/><br/>" + "<small>(served from disk cache)</small>"));
      }
      
      graphs_diskcache_hit.incrementAndGet();
      return true;
    }
    
    final HashMap<String, Object> map = loadCachedJson(query, end_time, max_age, basepath);
    if (map == null || !map.containsKey("plotted") || ((Integer)map.get("plotted")) == 0) {
      return false;
    }
    
    if (query.hasQueryStringParam("json")) {
      map.put("timing", query.processingTimeMillis());
      map.put("cachehit", "disk");
      query.sendReply(JSON.serializeToBytes(map));
    }
     else if (query.hasQueryStringParam("png")) {
      query.sendReply(" ");  
    }
     else {
        query.sendReply(HttpQuery.makePage("TSDB Query", "No results", "Sorry, your query didn't return anything.<br/>" + "<small>(served from disk cache)</small>"));
    }
    
    graphs_diskcache_hit.incrementAndGet();
    return true;
  }
  
  private static boolean staleCacheFile(final HttpQuery query, final long end_time, final long max_age, final File cachedfile) {
    final long mtime = cachedfile.lastModified() / 1000;
    if (mtime <= 0) {
      return true;  
    }
    
    final long now = System.currentTimeMillis() / 1000;
    final long staleness = now - mtime;
    if (staleness < 0) {  
      logWarn(query, "Not using file @ " + cachedfile + " with weird" + " mtime in the future: " + mtime);
      return true;  
    }
    
    if (0 < end_time && end_time < now) {
      return mtime < end_time;
    }
    
    if (staleness > max_age) {
      logInfo(query, "Cached file @ " + cachedfile.getPath() + " is " + staleness + "s stale, which is more than its limit of " + max_age + "s, and needs to be regenerated.");
      return true;
    }
    
    return false;
  }
  
  private static void writeFile(final HttpQuery query, final String path, final byte[] contents) {
    try {
      final FileOutputStream out = new FileOutputStream(path);
      try {
        out.write(contents);
      }
       finally {
        out.close();
      }
      
    }
     catch (FileNotFoundException e) {
      logError(query, "Failed to create file " + path, e);
    }
     catch (IOException e) {
      logError(query, "Failed to write file " + path, e);
    }
    
  }
  
  private static byte[] readFile(final HttpQuery query, final File file, final int max_length) {
    final int length = (int) file.length();
    if (length <= 0) {
      return null;
    }
    
    FileInputStream in;
    try {
      in = new FileInputStream(file.getPath());
    }
     catch (FileNotFoundException e) {
      return null;
    }
    
    try {
      final byte[] buf = new byte[Math.min(length, max_length)];
      final int read = in.read(buf);
      if (read != buf.length) {
        logError(query, "When reading " + file + ": read only " + read + " bytes instead of " + buf.length);
        return null;
      }
      
      return buf;
    }
     catch (IOException e) {
      logError(query, "Error while reading " + file, e);
      return null;
    }
     finally {
      try {
        in.close();
      }
       catch (IOException e) {
        logError(query, "Error while closing " + file, e);
      }
      
    }
    
  }
  
  private HashMap<String, Object> loadCachedJson(final HttpQuery query, final long end_time, final long max_age, final String basepath) throws JsonParseException, JsonMappingException, IOException {
    final String json_path = basepath + ".json";
    File json_cache = new File(json_path);
    if (staleCacheFile(query, end_time, max_age, json_cache)) {
      return null;
    }
    
    final byte[] json = readFile(query, json_cache, 4096);
    if (json == null) {
      return null;
    }
    
    json_cache = null;
    return (HashMap<String, Object>) JSON.parseToObject(json, HashMap.class);
  }
  
  static void setPlotDimensions(final HttpQuery query, final Plot plot) {
    String wxh = query.getQueryStringParam("wxh");
    if (wxh != null && !wxh.isEmpty()) {
      wxh = URLDecoder.decode(wxh.trim());
      if (!WXH_VALIDATOR.matcher(wxh).find()) {
        throw new IllegalArgumentException("'wxh' was invalid. " + "Must satisfy the pattern " + WXH_VALIDATOR.toString());
      }
      
      final int wxhlength = wxh.length();
      if (wxhlength < 7) {  
        throw new BadRequestException("Parameter wxh too short: " + wxh);
      }
      
      final int x = wxh.indexOf('x', 3);  
      if (x < 0) {
        throw new BadRequestException("Invalid wxh parameter: " + wxh);
      }
      
      try {
        final short width = Short.parseShort(wxh.substring(0, x));
        final short height = Short.parseShort(wxh.substring(x + 1, wxhlength));
        try {
          plot.setDimensions(width, height);
        }
         catch (IllegalArgumentException e) {
          throw new BadRequestException("Invalid wxh parameter: " + wxh + ", " + e.getMessage());
        }
        
      }
       catch (NumberFormatException e) {
        throw new BadRequestException("Can't parse wxh '" + wxh + "': " + e.getMessage());
      }
      
    }
    
  }
  
  private static String stringify(final String s) {
    final StringBuilder buf = new StringBuilder(1 + s.length() + 1);
    buf.append('"');
    HttpQuery.escapeJson(s, buf);  
    buf.append('"');
    return buf.toString();
  }
  
  public static String popParam(final Map<String, List<String>> querystring, final String param) {
    final List<String> params = querystring.remove(param);
    if (params == null) {
      return null;
    }
    
    String given = params.get(params.size() - 1);
    if (given != null) {
      given = URLDecoder.decode(given.trim());
    }
    
    if (given.contains("`") || given.contains("%60") ||  given.contains("&#96;")) {
      throw new BadRequestException("Parameter " + param + " contained a " + "back-tick. That's a no-no.");
    }
    
    return given;
  }
  
  static void setPlotParams(final HttpQuery query, final Plot plot) {
    final HashMap<String, String> params = new HashMap<String, String>();
    final Map<String, List<String>> querystring = query.getQueryString();
    String value;
    if ((value = popParam(querystring, "yrange")) != null) {
      if (!RANGE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'yrange' was invalid. " + "Must be in the format [min:max].");
      }
      
      params.put("yrange", value);
    }
    
    if ((value = popParam(querystring, "y2range")) != null) {
      if (!RANGE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'y2range' was invalid. " + "Must be in the format [min:max].");
      }
      
      params.put("y2range", value);
    }
    
    if ((value = popParam(querystring, "ylabel")) != null) {
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'ylabel' was invalid. Must " + "satisfy the pattern " + LABEL_VALIDATOR.toString());
      }
      
      params.put("ylabel", stringify(value));
    }
    
    if ((value = popParam(querystring, "y2label")) != null) {
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'y2label' was invalid. Must " + "satisfy the pattern " + LABEL_VALIDATOR.toString());
      }
      
      params.put("y2label", stringify(value));
    }
    
    if ((value = popParam(querystring, "yformat")) != null) {
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'yformat' was invalid. Must " + "satisfy the pattern " + FORMAT_VALIDATOR.toString());
      }
      
      params.put("format y", stringify(value));
    }
    
    if ((value = popParam(querystring, "y2format")) != null) {
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'y2format' was invalid. Must " + "satisfy the pattern " + FORMAT_VALIDATOR.toString());
      }
      
      params.put("format y2", stringify(value));
    }
    
    if ((value = popParam(querystring, "xformat")) != null) {
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'xformat' was invalid. Must " + "satisfy the pattern " + FORMAT_VALIDATOR.toString());
      }
      
      params.put("format x", stringify(value));
    }
    
    if ((value = popParam(querystring, "ylog")) != null) {
      params.put("logscale y", "");
    }
    
    if ((value = popParam(querystring, "y2log")) != null) {
      params.put("logscale y2", "");
    }
    
    if ((value = popParam(querystring, "key")) != null) {
      if (!KEY_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'key' was invalid. Must " + "satisfy the pattern " + KEY_VALIDATOR.toString());
      }
      
      params.put("key", value);
    }
    
    if ((value = popParam(querystring, "title")) != null) {
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'title' was invalid. Must " + "satisfy the pattern " + LABEL_VALIDATOR.toString());
      }
      
      params.put("title", stringify(value));
    }
    
    if ((value = popParam(querystring, "bgcolor")) != null) {
      if (!COLOR_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'bgcolor' was invalid. Must " + "be a hex value e.g. 'xFFFFFF'");
      }
      
      params.put("bgcolor", value);
    }
    
    if ((value = popParam(querystring, "fgcolor")) != null) {
      if (!COLOR_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'fgcolor' was invalid. Must " + "be a hex value e.g. 'xFFFFFF'");
      }
      
      params.put("fgcolor", value);
    }
    
    if ((value = popParam(querystring, "smooth")) != null) {
      if (!SMOOTH_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'smooth' was invalid. Must " + "satisfy the pattern " + SMOOTH_VALIDATOR.toString());
      }
      
      params.put("smooth", value);
    }
    
    if ((value = popParam(querystring, "style")) != null) {
      if (!STYLE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException("'style' was invalid. Must " + "satisfy the pattern " + STYLE_VALIDATOR.toString());
      }
      
      params.put("style", value);
    }
    
    if ((value = popParam(querystring, "nokey")) != null) {
      params.put("key", null);
    }
    
    plot.setParams(params);
  }
  
  static int runGnuplot(final HttpQuery query, final String basepath, final Plot plot) throws IOException {
    final int nplotted = plot.dumpToFiles(basepath);
    final long start_time = System.nanoTime();
    final Process gnuplot = new ProcessBuilder(GNUPLOT, basepath + ".out", basepath + ".err", basepath + ".gnuplot").start();
    final int rv;
    try {
      rv = gnuplot.waitFor();  
    }
     catch (InterruptedException e) {
      Thread.currentThread().interrupt();  
      throw new IOException("interrupted", e);  
    }
     finally {
      gnuplot.destroy();
    }
    
    gnuplotlatency.add((int) ((System.nanoTime() - start_time) / 1000000));
    if (rv != 0) {
      final byte[] stderr = readFile(query, new File(basepath + ".err"), 4096);
      new File(basepath + ".png").delete();
      if (stderr == null) {
        throw new GnuplotException(rv);
      }
      
      throw new GnuplotException(new String(stderr));
    }
    
    deleteFileIfEmpty(basepath + ".out");
    deleteFileIfEmpty(basepath + ".err");
    return nplotted;
  }
  
  private static void deleteFileIfEmpty(final String path) {
    final File file = new File(path);
    if (file.length() <= 0) {
      file.delete();
    }
    
  }
  
  private static void respondAsciiQuery(final HttpQuery query, final int max_age, final String basepath, final Plot plot) {
    final String path = basepath + ".txt";
    PrintWriter asciifile;
    try {
      asciifile = new PrintWriter(path);
    }
     catch (IOException e) {
      query.internalError(e);
      return;
    }
    
    try {
      final StringBuilder tagbuf = new StringBuilder();
      for (final DataPoints dp : plot.getDataPoints()) {
        final String metric = dp.metricName();
        tagbuf.setLength(0);
        for (final Map.Entry<String, String> tag : dp.getTags().entrySet()) {
          tagbuf.append(' ').append(tag.getKey()) .append('=').append(tag.getValue());
        }
        
        for (final DataPoint d : dp) {
          if (d.isInteger()) {
            printMetricHeader(asciifile, metric, d.timestamp());
            asciifile.print(d.longValue());
          }
           else {
            final double value = d.doubleValue();
            if (Double.isInfinite(value)) {
              throw new IllegalStateException("Infinity:" + value + " d=" + d + ", query=" + query);
            }
             else if (Double.isNaN(value)) {
              continue;
            }
            
            printMetricHeader(asciifile, metric, d.timestamp());
            asciifile.print(value);
          }
          
          asciifile.print(tagbuf);
          asciifile.print('\n');
        }
        
      }
      
    }
     finally {
      asciifile.close();
    }
    
    try {
      query.sendFile(path, max_age);
    }
     catch (IOException e) {
      query.internalError(e);
    }
    
  }
  
  private static void printMetricHeader(final PrintWriter writer, final String metric, final long timestamp) {
    writer.print(metric);
    writer.print(' ');
    writer.print(timestamp / 1000L);
    writer.print(' ');
  }
  
  private static final PlotThdFactory thread_factory = new PlotThdFactory();
  private static final class PlotThdFactory implements ThreadFactory {
    private final AtomicInteger id = new AtomicInteger(0);
    public Thread newThread(final Runnable r) {
      return new Thread(r, "Gnuplot #" + id.incrementAndGet());
    }
    
  }
  
  private static final String WRAPPER = IS_WINDOWS ? "mygnuplot.bat" : "mygnuplot.sh";
  private static final String GNUPLOT;
  static {
    GNUPLOT = findGnuplotHelperScript();
  }
  
  private static String findGnuplotHelperScript() {
    if(!GnuplotInstaller.FOUND_GP) {
      LOG.warn("Skipping Gnuplot Shell Script Install since Gnuplot executable was not found");
      return null;
    }
    
    if(!GnuplotInstaller.GP_FILE.exists()) {
      GnuplotInstaller.installMyGnuPlot();
    }
    
    if(GnuplotInstaller.GP_FILE.exists() && GnuplotInstaller.GP_FILE.canExecute()) {
      LOG.info("Auto Installed Gnuplot Invoker at [{}]", GnuplotInstaller.GP_FILE.getAbsolutePath());
      return GnuplotInstaller.GP_FILE.getAbsolutePath();
    }
    
    final URL url = GraphHandler.class.getClassLoader().getResource(WRAPPER);
    if (url == null) {
      throw new RuntimeException("Couldn't find " + WRAPPER + " on the" + " CLASSPATH: " + System.getProperty("java.class.path"));
    }
    
    final String path = url.getFile();
    LOG.debug("Using Gnuplot wrapper at {}", path);
    final File file = new File(path);
    final String error;
    if (!file.exists()) {
      error = "non-existent";
    }
     else if (!file.canExecute()) {
      error = "non-executable";
    }
     else if (!file.canRead()) {
      error = "unreadable";
    }
     else {
      return path;
    }
    
    throw new RuntimeException("The " + WRAPPER + " found on the" + " CLASSPATH (" + path + ") is a " + error + " file...  WTF?" + "  CLASSPATH=" + System.getProperty("java.class.path"));
  }
  
  static void logInfo(final HttpQuery query, final String msg) {
    LOG.info(query.channel().toString() + ' ' + msg);
  }
  
  static void logWarn(final HttpQuery query, final String msg) {
    LOG.warn(query.channel().toString() + ' ' + msg);
  }
  
  static void logError(final HttpQuery query, final String msg) {
    LOG.error(query.channel().toString() + ' ' + msg);
  }
  
  static void logError(final HttpQuery query, final String msg, final Throwable e) {
    LOG.error(query.channel().toString() + ' ' + msg, e);
  }
  
}


