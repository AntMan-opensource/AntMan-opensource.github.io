package org.kopi.ebics.utils;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.text.ParseException;
import java.util.Date;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.apache.xml.security.c14n.Canonicalizer;
import org.apache.xml.security.utils.IgnoreAllErrorHandler;
import org.apache.xpath.XPathAPI;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.kopi.ebics.exception.EbicsException;
import org.kopi.ebics.messages.Messages;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;
public final class Utils {
  static {
    org.apache.xml.security.Init.init();
  }
  
  public static final SecureRandom secureRandom = new SecureRandom();
  private Utils() {
  }
  
  public static byte[] zip(byte[] toZip) throws EbicsException {
    if (toZip == null) {
      throw new EbicsException("The input to be zipped cannot be null");
    }
    
    Deflater				compressor;
    ByteArrayOutputStream		output;
    byte[]				buffer;
    output = new ByteArrayOutputStream(toZip.length);
    buffer = new byte[1024];
    compressor = new Deflater(Deflater.BEST_COMPRESSION);
    compressor.setInput(toZip);
    compressor.finish();
    while (!compressor.finished()) {
      int count = compressor.deflate(buffer);
      output.write(buffer, 0, count);
    }
    
    try {
      output.close();
    }
     catch (IOException e) {
      throw new EbicsException(e.getMessage());
    }
    
    compressor.end();
    return output.toByteArray();
  }
  
  public static byte[] generateNonce() {
    return secureRandom.generateSeed(16);
  }
  
  public static byte[] generateKey() {
    return secureRandom.generateSeed(16);
  }
  
  public static byte[] unzip(byte[] zip) throws EbicsException {
    Inflater 			decompressor;
    ByteArrayOutputStream 	output;
    byte[] 			buf;
    decompressor = new Inflater();
    output = new ByteArrayOutputStream(zip.length);
    decompressor.setInput(zip);
    buf = new byte[1024];
    while (!decompressor.finished()) {
      int 		count;
      try {
	count = decompressor.inflate(buf);
      }
       catch (DataFormatException e) {
	throw new EbicsException(e.getMessage());
      }
      
      output.write(buf, 0, count);
    }
    
    try {
      output.close();
    }
     catch (IOException e) {
      throw new EbicsException(e.getMessage());
    }
    
    decompressor.end();
    return output.toByteArray();
  }
  
  public static byte[] canonize(byte[] input) throws EbicsException {
    DocumentBuilderFactory 		factory;
    DocumentBuilder			builder;
    Document				document;
    NodeIterator			iter;
    ByteArrayOutputStream		output;
    Node 				node;
    try {
      factory = DocumentBuilderFactory.newInstance();
      factory.setNamespaceAware(true);
      factory.setValidating(true);
      builder = factory.newDocumentBuilder();
      builder.setErrorHandler(new IgnoreAllErrorHandler());
      document = builder.parse(new ByteArrayInputStream(input));
      iter = XPathAPI.selectNodeIterator(document, "//*[@authenticate='true']");
      output = new ByteArrayOutputStream();
      while ((node = iter.nextNode()) != null) {
        Canonicalizer 		canonicalizer;
        canonicalizer = Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);
        output.write(canonicalizer.canonicalizeSubtree(node));
      }
      
      return output.toByteArray();
    }
     catch (Exception e) {
      throw new EbicsException(e.getMessage());
    }
    
  }
  
  public static byte[] encrypt(byte[] input, SecretKeySpec keySpec) throws EbicsException {
    return encryptOrDecrypt(Cipher.ENCRYPT_MODE, input, keySpec);
  }
  
  public static byte[] decrypt(byte[] input, SecretKeySpec keySpec) throws EbicsException {
    return encryptOrDecrypt(Cipher.DECRYPT_MODE, input, keySpec);
  }
  
  private static byte[] encryptOrDecrypt(int mode, byte[] input, SecretKeySpec keySpec) throws EbicsException {
    IvParameterSpec		iv;
    Cipher 			cipher;
    iv = new IvParameterSpec(new byte[16]);
    try {
      cipher = Cipher.getInstance("AES/CBC/ISO10126Padding", BouncyCastleProvider.PROVIDER_NAME);
      cipher.init(mode, keySpec, iv);
      return cipher.doFinal(input);
    }
     catch (GeneralSecurityException e) {
      throw new EbicsException(e.getMessage());
    }
    
  }
  
  public static Date parse(String date) throws EbicsException {
    try {
      return Constants.DEFAULT_DATE_FORMAT.parse(date);
    }
     catch (ParseException e) {
      throw new EbicsException(e.getMessage());
    }
    
  }
  
  public static void checkHttpCode(int httpCode) throws EbicsException {
    if (httpCode != 200) {
      Messages messages = new Messages(Constants.APPLICATION_BUNDLE_NAME);
      throw new EbicsException(messages.getString("http.code.error", httpCode));
    }
    
  }
  
}


