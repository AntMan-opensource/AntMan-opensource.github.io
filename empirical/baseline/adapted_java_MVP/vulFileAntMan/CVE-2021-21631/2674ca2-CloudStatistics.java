package org.jenkinsci.plugins.cloudstats;
import com.google.common.annotations.VisibleForTesting;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import hudson.BulkChange;
import hudson.Extension;
import hudson.FilePath;
import hudson.XmlFile;
import hudson.model.Computer;
import hudson.model.Label;
import hudson.model.ManagementLink;
import hudson.model.Node;
import hudson.model.PeriodicWork;
import hudson.model.Saveable;
import hudson.model.TaskListener;
import hudson.plugins.extendedread.SystemReadPermission;
import hudson.security.Permission;
import hudson.slaves.AbstractCloudComputer;
import hudson.slaves.Cloud;
import hudson.slaves.CloudProvisioningListener;
import hudson.slaves.ComputerListener;
import hudson.slaves.NodeProvisioner;
import jenkins.model.Jenkins;
import jenkins.model.NodeListener;
import jenkins.util.Timer;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.DoNotUse;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.concurrent.GuardedBy;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
public class CloudStatistics extends ManagementLink implements Saveable {
    private static final Logger LOGGER = Logger.getLogger(CloudStatistics.class.getName());
     static final String ARCHIVE_RECORDS_PROPERTY_NAME = "org.jenkinsci.plugins.cloudstats.CloudStatistics.ARCHIVE_RECORDS";
    @SuppressFBWarnings(value = "MS_SHOULD_BE_FINAL", justification = "Not final for testing")
    public static  int ARCHIVE_RECORDS = Integer.getInteger(ARCHIVE_RECORDS_PROPERTY_NAME, 100);
    private  @Nonnull Collection<ProvisioningActivity> active = new CopyOnWriteArrayList<>();
    private  @Nonnull CyclicThreadSafeCollection<ProvisioningActivity> log = new CyclicThreadSafeCollection<>(ARCHIVE_RECORDS);
    public static @Nonnull CloudStatistics get() {
        return Jenkins.getInstance().getExtensionList(CloudStatistics.class).get(0);
    }
    
    public CloudStatistics() {
        try {
            load();
        }
         catch (IOException e) {
            LOGGER.log(Level.WARNING, "Unable to load stored statistics", e);
        }
        
        for (ProvisioningActivity activity : getActivities()) {
            if (activity.getCurrentPhase() == ProvisioningActivity.Phase.PROVISIONING) {
                PhaseExecutionAttachment attachment = new PhaseExecutionAttachment( ProvisioningActivity.Status.OK, "Provisioning interrupted by restart" );
                activity.enter(ProvisioningActivity.Phase.COMPLETED);
                attach(activity, ProvisioningActivity.Phase.COMPLETED, attachment);
                archive(activity);
                LOGGER.info("Closing dangling provisioning activity " + activity);
            }
            
        }
        
    }
    
    public String getDisplayName() {
        return "Cloud Statistics";
    }
    
    public String getIconFileName() {
        Jenkins jenkins = Jenkins.get();
        if (!jenkins.hasPermission(getRequiredPermission())) return null;
        if (jenkins.clouds.isEmpty() && isEmpty()) return null;
        return "graph.png";
    }
    
    public @Nonnull Permission getRequiredPermission() {
        return SystemReadPermission.SYSTEM_READ;
    }
    
    private boolean isEmpty() {
        synchronized (active) {
            return log.isEmpty() && active.isEmpty();
        }
        
    }
    
    public @Nonnull Collection<ProvisioningActivity> getNotCompletedActivities() {
        ArrayList<ProvisioningActivity> activeCopy;
        synchronized (active) {
            activeCopy = new ArrayList<>(active);
        }
        
        ArrayList<ProvisioningActivity> ret = new ArrayList<>(activeCopy.size());
        for (ProvisioningActivity activity : activeCopy) {
            if (activity.getCurrentPhase() != ProvisioningActivity.Phase.COMPLETED) {
                ret.add(activity);
            }
            
        }
        
        return ret;
    }
    
     @Nonnull Collection<ProvisioningActivity> getRetainedActivities() { synchronized (active) { return new ArrayList<>(active); }
    }
    
    public String getUrlName() {
        return "cloud-stats";
    }
    
    public String getDescription() {
        return "Report of current and past provisioning activities";
    }
    
    public String getCategoryName() {
        return "STATUS";
    }
    
    public List<ProvisioningActivity> getActivities() {
        synchronized (active) {
            ArrayList<ProvisioningActivity> out = new ArrayList<>(active.size() + log.size());
            out.addAll(log.toList());
            out.addAll(active);
            return out;
        }
        
    }
    
    public @CheckForNull ProvisioningActivity getPotentiallyCompletedActivityFor(ProvisioningActivity.Id id) {
        if (id == null) return null;
        for (ProvisioningActivity activity : getActivities()) {
            if (activity.isFor(id)) {
                return activity;
            }
            
        }
        
        return null;
    }
    
    public @CheckForNull ProvisioningActivity getActivityFor(ProvisioningActivity.Id id) {
        ProvisioningActivity activity = getPotentiallyCompletedActivityFor(id);
        if (activity != null) return activity;
        LOGGER.log(Level.WARNING, "No activity tracked for " + id, new IllegalStateException());
        return null;
    }
    
    public @CheckForNull ProvisioningActivity getActivityFor(TrackedItem item) {
        ProvisioningActivity.Id id = item.getId();
        if (id == null) return null;
        return getActivityFor(id);
    }
    
    public ActivityIndex getIndex() {
        return new ActivityIndex(getActivities());
    }
    
    public ProvisioningActivity getActivity(@Nonnull String hashString) {
        int hash;
        try {
            hash = Integer.parseInt(hashString);
        }
         catch (NumberFormatException nan) {
            return null;
        }
        
        for (ProvisioningActivity activity : getActivities()) {
            if (activity.getId().getFingerprint() == hash) {
                return activity;
            }
            
        }
        
        return null;
    }
    
    public @CheckForNull String getUrl( @Nonnull ProvisioningActivity activity, @Nonnull PhaseExecution phaseExecution, @Nonnull PhaseExecutionAttachment attachment ) {
        activity.getClass(); phaseExecution.getClass(); attachment.getClass();
        if (attachment.getUrlName() == null) return null;
        StringBuilder url = new StringBuilder("/cloud-stats/");
        url.append("activity/").append(activity.getId().getFingerprint()).append('/');
        url.append("phase/").append(phaseExecution.getPhase().toString()).append('/');
        url.append(phaseExecution.getUrlName(attachment)).append('/');
        return url.toString();
    }
    
    public void attach(@Nonnull ProvisioningActivity activity, @Nonnull ProvisioningActivity.Phase phase, @Nonnull PhaseExecutionAttachment attachment) {
        activity.attach(phase, attachment);
        if (attachment.getStatus() == ProvisioningActivity.Status.FAIL) {
            boolean entered = activity.enterIfNotAlready(ProvisioningActivity.Phase.COMPLETED);
            if (entered) {
                archive(activity);
            }
            
        }
        
        persist();
    }
    
    public void save() throws IOException {
        if (BulkChange.contains(this)) return;
        getConfigFile().write(this);
    }
    
     void persist() {
        try {
            save();
        }
         catch (IOException e) {
            LOGGER.log(Level.WARNING, "Unable to store cloud statistics", e);
        }
        
    }
    
    private void load() throws IOException {
        final XmlFile file = getConfigFile();
        if (file.exists()) {
            file.unmarshal(this);
        }
        
        boolean changed = false;
        synchronized (active) {
            if (active.isEmpty()) {
                List<ProvisioningActivity> toSort = log.toList();
                log.clear();
                for (ProvisioningActivity activity: toSort) {
                    assert activity != null;
                    if (activity.getPhaseExecution(ProvisioningActivity.Phase.COMPLETED) == null) {
                        active.add(activity);
                        changed = true;
                    }
                     else {
                        log.add(activity);
                    }
                    
                }
                
            }
            
        }
        
        synchronized (active) {
            Collection<ProvisioningActivity> defensiveCopyOfActiveField = getRetainedActivities();
            for (ProvisioningActivity pa: defensiveCopyOfActiveField) {
                if (pa.getCurrentPhase() == ProvisioningActivity.Phase.COMPLETED) {
                    active.remove(pa);
                    log.add(pa);
                    changed = true;
                }
                
            }
            
        }
        
        if (changed) {
            persist();
        }
        
    }
    
    private Object readResolve() {
        if (!(active instanceof CopyOnWriteArrayList)) {
            Collection<ProvisioningActivity> a = active;
            active = new CopyOnWriteArrayList<>();
            active.addAll(a);
        }
        
        try {
            log.size();
        }
         catch (NullPointerException npe) {
            String msg = "Failed to properly deserialize cloud-stats records: ";
            log = new CyclicThreadSafeCollection<>(ARCHIVE_RECORDS);
            FilePath configFile = new FilePath(getConfigFile().getFile());
            try {
                if (configFile.exists()) {
                    FilePath target = new FilePath(new File(configFile.getRemote() + ".bak-JENKINS-44929"));
                    configFile.renameTo(target);
                    LOGGER.warning(msg + " Please file a bug report attaching " + target.getRemote());
                }
                 else {
                    LOGGER.warning(msg + " " + configFile.getRemote() + " not found");
                }
                
            }
             catch (IOException | InterruptedException ex) {
                LOGGER.log(Level.SEVERE, msg + " Unable to capture the old config.", ex);
            }
            
        }
        
        if (ARCHIVE_RECORDS != log.capacity()) {
            CyclicThreadSafeCollection<ProvisioningActivity> existing = log;
            log = new CyclicThreadSafeCollection<>(ARCHIVE_RECORDS);
            int added = 0;
            for (ProvisioningActivity pa : existing) {
                if (added > ARCHIVE_RECORDS) break; 
                log.add(pa);
                added++;
            }
            
        }
        
        return this;
    }
    
     XmlFile getConfigFile() {
        return new XmlFile(Jenkins.XSTREAM, new File(new File( Jenkins.getInstance().root, getClass().getCanonicalName() + ".xml" ).getAbsolutePath()));
    }
    
    private void archive(ProvisioningActivity activity) {
        synchronized (active) {
            log.add(activity);
            active.remove(activity);
        }
        
    }
    
    public static class ProvisioningListener extends CloudProvisioningListener {
        private final CloudStatistics stats = CloudStatistics.get();
        public void onStarted(Cloud cloud, Label label, Collection<NodeProvisioner.PlannedNode> plannedNodes) {
            BulkChange change = new BulkChange(stats);
            try {
                boolean changed = false;
                for (NodeProvisioner.PlannedNode plannedNode : plannedNodes) {
                    ProvisioningActivity.Id id = getIdFor(plannedNode);
                    if (id != null) {
                        onStarted(id);
                        changed = true;
                    }
                    
                }
                
                if (changed) {
                    stats.persist();
                }
                
            }
             finally {
                change.abort();
            }
            
        }
        
        public @Nonnull ProvisioningActivity onStarted(@Nonnull ProvisioningActivity.Id id) {
            ProvisioningActivity activity = new ProvisioningActivity(id);
            synchronized (stats.active) {
                stats.active.add(activity);
            }
            
            stats.persist();
            return activity;
        }
        
        public void onComplete(NodeProvisioner.PlannedNode plannedNode, Node node) {
            ProvisioningActivity.Id id = getIdFor(plannedNode);
            if (id != null) {
                Timer.get().schedule(() -> { 
                    onComplete(id, node);
                }, 0, TimeUnit.SECONDS);
            }
            
        }
        
        public @CheckForNull ProvisioningActivity onComplete(@Nonnull ProvisioningActivity.Id id, @Nonnull Node node) {
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity != null) {
                activity.rename(node.getDisplayName());
                stats.persist();
            }
            
            return activity;
        }
        
        public void onFailure(NodeProvisioner.PlannedNode plannedNode, Throwable t) {
            ProvisioningActivity.Id id = getIdFor(plannedNode);
            if (id != null) {
                Timer.get().schedule(() -> { 
                    onFailure(id, t);
                }, 0, TimeUnit.SECONDS);
            }
            
        }
        
        public @CheckForNull ProvisioningActivity onFailure(@Nonnull ProvisioningActivity.Id id, @Nonnull Throwable throwable) {
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity != null) {
                stats.attach(activity, ProvisioningActivity.Phase.PROVISIONING, new PhaseExecutionAttachment.ExceptionAttachment( ProvisioningActivity.Status.FAIL, throwable ));
            }
            
            return activity;
        }
        
        public static ProvisioningListener get() {
            return Jenkins.getInstance().getExtensionList(ProvisioningListener.class).get(0);
        }
        
    }
    
    @Extension @Restricted(NoExternalUse.class)
    public static class OperationListener extends ComputerListener {
        private final CloudStatistics stats = CloudStatistics.get();
        public void preLaunch(Computer c, TaskListener taskListener) {
            ProvisioningActivity.Id id = getIdFor(c);
            if (id == null) return;
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity == null) return;
            boolean entered = activity.enterIfNotAlready(ProvisioningActivity.Phase.LAUNCHING);
            if (entered) {
                stats.persist();
            }
            
        }
        
        public void onLaunchFailure(Computer c, TaskListener taskListener) {
            ProvisioningActivity.Id id = getIdFor(c);
            if (id == null) return;
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity == null) return;
        }
        
        public void onOnline(Computer c, TaskListener listener) {
            ProvisioningActivity.Id id = getIdFor(c);
            if (id == null) return;
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity == null) return;
            boolean entered = activity.enterIfNotAlready(ProvisioningActivity.Phase.OPERATING);
            if (entered) {
                stats.persist();
            }
            
        }
        
    }
    
    @Restricted(NoExternalUse.class) @Extension public static class DanglingSlaveScavenger extends PeriodicWork { private final CloudStatistics stats = CloudStatistics.get();
        public long getRecurrencePeriod() {
            return MIN * 10;
        }
        
        protected void doRun() {
            List<ProvisioningActivity.Id> trackedExisting = new ArrayList<>();
            for (Computer computer : Jenkins.getInstance().getComputers()) {
                if (computer instanceof TrackedItem) {
                    trackedExisting.add(((TrackedItem) computer).getId());
                }
                
            }
            
            ArrayList<ProvisioningActivity> completed = new ArrayList<>();
            for (ProvisioningActivity activity: stats.getRetainedActivities()) {
                Map<ProvisioningActivity.Phase, PhaseExecution> executions = activity.getPhaseExecutions();
                if (executions.get(ProvisioningActivity.Phase.COMPLETED) != null) {
                    completed.add(activity);
                    continue; 
                }
                
                assert activity.getStatus() != ProvisioningActivity.Status.FAIL; 
                if (executions.get(ProvisioningActivity.Phase.LAUNCHING) == null) continue; 
                if (trackedExisting.contains(activity.getId())) continue; 
                activity.enter(ProvisioningActivity.Phase.COMPLETED);
                completed.add(activity);
            }
            
            if (!completed.isEmpty()) {
                synchronized (stats.active) {
                    stats.log.addAll(completed);
                    stats.active.removeAll(completed);
                }
                
                stats.persist();
            }
            
        }
        
    }
    
    @Restricted(NoExternalUse.class) @Extension public static class SlaveCompletionDetector extends NodeListener { private final CloudStatistics stats = CloudStatistics.get();
        protected void onUpdated(@Nonnull Node oldOne, @Nonnull Node newOne) {
            if (oldOne.getNodeName().equals(newOne.getNodeName())) return; 
            ProvisioningActivity.Id id = getIdFor(oldOne);
            if (id == null) return; 
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity == null) return;
            activity.rename(newOne.getNodeName());
            stats.persist();
        }
        
        protected void onDeleted(@Nonnull Node node) {
            ProvisioningActivity.Id id = getIdFor(node);
            if (id == null) return; 
            ProvisioningActivity activity = stats.getActivityFor(id);
            if (activity == null) return;
            boolean entered = activity.enterIfNotAlready(ProvisioningActivity.Phase.COMPLETED);
            if (entered) {
                stats.archive(activity);
                stats.persist();
            }
            
        }
        
    }
    
    private static @CheckForNull ProvisioningActivity.Id getIdFor(NodeProvisioner.PlannedNode plannedNode) {
        if (!(plannedNode instanceof TrackedItem)) {
            logTypeNotSupported(plannedNode.getClass());
            return null;
        }
        
        return ((TrackedItem) plannedNode).getId();
    }
    
    private static @CheckForNull ProvisioningActivity.Id getIdFor(Node node) {
        if (node instanceof Jenkins) return null;
        if (!(node instanceof TrackedItem)) {
            LOGGER.info("No support for cloud-stats-plugin by " + node.getClass());
            return null;
        }
        
        return ((TrackedItem) node).getId();
    }
    
    private static @CheckForNull ProvisioningActivity.Id getIdFor(Computer computer) {
        if (computer instanceof Jenkins.MasterComputer) return null;
        if (!(computer instanceof AbstractCloudComputer)) return null;
        if (!(computer instanceof TrackedItem)) {
            logTypeNotSupported(computer.getClass());
            return null;
        }
        
        return ((TrackedItem) computer).getId();
    }
    
    private static void logTypeNotSupported(Class<?> type) {
        if (!loggedUnsupportedTypes.contains(type)) {
            LOGGER.info("No support for cloud-stats plugin by " + type);
            loggedUnsupportedTypes.add(type);
        }
        
    }
    
    private static final Set<Class> loggedUnsupportedTypes = Collections.synchronizedSet(new HashSet<>());
}


