package org.jenkinsci.plugins.scriptsecurity.scripts;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import jenkins.model.GlobalConfiguration;
import jenkins.model.GlobalConfigurationCategory;
import jenkins.util.SystemProperties;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.Symbol;
import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.AclAwareWhitelist;
import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.ProxyWhitelist;
import org.jenkinsci.plugins.scriptsecurity.sandbox.RejectedAccessException;
import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.StaticWhitelist;
import org.jenkinsci.plugins.scriptsecurity.sandbox.Whitelist;
import org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.GroovySandbox;
import hudson.Extension;
import hudson.ExtensionList;
import hudson.Util;
import hudson.XmlFile;
import hudson.model.RootAction;
import hudson.security.ACL;
import hudson.util.FormValidation;
import hudson.util.XStream2;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import jenkins.model.Jenkins;
import net.sf.json.JSON;
import org.acegisecurity.context.SecurityContext;
import org.acegisecurity.context.SecurityContextHolder;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.bind.JavaScriptMethod;
public class ScriptApproval extends GlobalConfiguration implements RootAction {
    @SuppressFBWarnings(value = "MS_SHOULD_BE_FINAL", justification = "for script console")
    public static  boolean ADMIN_AUTO_APPROVAL_ENABLED = SystemProperties.getBoolean(ScriptApproval.class.getName() + ".ADMIN_AUTO_APPROVAL_ENABLED");
    private static final Logger LOG = Logger.getLogger(ScriptApproval.class.getName());
    private static final XStream2 XSTREAM2 = new XStream2();
    static {
        XSTREAM2.alias("com.cloudbees.hudson.plugins.modeling.scripts.ScriptApproval", ScriptApproval.class);
        XSTREAM2.alias("com.cloudbees.hudson.plugins.modeling.scripts.ScriptApproval$PendingScript", PendingScript.class);
        XSTREAM2.alias("com.cloudbees.hudson.plugins.modeling.scripts.ScriptApproval$PendingSignature", PendingSignature.class);
        XSTREAM2.alias("scriptApproval", ScriptApproval.class);
        XSTREAM2.alias("approvedClasspathEntry", ApprovedClasspathEntry.class);
        XSTREAM2.alias("pendingScript", PendingScript.class);
        XSTREAM2.alias("pendingSignature", PendingSignature.class);
        XSTREAM2.alias("pendingClasspathEntry", PendingClasspathEntry.class);
    }
    
    protected XmlFile getConfigFile() {
        return new XmlFile(XSTREAM2, new File(Jenkins.get().getRootDir(),getUrlName() + ".xml"));
    }
    
    public GlobalConfigurationCategory getCategory() {
        return GlobalConfigurationCategory.get(GlobalConfigurationCategory.Security.class);
    }
    
    public static @NonNull ScriptApproval get() {
        ScriptApproval instance = ExtensionList.lookup(RootAction.class).get(ScriptApproval.class);
        if (instance == null) {
            throw new IllegalStateException("maybe need to rebuild plugin?");
        }
        
        return instance;
    }
    
    public static class ApprovedClasspathEntry implements Comparable<ApprovedClasspathEntry> {
        private final String hash;
        private final URL url;
        public ApprovedClasspathEntry(String hash, URL url) {
            this.hash = hash;
            this.url = url;
        }
        
        public String getHash() {
            return hash;
        }
        
        public URL getURL() {
            return url;
        }
        
        boolean isClassDirectory() {
            return ClasspathEntry.isClassDirectoryURL(url);
        }
        
 public int hashCode() {
            return hash.hashCode();
        }
        
 public boolean equals(Object obj) {
            return obj instanceof ApprovedClasspathEntry && ((ApprovedClasspathEntry) obj).hash.equals(hash);
        }
        
 public int compareTo(ApprovedClasspathEntry o) {
            return hash.compareTo(o.hash);
        }
        
    }
    
    private final TreeSet<String> approvedScriptHashes = new TreeSet<>();
    private final TreeSet<String> approvedSignatures = new TreeSet<>();
    private  TreeSet<String> aclApprovedSignatures;
    private  TreeSet<ApprovedClasspathEntry> approvedClasspathEntries;
     void addApprovedClasspathEntry(ApprovedClasspathEntry acp) {
        approvedClasspathEntries.add(acp);
    }
    
    public boolean isScriptApproved(String script, Language language) {
        return this.isScriptHashApproved(hash(script, language.getName()));
    }
    
    public static abstract class PendingThing {
 private String user;
        private @NonNull ApprovalContext context;
        PendingThing(@NonNull ApprovalContext context) {
            this.context = context;
        }
        
        public @NonNull ApprovalContext getContext() {
            return context;
        }
        
        private Object readResolve() {
            if (user != null) {
                context = ApprovalContext.create().withUser(user);
                user = null;
            }
            
            return this;
        }
        
    }
    
    public static final class PendingScript extends PendingThing {
        public final String script;
        private final String language;
        PendingScript(@NonNull String script, @NonNull Language language, @NonNull ApprovalContext context) {
            super(context);
            this.script = script;
            this.language = language.getName();
        }
        
        public String getHash() {
            return hash(script, language);
        }
        
        public Language getLanguage() {
            for (Language l : ExtensionList.lookup(Language.class)) {
                if (l.getName().equals(language)) {
                    return l;
                }
                
            }
            
            return new Language() {
 public String getName() {
                    return language;
                }
                
 public String getDisplayName() {
                    return "<missing language: " + language + ">";
                }
                
            };
        }
        
 public int hashCode() {
            return script.hashCode() ^ language.hashCode();
        }
        
 public boolean equals(Object obj) {
            return obj instanceof PendingScript && ((PendingScript) obj).language.equals(language) && ((PendingScript) obj).script.equals(script);
        }
        
    }
    
    public static final class PendingSignature extends PendingThing {
        public final String signature;
        public final boolean dangerous;
        PendingSignature(@NonNull String signature, boolean dangerous, @NonNull ApprovalContext context) {
            super(context);
            this.signature = signature;
            this.dangerous = dangerous;
        }
        
        public String getHash() {
            return Integer.toHexString(hashCode());
        }
        
 public int hashCode() {
            return signature.hashCode();
        }
        
 public boolean equals(Object obj) {
            return obj instanceof PendingSignature && ((PendingSignature) obj).signature.equals(signature);
        }
        
    }
    
    public static final class PendingClasspathEntry extends PendingThing implements Comparable<PendingClasspathEntry> {
        private final String hash;
        private final URL url;
        private static final ApprovalContext SEARCH_APPROVAL_CONTEXT = ApprovalContext.create();
        private static URL SEARCH_APPROVAL_URL;
        static {
            try {
                SEARCH_APPROVAL_URL = new URL("http://invalid.url/do/not/use");
            }
             catch (Throwable e) {
                LOG.log(Level.WARNING, "Unexpected exception", e);
            }
            
        }
        
        PendingClasspathEntry(@NonNull String hash, @NonNull URL url, @NonNull ApprovalContext context) {
            super(context);
            this.hash = hash;
            this.url = url;
        }
        
        public @NonNull String getHash() {
            return hash;
        }
        
        public @NonNull URL getURL() {
            return url;
        }
        
 public int hashCode() {
            return getHash().hashCode();
        }
        
 public boolean equals(Object obj) {
            return obj instanceof PendingClasspathEntry && ((PendingClasspathEntry) obj).getHash().equals(getHash());
        }
        
 public int compareTo(PendingClasspathEntry o) {
            return hash.compareTo(o.hash);
        }
        
        public static @NonNull PendingClasspathEntry searchKeyFor(@NonNull String hash) {
            final PendingClasspathEntry entry = new PendingClasspathEntry(hash,  SEARCH_APPROVAL_URL, SEARCH_APPROVAL_CONTEXT);
            return entry;
        }
        
    }
    
    private final LinkedHashSet<PendingScript> pendingScripts = new LinkedHashSet<>();
    private final LinkedHashSet<PendingSignature> pendingSignatures = new LinkedHashSet<>();
    private  TreeSet<PendingClasspathEntry> pendingClasspathEntries;
    private PendingClasspathEntry getPendingClasspathEntry(@NonNull String hash) {
        PendingClasspathEntry e = pendingClasspathEntries.floor(PendingClasspathEntry.searchKeyFor(hash));
        if (e != null && e.hash.equals(hash)) {
            return e;
        }
         else {
            return null;
        }
        
    }
    
     void addPendingClasspathEntry(PendingClasspathEntry pcp) {
        pendingClasspathEntries.add(pcp);
    }
    
    public ScriptApproval() {
        load();
        if (aclApprovedSignatures == null) {
            aclApprovedSignatures = new TreeSet<>();
        }
        
        if (approvedClasspathEntries == null) {
            approvedClasspathEntries = new TreeSet<>();
        }
        
        if (pendingClasspathEntries == null) {
            pendingClasspathEntries = new TreeSet<>();
        }
        
        boolean changed = false;
        for (Iterator<ApprovedClasspathEntry> i = approvedClasspathEntries.iterator(); i.hasNext();) {
            if (i.next().isClassDirectory()) {
                i.remove();
                changed = true;
            }
            
        }
        
        if (changed) {
            save();
        }
        
    }
    
    boolean isEmpty() {
        return approvedScriptHashes.isEmpty() && approvedSignatures.isEmpty() && aclApprovedSignatures.isEmpty() && approvedClasspathEntries.isEmpty() && pendingScripts.isEmpty() && pendingSignatures.isEmpty() && pendingClasspathEntries.isEmpty();
    }
    
    private static String hash(String script, String language) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            digest.update(language.getBytes("UTF-8"));
            digest.update((byte) ':');
            digest.update(script.getBytes("UTF-8"));
            return Util.toHexString(digest.digest());
        }
         catch (NoSuchAlgorithmException | UnsupportedEncodingException x) {
            throw new AssertionError(x);
        }
        
    }
    
    static String hashClasspathEntry(URL entry) throws IOException {
        InputStream is = entry.openStream();
        try {
            DigestInputStream input = null;
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-1");
                input = new DigestInputStream(new BufferedInputStream(is), digest);
                byte[] buffer = new byte[1024];
                while (input.read(buffer) != -1) {
                }
                
                return Util.toHexString(digest.digest());
            }
             catch (NoSuchAlgorithmException x) {
                throw new AssertionError(x);
            }
             finally {
                if (input != null) {
                    input.close();
                }
                
            }
            
        }
         finally {
            is.close();
        }
        
    }
    
    public synchronized String configuring(@NonNull String script, @NonNull Language language, @NonNull ApprovalContext context, boolean approveIfAdmin) {
        final String hash = hash(script, language.getName());
        if (!approvedScriptHashes.contains(hash)) {
            if (!Jenkins.get().isUseSecurity() ||  ((Jenkins.getAuthentication() != ACL.SYSTEM && Jenkins.get().hasPermission(Jenkins.ADMINISTER))  && (ADMIN_AUTO_APPROVAL_ENABLED || approveIfAdmin))) {
                approvedScriptHashes.add(hash);
                removePendingScript(hash);
            }
             else {
                String key = context.getKey();
                if (key != null) {
                    pendingScripts.removeIf(pendingScript -> key.equals(pendingScript.getContext().getKey()));
                }
                
                pendingScripts.add(new PendingScript(script, language, context));
            }
            
            save();
        }
        
        return script;
    }
    
    public String configuring(@NonNull String script, @NonNull Language language, @NonNull ApprovalContext context) {
        return this.configuring(script, language, context, false);
    }
    
    public synchronized String using(@NonNull String script, @NonNull Language language) throws UnapprovedUsageException {
        if (script.length() == 0) {
            return script;
        }
        
        String hash = hash(script, language.getName());
        if (!approvedScriptHashes.contains(hash)) {
            throw new UnapprovedUsageException(hash);
        }
        
        return script;
    }
    
    synchronized boolean isScriptHashApproved(String hash) {
        return approvedScriptHashes.contains(hash);
    }
    
    public synchronized void configuring(@NonNull ClasspathEntry entry, @NonNull ApprovalContext context) {
        if (entry.isClassDirectory()) {
            LOG.log(Level.WARNING, "Classpath {0} is a class directory, which are not allowed. Ignored in configuration, use will be rejected", entry.getURL());
            return;
        }
        
        URL url = entry.getURL();
        String hash;
        try {
            hash = hashClasspathEntry(url);
        }
         catch (IOException x) {
            LOG.log(Level.WARNING, null, x);
            return;
        }
        
        ApprovedClasspathEntry acp = new ApprovedClasspathEntry(hash, url);
        if (!approvedClasspathEntries.contains(acp)) {
            boolean shouldSave = false;
            PendingClasspathEntry pcp = new PendingClasspathEntry(hash, url, context);
            if (!Jenkins.get().isUseSecurity() || ((Jenkins.getAuthentication() != ACL.SYSTEM && Jenkins.get().hasPermission(Jenkins.ADMINISTER)) && (ADMIN_AUTO_APPROVAL_ENABLED || entry.isShouldBeApproved() || !StringUtils.equals(entry.getOldPath(), entry.getPath())))) {
                LOG.log(Level.FINE, "Classpath entry {0} ({1}) is approved as configured with ADMINISTER permission.", new Object[] {url, hash});
                pendingClasspathEntries.remove(pcp);
                approvedClasspathEntries.add(acp);
                shouldSave = true;
            }
             else {
                if (pendingClasspathEntries.add(pcp)) {
                    LOG.log(Level.FINE, "{0} ({1}) is pending", new Object[] {url, hash});
                    shouldSave = true;
                }
                
            }
            
            if (shouldSave) {
                save();
            }
            
        }
        
    }
    
    public synchronized FormValidation checking(@NonNull ClasspathEntry entry) {
        if (entry.isClassDirectory()) {
            return FormValidation.error(Messages.ClasspathEntry_path_noDirsAllowed());
        }
        
        URL url = entry.getURL();
        try {
            if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER) && !approvedClasspathEntries.contains(new ApprovedClasspathEntry(hashClasspathEntry(url), url))) {
                return FormValidation.error(Messages.ClasspathEntry_path_notApproved());
            }
             else {
                return FormValidation.ok();
            }
            
        }
         catch (FileNotFoundException x) {
            return FormValidation.error(Messages.ClasspathEntry_path_notExists());
        }
         catch (IOException x) {
            return FormValidation.error(x, "Could not verify: " + url); 
        }
        
    }
    
    public synchronized void using(@NonNull ClasspathEntry entry) throws IOException, UnapprovedClasspathException {
        URL url = entry.getURL();
        String hash = hashClasspathEntry(url);
        if (!approvedClasspathEntries.contains(new ApprovedClasspathEntry(hash, url))) {
            if (entry.isClassDirectory()) {
                LOG.log(Level.WARNING, "Classpath {0} ({1}) is a class directory, which are not allowed.", new Object[] {url, hash});
                throw new UnapprovedClasspathException("classpath entry %s is a class directory, which are not allowed.", url, hash);
            }
             else {
                ApprovalContext context = ApprovalContext.create();
                if (pendingClasspathEntries.add(new PendingClasspathEntry(hash, url, context))) {
                    LOG.log(Level.FINE, "{0} ({1}) is pending.", new Object[] {url, hash});
                    save();
                }
                
            }
            
            throw new UnapprovedClasspathException(url, hash);
        }
        
        LOG.log(Level.FINER, "{0} ({1}) had been approved", new Object[] {url, hash});
    }
    
    public synchronized FormValidation checking(@NonNull String script, @NonNull Language language, boolean willBeApproved) {
        if (StringUtils.isEmpty(script)) {
            return FormValidation.ok();
        }
        
        if (approvedScriptHashes.contains(hash(script, language.getName()))) {
            return FormValidation.okWithMarkup("The script is already approved");
        }
        
        if (!Jenkins.get().hasPermission(Jenkins.ADMINISTER)) {
            return FormValidation.warningWithMarkup("A Jenkins administrator will need to approve this script before it can be used");
        }
         else {
            if (willBeApproved || ADMIN_AUTO_APPROVAL_ENABLED) {
                return FormValidation.ok("The script has not yet been approved, but it will be approved on save");
            }
            
            return FormValidation.okWithMarkup("The script is not approved and will not be approved on save. " + "Modify the script to approve it on save, or approve it explicitly on the " + "<a target='blank' href='"+ Jenkins.get().getRootUrl() + ScriptApproval.get().getUrlName() + "'>Script Approval Configuration</a> page");
        }
        
    }
    
    public synchronized FormValidation checking(@NonNull String script, @NonNull Language language) {
        return this.checking(script, language, false);
    }
    
    synchronized boolean isClasspathEntryApproved(URL url) {
        try {
            return approvedClasspathEntries.contains(new ApprovedClasspathEntry(hashClasspathEntry(url), url));
        }
         catch (IOException e) {
            return false;
        }
        
    }
    
    public synchronized String preapprove(@NonNull String script, @NonNull Language language) {
        approvedScriptHashes.add(hash(script, language.getName()));
        return script;
    }
    
    public synchronized void preapproveAll() {
        for (PendingScript ps : pendingScripts) {
            approvedScriptHashes.add(ps.getHash());
        }
        
        pendingScripts.clear();
    }
    
    public synchronized RejectedAccessException accessRejected(@NonNull RejectedAccessException x, @NonNull ApprovalContext context) {
        String signature = x.getSignature();
        if (signature != null && pendingSignatures.add(new PendingSignature(signature, x.isDangerous(), context))) {
            save();
        }
        
        return x;
    }
    
    private static final ThreadLocal<Stack<Consumer<RejectedAccessException>>> callbacks = ThreadLocal.withInitial(Stack::new);
    public static void maybeRegister(@NonNull RejectedAccessException x) {
        for (Consumer<RejectedAccessException> callback : callbacks.get()) {
            callback.accept(x);
        }
        
    }
    
    public static void pushRegistrationCallback(Consumer<RejectedAccessException> callback) {
        callbacks.get().push(callback);
    }
    
    public static void popRegistrationCallback() {
        callbacks.get().pop();
    }
    
    public synchronized void setApprovedSignatures(String[] signatures) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        approvedSignatures.clear();
        List<String> goodSignatures = new ArrayList<>(signatures.length);
        for (String signature : signatures) {
            try {
                StaticWhitelist.parse(signature);
                goodSignatures.add(signature);
            }
             catch (IOException e) {
                LOG.warning("Ignoring malformed signature: " + signature + " (Occurred exception: " + e.toString() + ")");
            }
            
        }
        
        approvedSignatures.addAll(goodSignatures);
        save();
        reconfigure();
    }
    
    public synchronized String[] getApprovedSignatures() {
        return approvedSignatures.toArray(new String[approvedSignatures.size()]);
    }
    
    public synchronized String[] getDangerousApprovedSignatures() {
        List<String> dangerous = new ArrayList<>();
        for (String sig : approvedSignatures) {
            if (StaticWhitelist.isBlacklisted(sig)) {
                dangerous.add(sig);
            }
            
        }
        
        return dangerous.toArray(new String[dangerous.size()]);
    }
    
    public synchronized String[] getAclApprovedSignatures() {
        return aclApprovedSignatures.toArray(new String[aclApprovedSignatures.size()]);
    }
    
    public synchronized void setApprovedScriptHashes(String[] scriptHashes) throws IOException {
        Jenkins.getInstance().checkPermission(Jenkins.RUN_SCRIPTS);
        approvedScriptHashes.clear();
        Pattern sha1Pattern = Pattern.compile("[a-fA-F0-9]{40}");
        for (String scriptHash : scriptHashes) {
            if (scriptHash != null && sha1Pattern.matcher(scriptHash).matches()) {
                approvedScriptHashes.add(scriptHash);
            }
             else {
                LOG.warning(() -> "Ignoring malformed script hash: " + scriptHash);
            }
            
        }
        
        save();
        reconfigure();
    }
    
    public synchronized String[] getApprovedScriptHashes() {
        return approvedScriptHashes.toArray(new String[approvedScriptHashes.size()]);
    }
    
    @Extension public static final class ApprovedWhitelist extends ProxyWhitelist { public ApprovedWhitelist() { try { reconfigure(); } catch (IOException e) {
                LOG.log(Level.SEVERE, "Malformed signature entry in scriptApproval.xml: '" + e.getMessage() + "'");
            }
            
        }
        
        String[][] reconfigure() throws IOException {
            ScriptApproval instance = ScriptApproval.get();
            synchronized (instance) {
                reset(Collections.singleton(new AclAwareWhitelist(new StaticWhitelist(instance.approvedSignatures), new StaticWhitelist(instance.aclApprovedSignatures))));
                return new String[][] {instance.getApprovedSignatures(), instance.getAclApprovedSignatures(), instance.getDangerousApprovedSignatures()};
            }
            
        }
        
    }
    
 public String getIconFileName() {
        return null;
    }
    
 public String getUrlName() {
        return "scriptApproval";
    }
    
    public Set<PendingScript> getPendingScripts() {
        return pendingScripts;
    }
    
    @JavaScriptMethod public void approveScript(String hash) throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        synchronized (this) {
            approvedScriptHashes.add(hash);
            removePendingScript(hash);
            save();
        }
        
        SecurityContext orig = ACL.impersonate(ACL.SYSTEM);
        try {
            for (ApprovalListener listener : ExtensionList.lookup(ApprovalListener.class)) {
                listener.onApproved(hash);
            }
            
        }
         finally {
            SecurityContextHolder.setContext(orig);
        }
        
    }
    
    @JavaScriptMethod public synchronized void denyScript(String hash) throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        approvedScriptHashes.remove(hash);
        removePendingScript(hash);
        save();
    }
    
    synchronized void removePendingScript(String hash) {
        Iterator<PendingScript> it = pendingScripts.iterator();
        while (it.hasNext()) {
            if (it.next().getHash().equals(hash)) {
                it.remove();
                break;
            }
            
        }
        
    }
    
    @JavaScriptMethod public synchronized void clearApprovedScripts() throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        approvedScriptHashes.clear();
        save();
    }
    
    public Set<PendingSignature> getPendingSignatures() {
        return pendingSignatures;
    }
    
    private String[][] reconfigure() throws IOException {
        final ApprovedWhitelist awl = ExtensionList.lookup(Whitelist.class).get(ApprovedWhitelist.class);
        if (awl != null) {
            return awl.reconfigure();
        }
         else {
            return new String[][] {new String[0], new String[0], new String[0]};
        }
        
    }
    
    @JavaScriptMethod public synchronized String[][] approveSignature(String signature) throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        pendingSignatures.remove(new PendingSignature(signature, false, ApprovalContext.create()));
        approvedSignatures.add(signature);
        save();
        return reconfigure();
    }
    
    @JavaScriptMethod public synchronized String[][] aclApproveSignature(String signature) throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        pendingSignatures.remove(new PendingSignature(signature, false, ApprovalContext.create()));
        aclApprovedSignatures.add(signature);
        save();
        return reconfigure();
    }
    
    @JavaScriptMethod public synchronized void denySignature(String signature) throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        pendingSignatures.remove(new PendingSignature(signature, false, ApprovalContext.create()));
        save();
    }
    
    @JavaScriptMethod public synchronized String[][] clearApprovedSignatures() throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        approvedSignatures.clear();
        aclApprovedSignatures.clear();
        save();
        return reconfigure();
    }
    
    @JavaScriptMethod public synchronized String[][] clearDangerousApprovedSignatures() throws IOException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        Iterator<String> it = approvedSignatures.iterator();
        while (it.hasNext()) {
            if (StaticWhitelist.isBlacklisted(it.next())) {
                it.remove();
            }
            
        }
        
        it = aclApprovedSignatures.iterator();
        while (it.hasNext()) {
            if (StaticWhitelist.isBlacklisted(it.next())) {
                it.remove();
            }
            
        }
        
        save();
        return reconfigure();
    }
    
    public synchronized List<ApprovedClasspathEntry> getApprovedClasspathEntries() {
        ArrayList<ApprovedClasspathEntry> r = new ArrayList<>(approvedClasspathEntries);
        Collections.sort(r, Comparator.comparing(o -> o.url.toString()));
        return r;
    }
    
    public synchronized List<PendingClasspathEntry> getPendingClasspathEntries() {
        List<PendingClasspathEntry> r = new ArrayList<>(pendingClasspathEntries);
        Collections.sort(r, Comparator.comparing(o -> o.url.toString()));
        return r;
    }
    
    public JSON getClasspathRenderInfo() {
        JSONArray pendings = new JSONArray();
        for (PendingClasspathEntry cp : getPendingClasspathEntries()) {
            pendings.add(new JSONObject().element("hash", cp.getHash()).element("path", ClasspathEntry.urlToPath(cp.getURL())));
        }
        
        JSONArray approveds = new JSONArray();
        for (ApprovedClasspathEntry cp : getApprovedClasspathEntries()) {
            approveds.add(new JSONObject().element("hash", cp.getHash()).element("path", ClasspathEntry.urlToPath(cp.getURL())));
        }
        
        return new JSONArray().element(pendings).element(approveds);
    }
    
    public JSON approveClasspathEntry(String hash) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        URL url = null;
        synchronized (this) {
            final PendingClasspathEntry cp = getPendingClasspathEntry(hash);
            if (cp != null) {
                pendingClasspathEntries.remove(cp);
                url = cp.getURL();
                approvedClasspathEntries.add(new ApprovedClasspathEntry(hash, url));
                save();
            }
            
        }
        
        if (url != null) {
            SecurityContext orig = ACL.impersonate(ACL.SYSTEM);
            try {
                for (ApprovalListener listener : ExtensionList.lookup(ApprovalListener.class)) {
                    listener.onApprovedClasspathEntry(hash, url);
                }
                
            }
             finally {
                SecurityContextHolder.setContext(orig);
            }
            
        }
        
        return getClasspathRenderInfo();
    }
    
    public JSON denyClasspathEntry(String hash) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        PendingClasspathEntry cp = getPendingClasspathEntry(hash);
        if (cp != null) {
            pendingClasspathEntries.remove(cp);
            save();
        }
        
        return getClasspathRenderInfo();
    }
    
    public JSON denyApprovedClasspathEntry(String hash) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        if (approvedClasspathEntries.remove(new ApprovedClasspathEntry(hash, null))) {
            save();
        }
        
        return getClasspathRenderInfo();
    }
    
    public synchronized JSON clearApprovedClasspathEntries() throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        approvedClasspathEntries.clear();
        save();
        return getClasspathRenderInfo();
    }
    
}


