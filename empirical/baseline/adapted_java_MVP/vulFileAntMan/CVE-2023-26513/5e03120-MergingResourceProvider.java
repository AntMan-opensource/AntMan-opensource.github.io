package org.apache.sling.resourcemerger.impl;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.resource.ResourceUtil;
import org.apache.sling.api.resource.ValueMap;
import org.apache.sling.resourcemerger.spi.MergedResourcePicker2;
import org.apache.sling.spi.resource.provider.ResolveContext;
import org.apache.sling.spi.resource.provider.ResourceContext;
import org.apache.sling.spi.resource.provider.ResourceProvider;
public class MergingResourceProvider extends ResourceProvider<Void> {
    protected final String mergeRootPath;
    protected final MergedResourcePicker2 picker;
    private final boolean readOnly;
    protected final boolean traverseHierarchie;
    MergingResourceProvider(final String mergeRootPath, final MergedResourcePicker2 picker, final boolean readOnly, final boolean traverseHierarchie) {
        this.mergeRootPath = mergeRootPath;
        this.picker = picker;
        this.readOnly = readOnly;
        this.traverseHierarchie = traverseHierarchie;
    }
    
    protected static final class ResourceHidingHandler {
        private boolean isParentHiddenFully;
        private boolean isParentHiddenForUnderlay;
        private final HideItemPredicate hidePredicate;
        public ResourceHidingHandler(final Resource resource, final boolean traverseParent) {
            isParentHiddenFully = false;
            isParentHiddenForUnderlay = false;
            final ValueMap properties = resource.getValueMap();
            final String[] childrenToHideArray = properties.get(MergedResourceConstants.PN_HIDE_CHILDREN, new String[0]);
            hidePredicate = new HideItemPredicate(childrenToHideArray, resource.getPath() + "/" + MergedResourceConstants.PN_HIDE_CHILDREN);
            Resource parent = resource.getParent();
            String childResourceName = resource.getName();
            while (parent != null) {
                final ValueMap parentProperties = parent.getValueMap();
                final String[] parentChildrenToHideArray = parentProperties.get(MergedResourceConstants.PN_HIDE_CHILDREN, String[].class);
                if (parentChildrenToHideArray != null) {
                    HideItemPredicate parentHidePredicate = new HideItemPredicate(parentChildrenToHideArray, parent.getPath() + "/" + MergedResourceConstants.PN_HIDE_CHILDREN);
                    if (parentHidePredicate.testItem(childResourceName, false)) {
                        if (parentHidePredicate.isWildcard()) {
                            isParentHiddenForUnderlay = true;
                        }
                         else {
                            isParentHiddenFully = true;
                        }
                        
                        break;
                    }
                    
                }
                
                if (!traverseParent) {
                    break;
                }
                
                childResourceName = parent.getName();
                parent = parent.getParent();
            }
            
        }
        
        public boolean isHidden(final String name, boolean isLocalResource) {
            return isParentHiddenFully || ((!isLocalResource) && isParentHiddenForUnderlay) || (hidePredicate.testItem(name, isLocalResource));
        }
        
    }
    
    protected static final class ResourceHolder {
        public final String name;
        public final List<Resource> resources = new ArrayList<>();
        public final List<ValueMap> valueMaps = new ArrayList<>();
        public ResourceHolder(final String n) {
            this.name = n;
        }
        
    }
    
    private Resource createMergedResource(final ResourceResolver resolver, final String relativePath, final ResourceHolder holder) {
        int index = 0;
        while (index < holder.resources.size()) {
            final Resource baseRes = holder.resources.get(index);
            final ValueMap props = baseRes.getValueMap();
            holder.valueMaps.add(props);
            if (props.get(MergedResourceConstants.PN_HIDE_RESOURCE, Boolean.FALSE)) {
                for (int i = 0; i <= index; i++) {
                    holder.resources.remove(0);
                }
                
                holder.valueMaps.clear();
                index = 0; 
            }
             else {
                index++;
            }
            
        }
        
        if (!holder.resources.isEmpty()) {
            if ( this.readOnly ) {
                return new MergedResource(resolver, mergeRootPath, relativePath, holder.resources, holder.valueMaps);
            }
            
            return new CRUDMergedResource(resolver, mergeRootPath, relativePath, holder.resources, holder.valueMaps, this.picker);
        }
        
        return null;
    }
    
    protected String getRelativePath(String path) {
        if (path.startsWith(mergeRootPath)) {
            path = path.substring(mergeRootPath.length());
            if (path.length() == 0) {
                return path;
            }
             else if (path.charAt(0) == '/') {
                return path.substring(1);
            }
            
        }
        
        return null;
    }
    
    public Resource getParent(ResolveContext<Void> ctx, Resource child) {
        final String parentPath = ResourceUtil.getParent(child.getPath());
        if (parentPath == null) {
            return null;
        }
        
        return this.getResource(ctx, parentPath, ResourceContext.EMPTY_CONTEXT, child);
    }
    
    public Resource getResource(final ResolveContext<Void> ctx, final String path, final ResourceContext rCtx, final Resource parent) {
        final String relativePath = getRelativePath(path);
        if (relativePath != null) {
            final ResourceHolder holder = new ResourceHolder(ResourceUtil.getName(path));
            final ResourceResolver resolver = ctx.getResourceResolver();
            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath, parent).iterator();
            if (!resources.hasNext()) {
                return null;
            }
            
            boolean isUnderlying = true;
            while (resources.hasNext()) {
                final Resource resource = resources.next();
                final boolean hidden;
                if (isUnderlying) {
                    hidden = false;
                    isUnderlying = false;
                }
                 else {
                    final Resource resourceParent = resource.getParent();
                    hidden = resourceParent != null && new ResourceHidingHandler(resourceParent, this.traverseHierarchie).isHidden(holder.name, true);
                }
                
                if (hidden) {
                    holder.resources.clear();
                }
                 else if (!ResourceUtil.isNonExistingResource(resource)) {
                    holder.resources.add(resource);
                }
                
            }
            
            return createMergedResource(resolver, relativePath, holder);
        }
        
        return null;
    }
    
    public Iterator<Resource> listChildren(final ResolveContext<Void> ctx, final Resource parent) {
        final ResourceResolver resolver = parent.getResourceResolver();
        final String relativePath = getRelativePath(parent.getPath());
        if (relativePath != null) {
            final List<ResourceHolder> candidates = new ArrayList<ResourceHolder>();
            final Iterator<Resource> resources = picker.pickResources(resolver, relativePath, parent).iterator();
            boolean isUnderlying = true;
            while (resources.hasNext()) {
                Resource parentResource = resources.next();
                final ResourceHidingHandler handler = !isUnderlying ? new ResourceHidingHandler(parentResource, this.traverseHierarchie) : null;
                isUnderlying = false;
                if (handler != null) {
                    final Iterator<ResourceHolder> iter = candidates.iterator();
                    while (iter.hasNext()) {
                        final ResourceHolder holder = iter.next();
                        if (handler.isHidden(holder.name, false)) {
                            iter.remove(); 
                        }
                        
                    }
                    
                }
                
                int previousChildPositionInCandidateList = -1;
                for (final Resource child : parentResource.getChildren()) {
                    final String rsrcName = child.getName();
                    ResourceHolder holder = null;
                    int childPositionInCandidateList = -1;
                    for (int index=0; index < candidates.size(); index++) {
                        ResourceHolder current = candidates.get(index);
                        if (current.name.equals(rsrcName)) {
                            holder = current;
                            childPositionInCandidateList = index;
                            break;
                        }
                        
                    }
                    
                    if (holder == null) {
                        if (handler != null && handler.isHidden(rsrcName, true)) {
                            continue; 
                        }
                        
                        holder = new ResourceHolder(rsrcName);
                        if (previousChildPositionInCandidateList != -1) {
                            candidates.add(previousChildPositionInCandidateList+1, holder);
                            previousChildPositionInCandidateList++;
                        }
                         else {
                            candidates.add(holder);
                            previousChildPositionInCandidateList = candidates.size() - 1;
                        }
                        
                    }
                    
                    holder.resources.add(child);
                    int orderBeforeIndex = -1;
                    final ValueMap vm = child.getValueMap();
                    final String orderBefore = vm.get(MergedResourceConstants.PN_ORDER_BEFORE, String.class);
                    if (orderBefore != null && !orderBefore.equals(rsrcName)) {
                        int index = 0;
                        while (index < candidates.size()) {
                            final ResourceHolder current = candidates.get(index);
                            if (current.name.equals(orderBefore)) {
                                orderBeforeIndex = index;
                                break;
                            }
                            
                            index++;
                        }
                        
                    }
                    
                    if (orderBeforeIndex > -1) {
                        candidates.add(orderBeforeIndex, holder);
                        if (childPositionInCandidateList == -1) {
                            candidates.remove(candidates.size() - 1);
                        }
                         else {
                            if (childPositionInCandidateList > orderBeforeIndex) {
                                childPositionInCandidateList++;
                            }
                            
                            candidates.remove(childPositionInCandidateList);
                        }
                        
                    }
                     else {
                        if (childPositionInCandidateList != -1 && previousChildPositionInCandidateList != -1) {
                            candidates.remove(childPositionInCandidateList);
                            if (childPositionInCandidateList < previousChildPositionInCandidateList) {
                                previousChildPositionInCandidateList--;
                            }
                            
                            if(previousChildPositionInCandidateList+1 > candidates.size()){
                                candidates.add(holder);
                            }
                             else {
                                candidates.add(previousChildPositionInCandidateList + 1, holder);
                            }
                            
                            previousChildPositionInCandidateList++;
                        }
                        
                    }
                    
                }
                
            }
            
            final List<Resource> children = new ArrayList<Resource>();
            for (final ResourceHolder holder : candidates) {
                final Resource mergedResource = this.createMergedResource(resolver, (relativePath.length() == 0 ? holder.name : relativePath + '/' + holder.name), holder);
                if (mergedResource != null) {
                    children.add(mergedResource);
                }
                
            }
            
            return children.iterator();
        }
        
        return null;
    }
    
}


