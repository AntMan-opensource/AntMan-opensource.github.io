package org.jenkinsci.plugins;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.thoughtworks.xstream.converters.ConversionException;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import hudson.Extension;
import hudson.ProxyConfiguration;
import hudson.Util;
import hudson.model.Descriptor;
import hudson.model.User;
import hudson.security.GroupDetails;
import hudson.security.SecurityRealm;
import hudson.security.UserMayOrMayNotExistException;
import hudson.tasks.Mailer;
import hudson.util.Secret;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import javax.servlet.http.HttpSession;
import jenkins.model.Jenkins;
import jenkins.security.SecurityListener;
import org.acegisecurity.Authentication;
import org.acegisecurity.AuthenticationException;
import org.acegisecurity.AuthenticationManager;
import org.acegisecurity.BadCredentialsException;
import org.acegisecurity.context.SecurityContextHolder;
import org.acegisecurity.providers.UsernamePasswordAuthenticationToken;
import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.userdetails.UserDetailsService;
import org.acegisecurity.userdetails.UsernameNotFoundException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.NameValuePair;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.client.utils.URLEncodedUtils;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;
import org.gitlab4j.api.Constants.TokenType;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.models.Group;
import org.jfree.util.Log;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.Header;
import org.kohsuke.stapler.HttpRedirect;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.HttpResponses;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.DataRetrievalFailureException;
public class GitLabSecurityRealm extends SecurityRealm implements UserDetailsService {
    private String gitlabWebUri;
    private String gitlabApiUri;
    private String clientID;
    private Secret clientSecret;
    public GitLabSecurityRealm(String gitlabWebUri, String gitlabApiUri, String clientID, String clientSecret) {
        this.gitlabWebUri = Util.fixEmptyAndTrim(gitlabWebUri);
        this.gitlabApiUri = Util.fixEmptyAndTrim(gitlabApiUri);
        this.clientID = Util.fixEmptyAndTrim(clientID);
        setClientSecret(Util.fixEmptyAndTrim(clientSecret));
    }
    
    private GitLabSecurityRealm() {
    }
    
    private void setGitlabWebUri(String gitlabWebUri) {
        this.gitlabWebUri = gitlabWebUri;
    }
    
    private void setClientID(String clientID) {
        this.clientID = clientID;
    }
    
    private void setClientSecret(String clientSecret) {
        this.clientSecret = Secret.fromString(clientSecret);
    }
    
    public String getGitlabApiUri() {
        return gitlabApiUri;
    }
    
    private void setGitlabApiUri(String gitlabApiUri) {
        this.gitlabApiUri = gitlabApiUri;
    }
    
    public static final class ConverterImpl implements Converter {
        public boolean canConvert(Class type) {
            return type == GitLabSecurityRealm.class;
        }
        
        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
            GitLabSecurityRealm realm = (GitLabSecurityRealm) source;
            writer.startNode("gitlabWebUri");
            writer.setValue(realm.getGitlabWebUri());
            writer.endNode();
            writer.startNode("gitlabApiUri");
            writer.setValue(realm.getGitlabApiUri());
            writer.endNode();
            writer.startNode("clientID");
            writer.setValue(realm.getClientID());
            writer.endNode();
            writer.startNode("clientSecret");
            writer.setValue(realm.clientSecret.getEncryptedValue());
            writer.endNode();
        }
        
        public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
            GitLabSecurityRealm realm = new GitLabSecurityRealm();
            String node;
            String value;
            while (reader.hasMoreChildren()) {
                reader.moveDown();
                node = reader.getNodeName();
                value = reader.getValue();
                setValue(realm, node, value);
                reader.moveUp();
            }
            
            return realm;
        }
        
        private void setValue(GitLabSecurityRealm realm, String node, String value) {
            switch (node.toLowerCase()) {
                case "clientid":
                    realm.setClientID(value);
                    break;
                case "clientsecret":
                    realm.setClientSecret(value);
                    break;
                case "gitlabweburi":
                    realm.setGitlabWebUri(value);
                    break;
                case "gitlabapiuri":
                    realm.setGitlabApiUri(value);
                    break;
                default: throw new ConversionException("Invalid node value = " + node);
            }
            
        }
        
    }
    
    public String getGitlabWebUri() {
        return gitlabWebUri;
    }
    
    public String getClientID() {
        return clientID;
    }
    
    public Secret getClientSecret() {
        return clientSecret;
    }
    
    public HttpResponse doCommenceLogin(StaplerRequest request, @QueryParameter String from, @Header("Referer") final String referer) throws IOException {
        String redirectOnFinish;
        if (from != null && Util.isSafeToRedirectTo(from)) {
            redirectOnFinish = from;
        }
         else if (referer != null && (referer.startsWith(Jenkins.get().getRootUrl()) || Util.isSafeToRedirectTo(referer))) {
            redirectOnFinish = referer;
        }
         else {
            redirectOnFinish = Jenkins.get().getRootUrl();
        }
        
        request.getSession().setAttribute(REFERER_ATTRIBUTE, redirectOnFinish);
        List<NameValuePair> parameters = new ArrayList<>();
        parameters.add(new BasicNameValuePair("redirect_uri", buildRedirectUrl(request)));
        parameters.add(new BasicNameValuePair("response_type", "code"));
        parameters.add(new BasicNameValuePair("client_id", clientID));
        parameters.add(new BasicNameValuePair("scope", "api"));
        return new HttpRedirect(gitlabWebUri + "/oauth/authorize?" + URLEncodedUtils.format(parameters, StandardCharsets.UTF_8));
    }
    
    private String buildRedirectUrl(StaplerRequest request) throws MalformedURLException {
        URL currentUrl = new URL(Jenkins.get().getRootUrl());
        URL redirect_uri = new URL(currentUrl.getProtocol(), currentUrl.getHost(), currentUrl.getPort(), request.getContextPath() + "/securityRealm/finishLogin");
        return redirect_uri.toString();
    }
    
    public HttpResponse doFinishLogin(StaplerRequest request) throws IOException {
        String code = request.getParameter("code");
        if (StringUtils.isBlank(code)) {
            Log.info("doFinishLogin: missing code or private_token.");
            return HttpResponses.redirectToContextRoot();
        }
        
        if (clientSecret == null) {
            Log.info("doFinishLogin: missing client secret.");
            return HttpResponses.redirectToContextRoot();
        }
        
        String referer = (String) request.getSession().getAttribute(REFERER_ATTRIBUTE);
        HttpPost httpPost = new HttpPost(gitlabWebUri + "/oauth/token");
        List<NameValuePair> parameters = new ArrayList<>();
        parameters.add(new BasicNameValuePair("client_id", clientID));
        parameters.add(new BasicNameValuePair("client_secret", clientSecret.getPlainText()));
        parameters.add(new BasicNameValuePair("code", code));
        parameters.add(new BasicNameValuePair("grant_type", "authorization_code"));
        parameters.add(new BasicNameValuePair("redirect_uri", buildRedirectUrl(request)));
        httpPost.setEntity(new UrlEncodedFormEntity(parameters, StandardCharsets.UTF_8));
        CloseableHttpClient httpclient = HttpClients.createDefault();
        HttpHost proxy = getProxy(httpPost);
        if (proxy != null) {
            RequestConfig config = RequestConfig.custom() .setProxy(proxy) .build();
            httpPost.setConfig(config);
        }
        
        org.apache.http.HttpResponse response = httpclient.execute(httpPost);
        HttpEntity entity = response.getEntity();
        String content = EntityUtils.toString(entity);
        httpclient.close();
        String accessToken = extractToken(content);
        if (StringUtils.isNotBlank(accessToken)) {
          try {
            GitLabAuthenticationToken auth = new GitLabAuthenticationToken(accessToken, getGitlabApiUri(), TokenType.OAUTH2_ACCESS);
            HttpSession session = request.getSession(false);
            if (session != null) {
                session.invalidate();
            }
            
            request.getSession(true);
            SecurityContextHolder.getContext().setAuthentication(auth);
            org.gitlab4j.api.models.User self = auth.getMyself();
            User user = User.current();
            if (user != null) {
                user.setFullName(self.getName());
                if (!user.getProperty(Mailer.UserProperty.class).hasExplicitlyConfiguredAddress()) {
                    user.addProperty(new Mailer.UserProperty(auth.getMyself().getEmail()));
                }
                
            }
            
            SecurityListener.fireAuthenticated(new GitLabOAuthUserDetails(self, auth.getAuthorities()));
          }
           catch (GitLabApiException e) {
            throw new RuntimeException(e);
          }
          
        }
         else {
            Log.info("GitLab did not return an access token.");
        }
        
        if (StringUtils.isNotBlank(referer)) {
            return HttpResponses.redirectTo(referer);
        }
        
        return HttpResponses.redirectToContextRoot();
    }
    
    private HttpHost getProxy(HttpUriRequest method) {
        Jenkins jenkins = Jenkins.get();
        ProxyConfiguration proxy = jenkins.proxy;
        if (proxy == null) {
            return null; 
        }
        
        Proxy p = proxy.createProxy(method.getURI().getHost());
        switch (p.type()) {
            case DIRECT:
                return null; 
            case HTTP:
                InetSocketAddress sa = (InetSocketAddress) p.address();
                return new HttpHost(sa.getHostName(), sa.getPort());
            case SOCKS:
            default: return null; 
        }
        
    }
    
    private String extractToken(String content) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode jsonTree = mapper.readTree(content);
            JsonNode node = jsonTree.get("access_token");
            if (node != null) {
                return node.asText();
            }
            
        }
         catch (IOException e) {
            Log.error(e.getMessage(), e);
        }
        
        return null;
    }
    
    public boolean allowsSignup() {
        return false;
    }
    
    public SecurityComponents createSecurityComponents() {
        return new SecurityComponents(new AuthenticationManager() { 

            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                if (authentication instanceof GitLabAuthenticationToken) {
                    return authentication;
                }
                
                if (authentication instanceof UsernamePasswordAuthenticationToken) {
                    try {
                        UsernamePasswordAuthenticationToken token = (UsernamePasswordAuthenticationToken) authentication;
                        GitLabAuthenticationToken gitlab = new GitLabAuthenticationToken(token.getCredentials().toString(), getGitlabApiUri(), TokenType.PRIVATE);
                        SecurityContextHolder.getContext().setAuthentication(gitlab);
                        return gitlab;
                    }
                     catch (GitLabApiException e) {
                        throw new RuntimeException(e);
                    }
                    
                }
                
                throw new BadCredentialsException("Unexpected authentication type: " + authentication);
            }
            
        }, new UserDetailsService() {
            public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {
                return GitLabSecurityRealm.this.loadUserByUsername(username);
            }
            
        }
        
);
    }
    
    public String getLoginUrl() {
        return "securityRealm/commenceLogin";
    }
    
    protected String getPostLogOutUrl(StaplerRequest req, Authentication auth) {
        Jenkins jenkins = Jenkins.get();
        if (jenkins.hasPermission(Jenkins.READ)) {
            return req.getContextPath() + "/";
        }
        
        return req.getContextPath() + "/" + GitLabLogoutAction.POST_LOGOUT_URL;
    }
    
    public static final class DescriptorImpl extends Descriptor<SecurityRealm> {
        public String getHelpFile() {
            return "/plugin/gitlab-oauth/help/help-security-realm.html";
        }
        
        public String getDisplayName() {
            return "GitLab Authentication Plugin";
        }
        
        public DescriptorImpl() {
        }
        
        public DescriptorImpl(Class<? extends SecurityRealm> clazz) {
            super(clazz);
        }
        
    }
    
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }
    
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {
        GitLabAuthenticationToken authToken;
        if (SecurityContextHolder.getContext().getAuthentication() instanceof GitLabAuthenticationToken) {
            authToken = (GitLabAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();
        }
         else {
            throw new UserMayOrMayNotExistException("Could not get auth token.");
        }
        
        try {
            GitLabOAuthUserDetails userDetails = authToken.getUserDetails(username);
            if (userDetails == null) {
                throw new UsernameNotFoundException("Unknown user: " + username);
            }
            
            Group ghOrg = authToken.loadOrganization(username);
            if (ghOrg != null) {
                throw new UsernameNotFoundException("user(" + username + ") is also an organization");
            }
            
            return userDetails;
        }
         catch (Error e) {
            throw new DataRetrievalFailureException("loadUserByUsername (username=" + username + ")", e);
        }
        
    }
    
    public boolean equals(Object object) {
        if (object instanceof GitLabSecurityRealm) {
            GitLabSecurityRealm obj = (GitLabSecurityRealm) object;
            return this.getGitlabWebUri().equals(obj.getGitlabWebUri()) && this.getGitlabApiUri().equals(obj.getGitlabApiUri()) && this.getClientID().equals(obj.getClientID()) && this.clientSecret.equals(obj.clientSecret);
        }
         else {
            return false;
        }
        
    }
    
    public int hashCode() {
        return HashCodeBuilder.reflectionHashCode(this, false);
    }
    
    public GroupDetails loadGroupByGroupname(String groupName) throws UsernameNotFoundException, DataAccessException {
        GitLabAuthenticationToken authToken = (GitLabAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();
        if (authToken == null) {
            throw new UsernameNotFoundException("No known group: " + groupName);
        }
        
        Group gitlabGroup = authToken.loadOrganization(groupName);
        return new GitLabOAuthGroupDetails(gitlabGroup);
    }
    
    private static final Logger LOGGER = Logger.getLogger(GitLabSecurityRealm.class.getName());
    private static final String REFERER_ATTRIBUTE = GitLabSecurityRealm.class.getName() + ".referer";
}


