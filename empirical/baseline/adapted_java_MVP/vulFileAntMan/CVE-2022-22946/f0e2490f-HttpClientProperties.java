package org.springframework.cloud.gateway.config;
import java.io.IOException;
import java.net.URL;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchProviderException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.net.ssl.KeyManagerFactory;
import javax.validation.constraints.Max;
import reactor.netty.resources.ConnectionProvider;
import reactor.netty.tcp.SslProvider;
import reactor.netty.transport.ProxyProvider;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.server.WebServerException;
import org.springframework.core.style.ToStringCreator;
import org.springframework.util.ResourceUtils;
import org.springframework.util.unit.DataSize;
import org.springframework.validation.annotation.Validated;
public class HttpClientProperties {
	 private Integer connectTimeout;
	 private Duration responseTimeout;
	 private DataSize maxHeaderSize;
	 private DataSize maxInitialLineLength;
	 private Pool pool = new Pool();
	 private Proxy proxy = new Proxy();
	 private Ssl ssl = new Ssl();
	 private Websocket websocket = new Websocket();
	 private boolean wiretap;
	 private boolean compression;
	public Integer getConnectTimeout() {
		return connectTimeout;
	}
	
	public void setConnectTimeout(Integer connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	
	public Duration getResponseTimeout() {
		return responseTimeout;
	}
	
	public void setResponseTimeout(Duration responseTimeout) {
		this.responseTimeout = responseTimeout;
	}
	
	public DataSize getMaxHeaderSize() {
		return maxHeaderSize;
	}
	
	public void setMaxHeaderSize(DataSize maxHeaderSize) {
		this.maxHeaderSize = maxHeaderSize;
	}
	
	public DataSize getMaxInitialLineLength() {
		return maxInitialLineLength;
	}
	
	public void setMaxInitialLineLength(DataSize maxInitialLineLength) {
		this.maxInitialLineLength = maxInitialLineLength;
	}
	
	public Pool getPool() {
		return pool;
	}
	
	public void setPool(Pool pool) {
		this.pool = pool;
	}
	
	public Proxy getProxy() {
		return proxy;
	}
	
	public void setProxy(Proxy proxy) {
		this.proxy = proxy;
	}
	
	public Ssl getSsl() {
		return ssl;
	}
	
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	
	public Websocket getWebsocket() {
		return this.websocket;
	}
	
	public void setWebsocket(Websocket websocket) {
		this.websocket = websocket;
	}
	
	public boolean isWiretap() {
		return this.wiretap;
	}
	
	public void setWiretap(boolean wiretap) {
		this.wiretap = wiretap;
	}
	
	public boolean isCompression() {
		return compression;
	}
	
	public void setCompression(boolean compression) {
		this.compression = compression;
	}
	
	public String toString() {
		 return new ToStringCreator(this) .append("connectTimeout", connectTimeout) .append("responseTimeout", responseTimeout) .append("maxHeaderSize", maxHeaderSize) .append("maxInitialLineLength", maxInitialLineLength) .append("pool", pool) .append("proxy", proxy) .append("ssl", ssl) .append("websocket", websocket) .append("wiretap", wiretap) .append("compression", compression) .toString();
		 }
		 
	public static class Pool {
		 private PoolType type = PoolType.ELASTIC;
		 private String name = "proxy";
		 private Integer maxConnections = ConnectionProvider.DEFAULT_POOL_MAX_CONNECTIONS;
		 private Long acquireTimeout = ConnectionProvider.DEFAULT_POOL_ACQUIRE_TIMEOUT;
		 private Duration maxIdleTime = null;
		 private Duration maxLifeTime = null;
		 private Duration evictionInterval = Duration.ZERO;
		 private boolean metrics = false;
		public PoolType getType() {
			return type;
		}
		
		public void setType(PoolType type) {
			this.type = type;
		}
		
		public String getName() {
			return name;
		}
		
		public void setName(String name) {
			this.name = name;
		}
		
		public Integer getMaxConnections() {
			return maxConnections;
		}
		
		public void setMaxConnections(Integer maxConnections) {
			this.maxConnections = maxConnections;
		}
		
		public Long getAcquireTimeout() {
			return acquireTimeout;
		}
		
		public void setAcquireTimeout(Long acquireTimeout) {
			this.acquireTimeout = acquireTimeout;
		}
		
		public Duration getMaxIdleTime() {
			return maxIdleTime;
		}
		
		public void setMaxIdleTime(Duration maxIdleTime) {
			this.maxIdleTime = maxIdleTime;
		}
		
		public Duration getMaxLifeTime() {
			return maxLifeTime;
		}
		
		public void setMaxLifeTime(Duration maxLifeTime) {
			this.maxLifeTime = maxLifeTime;
		}
		
		public Duration getEvictionInterval() {
			return evictionInterval;
		}
		
		public void setEvictionInterval(Duration evictionInterval) {
			this.evictionInterval = evictionInterval;
		}
		
		public boolean isMetrics() {
			return metrics;
		}
		
		public void setMetrics(boolean metrics) {
			this.metrics = metrics;
		}
		
		public String toString() {
			return "Pool{" + "type=" + type + ", name='" + name + '\'' + ", maxConnections=" + maxConnections + ", acquireTimeout=" + acquireTimeout + ", maxIdleTime=" + maxIdleTime + ", maxLifeTime=" + maxLifeTime + ", evictionInterval=" + evictionInterval + ", metrics=" + metrics + '}';
		}
		
		public enum PoolType {
			 ELASTIC, FIXED, DISABLED }
	}
	
	public static class Proxy {
		 private ProxyProvider.Proxy type = ProxyProvider.Proxy.HTTP;
		 private String host;
		 private Integer port;
		 private String username;
		 private String password;
		 private String nonProxyHostsPattern;
		public ProxyProvider.Proxy getType() {
			return type;
		}
		
		public void setType(ProxyProvider.Proxy type) {
			this.type = type;
		}
		
		public String getHost() {
			return host;
		}
		
		public void setHost(String host) {
			this.host = host;
		}
		
		public Integer getPort() {
			return port;
		}
		
		public void setPort(Integer port) {
			this.port = port;
		}
		
		public String getUsername() {
			return username;
		}
		
		public void setUsername(String username) {
			this.username = username;
		}
		
		public String getPassword() {
			return password;
		}
		
		public void setPassword(String password) {
			this.password = password;
		}
		
		public String getNonProxyHostsPattern() {
			return nonProxyHostsPattern;
		}
		
		public void setNonProxyHostsPattern(String nonProxyHostsPattern) {
			this.nonProxyHostsPattern = nonProxyHostsPattern;
		}
		
		public String toString() {
			return "Proxy{" + "type='" + type + '\'' + "host='" + host + '\'' + ", port=" + port + ", username='" + username + '\'' + ", password='" + password + '\'' + ", nonProxyHostsPattern='" + nonProxyHostsPattern + '\'' + '}';
		}
		
	}
	
	public static class Ssl {
		 private boolean useInsecureTrustManager = false;
		 private List<String> trustedX509Certificates = new ArrayList<>();
		 private Duration handshakeTimeout = Duration.ofMillis(10000);
		 private Duration closeNotifyFlushTimeout = Duration.ofMillis(3000);
		 private Duration closeNotifyReadTimeout = Duration.ZERO;
		private SslProvider.DefaultConfigurationType defaultConfigurationType = SslProvider.DefaultConfigurationType.TCP;
		 private String keyStore;
		 private String keyStoreType = "JKS";
		 private String keyStoreProvider;
		 private String keyStorePassword;
		 private String keyPassword;
		public String getKeyStorePassword() {
			return keyStorePassword;
		}
		
		public void setKeyStorePassword(String keyStorePassword) {
			this.keyStorePassword = keyStorePassword;
		}
		
		public String getKeyStoreType() {
			return keyStoreType;
		}
		
		public void setKeyStoreType(String keyStoreType) {
			this.keyStoreType = keyStoreType;
		}
		
		public String getKeyStoreProvider() {
			return keyStoreProvider;
		}
		
		public void setKeyStoreProvider(String keyStoreProvider) {
			this.keyStoreProvider = keyStoreProvider;
		}
		
		public String getKeyStore() {
			return keyStore;
		}
		
		public void setKeyStore(String keyStore) {
			this.keyStore = keyStore;
		}
		
		public String getKeyPassword() {
			return keyPassword;
		}
		
		public void setKeyPassword(String keyPassword) {
			this.keyPassword = keyPassword;
		}
		
		public List<String> getTrustedX509Certificates() {
			return trustedX509Certificates;
		}
		
		public void setTrustedX509Certificates(List<String> trustedX509) {
			this.trustedX509Certificates = trustedX509;
		}
		
		public X509Certificate[] getTrustedX509CertificatesForTrustManager() {
			try {
				CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
				ArrayList<Certificate> allCerts = new ArrayList<>();
				for (String trustedCert : getTrustedX509Certificates()) {
					try {
						URL url = ResourceUtils.getURL(trustedCert);
						Collection<? extends Certificate> certs = certificateFactory .generateCertificates(url.openStream());
						allCerts.addAll(certs);
					}
					
					catch (IOException e) {
						throw new WebServerException("Could not load certificate '" + trustedCert + "'", e);
					}
					
				}
				
				return allCerts.toArray(new X509Certificate[allCerts.size()]);
			}
			
			catch (CertificateException e1) {
				throw new WebServerException("Could not load CertificateFactory X.509", e1);
			}
			
		}
		
		public KeyManagerFactory getKeyManagerFactory() {
			try {
				if (getKeyStore() != null && getKeyStore().length() > 0) {
					KeyManagerFactory keyManagerFactory = KeyManagerFactory .getInstance(KeyManagerFactory.getDefaultAlgorithm());
					char[] keyPassword = getKeyPassword() != null ? getKeyPassword().toCharArray() : null;
					if (keyPassword == null && getKeyStorePassword() != null) {
						keyPassword = getKeyStorePassword().toCharArray();
					}
					
					keyManagerFactory.init(this.createKeyStore(), keyPassword);
					return keyManagerFactory;
				}
				
				return null;
			}
			
			catch (Exception e) {
				throw new IllegalStateException(e);
			}
			
		}
		
		public KeyStore createKeyStore() {
			try {
				KeyStore store = getKeyStoreProvider() != null ? KeyStore.getInstance(getKeyStoreType(), getKeyStoreProvider()) : KeyStore.getInstance(getKeyStoreType());
				try {
					URL url = ResourceUtils.getURL(getKeyStore());
					store.load(url.openStream(), getKeyStorePassword() != null ? getKeyStorePassword().toCharArray() : null);
				}
				
				catch (Exception e) {
					throw new WebServerException("Could not load key store ' " + getKeyStore() + "'", e);
				}
				
				return store;
			}
			
			catch (KeyStoreException | NoSuchProviderException e) {
				throw new WebServerException("Could not load KeyStore for given type and provider", e);
			}
			
		}
		
		 public boolean isUseInsecureTrustManager() {
			return useInsecureTrustManager;
		}
		
		public void setUseInsecureTrustManager(boolean useInsecureTrustManager) {
			this.useInsecureTrustManager = useInsecureTrustManager;
		}
		
		public Duration getHandshakeTimeout() {
			return handshakeTimeout;
		}
		
		public void setHandshakeTimeout(Duration handshakeTimeout) {
			this.handshakeTimeout = handshakeTimeout;
		}
		
		public Duration getCloseNotifyFlushTimeout() {
			return closeNotifyFlushTimeout;
		}
		
		public void setCloseNotifyFlushTimeout(Duration closeNotifyFlushTimeout) {
			this.closeNotifyFlushTimeout = closeNotifyFlushTimeout;
		}
		
		public Duration getCloseNotifyReadTimeout() {
			return closeNotifyReadTimeout;
		}
		
		public void setCloseNotifyReadTimeout(Duration closeNotifyReadTimeout) {
			this.closeNotifyReadTimeout = closeNotifyReadTimeout;
		}
		
		public SslProvider.DefaultConfigurationType getDefaultConfigurationType() {
			return defaultConfigurationType;
		}
		
		public void setDefaultConfigurationType(SslProvider.DefaultConfigurationType defaultConfigurationType) {
			this.defaultConfigurationType = defaultConfigurationType;
		}
		
		public String toString() {
			return new ToStringCreator(this).append("useInsecureTrustManager", useInsecureTrustManager) .append("trustedX509Certificates", trustedX509Certificates) .append("handshakeTimeout", handshakeTimeout) .append("closeNotifyFlushTimeout", closeNotifyFlushTimeout) .append("closeNotifyReadTimeout", closeNotifyReadTimeout) .append("defaultConfigurationType", defaultConfigurationType).toString();
		}
		
	}
	
	public static class Websocket {
		 private Integer maxFramePayloadLength;
		 private boolean proxyPing = true;
		public Integer getMaxFramePayloadLength() {
			return this.maxFramePayloadLength;
		}
		
		public void setMaxFramePayloadLength(Integer maxFramePayloadLength) {
			this.maxFramePayloadLength = maxFramePayloadLength;
		}
		
		public boolean isProxyPing() {
			return proxyPing;
		}
		
		public void setProxyPing(boolean proxyPing) {
			this.proxyPing = proxyPing;
		}
		
		public String toString() {
			return new ToStringCreator(this).append("maxFramePayloadLength", maxFramePayloadLength) .append("proxyPing", proxyPing).toString();
		}
		
	}
	
}


