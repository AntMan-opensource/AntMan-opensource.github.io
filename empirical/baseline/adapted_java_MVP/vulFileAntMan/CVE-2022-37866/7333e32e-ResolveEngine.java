package org.apache.ivy.core.resolve;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import org.apache.ivy.Ivy;
import org.apache.ivy.core.IvyContext;
import org.apache.ivy.core.LogOptions;
import org.apache.ivy.core.cache.ArtifactOrigin;
import org.apache.ivy.core.cache.ResolutionCacheManager;
import org.apache.ivy.core.event.EventManager;
import org.apache.ivy.core.event.download.PrepareDownloadEvent;
import org.apache.ivy.core.event.resolve.EndResolveEvent;
import org.apache.ivy.core.event.resolve.StartResolveEvent;
import org.apache.ivy.core.module.descriptor.Artifact;
import org.apache.ivy.core.module.descriptor.Configuration;
import org.apache.ivy.core.module.descriptor.DefaultDependencyDescriptor;
import org.apache.ivy.core.module.descriptor.DefaultModuleDescriptor;
import org.apache.ivy.core.module.descriptor.DependencyDescriptor;
import org.apache.ivy.core.module.descriptor.ModuleDescriptor;
import org.apache.ivy.core.module.id.ModuleId;
import org.apache.ivy.core.module.id.ModuleRevisionId;
import org.apache.ivy.core.report.ArtifactDownloadReport;
import org.apache.ivy.core.report.ConfigurationResolveReport;
import org.apache.ivy.core.report.DownloadReport;
import org.apache.ivy.core.report.DownloadStatus;
import org.apache.ivy.core.report.ResolveReport;
import org.apache.ivy.core.resolve.IvyNodeEviction.EvictionData;
import org.apache.ivy.core.settings.IvySettings;
import org.apache.ivy.core.sort.SortEngine;
import org.apache.ivy.core.sort.SortOptions;
import org.apache.ivy.plugins.conflict.ConflictManager;
import org.apache.ivy.plugins.parser.ModuleDescriptorParser;
import org.apache.ivy.plugins.parser.ModuleDescriptorParserRegistry;
import org.apache.ivy.plugins.repository.url.URLResource;
import org.apache.ivy.plugins.resolver.DependencyResolver;
import org.apache.ivy.plugins.version.VersionMatcher;
import org.apache.ivy.util.Message;
import org.apache.ivy.util.filter.Filter;
public class ResolveEngine {
    private ResolveEngineSettings settings;
    private EventManager eventManager;
    private SortEngine sortEngine;
    private DependencyResolver dictatorResolver;
    public ResolveEngine(ResolveEngineSettings settings, EventManager eventManager, SortEngine sortEngine) {
        this.settings = settings;
        this.eventManager = eventManager;
        this.sortEngine = sortEngine;
    }
    
    public DependencyResolver getDictatorResolver() {
        return dictatorResolver;
    }
    
    public void setDictatorResolver(DependencyResolver dictatorResolver) {
        this.dictatorResolver = dictatorResolver;
    }
    
    public ResolveReport resolve(File ivySource) throws ParseException, IOException {
        return resolve(ivySource.toURI().toURL());
    }
    
    public ResolveReport resolve(URL ivySource) throws ParseException, IOException {
        return resolve(ivySource, new ResolveOptions());
    }
    
    public ResolveReport resolve(final ModuleRevisionId mrid, ResolveOptions options, boolean changing) throws ParseException, IOException {
        DefaultModuleDescriptor md;
        ResolveOptions optionsToUse = new ResolveOptions(options);
        if (options.useSpecialConfs()) {
            ResolvedModuleRevision rmr = findModule(mrid, new ResolveOptions(options));
            if (rmr == null) {
                Message.verbose("module not found " + mrid);
                optionsToUse.setLog(LogOptions.LOG_DOWNLOAD_ONLY);
                md = DefaultModuleDescriptor.newCallerInstance(mrid, new String[] {"default"}, options.isTransitive(), changing);
            }
             else {
                String[] confs = options.getConfs(rmr.getDescriptor());
                md = DefaultModuleDescriptor.newCallerInstance( ModuleRevisionId.newInstance(mrid, rmr.getId().getRevision()), confs, options.isTransitive(), changing);
            }
            
        }
         else {
            md = DefaultModuleDescriptor.newCallerInstance(mrid, options.getConfs(), options.isTransitive(), changing);
        }
        
        return resolve(md, optionsToUse);
    }
    
    public ResolveReport resolve(URL ivySource, ResolveOptions options) throws ParseException, IOException {
        URLResource res = new URLResource(ivySource);
        ModuleDescriptorParser parser = ModuleDescriptorParserRegistry.getInstance().getParser(res);
        Message.verbose("using " + parser + " to parse " + ivySource);
        ModuleDescriptor md = parser.parseDescriptor(settings, ivySource, options.isValidate());
        String revision = options.getRevision();
        if (revision == null && md.getResolvedModuleRevisionId().getRevision() == null) {
            revision = Ivy.getWorkingRevision();
        }
        
        if (revision != null) {
            md.setResolvedModuleRevisionId(ModuleRevisionId.newInstance(md.getModuleRevisionId(), revision));
        }
        
        return resolve(md, options);
    }
    
    public ResolveReport resolve(ModuleDescriptor md, ResolveOptions options) throws ParseException, IOException {
        DependencyResolver oldDictator = getDictatorResolver();
        IvyContext context = IvyContext.getContext();
        try {
            String[] confs = options.getConfs(md);
            options.setConfs(confs);
            if (options.getResolveId() == null) {
                options.setResolveId(ResolveOptions.getDefaultResolveId(md));
            }
            
            eventManager.fireIvyEvent(new StartResolveEvent(md, confs));
            long start = System.currentTimeMillis();
            if (ResolveOptions.LOG_DEFAULT.equals(options.getLog())) {
                Message.info(":: resolving dependencies :: " + md.getResolvedModuleRevisionId() + (options.isTransitive() ? "" : " [not transitive]"));
                Message.info("\tconfs: " + Arrays.asList(confs));
            }
             else {
                Message.verbose(":: resolving dependencies :: " + md.getResolvedModuleRevisionId() + (options.isTransitive() ? "" : " [not transitive]"));
                Message.verbose("\tconfs: " + Arrays.asList(confs));
            }
            
            Message.verbose("\tvalidate = " + options.isValidate());
            Message.verbose("\trefresh = " + options.isRefresh());
            ResolveReport report = new ResolveReport(md, options.getResolveId());
            ResolveData data = new ResolveData(this, options);
            context.setResolveData(data);
            IvyNode[] dependencies = getDependencies(md, options, report);
            report.setDependencies(Arrays.asList(dependencies), options.getArtifactFilter());
            if (options.getCheckIfChanged()) {
                report.checkIfChanged();
            }
            
            ResolutionCacheManager cacheManager = settings.getResolutionCacheManager();
            cacheManager.saveResolvedModuleDescriptor(md);
            File ivyPropertiesInCache = cacheManager.getResolvedIvyPropertiesInCache(md .getResolvedModuleRevisionId());
            Properties props = new Properties();
            if (dependencies.length > 0) {
                Map<ModuleId, ModuleRevisionId> forcedRevisions = new HashMap<>();
                for (IvyNode dependency : dependencies) {
                    if (dependency.getModuleRevision() != null && dependency.getModuleRevision().isForce()) {
                        forcedRevisions.put(dependency.getModuleId(), dependency.getResolvedId());
                    }
                    
                }
                
                IvyNode root = dependencies[0].getRoot();
                Map<ModuleId, IvyNode> topLevelDeps = new HashMap<>();
                for (IvyNode dependency : dependencies) {
                    if (!dependency.hasProblem()) {
                        DependencyDescriptor dd = dependency.getDependencyDescriptor(root);
                        if (dd != null) {
                            ModuleId orgMod = dependency.getModuleId();
                            topLevelDeps.put(orgMod, dependency);
                        }
                        
                    }
                    
                }
                
                for (IvyNode dependency : dependencies) {
                    if (!dependency.hasProblem() && !dependency.isCompletelyEvicted()) {
                        DependencyDescriptor dd = dependency.getDependencyDescriptor(root);
                        if (dd == null) {
                            ModuleId mid = dependency.getModuleId();
                            IvyNode tlDep = topLevelDeps.get(mid);
                            if (tlDep != null) {
                                dd = tlDep.getDependencyDescriptor(root);
                            }
                            
                        }
                        
                        if (dd != null) {
                            ModuleRevisionId depResolvedId = dependency.getResolvedId();
                            ModuleDescriptor depDescriptor = dependency.getDescriptor();
                            ModuleRevisionId depRevisionId = dd.getDependencyRevisionId();
                            ModuleRevisionId forcedRevisionId = forcedRevisions.get(dependency .getModuleId());
                            if (dependency.getModuleRevision() != null && dependency.getModuleRevision().isForce() && !depResolvedId.equals(depRevisionId) && !settings.getVersionMatcher().isDynamic(depRevisionId)) {
                                depResolvedId = depRevisionId;
                                depDescriptor = null;
                            }
                            
                            if (depResolvedId == null) {
                                throw new NullPointerException("getResolvedId() is null for " + dependency.toString());
                            }
                            
                            if (depRevisionId == null) {
                                throw new NullPointerException("getDependencyRevisionId() " + "is null for " + dd.toString());
                            }
                            
                            String rev = depResolvedId.getRevision();
                            String forcedRev = forcedRevisionId == null ? rev : forcedRevisionId .getRevision();
                            String status = depDescriptor == null ? "?" : depDescriptor.getStatus();
                            Message.debug("storing dependency " + depResolvedId + " in props");
                            props.put(depRevisionId.encodeToString(), rev + " " + status + " " + forcedRev + " " + depResolvedId.getBranch());
                        }
                        
                    }
                    
                }
                
            }
            
            FileOutputStream out = new FileOutputStream(ivyPropertiesInCache);
            props.store(out, md.getResolvedModuleRevisionId() + " resolved revisions");
            out.close();
            Message.verbose("\tresolved ivy file produced in cache");
            report.setResolveTime(System.currentTimeMillis() - start);
            if (options.isDownload()) {
                Message.verbose(":: downloading artifacts ::");
                DownloadOptions downloadOptions = new DownloadOptions();
                downloadOptions.setLog(options.getLog());
                downloadArtifacts(report, options.getArtifactFilter(), downloadOptions);
            }
            
            if (options.isOutputReport()) {
                outputReport(report, cacheManager, options);
            }
            
            Message.verbose("\tresolve done (" + report.getResolveTime() + "ms resolve - " + report.getDownloadTime() + "ms download)");
            Message.sumupProblems();
            eventManager.fireIvyEvent(new EndResolveEvent(md, confs, report));
            return report;
        }
         catch (RuntimeException ex) {
            Message.debug(ex);
            Message.error(ex.getMessage());
            Message.sumupProblems();
            throw ex;
        }
         finally {
            context.setResolveData(null);
            setDictatorResolver(oldDictator);
        }
        
    }
    
    public void outputReport(ResolveReport report, ResolutionCacheManager cacheMgr, ResolveOptions options) throws IOException {
        if (ResolveOptions.LOG_DEFAULT.equals(options.getLog())) {
            Message.info(":: resolution report :: resolve " + report.getResolveTime() + "ms" + " :: artifacts dl " + report.getDownloadTime() + "ms");
        }
         else {
            Message.verbose(":: resolution report :: resolve " + report.getResolveTime() + "ms" + " :: artifacts dl " + report.getDownloadTime() + "ms");
        }
        
        report.setProblemMessages(Message.getProblems());
        report.output(settings.getReportOutputters(), cacheMgr, options);
    }
    
    public void downloadArtifacts(ResolveReport report, Filter<Artifact> artifactFilter, DownloadOptions options) {
        long start = System.currentTimeMillis();
        eventManager.fireIvyEvent(new PrepareDownloadEvent(report.getArtifacts().toArray( new Artifact[report.getArtifacts().size()])));
        long totalSize = 0;
        for (IvyNode dependency : report.getDependencies()) {
            checkInterrupted();
            if (!dependency.isCompletelyEvicted() && !dependency.hasProblem() && dependency.getModuleRevision() != null) {
                DependencyResolver resolver = dependency.getModuleRevision() .getArtifactResolver();
                Artifact[] selectedArtifacts = dependency.getSelectedArtifacts(artifactFilter);
                DownloadReport dReport = resolver.download(selectedArtifacts, options);
                for (ArtifactDownloadReport adr : dReport.getArtifactsReports()) {
                    if (adr.getDownloadStatus() == DownloadStatus.FAILED) {
                        if (adr.getArtifact().getExtraAttribute("ivy:merged") != null) {
                            Message.warn("\tmerged artifact not found: " + adr.getArtifact() + ". It was required in " + adr.getArtifact().getExtraAttribute("ivy:merged"));
                        }
                         else {
                            Message.warn("\t" + adr);
                            resolver.reportFailure(adr.getArtifact());
                        }
                        
                    }
                     else if (adr.getDownloadStatus() == DownloadStatus.SUCCESSFUL) {
                        totalSize += adr.getSize();
                    }
                    
                }
                
                for (String dconf : dependency.getRootModuleConfigurations()) {
                    if (dependency.isEvicted(dconf) || dependency.isBlacklisted(dconf)) {
                        report.getConfigurationReport(dconf).addDependency(dependency);
                    }
                     else {
                        report.getConfigurationReport(dconf).addDependency(dependency, dReport);
                    }
                    
                }
                
            }
            
        }
        
        report.setDownloadTime(System.currentTimeMillis() - start);
        report.setDownloadSize(totalSize);
    }
    
    public ArtifactDownloadReport download(Artifact artifact, DownloadOptions options) {
        DependencyResolver resolver = settings.getResolver(artifact.getModuleRevisionId());
        DownloadReport r = resolver.download(new Artifact[] {artifact}, options);
        return r.getArtifactReport(artifact);
    }
    
    public ArtifactOrigin locate(Artifact artifact) {
        DependencyResolver resolver = settings.getResolver(artifact.getModuleRevisionId());
        return resolver.locate(artifact);
    }
    
    public ArtifactDownloadReport download(ArtifactOrigin origin, DownloadOptions options) {
        DependencyResolver resolver = settings.getResolver(origin.getArtifact() .getModuleRevisionId());
        return resolver.download(origin, options);
    }
    
    public IvyNode[] getDependencies(URL ivySource, ResolveOptions options) throws ParseException, IOException {
        return getDependencies( ModuleDescriptorParserRegistry.getInstance().parseDescriptor(settings, ivySource, options.isValidate()), options, null);
    }
    
    public IvyNode[] getDependencies(ModuleDescriptor md, ResolveOptions options, ResolveReport report) {
        if (md == null) {
            throw new NullPointerException("module descriptor must not be null");
        }
        
        String[] confs = options.getConfs(md);
        Collection<String> missingConfs = new ArrayList<>();
        for (String conf : confs) {
            if (conf == null) {
                throw new NullPointerException("null conf not allowed: confs where: " + Arrays.asList(confs));
            }
            
            if (md.getConfiguration(conf) == null) {
                missingConfs.add(" '" + conf + "' ");
            }
            
        }
        
        if (!missingConfs.isEmpty()) {
            throw new IllegalArgumentException("requested configuration" + (missingConfs.size() > 1 ? "s" : "") + " not found in " + md.getModuleRevisionId() + ": " + missingConfs);
        }
        
        IvyContext context = IvyContext.pushNewCopyContext();
        try {
            options.setConfs(confs);
            Date reportDate = new Date();
            ResolveData data = context.getResolveData();
            if (data == null) {
                data = new ResolveData(this, options);
                context.setResolveData(data);
            }
            
            IvyNode rootNode = new IvyNode(data, md);
            for (String conf : confs) {
                Message.verbose("resolving dependencies for configuration '" + conf + "'");
                ConfigurationResolveReport confReport = null;
                if (report != null) {
                    confReport = report.getConfigurationReport(conf);
                    if (confReport == null) {
                        confReport = new ConfigurationResolveReport(this, md, conf, reportDate, options);
                        report.addReport(conf, confReport);
                    }
                    
                }
                
                data.setReport(confReport);
                VisitNode root = new VisitNode(data, rootNode, null, conf, null);
                root.setRequestedConf(conf);
                rootNode.updateConfsToFetch(Collections.singleton(conf));
                boolean fetched = false;
                while (!fetched) {
                    try {
                        fetchDependencies(root, conf, new HashSet<String>(), false);
                        fetched = true;
                    }
                     catch (RestartResolveProcess restart) {
                        Message.verbose("====================================================");
                        Message.verbose("=           RESTARTING RESOLVE PROCESS");
                        Message.verbose("= " + restart.getMessage());
                        Message.verbose("====================================================");
                    }
                    
                }
                
                for (IvyNode dep : data.getNodes()) {
                    dep.clean();
                }
                
            }
            
            Collection<IvyNode> nodes = data.getNodes();
            Collection<IvyNode> dependencies = new LinkedHashSet<>(nodes.size());
            for (IvyNode node : nodes) {
                if (node != null && !node.isRoot() && !node.isCompletelyBlacklisted()) {
                    dependencies.add(node);
                }
                
            }
            
            List<IvyNode> sortedDependencies = sortEngine.sortNodes(dependencies, SortOptions.SILENT);
            Collections.reverse(sortedDependencies);
            handleTransitiveEviction(md, confs, data, sortedDependencies);
            return dependencies.toArray(new IvyNode[dependencies.size()]);
        }
         finally {
            IvyContext.popContext();
        }
        
    }
    
    private void handleTransitiveEviction(ModuleDescriptor md, String[] confs, ResolveData data, List<IvyNode> sortedDependencies) {
        for (IvyNode node : sortedDependencies) {
            if (!node.isCompletelyEvicted()) {
                for (String conf : confs) {
                    IvyNodeCallers.Caller[] callers = node.getCallers(conf);
                    if (settings.debugConflictResolution()) {
                        Message.debug("checking if " + node.getId() + " is transitively evicted in " + conf);
                    }
                    
                    boolean allEvicted = callers.length > 0;
                    for (IvyNodeCallers.Caller caller : callers) {
                        if (caller.getModuleRevisionId().equals(md.getModuleRevisionId())) {
                            allEvicted = false;
                            break;
                        }
                         else {
                            IvyNode callerNode = data.getNode(caller.getModuleRevisionId());
                            if (callerNode == null) {
                                Message.warn("ivy internal error: no node found for " + caller.getModuleRevisionId() + ": looked in " + data.getNodeIds() + " and root module id was " + md.getModuleRevisionId());
                            }
                             else if (!callerNode.isEvicted(conf)) {
                                allEvicted = false;
                                break;
                            }
                             else {
                                if (settings.debugConflictResolution()) {
                                    Message.debug("caller " + callerNode.getId() + " of " + node.getId() + " is evicted");
                                }
                                
                            }
                            
                        }
                        
                    }
                    
                    if (allEvicted) {
                        Message.verbose("all callers are evicted for " + node + ": evicting too");
                        node.markEvicted(conf, null, null, null);
                    }
                     else {
                        if (settings.debugConflictResolution()) {
                            Message.debug(node.getId() + " isn't transitively evicted, at least one caller was" + " not evicted");
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
    }
    
    private void fetchDependencies(VisitNode node, String conf, Set<String> fetchedSet, boolean shouldBePublic) {
        checkInterrupted();
        long start = System.currentTimeMillis();
        if (node.getParent() != null) {
            Message.verbose("== resolving dependencies " + node.getParent().getId() + "->" + node.getId() + " [" + node.getParentConf() + "->" + conf + "]");
        }
         else {
            Message.verbose("== resolving dependencies for " + node.getId() + " [" + conf + "]");
        }
        
        ResolveData data = node.getNode().getData();
        VisitNode parentVisitNode = data.getCurrentVisitNode();
        data.setCurrentVisitNode(node);
        DependencyDescriptor dd = node.getDependencyDescriptor();
        VersionMatcher versionMatcher = node.getNode().getData().getSettings().getVersionMatcher();
        if (dd != null && !(node.getRoot() == node.getParent() && versionMatcher.isDynamic(dd.getDependencyRevisionId()))) {
            resolveConflict(node, conf);
        }
        
        if (node.loadData(conf, shouldBePublic)) {
            resolveConflict(node, conf);
            if (!node.isEvicted() && !node.isCircular()) {
                for (String rconf : node.getRealConfs(conf)) {
                    doFetchDependencies(node, rconf, fetchedSet);
                }
                
            }
            
        }
         else if (!node.hasProblem()) {
            if (!node.isEvicted() && !node.isCircular()) {
                for (String rconf : node.getRealConfs(conf)) {
                    doFetchDependencies(node, rconf, fetchedSet);
                }
                
            }
            
        }
        
        if (node.isEvicted()) {
            EvictionData ed = node.getEvictedData();
            if (ed.getSelected() != null) {
                for (IvyNode selected : ed.getSelected()) {
                    if (!selected.isLoaded()) {
                        selected.updateConfsToFetch(Collections.singleton(conf));
                    }
                     else {
                        fetchDependencies(node.gotoNode(selected), conf, fetchedSet, true);
                    }
                    
                }
                
            }
            
        }
        
        if (settings.debugConflictResolution()) {
            Message.debug(node.getId() + " => dependencies resolved in " + conf + " (" + (System.currentTimeMillis() - start) + "ms)");
        }
        
        data.setCurrentVisitNode(parentVisitNode);
    }
    
    private void doFetchDependencies(VisitNode node, String conf, Set<String> fetchedSet) {
        Configuration c = node.getConfiguration(conf);
        if (c == null) {
            if (!node.isConfRequiredByMergedUsageOnly(conf)) {
                Message.warn("configuration not found '" + conf + "' in " + node.getResolvedId() + ": ignoring");
                if (node.getParent() != null) {
                    Message.warn("it was required from " + node.getParent().getResolvedId());
                }
                
            }
            
            return;
        }
        
        boolean requestedConfSet = false;
        if (node.getRequestedConf() == null) {
            node.setRequestedConf(conf);
            requestedConfSet = true;
        }
        
        String[] extendedConfs = c.getExtends();
        if (extendedConfs.length > 0) {
            node.updateConfsToFetch(Arrays.asList(extendedConfs));
        }
        
        for (String extendedConf : extendedConfs) {
            fetchDependencies(node, extendedConf, fetchedSet, false);
        }
        
        if (!isDependenciesFetched(node.getNode(), conf, fetchedSet) && node.isTransitive()) {
            for (VisitNode dep : node.getDependencies(conf)) {
                dep.useRealNode(); 
                for (String rconf : dep.getRequiredConfigurations(node, conf)) {
                    fetchDependencies(dep, rconf, fetchedSet, true);
                }
                
                if (!dep.isEvicted() && !dep.hasProblem()) {
                    for (String fconf : dep.getConfsToFetch()) {
                        fetchDependencies(dep, fconf, fetchedSet, false);
                    }
                    
                }
                
            }
            
            markDependenciesFetched(node.getNode(), conf, fetchedSet);
        }
        
        if (requestedConfSet) {
            node.setRequestedConf(null);
        }
        
    }
    
    private boolean isDependenciesFetched(IvyNode node, String conf, Set<String> fetchedSet) {
        String key = getDependenciesFetchedKey(node, conf);
        return fetchedSet.contains(key);
    }
    
    private void markDependenciesFetched(IvyNode node, String conf, Set<String> fetchedSet) {
        String key = getDependenciesFetchedKey(node, conf);
        fetchedSet.add(key);
    }
    
    private String getDependenciesFetchedKey(IvyNode node, String conf) {
        ModuleRevisionId moduleRevisionId = node.getResolvedId();
        return moduleRevisionId.getOrganisation() + "|" + moduleRevisionId.getName() + "|" + moduleRevisionId.getRevision() + "|" + conf;
    }
    
    private void resolveConflict(VisitNode node, String conf) {
        resolveConflict(node, node.getParent(), conf, Collections.<IvyNode> emptySet());
    }
    
    private boolean resolveConflict(VisitNode node, VisitNode ancestor, String conf, Collection<IvyNode> toevict) {
        if (ancestor == null || node == ancestor) {
            return true;
        }
        
        if (checkConflictSolvedEvicted(node, ancestor)) {
            return true;
        }
        
        boolean debugConflictResolution = settings.debugConflictResolution();
        if (checkConflictSolvedSelected(node, ancestor)) {
            if (resolveConflict(node, ancestor.getParent(), conf, toevict)) {
                EvictionData evictionData = node.getEvictionDataInRoot(node.getRootModuleConf(), ancestor);
                if (evictionData != null) {
                    if (debugConflictResolution) {
                        Message.debug(node + " was previously evicted in root module conf " + node.getRootModuleConf());
                    }
                    
                    node.markEvicted(evictionData);
                    if (debugConflictResolution) {
                        Message.debug("evicting " + node + " by " + evictionData);
                    }
                    
                }
                
                return true;
            }
             else {
                return false;
            }
            
        }
        
        Set<IvyNode> resolvedNodes = ancestor.getNode().getResolvedNodes(node.getModuleId(), node.getRootModuleConf());
        resolvedNodes.addAll(ancestor.getNode().getPendingConflicts(node.getRootModuleConf(), node.getModuleId()));
        Collection<IvyNode> conflicts = computeConflicts(node, ancestor, conf, toevict, resolvedNodes);
        ConflictManager conflictManager = null;
        for (VisitNode current : ancestor.getPath()) {
            ModuleDescriptor descriptor = current.getNode().getDescriptor();
            if (descriptor == null) {
                throw new IllegalStateException( "impossible to get conflict manager when data has not been loaded. IvyNode = " + current.getNode());
            }
            
            conflictManager = descriptor.getConflictManager(node.getModuleId());
            if (conflictManager != null) {
                break;
            }
            
        }
        
        if (conflictManager == null) {
            conflictManager = settings.getConflictManager(node.getModuleId());
        }
        
        Collection<IvyNode> resolved = resolveConflicts(node, ancestor, conflicts, conflictManager);
        if (resolved == null) {
            if (debugConflictResolution) {
                Message.debug("impossible to resolve conflicts for " + node + " in " + ancestor + " yet");
                Message.debug("setting all nodes as pending conflicts for later conflict" + " resolution: " + conflicts);
            }
            
            ancestor.getNode().setPendingConflicts(node.getModuleId(), node.getRootModuleConf(), conflicts);
            return false;
        }
        
        if (debugConflictResolution) {
            Message.debug("selected revisions for " + node + " in " + ancestor + ": " + resolved);
        }
        
        if (resolved.contains(node.getNode())) {
            toevict = resolvedNodes;
            toevict.removeAll(resolved);
            for (IvyNode te : toevict) {
                te.markEvicted(node.getRootModuleConf(), ancestor.getNode(), conflictManager, resolved);
                if (debugConflictResolution) {
                    Message.debug("evicting " + te + " by " + te.getEvictedData(node.getRootModuleConf()));
                }
                
            }
            
            ancestor.getNode().setResolvedNodes(node.getModuleId(), node.getRootModuleConf(), resolved);
            Collection<IvyNode> evicted = new HashSet<>(ancestor.getNode().getEvictedNodes( node.getModuleId(), node.getRootModuleConf()));
            evicted.removeAll(resolved);
            evicted.addAll(toevict);
            ancestor.getNode().setEvictedNodes(node.getModuleId(), node.getRootModuleConf(), evicted);
            ancestor.getNode().setPendingConflicts(node.getModuleId(), node.getRootModuleConf(), Collections.<IvyNode> emptySet());
            return resolveConflict(node, ancestor.getParent(), conf, toevict);
        }
         else {
            if (resolved.isEmpty()) {
                if (debugConflictResolution) {
                    Message.verbose("conflict manager '" + conflictManager + "' evicted all revisions among " + conflicts);
                }
                
            }
            
            Collection<IvyNode> evicted = new HashSet<>(ancestor.getNode().getEvictedNodes( node.getModuleId(), node.getRootModuleConf()));
            toevict.removeAll(resolved);
            evicted.removeAll(resolved);
            evicted.addAll(toevict);
            evicted.add(node.getNode());
            ancestor.getNode().setEvictedNodes(node.getModuleId(), node.getRootModuleConf(), evicted);
            ancestor.getNode().setPendingConflicts(node.getModuleId(), node.getRootModuleConf(), Collections.<IvyNode> emptySet());
            node.markEvicted(ancestor, conflictManager, resolved);
            if (debugConflictResolution) {
                Message.debug("evicting " + node + " by " + node.getEvictedData());
            }
            
            Collection<IvyNode> prevResolved = ancestor.getNode().getResolvedNodes( node.getModuleId(), node.getRootModuleConf());
            boolean solved = true;
            if (!prevResolved.equals(resolved)) {
                ancestor.getNode().setResolvedNodes(node.getModuleId(), node.getRootModuleConf(), resolved);
                for (IvyNode sel : resolved) {
                    if (!prevResolved.contains(sel)) {
                        solved &= resolveConflict(node.gotoNode(sel), ancestor.getParent(), conf, toevict);
                    }
                    
                }
                
            }
            
            return solved;
        }
        
    }
    
    private Collection<IvyNode> resolveConflicts(VisitNode node, VisitNode ancestor, Collection<IvyNode> conflicts, ConflictManager conflictManager) {
        if (node.getParent() != ancestor && conflictManager == settings.getConflictManager(node.getModuleId()) && node.getParent().getNode() .getResolvedNodes(node.getModuleId(), node.getRootModuleConf()) .equals(conflicts) ) {
            if (settings.debugConflictResolution()) {
                Message.debug("no new conflicting revisions for " + node + " in " + ancestor + ": " + conflicts);
            }
            
            return conflicts;
        }
         else {
            if (settings.debugConflictResolution()) {
                Message.debug("found conflicting revisions for " + node + " in " + ancestor + ": " + conflicts);
            }
            
            return conflictManager.resolveConflicts(ancestor.getNode(), conflicts);
        }
        
    }
    
    private Collection<IvyNode> computeConflicts(VisitNode node, VisitNode ancestor, String conf, Collection<IvyNode> toevict, Collection<IvyNode> selectedNodes) {
        Collection<IvyNode> conflicts = new LinkedHashSet<>();
        conflicts.add(node.getNode());
        boolean evictedInSelected = selectedNodes.removeAll(toevict);
        if (evictedInSelected || (selectedNodes.isEmpty() && !node.getParent().getNode() .equals(ancestor.getNode()))) {
            IvyContext context = IvyContext.getContext();
            ResolveData data = context.getResolveData();
            VisitNode oldVisitNode = data.getCurrentVisitNode();
            data.setCurrentVisitNode(ancestor);
            try {
                Collection<IvyNode> deps = ancestor.getNode().getDependencies( node.getRootModuleConf(), ancestor.getNode().getConfigurations(node.getRootModuleConf()), ancestor.getRequestedConf());
                for (IvyNode dep : deps) {
                    if (dep.getModuleId().equals(node.getModuleId())) {
                        conflicts.add(dep);
                    }
                    
                    conflicts.addAll(dep.getResolvedNodes(node.getModuleId(), node.getRootModuleConf()));
                }
                
            }
             finally {
                data.setCurrentVisitNode(oldVisitNode);
            }
            
        }
         else if (selectedNodes.isEmpty()) {
            VisitNode parent = node.getParent();
            Collection<IvyNode> parentDepIvyNodes = parent.getNode().getDependencies( node.getRootModuleConf(), parent.getNode().getConfigurations(node.getRootModuleConf()), parent.getRequestedConf());
            for (IvyNode parentDep : parentDepIvyNodes) {
                if (parentDep.getModuleId().equals(node.getModuleId())) {
                    conflicts.add(parentDep);
                }
                
            }
            
        }
         else {
            conflicts.addAll(selectedNodes);
        }
        
        return conflicts;
    }
    
    private boolean checkConflictSolvedSelected(VisitNode node, VisitNode ancestor) {
        if (ancestor.getResolvedRevisions(node.getModuleId()).contains(node.getResolvedId())) {
            if (settings.debugConflictResolution()) {
                Message.debug("conflict resolution already done for " + node + " in " + ancestor);
            }
            
            return true;
        }
        
        return false;
    }
    
    private boolean checkConflictSolvedEvicted(VisitNode node, VisitNode ancestor) {
        if (ancestor.getEvictedRevisions(node.getModuleId()).contains(node.getResolvedId())) {
            if (settings.debugConflictResolution()) {
                Message.debug("conflict resolution already done for " + node + " in " + ancestor);
            }
            
            return true;
        }
        
        return false;
    }
    
    public ResolvedModuleRevision findModule(ModuleRevisionId id, ResolveOptions options) {
        DependencyResolver r = settings.getResolver(id);
        if (r == null) {
            throw new IllegalStateException("no resolver found for " + id.getModuleId());
        }
        
        DefaultModuleDescriptor md = DefaultModuleDescriptor.newCallerInstance(id, new String[] {"*"}, false, false);
        if (options.getResolveId() == null) {
            options.setResolveId(ResolveOptions.getDefaultResolveId(md));
        }
        
        try {
            return r.getDependency(new DefaultDependencyDescriptor(id, true), new ResolveData(this, options, new ConfigurationResolveReport(this, md, "default", null, options)));
        }
         catch (ParseException e) {
            throw new RuntimeException("problem while parsing repository module descriptor for " + id + ": " + e, e);
        }
        
    }
    
    public DependencyDescriptor mediate(DependencyDescriptor dd, ResolveOptions options) {
        if (dd == null) {
            return null;
        }
        
        String resolveMode = options.getResolveMode() == null ? settings.getResolveMode(dd .getDependencyId()) : options.getResolveMode();
        if (ResolveOptions.RESOLVEMODE_DYNAMIC.equals(resolveMode) && !dd.getDynamicConstraintDependencyRevisionId().equals( dd.getDependencyRevisionId())) {
            return dd.clone(ModuleRevisionId.newInstance(dd .getDynamicConstraintDependencyRevisionId(), dd .getDynamicConstraintDependencyRevisionId().getRevision()));
        }
         else {
            return dd;
        }
        
    }
    
    public EventManager getEventManager() {
        return eventManager;
    }
    
    public ResolveEngineSettings getSettings() {
        return settings;
    }
    
    public SortEngine getSortEngine() {
        return sortEngine;
    }
    
    private void checkInterrupted() {
        IvyContext.getContext().getIvy().checkInterrupted();
    }
    
}


