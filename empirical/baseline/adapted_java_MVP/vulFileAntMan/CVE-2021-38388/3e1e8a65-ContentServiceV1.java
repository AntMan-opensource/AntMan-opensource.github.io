package com.linecorp.centraldogma.server.internal.api;
import static com.google.common.base.MoreObjects.firstNonNull;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.linecorp.centraldogma.common.EntryType.DIRECTORY;
import static com.linecorp.centraldogma.internal.Util.isValidDirPath;
import static com.linecorp.centraldogma.internal.Util.isValidFilePath;
import static com.linecorp.centraldogma.server.internal.api.DtoConverter.convert;
import static com.linecorp.centraldogma.server.internal.api.HttpApiUtil.returnOrThrow;
import static java.util.Objects.requireNonNull;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import javax.annotation.Nullable;
import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.linecorp.armeria.common.HttpHeaderNames;
import com.linecorp.armeria.common.HttpResponse;
import com.linecorp.armeria.common.HttpStatus;
import com.linecorp.armeria.common.util.Exceptions;
import com.linecorp.armeria.server.ServiceRequestContext;
import com.linecorp.armeria.server.annotation.Default;
import com.linecorp.armeria.server.annotation.ExceptionHandler;
import com.linecorp.armeria.server.annotation.Get;
import com.linecorp.armeria.server.annotation.Param;
import com.linecorp.armeria.server.annotation.Post;
import com.linecorp.armeria.server.annotation.ProducesJson;
import com.linecorp.armeria.server.annotation.RequestConverter;
import com.linecorp.centraldogma.common.Author;
import com.linecorp.centraldogma.common.Change;
import com.linecorp.centraldogma.common.Entry;
import com.linecorp.centraldogma.common.Markup;
import com.linecorp.centraldogma.common.MergeQuery;
import com.linecorp.centraldogma.common.Query;
import com.linecorp.centraldogma.common.Revision;
import com.linecorp.centraldogma.common.RevisionRange;
import com.linecorp.centraldogma.internal.api.v1.ChangeDto;
import com.linecorp.centraldogma.internal.api.v1.CommitMessageDto;
import com.linecorp.centraldogma.internal.api.v1.EntryDto;
import com.linecorp.centraldogma.internal.api.v1.MergedEntryDto;
import com.linecorp.centraldogma.internal.api.v1.PushResultDto;
import com.linecorp.centraldogma.internal.api.v1.WatchResultDto;
import com.linecorp.centraldogma.server.command.Command;
import com.linecorp.centraldogma.server.command.CommandExecutor;
import com.linecorp.centraldogma.server.command.CommitResult;
import com.linecorp.centraldogma.server.internal.api.auth.RequiresReadPermission;
import com.linecorp.centraldogma.server.internal.api.auth.RequiresWritePermission;
import com.linecorp.centraldogma.server.internal.api.converter.ChangesRequestConverter;
import com.linecorp.centraldogma.server.internal.api.converter.CommitMessageRequestConverter;
import com.linecorp.centraldogma.server.internal.api.converter.MergeQueryRequestConverter;
import com.linecorp.centraldogma.server.internal.api.converter.QueryRequestConverter;
import com.linecorp.centraldogma.server.internal.api.converter.WatchRequestConverter;
import com.linecorp.centraldogma.server.internal.api.converter.WatchRequestConverter.WatchRequest;
import com.linecorp.centraldogma.server.storage.project.ProjectManager;
import com.linecorp.centraldogma.server.storage.repository.FindOption;
import com.linecorp.centraldogma.server.storage.repository.FindOptions;
import com.linecorp.centraldogma.server.storage.repository.Repository;
public class ContentServiceV1 extends AbstractService {
    private final WatchService watchService;
    public ContentServiceV1(ProjectManager projectManager, CommandExecutor executor, WatchService watchService) {
        super(projectManager, executor);
        this.watchService = requireNonNull(watchService, "watchService");
    }
    
    public CompletableFuture<List<EntryDto<?>>> listFiles(@Param String path, @Param @Default("-1") String revision, Repository repository) {
        final String normalizedPath = normalizePath(path);
        final Revision normalizedRev = repository.normalizeNow(new Revision(revision));
        final CompletableFuture<List<EntryDto<?>>> future = new CompletableFuture<>();
        listFiles(repository, normalizedPath, normalizedRev, false, future);
        return future;
    }
    
    private static void listFiles(Repository repository, String pathPattern, Revision normalizedRev, boolean withContent, CompletableFuture<List<EntryDto<?>>> result) {
        final Map<FindOption<?>, ?> options = withContent ? FindOptions.FIND_ALL_WITH_CONTENT : FindOptions.FIND_ALL_WITHOUT_CONTENT;
        repository.find(normalizedRev, pathPattern, options).handle((entries, thrown) -> {
            if (thrown != null) {
                result.completeExceptionally(thrown);
                return null;
            }
            
            if (isValidFilePath(pathPattern) && entries.size() == 1 && entries.values().iterator().next().type() == DIRECTORY) {
                listFiles(repository, pathPattern + "/*", normalizedRev, withContent, result);
            }
             else {
                result.complete(entries.values().stream() .map(entry -> convert(repository, normalizedRev, entry, withContent)) .collect(toImmutableList()));
            }
            
            return null;
        }
        
);
    }
    
    private static String normalizePath(String path) {
        if (path == null || path.isEmpty() || "/".equals(path)) {
            return "/*";
        }
        
        if (isValidFilePath(path)) {
            return path;
        }
        
        if (isValidDirPath(path)) {
            if (path.endsWith("/")) {
                return path + '*';
            }
             else {
                return path + "/*";
            }
            
        }
        
        return path;
    }
    
    public CompletableFuture<PushResultDto> push( @Param @Default("-1") String revision, Repository repository, Author author, CommitMessageDto commitMessage, @RequestConverter(ChangesRequestConverter.class) Iterable<Change<?>> changes) {
        final long commitTimeMillis = System.currentTimeMillis();
        return push(commitTimeMillis, author, repository, new Revision(revision), commitMessage, changes) .toCompletableFuture() .thenApply(rrev -> convert(rrev, commitTimeMillis));
    }
    
    private CompletableFuture<Revision> push(long commitTimeMills, Author author, Repository repository, Revision revision, CommitMessageDto commitMessage, Iterable<Change<?>> changes) {
        final String summary = commitMessage.summary();
        final String detail = commitMessage.detail();
        final Markup markup = commitMessage.markup();
        return execute(Command.push( commitTimeMills, author, repository.parent().name(), repository.name(), revision, summary, detail, markup, changes)).thenApply(CommitResult::revision);
    }
    
    public CompletableFuture<Iterable<ChangeDto<?>>> preview( @Param @Default("-1") String revision, Repository repository, @RequestConverter(ChangesRequestConverter.class) Iterable<Change<?>> changes) {
        final CompletableFuture<Map<String, Change<?>>> changesFuture = repository.previewDiff(new Revision(revision), changes);
        return changesFuture.thenApply(previewDiffs -> previewDiffs.values().stream() .map(DtoConverter::convert) .collect(toImmutableList()));
    }
    
    public CompletableFuture<?> getFiles( ServiceRequestContext ctx, @Param String path, @Param @Default("-1") String revision, Repository repository, @RequestConverter(WatchRequestConverter.class) @Nullable WatchRequest watchRequest, @RequestConverter(QueryRequestConverter.class) @Nullable Query<?> query) {
        final String normalizedPath = normalizePath(path);
        if (watchRequest != null) {
            final Revision lastKnownRevision = watchRequest.lastKnownRevision();
            final long timeOutMillis = watchRequest.timeoutMillis();
            if (query != null) {
                return watchFile(ctx, repository, lastKnownRevision, query, timeOutMillis);
            }
            
            return watchRepository(ctx, repository, lastKnownRevision, normalizedPath, timeOutMillis);
        }
        
        final Revision normalizedRev = repository.normalizeNow(new Revision(revision));
        if (query != null) {
            return repository.get(normalizedRev, query) .handle(returnOrThrow((Entry<?> result) -> convert(repository, normalizedRev, result, true)));
        }
        
        final CompletableFuture<List<EntryDto<?>>> future = new CompletableFuture<>();
        listFiles(repository, normalizedPath, normalizedRev, true, future);
        return future;
    }
    
    private CompletableFuture<?> watchFile(ServiceRequestContext ctx, Repository repository, Revision lastKnownRevision, Query<?> query, long timeOutMillis) {
        final CompletableFuture<? extends Entry<?>> future = watchService.watchFile( repository, lastKnownRevision, query, timeOutMillis);
        if (!future.isDone()) {
            ctx.log().whenComplete().thenRun(() -> future.cancel(false));
        }
        
        return future.thenApply(entry -> {
            final Revision revision = entry.revision();
            final EntryDto<?> entryDto = convert(repository, revision, entry, true);
            return (Object) new WatchResultDto(revision, entryDto);
        }
).exceptionally(ContentServiceV1::handleWatchFailure);
    }
    
    private CompletableFuture<?> watchRepository(ServiceRequestContext ctx, Repository repository, Revision lastKnownRevision, String pathPattern, long timeOutMillis) {
        final CompletableFuture<Revision> future = watchService.watchRepository(repository, lastKnownRevision, pathPattern, timeOutMillis);
        if (!future.isDone()) {
            ctx.log().whenComplete().thenRun(() -> future.cancel(false));
        }
        
        return future.thenApply(revision -> (Object) new WatchResultDto(revision, null)) .exceptionally(ContentServiceV1::handleWatchFailure);
    }
    
    private static Object handleWatchFailure(Throwable thrown) {
        if (Throwables.getRootCause(thrown) instanceof CancellationException) {
            return HttpResponse.of(HttpStatus.NOT_MODIFIED);
        }
        
        return Exceptions.throwUnsafely(thrown);
    }
    
    public CompletableFuture<?> listCommits(@Param String revision, @Param @Default("/**") String path, @Param @Nullable String to, @Param @Nullable Integer maxCommits, Repository repository) {
        final Revision fromRevision;
        final Revision toRevision;
        if (isNullOrEmpty(revision) || "/".equalsIgnoreCase(revision)) {
            fromRevision = Revision.HEAD;
            toRevision = to != null ? new Revision(to) : Revision.INIT;
        }
         else {
            fromRevision = new Revision(revision.substring(1));
            toRevision = to != null ? new Revision(to) : fromRevision;
        }
        
        final RevisionRange range = repository.normalizeNow(fromRevision, toRevision).toDescending();
        final int maxCommits0 = firstNonNull(maxCommits, Repository.DEFAULT_MAX_COMMITS);
        return repository .history(range.from(), range.to(), normalizePath(path), maxCommits0) .thenApply(commits -> {
                    final boolean toList = to != null || isNullOrEmpty(revision) || "/".equalsIgnoreCase(revision);
                    return objectOrList(commits, toList, DtoConverter::convert);
                }
                
);
    }
    
    public CompletableFuture<?> getDiff( @Param @Default("/**") String pathPattern, @Param @Default("1") String from, @Param @Default("head") String to, Repository repository, @RequestConverter(QueryRequestConverter.class) @Nullable Query<?> query) {
        if (query != null) {
            return repository.diff(new Revision(from), new Revision(to), query) .thenApply(DtoConverter::convert);
        }
         else {
            return repository .diff(new Revision(from), new Revision(to), normalizePath(pathPattern)) .thenApply(changeMap -> changeMap.values().stream() .map(DtoConverter::convert).collect(toImmutableList()));
        }
        
    }
    
    private static <T> Object objectOrList(Collection<T> collection, boolean toList, Function<T, ?> converter) {
        if (collection.isEmpty()) {
            return ImmutableList.of();
        }
        
        if (toList) {
            return collection.stream().map(converter).collect(toImmutableList());
        }
        
        return converter.apply(Iterables.getOnlyElement(collection));
    }
    
    public <T> CompletableFuture<MergedEntryDto<T>> mergeFiles( @Param @Default("-1") String revision, Repository repository, @RequestConverter(MergeQueryRequestConverter.class) MergeQuery<T> query) {
        return repository.mergeFiles(new Revision(revision), query).thenApply(DtoConverter::convert);
    }
    
}


