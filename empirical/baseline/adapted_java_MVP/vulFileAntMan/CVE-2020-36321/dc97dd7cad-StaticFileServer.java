package com.vaadin.flow.server;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.vaadin.flow.function.DeploymentConfiguration;
import com.vaadin.flow.internal.ResponseWriter;
import static com.vaadin.flow.server.Constants.VAADIN_BUILD_FILES_PATH;
import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;
import static com.vaadin.flow.shared.ApplicationConstants.VAADIN_STATIC_FILES_PATH;
public class StaticFileServer implements StaticFileHandler {
    static final String PROPERTY_FIX_INCORRECT_WEBJAR_PATHS = Constants.VAADIN_PREFIX + "fixIncorrectWebjarPaths";
    private static final Pattern INCORRECT_WEBJAR_PATH_REGEX = Pattern .compile("^/frontend[-\\w/]*/webjars/");
    private static final Pattern PARENT_DIRECTORY_REGEX = Pattern .compile("(/|\\\\)\\.\\.(/|\\\\)", Pattern.CASE_INSENSITIVE);
    private final ResponseWriter responseWriter;
    private final VaadinServletService servletService;
    private DeploymentConfiguration deploymentConfiguration;
    public StaticFileServer(VaadinServletService servletService) {
        this.servletService = servletService;
        deploymentConfiguration = servletService.getDeploymentConfiguration();
        responseWriter = new ResponseWriter(deploymentConfiguration);
    }
    
    public boolean isStaticResourceRequest(HttpServletRequest request) {
        URL resource;
        String requestFilename = getRequestFilename(request);
        if (requestFilename.endsWith("/")) {
            return false;
        }
        
        if (requestFilename.startsWith("/" + VAADIN_STATIC_FILES_PATH) || requestFilename.startsWith("/" + VAADIN_BUILD_FILES_PATH)) {
            return true;
        }
        
        resource = servletService.getStaticResource(requestFilename);
        if (resource == null && shouldFixIncorrectWebjarPaths() && isIncorrectWebjarPath(requestFilename)) {
            return true;
        }
        
        return resource != null;
    }
    
    public boolean serveStaticResource(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String filenameWithPath = getRequestFilename(request);
        if (!isPathSafe(filenameWithPath)) {
            getLogger().info("Blocked attempt to access file: {}", filenameWithPath);
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            return true;
        }
        
        URL resourceUrl = null;
        if (isAllowedVAADINBuildUrl(filenameWithPath)) {
            resourceUrl = servletService.getClassLoader() .getResource("META-INF" + filenameWithPath);
        }
        
        if (resourceUrl == null) {
            resourceUrl = servletService.getStaticResource(filenameWithPath);
        }
        
        if (resourceUrl == null && shouldFixIncorrectWebjarPaths() && isIncorrectWebjarPath(filenameWithPath)) {
            resourceUrl = servletService.getStaticResource( fixIncorrectWebjarPath(filenameWithPath));
        }
        
        if (resourceUrl == null) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return true;
        }
        
        writeCacheHeaders(filenameWithPath, response);
        long timestamp = writeModificationTimestamp(resourceUrl, request, response);
        if (browserHasNewestVersion(request, timestamp)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
            return true;
        }
        
        responseWriter.writeResponseContents(filenameWithPath, resourceUrl, request, response);
        return true;
    }
    
    private boolean shouldFixIncorrectWebjarPaths() {
        return deploymentConfiguration.isProductionMode() && deploymentConfiguration.getBooleanProperty( PROPERTY_FIX_INCORRECT_WEBJAR_PATHS, false);
    }
    
    private boolean isIncorrectWebjarPath(String requestFilename) {
        return INCORRECT_WEBJAR_PATH_REGEX.matcher(requestFilename).lookingAt();
    }
    
    private String fixIncorrectWebjarPath(String requestFilename) {
        return INCORRECT_WEBJAR_PATH_REGEX.matcher(requestFilename) .replaceAll("/webjars/");
    }
    
    private boolean isPathSafe(String path) {
        try {
            path = URLDecoder.decode(path, StandardCharsets.UTF_8.name());
        }
         catch (UnsupportedEncodingException e) {
            throw new RuntimeException("An error occurred during decoding URL.", e);
        }
        
        return !PARENT_DIRECTORY_REGEX.matcher(path).find();
    }
    
    private boolean isAllowedVAADINBuildUrl(String filenameWithPath) {
        return filenameWithPath.startsWith("/" + VAADIN_BUILD_FILES_PATH);
    }
    
    protected long writeModificationTimestamp(URL resourceUrl, HttpServletRequest request, HttpServletResponse response) {
        long lastModifiedTime;
        URLConnection connection = null;
        try {
            connection = resourceUrl.openConnection();
            lastModifiedTime = connection.getLastModified();
            lastModifiedTime = lastModifiedTime - lastModifiedTime % 1000;
            response.setDateHeader("Last-Modified", lastModifiedTime);
            return lastModifiedTime;
        }
         catch (Exception e) {
            getLogger().trace( "Failed to find out last modified timestamp. Continuing without it.", e);
        }
         finally {
            try {
                if (connection != null) {
                    InputStream is = connection.getInputStream();
                    if (is != null) {
                        is.close();
                    }
                    
                }
                
            }
             catch (IOException e) {
                getLogger().warn("Error closing URLConnection input stream", e);
            }
            
        }
        
        return -1L;
    }
    
    protected void writeCacheHeaders(String filenameWithPath, HttpServletResponse response) {
        int resourceCacheTime = getCacheTime(filenameWithPath);
        String cacheControl;
        if (!deploymentConfiguration.isProductionMode()) {
            cacheControl = "no-cache";
        }
         else if (resourceCacheTime > 0) {
            cacheControl = "max-age=" + resourceCacheTime;
        }
         else {
            cacheControl = "public, max-age=0, must-revalidate";
        }
        
        response.setHeader("Cache-Control", cacheControl);
    }
    
    String getRequestFilename(HttpServletRequest request) {
        if (request.getPathInfo() == null) {
            return request.getServletPath();
        }
         else if (request.getPathInfo().startsWith("/" + VAADIN_MAPPING)) {
            return request.getPathInfo();
        }
        
        return request.getServletPath() + request.getPathInfo();
    }
    
    protected int getCacheTime(String filenameWithPath) {
        if (filenameWithPath.contains(".nocache.")) {
            return 0;
        }
        
        if (filenameWithPath.contains(".cache.")) {
            return 60 * 60 * 24 * 365;
        }
        
        return 3600;
    }
    
    protected boolean browserHasNewestVersion(HttpServletRequest request, long resourceLastModifiedTimestamp) {
        assert resourceLastModifiedTimestamp >= -1L;
        if (resourceLastModifiedTimestamp == -1L) {
            return false;
        }
        
        try {
            long headerIfModifiedSince = request .getDateHeader("If-Modified-Since");
            if (headerIfModifiedSince >= resourceLastModifiedTimestamp) {
                return true;
            }
            
        }
         catch (Exception e) {
            getLogger().trace("Unable to parse If-Modified-Since", e);
        }
        
        return false;
    }
    
    private static Logger getLogger() {
        return LoggerFactory.getLogger(StaticFileServer.class.getName());
    }
    
}


