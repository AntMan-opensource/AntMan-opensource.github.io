package com.vaadin.flow.server;
import static com.vaadin.flow.server.Constants.VAADIN_MAPPING;
import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_DEVMODE_WEBPACK_ERROR_PATTERN;
import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_DEVMODE_WEBPACK_OPTIONS;
import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_DEVMODE_WEBPACK_SUCCESS_PATTERN;
import static com.vaadin.flow.server.InitParameters.SERVLET_PARAMETER_DEVMODE_WEBPACK_TIMEOUT;
import static com.vaadin.flow.server.frontend.FrontendUtils.GREEN;
import static com.vaadin.flow.server.frontend.FrontendUtils.RED;
import static com.vaadin.flow.server.frontend.FrontendUtils.commandToString;
import static com.vaadin.flow.server.frontend.FrontendUtils.console;
import static java.lang.String.format;
import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
import static java.net.HttpURLConnection.HTTP_OK;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.net.HttpURLConnection;
import java.net.ServerSocket;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Pattern;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.vaadin.flow.function.DeploymentConfiguration;
import com.vaadin.flow.internal.BrowserLiveReload;
import com.vaadin.flow.internal.Pair;
import com.vaadin.flow.server.communication.StreamRequestHandler;
import com.vaadin.flow.server.frontend.FrontendTools;
import com.vaadin.flow.server.frontend.FrontendUtils;
public final class DevModeHandler implements RequestHandler {
    private static final String START_FAILURE = "Couldn't start dev server because";
    private static final AtomicReference<DevModeHandler> atomicHandler = new AtomicReference<>();
    private static final String DEFAULT_OUTPUT_PATTERN = ": Compiled.";
    private static final String DEFAULT_ERROR_PATTERN = ": Failed to compile.";
    private static final String FAILED_MSG = "\n------------------ Frontend compilation failed. ------------------\n\n";
    private static final String SUCCEED_MSG = "\n----------------- Frontend compiled successfully. -----------------\n\n";
    private static final String START = "\n------------------ Starting Frontend compilation. ------------------\n";
    private static final String END = "\n------------------------- Webpack stopped  -------------------------\n";
    private static final String LOG_START = "Running webpack to compile frontend resources. This may take a moment, please stand by...";
    private static final String LOG_END = "Started webpack-dev-server. Time: {}ms";
    private static final String DEFAULT_TIMEOUT_FOR_PATTERN = "60000";
    private static final int DEFAULT_BUFFER_SIZE = 32 * 1024;
    private static final int DEFAULT_TIMEOUT = 120 * 1000;
    private static final String WEBPACK_HOST = "http://localhost";
    private boolean notified = false;
    private volatile String failedOutput;
    private AtomicBoolean isDevServerFailedToStart = new AtomicBoolean();
    private transient BrowserLiveReload liveReload;
    public static final String WEBPACK_SERVER = "node_modules/webpack-dev-server/bin/webpack-dev-server.js";
    private static final String WEBPACK_PORTFILE_UUID_PROPERTY = "vaadin.frontend.webpack.portfile.uuid";
    private volatile int port;
    private final AtomicReference<Process> webpackProcess = new AtomicReference<>();
    private final boolean reuseDevServer;
    private final AtomicReference<DevServerWatchDog> watchDog = new AtomicReference<>();
    private final File devServerPortFile;
    private StringBuilder cumulativeOutput = new StringBuilder();
    private final CompletableFuture<Void> devServerStartFuture;
    private final File npmFolder;
    private DevModeHandler(DeploymentConfiguration config, int runningPort, File npmFolder, CompletableFuture<Void> waitFor) {
        this.npmFolder = npmFolder;
        port = runningPort;
        reuseDevServer = config.reuseDevServer();
        devServerPortFile = getDevServerPortFile(npmFolder);
        devServerStartFuture = waitFor.whenCompleteAsync((value, exception) -> {
            waitFor.getNow(null);
            runOnFutureComplete(config);
        }
        
);
    }
    
    public static DevModeHandler start(DeploymentConfiguration configuration, File npmFolder, CompletableFuture<Void> waitFor) {
        return start(0, configuration, npmFolder, waitFor);
    }
    
    public static DevModeHandler start(int runningPort, DeploymentConfiguration configuration, File npmFolder, CompletableFuture<Void> waitFor) {
        if (configuration.isProductionMode() || !configuration.enableDevServer()) {
            return null;
        }
        
        if (atomicHandler.get() == null) {
            atomicHandler.compareAndSet(null, createInstance(runningPort, configuration, npmFolder, waitFor));
        }
        
        return getDevModeHandler();
    }
    
    public static DevModeHandler getDevModeHandler() {
        return atomicHandler.get();
    }
    
    public void setLiveReload(BrowserLiveReload liveReload) {
        this.liveReload = liveReload;
    }
    
    public BrowserLiveReload getLiveReload() {
        return liveReload;
    }
    
    public boolean handleRequest(VaadinSession session, VaadinRequest request, VaadinResponse response) throws IOException {
        if (devServerStartFuture.isDone()) {
            try {
                devServerStartFuture.getNow(null);
            }
             catch (CompletionException exception) {
                isDevServerFailedToStart.set(true);
                throw getCause(exception);
            }
            
            return false;
        }
         else {
            InputStream inputStream = DevModeHandler.class .getResourceAsStream("dev-mode-not-ready.html");
            IOUtils.copy(inputStream, response.getOutputStream());
            response.setContentType("text/html;charset=utf-8");
            return true;
        }
        
    }
    
    private RuntimeException getCause(Throwable exception) {
        if (exception instanceof CompletionException) {
            return getCause(exception.getCause());
        }
         else if (exception instanceof RuntimeException) {
            return (RuntimeException) exception;
        }
         else {
            return new IllegalStateException(exception);
        }
        
    }
    
    private static DevModeHandler createInstance(int runningPort, DeploymentConfiguration configuration, File npmFolder, CompletableFuture<Void> waitFor) {
        return new DevModeHandler(configuration, runningPort, npmFolder, waitFor);
    }
    
    public boolean isDevModeRequest(HttpServletRequest request) {
        String pathInfo = request.getPathInfo();
        return pathInfo != null && pathInfo.startsWith("/" + VAADIN_MAPPING) && !pathInfo .startsWith("/" + StreamRequestHandler.DYN_RES_PREFIX);
    }
    
    public boolean serveDevModeRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {
        if (isDevServerFailedToStart.get() || !devServerStartFuture.isDone()) {
            return false;
        }
        
        String requestFilename = request.getPathInfo();
        HttpURLConnection connection = prepareConnection(requestFilename, request.getMethod());
        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String header = headerNames.nextElement();
            connection.setRequestProperty(header, "Connect".equals(header) ? "close" : request.getHeader(header));
        }
        
        getLogger().debug("Requesting resource to webpack {}", connection.getURL());
        int responseCode = connection.getResponseCode();
        if (responseCode == HTTP_NOT_FOUND) {
            getLogger().debug("Resource not served by webpack {}", requestFilename);
            return false;
        }
        
        getLogger().debug("Served resource by webpack: {} {}", responseCode, requestFilename);
        connection.getHeaderFields().forEach((header, values) -> {
            if (header != null) {
                response.addHeader(header, values.get(0));
            }
            
        }
        
);
        if (responseCode == HTTP_OK) {
            writeStream(response.getOutputStream(), connection.getInputStream());
        }
         else if (responseCode < 400) {
            response.setStatus(responseCode);
        }
         else {
            response.sendError(responseCode);
        }
        
        response.getOutputStream().close();
        return true;
    }
    
    private boolean checkWebpackConnection() {
        try {
            prepareConnection("/", "GET").getResponseCode();
            return true;
        }
         catch (IOException e) {
            getLogger().debug("Error checking webpack dev server connection", e);
        }
        
        return false;
    }
    
    public HttpURLConnection prepareConnection(String path, String method) throws IOException {
        URL uri = new URL(WEBPACK_HOST + ":" + getPort() + path);
        HttpURLConnection connection = (HttpURLConnection) uri.openConnection();
        connection.setRequestMethod(method);
        connection.setReadTimeout(DEFAULT_TIMEOUT);
        connection.setConnectTimeout(DEFAULT_TIMEOUT);
        return connection;
    }
    
    private synchronized void doNotify() {
        if (!notified) {
            notified = true;
            notifyAll(); 
        }
        
    }
    
    private void logStream(InputStream input, Pattern success, Pattern failure) {
        Thread thread = new Thread(() -> {
            InputStreamReader reader = new InputStreamReader(input, StandardCharsets.UTF_8);
            try {
                readLinesLoop(success, failure, reader);
            }
             catch (IOException e) {
                if ("Stream closed".equals(e.getMessage())) {
                    console(GREEN, END);
                    getLogger().debug("Exception when reading webpack output.", e);
                }
                 else {
                    getLogger().error("Exception when reading webpack output.", e);
                }
                
            }
            
            doNotify();
        }
        
);
        thread.setDaemon(true);
        thread.setName("webpack");
        thread.start();
    }
    
    private void readLinesLoop(Pattern success, Pattern failure, InputStreamReader reader) throws IOException {
        StringBuilder line = new StringBuilder();
        for (int i; (i = reader.read()) >= 0;) {
            char ch = (char) i;
            console("%c", ch);
            line.append(ch);
            if (ch == '\n') {
                processLine(line.toString(), success, failure);
                line.setLength(0);
            }
            
        }
        
    }
    
    private void processLine(String line, Pattern success, Pattern failure) {
        if (line.contains("\b")) {
            return;
        }
        
        String cleanLine = line.replaceAll("(\u001b\\[[;\\d]*m|[\b\r]+)", "");
        cumulativeOutput.append(cleanLine);
        boolean succeed = success.matcher(line).find();
        boolean failed = failure.matcher(line).find();
        if (succeed || failed) {
            if (succeed) {
                console(GREEN, SUCCEED_MSG);
            }
             else {
                console(RED, FAILED_MSG);
            }
            
            failedOutput = failed ? cumulativeOutput.toString() : null;
            cumulativeOutput = new StringBuilder();
            doNotify();
            if (liveReload != null) {
                liveReload.reload();
            }
            
        }
        
    }
    
    private void writeStream(ServletOutputStream outputStream, InputStream inputStream) throws IOException {
        final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
        int bytes;
        while ((bytes = inputStream.read(buffer)) >= 0) {
            outputStream.write(buffer, 0, bytes);
        }
        
    }
    
    private static Logger getLogger() {
        return LoggerFactory.getLogger(DevModeHandler.class);
    }
    
    public String getFailedOutput() {
        return failedOutput;
    }
    
    public void removeRunningDevServerPort() {
        FileUtils.deleteQuietly(devServerPortFile);
    }
    
    private void runOnFutureComplete(DeploymentConfiguration config) {
        try {
            doStartDevModeServer(config);
        }
         catch (ExecutionFailedException exception) {
            getLogger().error(null, exception);
            throw new CompletionException(exception);
        }
        
    }
    
    private void saveRunningDevServerPort() {
        try {
            FileUtils.writeStringToFile(devServerPortFile, String.valueOf(port), StandardCharsets.UTF_8);
        }
         catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        
    }
    
    private boolean checkPort() {
        if (checkWebpackConnection()) {
            getLogger().info("Reusing webpack-dev-server running at {}:{}", WEBPACK_HOST, port);
            saveRunningDevServerPort();
            watchDog.set(null);
            return false;
        }
        
        throw new IllegalStateException(format( "%s webpack-dev-server port '%d' is defined but it's not working properly", START_FAILURE, port));
    }
    
    private void doStartDevModeServer(DeploymentConfiguration config) throws ExecutionFailedException {
        if (port > 0) {
            if (!checkWebpackConnection()) {
                throw new IllegalStateException(format( "%s webpack-dev-server port '%d' is defined but it's not working properly", START_FAILURE, port));
            }
            
            reuseExistingPort(port);
            return;
        }
        
        port = getRunningDevServerPort(npmFolder);
        if (port > 0) {
            if (checkWebpackConnection()) {
                reuseExistingPort(port);
                return;
            }
             else {
                getLogger().warn( "webpack-dev-server port '%d' is defined but it's not working properly. Using a new free port...", port);
                port = 0;
            }
            
        }
        
        Pair<File, File> webPackFiles = validateFiles(npmFolder);
        long start = System.nanoTime();
        getLogger().info("Starting webpack-dev-server");
        watchDog.set(new DevServerWatchDog());
        port = getFreePort();
        saveRunningDevServerPort();
        boolean success = false;
        try {
            success = doStartWebpack(config, webPackFiles, start);
        }
         finally {
            if (!success) {
                removeRunningDevServerPort();
            }
            
        }
        
    }
    
    private boolean doStartWebpack(DeploymentConfiguration config, Pair<File, File> webPackFiles, long start) {
        ProcessBuilder processBuilder = new ProcessBuilder() .directory(npmFolder);
        FrontendTools tools = new FrontendTools(npmFolder.getAbsolutePath(), () -> FrontendUtils.getVaadinHomeDirectory().getAbsolutePath());
        tools.validateNodeAndNpmVersion();
        boolean useHomeNodeExec = config.getBooleanProperty( InitParameters.REQUIRE_HOME_NODE_EXECUTABLE, false);
        String nodeExec = null;
        if (useHomeNodeExec) {
            nodeExec = tools.forceAlternativeNodeExecutable();
        }
         else {
            nodeExec = tools.getNodeExecutable();
        }
        
        List<String> command = makeCommands(config, webPackFiles.getFirst(), webPackFiles.getSecond(), nodeExec);
        console(GREEN, START);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug( commandToString(npmFolder.getAbsolutePath(), command));
        }
        
        processBuilder.command(command);
        try {
            webpackProcess.set( processBuilder.redirectError(ProcessBuilder.Redirect.PIPE) .redirectErrorStream(true).start());
            Runtime.getRuntime().addShutdownHook(new Thread(this::stop));
            Pattern succeed = Pattern.compile(config.getStringProperty( SERVLET_PARAMETER_DEVMODE_WEBPACK_SUCCESS_PATTERN, DEFAULT_OUTPUT_PATTERN));
            Pattern failure = Pattern.compile(config.getStringProperty( SERVLET_PARAMETER_DEVMODE_WEBPACK_ERROR_PATTERN, DEFAULT_ERROR_PATTERN));
            logStream(webpackProcess.get().getInputStream(), succeed, failure);
            getLogger().info(LOG_START);
            synchronized (this) {
                this.wait(Integer.parseInt(config.getStringProperty(  SERVLET_PARAMETER_DEVMODE_WEBPACK_TIMEOUT, DEFAULT_TIMEOUT_FOR_PATTERN)));
            }
            
            if (!webpackProcess.get().isAlive()) {
                throw new IllegalStateException("Webpack exited prematurely");
            }
            
            long ms = (System.nanoTime() - start) / 1000000;
            getLogger().info(LOG_END, ms);
            return true;
        }
         catch (IOException | InterruptedException e) {
            getLogger().error("Failed to start the webpack process", e);
        }
        
        return false;
    }
    
    private void reuseExistingPort(int port) {
        getLogger().info("Reusing webpack-dev-server running at {}:{}", WEBPACK_HOST, port);
        saveRunningDevServerPort();
        watchDog.set(null);
    }
    
    private List<String> makeCommands(DeploymentConfiguration config, File webpack, File webpackConfig, String nodeExec) {
        List<String> command = new ArrayList<>();
        command.add(nodeExec);
        command.add(webpack.getAbsolutePath());
        command.add("--config");
        command.add(webpackConfig.getAbsolutePath());
        command.add("--port");
        command.add(String.valueOf(port));
        command.add("--watchDogPort=" + watchDog.get().getWatchDogPort());
        command.addAll(Arrays.asList(config .getStringProperty(SERVLET_PARAMETER_DEVMODE_WEBPACK_OPTIONS, "-d --inline=false") .split(" +")));
        return command;
    }
    
    private Pair<File, File> validateFiles(File npmFolder) throws ExecutionFailedException {
        assert port == 0;
        File webpack = new File(npmFolder, WEBPACK_SERVER);
        File webpackConfig = new File(npmFolder, FrontendUtils.WEBPACK_CONFIG);
        if (!npmFolder.exists()) {
            getLogger().warn("No project folder '{}' exists", npmFolder);
            throw new ExecutionFailedException(START_FAILURE + " the target execution folder doesn't exist.");
        }
        
        if (!webpack.exists()) {
            getLogger().warn("'{}' doesn't exist. Did you run `npm install`?", webpack);
            throw new ExecutionFailedException(String.format( "%s '%s' doesn't exist. `npm install` has not run or failed.", START_FAILURE, webpack));
        }
         else if (!webpack.canExecute()) {
            getLogger().warn( " '{}' is not an executable. Did you run `npm install`?", webpack);
            throw new ExecutionFailedException(String.format( "%s '%s' is not an executable." + " `npm install` has not run or failed.", START_FAILURE, webpack));
        }
        
        if (!webpackConfig.canRead()) {
            getLogger().warn( "Webpack configuration '{}' is not found or is not readable.", webpackConfig);
            throw new ExecutionFailedException( String.format("%s '%s' doesn't exist or is not readable.", START_FAILURE, webpackConfig));
        }
        
        return new Pair<>(webpack, webpackConfig);
    }
    
    private static int getRunningDevServerPort(File npmFolder) {
        int port = 0;
        File portFile = getDevServerPortFile(npmFolder);
        if (portFile.canRead()) {
            try {
                String portString = FileUtils .readFileToString(portFile, StandardCharsets.UTF_8) .trim();
                if (!portString.isEmpty()) {
                    port = Integer.parseInt(portString);
                }
                
            }
             catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            
        }
        
        return port;
    }
    
    static int getFreePort() {
        try (ServerSocket s = new ServerSocket(0)) {
            s.setReuseAddress(true);
            return s.getLocalPort();
        }
         catch (IOException e) {
            throw new IllegalStateException( "Unable to find a free port for running webpack", e);
        }
        
    }
    
    public int getPort() {
        return port;
    }
    
    public boolean reuseDevServer() {
        return reuseDevServer;
    }
    
    public void stop() {
        if (atomicHandler.get() == null) {
            return;
        }
        
        try {
            prepareConnection("/stop", "GET").getResponseCode();
        }
         catch (IOException e) {
            getLogger().debug( "webpack-dev-server does not support the `/stop` command.", e);
        }
        
        DevServerWatchDog watchDogInstance = watchDog.get();
        if (watchDogInstance != null) {
            watchDogInstance.stop();
        }
        
        Process process = webpackProcess.get();
        if (process != null && process.isAlive()) {
            process.destroy();
        }
        
        atomicHandler.set(null);
        removeRunningDevServerPort();
    }
    
    void join() {
        devServerStartFuture.join();
    }
    
    private static File getDevServerPortFile(File npmFolder) {
        String jvmUuid = System.getProperty(WEBPACK_PORTFILE_UUID_PROPERTY);
        if (jvmUuid == null) {
            jvmUuid = UUID.randomUUID().toString();
            System.setProperty(WEBPACK_PORTFILE_UUID_PROPERTY, jvmUuid);
        }
        
        String frontendBuildPath = npmFolder.getAbsolutePath();
        String uniqueUid = UUID.nameUUIDFromBytes( (jvmUuid + frontendBuildPath).getBytes(StandardCharsets.UTF_8)) .toString();
        return new File(System.getProperty("java.io.tmpdir"), uniqueUid);
    }
    
}


