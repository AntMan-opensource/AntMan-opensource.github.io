package org.silverpeas.core.web.authentication;
import org.silverpeas.core.admin.user.model.User;
import org.silverpeas.core.admin.user.model.UserDetail;
import org.silverpeas.core.security.authentication.AuthenticationCredential;
import org.silverpeas.core.security.authentication.AuthenticationProtocol;
import org.silverpeas.core.security.authentication.AuthenticationResponse;
import org.silverpeas.core.security.authentication.AuthenticationResponse.Status;
import org.silverpeas.core.security.authentication.AuthenticationService;
import org.silverpeas.core.security.authentication.exception.AuthenticationException;
import org.silverpeas.core.security.authentication.exception.AuthenticationNoMoreUserConnectionAttemptException;
import org.silverpeas.core.security.authentication.exception.AuthenticationUserMustAcceptTermsOfService;
import org.silverpeas.core.security.authentication.verifier.AuthenticationUserVerifierFactory;
import org.silverpeas.core.security.authentication.verifier.UserCanTryAgainToLoginVerifier;
import org.silverpeas.core.security.authentication.verifier.UserMustAcceptTermsOfServiceVerifier;
import org.silverpeas.core.util.*;
import org.silverpeas.kernel.bundle.ResourceLocator;
import org.silverpeas.kernel.bundle.SettingBundle;
import org.silverpeas.kernel.logging.SilverLogger;
import org.silverpeas.core.web.http.HttpRequest;
import org.silverpeas.core.web.mvc.webcomponent.SilverpeasHttpServlet;
import org.silverpeas.kernel.util.StringUtil;
import javax.inject.Inject;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.io.Serializable;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;
import static java.text.MessageFormat.format;
public class AuthenticationServlet extends SilverpeasHttpServlet {
  private static final long serialVersionUID = -8695946617361150513L;
  private static final String SSO_NON_EXISTING_USER_ACCOUNT = "Error_SsoOnUnexistantUserAccount";
  private static final String LOGIN_ERROR_PAGE = "/Login?ErrorCode=";
  private static final int COOKIE_TIME_LIFE = 31536000;
  private AuthenticationService authService;
  private SilverpeasSessionOpener silverpeasSessionOpener;
  private CredentialEncryption credentialEncryption;
  private MandatoryQuestionChecker mandatoryQuestionChecker;
  private final SilverLogger logger = SilverLogger.getLogger(this);
  public void doPost(HttpServletRequest servletRequest, HttpServletResponse response) {
    try {
      HttpRequest request = HttpRequest.decorate(servletRequest);
      final UserSessionStatus userSessionStatus = existOpenedUserSession(servletRequest);
      final AuthenticationParameters authenticationParameters = new AuthenticationParameters(request);
      if (userSessionStatus.isValid()) {
        final User connectedUser = userSessionStatus.getInfo().getUserDetail();
        if (authenticationParameters.isSsoMode() && connectedUser.getLogin().equals(authenticationParameters.getLogin()) && connectedUser.getDomainId().equals(authenticationParameters.getDomainId())) {
          SilverLogger.getLogger("silverpeas.sso") .debug(() -> format( "SSO Authentication of PRINCIPAL {0} on domain {1}, keeping existing user " + "session alive {2}", connectedUser.getLogin(), connectedUser.getDomainId(), userSessionStatus.getInfo().getSessionId()));
          forward(request, response, "/Login");
          return;
        }
        
        final HttpSession session = servletRequest.getSession(false);
        silverpeasSessionOpener.closeSession(session);
      }
      
      request.getSession();
      if (!StringUtil.isDefined(request.getCharacterEncoding())) {
        request.setCharacterEncoding(Charsets.UTF_8.name());
      }
      
      if (!userSessionStatus.isValid() && request.isWithinAnonymousUserSession()) {
        renewHttpSession(request);
      }
      
      AuthenticationResponse result = authenticate(request, authenticationParameters);
      UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier = AuthenticationUserVerifierFactory.getUserCanTryAgainToLoginVerifier( authenticationParameters.getCredential());
      userCanTryAgainToLoginVerifier.clearSession(request);
      if (result == null || result.getStatus().isInError()) {
        processError(result, request, response, authenticationParameters, userCanTryAgainToLoginVerifier);
      }
       else {
        openNewSession(result.getToken(), request, response, authenticationParameters, userCanTryAgainToLoginVerifier);
      }
      
    }
     catch (ServletException | IOException e) {
      SilverLogger.getLogger(this).error(e);
      response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
    
  }
  
  private void openNewSession(final String token, HttpRequest request, HttpServletResponse response, AuthenticationParameters authenticationParameters, UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier) throws ServletException, IOException {
    userCanTryAgainToLoginVerifier.clearCache();
    if (authenticationParameters.getDomainId() != null) {
      storeDomain(response, authenticationParameters);
    }
    
    storeLogin(response, authenticationParameters);
    if (request.getAttribute("skipTermsOfServiceAcceptance") == null) {
      UserMustAcceptTermsOfServiceVerifier verifier = AuthenticationUserVerifierFactory. getUserMustAcceptTermsOfServiceVerifier(authenticationParameters.getCredential());
      try {
        verifier.verify();
      }
       catch (AuthenticationUserMustAcceptTermsOfService authenticationUserMustAcceptTermsOfService) {
        logger.warn(authenticationUserMustAcceptTermsOfService.getMessage(), authenticationUserMustAcceptTermsOfService);
        forward(request, response, verifier.getDestination(request));
        return;
      }
      
    }
    
    String destination = mandatoryQuestionChecker.check(request, token);
    if (StringUtil.isDefined(destination)) {
      forward(request, response, destination);
      return;
    }
    
    String absoluteUrl = silverpeasSessionOpener.openSession(request, token);
    HttpSession session = request.getSession(false);
    session. setAttribute("Silverpeas_pwdForHyperlink", authenticationParameters.getPassword());
    response.sendRedirect(response.encodeRedirectURL(absoluteUrl));
  }
  
  private void processError(final AuthenticationResponse error, final HttpRequest request, final HttpServletResponse response, final AuthenticationParameters authenticationParameters, final UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier) throws ServletException, IOException {
    String url;
    if (authenticationParameters.isCasMode()) {
      url = "/admin/jsp/casAuthenticationError.jsp";
    }
     else if (error != null) {
      url = processUrlForError(error, request, response, authenticationParameters, userCanTryAgainToLoginVerifier);
      if (url != null) {
        String paramDelimiter = (url.contains("?") ? "&" : "?");
        url += paramDelimiter + LoginServlet.PARAM_DOMAINID + "=" + authenticationParameters.getDomainId();
      }
       else {
        return;
      }
      
    }
     else {
      url = LOGIN_ERROR_PAGE + Status.UNKNOWN_FAILURE;
    }
    
    response.sendRedirect( response.encodeRedirectURL(URLUtil.getFullApplicationURL(request) + url));
  }
  
  private String processUrlForError(final AuthenticationResponse error, final HttpRequest request, final HttpServletResponse response, final AuthenticationParameters authenticationParameters, final UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier) throws ServletException, IOException {
    final String url;
    Status status = error.getStatus();
    if (status == Status.BAD_LOGIN_PASSWORD || status == Status.BAD_LOGIN_PASSWORD_DOMAIN) {
      url = processBadLogin(status, request, response, authenticationParameters, userCanTryAgainToLoginVerifier);
    }
     else if (status == Status.USER_ACCOUNT_BLOCKED || status == Status.USER_ACCOUNT_DEACTIVATED) {
      url = processBadAccountState(status, response, authenticationParameters, userCanTryAgainToLoginVerifier);
    }
     else if (status == Status.PASSWORD_EXPIRED || status == Status.PASSWORD_TO_CHANGE) {
      HttpSession session = request.getSession();
      url = processPasswordExpiration(authenticationParameters, session);
    }
     else if (status == Status.PASSWORD_TO_CHANGE_ON_FIRST_LOGIN) {
      storeLogin(response, authenticationParameters);
      storeDomain(response, authenticationParameters);
      url = AuthenticationUserVerifierFactory.getUserMustChangePasswordVerifier( authenticationParameters.getCredential()).getDestinationOnFirstLogin(request);
      forward(request, response, url);
      return null;
    }
     else if (authenticationParameters.isSsoMode()) {
      storeDomain(response, authenticationParameters);
      storeLogin(response, authenticationParameters);
      url = LOGIN_ERROR_PAGE + SSO_NON_EXISTING_USER_ACCOUNT;
    }
     else {
      url = LOGIN_ERROR_PAGE + status.getCode();
    }
    
    return url;
  }
  
  private String processPasswordExpiration(final AuthenticationParameters authenticationParameters, final HttpSession session) {
    final String url;
    String allowPasswordChange = (String) session.getAttribute( AuthenticationProtocol.PASSWORD_CHANGE_ALLOWED);
    if (StringUtil.getBooleanValue(allowPasswordChange)) {
      SettingBundle settings = ResourceLocator.getSettingBundle( "org.silverpeas.authentication.settings.passwordExpiration");
      url = settings.getString("passwordExpiredURL") + "?login=" + authenticationParameters. getLogin() + "&domainId=" + authenticationParameters.getDomainId();
    }
     else {
      url = LOGIN_ERROR_PAGE + Status.PASSWORD_EXPIRED;
    }
    
    return url;
  }
  
  private String processBadAccountState(final Status error, final HttpServletResponse response, final AuthenticationParameters authenticationParameters, final UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier) {
    String url = null;
    if (userCanTryAgainToLoginVerifier.isActivated() || StringUtil.isDefined( userCanTryAgainToLoginVerifier.getUser().getId())) {
      storeLogin(response, authenticationParameters);
      storeDomain(response, authenticationParameters);
      url = AuthenticationUserVerifierFactory .getUserCanLoginVerifier(userCanTryAgainToLoginVerifier.getUser()) .getErrorDestination();
    }
     else if (error == Status.BAD_LOGIN_PASSWORD || error == Status.BAD_LOGIN_PASSWORD_DOMAIN) {
      url = LOGIN_ERROR_PAGE + error;
    }
    
    return url;
  }
  
  private String processBadLogin(final Status error, final HttpRequest request, final HttpServletResponse response, final AuthenticationParameters authenticationParameters, final UserCanTryAgainToLoginVerifier userCanTryAgainToLoginVerifier) {
    String url = null;
    try {
      if (userCanTryAgainToLoginVerifier.isActivated()) {
        storeLogin(response, authenticationParameters);
        storeDomain(response, authenticationParameters);
      }
      
      if (error == Status.BAD_LOGIN_PASSWORD || error == Status.BAD_LOGIN_PASSWORD_DOMAIN) {
        url = userCanTryAgainToLoginVerifier.verify() .performRequestUrl(request, LOGIN_ERROR_PAGE + error);
      }
      
    }
     catch (AuthenticationNoMoreUserConnectionAttemptException e) {
      logger.error(e.getMessage(), e);
      url = userCanTryAgainToLoginVerifier.getErrorDestination();
    }
    
    return url;
  }
  
  private void forward(HttpServletRequest request, HttpServletResponse response, String destination) throws ServletException, IOException {
    RequestDispatcher dispatcher = request.getRequestDispatcher(destination);
    dispatcher.forward(request, response);
  }
  
  private void storeLogin(HttpServletResponse response, AuthenticationParameters params) {
    if (isNotAnonymousAuthentication(params)) {
      String sLogin = params.getLogin();
      boolean secured = params.isSecuredAccess();
      if (params.isNewEncryptionMode()) {
        writeCookie(response, "var1", credentialEncryption.encode(sLogin), -1, secured);
        writeCookie(response, "var1", credentialEncryption.encode(sLogin), COOKIE_TIME_LIFE, secured);
      }
       else {
        writeCookie(response, "svpLogin", sLogin, -1, secured);
        writeCookie(response, "svpLogin", sLogin, COOKIE_TIME_LIFE, secured);
      }
      
    }
    
  }
  
  private void storeDomain(HttpServletResponse response, AuthenticationParameters params) {
    if (isNotAnonymousAuthentication(params)) {
      String sDomainId = params.getDomainId();
      boolean secured = params.isSecuredAccess();
      writeCookie(response, "defaultDomain", sDomainId, -1, secured);
      writeCookie(response, "defaultDomain", sDomainId, COOKIE_TIME_LIFE, secured);
    }
    
  }
  
  private boolean isNotAnonymousAuthentication(AuthenticationParameters params) {
    User anonymous = UserDetail.getAnonymousUser();
    return anonymous == null || !anonymous.getLogin().equals(params.getLogin());
  }
  
  private AuthenticationResponse authenticate(HttpServletRequest request, AuthenticationParameters authenticationParameters) {
    final String key = request.getParameter("TestKey");
    if (StringUtil.isNotDefined(key)) {
      AuthenticationCredential credential = getAuthenticationCredential(authenticationParameters);
      if (credential == null) {
        return AuthenticationResponse.error(Status.BAD_LOGIN_PASSWORD);
      }
      
      final AuthenticationResponse result;
      if (authenticationParameters.isUserByInternalAuthTokenMode() || authenticationParameters. isSsoMode() || authenticationParameters.isCasMode()) {
        result = authService.authenticate( credential.withAsDomainId(authenticationParameters.getDomainId()));
      }
       else if (authenticationParameters.isSocialNetworkMode()) {
        result = authService.authenticate(credential.withAsDomainId(authenticationParameters. getDomainId()));
      }
       else {
        result = authService.authenticate(credential .withAsPassword(authenticationParameters.getPassword()) .withAsDomainId(authenticationParameters.getDomainId()));
      }
      
      authenticationParameters.setCredential(credential);
      HttpSession session = request.getSession(false);
      for (Map.Entry<String, Serializable> capability : credential.getCapabilities().entrySet()) {
        session.setAttribute(capability.getKey(), capability.getValue());
      }
      
      return result;
    }
    
    return null;
  }
  
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    doPost(request, response);
  }
  
  private void writeCookie(HttpServletResponse response, String name, String value, int duration, boolean secure) {
    String cookieValue = URLEncoder.encode(value, Charsets.UTF_8);
    Cookie cookie = new Cookie(name, cookieValue);
    cookie.setSecure(secure);
    cookie.setMaxAge(duration);
    cookie.setPath("/");
    response.addCookie(cookie);
  }
  
  private void renewHttpSession(final HttpRequest request) {
    HttpSession session = request.getSession(false);
    Map<String, Object> attrs = new HashMap<>();
    session.getAttributeNames().asIterator().forEachRemaining(a -> {
      if (a.startsWith("Redirect") || a.equals("gotoNew")) {
        attrs.put(a, session.getAttribute(a));
      }
      
    }
    
);
    session.invalidate();
    HttpSession newSession = request.getSession(true);
    attrs.forEach(newSession::setAttribute);
  }
  
  private AuthenticationCredential getAuthenticationCredential(final AuthenticationParameters parameters) {
    try {
      return AuthenticationCredential.newWithAsLogin(parameters.getLogin());
    }
     catch (AuthenticationException e) {
      return null;
    }
    
  }
  
}


