package org.silverpeas.core.security.authentication;
import org.silverpeas.core.SilverpeasExceptionMessages;
import org.silverpeas.kernel.SilverpeasRuntimeException;
import org.silverpeas.core.admin.domain.model.Domain;
import org.silverpeas.core.admin.service.AdminController;
import org.silverpeas.core.admin.service.AdminException;
import org.silverpeas.core.admin.service.Administration;
import org.silverpeas.core.admin.user.model.User;
import org.silverpeas.core.admin.user.model.UserDetail;
import org.silverpeas.core.admin.user.model.UserFull;
import org.silverpeas.core.annotation.Service;
import org.silverpeas.core.persistence.Transaction;
import org.silverpeas.core.persistence.jdbc.DBUtil;
import org.silverpeas.core.persistence.jdbc.sql.JdbcSqlQuery;
import org.silverpeas.core.security.authentication.AuthenticationResponse.Status;
import org.silverpeas.core.security.authentication.exception.AuthenticationBadCredentialException;
import org.silverpeas.core.security.authentication.exception.AuthenticationException;
import org.silverpeas.core.security.authentication.exception.AuthenticationHostException;
import org.silverpeas.core.security.authentication.exception.AuthenticationPasswordExpired;
import org.silverpeas.core.security.authentication.exception.AuthenticationPasswordMustBeChangedAtNextLogon;
import org.silverpeas.core.security.authentication.exception.AuthenticationPasswordMustBeChangedOnFirstLogin;
import org.silverpeas.core.security.authentication.exception.AuthenticationPwdNotAvailException;
import org.silverpeas.core.security.authentication.exception.AuthenticationUserAccountBlockedException;
import org.silverpeas.core.security.authentication.exception.AuthenticationUserAccountDeactivatedException;
import org.silverpeas.core.security.authentication.verifier.AuthenticationUserVerifierFactory;
import org.silverpeas.core.security.authentication.verifier.UserCanLoginVerifier;
import org.silverpeas.kernel.bundle.ResourceLocator;
import org.silverpeas.kernel.bundle.SettingBundle;
import org.silverpeas.kernel.util.StringUtil;
import org.silverpeas.kernel.logging.SilverLogger;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.naming.InitialContext;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import static java.util.Arrays.stream;
public class AuthenticationService implements Authentication {
  private static final String DATA_SOURCE_JNDI_NAME;
  private static final String DOMAIN_TABLE_NAME;
  private static final String DOMAIN_ID_COLUMN_NAME;
  private static final String DOMAIN_AUTHENTICATION_SERVER_COLUMN_NAME;
  private static final String KEY_STORE_TABLE_NAME;
  private static final String KEY_STORE_KEY_COLUMN_NAME;
  private static final String KEY_STORE_LOGIN_COLUMN_NAME;
  private static final String KEY_STORE_DOMAIN_ID_COLUMN_NAME;
  private static final String USER_TABLE_NAME;
  private static final String USER_ID_COLUMN_NAME;
  private static final String USER_LOGIN_COLUMN_NAME;
  private static final String USER_DOMAIN_COLUMN_NAME;
  private static int autoInc = 1;
  private AdminController adminController;
  private static final Predicate<Domain> DOMAIN_WITH_AUTHENTICATION_SERVER = d -> {
    final AuthenticationServer authenticationServer = AuthenticationServer.getAuthenticationServer(d.getAuthenticationServer());
    return authenticationServer.hasProtocols();
  };
  protected AuthenticationService() {
  }
  
  private static Connection openConnection() throws AuthenticationException {
    Connection connection;
    try {
      DataSource dataSource = InitialContext.doLookup(DATA_SOURCE_JNDI_NAME);
      connection = dataSource.getConnection();
    }
     catch (Exception iex) {
      throw new AuthenticationHostException( "Connection failure with datasource " + DATA_SOURCE_JNDI_NAME, iex);
    }
    
    return connection;
  }
  
  private static void closeConnection(Connection con) {
    DBUtil.close(con);
  }
  
  public List<AuthDomain> getAllAuthDomains() {
    List<AuthDomain> domains;
    try {
      domains = stream(Administration.get() .getAllDomains()).filter(DOMAIN_WITH_AUTHENTICATION_SERVER) .collect(Collectors.toList());
    }
     catch (AdminException e) {
      SilverLogger.getLogger(this).error(e);
      domains = Collections.emptyList();
    }
    
    return domains;
  }
  
  public AuthenticationResponse authenticate(final AuthenticationCredential userCredential) {
    AuthenticationResponse result;
    try {
      String token = checkAuthentication(userCredential);
      result = AuthenticationResponse.succeed(token);
    }
     catch (AuthenticationBadCredentialException e) {
      if (isThereMultipleDomainsDefined()) {
        result = AuthenticationResponse.error(Status.BAD_LOGIN_PASSWORD_DOMAIN);
      }
       else {
        result = AuthenticationResponse.error(Status.BAD_LOGIN_PASSWORD);
      }
      
    }
     catch (AuthenticationPwdNotAvailException e) {
      result = AuthenticationResponse.error(Status.NO_PASSWORD);
    }
     catch (AuthenticationPasswordExpired e) {
      result = AuthenticationResponse.error(Status.PASSWORD_EXPIRED);
    }
     catch (AuthenticationPasswordMustBeChangedAtNextLogon e) {
      result = AuthenticationResponse.error(Status.PASSWORD_TO_CHANGE);
    }
     catch (AuthenticationPasswordMustBeChangedOnFirstLogin e) {
      result = AuthenticationResponse.error(Status.PASSWORD_TO_CHANGE_ON_FIRST_LOGIN);
    }
     catch (AuthenticationUserAccountBlockedException e) {
      result = AuthenticationResponse.error(Status.USER_ACCOUNT_BLOCKED);
    }
     catch (AuthenticationUserAccountDeactivatedException e) {
      result = AuthenticationResponse.error(Status.USER_ACCOUNT_DEACTIVATED);
    }
     catch (AuthenticationException ae) {
      result = AuthenticationResponse.error(Status.UNKNOWN_FAILURE);
    }
    
    if (!result.getStatus().succeeded()) {
      SilverLogger.getLogger(this) .error("authentication error ({0}) with login ''{1}'' and domain id ''{2}''", result.getStatus().toString(), userCredential.getLogin(), userCredential.getDomainId());
    }
    
    return result;
  }
  
  private String checkAuthentication(final AuthenticationCredential userCredential) throws AuthenticationException {
    final String key;
    if (userCredential.isPasswordSet()) {
      key = authenticateByLoginAndPasswordAndDomain(userCredential);
    }
     else {
      key = authenticateByLoginAndDomain(userCredential);
    }
    
    return key;
  }
  
  private String authenticateByLoginAndPasswordAndDomain(AuthenticationCredential credential) throws AuthenticationException {
    String password = credential.getPassword();
    String domainId = credential.getDomainId();
    if (password == null || domainId == null) {
      throw  new AuthenticationException("No login or no domain is specified!");
    }
    
    AuthenticationUserVerifierFactory.getUserCanLoginVerifier(credential).verify();
    try (Connection connection = openConnection()) {
      AuthenticationServer authenticationServer = getAuthenticationServer(connection, domainId);
      credential.getCapabilities() .put(AuthenticationProtocol.PASSWORD_CHANGE_ALLOWED, authenticationServer.isPasswordChangeAllowed() ? "yes" : "no");
      authenticationServer.authenticate(credential);
      return getAuthToken(credential);
    }
     catch (SQLException e) {
      SilverLogger.getLogger(this).warn(e);
      throw new AuthenticationException(e);
    }
    
  }
  
  private String authenticateByLoginAndDomain(AuthenticationCredential credential) throws AuthenticationException {
    String login = credential.getLogin();
    String domainId = credential.getDomainId();
    if (domainId == null) {
      throw new AuthenticationException("No domain is specified!");
    }
    
    final boolean authenticationOK;
    try (Connection connection = openConnection()) {
      final JdbcSqlQuery query = JdbcSqlQuery.select(USER_ID_COLUMN_NAME) .from(USER_TABLE_NAME) .where(USER_DOMAIN_COLUMN_NAME + " = ?", Integer.parseInt(domainId));
      if (credential.loginIgnoreCase()) {
        query.and("lower(" + USER_LOGIN_COLUMN_NAME + ") = lower(?)", login);
      }
       else {
        query.and(USER_LOGIN_COLUMN_NAME + " = ?", login);
      }
      
      authenticationOK = !query.executeWith(connection, row -> true).isEmpty();
    }
     catch (Exception ex) {
      SilverLogger.getLogger(this).warn(ex);
      throw new AuthenticationException(ex);
    }
    
    if (authenticationOK) {
      AuthenticationUserVerifierFactory.getUserCanLoginVerifier(credential).verify();
      try {
        return getAuthToken(credential);
      }
       catch (Exception e) {
        SilverLogger.getLogger(this).warn(e);
        throw new AuthenticationException(e);
      }
      
    }
    
    return null;
  }
  
  public void changePassword(AuthenticationCredential credential, String newPassword) throws AuthenticationException {
    changePasswordAndEmail(credential, newPassword, null);
  }
  
  public void changePasswordAndEmail(AuthenticationCredential credential, String newPassword, String email) throws AuthenticationException {
    String oldPassword = credential.getPassword();
    String domainId = credential.getDomainId();
    if (oldPassword == null || domainId == null || newPassword == null) {
      throw new AuthenticationBadCredentialException("The password or the domain isn't set!");
    }
    
    final UserCanLoginVerifier userCanLoginVerifier = AuthenticationUserVerifierFactory.getUserCanLoginVerifier(credential);
    userCanLoginVerifier.verify();
    try (Connection connection = openConnection()) {
      getAuthenticationServer(connection, domainId).changePassword(credential, newPassword);
      AuthenticationUserVerifierFactory.removeFromRequestCache(userCanLoginVerifier.getUser());
    }
     catch (AuthenticationException ex) {
      SilverLogger.getLogger(this).warn(ex);
      throw ex;
    }
     catch (SQLException e) {
      SilverLogger.getLogger(this).error(e);
      throw new SilverpeasRuntimeException(e);
    }
    
    onPasswordAndEmailChanged(credential, email);
  }
  
  public String getAuthToken(AuthenticationCredential credential) {
    String authKey = generateTokenFor(credential.getLogin());
    storeAuthenticationKey(credential.getLogin(), credential.getDomainId(), authKey);
    return authKey;
  }
  
  public User getUserByAuthToken(final String authToken) throws AuthenticationException {
    Administration admin = Administration.get();
    try {
      String userId = admin.getUserIdByAuthenticationKey(authToken);
      return admin.getUserDetail(userId);
    }
     catch (AdminException e) {
      throw new AuthenticationException(e);
    }
    
  }
  
  private String getAuthenticationServerName(Connection con, String domainId) throws AuthenticationException {
    JdbcSqlQuery query = JdbcSqlQuery.select(DOMAIN_AUTHENTICATION_SERVER_COLUMN_NAME) .from(DOMAIN_TABLE_NAME) .where(DOMAIN_ID_COLUMN_NAME + " = ?", Integer.parseInt(domainId));
    try {
      String domainServerName = query.executeUniqueWith(con, row -> {
          String serverName = row.getString(DOMAIN_AUTHENTICATION_SERVER_COLUMN_NAME);
          if (!StringUtil.isDefined(serverName)) {
            throw new SQLException("No server found for domain of id " + domainId);
          }
           else {
            return serverName;
          }
          
      }
      
);
      if (StringUtil.isNotDefined(domainServerName)) {
        throw new SQLException("No such domain with id " + domainId);
      }
      
      return domainServerName;
    }
     catch (SQLException e) {
      throw new AuthenticationException(e.getMessage(), e);
    }
    
  }
  
  private static String generateTokenFor(String login) {
    long nStart = login.hashCode() * new Date().getTime() * (autoInc++);
    Random rand = new Random(nStart);
    int key = rand.nextInt();
    return String.valueOf(key);
  }
  
  private void storeAuthenticationKey(String login, String domainId, String sKey) {
    Transaction.performInOne(() -> {
      JdbcSqlQuery query = JdbcSqlQuery.insertInto(KEY_STORE_TABLE_NAME) .withInsertParam(KEY_STORE_KEY_COLUMN_NAME, Integer.parseInt(sKey)) .withInsertParam(KEY_STORE_LOGIN_COLUMN_NAME, login) .withInsertParam(KEY_STORE_DOMAIN_ID_COLUMN_NAME, Integer.parseInt(domainId));
      try (Connection connection = openConnection()) {
        query.executeWith(connection);
      }
       catch (SQLException ex) {
        SilverLogger.getLogger(this).error( SilverpeasExceptionMessages.failureOnAdding("authentication key for login", login), ex);
      }
      
      return null;
    }
    
);
  }
  
  public void resetPassword(AuthenticationCredential credential, String newPassword) throws AuthenticationException {
    String login = credential.getLogin();
    String domainId = credential.getDomainId();
    if (domainId == null || newPassword == null) {
      throw new AuthenticationBadCredentialException( "The login, the password or the domain isn't set!");
    }
    
    AuthenticationUserVerifierFactory.getUserCanLoginVerifier(credential).verify();
    Connection connection = null;
    try {
      connection = openConnection();
      AuthenticationServer authenticationServer = getAuthenticationServer(connection, domainId);
      authenticationServer.resetPassword(login, credential.loginIgnoreCase(), newPassword);
    }
     catch (AuthenticationException ex) {
      SilverLogger.getLogger(this).warn(ex);
      throw ex;
    }
     finally {
      closeConnection(connection);
    }
    
    onPasswordAndEmailChanged(credential, null);
  }
  
  private void onPasswordAndEmailChanged(AuthenticationCredential credential, final String email) throws AuthenticationException {
    UserDetail user = UserDetail.getById( adminController.getUserIdByLoginAndDomain(credential.getLogin(), credential.getDomainId()));
    AuthenticationUserVerifierFactory.getUserMustChangePasswordVerifier(user) .notifyPasswordChange();
    UserFull userFull = adminController.getUserFull(user.getId());
    userFull.setNbSuccessfulLoginAttempts(0);
    userFull.setLastLoginCredentialUpdateDate(new Date());
    if (StringUtil.isDefined(email)) {
      userFull.setEmailAddress(email);
    }
    
    try {
      adminController.updateUserFull(userFull);
    }
     catch (AdminException e) {
      throw new AuthenticationException("Cannot update user full information", e);
    }
    
  }
  
  boolean isPasswordChangeAllowed(String domainId) {
    Connection connection = null;
    try {
      connection = openConnection();
      AuthenticationServer authenticationServer = getAuthenticationServer(connection, domainId);
      return authenticationServer.isPasswordChangeAllowed();
    }
     catch (AuthenticationException ex) {
      SilverLogger.getLogger(this).warn(ex);
    }
     finally {
      closeConnection(connection);
    }
    
    return false;
  }
  
  private AuthenticationServer getAuthenticationServer(Connection con, String domainId) throws AuthenticationException {
    String authenticationServerName = getAuthenticationServerName(con, domainId);
    return AuthenticationServer.getAuthenticationServer(authenticationServerName);
  }
  
  static {
    SettingBundle settings = ResourceLocator.getSettingBundle("org.silverpeas.authentication.domains");
    DATA_SOURCE_JNDI_NAME = settings.getString("SQLDomainDataSourceJNDIName");
    DOMAIN_TABLE_NAME = settings.getString("SQLDomainTableName");
    DOMAIN_ID_COLUMN_NAME = settings.getString("SQLDomainIdColumnName");
    DOMAIN_AUTHENTICATION_SERVER_COLUMN_NAME = settings.getString("SQLDomainAuthenticationServerColumnName");
    KEY_STORE_TABLE_NAME = settings.getString("SQLKeyStoreTableName");
    KEY_STORE_KEY_COLUMN_NAME = settings.getString("SQLKeyStoreKeyColumnName");
    KEY_STORE_LOGIN_COLUMN_NAME = settings.getString("SQLKeyStoreLoginColumnName");
    KEY_STORE_DOMAIN_ID_COLUMN_NAME = settings.getString("SQLKeyStoreDomainIdColumnName");
    USER_TABLE_NAME = settings.getString("SQLUserTableName");
    USER_ID_COLUMN_NAME = settings.getString("SQLUserIdColumnName");
    USER_LOGIN_COLUMN_NAME = settings.getString("SQLUserLoginColumnName");
    USER_DOMAIN_COLUMN_NAME = settings.getString("SQLUserDomainColumnName");
  }
  
}


