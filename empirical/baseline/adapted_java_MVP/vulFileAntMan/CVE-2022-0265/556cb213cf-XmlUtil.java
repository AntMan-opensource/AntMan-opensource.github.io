package com.hazelcast.internal.util;
import static com.hazelcast.internal.nio.IOUtil.closeResource;
import java.io.StringReader;
import java.io.StringWriter;
import javax.annotation.Nullable;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.SchemaFactory;
import org.xml.sax.SAXException;
import com.hazelcast.logging.ILogger;
import com.hazelcast.logging.Logger;
public final class XmlUtil {
    public static final String SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES = "hazelcast.ignoreXxeProtectionFailures";
    private static final ILogger LOGGER = Logger.getLogger(XmlUtil.class);
    private XmlUtil() {
    }
    
    public static DocumentBuilderFactory getNsAwareDocumentBuilderFactory() throws ParserConfigurationException {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        dbf.setNamespaceAware(true);
        setFeature(dbf, "http://apache.org/xml/features/disallow-doctype-decl");
        return dbf;
    }
    
    public static TransformerFactory getTransformerFactory() {
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_DTD);
        setAttribute(transformerFactory, XMLConstants.ACCESS_EXTERNAL_STYLESHEET);
        return transformerFactory;
    }
    
    public static SchemaFactory getSchemaFactory() throws SAXException {
        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_SCHEMA);
        setProperty(schemaFactory, XMLConstants.ACCESS_EXTERNAL_DTD);
        return schemaFactory;
    }
    
    public static String format(@Nullable String input, int indent) throws IllegalArgumentException {
        if (input == null || indent < 0) {
            return input;
        }
        
        if (indent == 0) {
            throw new IllegalArgumentException("Indentation must not be 0.");
        }
        
        StreamResult xmlOutput = null;
        try {
            Source xmlInput = new StreamSource(new StringReader(input));
            xmlOutput = new StreamResult(new StringWriter());
            TransformerFactory transformerFactory = getTransformerFactory();
            try {
                transformerFactory.setAttribute("indent-number", indent);
            }
             catch (IllegalArgumentException e) {
                if (LOGGER.isFinestEnabled()) {
                    LOGGER.finest("Failed to set indent-number attribute; cause: " + e.getMessage());
                }
                
            }
            
            Transformer transformer = transformerFactory.newTransformer();
            transformer.setErrorListener(ThrowingErrorListener.INSTANCE);
            transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
            transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
            try {
                transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", Integer.toString(indent));
            }
             catch (IllegalArgumentException e) {
                if (LOGGER.isFinestEnabled()) {
                    LOGGER.finest("Failed to set indent-amount property; cause: " + e.getMessage());
                }
                
            }
            
            transformer.transform(xmlInput, xmlOutput);
            return xmlOutput.getWriter().toString();
        }
         catch (Exception e) {
            LOGGER.warning(e);
            return input;
        }
         finally {
            if (xmlOutput != null) {
                closeResource(xmlOutput.getWriter());
            }
            
        }
        
    }
    
    public ErrorListener getErrorListener() {
        return ThrowingErrorListener.INSTANCE;
    }
    
    static void setAttribute(TransformerFactory transformerFactory, String attributeName) {
        try {
            transformerFactory.setAttribute(attributeName, "");
        }
         catch (IllegalArgumentException iae) {
            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {
                LOGGER.warning("Enabling XXE protection failed. The attribute " + attributeName + " is not supported by the TransformerFactory. The " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property is used so the XML processing continues in the UNSECURE mode" + " with XXE protection disabled!!!");
            }
             else {
                LOGGER.severe("Enabling XXE protection failed. The attribute " + attributeName + " is not supported by the TransformerFactory. This usually mean an outdated XML processor" + " is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by" + " fixing the classpath, the " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property can be used to disable XML External Entity protections." + " We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!", iae);
                throw iae;
            }
            
        }
        
    }
    
    static void setFeature(DocumentBuilderFactory dbf, String featureName) throws ParserConfigurationException {
        try {
            dbf.setFeature(featureName, true);
        }
         catch (ParserConfigurationException e) {
            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {
                LOGGER.warning("Enabling XXE protection failed. The feature " + featureName + " is not supported by the DocumentBuilderFactory. The " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property is used so the XML processing continues in the UNSECURE mode" + " with XXE protection disabled!!!");
            }
             else {
                LOGGER.severe("Enabling XXE protection failed. The feature " + featureName + " is not supported by the DocumentBuilderFactory. This usually mean an outdated XML processor" + " is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by" + " fixing the classpath, the " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property can be used to disable XML External Entity protections." + " We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!", e);
                throw e;
            }
            
        }
        
    }
    
    static void setProperty(SchemaFactory schemaFactory, String propertyName) throws SAXException {
        try {
            schemaFactory.setProperty(propertyName, "");
        }
         catch (SAXException e) {
            if (Boolean.getBoolean(SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES)) {
                LOGGER.warning("Enabling XXE protection failed. The property " + propertyName + " is not supported by the SchemaFactory. The " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property is used so the XML processing continues in the UNSECURE mode" + " with XXE protection disabled!!!");
            }
             else {
                LOGGER.severe("Enabling XXE protection failed. The property " + propertyName + " is not supported by the SchemaFactory. This usually mean an outdated XML processor" + " is present on the classpath (e.g. Xerces, Xalan). If you are not able to resolve the issue by" + " fixing the classpath, the " + SYSTEM_PROPERTY_IGNORE_XXE_PROTECTION_FAILURES + " system property can be used to disable XML External Entity protections." + " We don't recommend disabling the XXE as such the XML processor configuration is unsecure!!!", e);
                throw e;
            }
            
        }
        
    }
    
    static final class ThrowingErrorListener implements ErrorListener {
        public static final ThrowingErrorListener INSTANCE = new ThrowingErrorListener();
        private ThrowingErrorListener() {
        }
        
        public void warning(TransformerException exception) throws TransformerException {
            throw exception;
        }
        
        public void fatalError(TransformerException exception) throws TransformerException {
            throw exception;
        }
        
        public void error(TransformerException exception) throws TransformerException {
            throw exception;
        }
        
    }
    
}


