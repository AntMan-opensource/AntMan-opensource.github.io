package com.compuware.jenkins.common.utils;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.lang.StringUtils;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import com.compuware.jenkins.common.configuration.Messages;
import hudson.AbortException;
import hudson.FilePath;
public class CLIVersionUtils {
	public static final String HOST_CONNECTION_PROTOCOL_MINIMUM_VERSION = "19.4.1"; 
	 private CLIVersionUtils() {
	}
	
	 public static String getCLIVersion(FilePath cliDirectory, String minimumVersion) throws IOException, InterruptedException {
		String version = ""; 
		 if (!cliDirectory.exists()){
			throw new AbortException(Messages.cliNotInstalledError());
		}
		
		FilePath versionFilePath = cliDirectory.child(cliDirectory.getRemote() + CommonConstants.SLASH + CommonConstants.VERSION_FILE);
		 if (!versionFilePath.exists()){
			throw new AbortException(Messages.cliOldUnknownVersionError(minimumVersion));
		}
		
				 version = parseXml(versionFilePath.read());
		 return version;
	}
	
	 public static void checkCLICompatibility(String version, String minimumVersion) throws IOException, InterruptedException {
		if (StringUtils.isEmpty(version)){
			throw new AbortException(Messages.cliOldUnknownVersionError(minimumVersion));
		}
		
		else if (compareVersions(version, minimumVersion) < 0){
			throw new AbortException(Messages.cliOldVersionError(version, minimumVersion));
		}
		
	}
	
	 public static void checkCLICompatibility(FilePath cliDirectory, String minimumVersion) throws IOException, InterruptedException {
		String version = getCLIVersion(cliDirectory, minimumVersion);
		checkCLICompatibility(version, minimumVersion);
	}
	
	 public static void checkProtocolSupported(String cliVersion) throws AbortException  {
		if (compareVersions(cliVersion, HOST_CONNECTION_PROTOCOL_MINIMUM_VERSION) < 0){
			throw new AbortException(Messages.hostConnectionProtocolCliVersionError(cliVersion, HOST_CONNECTION_PROTOCOL_MINIMUM_VERSION));
		}
		
	}
	
	 private static int compareVersions(String cliVersion, String minimumVersion) {
		if (StringUtils.isEmpty(cliVersion)){
			return -1;
		}
		
		String[] minimumVersionParts = StringUtils.split(minimumVersion, '.');
		String[] cliVersionParts = StringUtils.split(cliVersion, '.');
		int length = Math.max(minimumVersionParts.length, cliVersionParts.length);
		for (int i = 0; i < length; i++){
			int minimumVersionPart = i < minimumVersionParts.length ? Integer.parseInt(minimumVersionParts[i]) : 0;
			int cliVersionPart = i < cliVersionParts.length ? Integer.parseInt(cliVersionParts[i]) : 0;
			if (cliVersionPart < minimumVersionPart){
				return -1;
			}
			
			else if (cliVersionPart > minimumVersionPart){
				return 1;
			}
			
		}
		
		return 0;
	}
	
	 private static String parseXml(InputStream versionfile) throws IOException {
		String version = ""; 
		 try {
		    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		    Document document = dBuilder.parse(versionfile);
		     version = document.getDocumentElement().getAttribute("version"); 
		}
		
		catch (ParserConfigurationException | SAXException e) {
			throw new AbortException(Messages.cliParseXmlError());
		}
		
		 return version;
	}
	
}


