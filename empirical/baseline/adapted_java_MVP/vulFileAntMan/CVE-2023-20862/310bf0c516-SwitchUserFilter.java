package org.springframework.security.web.authentication.switchuser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.support.MessageSourceAccessor;
import org.springframework.core.log.LogMessage;
import org.springframework.security.authentication.AccountExpiredException;
import org.springframework.security.authentication.AccountStatusUserDetailsChecker;
import org.springframework.security.authentication.AuthenticationCredentialsNotFoundException;
import org.springframework.security.authentication.AuthenticationDetailsSource;
import org.springframework.security.authentication.CredentialsExpiredException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.SpringSecurityMessageSource;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsChecker;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.security.web.context.RequestAttributeSecurityContextRepository;
import org.springframework.security.web.context.SecurityContextRepository;
import org.springframework.security.web.util.UrlUtils;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;
import org.springframework.util.Assert;
import org.springframework.web.filter.GenericFilterBean;
import org.springframework.web.util.UrlPathHelper;
public class SwitchUserFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware {
	public static final String SPRING_SECURITY_SWITCH_USERNAME_KEY = "username";
	public static final String ROLE_PREVIOUS_ADMINISTRATOR = "ROLE_PREVIOUS_ADMINISTRATOR";
	private ApplicationEventPublisher eventPublisher;
	private AuthenticationDetailsSource<HttpServletRequest, ?> authenticationDetailsSource = new WebAuthenticationDetailsSource();
	protected MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();
	private RequestMatcher exitUserMatcher = createMatcher("/logout/impersonate");
	private RequestMatcher switchUserMatcher = createMatcher("/login/impersonate");
	private String targetUrl;
	private String switchFailureUrl;
	private String usernameParameter = SPRING_SECURITY_SWITCH_USERNAME_KEY;
	private String switchAuthorityRole = ROLE_PREVIOUS_ADMINISTRATOR;
	private SwitchUserAuthorityChanger switchUserAuthorityChanger;
	private UserDetailsService userDetailsService;
	private UserDetailsChecker userDetailsChecker = new AccountStatusUserDetailsChecker();
	private AuthenticationSuccessHandler successHandler;
	private AuthenticationFailureHandler failureHandler;
	private SecurityContextRepository securityContextRepository = new RequestAttributeSecurityContextRepository();
	public void afterPropertiesSet() {
		Assert.notNull(this.userDetailsService, "userDetailsService must be specified");
		Assert.isTrue(this.successHandler != null || this.targetUrl != null, "You must set either a successHandler or the targetUrl");
		if (this.targetUrl != null) {
			Assert.isNull(this.successHandler, "You cannot set both successHandler and targetUrl");
			this.successHandler = new SimpleUrlAuthenticationSuccessHandler(this.targetUrl);
		}
		
		if (this.failureHandler == null) {
			this.failureHandler = (this.switchFailureUrl != null) ? new SimpleUrlAuthenticationFailureHandler(this.switchFailureUrl) : new SimpleUrlAuthenticationFailureHandler();
		}
		
		else {
			Assert.isNull(this.switchFailureUrl, "You cannot set both a switchFailureUrl and a failureHandler");
		}
		
	}
	
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
	}
	
	private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
		 if (requiresSwitchUser(request)) {
			 try {
				Authentication targetUser = attemptSwitchUser(request);
				 SecurityContext context = SecurityContextHolder.createEmptyContext();
				context.setAuthentication(targetUser);
				SecurityContextHolder.setContext(context);
				this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", targetUser));
				this.securityContextRepository.saveContext(context, request, response);
				 this.successHandler.onAuthenticationSuccess(request, response, targetUser);
			}
			
			catch (AuthenticationException ex) {
				this.logger.debug("Failed to switch user", ex);
				this.failureHandler.onAuthenticationFailure(request, response, ex);
			}
			
			return;
		}
		
		if (requiresExitUser(request)) {
			 Authentication originalUser = attemptExitUser(request);
			 SecurityContext context = SecurityContextHolder.createEmptyContext();
			context.setAuthentication(originalUser);
			SecurityContextHolder.setContext(context);
			this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", originalUser));
			this.securityContextRepository.saveContext(context, request, response);
			 this.successHandler.onAuthenticationSuccess(request, response, originalUser);
			return;
		}
		
		this.logger.trace(LogMessage.format("Did not attempt to switch user since request did not match [%s] or [%s]", this.switchUserMatcher, this.exitUserMatcher));
		chain.doFilter(request, response);
	}
	
	 protected Authentication attemptSwitchUser(HttpServletRequest request) throws AuthenticationException {
		UsernamePasswordAuthenticationToken targetUserRequest;
		String username = request.getParameter(this.usernameParameter);
		username = (username != null) ? username : "";
		this.logger.debug(LogMessage.format("Attempting to switch to user [%s]", username));
		UserDetails targetUser = this.userDetailsService.loadUserByUsername(username);
		this.userDetailsChecker.check(targetUser);
		 targetUserRequest = createSwitchUserToken(request, targetUser);
		 if (this.eventPublisher != null) {
			this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent( SecurityContextHolder.getContext().getAuthentication(), targetUser));
		}
		
		return targetUserRequest;
	}
	
	 protected Authentication attemptExitUser(HttpServletRequest request) throws AuthenticationCredentialsNotFoundException {
		 Authentication current = SecurityContextHolder.getContext().getAuthentication();
		if (current == null) {
			throw new AuthenticationCredentialsNotFoundException(this.messages .getMessage("SwitchUserFilter.noCurrentUser", "No current user associated with this request"));
		}
		
		 Authentication original = getSourceAuthentication(current);
		if (original == null) {
			this.logger.debug("Failed to find original user");
			throw new AuthenticationCredentialsNotFoundException(this.messages .getMessage("SwitchUserFilter.noOriginalAuthentication", "Failed to find original user"));
		}
		
		 UserDetails originalUser = null;
		Object obj = original.getPrincipal();
		if ((obj != null) && obj instanceof UserDetails) {
			originalUser = (UserDetails) obj;
		}
		
		 if (this.eventPublisher != null) {
			this.eventPublisher.publishEvent(new AuthenticationSwitchUserEvent(current, originalUser));
		}
		
		return original;
	}
	
	 private UsernamePasswordAuthenticationToken createSwitchUserToken(HttpServletRequest request, UserDetails targetUser) {
		UsernamePasswordAuthenticationToken targetUserRequest;
		 Authentication currentAuthentication = getCurrentAuthentication(request);
		GrantedAuthority switchAuthority = new SwitchUserGrantedAuthority(this.switchAuthorityRole, currentAuthentication);
		 Collection<? extends GrantedAuthority> orig = targetUser.getAuthorities();
		 if (this.switchUserAuthorityChanger != null) {
			orig = this.switchUserAuthorityChanger.modifyGrantedAuthorities(targetUser, currentAuthentication, orig);
		}
		
		 List<GrantedAuthority> newAuths = new ArrayList<>(orig);
		newAuths.add(switchAuthority);
		 targetUserRequest = UsernamePasswordAuthenticationToken.authenticated(targetUser, targetUser.getPassword(), newAuths);
		 targetUserRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));
		return targetUserRequest;
	}
	
	private Authentication getCurrentAuthentication(HttpServletRequest request) {
		try {
			 return attemptExitUser(request);
		}
		
		catch (AuthenticationCredentialsNotFoundException ex) {
			return SecurityContextHolder.getContext().getAuthentication();
		}
		
	}
	
	 private Authentication getSourceAuthentication(Authentication current) {
		Authentication original = null;
		 Collection<? extends GrantedAuthority> authorities = current.getAuthorities();
		for (GrantedAuthority auth : authorities) {
			 if (auth instanceof SwitchUserGrantedAuthority) {
				original = ((SwitchUserGrantedAuthority) auth).getSource();
				this.logger.debug(LogMessage.format("Found original switch user granted authority [%s]", original));
			}
			
		}
		
		return original;
	}
	
	 protected boolean requiresExitUser(HttpServletRequest request) {
		return this.exitUserMatcher.matches(request);
	}
	
	 protected boolean requiresSwitchUser(HttpServletRequest request) {
		return this.switchUserMatcher.matches(request);
	}
	
	public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) throws BeansException {
		this.eventPublisher = eventPublisher;
	}
	
	public void setAuthenticationDetailsSource( AuthenticationDetailsSource<HttpServletRequest, ?> authenticationDetailsSource) {
		Assert.notNull(authenticationDetailsSource, "AuthenticationDetailsSource required");
		this.authenticationDetailsSource = authenticationDetailsSource;
	}
	
	public void setMessageSource(MessageSource messageSource) {
		Assert.notNull(messageSource, "messageSource cannot be null");
		this.messages = new MessageSourceAccessor(messageSource);
	}
	
	 public void setUserDetailsService(UserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}
	
	 public void setExitUserUrl(String exitUserUrl) {
		Assert.isTrue(UrlUtils.isValidRedirectUrl(exitUserUrl), "exitUserUrl cannot be empty and must be a valid redirect URL");
		this.exitUserMatcher = createMatcher(exitUserUrl);
	}
	
	 public void setExitUserMatcher(RequestMatcher exitUserMatcher) {
		Assert.notNull(exitUserMatcher, "exitUserMatcher cannot be null");
		this.exitUserMatcher = exitUserMatcher;
	}
	
	 public void setSwitchUserUrl(String switchUserUrl) {
		Assert.isTrue(UrlUtils.isValidRedirectUrl(switchUserUrl), "switchUserUrl cannot be empty and must be a valid redirect URL");
		this.switchUserMatcher = createMatcher(switchUserUrl);
	}
	
	 public void setSwitchUserMatcher(RequestMatcher switchUserMatcher) {
		Assert.notNull(switchUserMatcher, "switchUserMatcher cannot be null");
		this.switchUserMatcher = switchUserMatcher;
	}
	
	 public void setTargetUrl(String targetUrl) {
		this.targetUrl = targetUrl;
	}
	
	 public void setSuccessHandler(AuthenticationSuccessHandler successHandler) {
		Assert.notNull(successHandler, "successHandler cannot be null");
		this.successHandler = successHandler;
	}
	
	 public void setSwitchFailureUrl(String switchFailureUrl) {
		Assert.isTrue(UrlUtils.isValidRedirectUrl(switchFailureUrl), "switchFailureUrl must be a valid redirect URL");
		this.switchFailureUrl = switchFailureUrl;
	}
	
	 public void setFailureHandler(AuthenticationFailureHandler failureHandler) {
		Assert.notNull(failureHandler, "failureHandler cannot be null");
		this.failureHandler = failureHandler;
	}
	
	 public void setSwitchUserAuthorityChanger(SwitchUserAuthorityChanger switchUserAuthorityChanger) {
		this.switchUserAuthorityChanger = switchUserAuthorityChanger;
	}
	
	 public void setUserDetailsChecker(UserDetailsChecker userDetailsChecker) {
		this.userDetailsChecker = userDetailsChecker;
	}
	
	 public void setUsernameParameter(String usernameParameter) {
		this.usernameParameter = usernameParameter;
	}
	
	 public void setSwitchAuthorityRole(String switchAuthorityRole) {
		Assert.notNull(switchAuthorityRole, "switchAuthorityRole cannot be null");
		this.switchAuthorityRole = switchAuthorityRole;
	}
	
	 public void setSecurityContextRepository(SecurityContextRepository securityContextRepository) {
		Assert.notNull(securityContextRepository, "securityContextRepository cannot be null");
		this.securityContextRepository = securityContextRepository;
	}
	
	private static RequestMatcher createMatcher(String pattern) {
		return new AntPathRequestMatcher(pattern, "POST", true, new UrlPathHelper());
	}
	
}


