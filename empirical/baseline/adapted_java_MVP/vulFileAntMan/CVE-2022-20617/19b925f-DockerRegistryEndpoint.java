package org.jenkinsci.plugins.docker.commons.credentials;
import com.cloudbees.plugins.credentials.CredentialsProvider;
import com.cloudbees.plugins.credentials.common.IdCredentials;
import com.cloudbees.plugins.credentials.common.StandardCredentials;
import com.cloudbees.plugins.credentials.common.StandardListBoxModel;
import com.cloudbees.plugins.credentials.domains.DomainRequirement;
import com.cloudbees.plugins.credentials.domains.HostnameRequirement;
import hudson.Extension;
import hudson.FilePath;
import hudson.Util;
import hudson.model.AbstractBuild;
import hudson.model.AbstractDescribableImpl;
import hudson.model.Describable;
import hudson.model.Descriptor;
import hudson.model.Item;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.remoting.VirtualChannel;
import hudson.util.ListBoxModel;
import jenkins.authentication.tokens.api.AuthenticationTokens;
import jenkins.model.Jenkins;
import org.kohsuke.stapler.AncestorInPath;
import org.kohsuke.stapler.DataBoundConstructor;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Collections;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import static com.cloudbees.plugins.credentials.CredentialsMatchers.*;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Launcher;
import hudson.slaves.WorkspaceList;
import org.jenkinsci.plugins.docker.commons.tools.DockerTool;
public class DockerRegistryEndpoint extends AbstractDescribableImpl<DockerRegistryEndpoint> {
    private static final Pattern DOCKER_REGISTRY_PATTERN = Pattern .compile("(([^/]+\\.[^/]+)/)?(([a-z0-9_]+)/)?([a-zA-Z0-9-_\\.]+)(:([a-z0-9-_\\.]+))?");
    private static final Logger LOGGER = Logger.getLogger(DockerRegistryEndpoint.class.getName());
    private final String url;
    private final @CheckForNull String credentialsId;
    public DockerRegistryEndpoint(String url, String credentialsId) {
        this.url = Util.fixEmpty(url);
        this.credentialsId = Util.fixEmpty(credentialsId);
    }
    
    public static DockerRegistryEndpoint fromImageName(String s, @CheckForNull String credentialsId) {
        Matcher matcher = DOCKER_REGISTRY_PATTERN.matcher(s);
        if (!matcher.matches() || matcher.groupCount() < 7) {
            throw new IllegalArgumentException(s + " does not match regex " + DOCKER_REGISTRY_PATTERN);
        }
        
        String url;
        try {
            url = matcher.group(2) == null ? null : new URL("https://" + matcher.group(2)).toString();
        }
         catch (MalformedURLException e) {
            throw new IllegalArgumentException(s + " can not be parsed as URL: " + e.getMessage());
        }
        
        return new DockerRegistryEndpoint(url, credentialsId);
    }
    
    public @Nonnull URL getEffectiveUrl() throws IOException {
        if (url != null) {
            return new URL(url);
        }
         else {
            return new URL("https://index.docker.io/v1/");
        }
        
    }
    
    public @Nullable String getUrl() {
        return url;
    }
    
    public @Nullable String getCredentialsId() {
        return credentialsId;
    }
    
    public @CheckForNull DockerRegistryToken getToken(Item context) {
        if (credentialsId == null) {
            return null;
        }
        
        List<DomainRequirement> requirements = Collections.emptyList();
        try {
            requirements = Collections.<DomainRequirement>singletonList(new HostnameRequirement(getEffectiveUrl().getHost()));
        }
         catch (IOException e) {
            LOGGER.log(Level.FINE, "Unable to add domain requirement for endpoint URL", e);
        }
        
        return AuthenticationTokens.convert(DockerRegistryToken.class, firstOrNull(CredentialsProvider.lookupCredentials( IdCredentials.class, context, Jenkins.getAuthentication(), requirements), allOf(AuthenticationTokens.matcher(DockerRegistryToken.class), withId(credentialsId))));
    }
    
    @CheckForNull DockerRegistryToken getToken(@CheckForNull Run context) { if (credentialsId == null) { return null; }
        List<DomainRequirement> requirements = Collections.emptyList();
        try {
            requirements = Collections.<DomainRequirement>singletonList(new HostnameRequirement(getEffectiveUrl().getHost()));
        }
         catch (IOException e) {
            LOGGER.log(Level.FINE, "Unable to add domain requirement for endpoint URL", e);
        }
        
        return AuthenticationTokens.convert(DockerRegistryToken.class, CredentialsProvider.findCredentialById(credentialsId, IdCredentials.class, context, requirements));
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(@Nonnull AbstractBuild build) throws IOException, InterruptedException {
        final FilePath workspace = build.getWorkspace();
        if (workspace == null) {
            throw new IllegalStateException("Requires workspace.");
        }
        
        return newKeyMaterialFactory(build.getParent(), workspace.getChannel());
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(Item context, @Nonnull VirtualChannel target) throws IOException, InterruptedException {
        return newKeyMaterialFactory(context, target, null, TaskListener.NULL);
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(@CheckForNull Item context, @Nonnull VirtualChannel target, @CheckForNull Launcher launcher, @Nonnull TaskListener listener) throws IOException, InterruptedException {
        if (credentialsId == null) {
            return KeyMaterialFactory.NULL; 
        }
        
        DockerRegistryToken token = getToken(context);
        if (token == null) {
            throw new AbortException("Could not find credentials matching " + credentialsId);
        }
        
        return token.newKeyMaterialFactory(getEffectiveUrl(), target, launcher, listener);
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(@CheckForNull Item context, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener, @Nonnull String dockerExecutable) throws IOException, InterruptedException {
        return newKeyMaterialFactory(context, workspace, launcher, new EnvVars(), listener, dockerExecutable);
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(@CheckForNull Item context, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull EnvVars env, @Nonnull TaskListener listener, @Nonnull String dockerExecutable) throws IOException, InterruptedException {
        if (credentialsId == null) {
            return KeyMaterialFactory.NULL; 
        }
        
        DockerRegistryToken token = getToken(context);
        if (token == null) {
            throw new AbortException("Could not find credentials matching " + credentialsId);
        }
        
        return token.newKeyMaterialFactory(getEffectiveUrl(), workspace, launcher, env, listener, dockerExecutable);
    }
    
    public KeyMaterialFactory newKeyMaterialFactory(@CheckForNull Run context, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull EnvVars env, @Nonnull TaskListener listener, @Nonnull String dockerExecutable) throws IOException, InterruptedException {
        if (credentialsId == null) {
            return KeyMaterialFactory.NULL; 
        }
        
        DockerRegistryToken token = getToken(context);
        if (token == null) {
            throw new AbortException("Could not find credentials matching " + credentialsId);
        }
        
        return token.newKeyMaterialFactory(getEffectiveUrl(), workspace, launcher, env, listener, dockerExecutable);
    }
    
    public String imageName(@Nonnull String userAndRepo) throws IOException {
        if (userAndRepo == null) {
            throw new IllegalArgumentException("Image name cannot be null.");
        }
        
        if (url == null) {
            return userAndRepo;
        }
        
        URL effectiveUrl = getEffectiveUrl();
        StringBuilder s = new StringBuilder(effectiveUrl.getHost());
        if (effectiveUrl.getPort() > 0 ) {
            s.append(':').append(effectiveUrl.getPort());
        }
        
        if (userAndRepo.startsWith(String.valueOf(s))) {
            return userAndRepo;
        }
        
        return s.append('/').append(userAndRepo).toString();
    }
    
 public String toString() {
        return "DockerRegistryEndpoint[" + url + ";credentialsId=" + credentialsId + "]";
    }
    
    public int hashCode() {
        int hash = 3;
        hash = 31 * hash + (this.url != null ? this.url.hashCode() : 0);
        hash = 31 * hash + (this.credentialsId != null ? this.credentialsId.hashCode() : 0);
        return hash;
    }
    
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        final DockerRegistryEndpoint other = (DockerRegistryEndpoint) obj;
        if ((this.url == null) ? (other.url != null) : !this.url.equals(other.url)) {
            return false;
        }
        
        if ((this.credentialsId == null) ? (other.credentialsId != null) : !this.credentialsId.equals(other.credentialsId)) {
            return false;
        }
        
        return true;
    }
    
    public static class DescriptorImpl extends Descriptor<DockerRegistryEndpoint> {
        public String getDisplayName() {
            return "Docker Hub";
        }
        
        public ListBoxModel doFillCredentialsIdItems(@AncestorInPath Item item) {
            if (item == null && !Jenkins.getActiveInstance().hasPermission(Jenkins.ADMINISTER) || item != null && !item.hasPermission(Item.EXTENDED_READ)) {
                return new StandardListBoxModel();
            }
            
            return new StandardListBoxModel() .withEmptySelection() .withMatching(AuthenticationTokens.matcher(DockerRegistryToken.class), CredentialsProvider.lookupCredentials( StandardCredentials.class, item, null, Collections.<DomainRequirement>emptyList() ) );
        }
        
    }
    
}


