package com.sun.enterprise.admin.launcher;
import com.sun.enterprise.universal.collections.CollectionUtils;
import com.sun.enterprise.universal.glassfish.ASenvPropertyReader;
import com.sun.enterprise.universal.glassfish.GFLauncherUtils;
import com.sun.enterprise.universal.glassfish.TokenResolver;
import com.sun.enterprise.universal.i18n.LocalStringsImpl;
import com.sun.enterprise.universal.io.SmartFile;
import com.sun.enterprise.universal.process.ProcessStreamDrainer;
import com.sun.enterprise.universal.xml.MiniXmlParser;
import com.sun.enterprise.universal.xml.MiniXmlParserException;
import com.sun.enterprise.util.JDK;
import com.sun.enterprise.util.OS;
import com.sun.enterprise.util.SystemPropertyConstants;
import com.sun.enterprise.util.io.FileUtils;
import fish.payara.admin.launcher.PayaraDefaultJvmOptions;
import java.io.*;
import java.util.*;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import static com.sun.enterprise.admin.launcher.GFLauncherConstants.*;
import static com.sun.enterprise.util.SystemPropertyConstants.*;
public abstract class GFLauncher {
    private static final Pattern JAVA_VERSION_PATTERN = Pattern.compile(".* version \"([^\"\\-]+)(-.*)?\".*");
    private final List<String> commandLine = new ArrayList<String>();
    private final List<String> jvmOptionsList = new ArrayList<String>();
    private final GFLauncherInfo info;
    private Map<String, String> asenvProps;
    private JavaConfig javaConfig;
    private JvmOptions jvmOptions;
    private Profiler profiler;
    private Map<String, String> sysPropsFromXml;
    private String javaExe;
    private String classpath;
    private String adminFileRealmKeyFile;
    private boolean secureAdminEnabled;
    private List<String> debugOptions;
    private long startTime;
    private String logFilename;
    private LaunchType mode = LaunchType.normal;
    private static final LocalStringsImpl STRINGS = new LocalStringsImpl(GFLauncher.class);
    private boolean setupCalledByClients = false; 
    private int exitValue = -1;
    private ProcessWhacker processWhacker;
    private Process process;
    private ProcessStreamDrainer psd;
    private boolean logFilenameWasFixed = false;
    private boolean needsAutoUpgrade = false;
    private boolean needsManualUpgrade = false;
    private int debugPort = -1;
    private boolean debugSuspend = false;
    public final GFLauncherInfo getInfo() {
        return info;
    }
    
    public final void launch() throws GFLauncherException {
        try {
            startTime = System.currentTimeMillis();
            if (!setupCalledByClients) {
                setup();
            }
            
            internalLaunch();
        }
         catch (GFLauncherException gfe) {
            throw gfe;
        }
         catch (Throwable t) {
            throw new GFLauncherException(STRINGS.get("unknownError", t.getMessage()), t);
        }
         finally {
            GFLauncherLogger.removeLogFileHandler();
        }
        
    }
    
    public final void relaunch() throws GFLauncherException {
        setupCalledByClients = false;
        launch();
    }
    
    public final void launchJVM(List<String> cmdsIn) throws GFLauncherException {
        try {
            setup();    
            List<String> commands = new LinkedList<String>();
            commands.add(javaExe);
            for (String cmd : cmdsIn) {
                commands.add(cmd);
            }
            
            ProcessBuilder pb = new ProcessBuilder(commands);
            Process p = pb.start();
            ProcessStreamDrainer.drain("launchJVM", p); 
        }
         catch (GFLauncherException gfe) {
            throw gfe;
        }
         catch (Throwable t) {
            throw new GFLauncherException(STRINGS.get("unknownError", t.getMessage()), t);
        }
         finally {
            GFLauncherLogger.removeLogFileHandler();
        }
        
    }
    
    public void setup() throws GFLauncherException, MiniXmlParserException {
        ASenvPropertyReader pr;
        if (isFakeLaunch()) {
            pr = new ASenvPropertyReader(info.getInstallDir());
        }
         else {
            pr = new ASenvPropertyReader();
        }
        
        asenvProps = pr.getProps();
        info.setup();
        setupLogLevels();
        MiniXmlParser parser = new MiniXmlParser(getInfo().getConfigFile(), getInfo().getInstanceName());
        String domainName = parser.getDomainName();
        if (GFLauncherUtils.ok(domainName)) {
            info.setDomainName(domainName);
        }
        
        info.setAdminAddresses(parser.getAdminAddresses());
        javaConfig = new JavaConfig(parser.getJavaConfig());
        String jhome = javaConfig.getJavaHome();
        if (GFLauncherUtils.ok(jhome) && !jhome.trim().equals("${" + JAVA_ROOT_PROPERTY + "}")) {
            asenvProps.put(JAVA_ROOT_PROPERTY, jhome);
        }
        
        setJavaExecutable();
        setupProfilerAndJvmOptions(parser);
        setupUpgradeSecurity();
        Map<String, String> realmprops = parser.getAdminRealmProperties();
        if (realmprops != null) {
            String classname = realmprops.get("classname");
            String keyfile = realmprops.get("file");
            if ("com.sun.enterprise.security.auth.realm.file.FileRealm".equals(classname) && keyfile != null) {
                adminFileRealmKeyFile = keyfile;
            }
            
        }
        
        secureAdminEnabled = parser.getSecureAdminEnabled();
        renameOsgiCache();
        setupMonitoring(parser);
        sysPropsFromXml = parser.getSystemProperties();
        asenvProps.put(INSTANCE_ROOT_PROPERTY, getInfo().getInstanceRootDir().getPath());
        debugOptions = getDebug();
        parseDebug();
        parser.setupConfigDir(getInfo().getConfigDir(), getInfo().getInstallDir());
        setLogFilename(parser);
        resolveAllTokens();
        fixLogFilename();
        GFLauncherLogger.addLogFileHandler(logFilename);
        setClasspath();
        setCommandLine();
        setJvmOptions();
        logCommandLine();
        checkJDKVersion();
        needsAutoUpgrade = !parser.hasNetworkConfig();
        needsManualUpgrade = !parser.hasDefaultConfig();
        setupCalledByClients = true;
    }
    
    public String getAdminRealmKeyFile() {
        return adminFileRealmKeyFile;
    }
    
    public boolean isSecureAdminEnabled() {
        return secureAdminEnabled;
    }
    
    public final int getExitValue() {
        return exitValue;
    }
    
    public final Process getProcess() throws GFLauncherException {
        if (process == null){
            throw new GFLauncherException("invalid_process");
}
        return process;
    }
    
    public final ProcessStreamDrainer getProcessStreamDrainer() throws GFLauncherException {
        if (psd == null){
            throw new GFLauncherException("invalid_psd");
}
        return psd;
    }
    
    public String getLogFilename() throws GFLauncherException {
        if (!logFilenameWasFixed){
            throw new GFLauncherException(STRINGS.get("internalError") + " call to getLogFilename() before it has been initialized");
}
        return logFilename;
    }
    
    public final int getDebugPort() {
        return debugPort;
    }
    
    public final boolean isDebugSuspend() {
        return debugPort >= 0 && debugSuspend;
    }
    
    public final boolean needsAutoUpgrade() {
        return needsAutoUpgrade;
    }
    
    public final boolean needsManualUpgrade() {
        return needsManualUpgrade;
    }
    
    abstract void internalLaunch() throws GFLauncherException;
    private void parseDebug() {
        for (String opt : debugOptions) {
            if (isJdwpOption(opt)) {
              debugPort = extractDebugPort(opt);
              debugSuspend = extractDebugSuspend(opt);
            }
            
        }
        
    }
    
    static boolean isJdwpOption(String option) {
        return option.startsWith("-Xrunjdwp:") || option.startsWith("-agentlib:jdwp");
    }
    
    static int extractDebugPort(String option) {
        Pattern portRegex = Pattern.compile(".*address=(?<port>\\d*).*");
        Matcher m = portRegex.matcher(option);
        if (!m.matches()) {
            return -1;
        }
        
        try {
            String addressGroup = m.group("port");
            return Integer.parseInt(addressGroup);
        }
         catch (NumberFormatException nfex) {
            return -1;
        }
        
    }
    
    static boolean extractDebugSuspend(String option) {
        Pattern suspendRegex = Pattern.compile(".*suspend=[yY](?:,.*|$)");
        Matcher m = suspendRegex.matcher(option);
        return m.matches();
    }
    
    private void setLogFilename(MiniXmlParser parser) {
        if (info.isInstance()) {
            logFilename = parser.getInstanceLogFilename();
        }
         else {
            logFilename = parser.getLogFilename();
        }
        
        if (logFilename == null) {
            logFilename = DEFAULT_LOGFILE;
        }
        
    }
    
    private void fixLogFilename() throws GFLauncherException {
        if (!GFLauncherUtils.ok(logFilename)){
            logFilename = DEFAULT_LOGFILE;
}
        File f = new File(logFilename);
        if (!f.isAbsolute()) {
            f = new File(info.getInstanceRootDir(), logFilename);
        }
        
        f = SmartFile.sanitize(f);
        if (!f.exists()) {
            File parent = f.getParentFile();
            if (!parent.isDirectory()) {
                boolean wasCreated = parent.mkdirs();
                if (!wasCreated) {
                    f = null; 
                }
                
            }
            
        }
        
        if (f == null){
            logFilename = null;
}
        else{
            logFilename = f.getPath();
}
        logFilenameWasFixed = true;
    }
    
    enum LaunchType {
        normal, debug, trace, fake }
    void setMode(LaunchType mode) {
        this.mode = mode;
    }
    
    LaunchType getMode() {
        return mode;
    }
    
    boolean isFakeLaunch() {
        return mode == LaunchType.fake;
    }
    
    abstract List<File> getMainClasspath() throws GFLauncherException;
    abstract String getMainClass() throws GFLauncherException;
    GFLauncher(GFLauncherInfo info) {
        this.info = info;
    }
    
    final Map<String, String> getEnvProps() {
        return asenvProps;
    }
    
    public final List<String> getCommandLine() {
        return commandLine;
    }
    
    final long getStartTime() {
        return startTime;
    }
    
    void launchInstance() throws GFLauncherException, MiniXmlParserException {
        if (isFakeLaunch()) {
            return;
        }
        
        List<String> cmds;
	 if (OS.isDarwin() && useLaunchCtl(System.getProperty("os.version")) &&  (!getInfo().isVerboseOrWatchdog())) {
            cmds = new ArrayList<String>();
	    cmds.add("nohup");
            cmds.addAll(getCommandLine());            
        }
         else {
            cmds = getCommandLine();
        }
        
        ProcessBuilder pb = new ProcessBuilder(cmds);
        try {
            File newDir = getInfo().getConfigDir();
            pb.directory(newDir);
        }
        
        catch (Exception e) {
        }
        
        try {
            closeStandardStreamsMaybe();
            process = pb.start();
            final String name = getInfo().getDomainName();
            if (getInfo().isVerbose()) {
                psd = ProcessStreamDrainer.redirect(name, process);
            }
            
            else if (getInfo().isWatchdog()) {
                psd = ProcessStreamDrainer.dispose(name, process);
            }
            
            else {
                psd = ProcessStreamDrainer.save(name, process);
            }
            
            writeSecurityTokens(process);
        }
        
        catch (Exception e) {
            throw new GFLauncherException("jvmfailure", e, e);
        }
        
        if (getInfo().isVerboseOrWatchdog()){
            wait(process);
}
    }
    
    private static boolean useLaunchCtl(String osversion) {
        int major = 0;
        int minor = 0;
	if (osversion == null || osversion.isEmpty()){
	    return false;
}
        String[] split = osversion.split("[\\._\\-]+");
	try {
            if (split.length > 0  && split[0].length() > 0) {
                major = Integer.parseInt(split[0]);
            }
            
            if (split.length > 1 && split[1].length() > 0) {
                minor = Integer.parseInt(split[1]);
            }
            
	    return ((major <= 9) || (major <= 10 && minor < 10));
	}
	
	catch (NumberFormatException e) {
	     return false;
	}
	
    }
    
    private void writeSecurityTokens(Process sp) throws GFLauncherException, IOException {
        handleDeadProcess();
        OutputStream os = sp.getOutputStream();
        OutputStreamWriter osw = null;
        BufferedWriter bw = null;
        try {
            osw = new OutputStreamWriter(os);
            bw = new BufferedWriter(osw);
            for (String token : info.securityTokens) {
                bw.write(token);
                bw.newLine();
                bw.flush();      
            }
            
        }
        
        catch (IOException e) {
            handleDeadProcess();
            throw e;   
        }
        
        finally {
            if (bw != null) {
                bw.close();
            }
            
            if (osw != null) {
                osw.close();
            }
            
            if (os != null) {
                try {
                    os.close();
                }
                
                catch (IOException ioe) {
                }
                
            }
            
            if (bw != null) {
                handleDeadProcess();
            }
            
        }
        
    }
    
    private void handleDeadProcess() throws GFLauncherException {
        String trace = getDeadProcessTrace(process);
        if (trace != null){
            throw new GFLauncherException(trace);
}
    }
    
    private String getDeadProcessTrace(Process sp) throws GFLauncherException {
        try {
            int ev = sp.exitValue();
            ProcessStreamDrainer psd1 = getProcessStreamDrainer();
            String output = psd1.getOutErrString();
            return STRINGS.get("server_process_died", ev, output);
        }
        
        catch (IllegalThreadStateException e) {
            return null;
        }
        
    }
    
    void setCommandLine() throws GFLauncherException {
        List<String> cmdLine = getCommandLine();
        cmdLine.clear();
        addIgnoreNull(cmdLine, javaExe);
        addIgnoreNull(cmdLine, "-cp");
        addIgnoreNull(cmdLine, getClasspath());
        addIgnoreNull(cmdLine, debugOptions);
        String CLIStartTime = System.getProperty("WALL_CLOCK_START");
        if (CLIStartTime != null && CLIStartTime.length() > 0) {
            cmdLine.add("-DWALL_CLOCK_START=" + CLIStartTime);
        }
        
        if (jvmOptions != null){
            addIgnoreNull(cmdLine, jvmOptions.toStringArray());
}
        GFLauncherNativeHelper nativeHelper = new GFLauncherNativeHelper(info, javaConfig, jvmOptions, profiler);
        addIgnoreNull(cmdLine, nativeHelper.getCommands());
        addIgnoreNull(cmdLine, getMainClass());
        try {
            addIgnoreNull(cmdLine, getInfo().getArgsAsList());
        }
        
        catch (GFLauncherException gfle) {
            throw gfle;
        }
        
        catch (Exception e) {
        }
        
    }
    
    void setJvmOptions() {
        List<String> jvmOpts = getJvmOptions();
        jvmOpts.clear();
        if (jvmOptions != null) {
            addIgnoreNull(jvmOpts, jvmOptions.toStringArray());
        }
        
    }
    
    public final List<String> getJvmOptions() {
        return jvmOptionsList;
    }
    
    private void addIgnoreNull(List<String> list, String s) {
        if (GFLauncherUtils.ok(s)){
            list.add(s);
}
    }
    
    private void addIgnoreNull(List<String> list, Collection<String> ss) {
        if (ss != null && !ss.isEmpty()){
            list.addAll(ss);
}
    }
    
    private void wait(final Process p) throws GFLauncherException {
        try {
            setShutdownHook(p);
            p.waitFor();
            exitValue = p.exitValue();
        }
        
        catch (InterruptedException ex) {
            throw new GFLauncherException("verboseInterruption", ex, ex);
        }
        
    }
    
    private void setShutdownHook(final Process p) {
        if (processWhacker == null) {
            Runtime runtime = Runtime.getRuntime();
            final String msg = STRINGS.get("serverStopped", info.getType());
            processWhacker = new ProcessWhacker(p, msg);
            runtime.addShutdownHook(new Thread(processWhacker));
        }
        
        else{
            processWhacker.setProcess(p);
}
    }
    
    private void resolveAllTokens() {
        Map<String, String> all = new HashMap<String, String>();
        Map<String, String> envProps = System.getenv();
        Map<String, String> sysProps = CollectionUtils.propertiesToStringMap(System.getProperties());
        all.putAll(envProps);
        all.putAll(asenvProps);
        all.putAll(sysProps);
        all.put(SystemPropertyConstants.SERVER_NAME, getInfo().getInstanceName());
        all.putAll(sysPropsFromXml);
        all.putAll(jvmOptions.getCombinedMap());
        all.putAll(profiler.getConfig());
        TokenResolver resolver = new TokenResolver(all);
        resolver.resolve(jvmOptions.xProps);
        resolver.resolve(jvmOptions.xxProps);
        resolver.resolve(jvmOptions.plainProps);
        resolver.resolve(jvmOptions.sysProps);
        resolver.resolve(javaConfig.getMap());
        resolver.resolve(profiler.getConfig());
        resolver.resolve(debugOptions);
        logFilename = resolver.resolve(logFilename);
        adminFileRealmKeyFile = resolver.resolve(adminFileRealmKeyFile);
    }
    
    private void setJavaExecutable() throws GFLauncherException {
        if (setJavaExecutableIfValid(javaConfig.getJavaHome())){
            return;
}
        if (!setJavaExecutableIfValid(asenvProps.get(JAVA_ROOT_PROPERTY))){
            throw new GFLauncherException("nojvm");
}
    }
    
    void setClasspath() throws GFLauncherException {
        List<File> mainCP = getMainClasspath(); 
        List<File> envCP = javaConfig.getEnvClasspath();
        List<File> sysCP = javaConfig.getSystemClasspath();
        List<File> prefixCP = javaConfig.getPrefixClasspath();
        List<File> suffixCP = javaConfig.getSuffixClasspath();
        List<File> profilerCP = profiler.getClasspath();
        List<File> all = new ArrayList<File>();
        all.addAll(prefixCP);
        all.addAll(profilerCP);
        all.addAll(mainCP);
        all.addAll(sysCP);
        all.addAll(envCP);
        all.addAll(suffixCP);
        setClasspath(GFLauncherUtils.fileListToPathString(all));
    }
    
    boolean setJavaExecutableIfValid(String filename) {
        if (!GFLauncherUtils.ok(filename)) {
            return false;
        }
        
        File f = new File(filename);
        if (!f.isDirectory()) {
            return false;
        }
        
        if (GFLauncherUtils.isWindows()) {
            f = new File(f, "bin/java.exe");
        }
        
        else {
            f = new File(f, "bin/java");
        }
        
        if (f.exists()) {
            javaExe = SmartFile.sanitize(f).getPath();
            return true;
        }
        
        return false;
    }
    
    private List<String> getDebug() {
        if (info.isDebug() || javaConfig.isDebugEnabled()) {
            return javaConfig.getDebugOptions();
        }
        
        return Collections.emptyList();
    }
    
    private void setupProfilerAndJvmOptions(MiniXmlParser parser) throws MiniXmlParserException, GFLauncherException {
        profiler = new Profiler( parser.getProfilerConfig(), parser.getProfilerJvmOptions(), parser.getProfilerSystemProperties());
        Optional<JDK.Version> jdkVersion = getConfiguredJdkVersion(javaExe);
        List<String> rawJvmOptions = parser.getJvmOptions() .stream() .filter(fullOption -> JDK.isCorrectJDK(jdkVersion, fullOption.vendorOrVM, fullOption.minVersion, fullOption.maxVersion)) .map(option -> option.option) .collect(Collectors.toList());
        rawJvmOptions.addAll(getSpecialSystemProperties());
        if (profiler.isEnabled()) {
            rawJvmOptions.addAll(profiler.getJvmOptions());
        }
        
        jvmOptions = new JvmOptions(rawJvmOptions);
        if (info.isDropInterruptedCommands()) {
            jvmOptions.sysProps.put(SystemPropertyConstants.DROP_INTERRUPTED_COMMANDS, Boolean.TRUE.toString());
        }
        
        addDefaultJvmOptions();
    }
    
    private Optional<JDK.Version> getConfiguredJdkVersion(String javaExePath) throws GFLauncherException {
        try {
            Runtime r = Runtime.getRuntime();
            Process p = r.exec(javaExePath + " -version");
            p.waitFor();
            try (BufferedReader b = new BufferedReader(new InputStreamReader(p.getErrorStream()))) {
                String line;
                while ((line = b.readLine()) != null) {
                    Matcher m = JAVA_VERSION_PATTERN.matcher(line);
                    if (m.matches()) {
                        return Optional.ofNullable(JDK.getVersion(m.group(1)));
                    }
                    
                }
                
            }
            
            return Optional.empty();
        }
         catch (IOException | InterruptedException ex) {
            throw new GFLauncherException("nojvm");
        }
        
    }
    
    private void addDefaultJvmOptions() {
        if (!jvmOptions.getCombinedMap().containsKey(PayaraDefaultJvmOptions.GRIZZLY_DEFAULT_MEMORY_MANAGER_PROPERTY)) {
            jvmOptions.sysProps.put(PayaraDefaultJvmOptions.GRIZZLY_DEFAULT_MEMORY_MANAGER_PROPERTY,  PayaraDefaultJvmOptions.GRIZZLY_DEFAULT_MEMORY_MANAGER_VALUE);
            GFLauncherLogger.fine(GFLauncherLogger.DEFAULT_JVM_OPTION,  PayaraDefaultJvmOptions.GRIZZLY_DEFAULT_MEMORY_MANAGER_PROPERTY, PayaraDefaultJvmOptions.GRIZZLY_DEFAULT_MEMORY_MANAGER_VALUE);
        }
        
    }
    
    private void setupUpgradeSecurity() throws GFLauncherException {
        if (info.isUpgrade() && jvmOptions.sysProps.containsKey("java.security.manager")) {
            GFLauncherLogger.info(GFLauncherLogger.COPY_SERVER_POLICY);
            File source = new File(new File(new File(info.installDir, "lib"), "templates"), "server.policy");
            File target = new File(info.getConfigDir(), "server.policy");
            try {
                FileUtils.copyFile(source, target);
            }
            
            catch (IOException ioe) {
                Throwable cause = ioe.getCause() == null ? ioe : ioe.getCause();
                throw new GFLauncherException(STRINGS.get( "COPY_SERVER_POLICY_error", cause.getMessage()));
            }
            
        }
        
    }
    
    private void renameOsgiCache() throws GFLauncherException {
        if (info.isUpgrade()) {
            File osgiCacheDir = new File(info.getDomainRootDir(), "osgi-cache");
            File backupOsgiCacheDir = new File(info.getDomainRootDir(), "osgi-cache-" + System.currentTimeMillis());
            if (osgiCacheDir.exists() && !backupOsgiCacheDir.exists()) {
                if (!FileUtils.renameFile(osgiCacheDir, backupOsgiCacheDir)) {
                    throw new GFLauncherException(STRINGS.get("rename_osgi_cache_failed", osgiCacheDir, backupOsgiCacheDir));
                }
                
                else {
                    GFLauncherLogger.fine("rename_osgi_cache_succeeded", osgiCacheDir, backupOsgiCacheDir);
                }
                
            }
            
        }
        
    }
    
    private void setupMonitoring(MiniXmlParser parser) throws GFLauncherException {
        if (!parser.isMonitoringEnabled()) {
            return;
        }
        
        Set<String> plainKeys = jvmOptions.plainProps.keySet();
        for (String key : plainKeys) {
            if (key.startsWith("javaagent:")) {
                key = key.replace('\\', '/');
                if (key.contains(FLASHLIGHT_AGENT_NAME)){
                    return; 
}
            }
            
        }
        
        try {
            jvmOptions.plainProps.put(getMonitoringAgentJvmOptionString(), null);
        }
        
        catch (GFLauncherException gfe) {
        }
        
    }
    
    private String getMonitoringAgentJvmOptionString() throws GFLauncherException {
        File libMonDir = new File(getInfo().getInstallDir(), LIBMON_NAME);
        File flashlightJarFile = new File(libMonDir, FLASHLIGHT_AGENT_NAME);
        if (flashlightJarFile.isFile()){
            return "javaagent:" + getCleanPath(flashlightJarFile);
}
        else {
            String msg = STRINGS.get("no_flashlight_agent", flashlightJarFile);
            GFLauncherLogger.warning(GFLauncherLogger.NO_FLASHLIGHT_AGENT, flashlightJarFile);
            throw new GFLauncherException(msg);
        }
        
    }
    
    private static String getCleanPath(File f) {
        return SmartFile.sanitize(f).getPath().replace('\\', '/');
    }
    
    private List<String> getSpecialSystemProperties() throws GFLauncherException {
        Map<String, String> props = new HashMap<String, String>();
        props.put(INSTALL_ROOT_PROPERTY, getInfo().getInstallDir().getAbsolutePath());
        props.put(INSTANCE_ROOT_PROPERTY, getInfo().getInstanceRootDir().getAbsolutePath());
        return (this.propsToJvmOptions(props));
    }
    
    void logCommandLine() {
        StringBuilder sb = new StringBuilder();
        if (!isFakeLaunch()) {
            Iterable<String> cmdLine = getCommandLine();
            for (String s : cmdLine) {
                sb.append(NEWLINE);
                sb.append(s);
            }
            
            GFLauncherLogger.info(GFLauncherLogger.COMMAND_LINE, sb.toString());
        }
        
    }
    
    private void checkJDKVersion() {
        if(!JDK.isRunningLTSJDK()) {
            GFLauncherLogger.warning("You are running the product on an unsupported JDK version and might see unexpected results or exceptions.");
        }
        
    }
    
    String getClasspath() {
        return classpath;
    }
    
    void setClasspath(String s) {
        classpath = s;
    }
    
    private List<String> propsToJvmOptions(Map<String, String> map) {
        List<String> ss = new ArrayList<String>();
        Set<Map.Entry<String, String>> entries = map.entrySet();
        for (Map.Entry<String, String> entry : entries) {
            String name = entry.getKey();
            String value = entry.getValue();
            String jvm = "-D" + name;
            if (value != null) {
                jvm += "=" + value;
            }
            
            ss.add(jvm);
        }
        
        return ss;
    }
    
    private void setupLogLevels() {
        if (info.isVerbose()){
            GFLauncherLogger.setConsoleLevel(Level.INFO);
}
        else{
            GFLauncherLogger.setConsoleLevel(Level.WARNING);
}
    }
    
    private void closeStandardStreamsMaybe() {
        if (System.console() == null && OS.isWindows() && !(info.isVerboseOrWatchdog())) {
            String sname;
            if (info.isDomain()) {
                sname = info.getDomainName();
            }
             else {
                sname = info.getInstanceName();
            }
            
            System.out.println(STRINGS.get("ssh", sname));
            try {
                System.in.close();
            }
            
            catch (Exception e) { 
            }
            
            try {
                System.err.close();
            }
            
            catch (Exception e) { 
            }
            
            try {
                System.out.close();
            }
            
            catch (Exception e) { 
            }
            
        }
        
    }
    
    private static class ProcessWhacker implements Runnable {
        private final String message;
        private Process process;
        ProcessWhacker(Process p, String msg) {
            message = msg;
            process = p;
        }
        
        void setProcess(Process p) {
            process = p;
        }
        
        public void run() {
            System.out.println(message);
            process.destroy();
        }
        
    }
    
}


