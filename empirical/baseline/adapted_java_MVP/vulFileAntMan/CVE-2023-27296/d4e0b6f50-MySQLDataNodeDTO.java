package org.apache.inlong.manager.pojo.node.mysql;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.apache.inlong.manager.common.enums.ErrorCodeEnum;
import org.apache.inlong.manager.common.exceptions.BusinessException;
import org.apache.inlong.manager.common.util.JsonUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.validation.constraints.NotNull;
@ApiModel("MySQL data node info")
public class MySQLDataNodeDTO {
    private static final Logger LOGGER = LoggerFactory.getLogger(MySQLDataNodeDTO.class);
    private static final String MYSQL_JDBC_PREFIX = "jdbc:mysql://";
    @ApiModelProperty("URL of backup DB server")
    private String backupUrl;
    public static MySQLDataNodeDTO getFromRequest(MySQLDataNodeRequest request) throws Exception {
        return MySQLDataNodeDTO.builder() .backupUrl(request.getBackupUrl()) .build();
    }
    
    public static MySQLDataNodeDTO getFromJson(@NotNull String extParams) {
        try {
            return JsonUtils.parseObject(extParams, MySQLDataNodeDTO.class);
        }
         catch (Exception e) {
            throw new BusinessException(ErrorCodeEnum.CLUSTER_INFO_INCORRECT, String.format("Failed to parse extParams for MySQL node: %s", e.getMessage()));
        }
        
    }
    
    public static String convertToJdbcurl(String url) {
        String jdbcUrl = url;
        if (StringUtils.isNotBlank(jdbcUrl) && !jdbcUrl.startsWith(MYSQL_JDBC_PREFIX)) {
            jdbcUrl = MYSQL_JDBC_PREFIX + jdbcUrl;
        }
        
        return jdbcUrl;
    }
    
}


