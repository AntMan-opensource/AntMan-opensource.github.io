package hudson.cli;
import hudson.Extension;
import hudson.model.UnprotectedRootAction;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import jenkins.model.Jenkins;
import jenkins.util.FullDuplexHttpService;
import jenkins.websocket.WebSocketSession;
import jenkins.websocket.WebSockets;
import org.jenkinsci.Symbol;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.HttpResponses;
import org.kohsuke.stapler.Stapler;
import org.kohsuke.stapler.StaplerProxy;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.springframework.security.core.Authentication;
@Extension @Symbol("cli")
public class CLIAction implements UnprotectedRootAction, StaplerProxy {
    private static final Logger LOGGER = Logger.getLogger(CLIAction.class.getName());
    private final transient Map<UUID, FullDuplexHttpService> duplexServices = new HashMap<>();
    public String getIconFileName() {
        return null;
    }
    
    public String getDisplayName() {
        return "Jenkins CLI";
    }
    
    public String getUrlName() {
        return "cli";
    }
    
    public void doCommand(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {
        final Jenkins jenkins = Jenkins.get();
        jenkins.checkPermission(Jenkins.READ);
        final String commandName = req.getRestOfPath().substring(1);
        CLICommand command = CLICommand.clone(commandName);
        if (command == null) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND, "No such command");
            return;
        }
        
        req.setAttribute("command", command);
        req.getView(this, "command.jelly").forward(req, rsp);
    }
    
    public boolean isWebSocketSupported() {
        return WebSockets.isSupported();
    }
    
    public HttpResponse doWs() {
        if (!WebSockets.isSupported()) {
            return HttpResponses.notFound();
        }
        
        Authentication authentication = Jenkins.getAuthentication2();
        return WebSockets.upgrade(new WebSocketSession() {
            ServerSideImpl connection;
            long sentBytes, sentCount, receivedBytes, receivedCount;
            class OutputImpl implements PlainCLIProtocol.Output {
                public void send(byte[] data) throws IOException {
                    sendBinary(ByteBuffer.wrap(data));
                    sentBytes += data.length;
                    sentCount++;
                }
                
                public void close() throws IOException {
                    doClose();
                }
                
            }
            
            private void doClose() throws IOException {
                close();
            }
            
            protected void opened() {
                try {
                    connection = new ServerSideImpl(new OutputImpl(), authentication);
                }
                 catch (IOException x) {
                    error(x);
                    return;
                }
                
                new Thread(() -> {
                    try {
                        try {
                            connection.run();
                        }
                         finally {
                            connection.close();
                        }
                        
                    }
                     catch (Exception x) {
                        error(x);
                    }
                    
                }, "CLI handler for " + authentication.getName()).start();
            }
            
            protected void binary(byte[] payload, int offset, int len) {
                try {
                    connection.handle(new DataInputStream(new ByteArrayInputStream(payload, offset, len)));
                    receivedBytes += len;
                    receivedCount++;
                }
                 catch (IOException x) {
                    error(x);
                }
                
            }
            
            protected void error(Throwable cause) {
                LOGGER.log(Level.WARNING, null, cause);
            }
            
            protected void closed(int statusCode, String reason) {
                LOGGER.fine(() -> "closed: " + statusCode + ": " + reason);
                LOGGER.fine(() -> "received " + receivedCount + " packets of " + receivedBytes + " bytes; sent " + sentCount + " packets of " + sentBytes + " bytes");
                connection.handleClose();
            }
            
        }
        
);
    }
    
    public Object getTarget() {
        StaplerRequest req = Stapler.getCurrentRequest();
        if (req.getRestOfPath().length() == 0 && "POST".equals(req.getMethod())) {
            if ("false".equals(req.getParameter("remoting"))) {
                throw new PlainCliEndpointResponse();
            }
             else {
                throw HttpResponses.forbidden();
            }
            
        }
         else {
            return this;
        }
        
    }
    
    static class ServerSideImpl extends PlainCLIProtocol.ServerSide {
        private Thread runningThread;
        private boolean ready;
        private final List<String> args = new ArrayList<>();
        private Locale locale = Locale.getDefault();
        private Charset encoding = Charset.defaultCharset();
        private final PipedInputStream stdin = new PipedInputStream();
        private final PipedOutputStream stdinMatch = new PipedOutputStream();
        private final Authentication authentication;
        ServerSideImpl(PlainCLIProtocol.Output out, Authentication authentication) throws IOException {
            super(out);
            stdinMatch.connect(stdin);
            this.authentication = authentication;
        }
        
        protected void onArg(String text) {
            args.add(text);
        }
        
        protected void onLocale(String text) {
            for (Locale _locale : Locale.getAvailableLocales()) {
                if (_locale.toString().equals(text)) {
                    locale = _locale;
                    return;
                }
                
            }
            
            LOGGER.log(Level.WARNING, "unknown client locale {0}", text);
        }
        
        protected void onEncoding(String text) {
            try {
                encoding = Charset.forName(text);
            }
             catch (UnsupportedCharsetException x) {
                LOGGER.log(Level.WARNING, "unknown client charset {0}", text);
            }
            
        }
        
        protected void onStart() {
            ready();
        }
        
        protected void onStdin(byte[] chunk) throws IOException {
            stdinMatch.write(chunk);
        }
        
        protected void onEndStdin() throws IOException {
            stdinMatch.close();
        }
        
        protected void handleClose() {
            ready();
            if (runningThread != null) {
                runningThread.interrupt();
            }
            
        }
        
        private synchronized void ready() {
            ready = true;
            notifyAll();
        }
        
        void run() throws IOException, InterruptedException {
            synchronized (this) {
                while (!ready) {
                    wait();
                }
                
            }
            
            PrintStream stdout = new PrintStream(streamStdout(), false, encoding);
            PrintStream stderr = new PrintStream(streamStderr(), true, encoding);
            if (args.isEmpty()) {
                stderr.println("Connection closed before arguments received");
                sendExit(2);
                return;
            }
            
            String commandName = args.get(0);
            CLICommand command = CLICommand.clone(commandName);
            if (command == null) {
                stderr.println("No such command " + commandName);
                sendExit(2);
                return;
            }
            
            command.setTransportAuth2(authentication);
            command.setClientCharset(encoding);
            CLICommand orig = CLICommand.setCurrent(command);
            try {
                runningThread = Thread.currentThread();
                int exit = command.main(args.subList(1, args.size()), locale, stdin, stdout, stderr);
                stdout.flush();
                sendExit(exit);
                try { 
                    Thread.sleep(1000);
                }
                 catch (InterruptedException x) {
                }
                
            }
             finally {
                CLICommand.setCurrent(orig);
                runningThread = null;
            }
            
        }
        
    }
    
    private class PlainCliEndpointResponse extends FullDuplexHttpService.Response {
        PlainCliEndpointResponse() {
            super(duplexServices);
        }
        
        protected FullDuplexHttpService createService(StaplerRequest req, UUID uuid) throws IOException {
            return new FullDuplexHttpService(uuid) {
                protected void run(InputStream upload, OutputStream download) throws IOException, InterruptedException {
                    try (ServerSideImpl connection = new ServerSideImpl(new PlainCLIProtocol.FramedOutput(download), Jenkins.getAuthentication2())) {
                        new PlainCLIProtocol.FramedReader(connection, upload).start();
                        connection.run();
                    }
                    
                }
                
            };
        }
        
    }
    
}


