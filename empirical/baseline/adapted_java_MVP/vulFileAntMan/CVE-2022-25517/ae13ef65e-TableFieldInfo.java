package com.baomidou.mybatisplus.core.metadata;
import com.baomidou.mybatisplus.annotation.*;
import com.baomidou.mybatisplus.core.config.GlobalConfig;
import com.baomidou.mybatisplus.core.toolkit.Constants;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.core.toolkit.sql.SqlScriptUtils;
import lombok.*;
import org.apache.ibatis.mapping.ResultMapping;
import org.apache.ibatis.reflection.Reflector;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.type.*;
import java.lang.reflect.Field;
import java.util.Map;
public class TableFieldInfo implements Constants {
    private final Field field;
    private final String column;
    private final String property;
    private final String el;
    private final String mapping;
    private final Class<?> propertyType;
    private final boolean isPrimitive;
    private final boolean isCharSequence;
    private final FieldStrategy insertStrategy;
    private final FieldStrategy updateStrategy;
    private final FieldStrategy whereStrategy;
    private final boolean version;
    private boolean select = true;
    private boolean logicDelete = false;
    private String logicDeleteValue;
    private String logicNotDeleteValue;
    private String update;
    private String condition = SqlCondition.EQUAL;
    private FieldFill fieldFill = FieldFill.DEFAULT;
    private boolean withInsertFill;
    private boolean withUpdateFill;
    private String sqlSelect;
    private JdbcType jdbcType;
    private Class<? extends TypeHandler<?>> typeHandler;
    private boolean isOrderBy;
    private String orderByType;
    private short orderBySort;
    @SuppressWarnings({"unchecked", "rawtypes"})
    public TableFieldInfo(GlobalConfig.DbConfig dbConfig, TableInfo tableInfo, Field field, TableField tableField, Reflector reflector, boolean existTableLogic, boolean isOrderBy) {
        this(dbConfig, tableInfo, field, tableField, reflector, existTableLogic);
        this.isOrderBy = isOrderBy;
        if (isOrderBy) {
            initOrderBy(field);
        }
        
    }
    
    @SuppressWarnings({"unchecked", "rawtypes"})
    public TableFieldInfo(GlobalConfig.DbConfig dbConfig, TableInfo tableInfo, Field field, TableField tableField, Reflector reflector, boolean existTableLogic) {
        field.setAccessible(true);
        this.field = field;
        this.version = field.getAnnotation(Version.class) != null;
        this.property = field.getName();
        this.propertyType = reflector.getGetterType(this.property);
        this.isPrimitive = this.propertyType.isPrimitive();
        this.isCharSequence = StringUtils.isCharSequence(this.propertyType);
        this.fieldFill = tableField.fill();
        this.withInsertFill = this.fieldFill == FieldFill.INSERT || this.fieldFill == FieldFill.INSERT_UPDATE;
        this.withUpdateFill = this.fieldFill == FieldFill.UPDATE || this.fieldFill == FieldFill.INSERT_UPDATE;
        this.update = tableField.update();
        JdbcType jdbcType = tableField.jdbcType();
        final Class<? extends TypeHandler> typeHandler = tableField.typeHandler();
        final String numericScale = tableField.numericScale();
        boolean needAs = false;
        String el = this.property;
        if (StringUtils.isNotBlank(tableField.property())) {
            el = tableField.property();
            needAs = true;
        }
        
        if (JdbcType.UNDEFINED != jdbcType) {
            this.jdbcType = jdbcType;
            el += (COMMA + SqlScriptUtils.mappingJdbcType(jdbcType));
        }
        
        if (UnknownTypeHandler.class != typeHandler) {
            this.typeHandler = (Class<? extends TypeHandler<?>>) typeHandler;
            if (tableField.javaType()) {
                String javaType = null;
                TypeAliasRegistry registry = tableInfo.getConfiguration().getTypeAliasRegistry();
                Map<String, Class<?>> typeAliases = registry.getTypeAliases();
                for (Map.Entry<String, Class<?>> entry : typeAliases.entrySet()) {
                    if (entry.getValue().equals(propertyType)) {
                        javaType = entry.getKey();
                        break;
                    }
                    
                }
                
                if (javaType == null) {
                    javaType = propertyType.getName();
                    registry.registerAlias(javaType, propertyType);
                }
                
                el += (COMMA + "javaType=" + javaType);
            }
            
            el += (COMMA + SqlScriptUtils.mappingTypeHandler(this.typeHandler));
        }
        
        if (StringUtils.isNotBlank(numericScale)) {
            el += (COMMA + SqlScriptUtils.mappingNumericScale(Integer.valueOf(numericScale)));
        }
        
        this.el = el;
        int index = el.indexOf(COMMA);
        this.mapping = index > 0 ? el.substring(++index) : null;
        this.initLogicDelete(dbConfig, field, existTableLogic);
        String column = tableField.value();
        if (StringUtils.isBlank(column)) {
            column = this.property;
            if (tableInfo.isUnderCamel()) {
                column = StringUtils.camelToUnderline(column);
            }
            
            if (dbConfig.isCapitalMode()) {
                column = column.toUpperCase();
            }
            
        }
        
        String columnFormat = dbConfig.getColumnFormat();
        if (StringUtils.isNotBlank(columnFormat) && tableField.keepGlobalFormat()) {
            column = String.format(columnFormat, column);
        }
        
        this.column = column;
        this.sqlSelect = column;
        if (needAs) {
            this.sqlSelect += String.format("%s\"%s\"", AS, tableField.property());
        }
         else if (tableInfo.getResultMap() == null && !tableInfo.isAutoInitResultMap() && TableInfoHelper.checkRelated(tableInfo.isUnderCamel(), this.property, this.column)) {
            String propertyFormat = dbConfig.getPropertyFormat();
            String asProperty = this.property;
            if (StringUtils.isNotBlank(propertyFormat)) {
                asProperty = String.format(propertyFormat, this.property);
            }
            
            this.sqlSelect += (AS + asProperty);
        }
        
        this.insertStrategy = this.chooseFieldStrategy(tableField.insertStrategy(), dbConfig.getInsertStrategy());
        this.updateStrategy = this.chooseFieldStrategy(tableField.updateStrategy(), dbConfig.getUpdateStrategy());
        this.whereStrategy = this.chooseFieldStrategy(tableField.whereStrategy(), dbConfig.getWhereStrategy());
        if (StringUtils.isNotBlank(tableField.condition())) {
            this.condition = tableField.condition();
        }
        
        this.select = tableField.select();
    }
    
    private FieldStrategy chooseFieldStrategy(FieldStrategy fromAnnotation, FieldStrategy fromDbConfig) {
        return fromAnnotation == FieldStrategy.DEFAULT ? fromDbConfig : fromAnnotation;
    }
    
    public TableFieldInfo(GlobalConfig.DbConfig dbConfig, TableInfo tableInfo, Field field, Reflector reflector, boolean existTableLogic, boolean isOrderBy) {
        this(dbConfig, tableInfo, field, reflector, existTableLogic);
        this.isOrderBy = isOrderBy;
        if (isOrderBy) {
            initOrderBy(field);
        }
        
    }
    
    public TableFieldInfo(GlobalConfig.DbConfig dbConfig, TableInfo tableInfo, Field field, Reflector reflector, boolean existTableLogic) {
        field.setAccessible(true);
        this.field = field;
        this.version = field.getAnnotation(Version.class) != null;
        this.property = field.getName();
        this.propertyType = reflector.getGetterType(this.property);
        this.isPrimitive = this.propertyType.isPrimitive();
        this.isCharSequence = StringUtils.isCharSequence(this.propertyType);
        this.el = this.property;
        this.mapping = null;
        this.insertStrategy = dbConfig.getInsertStrategy();
        this.updateStrategy = dbConfig.getUpdateStrategy();
        this.whereStrategy = dbConfig.getWhereStrategy();
        this.initLogicDelete(dbConfig, field, existTableLogic);
        String column = this.property;
        if (tableInfo.isUnderCamel()) {
            column = StringUtils.camelToUnderline(column);
        }
        
        if (dbConfig.isCapitalMode()) {
            column = column.toUpperCase();
        }
        
        String columnFormat = dbConfig.getColumnFormat();
        if (StringUtils.isNotBlank(columnFormat)) {
            column = String.format(columnFormat, column);
        }
        
        this.column = column;
        this.sqlSelect = column;
        if (tableInfo.getResultMap() == null && !tableInfo.isAutoInitResultMap() && TableInfoHelper.checkRelated(tableInfo.isUnderCamel(), this.property, this.column)) {
            String propertyFormat = dbConfig.getPropertyFormat();
            String asProperty = this.property;
            if (StringUtils.isNotBlank(propertyFormat)) {
                asProperty = String.format(propertyFormat, this.property);
            }
            
            this.sqlSelect += (AS + asProperty);
        }
        
    }
    
    private void initOrderBy(Field field) {
        OrderBy orderBy = field.getAnnotation(OrderBy.class);
        if (null != orderBy) {
            this.isOrderBy = true;
            this.orderBySort = orderBy.sort();
            this.orderByType = orderBy.isDesc() ? "desc" : "asc";
        }
         else {
            this.isOrderBy = false;
        }
        
    }
    
    private void initLogicDelete(GlobalConfig.DbConfig dbConfig, Field field, boolean existTableLogic) {
        TableLogic tableLogic = field.getAnnotation(TableLogic.class);
        if (null != tableLogic) {
            if (StringUtils.isNotBlank(tableLogic.value())) {
                this.logicNotDeleteValue = tableLogic.value();
            }
             else {
                this.logicNotDeleteValue = dbConfig.getLogicNotDeleteValue();
            }
            
            if (StringUtils.isNotBlank(tableLogic.delval())) {
                this.logicDeleteValue = tableLogic.delval();
            }
             else {
                this.logicDeleteValue = dbConfig.getLogicDeleteValue();
            }
            
            this.logicDelete = true;
        }
         else if (!existTableLogic) {
            String deleteField = dbConfig.getLogicDeleteField();
            if (StringUtils.isNotBlank(deleteField) && this.property.equals(deleteField)) {
                this.logicNotDeleteValue = dbConfig.getLogicNotDeleteValue();
                this.logicDeleteValue = dbConfig.getLogicDeleteValue();
                this.logicDelete = true;
            }
            
        }
        
    }
    
    public String getInsertSqlProperty(final String prefix) {
        final String newPrefix = prefix == null ? EMPTY : prefix;
        return SqlScriptUtils.safeParam(newPrefix + el) + COMMA;
    }
    
    public String getInsertSqlPropertyMaybeIf(final String prefix) {
        final String newPrefix = prefix == null ? EMPTY : prefix;
        String sqlScript = getInsertSqlProperty(newPrefix);
        if (withInsertFill) {
            return sqlScript;
        }
        
        return convertIf(sqlScript, newPrefix + property, insertStrategy);
    }
    
    public String getInsertSqlColumn() {
        return column + COMMA;
    }
    
    public String getInsertSqlColumnMaybeIf(final String prefix) {
        final String newPrefix = prefix == null ? EMPTY : prefix;
        final String sqlScript = getInsertSqlColumn();
        if (withInsertFill) {
            return sqlScript;
        }
        
        return convertIf(sqlScript, newPrefix + property, insertStrategy);
    }
    
    public String getSqlSet(final String prefix) {
        return getSqlSet(false, prefix);
    }
    
    public String getSqlSet(final boolean ignoreIf, final String prefix) {
        final String newPrefix = prefix == null ? EMPTY : prefix;
        String sqlSet = column + EQUALS;
        if (StringUtils.isNotBlank(update)) {
            sqlSet += String.format(update, column);
        }
         else {
            sqlSet += SqlScriptUtils.safeParam(newPrefix + el);
        }
        
        sqlSet += COMMA;
        if (ignoreIf) {
            return sqlSet;
        }
        
        if (withUpdateFill) {
            return sqlSet;
        }
        
        return convertIf(sqlSet, convertIfProperty(newPrefix, property), updateStrategy);
    }
    
    private String convertIfProperty(String prefix, String property) {
        return StringUtils.isNotBlank(prefix) ? prefix.substring(0, prefix.length() - 1) + "['" + property + "']" : property;
    }
    
    public String getSqlWhere(final String prefix) {
        final String newPrefix = prefix == null ? EMPTY : prefix;
        String sqlScript = " AND " + String.format(condition, column, newPrefix + el);
        return convertIf(sqlScript, convertIfProperty(newPrefix, property), whereStrategy);
    }
    
    ResultMapping getResultMapping(final Configuration configuration) {
        ResultMapping.Builder builder = new ResultMapping.Builder(configuration, property, StringUtils.getTargetColumn(column), propertyType);
        TypeHandlerRegistry registry = configuration.getTypeHandlerRegistry();
        if (jdbcType != null && jdbcType != JdbcType.UNDEFINED) {
            builder.jdbcType(jdbcType);
        }
        
        if (typeHandler != null && typeHandler != UnknownTypeHandler.class) {
            TypeHandler<?> typeHandler = registry.getMappingTypeHandler(this.typeHandler);
            if (typeHandler == null) {
                typeHandler = registry.getInstance(propertyType, this.typeHandler);
            }
            
            builder.typeHandler(typeHandler);
        }
        
        return builder.build();
    }
    
    public String getVersionOli(final String alias, final String prefix) {
        final String oli = " AND " + column + EQUALS + SqlScriptUtils.safeParam(MP_OPTLOCK_VERSION_ORIGINAL);
        final String ognlStr = convertIfProperty(prefix, property);
        if (isCharSequence) {
            return SqlScriptUtils.convertIf(oli, String.format("%s != null and %s != null and %s != ''", alias, ognlStr, ognlStr), false);
        }
         else {
            return SqlScriptUtils.convertIf(oli, String.format("%s != null and %s != null", alias, ognlStr), false);
        }
        
    }
    
    private String convertIf(final String sqlScript, final String property, final FieldStrategy fieldStrategy) {
        if (fieldStrategy == FieldStrategy.NEVER) {
            return null;
        }
        
        if (isPrimitive || fieldStrategy == FieldStrategy.IGNORED) {
            return sqlScript;
        }
        
        if (fieldStrategy == FieldStrategy.NOT_EMPTY && isCharSequence) {
            return SqlScriptUtils.convertIf(sqlScript, String.format("%s != null and %s != ''", property, property), false);
        }
        
        return SqlScriptUtils.convertIf(sqlScript, String.format("%s != null", property), false);
    }
    
}


