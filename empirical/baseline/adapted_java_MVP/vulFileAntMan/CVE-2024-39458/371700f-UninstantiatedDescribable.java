package org.jenkinsci.plugins.structs.describable;
import hudson.model.Describable;
import hudson.model.TaskListener;
import org.jenkinsci.Symbol;
import edu.umd.cs.findbugs.annotations.Nullable;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;
import edu.umd.cs.findbugs.annotations.CheckForNull;
public class UninstantiatedDescribable implements Serializable {
    private String symbol;
    private String klass;
    private final Map<String,?> arguments;
    private DescribableModel model;
    public UninstantiatedDescribable(String symbol, String klass, Map<String, ?> arguments) {
        this.symbol = symbol;
        this.klass = klass;
        this.arguments = arguments;
    }
    
    public UninstantiatedDescribable(Map<String, ?> arguments) {
        this(null,null,arguments);
    }
    
    public UninstantiatedDescribable withArguments(Map<String, ?> arguments) {
        UninstantiatedDescribable copy = new UninstantiatedDescribable(symbol, klass, arguments);
        copy.model = model;
        return copy;
    }
    
    public @Nullable String getSymbol() {
        return symbol;
    }
    
    public void setSymbol(String symbol) {
        this.symbol = symbol;
    }
    
    public @Nullable String getKlass() {
        return klass;
    }
    
    public void setKlass(String klass) {
        this.klass = klass;
    }
    
    public @CheckForNull DescribableModel getModel() {
        return model;
    }
    
    public void setModel(DescribableModel model) {
        this.model = model;
    }
    
    public Map<String, ?> getArguments() {
        return arguments;
    }
    
    public boolean hasSoleRequiredArgument() {
        if (arguments.size()!=1)    return false;
        if (model==null)    return false;
        DescribableParameter p = model.getSoleRequiredParameter();
        if (p==null)        return false;
        return arguments.containsKey(p.getName());
    }
    
    public Map<String,Object> toMap() {
        Map<String,Object> r = toShallowMap();
        for (Entry<String,?> e : arguments.entrySet()) {
            Object v = e.getValue();
            v = toMap(v);
            if (v instanceof List) {
                List l = new ArrayList(((List) v).size());
                for (Object o : (List) v) {
                    l.add(toMap(o));
                }
                
                v = l;
            }
            
            r.put(e.getKey(),v);
        }
        
        return r;
    }
    
    public Map<String,Object> toShallowMap() {
        Map<String,Object> r = new TreeMap<String, Object>(arguments);
        if (klass !=null){
            r.put(DescribableModel.CLAZZ, klass);
}
        return r;
    }
    
    private static Object toMap(Object v) {
        if (v instanceof UninstantiatedDescribable) {
            UninstantiatedDescribable ud = (UninstantiatedDescribable) v;
            return ud.toMap();
        }
         else {
            return v;
        }
        
    }
    
    public Object instantiate() throws Exception {
        DescribableModel m = getModel();
        return instantiate(m!=null ? m.getType() : Object.class, null);
    }
    
    public Object instantiate(TaskListener listener) throws Exception {
        DescribableModel m = getModel();
        return instantiate(m!=null ? m.getType() : Object.class, listener);
    }
    
    public <T> T instantiate(Class<T> base) throws Exception {
        return instantiate(base, null);
    }
    
    public <T> T instantiate(Class<T> base, TaskListener listener) throws Exception {
        Class<?> c = DescribableModel.resolveClass(base, klass, symbol);
        return base.cast(new DescribableModel(c).instantiate(arguments, listener));
    }
    
    public static UninstantiatedDescribable from(Object o) {
        return DescribableModel.uninstantiate2_(o);
    }
    
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UninstantiatedDescribable that = (UninstantiatedDescribable) o;
        if (symbol != null ? !symbol.equals(that.symbol) : that.symbol != null) return false;
        if (klass != null ? !klass.equals(that.klass) : that.klass != null) return false;
        return arguments.equals(that.arguments);
    }
    
    public int hashCode() {
        int result = symbol != null ? symbol.hashCode() : 0;
        result = 31 * result + (klass != null ? klass.hashCode() : 0);
        result = 31 * result + arguments.hashCode();
        return result;
    }
    
    public String toString() {
        StringBuilder b = new StringBuilder();
        if (symbol!=null){
            b.append('@').append(symbol);
}
        if (klass!=null){
            b.append('$').append(klass);
}
        b.append('(');
        boolean first = true;
        for (Entry<String,?> e : arguments.entrySet()) {
            if (first)  first = false;
            else        b.append(',');
            b.append(e.getKey()).append('=').append(e.getValue());
        }
        
        b.append(')');
        return b.toString();
   }
   
    private static final long serialVersionUID = 1L;
    public static final String ANONYMOUS_KEY = "<anonymous>";
}


