package org.jenkinsci.plugins;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.security.cert.X509Certificate;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import com.google.common.base.Strings;
import jenkins.security.SecurityListener;
import org.acegisecurity.Authentication;
import org.acegisecurity.AuthenticationException;
import org.acegisecurity.AuthenticationManager;
import org.acegisecurity.BadCredentialsException;
import org.acegisecurity.context.SecurityContextHolder;
import org.keycloak.KeycloakSecurityContext;
import org.keycloak.OAuth2Constants;
import org.keycloak.adapters.AdapterDeploymentContext;
import org.keycloak.adapters.KeycloakDeployment;
import org.keycloak.adapters.KeycloakDeploymentBuilder;
import org.keycloak.adapters.OIDCHttpFacade;
import org.keycloak.adapters.ServerRequest;
import org.keycloak.adapters.ServerRequest.HttpFailure;
import org.keycloak.adapters.rotation.AdapterTokenVerifier;
import org.keycloak.adapters.spi.AuthenticationError;
import org.keycloak.adapters.spi.LogoutError;
import org.keycloak.common.util.KeycloakUriBuilder;
import org.keycloak.jose.jws.JWSInput;
import org.keycloak.representations.AccessToken;
import org.keycloak.representations.AccessTokenResponse;
import org.keycloak.representations.IDToken;
import org.keycloak.representations.adapters.config.AdapterConfig;
import org.keycloak.util.JsonSerialization;
import org.keycloak.util.TokenUtil;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.Header;
import org.kohsuke.stapler.HttpRedirect;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.HttpResponses;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import hudson.Extension;
import hudson.model.Descriptor;
import hudson.model.User;
import hudson.security.SecurityRealm;
import hudson.tasks.Mailer;
import hudson.util.FormValidation;
import net.sf.json.JSONObject;
public class KeycloakSecurityRealm extends SecurityRealm {
	private static final String JENKINS_LOGIN_URL = "securityRealm/commenceLogin";
	 public static final String JENKINS_FINISH_LOGIN_URL = "securityRealm/finishLogin";
	 public static final String AUTH_REQUESTED = "AUTH_REQUESTED";
	private static final Logger LOGGER = Logger.getLogger(KeycloakSecurityRealm.class.getName());
	private static final String REFERER_ATTRIBUTE = KeycloakSecurityRealm.class.getName() + ".referer";
	private transient KeycloakDeployment keycloakDeployment;
	private transient RefreshFilter filter;
	private String keycloakJson = "";
	private String keycloakIdp = "";
	private boolean keycloakValidate = false;
	private boolean keycloakRespectAccessTokenTimeout = true;
	public KeycloakSecurityRealm() throws IOException {
		super();
		createFilter();
	}
	
	 synchronized void createFilter() {
		 if (filter == null || !filter.isInitCalled()) {
			try {
				LOGGER.log(Level.INFO, "Create Filter");
				filter = new RefreshFilter();
				hudson.util.PluginServletFilter.addFilter(filter);
			}
			 catch (ServletException e) {
				LOGGER.log(Level.SEVERE, "createFilter", e);
			}
			
		}
		
	}
	
	 public HttpResponse doCommenceLogin(StaplerRequest request, StaplerResponse response, @Header("Referer") final String referer) throws IOException {
		request.getSession().setAttribute(REFERER_ATTRIBUTE, referer);
		String scopeParam = TokenUtil.attachOIDCScope(null);
		String redirect = redirectUrl(request);
		String state = UUID.randomUUID().toString();
        KeycloakUriBuilder builder = getKeycloakDeployment().getAuthUrl().clone() .queryParam(OAuth2Constants.CLIENT_ID, getKeycloakDeployment().getResourceName()) .queryParam(OAuth2Constants.REDIRECT_URI, redirect).queryParam(OAuth2Constants.STATE, state) .queryParam(OAuth2Constants.RESPONSE_TYPE, OAuth2Constants.CODE) .queryParam(OAuth2Constants.SCOPE, scopeParam);
        String keycloakIdp = getKeycloakIdp();
        if (!"".equals(keycloakIdp)&&(keycloakIdp!=null)) {
            builder.queryParam("kc_idp_hint", keycloakIdp);
        }
        
		String authUrl = builder.build().toString();
		request.getSession().setAttribute(AUTH_REQUESTED, Boolean.valueOf(true));
		createFilter();
		return new HttpRedirect(authUrl);
	}
	
	private String redirectUrl(StaplerRequest request) {
		String refererURL = request.getReferer();
		String requestURL = request.getRequestURL().toString();
		 if (refererURL != null && requestURL != null && refererURL.startsWith("https:") && requestURL.startsWith("http:")) {
			requestURL = requestURL.replace("http:", "https:");
		}
		
		KeycloakUriBuilder builder = KeycloakUriBuilder.fromUri(requestURL).replacePath(request.getContextPath()) .replaceQuery(null).path(JENKINS_FINISH_LOGIN_URL);
		String redirect = builder.toTemplate();
		return redirect;
	}
	
	private KeycloakDeployment resolveDeployment(KeycloakDeployment baseDeployment, HttpServletRequest request) {
		ServletFacade facade = new ServletFacade(request);
		return new AdapterDeploymentContext(baseDeployment).resolveDeployment(facade);
	}
	
	 public HttpResponse doFinishLogin(StaplerRequest request) throws IOException {
		String redirect = redirectUrl(request);
		try {
			LOGGER.log(Level.FINE, "Code" + request.getParameter(OAuth2Constants.CODE));
			LOGGER.log(Level.FINE, "Redirect" + redirect);
			KeycloakDeployment resolvedDeployment = resolveDeployment(getKeycloakDeployment(), request);
			LOGGER.log(Level.FINE, "TokenURL" + resolvedDeployment.getTokenUrl());
			AccessTokenResponse tokenResponse = ServerRequest.invokeAccessCodeToToken(resolvedDeployment, request.getParameter(OAuth2Constants.CODE), redirect, null);
			String tokenString = tokenResponse.getToken();
			String idTokenString = tokenResponse.getIdToken();
			String refreshToken = tokenResponse.getRefreshToken();
			AccessToken token = AdapterTokenVerifier.verifyToken(tokenString, resolvedDeployment);
			if (idTokenString != null) {
				JWSInput input = new JWSInput(idTokenString);
				IDToken idToken = input.readJsonContent(IDToken.class);
				KeycloakAuthentication auth = new KeycloakAuthentication(idToken, token, refreshToken, tokenResponse);
				SecurityContextHolder.getContext().setAuthentication(auth);
				User currentUser = User.current();
				if (currentUser != null) {
					currentUser.setFullName(idToken.getPreferredUsername());
					if (!currentUser.getProperty(Mailer.UserProperty.class).hasExplicitlyConfiguredAddress()) {
						currentUser.addProperty(new Mailer.UserProperty(idToken.getEmail()));
					}
					
					KeycloakUserDetails userDetails = new KeycloakUserDetails( idToken.getPreferredUsername(), auth.getAuthorities() );
					SecurityListener.fireAuthenticated(userDetails);
				}
				
			}
			
		}
		 catch (Exception e) {
			HttpFailure hf = null;
			LOGGER.log(Level.SEVERE, "Authentication Exception ", e);
			if (e instanceof HttpFailure) {
				hf = (HttpFailure) e;
			}
			
			Throwable cause = e.getCause();
			if (cause != null) {
				LOGGER.log(Level.SEVERE, "Original exception", cause);
				if (cause instanceof HttpFailure) {
					hf = (HttpFailure) cause;
				}
				
			}
			
			if (hf != null) {
				LOGGER.log(Level.SEVERE, "Failure Message" + ((HttpFailure) e).getError());
				LOGGER.log(Level.SEVERE, "Failure HTTP Status" + ((HttpFailure) e).getStatus());
			}
			
		}
		
		String referer = (String) request.getSession().getAttribute(REFERER_ATTRIBUTE);
		if (referer != null) {
			LOGGER.log(Level.FINEST, "Redirecting to " + referer);
			return HttpResponses.redirectTo(referer);
		}
		
		return HttpResponses.redirectToContextRoot();
	}
	
	public boolean allowsSignup() {
		return false;
	}
	
	public SecurityComponents createSecurityComponents() {
		SecurityComponents sc = new SecurityComponents(new AuthenticationManager() { 			public Authentication authenticate(Authentication authentication) throws AuthenticationException { if (authentication instanceof KeycloakAuthentication) { return authentication;
				}
				
				throw new BadCredentialsException("Unexpected authentication type: " + authentication);
			}
			
		}
		
);
		return sc;
	}
	
	public String getLoginUrl() {
		return JENKINS_LOGIN_URL;
	}
	
	public void doLogout(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
		final Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication instanceof KeycloakAuthentication) {
			KeycloakAuthentication keycloakAuthentication = (KeycloakAuthentication) authentication;
			try {
				ServerRequest.invokeLogout(getKeycloakDeployment(), keycloakAuthentication.getRefreshToken());
			}
			 catch (HttpFailure e) {
				LOGGER.log(Level.SEVERE, "Logout Exception ", e);
			}
			
		}
		
		req.getSession().setAttribute(AUTH_REQUESTED, Boolean.valueOf(false));
		super.doLogout(req, rsp);
	}
	
	public static final class DescriptorImpl extends Descriptor<SecurityRealm> {
		public String getHelpFile() {
			return "/plugin/keycloak/help/help-security-realm.html";
		}
		
		public String getDisplayName() {
			return "Keycloak Authentication Plugin";
		}
		
		 public DescriptorImpl() {
			super();
		}
		
		public DescriptorImpl(Class<? extends SecurityRealm> clazz) {
			super(clazz);
		}
		
		 public FormValidation doCheckKeycloakJson(@QueryParameter String value) throws ServletException {
			try {
				if (value != null && !value.isEmpty()) {
					JsonSerialization.readValue(value, AdapterConfig.class);
				}
				
			}
			 catch (IOException ex) {
				return FormValidation.error("Invalid adapter config");
			}
			
			return FormValidation.ok();
		}
		
		public boolean configure(StaplerRequest req, JSONObject json) throws hudson.model.Descriptor.FormException {
			json = json.getJSONObject("keycloak");
			 if (json.containsKey("keycloakValidate")) {
				LOGGER.log(Level.FINE, "Keycloakvalidate set to true");
				json.put("keycloakValidate", true);
				JSONObject validate = json.getJSONObject("keycloakValidate");
				if (validate.containsKey("keycloakRespectAccessTokenTimeout")) {
					json.put("keycloakRespectAccessTokenTimeout", validate.getBoolean("keycloakRespectAccessTokenTimeout"));
					LOGGER.log(Level.FINE, "Respect access token timeout is set to " + validate.getBoolean("keycloakRespectAccessTokenTimeout"));
				}
				
			}
			 else {
				json.put("keycloakValidate", false);
				json.put("keycloakRespectAccessTokenTimeout", true);
			}
			
			return super.configure(req, json);
		}
		
		public transient String keycloakJson = "";
		public transient String keycloakIdp = "";
		public transient boolean keycloakValidate = false;
		public transient boolean keycloakRespectAccessTokenTimeout = true;
	}
	
	 public String getKeycloakJson() {
		return keycloakJson;
	}
	
	public void setKeycloakJson(String keycloakJson) {
		this.keycloakJson = keycloakJson;
	}
	
	 public boolean isKeycloakValidate() {
		return keycloakValidate;
	}
	
	public void setKeycloakValidate(boolean keycloakValidate) {
		this.keycloakValidate = keycloakValidate;
	}
	
	 public boolean isKeycloakRespectAccessTokenTimeout() {
		return keycloakRespectAccessTokenTimeout;
	}
	
	public void setKeycloakRespectAccessTokenTimeout(boolean keycloakRespectAccessTokenTimeout) {
		this.keycloakRespectAccessTokenTimeout = keycloakRespectAccessTokenTimeout;
	}
	
	 public String getKeycloakIdp() {
		return keycloakIdp;
	}
	
	public void setKeycloakIdp(String keycloakIdp) {
		this.keycloakIdp = keycloakIdp;
	}
	
	 public boolean checkKeycloakOnEachRequest() {
		return isKeycloakValidate();
	}
	
	 public boolean respectAccessTokenTimeout() {
		return isKeycloakRespectAccessTokenTimeout();
	}
	
	 public synchronized KeycloakDeployment getKeycloakDeployment() throws IOException {
		if (keycloakDeployment == null || keycloakDeployment.getClient() == null) {
			AdapterConfig adapterConfig = JsonSerialization.readValue(getKeycloakJson(), AdapterConfig.class);
			keycloakDeployment = KeycloakDeploymentBuilder.build(adapterConfig);
		}
		
		return keycloakDeployment;
	}
	
	 public static class ServletFacade implements OIDCHttpFacade {
		private final HttpServletRequest servletRequest;
		private ServletFacade(HttpServletRequest servletRequest) {
			this.servletRequest = servletRequest;
		}
		
		public KeycloakSecurityContext getSecurityContext() {
			throw new IllegalStateException("Not yet implemented");
		}
		
		public Request getRequest() {
			return new Request() { 

				public String getFirstParam(String param) {
					return servletRequest.getParameter(param);
				}
				
				public String getMethod() {
					return servletRequest.getMethod();
				}
				
				public String getURI() {
					return servletRequest.getRequestURL().toString();
				}
				
				public String getRelativePath() {
					return servletRequest.getServletPath();
				}
				
				public boolean isSecure() {
					return servletRequest.isSecure();
				}
				
				public String getQueryParamValue(String param) {
					return servletRequest.getParameter(param);
				}
				
				public Cookie getCookie(String cookieName) {
					return null;
				}
				
				public String getHeader(String name) {
					return servletRequest.getHeader(name);
				}
				
				public List<String> getHeaders(String name) {
					return null;
				}
				
				public InputStream getInputStream() {
					try {
						return servletRequest.getInputStream();
					}
					 catch (IOException ioe) {
						throw new RuntimeException(ioe);
					}
					
				}
				
				public String getRemoteAddr() {
					return servletRequest.getRemoteAddr();
				}
				
				public void setError(AuthenticationError error) {
					servletRequest.setAttribute(AuthenticationError.class.getName(), error);
				}
				
				public void setError(LogoutError error) {
					servletRequest.setAttribute(LogoutError.class.getName(), error);
				}
				
				public InputStream getInputStream(boolean buffered) {
					try {
						return servletRequest.getInputStream();
					}
					 catch (IOException e) {
						throw new RuntimeException(e);
					}
					
				}
				
			};
		}
		
		public Response getResponse() {
			throw new IllegalStateException("Not yet implemented");
		}
		
		public X509Certificate[] getCertificateChain() {
			throw new IllegalStateException("Not yet implemented");
		}
		
	}
	
	private Object readResolve() {
		if (Strings.isNullOrEmpty(this.keycloakJson)) {
			getDescriptor().load();
			DescriptorImpl descriptor = ((DescriptorImpl) getDescriptor());
			System.out.println("Moo -- " + descriptor.keycloakJson);
			if (!Strings.isNullOrEmpty(descriptor.keycloakJson)) {
				this.keycloakJson = descriptor.keycloakJson;
				this.keycloakIdp = descriptor.keycloakIdp;
				this.keycloakValidate = descriptor.keycloakValidate;
				this.keycloakRespectAccessTokenTimeout = descriptor.keycloakRespectAccessTokenTimeout;
			}
			
		}
		
		return this;
	}
	
}


