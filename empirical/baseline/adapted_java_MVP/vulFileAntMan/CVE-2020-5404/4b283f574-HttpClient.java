package reactor.netty.http.client;
import java.net.SocketAddress;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import javax.annotation.Nullable;
import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaderValues;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
import io.netty.handler.codec.http.cookie.Cookie;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.ssl.SslContext;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.netty.ByteBufFlux;
import reactor.netty.ByteBufMono;
import reactor.netty.Connection;
import reactor.netty.ConnectionObserver;
import reactor.netty.NettyOutbound;
import reactor.netty.NettyPipeline;
import reactor.netty.channel.BootstrapHandlers;
import reactor.netty.http.HttpProtocol;
import reactor.netty.http.HttpResources;
import reactor.netty.http.websocket.WebsocketInbound;
import reactor.netty.http.websocket.WebsocketOutbound;
import reactor.netty.resources.ConnectionProvider;
import reactor.netty.tcp.SslProvider;
import reactor.netty.tcp.TcpClient;
public abstract class HttpClient {
	public static final String                         USER_AGENT = String.format("ReactorNetty/%s", reactorNettyVersion());
	 public interface UriConfiguration<S extends UriConfiguration<?>> {
		 S uri(String uri);
		 S uri(Mono<String> uri);
	}
	
	 public interface RequestSender extends ResponseReceiver<RequestSender> {
		 ResponseReceiver<?> send(Publisher<? extends ByteBuf> body);
		 ResponseReceiver<?> send(BiFunction<? super HttpClientRequest, ? super NettyOutbound, ? extends Publisher<Void>> sender);
		 default ResponseReceiver<?> sendForm(BiConsumer<? super HttpClientRequest, HttpClientForm> formCallback) {
			return sendForm(formCallback, null);
		}
		
		 ResponseReceiver<?> sendForm(BiConsumer<? super HttpClientRequest, HttpClientForm> formCallback, @Nullable Consumer<Flux<Long>>progress);
	}
	
	 public interface WebsocketSender extends WebsocketReceiver<WebsocketSender> {
		 WebsocketReceiver<?> send(Function<? super HttpClientRequest, ? extends Publisher<Void>> sender);
	}
	
	 public interface ResponseReceiver<S extends ResponseReceiver<?>> extends UriConfiguration<S> {
		 Mono<HttpClientResponse> response(); <V> Flux<V> response(BiFunction<? super HttpClientResponse, ? super ByteBufFlux, ? extends Publisher<V>> receiver); <V> Flux<V> responseConnection(BiFunction<? super HttpClientResponse, ? super Connection, ? extends Publisher<V>> receiver);
		 ByteBufFlux responseContent(); <V> Mono<V> responseSingle(BiFunction<? super HttpClientResponse, ? super ByteBufMono, ? extends Mono<V>> receiver);
	}
	
	 public interface WebsocketReceiver<S extends WebsocketReceiver<?>> extends UriConfiguration<S>  {
		 Mono<? extends Connection> connect(); <V> Flux<V> handle(BiFunction<? super WebsocketInbound, ? super WebsocketOutbound, ? extends Publisher<V>> receiver);
		 ByteBufFlux receive();
	}
	
	 public static HttpClient create() {
		return create(HttpResources.get());
	}
	
	 public static HttpClient create(ConnectionProvider connectionProvider) {
		return new HttpClientConnect(TcpClient.create(connectionProvider) .port(80));
	}
	
	 public static HttpClient newConnection() {
		return HttpClientConnect.INSTANCE;
	}
	
	 public static HttpClient from(TcpClient tcpClient) {
		return new HttpClientConnect(tcpClient);
	}
	
	 public final HttpClient baseUrl(String baseUrl) {
		Objects.requireNonNull(baseUrl, "baseUrl");
		return tcpConfiguration(tcp -> tcp.bootstrap(b -> HttpClientConfiguration.baseUrl(b, baseUrl)));
	}
	
	 public final HttpClient addressSupplier(Supplier<? extends SocketAddress> connectAddressSupplier) {
		Objects.requireNonNull(connectAddressSupplier, "connectAddressSupplier");
		return tcpConfiguration(tcpClient -> tcpClient.addressSupplier(connectAddressSupplier));
	}
	
	 public final HttpClient compress(boolean compressionEnabled) {
		if (compressionEnabled) {
			return tcpConfiguration(COMPRESS_ATTR_CONFIG).headers(COMPRESS_HEADERS);
		}
		
		else {
			return tcpConfiguration(COMPRESS_ATTR_DISABLE).headers(COMPRESS_HEADERS_DISABLE);
		}
		
	}
	
	 public final HttpClient mapConnect(BiFunction<? super Mono<? extends Connection>, ? super Bootstrap, ? extends Mono<? extends Connection>> connector) {
		return new HttpClientOnConnectMap(this, connector);
	}
	
	public final HttpClient chunkedTransfer(boolean chunkedEnabled) {
		if (chunkedEnabled) {
			return tcpConfiguration(CHUNKED_ATTR_CONFIG);
		}
		
		else {
			return tcpConfiguration(CHUNKED_ATTR_DISABLE);
		}
		
	}
	
	 public final HttpClient cookie(Cookie cookie) {
		return new HttpClientCookie(this, cookie);
	}
	
	 public final HttpClient cookie(String name, Consumer<? super Cookie> cookieBuilder) {
		return new HttpClientCookie(this, name, cookieBuilder);
	}
	
	 public final HttpClient cookiesWhen(String name, Function<? super Cookie, Mono<? extends Cookie>> cookieBuilder) {
		return new HttpClientCookieWhen(this, name, cookieBuilder);
	}
	
	 public final HttpClient cookieCodec(ClientCookieEncoder encoder) {
		ClientCookieDecoder decoder = encoder == ClientCookieEncoder.LAX ? ClientCookieDecoder.LAX : ClientCookieDecoder.STRICT;
		return cookieCodec(encoder, decoder);
	}
	
	 public final HttpClient cookieCodec(ClientCookieEncoder encoder, ClientCookieDecoder decoder) {
		return tcpConfiguration(tcp -> tcp.bootstrap( b -> HttpClientConfiguration.cookieCodec(b, encoder, decoder)));
	}
	
	 public final RequestSender delete() {
		return request(HttpMethod.DELETE);
	}
	
	 public final HttpClient doOnError(BiConsumer<? super HttpClientRequest, ? super Throwable> doOnRequest, BiConsumer<? super HttpClientResponse, ? super Throwable> doOnResponse) {
		Objects.requireNonNull(doOnRequest, "doOnRequest");
		Objects.requireNonNull(doOnResponse, "doOnResponse");
		return new HttpClientDoOnError(this, doOnRequest, doOnResponse);
	}
	
	 public final HttpClient doOnRequest(BiConsumer<? super HttpClientRequest, ? super Connection> doOnRequest) {
		Objects.requireNonNull(doOnRequest, "doOnRequest");
		return new HttpClientDoOn(this, doOnRequest, null, null, null);
	}
	
	 public final HttpClient doOnRequestError(BiConsumer<? super HttpClientRequest, ? super Throwable> doOnRequest) {
		Objects.requireNonNull(doOnRequest, "doOnRequest");
		return new HttpClientDoOnError(this, doOnRequest, null);
	}
	
	 public final HttpClient doAfterRequest(BiConsumer<? super HttpClientRequest, ? super Connection> doAfterRequest) {
		Objects.requireNonNull(doAfterRequest, "doAfterRequest");
		return new HttpClientDoOn(this, null, doAfterRequest, null, null);
	}
	
	 public final HttpClient doOnResponse(BiConsumer<? super HttpClientResponse, ? super Connection> doOnResponse) {
		Objects.requireNonNull(doOnResponse, "doOnResponse");
		return new HttpClientDoOn(this, null, null, doOnResponse, null);
	}
	
	 public final HttpClient doOnResponseError(BiConsumer<? super HttpClientResponse, ? super Throwable> doOnResponse) {
		Objects.requireNonNull(doOnResponse, "doOnResponse");
		return new HttpClientDoOnError(this, null, doOnResponse);
	}
	
	 public final HttpClient doAfterResponse(BiConsumer<? super HttpClientResponse, ? super Connection> doAfterResponse) {
		Objects.requireNonNull(doAfterResponse, "doAfterResponse");
		return new HttpClientDoOn(this, null, null, null, doAfterResponse);
	}
	
	 public final ResponseReceiver<?> get() {
		return request(HttpMethod.GET);
	}
	
	 public final ResponseReceiver<?> head() {
		return request(HttpMethod.HEAD);
	}
	
	 public final HttpClient headers(Consumer<? super HttpHeaders> headerBuilder) {
		return new HttpClientHeaders(this, headerBuilder);
	}
	
	 public final HttpClient headersWhen(Function<? super HttpHeaders, Mono<? extends HttpHeaders>> headerBuilder) {
		return new HttpClientHeadersWhen(this, headerBuilder);
	}
	
	 public final HttpClient keepAlive(boolean keepAlive) {
		if (keepAlive) {
			return tcpConfiguration(KEEPALIVE_ATTR_CONFIG);
		}
		
		else {
			return tcpConfiguration(KEEPALIVE_ATTR_DISABLE);
		}
		
	}
	
	 public final HttpClient followRedirect(boolean followRedirect) {
		if (followRedirect) {
			return tcpConfiguration(FOLLOW_REDIRECT_ATTR_CONFIG);
		}
		
		else {
			return tcpConfiguration(FOLLOW_REDIRECT_ATTR_DISABLE);
		}
		
	}
	
	 public final HttpClient followRedirect(BiPredicate<HttpClientRequest, HttpClientResponse> predicate) {
		Objects.requireNonNull(predicate, "predicate");
		return tcpConfiguration(tcp -> tcp.bootstrap( b -> HttpClientConfiguration.followRedirectPredicate(b, predicate)));
	}
	
	 public final HttpClient observe(ConnectionObserver observer) {
		return new HttpClientObserve(this, observer);
	}
	
	 public final ResponseReceiver<?> options() {
		return request(HttpMethod.OPTIONS);
	}
	
	 public final RequestSender patch() {
		return request(HttpMethod.PATCH);
	}
	
	 public final HttpClient port(int port) {
		return tcpConfiguration(tcpClient -> tcpClient.port(port));
	}
	
	 public final RequestSender post() {
		return request(HttpMethod.POST);
	}
	
	 public final HttpClient protocol(HttpProtocol... supportedProtocols) {
		return tcpConfiguration(tcpClient -> tcpClient.bootstrap(b -> HttpClientConfiguration.protocols(b, supportedProtocols)));
	}
	
	 public final RequestSender put() {
		return request(HttpMethod.PUT);
	}
	
	 public RequestSender request(HttpMethod method) {
		Objects.requireNonNull(method, "method");
		TcpClient tcpConfiguration = tcpConfiguration().bootstrap(b -> HttpClientConfiguration.method(b, method));
		return new HttpClientFinalizer(tcpConfiguration);
	}
	
	 public final HttpClient secure() {
		return new HttpClientSecure(this, null);
	}
	
	 public final HttpClient secure(Consumer<? super SslProvider.SslContextSpec> sslProviderBuilder) {
		return HttpClientSecure.secure(this, sslProviderBuilder);
	}
	
	 public final HttpClient tcpConfiguration(Function<? super TcpClient, ? extends TcpClient> tcpMapper) {
		return new HttpClientTcpConfig(this, tcpMapper);
	}
	
	public final HttpClient wiretap() {
		return tcpConfiguration(tcpClient -> tcpClient.bootstrap( b -> BootstrapHandlers.updateLogSupport(b, LOGGING_HANDLER)));
	}
	
	 public final HttpClient wiretap(boolean enable) {
		if (enable) {
			return tcpConfiguration(tcpClient -> tcpClient.bootstrap(b -> BootstrapHandlers.updateLogSupport(b, LOGGING_HANDLER)));
		}
		
		else {
			return tcpConfiguration(tcpClient -> tcpClient.bootstrap( b -> BootstrapHandlers.removeConfiguration(b, NettyPipeline.LoggingHandler)));
		}
		
	}
	
	 public final HttpClient httpResponseDecoder(Function<HttpResponseDecoderSpec, HttpResponseDecoderSpec> responseDecoderOptions) {
		return tcpConfiguration( responseDecoderOptions.apply(new HttpResponseDecoderSpec()) .build());
	}
	
	 public final WebsocketSender websocket() {
		return websocket("");
	}
	
	 public final WebsocketSender websocket(String subprotocols) {
		return websocket(subprotocols, 65536);
	}
	
	 public final WebsocketSender websocket(int maxFramePayloadLength) {
		return websocket("", maxFramePayloadLength);
	}
	
	 public final WebsocketSender websocket(String subprotocols, int maxFramePayloadLength) {
		Objects.requireNonNull(subprotocols, "subprotocols");
		TcpClient tcpConfiguration = tcpConfiguration() .bootstrap(b -> HttpClientConfiguration.websocketSubprotocols(b, subprotocols)) .bootstrap(b -> HttpClientConfiguration.websocketMaxFramePayloadLength(b, maxFramePayloadLength));
		return new WebsocketFinalizer(tcpConfiguration);
	}
	
	 protected TcpClient tcpConfiguration() {
		return DEFAULT_TCP_CLIENT;
	}
	
	static String reactorNettyVersion() {
		return Optional.ofNullable(HttpClient.class.getPackage() .getImplementationVersion()) .orElse("dev");
	}
	
	final static String                    WS_SCHEME    = "ws";
	final static String                    WSS_SCHEME   = "wss";
	final static String                    HTTP_SCHEME  = "http";
	final static String                    HTTPS_SCHEME = "https";
	static final TcpClient DEFAULT_TCP_CLIENT = TcpClient.newConnection() .port(80);
	static final LoggingHandler LOGGING_HANDLER = new LoggingHandler(HttpClient.class);
	static final Function<TcpClient, TcpClient> COMPRESS_ATTR_CONFIG = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_COMPRESS);
	static final Function<TcpClient, TcpClient> COMPRESS_ATTR_DISABLE = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_NO_COMPRESS);
	static final Function<TcpClient, TcpClient> CHUNKED_ATTR_CONFIG = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_CHUNKED);
	static final Function<TcpClient, TcpClient> KEEPALIVE_ATTR_CONFIG = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_KEEPALIVE);
	static final Function<TcpClient, TcpClient> KEEPALIVE_ATTR_DISABLE = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_NO_KEEPALIVE);
	static final Function<TcpClient, TcpClient> CHUNKED_ATTR_DISABLE = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_NO_CHUNKED);
	static final Function<TcpClient, TcpClient> FOLLOW_REDIRECT_ATTR_CONFIG = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_REDIRECT);
	static final Function<TcpClient, TcpClient> FOLLOW_REDIRECT_ATTR_DISABLE = tcp -> tcp.bootstrap(HttpClientConfiguration.MAP_NO_REDIRECT);
	static final Consumer<? super HttpHeaders> COMPRESS_HEADERS = h -> h.add(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP);
	static final Consumer<? super HttpHeaders> COMPRESS_HEADERS_DISABLE = h -> {
		if (isCompressing(h)) {
			h.remove(HttpHeaderNames.ACCEPT_ENCODING);
		}
		
	};
	static boolean isCompressing(HttpHeaders h){
		return h.contains(HttpHeaderNames.ACCEPT_ENCODING, HttpHeaderValues.GZIP, true);
	}
	
}


