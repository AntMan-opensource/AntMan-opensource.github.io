package com.rabbitmq.client.impl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.UnexpectedFrameError;
final class CommandAssembler {
    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
    private enum CAState {
        EXPECTING_METHOD, EXPECTING_CONTENT_HEADER, EXPECTING_CONTENT_BODY, COMPLETE }
    private CAState state;
    private Method method;
    private AMQContentHeader contentHeader;
    private final List<byte[]> bodyN;
    private int bodyLength;
    private long remainingBodyBytes;
    public CommandAssembler(Method method, AMQContentHeader contentHeader, byte[] body) {
        this.method = method;
        this.contentHeader = contentHeader;
        this.bodyN = new ArrayList<byte[]>(2);
        this.bodyLength = 0;
        this.remainingBodyBytes = 0;
        appendBodyFragment(body);
        if (method == null) {
            this.state = CAState.EXPECTING_METHOD;
        }
         else if (contentHeader == null) {
            this.state = method.hasContent() ? CAState.EXPECTING_CONTENT_HEADER : CAState.COMPLETE;
        }
         else {
            this.remainingBodyBytes = contentHeader.getBodySize() - this.bodyLength;
            updateContentBodyState();
        }
        
    }
    
    public synchronized Method getMethod() {
        return this.method;
    }
    
    public synchronized AMQContentHeader getContentHeader() {
        return this.contentHeader;
    }
    
    public synchronized boolean isComplete() {
        return (this.state == CAState.COMPLETE);
    }
    
    private void updateContentBodyState() {
        this.state = (this.remainingBodyBytes > 0) ? CAState.EXPECTING_CONTENT_BODY : CAState.COMPLETE;
    }
    
    private void consumeMethodFrame(Frame f) throws IOException {
        if (f.type == AMQP.FRAME_METHOD) {
            this.method = AMQImpl.readMethodFrom(f.getInputStream());
            this.state = this.method.hasContent() ? CAState.EXPECTING_CONTENT_HEADER : CAState.COMPLETE;
        }
         else {
            throw new UnexpectedFrameError(f, AMQP.FRAME_METHOD);
        }
        
    }
    
    private void consumeHeaderFrame(Frame f) throws IOException {
        if (f.type == AMQP.FRAME_HEADER) {
            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());
            this.remainingBodyBytes = this.contentHeader.getBodySize();
            updateContentBodyState();
        }
         else {
            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);
        }
        
    }
    
    private void consumeBodyFrame(Frame f) {
        if (f.type == AMQP.FRAME_BODY) {
            byte[] fragment = f.getPayload();
            this.remainingBodyBytes -= fragment.length;
            updateContentBodyState();
            if (this.remainingBodyBytes < 0) {
                throw new UnsupportedOperationException("%%%%%% FIXME unimplemented");
            }
            
            appendBodyFragment(fragment);
        }
         else {
            throw new UnexpectedFrameError(f, AMQP.FRAME_BODY);
        }
        
    }
    
    private byte[] coalesceContentBody() {
        if (this.bodyLength == 0) return EMPTY_BYTE_ARRAY;
        if (this.bodyN.size() == 1) return this.bodyN.get(0);
        byte[] body = new byte[bodyLength];
        int offset = 0;
        for (byte[] fragment : this.bodyN) {
            System.arraycopy(fragment, 0, body, offset, fragment.length);
            offset += fragment.length;
        }
        
        this.bodyN.clear();
        this.bodyN.add(body);
        return body;
    }
    
    public synchronized byte[] getContentBody() {
        return coalesceContentBody();
    }
    
    private void appendBodyFragment(byte[] fragment) {
        if (fragment == null || fragment.length == 0) return;
        bodyN.add(fragment);
        bodyLength += fragment.length;
    }
    
    public synchronized boolean handleFrame(Frame f) throws IOException {
        switch (this.state) {
          case EXPECTING_METHOD:          consumeMethodFrame(f); break;
          case EXPECTING_CONTENT_HEADER:  consumeHeaderFrame(f); break;
          case EXPECTING_CONTENT_BODY:    consumeBodyFrame(f);   break;
          default: throw new IllegalStateException("Bad Command State " + this.state);
        }
        
        return isComplete();
    }
    
}


