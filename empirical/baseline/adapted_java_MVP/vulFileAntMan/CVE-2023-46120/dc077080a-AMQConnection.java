package com.rabbitmq.client.impl;
import com.rabbitmq.client.Method;
import com.rabbitmq.client.*;
import com.rabbitmq.client.impl.AMQChannel.BlockingRpcContinuation;
import com.rabbitmq.client.impl.recovery.RecoveryCanBeginListener;
import com.rabbitmq.utility.BlockingCell;
import com.rabbitmq.utility.Utility;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.EOFException;
import java.io.IOException;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
final class Copyright {
    final static String COPYRIGHT="Copyright (c) 2007-2021 VMware, Inc. or its affiliates.";
    final static String LICENSE="Licensed under the MPL. See https://www.rabbitmq.com/";
}

public class AMQConnection extends ShutdownNotifierComponent implements Connection, NetworkConnection {
    private static final int MAX_UNSIGNED_SHORT = 65535;
    private static final Logger LOGGER = LoggerFactory.getLogger(AMQConnection.class);
    public static final double CHANNEL_SHUTDOWN_TIMEOUT_MULTIPLIER = 1.05;
    private final ExecutorService consumerWorkServiceExecutor;
    private final ScheduledExecutorService heartbeatExecutor;
    private final ExecutorService shutdownExecutor;
    private Thread mainLoopThread;
    private ThreadFactory threadFactory = Executors.defaultThreadFactory();
    private String id;
    private final List<RecoveryCanBeginListener> recoveryCanBeginListeners = Collections.synchronizedList(new ArrayList<RecoveryCanBeginListener>());
    private final ErrorOnWriteListener errorOnWriteListener;
    private final int workPoolTimeout;
    private final AtomicBoolean finalShutdownStarted = new AtomicBoolean(false);
    public static Map<String, Object> defaultClientProperties() {
        Map<String,Object> props = new HashMap<String, Object>();
        props.put("product", LongStringHelper.asLongString("RabbitMQ"));
        props.put("version", LongStringHelper.asLongString(ClientVersion.VERSION));
        props.put("platform", LongStringHelper.asLongString("Java"));
        props.put("copyright", LongStringHelper.asLongString(Copyright.COPYRIGHT));
        props.put("information", LongStringHelper.asLongString(Copyright.LICENSE));
        Map<String, Object> capabilities = new HashMap<String, Object>();
        capabilities.put("publisher_confirms", true);
        capabilities.put("exchange_exchange_bindings", true);
        capabilities.put("basic.nack", true);
        capabilities.put("consumer_cancel_notify", true);
        capabilities.put("connection.blocked", true);
        capabilities.put("authentication_failure_close", true);
        props.put("capabilities", capabilities);
        return props;
    }
    
    private static final Version clientVersion = new Version(AMQP.PROTOCOL.MAJOR, AMQP.PROTOCOL.MINOR);
    private final AMQChannel _channel0;
    protected ConsumerWorkService _workService = null;
    private final FrameHandler _frameHandler;
    private volatile boolean _running = false;
    private final ExceptionHandler _exceptionHandler;
    private final BlockingCell<Object> _appContinuation = new BlockingCell<Object>();
    private volatile boolean _brokerInitiatedShutdown;
    private volatile boolean _inConnectionNegotiation;
    private HeartbeatSender _heartbeatSender;
    private final String _virtualHost;
    private final Map<String, Object> _clientProperties;
    private final SaslConfig saslConfig;
    private final int requestedHeartbeat;
    private final int requestedChannelMax;
    private final int requestedFrameMax;
    private final int handshakeTimeout;
    private final int shutdownTimeout;
    private final CredentialsProvider credentialsProvider;
    private final Collection<BlockedListener> blockedListeners = new CopyOnWriteArrayList<BlockedListener>();
    protected final MetricsCollector metricsCollector;
    private final int channelRpcTimeout;
    private final boolean channelShouldCheckRpcResponseType;
    private final TrafficListener trafficListener;
    private final CredentialsRefreshService credentialsRefreshService;
    private volatile int _frameMax = 0;
    private volatile int _missedHeartbeats = 0;
    private volatile int _heartbeat = 0;
    private volatile ChannelManager _channelManager;
    private volatile Map<String, Object> _serverProperties;
    public final void disconnectChannel(ChannelN channel) {
        ChannelManager cm = _channelManager;
        if (cm != null){
            cm.releaseChannelNumber(channel);
}
    }
    
    private void ensureIsOpen() throws AlreadyClosedException {
        if (!isOpen()) {
            throw new AlreadyClosedException(getCloseReason());
        }
        
    }
    
    public InetAddress getAddress() {
        return _frameHandler.getAddress();
    }
    
    public InetAddress getLocalAddress() {
        return _frameHandler.getLocalAddress();
    }
    
    public int getPort() {
        return _frameHandler.getPort();
    }
    
    public int getLocalPort() {
        return _frameHandler.getLocalPort();
    }
    
    public FrameHandler getFrameHandler(){
        return _frameHandler;
    }
    
    public Map<String, Object> getServerProperties() {
        return _serverProperties;
    }
    
    public AMQConnection(ConnectionParams params, FrameHandler frameHandler) {
        this(params, frameHandler, new NoOpMetricsCollector());
    }
    
    public AMQConnection(ConnectionParams params, FrameHandler frameHandler, MetricsCollector metricsCollector) {
        checkPreconditions();
        this.credentialsProvider = params.getCredentialsProvider();
        this._frameHandler = frameHandler;
        this._virtualHost = params.getVirtualHost();
        this._exceptionHandler = params.getExceptionHandler();
        this._clientProperties = new HashMap<>(params.getClientProperties());
        this.requestedFrameMax = params.getRequestedFrameMax();
        this.requestedChannelMax = params.getRequestedChannelMax();
        this.requestedHeartbeat = params.getRequestedHeartbeat();
        this.handshakeTimeout = params.getHandshakeTimeout();
        this.shutdownTimeout = params.getShutdownTimeout();
        this.saslConfig = params.getSaslConfig();
        this.consumerWorkServiceExecutor = params.getConsumerWorkServiceExecutor();
        this.heartbeatExecutor = params.getHeartbeatExecutor();
        this.shutdownExecutor = params.getShutdownExecutor();
        this.threadFactory = params.getThreadFactory();
        if(params.getChannelRpcTimeout() < 0) {
            throw new IllegalArgumentException("Continuation timeout on RPC calls cannot be less than 0");
        }
        
        this.channelRpcTimeout = params.getChannelRpcTimeout();
        this.channelShouldCheckRpcResponseType = params.channelShouldCheckRpcResponseType();
        this.trafficListener = params.getTrafficListener() == null ? TrafficListener.NO_OP : params.getTrafficListener();
        this.credentialsRefreshService = params.getCredentialsRefreshService();
        this._channel0 = createChannel0();
        this._channelManager = null;
        this._brokerInitiatedShutdown = false;
        this._inConnectionNegotiation = true; 
        this.metricsCollector = metricsCollector;
        this.errorOnWriteListener = params.getErrorOnWriteListener() != null ? params.getErrorOnWriteListener() : (connection, exception) -> { throw exception; }; 
        this.workPoolTimeout = params.getWorkPoolTimeout();
    }
    
    AMQChannel createChannel0() {
        return new AMQChannel(this, 0) {
 public boolean processAsync(Command c) throws IOException {
                return getConnection().processControlCommand(c);
            }
            
        };
    }
    
    private void initializeConsumerWorkService() {
        this._workService  = new ConsumerWorkService(consumerWorkServiceExecutor, threadFactory, workPoolTimeout, shutdownTimeout);
    }
    
    private void initializeHeartbeatSender() {
        this._heartbeatSender = new HeartbeatSender(_frameHandler, heartbeatExecutor, threadFactory);
    }
    
    public void start() throws IOException, TimeoutException {
        initializeConsumerWorkService();
        initializeHeartbeatSender();
        this._running = true;
        AMQChannel.SimpleBlockingRpcContinuation connStartBlocker = new AMQChannel.SimpleBlockingRpcContinuation();
        _channel0.enqueueRpc(connStartBlocker);
        try {
            _frameHandler.setTimeout(handshakeTimeout);
            _frameHandler.sendHeader();
        }
         catch (IOException ioe) {
            _frameHandler.close();
            throw ioe;
        }
        
        this._frameHandler.initialize(this);
        AMQP.Connection.Start connStart;
        AMQP.Connection.Tune connTune = null;
        try {
            connStart = (AMQP.Connection.Start) connStartBlocker.getReply(handshakeTimeout/2).getMethod();
            _serverProperties = Collections.unmodifiableMap(connStart.getServerProperties());
            Version serverVersion = new Version(connStart.getVersionMajor(), connStart.getVersionMinor());
            if (!Version.checkVersion(clientVersion, serverVersion)) {
                throw new ProtocolVersionMismatchException(clientVersion, serverVersion);
            }
            
            String[] mechanisms = connStart.getMechanisms().toString().split(" ");
            SaslMechanism sm = this.saslConfig.getSaslMechanism(mechanisms);
            if (sm == null) {
                throw new IOException("No compatible authentication mechanism found - " + "server offered [" + connStart.getMechanisms() + "]");
            }
            
            String username = credentialsProvider.getUsername();
            String password = credentialsProvider.getPassword();
            if (credentialsProvider.getTimeBeforeExpiration() != null) {
                if (this.credentialsRefreshService == null) {
                    throw new IllegalStateException("Credentials can expire, a credentials refresh service should be set");
                }
                
                if (this.credentialsRefreshService.isApproachingExpiration(credentialsProvider.getTimeBeforeExpiration())) {
                    credentialsProvider.refresh();
                    username = credentialsProvider.getUsername();
                    password = credentialsProvider.getPassword();
                }
                
            }
            
            LongString challenge = null;
            LongString response = sm.handleChallenge(null, username, password);
            do {
                Method method = (challenge == null) ? new AMQP.Connection.StartOk.Builder() .clientProperties(_clientProperties) .mechanism(sm.getName()) .response(response) .build() : new AMQP.Connection.SecureOk.Builder().response(response).build();
                try {
                    Method serverResponse = _channel0.rpc(method, handshakeTimeout/2).getMethod();
                    if (serverResponse instanceof AMQP.Connection.Tune) {
                        connTune = (AMQP.Connection.Tune) serverResponse;
                    }
                     else {
                        challenge = ((AMQP.Connection.Secure) serverResponse).getChallenge();
                        response = sm.handleChallenge(challenge, username, password);
                    }
                    
                }
                 catch (ShutdownSignalException e) {
                    Method shutdownMethod = e.getReason();
                    if (shutdownMethod instanceof AMQP.Connection.Close) {
                        AMQP.Connection.Close shutdownClose = (AMQP.Connection.Close) shutdownMethod;
                        if (shutdownClose.getReplyCode() == AMQP.ACCESS_REFUSED) {
                            throw new AuthenticationFailureException(shutdownClose.getReplyText());
                        }
                        
                    }
                    
                    throw new PossibleAuthenticationFailureException(e);
                }
                
            }
             while (connTune == null);
        }
         catch (TimeoutException te) {
            _frameHandler.close();
            throw te;
        }
         catch (ShutdownSignalException sse) {
            _frameHandler.close();
            throw AMQChannel.wrap(sse);
        }
         catch(IOException ioe) {
            _frameHandler.close();
            throw ioe;
        }
        
        try {
            int negotiatedChannelMax = negotiateChannelMax(this.requestedChannelMax, connTune.getChannelMax());
            int channelMax = ConnectionFactory.ensureUnsignedShort(negotiatedChannelMax);
            if (channelMax != negotiatedChannelMax) {
                LOGGER.warn("Channel max must be between 0 and {}, value has been set to {} instead of {}", MAX_UNSIGNED_SHORT, channelMax, negotiatedChannelMax);
            }
            
            _channelManager = instantiateChannelManager(channelMax, threadFactory);
            int frameMax = negotiatedMaxValue(this.requestedFrameMax, connTune.getFrameMax());
            this._frameMax = frameMax;
            int negotiatedHeartbeat = negotiatedMaxValue(this.requestedHeartbeat, connTune.getHeartbeat());
            int heartbeat = ConnectionFactory.ensureUnsignedShort(negotiatedHeartbeat);
            if (heartbeat != negotiatedHeartbeat) {
                LOGGER.warn("Heartbeat must be between 0 and {}, value has been set to {} instead of {}", MAX_UNSIGNED_SHORT, heartbeat, negotiatedHeartbeat);
            }
            
            setHeartbeat(heartbeat);
            _channel0.transmit(new AMQP.Connection.TuneOk.Builder() .channelMax(channelMax) .frameMax(frameMax) .heartbeat(heartbeat) .build());
            _channel0.exnWrappingRpc(new AMQP.Connection.Open.Builder() .virtualHost(_virtualHost) .build());
        }
         catch (IOException ioe) {
            _heartbeatSender.shutdown();
            _frameHandler.close();
            throw ioe;
        }
         catch (ShutdownSignalException sse) {
            _heartbeatSender.shutdown();
            _frameHandler.close();
            throw AMQChannel.wrap(sse);
        }
        
        if (this.credentialsProvider.getTimeBeforeExpiration() != null) {
            String registrationId = this.credentialsRefreshService.register(credentialsProvider, () -> {
                if (!isOpen()) {
                    return false;
                }
                
                if (this._inConnectionNegotiation) {
                    return true;
                }
                
                String refreshedPassword = credentialsProvider.getPassword();
                UpdateSecretExtension.UpdateSecret updateSecret = new UpdateSecretExtension.UpdateSecret( LongStringHelper.asLongString(refreshedPassword), "Refresh scheduled by client" );
                try {
                    _channel0.rpc(updateSecret);
                }
                 catch (ShutdownSignalException e) {
                    LOGGER.warn("Error while trying to update secret: {}. Connection has been closed.", e.getMessage());
                    return false;
                }
                
                return true;
            }
            
);
            addShutdownListener(sse -> this.credentialsRefreshService.unregister(this.credentialsProvider, registrationId));
        }
        
        this._inConnectionNegotiation = false;
    }
    
    protected ChannelManager instantiateChannelManager(int channelMax, ThreadFactory threadFactory) {
        ChannelManager result = new ChannelManager(this._workService, channelMax, threadFactory, this.metricsCollector);
        configureChannelManager(result);
        return result;
    }
    
    protected void configureChannelManager(ChannelManager channelManager) {
        channelManager.setShutdownExecutor(this.shutdownExecutor);
        channelManager.setChannelShutdownTimeout((int) ((requestedHeartbeat * CHANNEL_SHUTDOWN_TIMEOUT_MULTIPLIER) * 1000));
    }
    
    public void startMainLoop() {
        MainLoop loop = new MainLoop();
        final String name = "AMQP Connection " + getHostAddress() + ":" + getPort();
        mainLoopThread = Environment.newThread(threadFactory, loop, name);
        mainLoopThread.start();
    }
    
    protected int negotiateChannelMax(int requestedChannelMax, int serverMax) {
        return negotiatedMaxValue(requestedChannelMax, serverMax);
    }
    
    private static void checkPreconditions() {
        AMQCommand.checkPreconditions();
    }
    
    public int getChannelMax() {
        ChannelManager cm = _channelManager;
        if (cm == null) return 0;
        return cm.getChannelMax();
    }
    
    public int getFrameMax() {
        return _frameMax;
    }
    
    public int getHeartbeat() {
        return _heartbeat;
    }
    
    public void setHeartbeat(int heartbeat) {
        try {
            _heartbeatSender.setHeartbeat(heartbeat);
            _heartbeat = heartbeat;
            _frameHandler.setTimeout(heartbeat * 1000 / 4);
        }
         catch (SocketException se) {
        }
        
    }
    
    public void setThreadFactory(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
    }
    
    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }
    
    public Map<String, Object> getClientProperties() {
        return new HashMap<String, Object>(_clientProperties);
    }
    
    public String getClientProvidedName() {
        return (String) _clientProperties.get("connection_name");
    }
    
    public ExceptionHandler getExceptionHandler() {
        return _exceptionHandler;
    }
    
    public boolean willShutDownConsumerExecutor() {
        return this._workService.usesPrivateExecutor();
    }
    
    public Channel createChannel(int channelNumber) throws IOException {
        ensureIsOpen();
        ChannelManager cm = _channelManager;
        if (cm == null) return null;
        Channel channel = cm.createChannel(this, channelNumber);
        if (channel != null) {
            metricsCollector.newChannel(channel);
        }
        
        return channel;
    }
    
    public Channel createChannel() throws IOException {
        ensureIsOpen();
        ChannelManager cm = _channelManager;
        if (cm == null) return null;
        Channel channel = cm.createChannel(this);
        if (channel != null) {
            metricsCollector.newChannel(channel);
        }
        
        return channel;
    }
    
    public void writeFrame(Frame f) throws IOException {
        _frameHandler.writeFrame(f);
        _heartbeatSender.signalActivity();
    }
    
    public void flush() throws IOException {
        try {
            _frameHandler.flush();
        }
         catch (IOException ioe) {
            this.errorOnWriteListener.handle(this, ioe);
        }
        
    }
    
    private static int negotiatedMaxValue(int clientValue, int serverValue) {
        return (clientValue == 0 || serverValue == 0) ? Math.max(clientValue, serverValue) : Math.min(clientValue, serverValue);
    }
    
    private static boolean checkUnsignedShort(int value) {
        return value >= 0 && value <= MAX_UNSIGNED_SHORT;
    }
    
    private class MainLoop implements Runnable {
        public void run() {
            boolean shouldDoFinalShutdown = true;
            try {
                while (_running) {
                    Frame frame = _frameHandler.readFrame();
                    readFrame(frame);
                }
                
            }
             catch (Throwable ex) {
                if (ex instanceof InterruptedException) {
                    shouldDoFinalShutdown = false;
                }
                 else {
                    handleFailure(ex);
                }
                
            }
             finally {
                if (shouldDoFinalShutdown) {
                    doFinalShutdown();
                }
                
            }
            
        }
        
    }
    
    public boolean handleReadFrame(Frame frame) {
        if(_running) {
            try {
                readFrame(frame);
                return true;
            }
             catch (WorkPoolFullException e) {
                throw e;
            }
             catch (Throwable ex) {
                try {
                    handleFailure(ex);
                }
                 finally {
                    doFinalShutdown();
                }
                
            }
            
        }
        
        return false;
    }
    
    public boolean isRunning() {
        return _running;
    }
    
    public boolean hasBrokerInitiatedShutdown() {
        return _brokerInitiatedShutdown;
    }
    
    private void readFrame(Frame frame) throws IOException {
        if (frame != null) {
            _missedHeartbeats = 0;
            if (frame.type == AMQP.FRAME_HEARTBEAT) {
            }
             else {
                if (frame.channel == 0) { 
                    _channel0.handleFrame(frame);
                }
                 else {
                    if (isOpen()) {
                        ChannelManager cm = _channelManager;
                        if (cm != null) {
                            ChannelN channel;
                            try {
                                channel = cm.getChannel(frame.channel);
                            }
                             catch(UnknownChannelException e) {
                                LOGGER.info("Received a frame on an unknown channel, ignoring it");
                                return;
                            }
                            
                            channel.handleFrame(frame);
                        }
                        
                    }
                    
                }
                
            }
            
        }
         else {
            handleSocketTimeout();
        }
        
    }
    
    public void handleHeartbeatFailure() {
        Exception ex = new MissedHeartbeatException("Detected missed server heartbeats, heartbeat interval: " + _heartbeat + " seconds, RabbitMQ node hostname: " + this.getHostAddress());
        try {
            _exceptionHandler.handleUnexpectedConnectionDriverException(this, ex);
            shutdown(null, false, ex, true);
        }
         finally {
            doFinalShutdown();
        }
        
    }
    
    public void handleIoError(Throwable ex) {
        try {
            handleFailure(ex);
        }
         finally {
            doFinalShutdown();
        }
        
    }
    
    private void handleFailure(Throwable ex)  {
        if(ex instanceof EOFException) {
            if (!_brokerInitiatedShutdown){
                shutdown(null, false, ex, true);
}
        }
         else {
            _exceptionHandler.handleUnexpectedConnectionDriverException(AMQConnection.this, ex);
            shutdown(null, false, ex, true);
        }
        
    }
    
    public void doFinalShutdown() {
        if (finalShutdownStarted.compareAndSet(false, true)) {
            _frameHandler.close();
            _appContinuation.set(null);
            closeMainLoopThreadIfNecessary();
            notifyListeners();
            notifyRecoveryCanBeginListeners();
        }
        
    }
    
    private void closeMainLoopThreadIfNecessary() {
        if (mainLoopReadThreadNotNull() && notInMainLoopThread()) {
            if (this.mainLoopThread.isAlive()) {
                this.mainLoopThread.interrupt();
            }
            
        }
        
    }
    
    private boolean notInMainLoopThread() {
        return Thread.currentThread() != this.mainLoopThread;
    }
    
    private boolean mainLoopReadThreadNotNull() {
        return this.mainLoopThread != null;
    }
    
    private void notifyRecoveryCanBeginListeners() {
        ShutdownSignalException sse = this.getCloseReason();
        for(RecoveryCanBeginListener fn : Utility.copy(this.recoveryCanBeginListeners)) {
            fn.recoveryCanBegin(sse);
        }
        
    }
    
    public void addRecoveryCanBeginListener(RecoveryCanBeginListener fn) {
        this.recoveryCanBeginListeners.add(fn);
    }
    
    public void removeRecoveryCanBeginListener(RecoveryCanBeginListener fn) {
        this.recoveryCanBeginListeners.remove(fn);
    }
    
    private void handleSocketTimeout() throws SocketTimeoutException {
        if (_inConnectionNegotiation) {
            throw new SocketTimeoutException("Timeout during Connection negotiation");
        }
        
        if (_heartbeat == 0) { 
            return;
        }
        
        if (++_missedHeartbeats > (2 * 4)) {
            throw new MissedHeartbeatException("Heartbeat missing with heartbeat = " + _heartbeat + " seconds");
        }
        
    }
    
    public boolean processControlCommand(Command c) throws IOException {
        Method method = c.getMethod();
        if (isOpen()) {
            if (method instanceof AMQP.Connection.Close) {
                handleConnectionClose(c);
                return true;
            }
             else if (method instanceof AMQP.Connection.Blocked) {
                AMQP.Connection.Blocked blocked = (AMQP.Connection.Blocked) method;
                try {
                    for (BlockedListener l : this.blockedListeners) {
                        l.handleBlocked(blocked.getReason());
                    }
                    
                }
                 catch (Throwable ex) {
                    getExceptionHandler().handleBlockedListenerException(this, ex);
                }
                
                return true;
            }
             else if (method instanceof AMQP.Connection.Unblocked) {
                try {
                    for (BlockedListener l : this.blockedListeners) {
                        l.handleUnblocked();
                    }
                    
                }
                 catch (Throwable ex) {
                    getExceptionHandler().handleBlockedListenerException(this, ex);
                }
                
                return true;
            }
             else {
                return false;
            }
            
        }
         else {
            if (method instanceof AMQP.Connection.Close) {
                try {
                    _channel0.quiescingTransmit(new AMQP.Connection.CloseOk.Builder().build());
                }
                 catch (IOException ignored) {
 
}
 
                return true;
            }
             else if (method instanceof AMQP.Connection.CloseOk) {
                _running = false;
                return !_channel0.isOutstandingRpc();
            }
             else { 
                return true;
            }
            
        }
        
    }
    
    public void handleConnectionClose(Command closeCommand) {
        ShutdownSignalException sse = shutdown(closeCommand.getMethod(), false, null, _inConnectionNegotiation);
        try {
            _channel0.quiescingTransmit(new AMQP.Connection.CloseOk.Builder().build());
        }
         catch (IOException ignored) {
 
}
 
        _brokerInitiatedShutdown = true;
        SocketCloseWait scw = new SocketCloseWait(sse);
        if(shutdownExecutor != null) {
            shutdownExecutor.execute(scw);
        }
         else {
            final String name = "RabbitMQ connection shutdown monitor " + getHostAddress() + ":" + getPort();
            Thread waiter = Environment.newThread(threadFactory, scw, name);
            waiter.start();
        }
        
    }
    
    private static long SOCKET_CLOSE_TIMEOUT = 10000;
    private class SocketCloseWait implements Runnable {
        private final ShutdownSignalException cause;
        public SocketCloseWait(ShutdownSignalException sse) {
            cause = sse;
        }
        
        public void run() {
            try {
                _appContinuation.get(SOCKET_CLOSE_TIMEOUT);
            }
             catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
             catch (TimeoutException ignored) {
            }
             finally {
                _running = false;
                    _channel0.notifyOutstandingRpc(cause);
            }
            
        }
        
    }
    
    public ShutdownSignalException shutdown(Method reason, boolean initiatedByApplication, Throwable cause, boolean notifyRpc) {
        ShutdownSignalException sse = startShutdown(reason, initiatedByApplication, cause, notifyRpc);
        finishShutdown(sse);
        return sse;
    }
    
    private ShutdownSignalException startShutdown(Method reason, boolean initiatedByApplication, Throwable cause, boolean notifyRpc) {
        ShutdownSignalException sse = new ShutdownSignalException(true,initiatedByApplication, reason, this);
        sse.initCause(cause);
        if (!setShutdownCauseIfOpen(sse)) {
            if (initiatedByApplication){
                throw new AlreadyClosedException(getCloseReason(), cause);
}
        }
        
        _heartbeatSender.shutdown();
        _channel0.processShutdownSignal(sse, !initiatedByApplication, notifyRpc);
        return sse;
    }
    
    private void finishShutdown(ShutdownSignalException sse) {
        ChannelManager cm = _channelManager;
        if (cm != null) cm.handleSignal(sse);
    }
    
    public void close() throws IOException {
        close(-1);
    }
    
    public void close(int timeout) throws IOException {
        close(AMQP.REPLY_SUCCESS, "OK", timeout);
    }
    
    public void close(int closeCode, String closeMessage) throws IOException {
        close(closeCode, closeMessage, -1);
    }
    
    public void close(int closeCode, String closeMessage, int timeout) throws IOException {
        close(closeCode, closeMessage, true, null, timeout, false);
    }
    
    public void abort() {
        abort(-1);
    }
    
    public void abort(int closeCode, String closeMessage) {
       abort(closeCode, closeMessage, -1);
    }
    
    public void abort(int timeout) {
        abort(AMQP.REPLY_SUCCESS, "OK", timeout);
    }
    
    public void abort(int closeCode, String closeMessage, int timeout) {
        try {
            close(closeCode, closeMessage, true, null, timeout, true);
        }
         catch (IOException ignored) {
 
}
 
    }
    
    public void close(int closeCode, String closeMessage, boolean initiatedByApplication, Throwable cause) throws IOException {
        close(closeCode, closeMessage, initiatedByApplication, cause, -1, false);
    }
    
    public void close(int closeCode, String closeMessage, boolean initiatedByApplication, Throwable cause, int timeout, boolean abort) throws IOException {
        boolean sync = !(Thread.currentThread() == mainLoopThread);
        try {
            AMQP.Connection.Close reason = new AMQP.Connection.Close.Builder() .replyCode(closeCode) .replyText(closeMessage) .build();
            final ShutdownSignalException sse = startShutdown(reason, initiatedByApplication, cause, true);
            if(sync){
                BlockingRpcContinuation<AMQCommand> k = new BlockingRpcContinuation<AMQCommand>(){
                    public AMQCommand transformReply(AMQCommand command) {
                        AMQConnection.this.finishShutdown(sse);
                        return command;
                    }};
              _channel0.quiescingRpc(reason, k);
              k.getReply(timeout);
            }
             else {
              _channel0.quiescingTransmit(reason);
            }
            
        }
         catch (TimeoutException tte) {
            if (!abort) {
                ShutdownSignalException sse = new ShutdownSignalException(true, true, null, this);
                sse.initCause(cause);
                throw sse;
            }
            
        }
         catch (ShutdownSignalException sse) {
            if (!abort){
                throw sse;
}
        }
         catch (IOException ioe) {
            if (!abort){
                throw ioe;
}
        }
         finally {
            if(sync) _frameHandler.close();
        }
        
    }
    
 public String toString() {
        final String virtualHost = "/".equals(_virtualHost) ? _virtualHost : "/" + _virtualHost;
        return "amqp://" + this.credentialsProvider.getUsername() + "@" + getHostAddress() + ":" + getPort() + virtualHost;
    }
    
    private String getHostAddress() {
        return getAddress() == null ? null : getAddress().getHostAddress();
    }
    
    public void addBlockedListener(BlockedListener listener) {
        blockedListeners.add(listener);
    }
    
    public BlockedListener addBlockedListener(BlockedCallback blockedCallback, UnblockedCallback unblockedCallback) {
        BlockedListener blockedListener = new BlockedListener() { 

            public void handleBlocked(String reason) throws IOException {
                blockedCallback.handle(reason);
            }
            
            public void handleUnblocked() throws IOException {
                unblockedCallback.handle();
            }
            
        };
        this.addBlockedListener(blockedListener);
        return blockedListener;
    }
    
    public boolean removeBlockedListener(BlockedListener listener) {
        return blockedListeners.remove(listener);
    }
    
    public void clearBlockedListeners() {
        blockedListeners.clear();
    }
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public int getChannelRpcTimeout() {
        return channelRpcTimeout;
    }
    
    public boolean willCheckRpcResponseType() {
        return channelShouldCheckRpcResponseType;
    }
    
    public TrafficListener getTrafficListener() {
        return trafficListener;
    }
    
}


