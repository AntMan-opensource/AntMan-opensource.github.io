package com.rabbitmq.client.impl;
import com.rabbitmq.client.AMQP;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLSocket;
import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketException;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
public class SocketFrameHandler implements FrameHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(SocketFrameHandler.class);
    private final Socket _socket;
    private final ExecutorService _shutdownExecutor;
    private final DataInputStream _inputStream;
    private final DataOutputStream _outputStream;
    public static final int SOCKET_CLOSING_TIMEOUT = 1;
    public SocketFrameHandler(Socket socket) throws IOException {
        this(socket, null);
    }
    
    public SocketFrameHandler(Socket socket, ExecutorService shutdownExecutor) throws IOException {
        _socket = socket;
        _shutdownExecutor = shutdownExecutor;
        _inputStream = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
        _outputStream = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
    }
    
    public InetAddress getAddress() {
        return _socket.getInetAddress();
    }
    
    public InetAddress getLocalAddress() {
        return _socket.getLocalAddress();
    }
    
    public DataInputStream getInputStream() {
        return _inputStream;
    }
    
    public int getPort() {
        return _socket.getPort();
    }
    
    public int getLocalPort() {
        return _socket.getLocalPort();
    }
    
    public void setTimeout(int timeoutMs) throws SocketException {
        _socket.setSoTimeout(timeoutMs);
    }
    
    public int getTimeout() throws SocketException {
        return _socket.getSoTimeout();
    }
    
    public void sendHeader(int major, int minor) throws IOException {
        synchronized (_outputStream) {
            _outputStream.write("AMQP".getBytes("US-ASCII"));
            _outputStream.write(1);
            _outputStream.write(1);
            _outputStream.write(major);
            _outputStream.write(minor);
            try {
                _outputStream.flush();
            }
             catch (SSLHandshakeException e) {
                LOGGER.error("TLS connection failed: {}", e.getMessage());
                throw e;
            }
            
        }
        
    }
    
  public void sendHeader(int major, int minor, int revision) throws IOException {
        synchronized (_outputStream) {
            _outputStream.write("AMQP".getBytes("US-ASCII"));
            _outputStream.write(0);
            _outputStream.write(major);
            _outputStream.write(minor);
            _outputStream.write(revision);
            try {
                _outputStream.flush();
            }
             catch (SSLHandshakeException e) {
                LOGGER.error("TLS connection failed: {}", e.getMessage());
                throw e;
            }
            
        }
        
    }
    
    public void sendHeader() throws IOException {
        sendHeader(AMQP.PROTOCOL.MAJOR, AMQP.PROTOCOL.MINOR, AMQP.PROTOCOL.REVISION);
        if (this._socket instanceof SSLSocket) {
            TlsUtils.logPeerCertificateInfo(((SSLSocket) this._socket).getSession());
        }
        
    }
    
    public void initialize(AMQConnection connection) {
        connection.startMainLoop();
    }
    
    public Frame readFrame() throws IOException {
        synchronized (_inputStream) {
            return Frame.readFrom(_inputStream);
        }
        
    }
    
    public void writeFrame(Frame frame) throws IOException {
        synchronized (_outputStream) {
            frame.writeTo(_outputStream);
        }
        
    }
    
    public void flush() throws IOException {
        _outputStream.flush();
    }
    
    public void close() {
        try {
 _socket.setSoLinger(true, SOCKET_CLOSING_TIMEOUT); 
}
 catch (Exception _e) {}
        Callable<Void> flushCallable = new Callable<Void>() {
            public Void call() throws Exception {
                flush();
                return null;
            }
            
        };
        Future<Void> flushTask = null;
        try {
            if(this._shutdownExecutor == null) {
                flushCallable.call();
            }
             else {
                flushTask = this._shutdownExecutor.submit(flushCallable);
                flushTask.get(SOCKET_CLOSING_TIMEOUT, TimeUnit.SECONDS);
            }
            
        }
         catch(Exception e) {
            if(flushTask != null) {
                flushTask.cancel(true);
            }
            
        }
        
        try {
 _socket.close();                                   
}
 catch (Exception _e) {}
    }
    
}


