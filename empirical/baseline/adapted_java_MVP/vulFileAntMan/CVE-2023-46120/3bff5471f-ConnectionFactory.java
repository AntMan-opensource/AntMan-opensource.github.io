package com.rabbitmq.client;
import com.rabbitmq.client.impl.*;
import com.rabbitmq.client.impl.nio.NioParams;
import com.rabbitmq.client.impl.nio.SocketChannelFrameHandlerFactory;
import com.rabbitmq.client.impl.recovery.AutorecoveringConnection;
import com.rabbitmq.client.impl.recovery.RecoveredQueueNameSupplier;
import com.rabbitmq.client.impl.recovery.RetryHandler;
import com.rabbitmq.client.impl.recovery.TopologyRecoveryFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Map.Entry;
import java.util.function.BiConsumer;
import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Predicate;
import static java.util.concurrent.TimeUnit.MINUTES;
public class ConnectionFactory implements Cloneable {
    private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionFactory.class);
    private static final int MAX_UNSIGNED_SHORT = 65535;
    public static final String DEFAULT_USER = "guest";
    public static final String DEFAULT_PASS = "guest";
    public static final String DEFAULT_VHOST = "/";
    public static final int    DEFAULT_CHANNEL_MAX = 2047;
    public static final int    DEFAULT_FRAME_MAX = 0;
    public static final int    DEFAULT_HEARTBEAT = 60;
    public static final String DEFAULT_HOST = "localhost";
    public static final int    USE_DEFAULT_PORT = -1;
    public static final int    DEFAULT_AMQP_PORT = AMQP.PROTOCOL.PORT;
    public static final int    DEFAULT_AMQP_OVER_SSL_PORT = 5671;
    public static final int    DEFAULT_CONNECTION_TIMEOUT = 60000;
    public static final int    DEFAULT_HANDSHAKE_TIMEOUT = 10000;
    public static final int    DEFAULT_SHUTDOWN_TIMEOUT = 10000;
    public static final int    DEFAULT_CHANNEL_RPC_TIMEOUT = (int) MINUTES.toMillis(10);
    public static final long   DEFAULT_NETWORK_RECOVERY_INTERVAL = 5000;
    public static final int    DEFAULT_WORK_POOL_TIMEOUT = -1;
    private static final String PREFERRED_TLS_PROTOCOL = "TLSv1.2";
    private static final String FALLBACK_TLS_PROTOCOL = "TLSv1";
    private String virtualHost                    = DEFAULT_VHOST;
    private String host                           = DEFAULT_HOST;
    private int port                              = USE_DEFAULT_PORT;
    private int requestedChannelMax               = DEFAULT_CHANNEL_MAX;
    private int requestedFrameMax                 = DEFAULT_FRAME_MAX;
    private int requestedHeartbeat                = DEFAULT_HEARTBEAT;
    private int connectionTimeout                 = DEFAULT_CONNECTION_TIMEOUT;
    private int handshakeTimeout                  = DEFAULT_HANDSHAKE_TIMEOUT;
    private int shutdownTimeout                   = DEFAULT_SHUTDOWN_TIMEOUT;
    private Map<String, Object> _clientProperties = AMQConnection.defaultClientProperties();
    private SocketFactory socketFactory           = null;
    private SaslConfig saslConfig                 = DefaultSaslConfig.PLAIN;
    private ExecutorService sharedExecutor;
    private ThreadFactory threadFactory             = Executors.defaultThreadFactory();
    private ExecutorService shutdownExecutor;
    private ScheduledExecutorService heartbeatExecutor;
    private SocketConfigurator socketConf           = SocketConfigurators.defaultConfigurator();
    private ExceptionHandler exceptionHandler       = new DefaultExceptionHandler();
    private CredentialsProvider credentialsProvider = new DefaultCredentialsProvider(DEFAULT_USER, DEFAULT_PASS);
    private boolean automaticRecovery               = true;
    private boolean topologyRecovery                = true;
    private ExecutorService topologyRecoveryExecutor;
    private long networkRecoveryInterval          = DEFAULT_NETWORK_RECOVERY_INTERVAL;
    private RecoveryDelayHandler recoveryDelayHandler;
    private MetricsCollector metricsCollector;
    private boolean nio = false;
    private FrameHandlerFactory frameHandlerFactory;
    private NioParams nioParams = new NioParams();
    private SslContextFactory sslContextFactory;
    private int channelRpcTimeout = DEFAULT_CHANNEL_RPC_TIMEOUT;
    private boolean channelShouldCheckRpcResponseType = false;
    private ErrorOnWriteListener errorOnWriteListener;
    private int workPoolTimeout = DEFAULT_WORK_POOL_TIMEOUT;
    private TopologyRecoveryFilter topologyRecoveryFilter;
    private Predicate<ShutdownSignalException> connectionRecoveryTriggeringCondition;
    private RetryHandler topologyRecoveryRetryHandler;
    private RecoveredQueueNameSupplier recoveredQueueNameSupplier;
    private TrafficListener trafficListener = TrafficListener.NO_OP;
    private CredentialsRefreshService credentialsRefreshService;
    public String getHost() {
        return host;
    }
    
    public void setHost(String host) {
        this.host = host;
    }
    
    public static int portOrDefault(int port, boolean ssl) {
        if (port != USE_DEFAULT_PORT) return port;
        else if (ssl) return DEFAULT_AMQP_OVER_SSL_PORT;
        else return DEFAULT_AMQP_PORT;
    }
    
    public int getPort() {
        return portOrDefault(port, isSSL());
    }
    
    public void setPort(int port) {
        this.port = port;
    }
    
    public String getUsername() {
        return credentialsProvider.getUsername();
    }
    
    public void setUsername(String username) {
        this.credentialsProvider = new DefaultCredentialsProvider( username, this.credentialsProvider.getPassword() );
    }
    
    public String getPassword() {
        return credentialsProvider.getPassword();
    }
    
    public void setPassword(String password) {
        this.credentialsProvider = new DefaultCredentialsProvider( this.credentialsProvider.getUsername(), password );
    }
    
    public void setCredentialsProvider(CredentialsProvider credentialsProvider) {
        this.credentialsProvider = credentialsProvider;
    }
    
    public String getVirtualHost() {
        return this.virtualHost;
    }
    
    public void setVirtualHost(String virtualHost) {
        this.virtualHost = virtualHost;
    }
    
    public void setUri(URI uri) throws URISyntaxException, NoSuchAlgorithmException, KeyManagementException {
        if ("amqp".equals(uri.getScheme().toLowerCase())) {
        }
         else if ("amqps".equals(uri.getScheme().toLowerCase())) {
            setPort(DEFAULT_AMQP_OVER_SSL_PORT);
            if (this.sslContextFactory == null) {
                useSslProtocol();
            }
            
        }
         else {
            throw new IllegalArgumentException("Wrong scheme in AMQP URI: " + uri.getScheme());
        }
        
        String host = uri.getHost();
        if (host != null) {
            setHost(host);
        }
        
        int port = uri.getPort();
        if (port != -1) {
            setPort(port);
        }
        
        String userInfo = uri.getRawUserInfo();
        if (userInfo != null) {
            String userPass[] = userInfo.split(":");
            if (userPass.length > 2) {
                throw new IllegalArgumentException("Bad user info in AMQP " + "URI: " + userInfo);
            }
            
            setUsername(uriDecode(userPass[0]));
            if (userPass.length == 2) {
                setPassword(uriDecode(userPass[1]));
            }
            
        }
        
        String path = uri.getRawPath();
        if (path != null && path.length() > 0) {
            if (path.indexOf('/', 1) != -1) {
                throw new IllegalArgumentException("Multiple segments in " + "path of AMQP URI: " + path);
            }
            
            setVirtualHost(uriDecode(uri.getPath().substring(1)));
        }
        
        String rawQuery = uri.getRawQuery();
        if (rawQuery != null && rawQuery.length() > 0) {
            setQuery(rawQuery);
        }
        
    }
    
    public void setUri(String uriString) throws URISyntaxException, NoSuchAlgorithmException, KeyManagementException {
        setUri(new URI(uriString));
    }
    
    private static String uriDecode(String s) {
        try {
            return URLDecoder.decode(s.replace("+", "%2B"), "US-ASCII");
        }
        
        catch (IOException e) {
            throw new RuntimeException(e);
        }
        
    }
    
  private static final Map<String, BiConsumer<String, ConnectionFactory>> URI_QUERY_PARAMETER_HANDLERS = new HashMap<String, BiConsumer<String, ConnectionFactory>>() {         { put("heartbeat", (value, cf) -> { try { int heartbeatInt = Integer.parseInt(value);
                    cf.setRequestedHeartbeat(heartbeatInt);
                }
                 catch (NumberFormatException e) {
                    throw new IllegalArgumentException("Requested heartbeat must an integer");
                }
                
            }
            
);
            put("connection_timeout", (value, cf) -> {
              try {
                int connectionTimeoutInt = Integer.parseInt(value);
                cf.setConnectionTimeout(connectionTimeoutInt);
              }
               catch (NumberFormatException e) {
                throw new IllegalArgumentException("TCP connection timeout must an integer");
              }
              
            }
            
);
            put("channel_max", (value, cf) -> {
                try {
                    int channelMaxInt = Integer.parseInt(value);
                    cf.setRequestedChannelMax(channelMaxInt);
                }
                 catch (NumberFormatException e) {
                    throw new IllegalArgumentException("Requested channel max must an integer");
                }
                
            }
            
);
        }
        
      };
    private void setQuery(String rawQuery) {
        Map<String, String> parameters = new HashMap<>();
        try {
            for (String param : rawQuery.split("&")) {
                String[] pair = param.split("=");
                String key = URLDecoder.decode(pair[0], "US-ASCII");
                String value = null;
                if (pair.length > 1) {
                    value = URLDecoder.decode(pair[1], "US-ASCII");
                }
                
                parameters.put(key, value);
            }
            
        }
         catch (IOException e) {
            throw new IllegalArgumentException("Cannot parse the query parameters", e);
        }
        
        for (Entry<String, String> entry : parameters.entrySet()) {
            BiConsumer<String, ConnectionFactory> handler = URI_QUERY_PARAMETER_HANDLERS .get(entry.getKey());
            if (handler != null) {
                handler.accept(entry.getValue(), this);
            }
             else {
                processUriQueryParameter(entry.getKey(), entry.getValue());
            }
            
        }
        
    }
    
    protected void processUriQueryParameter(String key, String value) {
    }
    
    public int getRequestedChannelMax() {
        return this.requestedChannelMax;
    }
    
    public void setRequestedChannelMax(int requestedChannelMax) {
        this.requestedChannelMax = ensureUnsignedShort(requestedChannelMax);
        if (this.requestedChannelMax != requestedChannelMax) {
            LOGGER.warn("Requested channel max must be between 0 and {}, value has been set to {} instead of {}", MAX_UNSIGNED_SHORT, this.requestedChannelMax, requestedChannelMax);
        }
        
    }
    
    public int getRequestedFrameMax() {
        return this.requestedFrameMax;
    }
    
    public void setRequestedFrameMax(int requestedFrameMax) {
        this.requestedFrameMax = requestedFrameMax;
    }
    
    public int getRequestedHeartbeat() {
        return this.requestedHeartbeat;
    }
    
    public void setConnectionTimeout(int timeout) {
        if(timeout < 0) {
            throw new IllegalArgumentException("TCP connection timeout cannot be negative");
        }
        
        this.connectionTimeout = timeout;
    }
    
    public int getConnectionTimeout() {
        return this.connectionTimeout;
    }
    
    public int getHandshakeTimeout() {
        return handshakeTimeout;
    }
    
    public void setHandshakeTimeout(int timeout) {
        if(timeout < 0) {
            throw new IllegalArgumentException("handshake timeout cannot be negative");
        }
        
        this.handshakeTimeout = timeout;
    }
    
    public void setShutdownTimeout(int shutdownTimeout) {
        this.shutdownTimeout = shutdownTimeout;
    }
    
    public int getShutdownTimeout() {
        return shutdownTimeout;
    }
    
    public void setRequestedHeartbeat(int requestedHeartbeat) {
        this.requestedHeartbeat = ensureUnsignedShort(requestedHeartbeat);
        if (this.requestedHeartbeat != requestedHeartbeat) {
            LOGGER.warn("Requested heartbeat must be between 0 and {}, value has been set to {} instead of {}", MAX_UNSIGNED_SHORT, this.requestedHeartbeat, requestedHeartbeat);
        }
        
    }
    
    public Map<String, Object> getClientProperties() {
        return _clientProperties;
    }
    
    public void setClientProperties(Map<String, Object> clientProperties) {
        _clientProperties = clientProperties;
    }
    
    public SaslConfig getSaslConfig() {
        return saslConfig;
    }
    
    public void setSaslConfig(SaslConfig saslConfig) {
        this.saslConfig = saslConfig;
    }
    
    public SocketFactory getSocketFactory() {
        return this.socketFactory;
    }
    
    public void setSocketFactory(SocketFactory factory) {
        this.socketFactory = factory;
    }
    
    public SocketConfigurator getSocketConfigurator() {
        return socketConf;
    }
    
    public void setSocketConfigurator(SocketConfigurator socketConfigurator) {
        this.socketConf = socketConfigurator;
    }
    
    public void setSharedExecutor(ExecutorService executor) {
        this.sharedExecutor = executor;
    }
    
    public void setShutdownExecutor(ExecutorService executor) {
        this.shutdownExecutor = executor;
    }
    
    public void setHeartbeatExecutor(ScheduledExecutorService executor) {
        this.heartbeatExecutor = executor;
    }
    
    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }
    
    public void setThreadFactory(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
    }
    
    public ExceptionHandler getExceptionHandler() {
        return exceptionHandler;
    }
    
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        if (exceptionHandler == null) {
          throw new IllegalArgumentException("exception handler cannot be null!");
        }
        
        this.exceptionHandler = exceptionHandler;
    }
    
    public boolean isSSL(){
        return getSocketFactory() instanceof SSLSocketFactory || sslContextFactory != null;
    }
    
    public void useSslProtocol() throws NoSuchAlgorithmException, KeyManagementException {
        useSslProtocol(computeDefaultTlsProtocol(SSLContext.getDefault().getSupportedSSLParameters().getProtocols()));
    }
    
    public void useSslProtocol(String protocol) throws NoSuchAlgorithmException, KeyManagementException {
        useSslProtocol(protocol, new TrustEverythingTrustManager());
    }
    
    public void useSslProtocol(String protocol, TrustManager trustManager) throws NoSuchAlgorithmException, KeyManagementException {
        SSLContext c = SSLContext.getInstance(protocol);
        c.init(null, new TrustManager[] { trustManager }, null);
        useSslProtocol(c);
    }
    
    public void useSslProtocol(SSLContext context) {
        this.sslContextFactory = name -> context;
        setSocketFactory(context.getSocketFactory());
    }
    
    public void enableHostnameVerification() {
        enableHostnameVerificationForNio();
        enableHostnameVerificationForBlockingIo();
    }
    
    protected void enableHostnameVerificationForNio() {
        if (this.nioParams == null) {
            this.nioParams = new NioParams();
        }
        
        this.nioParams = this.nioParams.enableHostnameVerification();
    }
    
    protected void enableHostnameVerificationForBlockingIo() {
        if (this.socketConf == null) {
            this.socketConf = SocketConfigurators.builder().defaultConfigurator().enableHostnameVerification().build();
        }
         else {
            this.socketConf = this.socketConf.andThen(SocketConfigurators.enableHostnameVerification());
        }
        
    }
    
    public static String computeDefaultTlsProtocol(String[] supportedProtocols) {
        if(supportedProtocols != null) {
            for (String supportedProtocol : supportedProtocols) {
                if(PREFERRED_TLS_PROTOCOL.equalsIgnoreCase(supportedProtocol)) {
                    return supportedProtocol;
                }
                
            }
            
        }
        
        return FALLBACK_TLS_PROTOCOL;
    }
    
    public boolean isAutomaticRecoveryEnabled() {
        return automaticRecovery;
    }
    
    public void setAutomaticRecoveryEnabled(boolean automaticRecovery) {
        this.automaticRecovery = automaticRecovery;
    }
    
    public boolean isTopologyRecoveryEnabled() {
        return topologyRecovery;
    }
    
    public void setTopologyRecoveryEnabled(boolean topologyRecovery) {
        this.topologyRecovery = topologyRecovery;
    }
    
    public ExecutorService getTopologyRecoveryExecutor() {
        return topologyRecoveryExecutor;
    }
    
    public void setTopologyRecoveryExecutor(final ExecutorService topologyRecoveryExecutor) {
        this.topologyRecoveryExecutor = topologyRecoveryExecutor;
    }
    
    public void setMetricsCollector(MetricsCollector metricsCollector) {
        this.metricsCollector = metricsCollector;
    }
    
    public MetricsCollector getMetricsCollector() {
        return metricsCollector;
    }
    
    public void setCredentialsRefreshService(CredentialsRefreshService credentialsRefreshService) {
        this.credentialsRefreshService = credentialsRefreshService;
    }
    
    protected synchronized FrameHandlerFactory createFrameHandlerFactory() throws IOException {
        if(nio) {
            if(this.frameHandlerFactory == null) {
                if(this.nioParams.getNioExecutor() == null && this.nioParams.getThreadFactory() == null) {
                    this.nioParams.setThreadFactory(getThreadFactory());
                }
                
                this.frameHandlerFactory = new SocketChannelFrameHandlerFactory(connectionTimeout, nioParams, isSSL(), sslContextFactory);
            }
            
            return this.frameHandlerFactory;
        }
         else {
            return new SocketFrameHandlerFactory(connectionTimeout, socketFactory, socketConf, isSSL(), this.shutdownExecutor, sslContextFactory);
        }
        
    }
    
    public Connection newConnection(Address[] addrs) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Arrays.asList(addrs), null);
    }
    
    public Connection newConnection(AddressResolver addressResolver) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addressResolver, null);
    }
    
    public Connection newConnection(Address[] addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Arrays.asList(addrs), clientProvidedName);
    }
    
    public Connection newConnection(List<Address> addrs) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addrs, null);
    }
    
    public Connection newConnection(List<Address> addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addrs, clientProvidedName);
    }
    
    public Connection newConnection(ExecutorService executor, Address[] addrs) throws IOException, TimeoutException {
        return newConnection(executor, Arrays.asList(addrs), null);
    }
    
    public Connection newConnection(ExecutorService executor, Address[] addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(executor, Arrays.asList(addrs), clientProvidedName);
    }
    
    public Connection newConnection(ExecutorService executor, List<Address> addrs) throws IOException, TimeoutException {
        return newConnection(executor, addrs, null);
    }
    
    public Connection newConnection(ExecutorService executor, AddressResolver addressResolver) throws IOException, TimeoutException {
        return newConnection(executor, addressResolver, null);
    }
    
    public Connection newConnection(ExecutorService executor, List<Address> addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(executor, createAddressResolver(addrs), clientProvidedName);
    }
    
    public Connection newConnection(ExecutorService executor, AddressResolver addressResolver, String clientProvidedName) throws IOException, TimeoutException {
        if(this.metricsCollector == null) {
            this.metricsCollector = new NoOpMetricsCollector();
        }
        
        FrameHandlerFactory fhFactory = createFrameHandlerFactory();
        ConnectionParams params = params(executor);
        if (clientProvidedName != null) {
            Map<String, Object> properties = new HashMap<String, Object>(params.getClientProperties());
            properties.put("connection_name", clientProvidedName);
            params.setClientProperties(properties);
        }
        
        if (isAutomaticRecoveryEnabled()) {
            AutorecoveringConnection conn = new AutorecoveringConnection(params, fhFactory, addressResolver, metricsCollector); 
            conn.init();
            return conn;
        }
         else {
            List<Address> addrs = addressResolver.getAddresses();
            Exception lastException = null;
            for (Address addr : addrs) {
                try {
                    FrameHandler handler = fhFactory.create(addr, clientProvidedName);
                    AMQConnection conn = createConnection(params, handler, metricsCollector);
                    conn.start();
                    this.metricsCollector.newConnection(conn);
                    return conn;
                }
                 catch (IOException e) {
                    lastException = e;
                }
                 catch (TimeoutException te) {
                    lastException = te;
                }
                
            }
            
            if (lastException != null) {
                if (lastException instanceof IOException) {
                    throw (IOException) lastException;
                }
                 else if (lastException instanceof TimeoutException) {
                    throw (TimeoutException) lastException;
                }
                
            }
            
            throw new IOException("failed to connect");
        }
        
    }
    
    public ConnectionParams params(ExecutorService consumerWorkServiceExecutor) {
        ConnectionParams result = new ConnectionParams();
        result.setCredentialsProvider(credentialsProvider);
        result.setConsumerWorkServiceExecutor(consumerWorkServiceExecutor);
        result.setVirtualHost(virtualHost);
        result.setClientProperties(getClientProperties());
        result.setRequestedFrameMax(requestedFrameMax);
        result.setRequestedChannelMax(requestedChannelMax);
        result.setShutdownTimeout(shutdownTimeout);
        result.setSaslConfig(saslConfig);
        result.setNetworkRecoveryInterval(networkRecoveryInterval);
        result.setRecoveryDelayHandler(recoveryDelayHandler);
        result.setTopologyRecovery(topologyRecovery);
        result.setTopologyRecoveryExecutor(topologyRecoveryExecutor);
        result.setExceptionHandler(exceptionHandler);
        result.setThreadFactory(threadFactory);
        result.setHandshakeTimeout(handshakeTimeout);
        result.setRequestedHeartbeat(requestedHeartbeat);
        result.setShutdownExecutor(shutdownExecutor);
        result.setHeartbeatExecutor(heartbeatExecutor);
        result.setChannelRpcTimeout(channelRpcTimeout);
        result.setChannelShouldCheckRpcResponseType(channelShouldCheckRpcResponseType);
        result.setWorkPoolTimeout(workPoolTimeout);
        result.setErrorOnWriteListener(errorOnWriteListener);
        result.setTopologyRecoveryFilter(topologyRecoveryFilter);
        result.setConnectionRecoveryTriggeringCondition(connectionRecoveryTriggeringCondition);
        result.setTopologyRecoveryRetryHandler(topologyRecoveryRetryHandler);
        result.setRecoveredQueueNameSupplier(recoveredQueueNameSupplier);
        result.setTrafficListener(trafficListener);
        result.setCredentialsRefreshService(credentialsRefreshService);
        return result;
    }
    
    protected AMQConnection createConnection(ConnectionParams params, FrameHandler frameHandler, MetricsCollector metricsCollector) {
        return new AMQConnection(params, frameHandler, metricsCollector);
    }
    
    public Connection newConnection() throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())));
    }
    
    public Connection newConnection(String connectionName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())), connectionName);
    }
    
    public Connection newConnection(ExecutorService executor) throws IOException, TimeoutException {
        return newConnection(executor, Collections.singletonList(new Address(getHost(), getPort())));
    }
    
    public Connection newConnection(ExecutorService executor, String connectionName) throws IOException, TimeoutException {
        return newConnection(executor, Collections.singletonList(new Address(getHost(), getPort())), connectionName);
    }
    
    protected AddressResolver createAddressResolver(List<Address> addresses) {
        if (addresses.size() > 1) {
            return new ListAddressResolver(addresses);
        }
         else {
            return new DnsRecordIpAddressResolver(addresses.get(0), isSSL());
        }
        
    }
    
 public ConnectionFactory clone(){
        try {
            ConnectionFactory clone = (ConnectionFactory)super.clone();
            return clone;
        }
         catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        
    }
    
    public ConnectionFactory load(String propertyFileLocation) throws IOException {
        ConnectionFactoryConfigurator.load(this, propertyFileLocation);
        return this;
    }
    
    public ConnectionFactory load(String propertyFileLocation, String prefix) throws IOException {
        ConnectionFactoryConfigurator.load(this, propertyFileLocation, prefix);
        return this;
    }
    
    public ConnectionFactory load(Properties properties) {
        ConnectionFactoryConfigurator.load(this, properties);
        return this;
    }
    
    public ConnectionFactory load(Properties properties, String prefix) {
        ConnectionFactoryConfigurator.load(this, (Map) properties, prefix);
        return this;
    }
    
    public ConnectionFactory load(Map<String, String> properties) {
        ConnectionFactoryConfigurator.load(this, properties);
        return this;
    }
    
    public ConnectionFactory load(Map<String, String> properties, String prefix) {
        ConnectionFactoryConfigurator.load(this, properties, prefix);
        return this;
    }
    
    public long getNetworkRecoveryInterval() {
        return networkRecoveryInterval;
    }
    
    public void setNetworkRecoveryInterval(int networkRecoveryInterval) {
        this.networkRecoveryInterval = networkRecoveryInterval;
    }
    
    public void setNetworkRecoveryInterval(long networkRecoveryInterval) {
        this.networkRecoveryInterval = networkRecoveryInterval;
    }
    
    public RecoveryDelayHandler getRecoveryDelayHandler() {
        return recoveryDelayHandler;
    }
    
    public void setRecoveryDelayHandler(final RecoveryDelayHandler recoveryDelayHandler) {
        this.recoveryDelayHandler = recoveryDelayHandler;
    }
    
    public void setNioParams(NioParams nioParams) {
        this.nioParams = nioParams;
    }
    
    public NioParams getNioParams() {
        return nioParams;
    }
    
    public void useNio() {
        this.nio = true;
    }
    
    public void useBlockingIo() {
        this.nio = false;
    }
    
    public void setChannelRpcTimeout(int channelRpcTimeout) {
        if(channelRpcTimeout < 0) {
            throw new IllegalArgumentException("Timeout cannot be less than 0");
        }
        
        this.channelRpcTimeout = channelRpcTimeout;
    }
    
    public int getChannelRpcTimeout() {
        return channelRpcTimeout;
    }
    
    public void setSslContextFactory(SslContextFactory sslContextFactory) {
        this.sslContextFactory = sslContextFactory;
    }
    
    public void setChannelShouldCheckRpcResponseType(boolean channelShouldCheckRpcResponseType) {
        this.channelShouldCheckRpcResponseType = channelShouldCheckRpcResponseType;
    }
    
    public boolean isChannelShouldCheckRpcResponseType() {
        return channelShouldCheckRpcResponseType;
    }
    
    public void setWorkPoolTimeout(int workPoolTimeout) {
        this.workPoolTimeout = workPoolTimeout;
    }
    
    public int getWorkPoolTimeout() {
        return workPoolTimeout;
    }
    
    public void setErrorOnWriteListener(ErrorOnWriteListener errorOnWriteListener) {
        this.errorOnWriteListener = errorOnWriteListener;
    }
    
    public void setTopologyRecoveryFilter(TopologyRecoveryFilter topologyRecoveryFilter) {
        this.topologyRecoveryFilter = topologyRecoveryFilter;
    }
    
    public void setConnectionRecoveryTriggeringCondition(Predicate<ShutdownSignalException> connectionRecoveryTriggeringCondition) {
        this.connectionRecoveryTriggeringCondition = connectionRecoveryTriggeringCondition;
    }
    
    public void setTopologyRecoveryRetryHandler(RetryHandler topologyRecoveryRetryHandler) {
        this.topologyRecoveryRetryHandler = topologyRecoveryRetryHandler;
    }
    
    public void setRecoveredQueueNameSupplier(RecoveredQueueNameSupplier recoveredQueueNameSupplier) {
        this.recoveredQueueNameSupplier = recoveredQueueNameSupplier;
    }
    
    public void setTrafficListener(TrafficListener trafficListener) {
        this.trafficListener = trafficListener;
    }
    
    public static int ensureUnsignedShort(int value) {
        if (value < 0) {
            return 0;
        }
         else if (value > MAX_UNSIGNED_SHORT) {
            return MAX_UNSIGNED_SHORT;
        }
         else {
            return value;
        }
        
    }
    
}


