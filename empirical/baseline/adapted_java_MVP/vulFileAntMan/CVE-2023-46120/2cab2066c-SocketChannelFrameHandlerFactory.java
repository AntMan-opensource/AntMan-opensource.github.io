package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.Address;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.SslContextFactory;
import com.rabbitmq.client.impl.AbstractFrameHandlerFactory;
import com.rabbitmq.client.impl.FrameHandler;
import com.rabbitmq.client.impl.TlsUtils;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class SocketChannelFrameHandlerFactory extends AbstractFrameHandlerFactory {
    private static final Logger LOGGER = LoggerFactory.getLogger(SocketChannelFrameHandler.class);
    final NioParams nioParams;
    private final SslContextFactory sslContextFactory;
    private final Lock stateLock = new ReentrantLock();
    private final AtomicLong globalConnectionCount = new AtomicLong();
    private final List<NioLoopContext> nioLoopContexts;
    public SocketChannelFrameHandlerFactory(int connectionTimeout, NioParams nioParams, boolean ssl, SslContextFactory sslContextFactory) {
        super(connectionTimeout, null, ssl);
        this.nioParams = new NioParams(nioParams);
        this.sslContextFactory = sslContextFactory;
        this.nioLoopContexts = new ArrayList<>(this.nioParams.getNbIoThreads());
        for (int i = 0; i < this.nioParams.getNbIoThreads(); i++) {
            this.nioLoopContexts.add(new NioLoopContext(this, this.nioParams));
        }
        
    }
    
    public FrameHandler create(Address addr, String connectionName) throws IOException {
        int portNumber = ConnectionFactory.portOrDefault(addr.getPort(), ssl);
        SSLEngine sslEngine = null;
        SocketChannel channel = null;
        try {
            if (ssl) {
                SSLContext sslContext = sslContextFactory.create(connectionName);
                sslEngine = sslContext.createSSLEngine(addr.getHost(), portNumber);
                sslEngine.setUseClientMode(true);
                if (nioParams.getSslEngineConfigurator() != null) {
                    nioParams.getSslEngineConfigurator().configure(sslEngine);
                }
                
            }
            
            SocketAddress address = addr.toInetSocketAddress(portNumber);
            channel = SocketChannel.open(); 
            channel.configureBlocking(true);
            if(nioParams.getSocketChannelConfigurator() != null) {
                nioParams.getSocketChannelConfigurator().configure(channel);
            }
            
            channel.socket().connect(address, this.connectionTimeout);
            if (ssl) {
                int initialSoTimeout = channel.socket().getSoTimeout();
                channel.socket().setSoTimeout(this.connectionTimeout);
                sslEngine.beginHandshake();
                try {
                    ReadableByteChannel wrappedReadChannel = Channels.newChannel( channel.socket().getInputStream());
                    WritableByteChannel wrappedWriteChannel = Channels.newChannel( channel.socket().getOutputStream());
                    boolean handshake = SslEngineHelper.doHandshake( wrappedWriteChannel, wrappedReadChannel, sslEngine);
                    if (!handshake) {
                        LOGGER.error("TLS connection failed");
                        throw new SSLException("TLS handshake failed");
                    }
                    
                    channel.socket().setSoTimeout(initialSoTimeout);
                }
                 catch (SSLHandshakeException e) {
                    LOGGER.error("TLS connection failed: {}", e.getMessage());
                    throw e;
                }
                
                TlsUtils.logPeerCertificateInfo(sslEngine.getSession());
            }
            
            channel.configureBlocking(false);
            stateLock.lock();
            NioLoopContext nioLoopContext = null;
            try {
                long modulo = globalConnectionCount.getAndIncrement() % nioParams.getNbIoThreads();
                nioLoopContext = nioLoopContexts.get((int) modulo);
                nioLoopContext.initStateIfNecessary();
                SocketChannelFrameHandlerState state = new SocketChannelFrameHandlerState( channel, nioLoopContext, nioParams, sslEngine );
                state.startReading();
                SocketChannelFrameHandler frameHandler = new SocketChannelFrameHandler(state);
                return frameHandler;
            }
             finally {
                stateLock.unlock();
            }
            
        }
         catch(IOException e) {
            try {
                if(sslEngine != null && channel != null) {
                    SslEngineHelper.close(channel, sslEngine);
                }
                
                if (channel != null) {
                    channel.close();
                }
                
            }
             catch(IOException closingException) {
            }
            
            throw e;
        }
        
    }
    
    void lock() {
        stateLock.lock();
    }
    
    void unlock() {
        stateLock.unlock();
    }
    
}


