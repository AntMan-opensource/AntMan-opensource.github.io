package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.MalformedFrameException;
import com.rabbitmq.client.impl.Frame;
import java.io.DataInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
public class FrameBuilder {
    private static final int PAYLOAD_OFFSET = 1  + 2  + 4 ;
    protected final ReadableByteChannel channel;
    protected final ByteBuffer applicationBuffer;
    private final int[] frameBuffer = new int[3];
    private int frameType;
    private int frameChannel;
    private byte[] framePayload;
    private int bytesRead = 0;
    public FrameBuilder(ReadableByteChannel channel, ByteBuffer buffer) {
        this.channel = channel;
        this.applicationBuffer = buffer;
    }
    
    public Frame readFrame() throws IOException {
        while (somethingToRead()) {
            if (bytesRead == 0) {
                frameType = readFromBuffer();
                if (frameType == 'A') {
                    handleProtocolVersionMismatch();
                }
                
            }
             else if (bytesRead == 1) {
                frameBuffer[0] = readFromBuffer();
            }
             else if (bytesRead == 2) {
                frameChannel = (frameBuffer[0] << 8) + readFromBuffer();
            }
             else if (bytesRead == 3) {
                frameBuffer[0] = readFromBuffer();
            }
             else if (bytesRead == 4) {
                frameBuffer[1] = readFromBuffer();
            }
             else if (bytesRead == 5) {
                frameBuffer[2] = readFromBuffer();
            }
             else if (bytesRead == 6) {
                int framePayloadSize = (frameBuffer[0] << 24) + (frameBuffer[1] << 16) + (frameBuffer[2] << 8) + readFromBuffer();
                framePayload = new byte[framePayloadSize];
            }
             else if (bytesRead >= PAYLOAD_OFFSET && bytesRead < framePayload.length + PAYLOAD_OFFSET) {
                framePayload[bytesRead - PAYLOAD_OFFSET] = (byte) readFromBuffer();
            }
             else if (bytesRead == framePayload.length + PAYLOAD_OFFSET) {
                int frameEndMarker = readFromBuffer();
                if (frameEndMarker != AMQP.FRAME_END) {
                    throw new MalformedFrameException("Bad frame end marker: " + frameEndMarker);
                }
                
                bytesRead = 0;
                return new Frame(frameType, frameChannel, framePayload);
            }
             else {
                throw new IllegalStateException("Number of read bytes incorrect: " + bytesRead);
            }
            
            bytesRead++;
        }
        
        return null;
    }
    
    protected boolean somethingToRead() throws IOException {
        if (!applicationBuffer.hasRemaining()) {
            applicationBuffer.clear();
            int read = NioHelper.read(channel, applicationBuffer);
            applicationBuffer.flip();
            if (read > 0) {
                return true;
            }
             else {
                return false;
            }
            
        }
         else {
            return true;
        }
        
    }
    
    private int readFromBuffer() {
        return applicationBuffer.get() & 0xff;
    }
    
    private void handleProtocolVersionMismatch() throws IOException {
        byte[] expectedBytes = new byte[] { 'M', 'Q', 'P' };
        int expectedBytesCount = 0;
        while (somethingToRead() && expectedBytesCount < 3) {
            int nextByte = readFromBuffer();
            if (nextByte != expectedBytes[expectedBytesCount]) {
                throw new MalformedFrameException("Invalid AMQP protocol header from server: expected character " + expectedBytes[expectedBytesCount] + ", got " + nextByte);
            }
            
            expectedBytesCount++;
        }
        
        if (expectedBytesCount != 3) {
            throw new MalformedFrameException("Invalid AMQP protocol header from server: read only " + (expectedBytesCount + 1) + " byte(s) instead of 4");
        }
        
        int[] signature = new int[4];
        for (int i = 0; i < 4; i++) {
            if (somethingToRead()) {
                signature[i] = readFromBuffer();
            }
             else {
                throw new MalformedFrameException("Invalid AMQP protocol header from server");
            }
            
        }
        
        MalformedFrameException x;
        if (signature[0] == 1 && signature[1] == 1 && signature[2] == 8 && signature[3] == 0) {
            x = new MalformedFrameException("AMQP protocol version mismatch; we are version " + AMQP.PROTOCOL.MAJOR + "-" + AMQP.PROTOCOL.MINOR + "-" + AMQP.PROTOCOL.REVISION + ", server is 0-8");
        }
         else {
            String sig = "";
            for (int i = 0; i < 4; i++) {
                if (i != 0){
                    sig += ",";
}
                sig += signature[i];
            }
            
            x = new MalformedFrameException("AMQP protocol version mismatch; we are version " + AMQP.PROTOCOL.MAJOR + "-" + AMQP.PROTOCOL.MINOR + "-" + AMQP.PROTOCOL.REVISION + ", server sent signature " + sig);
        }
        
        throw x;
    }
    
    public boolean isUnderflowHandlingEnabled() {
        return false;
    }
    
}


