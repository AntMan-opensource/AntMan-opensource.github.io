package com.rabbitmq.client.impl;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Command;
public class AMQCommand implements Command {
    public static final int EMPTY_FRAME_SIZE = 8;
    private final CommandAssembler assembler;
    public AMQCommand() {
        this(null, null, null);
    }
    
    public AMQCommand(com.rabbitmq.client.Method method) {
        this(method, null, null);
    }
    
    public AMQCommand(com.rabbitmq.client.Method method, AMQContentHeader contentHeader, byte[] body) {
        this.assembler = new CommandAssembler((Method) method, contentHeader, body);
    }
    
    public Method getMethod() {
        return this.assembler.getMethod();
    }
    
    public AMQContentHeader getContentHeader() {
        return this.assembler.getContentHeader();
    }
    
    public byte[] getContentBody() {
        return this.assembler.getContentBody();
    }
    
    public boolean handleFrame(Frame f) throws IOException {
        return this.assembler.handleFrame(f);
    }
    
    public void transmit(AMQChannel channel) throws IOException {
        int channelNumber = channel.getChannelNumber();
        AMQConnection connection = channel.getConnection();
        synchronized (assembler) {
            Method m = this.assembler.getMethod();
            if (m.hasContent()) {
                byte[] body = this.assembler.getContentBody();
                Frame headerFrame = this.assembler.getContentHeader().toFrame(channelNumber, body.length);
                int frameMax = connection.getFrameMax();
                boolean cappedFrameMax = frameMax > 0;
                int bodyPayloadMax = cappedFrameMax ? frameMax - EMPTY_FRAME_SIZE : body.length;
                if (cappedFrameMax && headerFrame.size() > frameMax) {
                    String msg = String.format("Content headers exceeded max frame size: %d > %d", headerFrame.size(), frameMax);
                    throw new IllegalArgumentException(msg);
                }
                
                connection.writeFrame(m.toFrame(channelNumber));
                connection.writeFrame(headerFrame);
                for (int offset = 0; offset < body.length; offset += bodyPayloadMax) {
                    int remaining = body.length - offset;
                    int fragmentLength = (remaining < bodyPayloadMax) ? remaining : bodyPayloadMax;
                    Frame frame = Frame.fromBodyFragment(channelNumber, body, offset, fragmentLength);
                    connection.writeFrame(frame);
                }
                
            }
             else {
                connection.writeFrame(m.toFrame(channelNumber));
            }
            
        }
        
        connection.flush();
    }
    
 public String toString() {
        return toString(false);
    }
    
    public String toString(boolean suppressBody){
        synchronized (assembler) {
            return new StringBuilder() .append('{') .append(this.assembler.getMethod()) .append(", ") .append(this.assembler.getContentHeader()) .append(", ") .append(contentBodyStringBuilder( this.assembler.getContentBody(), suppressBody)) .append('}').toString();
        }
        
    }
    
    private static StringBuilder contentBodyStringBuilder(byte[] body, boolean suppressBody) {
        try {
            if (suppressBody) {
                return new StringBuilder().append(body.length).append(" bytes of payload");
            }
             else {
                return new StringBuilder().append('\"').append(new String(body, "UTF-8")).append('\"');
            }
            
        }
         catch (Exception e) {
            return new StringBuilder().append('|').append(body.length).append('|');
        }
        
    }
    
    public static void checkPreconditions() {
        checkEmptyFrameSize();
    }
    
    private static void checkEmptyFrameSize() {
        Frame f = new Frame(AMQP.FRAME_BODY, 0, new byte[0]);
        ByteArrayOutputStream s = new ByteArrayOutputStream();
        try {
            f.writeTo(new DataOutputStream(s));
        }
         catch (IOException ioe) {
            throw new IllegalStateException("IOException while checking EMPTY_FRAME_SIZE");
        }
        
        int actualLength = s.toByteArray().length;
        if (EMPTY_FRAME_SIZE != actualLength) {
            throw new IllegalStateException("Internal error: expected EMPTY_FRAME_SIZE(" + EMPTY_FRAME_SIZE + ") is not equal to computed value: " + actualLength);
        }
        
    }
    
}


