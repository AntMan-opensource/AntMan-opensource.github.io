package com.rabbitmq.client.impl;
import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.LongString;
import com.rabbitmq.client.MalformedFrameException;
import java.io.*;
import java.math.BigDecimal;
import java.net.SocketTimeoutException;
import java.util.Date;
import java.util.List;
import java.util.Map;
public class Frame {
    public final int type;
    public final int channel;
    private final byte[] payload;
    private final ByteArrayOutputStream accumulator;
    private static final int NON_BODY_SIZE = 1  + 2  + 4  + 1 ;
    public Frame(int type, int channel) {
        this.type = type;
        this.channel = channel;
        this.payload = null;
        this.accumulator = new ByteArrayOutputStream();
    }
    
    public Frame(int type, int channel, byte[] payload) {
        this.type = type;
        this.channel = channel;
        this.payload = payload;
        this.accumulator = null;
    }
    
    public static Frame fromBodyFragment(int channelNumber, byte[] body, int offset, int length) throws IOException {
        Frame frame = new Frame(AMQP.FRAME_BODY, channelNumber);
        DataOutputStream bodyOut = frame.getOutputStream();
        bodyOut.write(body, offset, length);
        return frame;
    }
    
    public static Frame readFrom(DataInputStream is) throws IOException {
        int type;
        int channel;
        try {
            type = is.readUnsignedByte();
        }
         catch (SocketTimeoutException ste) {
            return null; 
        }
        
        if (type == 'A') {
            protocolVersionMismatch(is);
        }
        
        channel = is.readUnsignedShort();
        int payloadSize = is.readInt();
        byte[] payload = new byte[payloadSize];
        is.readFully(payload);
        int frameEndMarker = is.readUnsignedByte();
        if (frameEndMarker != AMQP.FRAME_END) {
            throw new MalformedFrameException("Bad frame end marker: " + frameEndMarker);
        }
        
        return new Frame(type, channel, payload);
    }
    
    public static void protocolVersionMismatch(DataInputStream is) throws IOException {
        MalformedFrameException x;
        byte[] expectedBytes = new byte[] { 'M', 'Q', 'P' };
        for (byte expectedByte : expectedBytes) {
            int nextByte = is.readUnsignedByte();
            if (nextByte != expectedByte) {
                throw new MalformedFrameException("Invalid AMQP protocol header from server: expected character " + expectedByte + ", got " + nextByte);
            }
            
        }
        
        try {
            int[] signature = new int[4];
            for (int i = 0; i < 4; i++) {
                signature[i] = is.readUnsignedByte();
            }
            
            if (signature[0] == 1 && signature[1] == 1 && signature[2] == 8 && signature[3] == 0) {
                x = new MalformedFrameException("AMQP protocol version mismatch; we are version " + AMQP.PROTOCOL.MAJOR + "-" + AMQP.PROTOCOL.MINOR + "-" + AMQP.PROTOCOL.REVISION + ", server is 0-8");
            }
            
            else {
                String sig = "";
                for (int i = 0; i < 4; i++) {
                    if (i != 0) sig += ",";
                    sig += signature[i];
                }
                
                x = new MalformedFrameException("AMQP protocol version mismatch; we are version " + AMQP.PROTOCOL.MAJOR + "-" + AMQP.PROTOCOL.MINOR + "-" + AMQP.PROTOCOL.REVISION + ", server sent signature " + sig);
            }
            
        }
         catch (IOException ex) {
            x = new MalformedFrameException("Invalid AMQP protocol header from server");
        }
        
        throw x;
    }
    
    public void writeTo(DataOutputStream os) throws IOException {
        os.writeByte(type);
        os.writeShort(channel);
        if (accumulator != null) {
            os.writeInt(accumulator.size());
            accumulator.writeTo(os);
        }
         else {
            os.writeInt(payload.length);
            os.write(payload);
        }
        
        os.write(AMQP.FRAME_END);
    }
    
    public int size() {
        if(accumulator != null) {
            return accumulator.size() + NON_BODY_SIZE;
        }
         else {
            return payload.length + NON_BODY_SIZE;
        }
        
    }
    
    public byte[] getPayload() {
        if (payload != null) return payload;
        return accumulator.toByteArray();
    }
    
    public DataInputStream getInputStream() {
        return new DataInputStream(new ByteArrayInputStream(getPayload()));
    }
    
    public DataOutputStream getOutputStream() {
        return new DataOutputStream(accumulator);
    }
    
 public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Frame(type=").append(type).append(", channel=").append(channel).append(", ");
        if (accumulator == null) {
            sb.append(payload.length).append(" bytes of payload)");
        }
         else {
            sb.append(accumulator.size()).append(" bytes of accumulator)");
        }
        
        return sb.toString();
    }
    
    public static long tableSize(Map<String, Object> table) throws UnsupportedEncodingException {
        long acc = 0;
        for(Map.Entry<String, Object> entry: table.entrySet()) {
            acc += shortStrSize(entry.getKey());
            acc += fieldValueSize(entry.getValue());
        }
        
        return acc;
    }
    
    private static long fieldValueSize(Object value) throws UnsupportedEncodingException {
        long acc = 1; 
        if(value instanceof String) {
            acc += longStrSize((String)value);
        }
        
        else if(value instanceof LongString) {
            acc += 4 + ((LongString)value).length();
        }
        
        else if(value instanceof Integer) {
            acc += 4;
        }
        
        else if(value instanceof BigDecimal) {
            acc += 5;
        }
        
        else if(value instanceof Date) {
            acc += 8;
        }
        
        else if(value instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String,Object> map = (Map<String,Object>) value;
            acc += 4 + tableSize(map);
        }
        
        else if (value instanceof Byte) {
            acc += 1;
        }
        
        else if(value instanceof Double) {
            acc += 8;
        }
        
        else if(value instanceof Float) {
            acc += 4;
        }
        
        else if(value instanceof Long) {
            acc += 8;
        }
        
        else if(value instanceof Short) {
            acc += 2;
        }
        
        else if(value instanceof Boolean) {
            acc += 1;
        }
        
        else if(value instanceof byte[]) {
            acc += 4 + ((byte[])value).length;
        }
        
        else if(value instanceof List) {
            acc += 4 + arraySize((List<?>)value);
        }
        
        else if(value instanceof Object[]) {
            acc += 4 + arraySize((Object[])value);
        }
        
        else if(value == null) {
        }
        
        else {
            throw new IllegalArgumentException("invalid value in table");
        }
        
        return acc;
    }
    
    public static long arraySize(List<?> values) throws UnsupportedEncodingException {
        long acc = 0;
        for (Object value : values) {
            acc += fieldValueSize(value);
        }
        
        return acc;
    }
    
    public static long arraySize(Object[] values) throws UnsupportedEncodingException {
        long acc = 0;
        for (Object value : values) {
            acc += fieldValueSize(value);
        }
        
        return acc;
    }
    
    private static int longStrSize(String str) throws UnsupportedEncodingException {
        return str.getBytes("utf-8").length + 4;
    }
    
    private static int shortStrSize(String str) throws UnsupportedEncodingException {
        return str.getBytes("utf-8").length + 1;
    }
    
}


