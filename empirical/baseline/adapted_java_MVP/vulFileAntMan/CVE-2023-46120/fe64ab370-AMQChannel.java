package com.rabbitmq.client.impl;
import com.rabbitmq.client.*;
import com.rabbitmq.client.AMQP.Basic;
import com.rabbitmq.client.AMQP.Confirm;
import com.rabbitmq.client.AMQP.Exchange;
import com.rabbitmq.client.AMQP.Queue;
import com.rabbitmq.client.AMQP.Tx;
import com.rabbitmq.client.Method;
import com.rabbitmq.utility.BlockingValueOrException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;
public abstract class AMQChannel extends ShutdownNotifierComponent {
    private static final Logger LOGGER = LoggerFactory.getLogger(AMQChannel.class);
    protected static final int NO_RPC_TIMEOUT = 0;
    protected final Object _channelMutex = new Object();
    private final AMQConnection _connection;
    private final int _channelNumber;
    private AMQCommand _command = new AMQCommand();
    private RpcWrapper _activeRpc = null;
    protected volatile boolean _blockContent = false;
    protected final int _rpcTimeout;
    private final boolean _checkRpcResponseType;
    private final TrafficListener _trafficListener;
    public AMQChannel(AMQConnection connection, int channelNumber) {
        this._connection = connection;
        this._channelNumber = channelNumber;
        if(connection.getChannelRpcTimeout() < 0) {
            throw new IllegalArgumentException("Continuation timeout on RPC calls cannot be less than 0");
        }
        
        this._rpcTimeout = connection.getChannelRpcTimeout();
        this._checkRpcResponseType = connection.willCheckRpcResponseType();
        this._trafficListener = connection.getTrafficListener();
    }
    
    public int getChannelNumber() {
        return _channelNumber;
    }
    
    public void handleFrame(Frame frame) throws IOException {
        AMQCommand command = _command;
        if (command.handleFrame(frame)) { 
            _command = new AMQCommand(); 
            handleCompleteInboundCommand(command);
        }
        
    }
    
    public static IOException wrap(ShutdownSignalException ex) {
        return wrap(ex, null);
    }
    
    public static IOException wrap(ShutdownSignalException ex, String message) {
        IOException ioe = new IOException(message);
        ioe.initCause(ex);
        return ioe;
    }
    
    public AMQCommand exnWrappingRpc(Method m) throws IOException {
        try {
            return privateRpc(m);
        }
         catch (AlreadyClosedException ace) {
            throw ace;
        }
         catch (ShutdownSignalException ex) {
            throw wrap(ex);
        }
        
    }
    
    public CompletableFuture<Command> exnWrappingAsyncRpc(Method m) throws IOException {
        try {
            return privateAsyncRpc(m);
        }
         catch (AlreadyClosedException ace) {
            throw ace;
        }
         catch (ShutdownSignalException ex) {
            throw wrap(ex);
        }
        
    }
    
    public void handleCompleteInboundCommand(AMQCommand command) throws IOException {
        this._trafficListener.read(command);
        if (!processAsync(command)) {
            if (_checkRpcResponseType) {
                synchronized (_channelMutex) {
                    if (_activeRpc != null && !_activeRpc.canHandleReply(command)) {
                        return;
                    }
                    
                }
                
            }
            
            final RpcWrapper nextOutstandingRpc = nextOutstandingRpc();
            if(nextOutstandingRpc != null) {
                nextOutstandingRpc.complete(command);
                markRpcFinished();
            }
            
        }
        
    }
    
    public void enqueueRpc(RpcContinuation k) {
        doEnqueueRpc(() -> new RpcContinuationRpcWrapper(k));
    }
    
    public void enqueueAsyncRpc(Method method, CompletableFuture<Command> future) {
        doEnqueueRpc(() -> new CompletableFutureRpcWrapper(method, future));
    }
    
    private void doEnqueueRpc(Supplier<RpcWrapper> rpcWrapperSupplier) {
        synchronized (_channelMutex) {
            boolean waitClearedInterruptStatus = false;
            while (_activeRpc != null) {
                try {
                    _channelMutex.wait();
                }
                 catch (InterruptedException e) { 
                    waitClearedInterruptStatus = true;
                }
                
            }
            
            if (waitClearedInterruptStatus) {
                Thread.currentThread().interrupt();
            }
            
            _activeRpc = rpcWrapperSupplier.get();
        }
        
    }
    
    public boolean isOutstandingRpc() {
        synchronized (_channelMutex) {
            return (_activeRpc != null);
        }
        
    }
    
    public RpcWrapper nextOutstandingRpc() {
        synchronized (_channelMutex) {
            RpcWrapper result = _activeRpc;
            _activeRpc = null;
            _channelMutex.notifyAll();
            return result;
        }
        
    }
    
    protected void markRpcFinished() {
    }
    
    public void ensureIsOpen() throws AlreadyClosedException {
        if (!isOpen()) {
            throw new AlreadyClosedException(getCloseReason());
        }
        
    }
    
    public AMQCommand rpc(Method m) throws IOException, ShutdownSignalException {
        return privateRpc(m);
    }
    
    public AMQCommand rpc(Method m, int timeout) throws IOException, ShutdownSignalException, TimeoutException {
        return privateRpc(m, timeout);
    }
    
    private AMQCommand privateRpc(Method m) throws IOException, ShutdownSignalException {
        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);
        rpc(m, k);
        if(_rpcTimeout == NO_RPC_TIMEOUT) {
            return k.getReply();
        }
         else {
            try {
                return k.getReply(_rpcTimeout);
            }
             catch (TimeoutException e) {
                throw wrapTimeoutException(m, e);
            }
            
        }
        
    }
    
    private void cleanRpcChannelState() {
        try {
            nextOutstandingRpc();
            markRpcFinished();
        }
         catch (Exception ex) {
            LOGGER.warn("Error while cleaning timed out channel RPC: {}", ex.getMessage());
        }
        
    }
    
    protected ChannelContinuationTimeoutException wrapTimeoutException(final Method m, final TimeoutException e)  {
        cleanRpcChannelState();
        return new ChannelContinuationTimeoutException(e, this, this._channelNumber, m);
    }
    
    private CompletableFuture<Command> privateAsyncRpc(Method m) throws IOException, ShutdownSignalException {
        CompletableFuture<Command> future = new CompletableFuture<>();
        asyncRpc(m, future);
        return future;
    }
    
    private AMQCommand privateRpc(Method m, int timeout) throws IOException, ShutdownSignalException, TimeoutException {
        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);
        rpc(m, k);
        try {
            return k.getReply(timeout);
        }
         catch (TimeoutException e) {
            cleanRpcChannelState();
            throw e;
        }
        
    }
    
    public void rpc(Method m, RpcContinuation k) throws IOException {
        synchronized (_channelMutex) {
            ensureIsOpen();
            quiescingRpc(m, k);
        }
        
    }
    
    public void quiescingRpc(Method m, RpcContinuation k) throws IOException {
        synchronized (_channelMutex) {
            enqueueRpc(k);
            quiescingTransmit(m);
        }
        
    }
    
    public void asyncRpc(Method m, CompletableFuture<Command> future) throws IOException {
        synchronized (_channelMutex) {
            ensureIsOpen();
            quiescingAsyncRpc(m, future);
        }
        
    }
    
    public void quiescingAsyncRpc(Method m, CompletableFuture<Command> future) throws IOException {
        synchronized (_channelMutex) {
            enqueueAsyncRpc(m, future);
            quiescingTransmit(m);
        }
        
    }
    
    public abstract boolean processAsync(Command command) throws IOException;
 public String toString() {
        return "AMQChannel(" + _connection + "," + _channelNumber + ")";
    }
    
    public void processShutdownSignal(ShutdownSignalException signal, boolean ignoreClosed, boolean notifyRpc) {
        try {
            synchronized (_channelMutex) {
                if (!setShutdownCauseIfOpen(signal)) {
                    if (!ignoreClosed){
                        throw new AlreadyClosedException(getCloseReason());
}
                }
                
                _channelMutex.notifyAll();
            }
            
        }
         finally {
            if (notifyRpc){
                notifyOutstandingRpc(signal);
}
        }
        
    }
    
    public void notifyOutstandingRpc(ShutdownSignalException signal) {
        RpcWrapper k = nextOutstandingRpc();
        if (k != null) {
            k.shutdown(signal);
        }
        
    }
    
    public void transmit(Method m) throws IOException {
        synchronized (_channelMutex) {
            transmit(new AMQCommand(m));
        }
        
    }
    
    public void transmit(AMQCommand c) throws IOException {
        synchronized (_channelMutex) {
            ensureIsOpen();
            quiescingTransmit(c);
        }
        
    }
    
    public void quiescingTransmit(Method m) throws IOException {
        synchronized (_channelMutex) {
            quiescingTransmit(new AMQCommand(m));
        }
        
    }
    
    public void quiescingTransmit(AMQCommand c) throws IOException {
        synchronized (_channelMutex) {
            if (c.getMethod().hasContent()) {
                while (_blockContent) {
                    try {
                        _channelMutex.wait();
                    }
                     catch (InterruptedException ignored) {
                        Thread.currentThread().interrupt();
                    }
                    
                    ensureIsOpen();
                }
                
            }
            
            this._trafficListener.write(c);
            c.transmit(this);
        }
        
    }
    
    public AMQConnection getConnection() {
        return _connection;
    }
    
    public interface RpcContinuation {
        void handleCommand(AMQCommand command);
        boolean canHandleReply(AMQCommand command);
        void handleShutdownSignal(ShutdownSignalException signal);
    }
    
    public static abstract class BlockingRpcContinuation<T> implements RpcContinuation {
        public final BlockingValueOrException<T, ShutdownSignalException> _blocker = new BlockingValueOrException<T, ShutdownSignalException>();
        protected final Method request;
        public BlockingRpcContinuation() {
            request = null;
        }
        
        public BlockingRpcContinuation(final Method request) {
            this.request = request;
        }
        
        public void handleCommand(AMQCommand command) {
            _blocker.setValue(transformReply(command));
        }
        
        public void handleShutdownSignal(ShutdownSignalException signal) {
            _blocker.setException(signal);
        }
        
        public T getReply() throws ShutdownSignalException {
            return _blocker.uninterruptibleGetValue();
        }
        
        public T getReply(int timeout) throws ShutdownSignalException, TimeoutException {
            return _blocker.uninterruptibleGetValue(timeout);
        }
        
        public boolean canHandleReply(AMQCommand command) {
            return isResponseCompatibleWithRequest(request, command.getMethod());
        }
        
        public abstract T transformReply(AMQCommand command);
        public static boolean isResponseCompatibleWithRequest(Method request, Method response) {
            if (request != null) {
                if (request instanceof Basic.Qos) {
                    return response instanceof Basic.QosOk;
                }
                 else if (request instanceof Basic.Get) {
                    return response instanceof Basic.GetOk || response instanceof Basic.GetEmpty;
                }
                 else if (request instanceof Basic.Consume) {
                    if (!(response instanceof Basic.ConsumeOk)){
                        return false;
}
                    final String consumerTag = ((Basic.Consume) request).getConsumerTag();
                    return consumerTag == null || consumerTag.equals("") || consumerTag.equals(((Basic.ConsumeOk) response).getConsumerTag());
                }
                 else if (request instanceof Basic.Cancel) {
                    if (!(response instanceof Basic.CancelOk)){
                        return false;
}
                    return ((Basic.Cancel) request).getConsumerTag().equals(((Basic.CancelOk) response).getConsumerTag());
                }
                 else if (request instanceof Basic.Recover) {
                    return response instanceof Basic.RecoverOk;
                }
                 else if (request instanceof Exchange.Declare) {
                    return response instanceof Exchange.DeclareOk;
                }
                 else if (request instanceof Exchange.Delete) {
                    return response instanceof Exchange.DeleteOk;
                }
                 else if (request instanceof Exchange.Bind) {
                    return response instanceof Exchange.BindOk;
                }
                 else if (request instanceof Exchange.Unbind) {
                    return response instanceof Exchange.UnbindOk;
                }
                 else if (request instanceof Queue.Declare) {
                    return response instanceof Queue.DeclareOk;
                }
                 else if (request instanceof Queue.Delete) {
                    return response instanceof Queue.DeleteOk;
                }
                 else if (request instanceof Queue.Bind) {
                    return response instanceof Queue.BindOk;
                }
                 else if (request instanceof Queue.Unbind) {
                    return response instanceof Queue.UnbindOk;
                }
                 else if (request instanceof Queue.Purge) {
                    return response instanceof Queue.PurgeOk;
                }
                 else if (request instanceof Tx.Select) {
                    return response instanceof Tx.SelectOk;
                }
                 else if (request instanceof Tx.Commit) {
                    return response instanceof Tx.CommitOk;
                }
                 else if (request instanceof Tx.Rollback) {
                    return response instanceof Tx.RollbackOk;
                }
                 else if (request instanceof Confirm.Select) {
                    return response instanceof Confirm.SelectOk;
                }
                
            }
            
            return true;
        }
        
    }
    
    public static class SimpleBlockingRpcContinuation extends BlockingRpcContinuation<AMQCommand> {
        public SimpleBlockingRpcContinuation() {
            super();
        }
        
        public SimpleBlockingRpcContinuation(final Method method) {
            super(method);
        }
        
        public AMQCommand transformReply(AMQCommand command) {
            return command;
        }
        
    }
    
}


