package org.keycloak.services.clientregistration;
import org.keycloak.events.EventBuilder;
import org.keycloak.events.EventType;
import org.keycloak.models.ClientInitialAccessModel;
import org.keycloak.models.ClientModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.ModelDuplicateException;
import org.keycloak.models.RealmModel;
import org.keycloak.models.utils.ModelToRepresentation;
import org.keycloak.models.utils.RepresentationToModel;
import org.keycloak.representations.idm.ClientRepresentation;
import org.keycloak.representations.oidc.OIDCClientRepresentation;
import org.keycloak.services.ErrorResponseException;
import org.keycloak.services.ForbiddenException;
import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;
import org.keycloak.services.clientregistration.policy.RegistrationAuth;
import org.keycloak.services.managers.ClientManager;
import org.keycloak.services.managers.RealmManager;
import org.keycloak.validation.ValidationUtil;
import javax.ws.rs.core.Response;
public abstract class AbstractClientRegistrationProvider implements ClientRegistrationProvider {
    protected KeycloakSession session;
    protected EventBuilder event;
    protected ClientRegistrationAuth auth;
    public AbstractClientRegistrationProvider(KeycloakSession session) {
        this.session = session;
    }
    
    public ClientRepresentation create(ClientRegistrationContext context) {
        ClientRepresentation client = context.getClient();
        event.event(EventType.CLIENT_REGISTER);
        RegistrationAuth registrationAuth = auth.requireCreate(context);
        try {
            RealmModel realm = session.getContext().getRealm();
            ClientModel clientModel = ClientManager.createClient(session, realm, client);
            if (clientModel.isServiceAccountsEnabled()) {
                new ClientManager(new RealmManager(session)).enableServiceAccount(clientModel);
            }
            
            if (Boolean.TRUE.equals(client.getAuthorizationServicesEnabled())) {
                RepresentationToModel.createResourceServer(clientModel, session, true);
            }
            
            ClientRegistrationPolicyManager.triggerAfterRegister(context, registrationAuth, clientModel);
            client = ModelToRepresentation.toRepresentation(clientModel, session);
            client.setSecret(clientModel.getSecret());
            String registrationAccessToken = ClientRegistrationTokenUtils.updateRegistrationAccessToken(session, clientModel, registrationAuth);
            client.setRegistrationAccessToken(registrationAccessToken);
            if (auth.isInitialAccessToken()) {
                ClientInitialAccessModel initialAccessModel = auth.getInitialAccessModel();
                session.realms().decreaseRemainingCount(realm, initialAccessModel);
            }
            
            event.client(client.getClientId()).success();
            return client;
        }
         catch (ModelDuplicateException e) {
            throw new ErrorResponseException(ErrorCodes.INVALID_CLIENT_METADATA, "Client Identifier in use", Response.Status.BAD_REQUEST);
        }
        
    }
    
    public ClientRepresentation get(ClientModel client) {
        event.event(EventType.CLIENT_INFO);
        auth.requireView(client);
        ClientRepresentation rep = ModelToRepresentation.toRepresentation(client, session);
        if (client.getSecret() != null) {
            rep.setSecret(client.getSecret());
        }
        
        if (auth.isRegistrationAccessToken()) {
            String registrationAccessToken = ClientRegistrationTokenUtils.updateTokenSignature(session, auth);
            rep.setRegistrationAccessToken(registrationAccessToken);
        }
        
        event.client(client.getClientId()).success();
        return rep;
    }
    
    public ClientRepresentation update(String clientId, ClientRegistrationContext context) {
        ClientRepresentation rep = context.getClient();
        event.event(EventType.CLIENT_UPDATE).client(clientId);
        ClientModel client = session.getContext().getRealm().getClientByClientId(clientId);
        RegistrationAuth registrationAuth = auth.requireUpdate(context, client);
        if (!client.getClientId().equals(rep.getClientId())) {
            throw new ErrorResponseException(ErrorCodes.INVALID_CLIENT_METADATA, "Client Identifier modified", Response.Status.BAD_REQUEST);
        }
        
        RepresentationToModel.updateClient(rep, client);
        RepresentationToModel.updateClientProtocolMappers(rep, client);
        rep = ModelToRepresentation.toRepresentation(client, session);
        if (auth.isRegistrationAccessToken()) {
            String registrationAccessToken = ClientRegistrationTokenUtils.updateRegistrationAccessToken(session, client, auth.getRegistrationAuth());
            rep.setRegistrationAccessToken(registrationAccessToken);
        }
        
        ClientRegistrationPolicyManager.triggerAfterUpdate(context, registrationAuth, client);
        event.client(client.getClientId()).success();
        return rep;
    }
    
    public void delete(String clientId) {
        event.event(EventType.CLIENT_DELETE).client(clientId);
        ClientModel client = session.getContext().getRealm().getClientByClientId(clientId);
        auth.requireDelete(client);
        if (new ClientManager(new RealmManager(session)).removeClient(session.getContext().getRealm(), client)) {
            event.client(client.getClientId()).success();
        }
         else {
            throw new ForbiddenException();
        }
        
    }
    
    public void validateClient(ClientModel clientModel, OIDCClientRepresentation oidcClient, boolean create) {
        ValidationUtil.validateClient(session, clientModel, oidcClient, create, r -> {
            session.getTransactionManager().setRollbackOnly();
            String errorCode = r.fieldHasError("redirectUris") ? ErrorCodes.INVALID_REDIRECT_URI : ErrorCodes.INVALID_CLIENT_METADATA;
            throw new ErrorResponseException(errorCode, r.getAllErrorsAsString(), Response.Status.BAD_REQUEST);
        }
        
);
    }
    
    public void validateClient(ClientRepresentation clientRep, boolean create) {
        validateClient(session.getContext().getRealm().getClientByClientId(clientRep.getClientId()), null, create);
    }
    
    public void setAuth(ClientRegistrationAuth auth) {
        this.auth = auth;
    }
    
    public ClientRegistrationAuth getAuth() {
        return this.auth;
    }
    
    public void setEvent(EventBuilder event) {
        this.event = event;
    }
    
    public EventBuilder getEvent() {
        return event;
    }
    
    public void close() {
    }
    
}


