package io.netty.incubator.codec.bhttp;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.handler.codec.CorruptedFrameException;
import io.netty.handler.codec.DecoderException;
import io.netty.handler.codec.TooLongFrameException;
import io.netty.handler.codec.http.DefaultFullHttpResponse;
import io.netty.handler.codec.http.DefaultHttpContent;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.DefaultLastHttpContent;
import io.netty.handler.codec.http.HttpContent;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpMessage;
import io.netty.handler.codec.http.HttpMethod;
import io.netty.handler.codec.http.HttpObject;
import io.netty.handler.codec.http.HttpResponseStatus;
import io.netty.handler.codec.http.HttpStatusClass;
import io.netty.handler.codec.http.HttpVersion;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.util.ByteProcessor;
import io.netty.util.internal.ObjectUtil;
import java.nio.charset.StandardCharsets;
import static io.netty.incubator.codec.bhttp.VarIntCodecUtils.getVariableLengthInteger;
import static io.netty.incubator.codec.bhttp.VarIntCodecUtils.numBytesForVariableLengthIntegerFromByte;
import static io.netty.incubator.codec.bhttp.VarIntCodecUtils.readVariableLengthInteger;
public final class BinaryHttpParser {
    private enum State {
        READ_FRAME_TYPE(true), READ_KNOWN_LENGTH_REQUEST_HEAD(true), READ_KNOWN_LENGTH_RESPONSE_HEAD(true), READ_KNOWN_LENGTH_FIELD_SECTION_TRAILERS(true), READ_KNOWN_LENGTH_CONTENT(true), READ_INDETERMINATE_LENGTH_REQUEST_HEAD(false), READ_INDETERMINATE_LENGTH_RESPONSE_HEAD(false), READ_INDETERMINATE_LENGTH_CONTENT(false), READ_INDETERMINATE_LENGTH_FIELD_SECTION_TRAILERS(false), READ_PADDING(true), DISCARD(true);
        final boolean knownLength;
        State(boolean knownLength) {
            this.knownLength = knownLength;
        }
        
    }
    
    private static final ByteProcessor PADDING_VALIDATOR = b -> {
        if (b != 0) {
            throw new CorruptedFrameException("Invalid byte used for padding: " + b);
        }
        
        return true;
    };
    private State state = State.READ_FRAME_TYPE;
    private boolean completeBodyReceived;
    private long contentLength = -1;
    private final int maxFieldSectionSize;
    public BinaryHttpParser(int maxFieldSectionSize) {
        this.maxFieldSectionSize = ObjectUtil.checkPositiveOrZero(maxFieldSectionSize, "maxFieldSectionSize");
    }
    
    public HttpObject parse(ByteBuf in, boolean completeBodyReceived) {
        try {
            if (!completeBodyReceived && this.completeBodyReceived) {
                throw new IllegalStateException("Body was already marked as complete before");
            }
            
            this.completeBodyReceived = completeBodyReceived;
            for (;;) {
                switch (state) {
                    case DISCARD:
                        in.skipBytes(in.readableBytes());
                        return null;
                    case READ_FRAME_TYPE:
                        assert contentLength == -1 : "contentLength should have been reset";
                        state = readFramingIndicator(in);
                        break;
                    case READ_KNOWN_LENGTH_REQUEST_HEAD:
                    case READ_INDETERMINATE_LENGTH_REQUEST_HEAD:
                        assert contentLength == -1 : "contentLength should have been reset";
                        HttpMessage request = readRequestHead(in, state.knownLength, maxFieldSectionSize);
                        if (request == null) {
                            throwIfNotReadAllAndBodyReceived(in, completeBodyReceived);
                            return null;
                        }
                        
                        if (state.knownLength) {
                            state = State.READ_KNOWN_LENGTH_CONTENT;
                        }
                         else {
                            state = State.READ_INDETERMINATE_LENGTH_CONTENT;
                        }
                        
                        return request;
                    case READ_KNOWN_LENGTH_RESPONSE_HEAD:
                    case READ_INDETERMINATE_LENGTH_RESPONSE_HEAD:
                        assert contentLength == -1 : "contentLength should have been reset";
                        BinaryHttpResponse response = readResponseHead(in, state.knownLength, maxFieldSectionSize);
                        if (response == null) {
                            throwIfNotReadAllAndBodyReceived(in, completeBodyReceived);
                            return null;
                        }
                        
                        boolean informational = response.status().codeClass() == HttpStatusClass.INFORMATIONAL;
                        if (informational) {
                            return new DefaultFullHttpResponse(response.protocolVersion(), response.status(), Unpooled.EMPTY_BUFFER, response.headers(), new DefaultHttpHeaders());
                        }
                         else if (state.knownLength) {
                            state = State.READ_KNOWN_LENGTH_CONTENT;
                        }
                         else {
                            state = State.READ_INDETERMINATE_LENGTH_CONTENT;
                        }
                        
                        return response;
                    case READ_KNOWN_LENGTH_CONTENT:
                    case READ_INDETERMINATE_LENGTH_CONTENT:
                        assert contentLength >= -1;
                        if (contentLength == -1) {
                            if (in.readableBytes() == 0) {
                                if (completeBodyReceived) {
                                    if (state.knownLength) {
                                        state = State.READ_KNOWN_LENGTH_FIELD_SECTION_TRAILERS;
                                    }
                                     else {
                                        state = State.READ_INDETERMINATE_LENGTH_FIELD_SECTION_TRAILERS;
                                    }
                                    
                                    break;
                                }
                                 else {
                                    return null;
                                }
                                
                            }
                            
                            int numBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(in.readerIndex()));
                            if (in.readableBytes() < numBytes) {
                                throwIfNotReadAllAndBodyReceived(in, completeBodyReceived);
                                return null;
                            }
                            
                            contentLength = readVariableLengthInteger(in, numBytes);
                            if (contentLength == 0) {
                                if (state.knownLength) {
                                    state = State.READ_KNOWN_LENGTH_FIELD_SECTION_TRAILERS;
                                }
                                 else {
                                    state = State.READ_INDETERMINATE_LENGTH_FIELD_SECTION_TRAILERS;
                                }
                                
                                contentLength = -1;
                                break;
                            }
                            
                        }
                        
                        int numBytes = (int) Math.min(contentLength, in.readableBytes());
                        contentLength -= numBytes;
                        if (contentLength == 0) {
                            contentLength = -1;
                            if (state.knownLength) {
                                state = State.READ_KNOWN_LENGTH_FIELD_SECTION_TRAILERS;
                            }
                            
                        }
                         else if (completeBodyReceived) {
                            throw new CorruptedFrameException("Closed input while still decoding the content");
                        }
                         else if (numBytes == 0) {
                            return null;
                        }
                        
                        return new DefaultHttpContent(in.readRetainedSlice(numBytes));
                    case READ_KNOWN_LENGTH_FIELD_SECTION_TRAILERS:
                    case READ_INDETERMINATE_LENGTH_FIELD_SECTION_TRAILERS:
                        assert contentLength == -1 : "contentLength should have been reset";
                        HttpHeaders trailers = readFieldSection(in, true, state.knownLength, maxFieldSectionSize);
                        if (trailers == null) {
                            if (completeBodyReceived) {
                                throwIfNotReadAllAndBodyReceived(in, true);
                                state = State.READ_PADDING;
                                return LastHttpContent.EMPTY_LAST_CONTENT;
                            }
                            
                            return null;
                        }
                        
                        state = State.READ_PADDING;
                        return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailers);
                    case READ_PADDING:
                        assert contentLength == -1 : "contentLength should have been reset";
                        readPadding(in);
                        return null;
                    default: throw new IllegalStateException();
                }
                
            }
            
        }
         catch (Exception e) {
            state = State.DISCARD;
            throw e;
        }
        
    }
    
    private static void throwIfNotReadAllAndBodyReceived(ByteBuf in, boolean completeBodyReceived) {
        if (in.isReadable() && completeBodyReceived) {
            throw new CorruptedFrameException("Closed input while still decoding");
        }
        
    }
    
    private static void readPadding(ByteBuf in) {
        in.forEachByte(PADDING_VALIDATOR);
        in.skipBytes(in.readableBytes());
    }
    
    private static State readFramingIndicator(ByteBuf in) {
        if (!in.isReadable()) {
            return State.READ_FRAME_TYPE;
        }
        
        int bytesNeeded = numBytesForVariableLengthIntegerFromByte(in.getByte(in.readerIndex()));
        if (bytesNeeded > in.readableBytes()) {
            return State.READ_FRAME_TYPE;
        }
        
        int framingIndicator = (int) readVariableLengthInteger(in, bytesNeeded);
        switch (framingIndicator) {
            case 0:
                return State.READ_KNOWN_LENGTH_REQUEST_HEAD;
            case 1:
                return State.READ_KNOWN_LENGTH_RESPONSE_HEAD;
            case 2:
                return State.READ_INDETERMINATE_LENGTH_REQUEST_HEAD;
            case 3:
                return State.READ_INDETERMINATE_LENGTH_RESPONSE_HEAD;
            default: throw new IllegalArgumentException("Unknown value for a FrameIndicator: " + framingIndicator);
        }
        
    }
    
    private static BinaryHttpRequest readRequestHead(ByteBuf in, boolean knownLength, int maxFieldSectionSize) {
        if (!in.isReadable()) {
            return null;
        }
        
        int sumBytes = 0;
        final int methodLengthIdx = in.readerIndex() + sumBytes;
        final int methodLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(methodLengthIdx));
        sumBytes += methodLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long methodLength = getVariableLengthInteger(in, methodLengthIdx, methodLengthBytes);
        sumBytes += methodLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int methodIdx = methodLengthIdx + methodLengthBytes;
        final int schemeLengthIdx = in.readerIndex() + sumBytes;
        final int schemeLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(schemeLengthIdx));
        sumBytes += schemeLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long schemeLength = getVariableLengthInteger(in, schemeLengthIdx, schemeLengthBytes);
        sumBytes += schemeLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int schemeIdx = schemeLengthIdx + schemeLengthBytes;
        final int authorityLengthIdx = in.readerIndex() + sumBytes;
        final int authorityLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(authorityLengthIdx));
        sumBytes += authorityLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long authorityLength = getVariableLengthInteger(in, authorityLengthIdx, authorityLengthBytes);
        sumBytes += authorityLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int authorityIdx = authorityLengthIdx + authorityLengthBytes;
        final int pathLengthIdx = in.readerIndex() + sumBytes;
        final int pathLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(pathLengthIdx));
        sumBytes += pathLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long pathLength = getVariableLengthInteger(in, pathLengthIdx, pathLengthBytes);
        sumBytes += pathLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int pathIdx = pathLengthIdx + pathLengthBytes;
        int fieldSectionIdx = in.readerIndex() + sumBytes;
        int fieldSectionLength = in.readableBytes() - sumBytes;
        ByteBuf fieldSectionSlice = in.slice(fieldSectionIdx, fieldSectionLength);
        int fieldSectionReadableBytes = fieldSectionSlice.readableBytes();
        BinaryHttpHeaders headers = readFieldSection(fieldSectionSlice, false, knownLength, maxFieldSectionSize);
        if (headers == null) {
            return null;
        }
        
        sumBytes += fieldSectionReadableBytes - fieldSectionSlice.readableBytes();
        String method = in.toString(methodIdx, (int) methodLength, StandardCharsets.US_ASCII);
        String scheme = in.toString(schemeIdx, (int) schemeLength, StandardCharsets.US_ASCII);
        String authority = in.toString(authorityIdx, (int) authorityLength, StandardCharsets.US_ASCII);
        String path = in.toString(pathIdx, (int) pathLength, StandardCharsets.US_ASCII);
        BinaryHttpRequest request = new DefaultBinaryHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.valueOf(method), scheme, authority, path, headers);
        in.skipBytes(sumBytes);
        return request;
    }
    
    private static BinaryHttpResponse readResponseHead(ByteBuf in, boolean knownLength, int maxFieldSectionSize) {
        if (!in.isReadable()) {
            return null;
        }
        
        int sumBytes = 0;
        final int statusLengthIdx = in.readerIndex();
        final int statusLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(statusLengthIdx));
        sumBytes += statusLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long status = getVariableLengthInteger(in, statusLengthIdx, statusLengthBytes);
        int fieldSectionIdx = in.readerIndex() + sumBytes;
        int fieldSectionLength = in.readableBytes() - sumBytes;
        ByteBuf fieldSectionSlice = in.slice(fieldSectionIdx, fieldSectionLength);
        int fieldSectionReadableBytes = fieldSectionSlice.readableBytes();
        BinaryHttpHeaders headers = readFieldSection(fieldSectionSlice, false, knownLength, maxFieldSectionSize);
        if (headers == null) {
            return null;
        }
        
        sumBytes += fieldSectionReadableBytes - fieldSectionSlice.readableBytes();
        in.skipBytes(sumBytes);
        if (status < 100 || status > 599) {
            throw new IllegalArgumentException("Invalid status: " + status);
        }
        
        HttpResponseStatus responseStatus = HttpResponseStatus.valueOf((int) status);
        return new DefaultBinaryHttpResponse(HttpVersion.HTTP_1_1, responseStatus, headers);
    }
    
    private static int getIndeterminateLength(ByteBuf in) {
        if (!in.isReadable()) {
            return -1;
        }
        
        boolean name = true;
        for (int sumBytes = 0; sumBytes < in.readableBytes();) {
            int idx = in.readerIndex() + sumBytes;
            int possibleTerminatorBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(idx));
            sumBytes += possibleTerminatorBytes;
            if (in.readableBytes() < sumBytes) {
                return -1;
            }
            
            long possibleTerminator = getVariableLengthInteger(in, idx, possibleTerminatorBytes);
            sumBytes += possibleTerminator;
            if (in.readableBytes() < sumBytes) {
                return -1;
            }
            
            if (name && possibleTerminator == 0) {
                return sumBytes - possibleTerminatorBytes;
            }
            
            name = !name;
        }
        
        return -1;
    }
    
    private static BinaryHttpHeaders readFieldSection( ByteBuf in, boolean trailers, boolean knownLength, int maxFieldSectionSize) {
        if (!in.isReadable()) {
            return null;
        }
        
        final int fieldSectionBytes;
        long fieldSectionLength;
        int sumBytes = 0;
        if (knownLength) {
            fieldSectionBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(in.readerIndex()));
            sumBytes += fieldSectionBytes;
            if (in.readableBytes() < sumBytes) {
                checkFieldSectionTooLarge(in.readableBytes(), maxFieldSectionSize);
                return null;
            }
            
            fieldSectionLength = getVariableLengthInteger(in, in.readerIndex(), fieldSectionBytes);
            sumBytes += fieldSectionLength;
        }
         else {
            int indeterminateLength = getIndeterminateLength(in);
            assert indeterminateLength >= -1;
            if (indeterminateLength == -1) {
                checkFieldSectionTooLarge(in.readableBytes(), maxFieldSectionSize);
                return null;
            }
            
            fieldSectionBytes = 0;
            fieldSectionLength = indeterminateLength;
            sumBytes = (int) fieldSectionLength + 1;
        }
        
        checkFieldSectionTooLarge(fieldSectionLength, maxFieldSectionSize);
        if (in.readableBytes() < sumBytes) {
            return null;
        }
        
        in.skipBytes(fieldSectionBytes);
        BinaryHttpHeaders headers = trailers ? BinaryHttpHeaders.newTrailers(true) : BinaryHttpHeaders.newHeaders(true);
        HeaderType lastType = HeaderType.PSEUDO_HEADER;
        while (fieldSectionLength != 0) {
            int readableBytes = in.readableBytes();
            lastType = readFieldLine(in, headers, lastType, trailers);
            assert lastType != null;
            int read = readableBytes - in.readableBytes();
            assert read > 0;
            fieldSectionLength -= read;
        }
        
        if (!knownLength) {
            int terminator = in.readByte();
            assert terminator == 0;
        }
        
        return headers;
    }
    
    private static void checkFieldSectionTooLarge(long fieldSectionSize, int maxFieldSectionSize) {
        if (fieldSectionSize > maxFieldSectionSize) {
            throw new TooLongFrameException("field-section length exceeds configured maximum: " + fieldSectionSize + " > " + maxFieldSectionSize);
        }
        
    }
    
    private static HeaderType readFieldLine(ByteBuf in, HttpHeaders headers, HeaderType lastType, boolean trailers) {
        if (!in.isReadable()) {
            return null;
        }
        
        int sumBytes = 0;
        final int nameLengthIdx = in.readerIndex();
        final int nameLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(in.readerIndex()));
        sumBytes += nameLengthBytes;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final long nameLength = getVariableLengthInteger(in, in.readerIndex(), nameLengthBytes);
        sumBytes += nameLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int nameIdx = nameLengthIdx + nameLengthBytes;
        final int valueLengthIdx = nameIdx + (int) nameLength;
        final int valueLengthBytes = numBytesForVariableLengthIntegerFromByte(in.getByte(valueLengthIdx));
        sumBytes += valueLengthBytes;
        final long valueLength = getVariableLengthInteger(in, valueLengthIdx, valueLengthBytes);
        sumBytes += valueLength;
        if (sumBytes >= in.readableBytes()) {
            return null;
        }
        
        final int valueIdx = valueLengthIdx + valueLengthBytes;
        CharSequence name = in.getCharSequence(nameIdx, (int) nameLength, StandardCharsets.US_ASCII);
        boolean pseudo = PseudoHeaderName.hasPseudoHeaderFormat(name);
        if (pseudo) {
            if (trailers) {
                throw new DecoderException("pseudo-fields are not allowed in trailers: " + name);
            }
            
            if (PseudoHeaderName.isPseudoHeader(name)) {
                throw new DecoderException("pseudo-field not allowed in headers: " + name);
            }
            
            if (lastType == HeaderType.REGULAR_HEADER) {
                throw new DecoderException("pseudo-field must not follow non pseudo-field");
            }
            
        }
        
        CharSequence value = in.getCharSequence(valueIdx, (int) valueLength, StandardCharsets.US_ASCII);
        headers.add(name, value);
        in.skipBytes(sumBytes);
        return pseudo ? HeaderType.PSEUDO_HEADER : HeaderType.REGULAR_HEADER;
    }
    
    private enum HeaderType {
        REGULAR_HEADER, PSEUDO_HEADER, }
}


