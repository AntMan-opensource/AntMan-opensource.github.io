package org.elasticsearch.xpack.ilm.action;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.elasticsearch.action.ActionListener;
import org.elasticsearch.action.support.ActionFilters;
import org.elasticsearch.action.support.master.TransportMasterNodeAction;
import org.elasticsearch.client.Client;
import org.elasticsearch.cluster.AckedClusterStateUpdateTask;
import org.elasticsearch.cluster.ClusterState;
import org.elasticsearch.cluster.block.ClusterBlockException;
import org.elasticsearch.cluster.block.ClusterBlockLevel;
import org.elasticsearch.cluster.metadata.IndexMetadata;
import org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;
import org.elasticsearch.cluster.metadata.Metadata;
import org.elasticsearch.cluster.service.ClusterService;
import org.elasticsearch.common.Nullable;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.xcontent.DeprecationHandler;
import org.elasticsearch.common.xcontent.NamedXContentRegistry;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.common.xcontent.json.JsonXContent;
import org.elasticsearch.threadpool.ThreadPool;
import org.elasticsearch.transport.TransportService;
import org.elasticsearch.xpack.core.ClientHelper;
import org.elasticsearch.xpack.core.ilm.ErrorStep;
import org.elasticsearch.xpack.core.ilm.IndexLifecycleMetadata;
import org.elasticsearch.xpack.core.ilm.LifecycleExecutionState;
import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;
import org.elasticsearch.xpack.core.ilm.LifecyclePolicyMetadata;
import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
import org.elasticsearch.xpack.core.ilm.PhaseExecutionInfo;
import org.elasticsearch.xpack.core.ilm.Step;
import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction;
import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction.Request;
import org.elasticsearch.xpack.core.ilm.action.PutLifecycleAction.Response;
import org.elasticsearch.xpack.ilm.IndexLifecycleTransition;
import java.io.IOException;
import java.time.Instant;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.Spliterators;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;
public class TransportPutLifecycleAction extends TransportMasterNodeAction<Request, Response> {
    private static final Logger logger = LogManager.getLogger(TransportPutLifecycleAction.class);
    private final NamedXContentRegistry xContentRegistry;
    private final Client client;
    public TransportPutLifecycleAction(TransportService transportService, ClusterService clusterService, ThreadPool threadPool, ActionFilters actionFilters, IndexNameExpressionResolver indexNameExpressionResolver, NamedXContentRegistry namedXContentRegistry, Client client) {
        super(PutLifecycleAction.NAME, transportService, clusterService, threadPool, actionFilters, Request::new, indexNameExpressionResolver);
        this.xContentRegistry = namedXContentRegistry;
        this.client = client;
    }
    
    protected String executor() {
        return ThreadPool.Names.SAME;
    }
    
    protected Response read(StreamInput in) throws IOException {
        return new Response(in);
    }
    
    protected void masterOperation(Request request, ClusterState state, ActionListener<Response> listener) {
        Map<String, String> filteredHeaders = threadPool.getThreadContext().getHeaders().entrySet().stream() .filter(e -> ClientHelper.SECURITY_HEADER_FILTERS.contains(e.getKey())) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        LifecyclePolicy.validatePolicyName(request.getPolicy().getName());
        clusterService.submitStateUpdateTask("put-lifecycle-" + request.getPolicy().getName(), new AckedClusterStateUpdateTask<Response>(request, listener) {
                    protected Response newResponse(boolean acknowledged) {
                        return new Response(acknowledged);
                    }
                    
                    public ClusterState execute(ClusterState currentState) throws Exception {
                        ClusterState.Builder stateBuilder = ClusterState.builder(currentState);
                        IndexLifecycleMetadata currentMetadata = currentState.metadata().custom(IndexLifecycleMetadata.TYPE);
                        if (currentMetadata == null) { 
                            currentMetadata = IndexLifecycleMetadata.EMPTY;
                        }
                        
                        LifecyclePolicyMetadata existingPolicyMetadata = currentMetadata.getPolicyMetadatas() .get(request.getPolicy().getName());
                        long nextVersion = (existingPolicyMetadata == null) ? 1L : existingPolicyMetadata.getVersion() + 1L;
                        SortedMap<String, LifecyclePolicyMetadata> newPolicies = new TreeMap<>(currentMetadata.getPolicyMetadatas());
                        LifecyclePolicyMetadata lifecyclePolicyMetadata = new LifecyclePolicyMetadata(request.getPolicy(), filteredHeaders, nextVersion, Instant.now().toEpochMilli());
                        LifecyclePolicyMetadata oldPolicy = newPolicies.put(lifecyclePolicyMetadata.getName(), lifecyclePolicyMetadata);
                        if (oldPolicy == null) {
                            logger.info("adding index lifecycle policy [{}]", request.getPolicy().getName());
                        }
                         else {
                            logger.info("updating index lifecycle policy [{}]", request.getPolicy().getName());
                        }
                        
                        IndexLifecycleMetadata newMetadata = new IndexLifecycleMetadata(newPolicies, currentMetadata.getOperationMode());
                        stateBuilder.metadata(Metadata.builder(currentState.getMetadata()) .putCustom(IndexLifecycleMetadata.TYPE, newMetadata).build());
                        ClusterState nonRefreshedState = stateBuilder.build();
                        if (oldPolicy == null) {
                            return nonRefreshedState;
                        }
                         else {
                            try {
                                return updateIndicesForPolicy(nonRefreshedState, xContentRegistry, client, oldPolicy.getPolicy(), lifecyclePolicyMetadata);
                            }
                             catch (Exception e) {
                                logger.warn(new ParameterizedMessage("unable to refresh indices phase JSON for updated policy [{}]", oldPolicy.getName()), e);
                                return nonRefreshedState;
                            }
                            
                        }
                        
                    }
                    
                }
                
);
    }
    
    static boolean eligibleToCheckForRefresh(final IndexMetadata metadata) {
        LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metadata);
        if (executionState == null || executionState.getPhaseDefinition() == null) {
            return false;
        }
        
        Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);
        if (currentStepKey == null || currentStepKey.getPhase() == null) {
            return false;
        }
        
        return ErrorStep.NAME.equals(currentStepKey.getName()) == false;
    }
    
    @Nullable
    static Set<Step.StepKey> readStepKeys(final NamedXContentRegistry xContentRegistry, final Client client, final String phaseDef, final String currentPhase) {
        final PhaseExecutionInfo phaseExecutionInfo;
        try (XContentParser parser = JsonXContent.jsonXContent.createParser(xContentRegistry, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, phaseDef)) {
            phaseExecutionInfo = PhaseExecutionInfo.parse(parser, currentPhase);
        }
         catch (Exception e) {
            logger.trace(new ParameterizedMessage("exception reading step keys checking for refreshability, phase definition: {}", phaseDef), e);
            return null;
        }
        
        if (phaseExecutionInfo == null || phaseExecutionInfo.getPhase() == null) {
            return null;
        }
        
        return phaseExecutionInfo.getPhase().getActions().values().stream() .flatMap(a -> a.toSteps(client, phaseExecutionInfo.getPhase().getName(), null).stream()) .map(Step::getKey) .collect(Collectors.toCollection(LinkedHashSet::new));
    }
    
    static boolean isIndexPhaseDefinitionUpdatable(final NamedXContentRegistry xContentRegistry, final Client client, final IndexMetadata metadata, final LifecyclePolicy newPolicy) {
        final String index = metadata.getIndex().getName();
        if (eligibleToCheckForRefresh(metadata) == false) {
            logger.debug("[{}] does not contain enough information to check for eligibility of refreshing phase", index);
            return false;
        }
        
        final String policyId = newPolicy.getName();
        final LifecycleExecutionState executionState = LifecycleExecutionState.fromIndexMetadata(metadata);
        final Step.StepKey currentStepKey = LifecycleExecutionState.getCurrentStepKey(executionState);
        final String currentPhase = currentStepKey.getPhase();
        final Set<Step.StepKey> newStepKeys = newPolicy.toSteps(client).stream() .map(Step::getKey) .collect(Collectors.toCollection(LinkedHashSet::new));
        if (newStepKeys.contains(currentStepKey) == false) {
            logger.debug("[{}] updated policy [{}] does not contain the current step key [{}], so the policy phase will not be refreshed", index, policyId, currentStepKey);
            return false;
        }
        
        final String phaseDef = executionState.getPhaseDefinition();
        final Set<Step.StepKey> oldStepKeys = readStepKeys(xContentRegistry, client, phaseDef, currentPhase);
        if (oldStepKeys == null) {
            logger.debug("[{}] unable to parse phase definition for cached policy [{}], policy phase will not be refreshed", index, policyId);
            return false;
        }
        
        final Set<Step.StepKey> oldPhaseStepKeys = oldStepKeys.stream() .filter(sk -> currentPhase.equals(sk.getPhase())) .collect(Collectors.toCollection(LinkedHashSet::new));
        final PhaseExecutionInfo phaseExecutionInfo = new PhaseExecutionInfo(policyId, newPolicy.getPhases().get(currentPhase), 1L, 1L);
        final String peiJson = Strings.toString(phaseExecutionInfo);
        final Set<Step.StepKey> newPhaseStepKeys = readStepKeys(xContentRegistry, client, peiJson, currentPhase);
        if (newPhaseStepKeys == null) {
            logger.debug(new ParameterizedMessage("[{}] unable to parse phase definition for policy [{}] " + "to determine if it could be refreshed", index, policyId));
            return false;
        }
        
        if (newPhaseStepKeys.equals(oldPhaseStepKeys)) {
            logger.debug("[{}] updated policy [{}] contains the same phase step keys and can be refreshed", index, policyId);
            return true;
        }
         else {
            logger.debug("[{}] updated policy [{}] has different phase step keys and will NOT refresh phase " + "definition as it differs too greatly. old: {}, new: {}", index, policyId, oldPhaseStepKeys, newPhaseStepKeys);
            return false;
        }
        
    }
    
    static ClusterState refreshPhaseDefinition(final ClusterState state, final String index, final LifecyclePolicyMetadata updatedPolicy) {
        final IndexMetadata idxMeta = state.metadata().index(index);
        assert eligibleToCheckForRefresh(idxMeta) : "index " + index + " is missing crucial information needed to refresh phase definition";
        logger.trace("[{}] updating cached phase definition for policy [{}]", index, updatedPolicy.getName());
        LifecycleExecutionState currentExState = LifecycleExecutionState.fromIndexMetadata(idxMeta);
        String currentPhase = currentExState.getPhase();
        PhaseExecutionInfo pei = new PhaseExecutionInfo(updatedPolicy.getName(), updatedPolicy.getPolicy().getPhases().get(currentPhase), updatedPolicy.getVersion(), updatedPolicy.getModifiedDate());
        LifecycleExecutionState newExState = LifecycleExecutionState.builder(currentExState) .setPhaseDefinition(Strings.toString(pei, false, false)) .build();
        return IndexLifecycleTransition.newClusterStateWithLifecycleState(idxMeta.getIndex(), state, newExState).build();
    }
    
    static ClusterState updateIndicesForPolicy(final ClusterState state, final NamedXContentRegistry xContentRegistry, final Client client, final LifecyclePolicy oldPolicy, final LifecyclePolicyMetadata newPolicy) {
        assert oldPolicy.getName().equals(newPolicy.getName()) : "expected both policies to have the same id but they were: [" + oldPolicy.getName() + "] vs. [" + newPolicy.getName() + "]";
        if (oldPolicy.equals(newPolicy.getPolicy())) {
            logger.debug("policy [{}] is unchanged and no phase definition refresh is needed", oldPolicy.getName());
            return state;
        }
        
        final List<String> indicesThatCanBeUpdated = StreamSupport.stream(Spliterators.spliteratorUnknownSize(state.metadata().indices().valuesIt(), 0), false) .filter(meta -> newPolicy.getName().equals(LifecycleSettings.LIFECYCLE_NAME_SETTING.get(meta.getSettings()))) .filter(meta -> isIndexPhaseDefinitionUpdatable(xContentRegistry, client, meta, newPolicy.getPolicy())) .map(meta -> meta.getIndex().getName()) .collect(Collectors.toList());
        ClusterState updatedState = state;
        for (String index : indicesThatCanBeUpdated) {
            try {
                updatedState = refreshPhaseDefinition(updatedState, index, newPolicy);
            }
             catch (Exception e) {
                logger.warn(new ParameterizedMessage("[{}] unable to refresh phase definition for updated policy [{}]", index, newPolicy.getName()), e);
            }
            
        }
        
        return updatedState;
    }
    
    protected ClusterBlockException checkBlock(Request request, ClusterState state) {
        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE);
    }
    
}


