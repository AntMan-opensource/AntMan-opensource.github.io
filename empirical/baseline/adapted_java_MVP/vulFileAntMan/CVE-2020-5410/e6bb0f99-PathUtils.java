package org.springframework.cloud.config.server.support;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.util.ResourceUtils;
import org.springframework.util.StringUtils;
public abstract class PathUtils {
	private static final Log logger = LogFactory.getLog(PathUtils.class);
	private PathUtils() {
	}
	
	 public static boolean isInvalidEncodedLocation(String location) {
		if (StringUtils.isEmpty(location)) {
			return false;
		}
		
		if (location.contains("%")) {
			try {
				 String decodedPath = URLDecoder.decode(location, "UTF-8");
				if (isInvalidLocation(decodedPath)) {
					return true;
				}
				
				decodedPath = processPath(decodedPath);
				if (isInvalidLocation(decodedPath)) {
					return true;
				}
				
			}
			
			catch (IllegalArgumentException | UnsupportedEncodingException ex) {
				 }
				 
		}
		
		return isInvalidLocation(location);
	}
	
	private static boolean isInvalidLocation(String location) {
		boolean isInvalid = location.contains("..");
		if (isInvalid && logger.isWarnEnabled()) {
			logger.warn("Location contains \"..\"");
		}
		
		if (!isInvalid) {
			isInvalid = location.contains("#");
			if (isInvalid && logger.isWarnEnabled()) {
				logger.warn("Location contains \"#\"");
			}
			
		}
		
		return isInvalid;
	}
	
	 public static boolean isInvalidEncodedPath(String path) {
		if (path.contains("%")) {
			try {
				 String decodedPath = URLDecoder.decode(path, "UTF-8");
				if (isInvalidPath(decodedPath)) {
					return true;
				}
				
				decodedPath = processPath(decodedPath);
				if (isInvalidPath(decodedPath)) {
					return true;
				}
				
			}
			
			catch (IllegalArgumentException | UnsupportedEncodingException ex) {
				 }
				 
		}
		
		return false;
	}
	
	 protected static String processPath(String path) {
		path = StringUtils.replace(path, "\\", "/");
		path = cleanDuplicateSlashes(path);
		return cleanLeadingSlash(path);
	}
	
	private static String cleanDuplicateSlashes(String path) {
		StringBuilder sb = null;
		char prev = 0;
		for (int i = 0; i < path.length(); i++) {
			char curr = path.charAt(i);
			try {
				if ((curr == '/') && (prev == '/')) {
					if (sb == null) {
						sb = new StringBuilder(path.substring(0, i));
					}
					
					continue;
				}
				
				if (sb != null) {
					sb.append(path.charAt(i));
				}
				
			}
			
			finally {
				prev = curr;
			}
			
		}
		
		return sb != null ? sb.toString() : path;
	}
	
	private static String cleanLeadingSlash(String path) {
		boolean slash = false;
		for (int i = 0; i < path.length(); i++) {
			if (path.charAt(i) == '/') {
				slash = true;
			}
			
			else if (path.charAt(i) > ' ' && path.charAt(i) != 127) {
				if (i == 0 || (i == 1 && slash)) {
					return path;
				}
				
				return (slash ? "/" + path.substring(i) : path.substring(i));
			}
			
		}
		
		return (slash ? "/" : "");
	}
	
	 public static boolean isInvalidPath(String path) {
		if (path.contains("WEB-INF") || path.contains("META-INF")) {
			if (logger.isWarnEnabled()) {
				logger.warn("Path with \"WEB-INF\" or \"META-INF\": [" + path + "]");
			}
			
			return true;
		}
		
		if (path.contains(":/")) {
			String relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);
			if (ResourceUtils.isUrl(relativePath) || relativePath.startsWith("url:")) {
				if (logger.isWarnEnabled()) {
					logger.warn( "Path represents URL or has \"url:\" prefix: [" + path + "]");
				}
				
				return true;
			}
			
		}
		
		if (path.contains("..") && StringUtils.cleanPath(path).contains("../")) {
			if (logger.isWarnEnabled()) {
				logger.warn("Path contains \"../\" after call to StringUtils#cleanPath: [" + path + "]");
			}
			
			return true;
		}
		
		return false;
	}
	
}


