package org.apache.camel.processor.aggregate.jdbc;
import java.io.IOException;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.sql.DataSource;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.OptimisticLockingAggregationRepository;
import org.apache.camel.spi.RecoverableAggregationRepository;
import org.apache.camel.support.service.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Constants;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.support.AbstractLobCreatingPreparedStatementCallback;
import org.springframework.jdbc.support.lob.DefaultLobHandler;
import org.springframework.jdbc.support.lob.LobCreator;
import org.springframework.jdbc.support.lob.LobHandler;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
public class JdbcAggregationRepository extends ServiceSupport implements RecoverableAggregationRepository, OptimisticLockingAggregationRepository {
    protected static final String EXCHANGE = "exchange";
    protected static final String ID = "id";
    protected static final String BODY = "body";
    protected static final String VERSION = "version";
    protected static final String VERSION_PROPERTY = "CamelOptimisticLockVersion";
    private static final Logger LOG = LoggerFactory.getLogger(JdbcAggregationRepository.class);
    private static final Constants PROPAGATION_CONSTANTS = new Constants(TransactionDefinition.class);
    protected JdbcCamelCodec codec = new JdbcCamelCodec();
    protected JdbcTemplate jdbcTemplate;
    protected TransactionTemplate transactionTemplate;
    protected TransactionTemplate transactionTemplateReadOnly;
    protected boolean allowSerializedHeaders;
    private JdbcOptimisticLockingExceptionMapper jdbcOptimisticLockingExceptionMapper = new DefaultJdbcOptimisticLockingExceptionMapper();
    private PlatformTransactionManager transactionManager;
    private DataSource dataSource;
    private int propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED;
    private LobHandler lobHandler = new DefaultLobHandler();
    private String repositoryName;
    private boolean returnOldExchange;
    private long recoveryInterval = 5000;
    private boolean useRecovery = true;
    private int maximumRedeliveries;
    private String deadLetterUri;
    private List<String> headersToStoreAsText;
    private boolean storeBodyAsText;
    public JdbcAggregationRepository() {
    }
    
    public JdbcAggregationRepository(PlatformTransactionManager transactionManager, String repositoryName, DataSource dataSource) {
        this.setRepositoryName(repositoryName);
        this.setTransactionManager(transactionManager);
        this.setDataSource(dataSource);
    }
    
    public final void setRepositoryName(String repositoryName) {
        this.repositoryName = repositoryName;
    }
    
    public final void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    
    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
        jdbcTemplate = new JdbcTemplate(dataSource);
    }
    
    public Exchange add( final CamelContext camelContext, final String correlationId, final Exchange oldExchange, final Exchange newExchange) throws OptimisticLockingException {
        try {
            return add(camelContext, correlationId, newExchange);
        }
         catch (Exception e) {
            if (jdbcOptimisticLockingExceptionMapper != null && jdbcOptimisticLockingExceptionMapper.isOptimisticLocking(e)) {
                throw new OptimisticLockingException();
            }
             else {
                throw RuntimeCamelException.wrapRuntimeCamelException(e);
            }
            
        }
        
    }
    
    public Exchange add(final CamelContext camelContext, final String correlationId, final Exchange exchange) {
        return transactionTemplate.execute(new TransactionCallback<Exchange>() {
            public Exchange doInTransaction(TransactionStatus status) {
                Exchange result = null;
                try {
                    LOG.debug("Adding exchange with key {}", correlationId);
                    boolean present = jdbcTemplate.queryForObject( "SELECT COUNT(1) FROM " + getRepositoryName() + " WHERE " + ID + " = ?", Integer.class, correlationId) != 0;
                    if (isReturnOldExchange() && present) {
                        result = get(correlationId, getRepositoryName(), camelContext);
                    }
                    
                    if (present) {
                        Long versionLong = exchange.getProperty(VERSION_PROPERTY, Long.class);
                        if (versionLong == null) {
                            LOG.debug("Race while inserting record with key {}", correlationId);
                            throw new OptimisticLockingException();
                        }
                         else {
                            long version = versionLong.longValue();
                            LOG.debug("Updating record with key {} and version {}", correlationId, version);
                            update(camelContext, correlationId, exchange, getRepositoryName(), version);
                        }
                        
                    }
                     else {
                        LOG.debug("Inserting record with key {}", correlationId);
                        insert(camelContext, correlationId, exchange, getRepositoryName(), 1L);
                    }
                    
                }
                 catch (Exception e) {
                    throw new RuntimeException( "Error adding to repository " + repositoryName + " with key " + correlationId, e);
                }
                
                return result;
            }
            
        }
        
);
    }
    
    protected void update( final CamelContext camelContext, final String key, final Exchange exchange, String repositoryName, Long version) throws Exception {
        StringBuilder queryBuilder = new StringBuilder() .append("UPDATE ").append(repositoryName) .append(" SET ") .append(EXCHANGE).append(" = ?") .append(", ") .append(VERSION).append(" = ?");
        if (storeBodyAsText) {
            queryBuilder.append(", ").append(BODY).append(" = ?");
        }
        
        if (hasHeadersToStoreAsText()) {
            for (String headerName : headersToStoreAsText) {
                queryBuilder.append(", ").append(headerName).append(" = ?");
            }
            
        }
        
        queryBuilder.append(" WHERE ") .append(ID).append(" = ?") .append(" AND ") .append(VERSION).append(" = ?");
        String sql = queryBuilder.toString();
        updateHelper(camelContext, key, exchange, sql, version);
    }
    
    protected void insert( final CamelContext camelContext, final String correlationId, final Exchange exchange, String repositoryName, Long version) throws Exception {
        int totalParameterIndex = 3;
        StringBuilder queryBuilder = new StringBuilder() .append("INSERT INTO ").append(repositoryName) .append('(').append(EXCHANGE) .append(", ").append(ID) .append(", ").append(VERSION);
        if (storeBodyAsText) {
            queryBuilder.append(", ").append(BODY);
            totalParameterIndex++;
        }
        
        if (hasHeadersToStoreAsText()) {
            for (String headerName : headersToStoreAsText) {
                queryBuilder.append(", ").append(headerName);
                totalParameterIndex++;
            }
            
        }
        
        queryBuilder.append(") VALUES (");
        queryBuilder.append("?, ".repeat(totalParameterIndex - 1));
        queryBuilder.append("?)");
        String sql = queryBuilder.toString();
        insertHelper(camelContext, correlationId, exchange, sql, version);
    }
    
    protected int insertHelper( final CamelContext camelContext, final String key, final Exchange exchange, String sql, final Long version) throws Exception {
        final byte[] data = codec.marshallExchange(exchange, allowSerializedHeaders);
        Integer insertCount = jdbcTemplate.execute(sql, new AbstractLobCreatingPreparedStatementCallback(getLobHandler()) {
                    protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
                        int totalParameterIndex = 0;
                        lobCreator.setBlobAsBytes(ps, ++totalParameterIndex, data);
                        ps.setString(++totalParameterIndex, key);
                        ps.setLong(++totalParameterIndex, version);
                        if (storeBodyAsText) {
                            ps.setString(++totalParameterIndex, exchange.getIn().getBody(String.class));
                        }
                        
                        if (hasHeadersToStoreAsText()) {
                            for (String headerName : headersToStoreAsText) {
                                String headerValue = exchange.getIn().getHeader(headerName, String.class);
                                ps.setString(++totalParameterIndex, headerValue);
                            }
                            
                        }
                        
                    }
                    
                }
                
);
        return insertCount == null ? 0 : insertCount;
    }
    
    protected int updateHelper( final CamelContext camelContext, final String key, final Exchange exchange, String sql, final Long version) throws Exception {
        final byte[] data = codec.marshallExchange(exchange, allowSerializedHeaders);
        Integer updateCount = jdbcTemplate.execute(sql, new AbstractLobCreatingPreparedStatementCallback(getLobHandler()) {
                    protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
                        int totalParameterIndex = 0;
                        lobCreator.setBlobAsBytes(ps, ++totalParameterIndex, data);
                        ps.setLong(++totalParameterIndex, version + 1);
                        if (storeBodyAsText) {
                            ps.setString(++totalParameterIndex, exchange.getIn().getBody(String.class));
                        }
                        
                        if (hasHeadersToStoreAsText()) {
                            for (String headerName : headersToStoreAsText) {
                                String headerValue = exchange.getIn().getHeader(headerName, String.class);
                                ps.setString(++totalParameterIndex, headerValue);
                            }
                            
                        }
                        
                        ps.setString(++totalParameterIndex, key);
                        ps.setLong(++totalParameterIndex, version);
                    }
                    
                }
                
);
        if (updateCount == 1) {
            return updateCount;
        }
         else {
            throw new OptimisticLockingException();
        }
        
    }
    
    public Exchange get(final CamelContext camelContext, final String correlationId) {
        Exchange result = get(correlationId, getRepositoryName(), camelContext);
        LOG.debug("Getting key {} -> {}", correlationId, result);
        return result;
    }
    
    private Exchange get(final String key, final String repositoryName, final CamelContext camelContext) {
        return transactionTemplateReadOnly.execute(new TransactionCallback<Exchange>() {
            public Exchange doInTransaction(TransactionStatus status) {
                try {
                    Map<String, Object> columns = jdbcTemplate.queryForMap( String.format("SELECT %1$s, %2$s FROM %3$s WHERE %4$s=?", EXCHANGE, VERSION, repositoryName, ID), new Object[] { key }, new int[] { Types.VARCHAR });
                    byte[] marshalledExchange = (byte[]) columns.get(EXCHANGE);
                    long version;
                    Object versionObj = columns.get(VERSION);
                    if (versionObj instanceof BigDecimal) {
                        version = ((BigDecimal) versionObj).longValue();
                    }
                     else {
                        version = (long) versionObj;
                    }
                    
                    Exchange result = codec.unmarshallExchange(camelContext, marshalledExchange);
                    result.setProperty(VERSION_PROPERTY, version);
                    return result;
                }
                 catch (EmptyResultDataAccessException ex) {
                    return null;
                }
                 catch (IOException ex) {
                    throw new RuntimeException("Error getting key " + key + " from repository " + repositoryName, ex);
                }
                 catch (ClassNotFoundException ex) {
                    throw new RuntimeException(ex);
                }
                
            }
            
        }
        
);
    }
    
    public void remove(final CamelContext camelContext, final String correlationId, final Exchange exchange) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                final String confirmKey = exchange.getExchangeId();
                final long version = exchange.getProperty(VERSION_PROPERTY, Long.class);
                try {
                    LOG.debug("Removing key {}", correlationId);
                    jdbcTemplate.update("DELETE FROM " + getRepositoryName() + " WHERE " + ID + " = ? AND " + VERSION + " = ?", correlationId, version);
                    insert(camelContext, confirmKey, exchange, getRepositoryNameCompleted(), version);
                    LOG.debug("Removed key {}", correlationId);
                }
                 catch (Exception e) {
                    throw new RuntimeException("Error removing key " + correlationId + " from repository " + repositoryName, e);
                }
                
            }
            
        }
        
);
    }
    
    public void confirm(final CamelContext camelContext, final String exchangeId) {
        confirmWithResult(camelContext, exchangeId);
    }
    
    public boolean confirmWithResult(final CamelContext camelContext, final String exchangeId) {
        return transactionTemplate.execute(new TransactionCallback<Boolean>() {
            public Boolean doInTransaction(TransactionStatus status) {
                LOG.debug("Confirming exchangeId {}", exchangeId);
                final int mustBeOne = jdbcTemplate .update("DELETE FROM " + getRepositoryNameCompleted() + " WHERE " + ID + " = ?", exchangeId);
                if (mustBeOne != 1) {
                    LOG.error("problem removing row {} from {} - DELETE statement did not return 1 but {}", exchangeId, getRepositoryNameCompleted(), mustBeOne);
                    return false;
                }
                
                return true;
            }
            
        }
        
);
    }
    
    public Set<String> getKeys() {
        return getKeys(getRepositoryName());
    }
    
    public Set<String> scan(CamelContext camelContext) {
        return getKeys(getRepositoryNameCompleted());
    }
    
    protected Set<String> getKeys(final String repositoryName) {
        return transactionTemplateReadOnly.execute(new TransactionCallback<LinkedHashSet<String>>() {
            public LinkedHashSet<String> doInTransaction(TransactionStatus status) {
                List<String> keys = jdbcTemplate.query("SELECT " + ID + " FROM " + repositoryName, new RowMapper<String>() {                             public String mapRow(ResultSet rs, int rowNum) throws SQLException { String id = rs.getString(ID);
                                LOG.trace("getKey {}", id);
                                return id;
                            }
                            
                        }
                        
);
                return new LinkedHashSet<>(keys);
            }
            
        }
        
);
    }
    
    public Exchange recover(CamelContext camelContext, String exchangeId) {
        Exchange answer = get(exchangeId, getRepositoryNameCompleted(), camelContext);
        LOG.debug("Recovering exchangeId {} -> {}", exchangeId, answer);
        return answer;
    }
    
    public void setRecoveryInterval(long interval, TimeUnit timeUnit) {
        this.recoveryInterval = timeUnit.toMillis(interval);
    }
    
    public void setRecoveryInterval(long interval) {
        this.recoveryInterval = interval;
    }
    
    public long getRecoveryIntervalInMillis() {
        return recoveryInterval;
    }
    
    public boolean isUseRecovery() {
        return useRecovery;
    }
    
    public void setUseRecovery(boolean useRecovery) {
        this.useRecovery = useRecovery;
    }
    
    public int getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    
    public void setMaximumRedeliveries(int maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    
    public String getDeadLetterUri() {
        return deadLetterUri;
    }
    
    public void setDeadLetterUri(String deadLetterUri) {
        this.deadLetterUri = deadLetterUri;
    }
    
    public boolean isReturnOldExchange() {
        return returnOldExchange;
    }
    
    public void setReturnOldExchange(boolean returnOldExchange) {
        this.returnOldExchange = returnOldExchange;
    }
    
    public void setJdbcCamelCodec(JdbcCamelCodec codec) {
        this.codec = codec;
    }
    
    public boolean hasHeadersToStoreAsText() {
        return this.headersToStoreAsText != null && !this.headersToStoreAsText.isEmpty();
    }
    
    public List<String> getHeadersToStoreAsText() {
        return headersToStoreAsText;
    }
    
    public void setHeadersToStoreAsText(List<String> headersToStoreAsText) {
        this.headersToStoreAsText = headersToStoreAsText;
    }
    
    public boolean isStoreBodyAsText() {
        return storeBodyAsText;
    }
    
    public void setStoreBodyAsText(boolean storeBodyAsText) {
        this.storeBodyAsText = storeBodyAsText;
    }
    
    public boolean isAllowSerializedHeaders() {
        return allowSerializedHeaders;
    }
    
    public void setAllowSerializedHeaders(boolean allowSerializedHeaders) {
        this.allowSerializedHeaders = allowSerializedHeaders;
    }
    
    public int getPropagationBehavior() {
        return propagationBehavior;
    }
    
    public void setPropagationBehavior(int propagationBehavior) {
        this.propagationBehavior = propagationBehavior;
    }
    
    public void setPropagationBehaviorName(String propagationBehaviorName) {
        if (!propagationBehaviorName.startsWith(DefaultTransactionDefinition.PREFIX_PROPAGATION)) {
            throw new IllegalArgumentException("Only propagation constants allowed");
        }
        
        setPropagationBehavior(PROPAGATION_CONSTANTS.asNumber(propagationBehaviorName).intValue());
    }
    
    public LobHandler getLobHandler() {
        return lobHandler;
    }
    
    public void setLobHandler(LobHandler lobHandler) {
        this.lobHandler = lobHandler;
    }
    
    public JdbcOptimisticLockingExceptionMapper getJdbcOptimisticLockingExceptionMapper() {
        return jdbcOptimisticLockingExceptionMapper;
    }
    
    public void setJdbcOptimisticLockingExceptionMapper( JdbcOptimisticLockingExceptionMapper jdbcOptimisticLockingExceptionMapper) {
        this.jdbcOptimisticLockingExceptionMapper = jdbcOptimisticLockingExceptionMapper;
    }
    
    public String getRepositoryName() {
        return repositoryName;
    }
    
    public String getRepositoryNameCompleted() {
        return getRepositoryName() + "_completed";
    }
    
    protected void doInit() throws Exception {
        super.doInit();
        ObjectHelper.notNull(repositoryName, "RepositoryName");
        ObjectHelper.notNull(transactionManager, "TransactionManager");
        ObjectHelper.notNull(dataSource, "DataSource");
        transactionTemplate = new TransactionTemplate(transactionManager);
        transactionTemplate.setPropagationBehavior(propagationBehavior);
        transactionTemplateReadOnly = new TransactionTemplate(transactionManager);
        transactionTemplateReadOnly.setPropagationBehavior(propagationBehavior);
        transactionTemplateReadOnly.setReadOnly(true);
    }
    
    private int rowCount(final String repository) {
        return jdbcTemplate.queryForObject("SELECT COUNT(1) FROM " + repository, Integer.class);
    }
    
    protected void doStart() throws Exception {
        super.doStart();
        final int current = rowCount(getRepositoryName());
        final int completed = rowCount(getRepositoryNameCompleted());
        if (current > 0) {
            LOG.info("On startup there are {} aggregate exchanges (not completed) in repository: {}", current, getRepositoryName());
        }
         else {
            LOG.info("On startup there are no existing aggregate exchanges (not completed) in repository: {}", getRepositoryName());
        }
        
        if (completed > 0) {
            LOG.warn("On startup there are {} completed exchanges to be recovered in repository: {}", completed, getRepositoryNameCompleted());
        }
         else {
            LOG.info("On startup there are no completed exchanges to be recovered in repository: {}", getRepositoryNameCompleted());
        }
        
    }
    
    protected void doStop() throws Exception {
    }
    
}


