package org.apache.cassandra.cql3.functions;
import java.security.AccessControlException;
import java.security.AllPermission;
import java.security.CodeSource;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.Permissions;
import java.security.Policy;
import java.security.ProtectionDomain;
import java.util.Collections;
import java.util.Enumeration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.spi.TurboFilterList;
import ch.qos.logback.classic.turbo.ReconfigureOnChangeFilter;
import ch.qos.logback.classic.turbo.TurboFilter;
public final class ThreadAwareSecurityManager extends SecurityManager {
    static final PermissionCollection noPermissions = new PermissionCollection() {         public void add(Permission permission) { throw new UnsupportedOperationException();
        }
        
        public boolean implies(Permission permission) {
            return false;
        }
        
        public Enumeration<Permission> elements() {
            return Collections.emptyEnumeration();
        }
        
    };
    private static final RuntimePermission CHECK_MEMBER_ACCESS_PERMISSION = new RuntimePermission("accessDeclaredMembers");
    private static final RuntimePermission MODIFY_THREAD_PERMISSION = new RuntimePermission("modifyThread");
    private static final RuntimePermission MODIFY_THREADGROUP_PERMISSION = new RuntimePermission("modifyThreadGroup");
    private static volatile boolean installed;
    public static void install() {
        if (installed){
            return;
}
        System.setSecurityManager(new ThreadAwareSecurityManager());
        Logger l = LoggerFactory.getLogger(ThreadAwareSecurityManager.class);
        ch.qos.logback.classic.Logger logbackLogger = (ch.qos.logback.classic.Logger) l;
        LoggerContext ctx = logbackLogger.getLoggerContext();
        TurboFilterList turboFilterList = ctx.getTurboFilterList();
        for (int i = 0; i < turboFilterList.size(); i++){
            TurboFilter turboFilter = turboFilterList.get(i);
            if (turboFilter instanceof ReconfigureOnChangeFilter){
                ReconfigureOnChangeFilter reconfigureOnChangeFilter = (ReconfigureOnChangeFilter) turboFilter;
                turboFilterList.set(i, new SMAwareReconfigureOnChangeFilter(reconfigureOnChangeFilter));
                break;
            }
            
        }
        
        installed = true;
    }
    
    private static class SMAwareReconfigureOnChangeFilter extends ReconfigureOnChangeFilter {
        SMAwareReconfigureOnChangeFilter(ReconfigureOnChangeFilter reconfigureOnChangeFilter) {
            setRefreshPeriod(reconfigureOnChangeFilter.getRefreshPeriod());
            setName(reconfigureOnChangeFilter.getName());
            setContext(reconfigureOnChangeFilter.getContext());
            if (reconfigureOnChangeFilter.isStarted()){
                reconfigureOnChangeFilter.stop();
                start();
            }
            
        }
        
        protected boolean changeDetected(long now) {
            if (isSecuredThread()){
                return false;
}
            return super.changeDetected(now);
        }
        
    }
    
    static {
        Policy.setPolicy(new Policy() {
            public PermissionCollection getPermissions(CodeSource codesource) {
                Permissions perms = new Permissions();
                if (codesource == null || codesource.getLocation() == null){
                    return perms;
}
                switch (codesource.getLocation().getProtocol()){
                    case "file":
                        perms.add(new AllPermission());
                        return perms;
                }
                
                return perms;
            }
            
            public PermissionCollection getPermissions(ProtectionDomain domain) {
                return getPermissions(domain.getCodeSource());
            }
            
            public boolean implies(ProtectionDomain domain, Permission permission) {
                CodeSource codesource = domain.getCodeSource();
                if (codesource == null || codesource.getLocation() == null){
                    return false;
}
                switch (codesource.getLocation().getProtocol()){
                    case "file":
                        return true;
                }
                
                return false;
            }
            
        }
        
);
    }
    
    private static final ThreadLocal<Boolean> initializedThread = new ThreadLocal<>();
    private ThreadAwareSecurityManager() {
    }
    
    private static boolean isSecuredThread() {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        if (!(tg instanceof SecurityThreadGroup)){
            return false;
}
        Boolean threadInitialized = initializedThread.get();
        if (threadInitialized == null){
            initializedThread.set(false);
            ((SecurityThreadGroup) tg).initializeThread();
            initializedThread.set(true);
            threadInitialized = true;
        }
        
        return threadInitialized;
    }
    
    public void checkAccess(Thread t) {
        if (isSecuredThread()){
            throw new AccessControlException("access denied: " + MODIFY_THREAD_PERMISSION, MODIFY_THREAD_PERMISSION);
}
        super.checkAccess(t);
    }
    
    public void checkAccess(ThreadGroup g) {
        if (isSecuredThread()){
            throw new AccessControlException("access denied: " + MODIFY_THREADGROUP_PERMISSION, MODIFY_THREADGROUP_PERMISSION);
}
        super.checkAccess(g);
    }
    
    public void checkPermission(Permission perm) {
        if (!isSecuredThread()){
            return;
}
        if (CHECK_MEMBER_ACCESS_PERMISSION.equals(perm)){
            return;
}
        super.checkPermission(perm);
    }
    
    public void checkPermission(Permission perm, Object context) {
        if (isSecuredThread()){
            super.checkPermission(perm, context);
}
    }
    
    public void checkPackageAccess(String pkg) {
        if (!isSecuredThread()){
            return;
}
        if (!((SecurityThreadGroup) Thread.currentThread().getThreadGroup()).isPackageAllowed(pkg)){
            RuntimePermission perm = new RuntimePermission("accessClassInPackage." + pkg);
            throw new AccessControlException("access denied: " + perm, perm);
        }
        
        super.checkPackageAccess(pkg);
    }
    
}


