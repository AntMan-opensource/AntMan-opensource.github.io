package com.sonyericsson.jenkins.plugins.bfa.model.indication;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.sonyericsson.jenkins.plugins.bfa.Messages;
import com.sonyericsson.jenkins.plugins.bfa.PluginImpl;
import com.sonyericsson.jenkins.plugins.bfa.model.BuildLogFailureReader;
import com.sonyericsson.jenkins.plugins.bfa.model.FailureReader;
import hudson.Extension;
import hudson.matrix.MatrixConfiguration;
import hudson.matrix.MatrixProject;
import hudson.model.Hudson;
import hudson.model.Item;
import hudson.model.ItemGroup;
import hudson.model.Job;
import hudson.model.Run;
import hudson.util.FormValidation;
import jenkins.model.Jenkins;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.interceptor.RequirePOST;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, property = "@class", visible = true)
@JsonIgnoreProperties(ignoreUnknown = true)
public class BuildLogIndication extends Indication {
    private static final long serialVersionUID = -2889792693081908532L;
    private transient Pattern compiled = null;
    public BuildLogIndication(@JsonProperty("pattern") String pattern) {
        super(pattern);
    }
    
    public FailureReader getReader() {
        return new BuildLogFailureReader(this);
    }
    
    public Pattern getPattern() {
        if (compiled == null) {
            compiled = Pattern.compile(getUserProvidedExpression());
        }
        
        return compiled;
    }
    
    public IndicationDescriptor getDescriptor() {
        return Hudson.getInstance().getDescriptorByType(BuildLogIndicationDescriptor.class);
    }
    
    public static class BuildLogIndicationDescriptor extends IndicationDescriptor {
        private static final Pattern URL_PATTERN = Pattern.compile("^(.*/)([^/]+)/([^/]+)/([^/]+)/?$");
        private static final int NUM_OF_URL_PARTS = 4;
        public enum StringBuildId {
            LAST_BUILD("lastBuild") {
                public Run getBuild(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project) {
                    return project.getLastBuild();
                }
                
            }, LAST_FAILED_BUILD("lastFailedBuild") {
                public Run getBuild(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project) {
                    return project.getLastFailedBuild();
                }
                
            }, LAST_UNSUCCESSFUL_BUILD("lastUnsuccessfulBuild") {
                public Run getBuild(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project) {
                    return project.getLastUnsuccessfulBuild();
                }
                
            }, LAST_SUCCESSFUL_BUILD("lastSuccessfulBuild") {
                public Run getBuild(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project) {
                    return project.getLastSuccessfulBuild();
                }
                
            };
            private final String name;
            StringBuildId(String name) {
                this.name = name;
            }
            
            public String getName() {
                return name;
            }
            
            public static StringBuildId fromString(String str) {
                if (str != null) {
                    for (StringBuildId stringBuildId : values()) {
                        if (str.equals(stringBuildId.getName())) {
                            return stringBuildId;
                        }
                        
                    }
                    
                }
                
                return null;
            }
            
            public abstract Run getBuild(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project);
        }
        
        public String getDisplayName() {
            return Messages.BuildLogIndication_DisplayName();
        }
        
        public FormValidation doMatchText( @QueryParameter("pattern") final String testPattern, @QueryParameter("testText") String testText, @QueryParameter("textSourceIsUrl") final boolean textSourceIsUrl) {
            Jenkins.get().checkPermission(PluginImpl.UPDATE_PERMISSION);
            if (textSourceIsUrl) {
                testText = testText.replaceAll("/\\./", "/").replaceAll("/view/change-requests", "");
                Matcher urlMatcher = URL_PATTERN.matcher(testText);
                if (urlMatcher.matches()) {
                    String[] urlParts = new String[NUM_OF_URL_PARTS];
                    for (int i = 0; i < urlParts.length; i++) {
                        urlParts[i] = urlMatcher.group(i + 1);
                    }
                    
                    Run build = null;
                    ItemGroup getItemInstance;
                    if (urlParts[0].split("/job/").length > 1) {
                        StringBuilder fullFolderName = new StringBuilder();
                        String[] interestingJobParts = urlParts[0].split("/job/", 2);
                        String[] jobParts = interestingJobParts[interestingJobParts.length - 1].split("/job/");
                        for (String part: jobParts) {
                            fullFolderName.append("/").append(part);
                        }
                        
                        getItemInstance = (ItemGroup)Jenkins.getInstance().getItemByFullName(fullFolderName.toString());
                    }
                     else {
                        getItemInstance = (ItemGroup)Jenkins.getInstance();
                    }
                    
                    if (getItemInstance == null) {
                        throw new AssertionError("Folder not found!");
                    }
                    
                    final Item itemFromPart2 = getItemInstance.getItem(urlParts[2]);
                    if (itemFromPart2 instanceof Job && isValidBuildId(urlParts[3])) {
                        Job project = (Job)itemFromPart2;
                        build = getBuildById(project, urlParts[3]);
                    }
                     else {
                        final Item itemFromPart1 = getItemInstance.getItem(urlParts[1]);
                        if (itemFromPart1 instanceof MatrixProject && isValidBuildId(urlParts[3])) {
                            MatrixProject project = (MatrixProject)itemFromPart1;
                            MatrixConfiguration configuration = project.getItem(urlParts[2]);
                            build = getBuildById(configuration, urlParts[3]);
                        }
                         else if (itemFromPart1 instanceof MatrixProject && isValidBuildId(urlParts[2])) {
                            MatrixProject matrixProject = (MatrixProject)itemFromPart1;
                            MatrixConfiguration configuration = matrixProject.getItem(urlParts[3]);
                            build = getBuildById(configuration, urlParts[2]);
                        }
                        
                    }
                    
                    if (build != null) {
                        try {
                            final FailureReader failureReader = getFailureReader(testPattern);
                            final FoundIndication foundIndication = failureReader.scan(build);
                            if (foundIndication == null) {
                                return FormValidation.warning(Messages.StringDoesNotMatchPattern());
                            }
                            
                            return FormValidation.okWithMarkup(foundIndication.getFirstMatchingLine());
                        }
                         catch (IOException e) {
                            return FormValidation.error(Messages.FailedToScanFile_Error());
                        }
                        
                    }
                    
                }
                
                return FormValidation.error(Messages.InvalidURL_Error());
            }
             else {
                try {
                    final Pattern pattern = Pattern.compile(testPattern);
                    final Matcher matcher = pattern.matcher(new FailureReader.InterruptibleCharSequence(testText));
                    if (matcher.matches()) {
                        return FormValidation.ok(Messages.StringMatchesPattern());
                    }
                    
                    return FormValidation.warning(Messages.StringDoesNotMatchPattern());
                }
                 catch (PatternSyntaxException e) {
                    return FormValidation.error(Messages.InvalidPattern_Error());
                }
                
            }
            
        }
        
        private boolean isValidBuildId(String id) {
            return id.matches("\\d+") || StringBuildId.fromString(id) != null;
        }
        
        private Run getBuildById(Job<? extends Job<?, ?>, ? extends Run<?, ?>> project, String id) {
            if (id.matches("\\d+")) {
                return project.getBuildByNumber(Integer.parseInt(id));
            }
             else {
                StringBuildId stringBuildId = StringBuildId.fromString(id);
                if (stringBuildId != null) {
                    return stringBuildId.getBuild(project);
                }
                
                return null;
            }
            
        }
        
        protected FailureReader getFailureReader(final String testPattern) {
            return new BuildLogFailureReader(new BuildLogIndication(testPattern));
        }
        
    }
    
}


