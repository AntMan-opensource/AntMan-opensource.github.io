package reactor.netty.http.client;
import java.net.URI;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.HttpHeaderNames;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.LastHttpContent;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshakeException;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;
import io.netty.handler.codec.http.websocketx.WebSocketCloseStatus;
import org.reactivestreams.Publisher;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Sinks;
import reactor.netty.FutureMono;
import reactor.netty.NettyOutbound;
import reactor.netty.ReactorNetty;
import reactor.netty.http.websocket.WebsocketInbound;
import reactor.netty.http.websocket.WebsocketOutbound;
import reactor.util.annotation.Nullable;
import static reactor.netty.ReactorNetty.format;
final class WebsocketClientOperations extends HttpClientOperations implements WebsocketInbound, WebsocketOutbound {
	final WebSocketClientHandshaker handshaker;
	final Sinks.One<WebSocketCloseStatus> onCloseState;
	final boolean proxyPing;
	volatile int closeSent;
	final static String INBOUND_CANCEL_LOG = "WebSocket client inbound receiver cancelled, closing Websocket.";
	WebsocketClientOperations(URI currentURI, WebsocketClientSpec websocketClientSpec, HttpClientOperations replaced) {
		super(replaced);
		this.proxyPing = websocketClientSpec.handlePing();
		Channel channel = channel();
		onCloseState = Sinks.unsafe().one();
		String subprotocols = websocketClientSpec.protocols();
		handshaker = WebSocketClientHandshakerFactory.newHandshaker(currentURI, websocketClientSpec.version(), subprotocols != null && !subprotocols.isEmpty() ? subprotocols : null, true, replaced.requestHeaders() .remove(HttpHeaderNames.HOST), websocketClientSpec.maxFramePayloadLength());
		handshaker.handshake(channel) .addListener(f -> {
			          markPersistent(false);
			          channel.read();
		          }
		          
);
	}
	
	public HttpHeaders headers() {
		return responseHeaders();
	}
	
	public boolean isWebsocket() {
		return true;
	}
	
	public String selectedSubprotocol() {
		return handshaker.actualSubprotocol();
	}
	
	public void onInboundNext(ChannelHandlerContext ctx, Object msg) {
		if (msg instanceof FullHttpResponse) {
			started = true;
			channel().pipeline() .remove(HttpObjectAggregator.class);
			FullHttpResponse response = (FullHttpResponse) msg;
			setNettyResponse(response);
			if (notRedirected(response)) {
				try {
					handshaker.finishHandshake(channel(), response);
					 ctx.read();
					listener().onStateChange(this, HttpClientState.RESPONSE_RECEIVED);
				}
				
				catch (Exception e) {
					onInboundError(e);
					 ctx.close();
				}
				
				finally {
					 response.content() .release();
				}
				
			}
			
			else {
				response.content() .release();
				listener().onUncaughtException(this, redirecting);
			}
			
			return;
		}
		
		if (!this.proxyPing && msg instanceof PingWebSocketFrame) {
			 ctx.writeAndFlush(new PongWebSocketFrame(((PingWebSocketFrame) msg).content()));
			ctx.read();
			return;
		}
		
		if (msg instanceof CloseWebSocketFrame && ((CloseWebSocketFrame) msg).isFinalFragment()) {
			if (log.isDebugEnabled()) {
				log.debug(format(channel(), "CloseWebSocketFrame detected. Closing Websocket"));
			}
			
			CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(true, ((CloseWebSocketFrame) msg).rsv(), ((CloseWebSocketFrame) msg).content());
			if (closeFrame.statusCode() != -1) {
				sendCloseNow(closeFrame);
			}
			
			else {
				sendCloseNow(closeFrame, WebSocketCloseStatus.EMPTY);
			}
			
			onInboundComplete();
		}
		
		else if (msg != LastHttpContent.EMPTY_LAST_CONTENT) {
			super.onInboundNext(ctx, msg);
		}
		
	}
	
	protected void onInboundCancel() {
		if (log.isDebugEnabled()) {
			log.debug(format(channel(), INBOUND_CANCEL_LOG));
		}
		
		sendCloseNow(new CloseWebSocketFrame(), WebSocketCloseStatus.ABNORMAL_CLOSURE);
	}
	
	protected void onInboundClose() {
		if (handshaker.isHandshakeComplete()) {
			terminate();
		}
		
		else {
			onInboundError(new WebSocketClientHandshakeException("Connection prematurely closed BEFORE " + "opening handshake is complete."));
		}
		
	}
	
	protected void onOutboundComplete() {
	}
	
	protected void onOutboundError(Throwable err) {
		if (channel().isActive()) {
			if (log.isDebugEnabled()) {
				log.debug(format(channel(), "Outbound error happened"), err);
			}
			
			sendCloseNow(new CloseWebSocketFrame(WebSocketCloseStatus.PROTOCOL_ERROR));
		}
		
	}
	
	public NettyOutbound send(Publisher<? extends ByteBuf> dataStream) {
		return sendObject(Flux.from(dataStream).map(bytebufToWebsocketFrame));
	}
	
	public Mono<Void> sendClose() {
		return sendClose(new CloseWebSocketFrame());
	}
	
	public Mono<Void> sendClose(int rsv) {
		return sendClose(new CloseWebSocketFrame(true, rsv));
	}
	
	public Mono<Void> sendClose(int statusCode, @Nullable String reasonText) {
		return sendClose(new CloseWebSocketFrame(statusCode, reasonText));
	}
	
	public Mono<Void> sendClose(int rsv, int statusCode, @Nullable String reasonText) {
		return sendClose(new CloseWebSocketFrame(true, rsv, statusCode, reasonText));
	}
	
	public Mono<WebSocketCloseStatus> receiveCloseStatus() {
		return onCloseState.asMono().or((Mono) onTerminate());
	}
	
	Mono<Void> sendClose(CloseWebSocketFrame frame) {
		if (CLOSE_SENT.get(this) == 0) {
			 return FutureMono.deferFuture(() -> {
				if (CLOSE_SENT.getAndSet(this, 1) == 0) {
					discard();
					 onCloseState.tryEmitValue(new WebSocketCloseStatus(frame.statusCode(), frame.reasonText()));
					return channel().writeAndFlush(frame) .addListener(ChannelFutureListener.CLOSE);
				}
				
				frame.release();
				return channel().newSucceededFuture();
			}
).doOnCancel(() -> ReactorNetty.safeRelease(frame));
		}
		
		frame.release();
		return Mono.empty();
	}
	
	void sendCloseNow(CloseWebSocketFrame frame) {
		sendCloseNow(frame, new WebSocketCloseStatus(frame.statusCode(), frame.reasonText()));
	}
	
	@SuppressWarnings("FutureReturnValueIgnored")
	void sendCloseNow(CloseWebSocketFrame frame, WebSocketCloseStatus closeStatus) {
		if (!frame.isFinalFragment()) {
			 channel().writeAndFlush(frame);
			return;
		}
		
		if (CLOSE_SENT.getAndSet(this, 1) == 0) {
			 onCloseState.tryEmitValue(closeStatus);
			channel().writeAndFlush(frame) .addListener(ChannelFutureListener.CLOSE);
		}
		
		else {
			frame.release();
		}
		
	}
	
	static final AtomicIntegerFieldUpdater<WebsocketClientOperations> CLOSE_SENT = AtomicIntegerFieldUpdater.newUpdater(WebsocketClientOperations.class, "closeSent");
}

