package reactor.netty;
import java.net.SocketAddress;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.time.ZoneId;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.ByteBufHolder;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.nio.NioEventLoop;
import io.netty.handler.ssl.SslHandler;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleState;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.handler.timeout.IdleStateHandler;
import io.netty.util.AttributeKey;
import io.netty.util.ReferenceCounted;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscription;
import reactor.core.CorePublisher;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.SignalType;
import reactor.pool.AllocationStrategy;
import reactor.pool.PoolBuilder;
import reactor.pool.introspection.SamplingAllocationStrategy;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;
import reactor.util.context.Context;
import reactor.util.context.ContextView;
import static java.util.Objects.requireNonNull;
public final class ReactorNetty {
	 static final boolean LOG_CHANNEL_INFO = Boolean.parseBoolean(System.getProperty("reactor.netty.logChannelInfo", "true"));
	 public static final String IO_WORKER_COUNT = "reactor.netty.ioWorkerCount";
	 public static final String IO_SELECT_COUNT = "reactor.netty.ioSelectCount";
	 public static final String UDP_IO_THREAD_COUNT = "reactor.netty.udp.ioThreadCount";
	 public static final String SHUTDOWN_QUIET_PERIOD = "reactor.netty.ioShutdownQuietPeriod";
	 public static final String SHUTDOWN_TIMEOUT = "reactor.netty.ioShutdownTimeout";
	 public static final String NATIVE = "reactor.netty.native";
	 public static final String POOL_MAX_CONNECTIONS = "reactor.netty.pool.maxConnections";
	 public static final String POOL_ACQUIRE_TIMEOUT = "reactor.netty.pool.acquireTimeout";
	 public static final String POOL_MAX_IDLE_TIME = "reactor.netty.pool.maxIdleTime";
	 public static final String POOL_MAX_LIFE_TIME = "reactor.netty.pool.maxLifeTime";
	 public static final String POOL_LEASING_STRATEGY = "reactor.netty.pool.leasingStrategy";
	 public static final String POOL_GET_PERMITS_SAMPLING_RATE = "reactor.netty.pool.getPermitsSamplingRate";
	 public static final String POOL_RETURN_PERMITS_SAMPLING_RATE = "reactor.netty.pool.returnPermitsSamplingRate";
	 public static final String SSL_HANDSHAKE_TIMEOUT = "reactor.netty.tcp.sslHandshakeTimeout";
	 public static final String SSL_CLIENT_DEBUG = "reactor.netty.tcp.ssl.client.debug";
	 public static final String SSL_SERVER_DEBUG = "reactor.netty.tcp.ssl.server.debug";
	 public static final String ACCESS_LOG_ENABLED = "reactor.netty.http.server.accessLogEnabled";
	 public static final ZoneId ZONE_ID_SYSTEM = ZoneId.systemDefault();
	 public static void safeRelease(Object msg) {
		if (msg instanceof ReferenceCounted) {
			ReferenceCounted referenceCounted = (ReferenceCounted) msg;
			if (referenceCounted.refCnt() > 0) {
				referenceCounted.release();
			}
			
		}
		
	}
	
	 public static String format(Channel channel, String msg) {
		Objects.requireNonNull(channel, "channel");
		Objects.requireNonNull(msg, "msg");
		if (LOG_CHANNEL_INFO) {
			String channelStr;
			StringBuilder result;
			Connection connection = Connection.from(channel);
			if (connection instanceof ChannelOperationsId) {
				channelStr = ((ChannelOperationsId) connection).asLongText();
				if (channelStr.charAt(0) != TRACE_ID_PREFIX) {
					result = new StringBuilder(1 + channelStr.length() + 2 + msg.length()) .append(CHANNEL_ID_PREFIX) .append(channelStr) .append(CHANNEL_ID_SUFFIX_1);
				}
				
				else {
					result = new StringBuilder(channelStr.length() + 1 + msg.length()) .append(channelStr) .append(CHANNEL_ID_SUFFIX_2);
				}
				
				return result.append(msg) .toString();
			}
			
			else {
				channelStr = channel.toString();
				if (channelStr.charAt(0) == CHANNEL_ID_PREFIX) {
					channelStr = channelStr.substring(ORIGINAL_CHANNEL_ID_PREFIX_LENGTH);
					result = new StringBuilder(1 + channelStr.length() + 1 + msg.length()) .append(CHANNEL_ID_PREFIX) .append(channelStr);
				}
				
				else {
					int ind = channelStr.indexOf(ORIGINAL_CHANNEL_ID_PREFIX);
					result = new StringBuilder(1 + (channelStr.length() - ORIGINAL_CHANNEL_ID_PREFIX_LENGTH) + 1 + msg.length()) .append(channelStr.substring(0, ind)) .append(CHANNEL_ID_PREFIX) .append(channelStr.substring(ind + ORIGINAL_CHANNEL_ID_PREFIX_LENGTH));
				}
				
				return result.append(CHANNEL_ID_SUFFIX_2) .append(msg) .toString();
			}
			
		}
		
		else {
			return msg;
		}
		
	}
	
	 public static String toPrettyHexDump(Object msg) {
		Objects.requireNonNull(msg, "msg");
		String result;
		if (msg instanceof ByteBufHolder && !Objects.equals(Unpooled.EMPTY_BUFFER, ((ByteBufHolder) msg).content())) {
			ByteBuf buffer = ((ByteBufHolder) msg).content();
			result = "\n" + ByteBufUtil.prettyHexDump(buffer);
		}
		
		else if (msg instanceof ByteBuf) {
			result = "\n" + ByteBufUtil.prettyHexDump((ByteBuf) msg);
		}
		
		else {
			result = msg.toString();
		}
		
		return result;
	}
	
	public static ContextView getChannelContext(Channel channel) {
		return channel.attr(CONTEXT_VIEW).get();
	}
	
	 public static void setChannelContext(Channel channel, @Nullable ContextView contextView) {
		channel.attr(CONTEXT_VIEW).set(contextView);
	}
	
	 public static RuntimeException wrapException(Throwable throwable) {
		return new InternalNettyException(Objects.requireNonNull(throwable));
	}
	
	static void addChunkedWriter(Connection c) {
		if (c.channel() .pipeline() .get(ChunkedWriteHandler.class) == null) {
			c.addHandlerLast(NettyPipeline.ChunkedWriter, new ChunkedWriteHandler());
		}
		
	}
	
	 static void addHandlerBeforeReactorEndHandlers(Connection context, String name,	ChannelHandler handler) {
		Objects.requireNonNull(name, "name");
		Objects.requireNonNull(handler, "handler");
		Channel channel = context.channel();
		boolean exists = channel.pipeline().get(name) != null;
		if (exists) {
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Handler [{}] already exists in the pipeline, decoder has been skipped"), name);
			}
			
			return;
		}
		
		 String before = null;
		for (String s : channel.pipeline().names()) {
			if (s.startsWith(NettyPipeline.RIGHT)) {
				before = s;
				break;
			}
			
		}
		
		if (before == null) {
			channel.pipeline().addLast(name, handler);
		}
		
		else {
			channel.pipeline().addBefore(before, name, handler);
		}
		
		registerForClose(context.isPersistent(),  name, context);
		if (log.isDebugEnabled()) {
			log.debug(format(channel, "Added decoder [{}] at the end of the user pipeline, full pipeline: {}"), name, channel.pipeline().names());
		}
		
	}
	
	 static void addHandlerAfterReactorCodecs(Connection context, String name, ChannelHandler handler) {
		Objects.requireNonNull(name, "name");
		Objects.requireNonNull(handler, "handler");
		Channel channel = context.channel();
		boolean exists = channel.pipeline().get(name) != null;
		if (exists) {
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Handler [{}] already exists in the pipeline, encoder has been skipped"), name);
			}
			
			return;
		}
		
		 String after = null;
		for (String s : channel.pipeline().names()) {
			if (s.startsWith(NettyPipeline.LEFT)) {
				after = s;
			}
			
		}
		
		if (after == null) {
			channel.pipeline().addFirst(name, handler);
		}
		
		else {
			channel.pipeline().addAfter(after, name, handler);
		}
		
		registerForClose(context.isPersistent(), name, context);
		if (log.isDebugEnabled()) {
			log.debug(format(channel, "Added encoder [{}] at the beginning of the user pipeline, full pipeline: {}"), name, channel.pipeline().names());
		}
		
	}
	
	static boolean mustChunkFileTransfer(Connection c, Path file) {
		 if (c.channel().parent() != null && c.channel().parent().pipeline().get(NettyPipeline.H2MultiplexHandler) != null) {
			return true;
		}
		
		ChannelPipeline p = c.channel().pipeline();
		return p.get(SslHandler.class) != null  || p.get(NettyPipeline.CompressionHandler) != null || (!(c.channel().eventLoop() instanceof NioEventLoop) && !"file".equals(file.toUri().getScheme()));
	}
	
	static void registerForClose(boolean shouldCleanupOnClose, String name, Connection context) {
		if (!shouldCleanupOnClose) {
			return;
		}
		
		context.onTerminate().subscribe(null, null, () -> context.removeHandler(name));
	}
	
	static void removeHandler(Channel channel, String name) {
		if (channel.isActive() && channel.pipeline() .context(name) != null) {
			channel.pipeline() .remove(name);
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Removed handler: {}, pipeline: {}"), name, channel.pipeline());
			}
			
		}
		
		else if (log.isDebugEnabled()) {
			log.debug(format(channel, "Non Removed handler: {}, context: {}, pipeline: {}"), name, channel.pipeline() .context(name), channel.pipeline());
		}
		
	}
	
	static void replaceHandler(Channel channel, String name, ChannelHandler handler) {
		if (channel.isActive() && channel.pipeline() .context(name) != null) {
			channel.pipeline() .replace(name, name, handler);
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Replaced handler: {}, pipeline: {}"), name, channel.pipeline());
			}
			
		}
		
		else if (log.isDebugEnabled()) {
			log.debug(format(channel, "Non Replaced handler: {}, context: {}, pipeline: {}"), name, channel.pipeline() .context(name), channel.pipeline());
		}
		
	}
	
	static ConnectionObserver compositeConnectionObserver(ConnectionObserver observer, ConnectionObserver other) {
		if (observer == ConnectionObserver.emptyListener()) {
			return other;
		}
		
		if (other == ConnectionObserver.emptyListener()) {
			return observer;
		}
		
		final ConnectionObserver[] newObservers;
		final ConnectionObserver[] thizObservers;
		final ConnectionObserver[] otherObservers;
		int length = 2;
		if (observer instanceof CompositeConnectionObserver) {
			thizObservers = ((CompositeConnectionObserver) observer).observers;
			length += thizObservers.length - 1;
		}
		
		else {
			thizObservers = null;
		}
		
		if (other instanceof CompositeConnectionObserver) {
			otherObservers = ((CompositeConnectionObserver) other).observers;
			length += otherObservers.length - 1;
		}
		
		else {
			otherObservers = null;
		}
		
		newObservers = new ConnectionObserver[length];
		int pos;
		if (thizObservers != null) {
			pos = thizObservers.length;
			System.arraycopy(thizObservers, 0, newObservers, 0, pos);
		}
		
		else {
			pos = 1;
			newObservers[0] = observer;
		}
		
		if (otherObservers != null) {
			System.arraycopy(otherObservers, 0, newObservers, pos, otherObservers.length);
		}
		
		else {
			newObservers[pos] = other;
		}
		
		return new CompositeConnectionObserver(newObservers);
	}
	
	static <T, V> CorePublisher<V> publisherOrScalarMap(Publisher<T> publisher, Function<? super T, ? extends V> mapper) {
		if (publisher instanceof Callable) {
			return Mono.fromCallable(new ScalarMap<>(publisher, mapper));
		}
		
		else if (publisher instanceof Mono) {
			return ((Mono<T>) publisher).map(mapper);
		}
		
		return Flux.from(publisher) .map(mapper);
	}
	
	static <T, V> CorePublisher<V> publisherOrScalarMap( Publisher<T> publisher, Function<? super T, ? extends V> monoMapper, Function<? super List<T>, ? extends V> fluxMapper) {
		if (publisher instanceof Callable) {
			return Mono.fromCallable(new ScalarMap<>(publisher, monoMapper));
		}
		
		else if (publisher instanceof Mono) {
			return ((Mono<T>) publisher).map(monoMapper);
		}
		
		return Flux.from(publisher) .collectList() .map(fluxMapper);
	}
	
	ReactorNetty() {
	}
	
	static final class ScalarMap<T, V> implements Callable<V> {
		final Callable<T>                      source;
		final Function<? super T, ? extends V> mapper;
		@SuppressWarnings("unchecked")
		ScalarMap(Publisher<T> source, Function<? super T, ? extends V> mapper) {
			this.source = (Callable<T>) source;
			this.mapper = mapper;
		}
		
		public V call() throws Exception {
			T called = source.call();
			if (called == null) {
				return null;
			}
			
			return mapper.apply(called);
		}
		
	}
	
	static final class CompositeChannelPipelineConfigurer implements ChannelPipelineConfigurer {
		final ChannelPipelineConfigurer[] configurers;
		CompositeChannelPipelineConfigurer(ChannelPipelineConfigurer[] configurers) {
			this.configurers = configurers;
		}
		
		public void onChannelInit(ConnectionObserver connectionObserver, Channel channel, @Nullable SocketAddress remoteAddress) {
			for (ChannelPipelineConfigurer configurer : configurers) {
				configurer.onChannelInit(connectionObserver, channel, remoteAddress);
			}
			
		}
		
		static ChannelPipelineConfigurer compositeChannelPipelineConfigurer( ChannelPipelineConfigurer configurer, ChannelPipelineConfigurer other) {
			if (configurer == ChannelPipelineConfigurer.emptyConfigurer()) {
				return other;
			}
			
			if (other == ChannelPipelineConfigurer.emptyConfigurer()) {
				return configurer;
			}
			
			final ChannelPipelineConfigurer[] newConfigurers;
			final ChannelPipelineConfigurer[] thizConfigurers;
			final ChannelPipelineConfigurer[] otherConfigurers;
			int length = 2;
			if (configurer instanceof CompositeChannelPipelineConfigurer) {
				thizConfigurers = ((CompositeChannelPipelineConfigurer) configurer).configurers;
				length += thizConfigurers.length - 1;
			}
			
			else {
				thizConfigurers = null;
			}
			
			if (other instanceof CompositeChannelPipelineConfigurer) {
				otherConfigurers = ((CompositeChannelPipelineConfigurer) other).configurers;
				length += otherConfigurers.length - 1;
			}
			
			else {
				otherConfigurers = null;
			}
			
			newConfigurers = new ChannelPipelineConfigurer[length];
			int pos;
			if (thizConfigurers != null) {
				pos = thizConfigurers.length;
				System.arraycopy(thizConfigurers, 0, newConfigurers, 0, pos);
			}
			
			else {
				pos = 1;
				newConfigurers[0] = configurer;
			}
			
			if (otherConfigurers != null) {
				System.arraycopy(otherConfigurers, 0, newConfigurers, pos, otherConfigurers.length);
			}
			
			else {
				newConfigurers[pos] = other;
			}
			
			return new CompositeChannelPipelineConfigurer(newConfigurers);
		}
		
	}
	
	static final class CompositeConnectionObserver implements ConnectionObserver {
		final ConnectionObserver[] observers;
		CompositeConnectionObserver(ConnectionObserver[] observers) {
			this.observers = observers;
		}
		
		public Context currentContext() {
			return observers[observers.length - 1].currentContext();
		}
		
		public void onUncaughtException(Connection connection, Throwable error) {
			for (ConnectionObserver observer : observers) {
				observer.onUncaughtException(connection, error);
			}
			
		}
		
		public void onStateChange(Connection connection, State newState) {
			for (ConnectionObserver observer : observers) {
				observer.onStateChange(connection, newState);
			}
			
		}
		
	}
	
	 static final class OutboundThen implements NettyOutbound {
		final NettyOutbound source;
		final Mono<Void> thenMono;
		static final Runnable EMPTY_CLEANUP = () -> {};
		OutboundThen(NettyOutbound source, Publisher<Void> thenPublisher) {
			this(source, thenPublisher, EMPTY_CLEANUP);
		}
		
		OutboundThen(NettyOutbound source, Publisher<Void> thenPublisher, Runnable onCleanup) {
			this.source = source;
			Objects.requireNonNull(onCleanup, "onCleanup");
			Mono<Void> parentMono = source.then();
			if (parentMono == Mono.<Void>empty()) {
				if (onCleanup == EMPTY_CLEANUP) {
					this.thenMono = Mono.from(thenPublisher);
				}
				
				else {
					this.thenMono = Mono.from(thenPublisher) .doOnCancel(onCleanup) .doOnError(t -> onCleanup.run());
				}
				
			}
			
			else {
				if (onCleanup == EMPTY_CLEANUP) {
					this.thenMono = parentMono.thenEmpty(thenPublisher);
				}
				
				else {
					this.thenMono = parentMono.thenEmpty(thenPublisher) .doOnCancel(onCleanup) .doOnError(t -> onCleanup.run());
				}
				
			}
			
		}
		
		public <S> NettyOutbound sendUsing(Callable<? extends S> sourceInput, BiFunction<? super Connection, ? super S, ?> mappedInput, Consumer<? super S> sourceCleanup) {
			return then(source.sendUsing(sourceInput, mappedInput, sourceCleanup));
		}
		
		public ByteBufAllocator alloc() {
			return source.alloc();
		}
		
		public NettyOutbound withConnection(Consumer<? super Connection> withConnection) {
			return source.withConnection(withConnection);
		}
		
		public NettyOutbound send(Publisher<? extends ByteBuf> dataStream, Predicate<ByteBuf> predicate) {
			return then(source.send(dataStream, predicate));
		}
		
		public NettyOutbound sendObject(Publisher<?> dataStream, Predicate<Object> predicate) {
			return then(source.sendObject(dataStream, predicate));
		}
		
		public NettyOutbound sendObject(Object message) {
			return then(source.sendObject(message), () -> ReactorNetty.safeRelease(message));
		}
		
		public Mono<Void> then() {
			return thenMono;
		}
		
	}
	
	final static class OutboundIdleStateHandler extends IdleStateHandler {
		final Runnable onWriteIdle;
		OutboundIdleStateHandler(long idleTimeout, Runnable onWriteIdle) {
			super(0, idleTimeout, 0, TimeUnit.MILLISECONDS);
			this.onWriteIdle = requireNonNull(onWriteIdle, "onWriteIdle");
		}
		
		protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {
			if (evt.state() == IdleState.WRITER_IDLE) {
				onWriteIdle.run();
			}
			
			super.channelIdle(ctx, evt);
		}
		
	}
	
	final static class InboundIdleStateHandler extends IdleStateHandler {
		final Runnable onReadIdle;
		InboundIdleStateHandler(long idleTimeout, Runnable onReadIdle) {
			super(idleTimeout, 0, 0, TimeUnit.MILLISECONDS);
			this.onReadIdle = requireNonNull(onReadIdle, "onReadIdle");
		}
		
		protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {
			if (evt.state() == IdleState.READER_IDLE) {
				onReadIdle.run();
			}
			
			super.channelIdle(ctx, evt);
		}
		
	}
	
	final static ConnectionObserver.State CONNECTED = new ConnectionObserver.State() {
		public String toString() {
			return "[connected]";
		}
		
	};
	final static ConnectionObserver.State ACQUIRED = new ConnectionObserver.State() {
		public String toString() {
			return "[acquired]";
		}
		
	};
	final static ConnectionObserver.State CONFIGURED = new ConnectionObserver.State() {
		public String toString() {
			return "[configured]";
		}
		
	};
	final static ConnectionObserver.State RELEASED = new ConnectionObserver.State() {
		public String toString() {
			return "[released]";
		}
		
	};
	final static ConnectionObserver.State DISCONNECTING = new ConnectionObserver.State() {
		public String toString() {
			return "[disconnecting]";
		}
		
	};
	 @ChannelHandler.Sharable
	static final class ExtractorHandler extends ChannelInboundHandlerAdapter {
		final BiConsumer<? super ChannelHandlerContext, Object> extractor;
		ExtractorHandler(BiConsumer<? super ChannelHandlerContext, Object> extractor) {
			this.extractor = Objects.requireNonNull(extractor, "extractor");
		}
		
		public void channelRead(ChannelHandlerContext ctx, Object msg) {
			extractor.accept(ctx, msg);
		}
		
	}
	
	static final class ChannelDisposer extends BaseSubscriber<Void> {
		final DisposableChannel channelDisposable;
		ChannelDisposer(DisposableChannel channelDisposable) {
			this.channelDisposable = channelDisposable;
		}
		
		protected void hookOnSubscribe(Subscription subscription) {
			request(Long.MAX_VALUE);
			channelDisposable.onDispose(this);
		}
		
		protected void hookFinally(SignalType type) {
			if (type != SignalType.CANCEL) {
				channelDisposable.dispose();
			}
			
		}
		
	}
	
	static final class SimpleConnection extends AtomicLong implements Connection {
		final Channel channel;
		SimpleConnection(Channel channel) {
			this.channel = Objects.requireNonNull(channel, "channel");
		}
		
		public Channel channel() {
			return channel;
		}
		
		public String toString() {
			return "SimpleConnection{" + "channel=" + channel + '}';
		}
		
	}
	
	static NettyInbound unavailableInbound(Connection c) {
		return new NettyInbound() {
			public ByteBufFlux receive() {
				return ByteBufFlux.fromInbound(Mono.error(new IllegalStateException("Receiver Unavailable")));
			}
			
			public Flux<?> receiveObject() {
				return Flux.error(new IllegalStateException("Receiver Unavailable"));
			}
			
			public NettyInbound withConnection(Consumer<? super Connection> withConnection) {
				withConnection.accept(c);
				return this;
			}
			
		};
	}
	
	static NettyOutbound unavailableOutbound(Connection c) {
		return new NettyOutbound() {
			public ByteBufAllocator alloc() {
				return c.channel().alloc();
			}
			
			public NettyOutbound send(Publisher<? extends ByteBuf> dataStream, Predicate<ByteBuf> predicate) {
				return this;
			}
			
			public NettyOutbound sendObject(Publisher<?> dataStream, Predicate<Object> predicate) {
				return this;
			}
			
			public NettyOutbound sendObject(Object message) {
				return this;
			}
			
			public <S> NettyOutbound sendUsing(Callable<? extends S> sourceInput, BiFunction<? super Connection, ? super S, ?> mappedInput, Consumer<? super S> sourceCleanup) {
				return this;
			}
			
			public NettyOutbound withConnection(Consumer<? super Connection> withConnection) {
				withConnection.accept(c);
				return this;
			}
			
			public Mono<Void> then() {
				return Mono.error(new IllegalStateException("Sender Unavailable"));
			}
			
		};
	}
	
	static final class InternalNettyException extends RuntimeException {
		InternalNettyException(Throwable cause) {
			super(cause);
		}
		
		public synchronized Throwable fillInStackTrace() {
			return this;
		}
		
		private static final long serialVersionUID = 6643227207055930902L;
	}
	
	static final ChannelPipelineConfigurer NOOP_CONFIGURER = (observer, ch, address) -> {};
	static final ConnectionObserver NOOP_LISTENER = (connection, newState) -> {};
	static final Logger log                               = Loggers.getLogger(ReactorNetty.class);
	static final AttributeKey<Boolean> PERSISTENT_CHANNEL = AttributeKey.valueOf("$PERSISTENT_CHANNEL");
	static final AttributeKey<Connection> CONNECTION = AttributeKey.valueOf("$CONNECTION");
	static final AttributeKey<ContextView> CONTEXT_VIEW = AttributeKey.valueOf("$CONTEXT_VIEW");
	static final Consumer<? super FileChannel> fileCloser = fc -> {
		try {
			fc.close();
		}
		
		catch (Throwable e) {
			if (log.isTraceEnabled()) {
				log.trace("", e);
			}
			
		}
		
	};
	static final Predicate<ByteBuf>        PREDICATE_BB_FLUSH    = b -> false;
	static final Predicate<Object>         PREDICATE_FLUSH       = o -> false;
	static final ByteBuf                   BOUNDARY              = Unpooled.EMPTY_BUFFER;
	static final char CHANNEL_ID_PREFIX = '[';
	static final String CHANNEL_ID_SUFFIX_1 = "] ";
	static final char CHANNEL_ID_SUFFIX_2 = ' ';
	static final String ORIGINAL_CHANNEL_ID_PREFIX = "[id: 0x";
	static final int ORIGINAL_CHANNEL_ID_PREFIX_LENGTH = ORIGINAL_CHANNEL_ID_PREFIX.length();
	static final char TRACE_ID_PREFIX = '(';
	 public static final Predicate<ByteBuf> PREDICATE_GROUP_FLUSH = b -> b == BOUNDARY;
}


