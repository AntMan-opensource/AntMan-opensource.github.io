package reactor.netty.transport;
import io.micrometer.core.instrument.Gauge;
import io.netty.channel.EventLoop;
import io.netty.util.concurrent.SingleThreadEventExecutor;
import reactor.netty.internal.util.MapUtils;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import static reactor.netty.Metrics.EVENT_LOOP_PREFIX;
import static reactor.netty.Metrics.NAME;
import static reactor.netty.Metrics.PENDING_TASKS;
import static reactor.netty.Metrics.REGISTRY;
final class MicrometerEventLoopMeterRegistrar {
	static final String PENDING_TASKS_DESCRIPTION = "Event loop pending scheduled tasks.";
	final static MicrometerEventLoopMeterRegistrar INSTANCE = new MicrometerEventLoopMeterRegistrar();
	private final ConcurrentMap<String, EventLoop> cache = new ConcurrentHashMap<>();
	private MicrometerEventLoopMeterRegistrar() {}
	void registerMetrics(EventLoop eventLoop) {
		if (eventLoop instanceof SingleThreadEventExecutor) {
			SingleThreadEventExecutor singleThreadEventExecutor = (SingleThreadEventExecutor) eventLoop;
			String executorName = singleThreadEventExecutor.threadProperties().name();
			MapUtils.computeIfAbsent(cache, executorName, key -> {
				Gauge.builder(EVENT_LOOP_PREFIX + PENDING_TASKS, singleThreadEventExecutor::pendingTasks) .description(PENDING_TASKS_DESCRIPTION) .tag(NAME, executorName) .register(REGISTRY);
				return eventLoop;
			}
			
);
		}
		
	}
	
}


