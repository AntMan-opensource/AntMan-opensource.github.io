package com.graphhopper.navigation;
import com.graphhopper.GHRequest;
import com.graphhopper.GHResponse;
import com.graphhopper.GraphHopperAPI;
import com.graphhopper.GraphHopperConfig;
import com.graphhopper.util.Helper;
import com.graphhopper.util.Parameters;
import com.graphhopper.util.StopWatch;
import com.graphhopper.util.TranslationMap;
import com.graphhopper.util.shapes.GHPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.*;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;
import java.util.*;
import static com.graphhopper.util.Parameters.Routing.*;
public class NavigateResource {
    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);
    private final GraphHopperAPI graphHopper;
    private final TranslationMap translationMap;
    private final Map<String, String> resolverMap;
    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {
        this.graphHopper = graphHopper;
        resolverMap = config.asPMap().getObject("profiles_mapbox", new HashMap<>());
        if (resolverMap.isEmpty()) {
            resolverMap.put("driving", "car");
            resolverMap.put("driving-traffic", "car");
            resolverMap.put("walking", "foot");
            resolverMap.put("cycling", "bike");
        }
        
        this.translationMap = translationMap;
    }
    
    @Path("/{profile}/{coordinatesArray : .+}")
    public Response doGet( @Context HttpServletRequest httpReq, @Context UriInfo uriInfo, @Context ContainerRequestContext rc, @QueryParam("steps") @DefaultValue("false") boolean enableInstructions, @QueryParam("voice_instructions") @DefaultValue("false") boolean voiceInstructions, @QueryParam("banner_instructions") @DefaultValue("false") boolean bannerInstructions, @QueryParam("roundabout_exits") @DefaultValue("false") boolean roundaboutExits, @QueryParam("voice_units") @DefaultValue("metric") String voiceUnits, @QueryParam("overview") @DefaultValue("simplified") String overview, @QueryParam("geometries") @DefaultValue("polyline") String geometries, @QueryParam("bearings") @DefaultValue("") String bearings, @QueryParam("language") @DefaultValue("en") String localeStr, @PathParam("profile") String mapboxProfile) {
        if (!geometries.equals("polyline6")){
            throw new IllegalArgumentException("Currently, we only support polyline6");
}
        if (!enableInstructions){
            throw new IllegalArgumentException("Currently, you need to enable steps");
}
        if (!roundaboutExits){
            throw new IllegalArgumentException("Roundabout exits have to be enabled right now");
}
        if (!voiceInstructions){
            throw new IllegalArgumentException("You need to enable voice instructions right now");
}
        if (!bannerInstructions){
            throw new IllegalArgumentException("You need to enable banner instructions right now");
}
        double minPathPrecision = 1;
        if (overview.equals("full")){
            minPathPrecision = 0;
}
        DistanceUtils.Unit unit;
        if (voiceUnits.equals("metric")) {
            unit = DistanceUtils.Unit.METRIC;
        }
         else {
            unit = DistanceUtils.Unit.IMPERIAL;
        }
        
        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);
        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);
        List<Double> favoredHeadings = getBearing(bearings);
        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {
            throw new IllegalArgumentException("Number of bearings and waypoints did not match");
        }
        
        StopWatch sw = new StopWatch().start();
        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);
        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {
            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);
            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {
                ghResponse.getAll().add(noHeadingResponse.getBest());
            }
            
        }
        
        float took = sw.stop().getSeconds();
        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
        String logStr = httpReq.getQueryString() + " " + infoStr + " " + requestPoints + ", took:" + took + ", " + ghProfile;
        Locale locale = Helper.getLocale(localeStr);
        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);
        if (ghResponse.hasErrors()) {
            logger.error(logStr + ", errors:" + ghResponse.getErrors());
            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)). header("X-GH-Took", "" + Math.round(took * 1000)). build();
        }
         else {
            logger.info(logStr);
            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)). header("X-GH-Took", "" + Math.round(took * 1000)). build();
        }
        
    }
    
    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr, String localeStr, boolean enableInstructions, double minPathPrecision) {
        GHRequest request;
        if (favoredHeadings.size() > 0) {
            request = new GHRequest(requestPoints, favoredHeadings);
        }
         else {
            request = new GHRequest(requestPoints);
        }
        
        request.setProfile(profileStr). setLocale(localeStr). putHint(CALC_POINTS, true). putHint(INSTRUCTIONS, enableInstructions). putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision). putHint(Parameters.CH.DISABLE, true). putHint(Parameters.Routing.PASS_THROUGH, false);
        return graphHopper.route(request);
    }
    
    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {
        String url = httpServletRequest.getRequestURI();
        url = url.replaceFirst("/navigate/directions/v5/gh/" + profile + "/", "");
        url = url.replaceAll("\\?[*]", "");
        String[] pointStrings = url.split(";");
        List<GHPoint> points = new ArrayList<>(pointStrings.length);
        for (int i = 0; i < pointStrings.length; i++) {
            points.add(GHPoint.fromStringLonLat(pointStrings[i]));
        }
        
        return points;
    }
    
    static List<Double> getBearing(String bearingString) {
        if (bearingString == null || bearingString.isEmpty()){
            return Collections.EMPTY_LIST;
}
        String[] bearingArray = bearingString.split(";", -1);
        List<Double> bearings = new ArrayList<>(bearingArray.length);
        for (int i = 0; i < bearingArray.length; i++) {
            String singleBearing = bearingArray[i];
            if (singleBearing.isEmpty()) {
                bearings.add(Double.NaN);
            }
             else {
                if (!singleBearing.contains(",")) {
                    throw new IllegalArgumentException("You passed an invalid bearings parameter " + bearingString);
                }
                
                String[] singleBearingArray = singleBearing.split(",");
                try {
                    bearings.add(Double.parseDouble(singleBearingArray[0]));
                }
                 catch (NumberFormatException e) {
                    throw new IllegalArgumentException("You passed an invalid bearings parameter " + bearingString);
                }
                
            }
            
        }
        
        return bearings;
    }
    
}


