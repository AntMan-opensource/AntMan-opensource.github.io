package io.netty.incubator.codec.hpke.boringssl;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
abstract class BoringSSLCryptoOperation {
    final boolean execute(long ctx, ByteBufAllocator alloc, ByteBuf aad, ByteBuf in, ByteBuf out) {
        ByteBuf directAad = null;
        ByteBuf directIn = null;
        ByteBuf directOut = null;
        try {
            directAad = directReadable(alloc, aad);
            directIn = directReadable(alloc, in);
            int maxOutLen = maxOutLen(ctx, in.readableBytes());
            directOut = directWritable(alloc, out, maxOutLen);
            long directAadAddress = BoringSSL.memory_address(directAad) + directAad.readerIndex();
            int directAddReadableBytes = directAad.readableBytes();
            long directInAddress = BoringSSL.memory_address(directIn) + directIn.readerIndex();
            int directInReadableBytes = directIn.readableBytes();
            long directOutAddress = BoringSSL.memory_address(directOut) + directOut.writerIndex();
            int directOutWritableBytes = directOut.writableBytes();
            int result = execute(ctx, alloc, directAadAddress, directAddReadableBytes, directInAddress, directInReadableBytes, directOutAddress, directOutWritableBytes);
            if (result < 0) {
                return false;
            }
            
            aad.skipBytes(directAddReadableBytes);
            in.skipBytes(directInReadableBytes);
            directOut.writerIndex(directOut.writerIndex() + result);
            if (out != directOut) {
                out.writeBytes(directOut);
            }
            
            return true;
        }
         finally {
            releaseIfNotTheSameInstance(aad, directAad);
            releaseIfNotTheSameInstance(in, directIn);
            releaseIfNotTheSameInstance(out, directOut);
        }
        
    }
    
    abstract int maxOutLen(long ctx, int inReadable);
    abstract int execute(long ctx, ByteBufAllocator alloc, long ad, int adLen, long in, int inLen, long out, int outLen);
    private static ByteBuf directReadable(ByteBufAllocator alloc, ByteBuf in) {
        if (in.isDirect()) {
            return in;
        }
        
        ByteBuf directIn = alloc.directBuffer(in.readableBytes());
        directIn.writeBytes(in, in.readerIndex(), in.readableBytes());
        return directIn;
    }
    
    private static ByteBuf directWritable(ByteBufAllocator alloc, ByteBuf out, int minWritable) {
        if (out.isDirect()) {
            out.ensureWritable(minWritable);
            return out;
        }
        
        return alloc.directBuffer(minWritable);
    }
    
    private static void releaseIfNotTheSameInstance(ByteBuf buf, ByteBuf maybeOther) {
        if (maybeOther != null && maybeOther != buf) {
            maybeOther.release();
        }
        
    }
    
}


