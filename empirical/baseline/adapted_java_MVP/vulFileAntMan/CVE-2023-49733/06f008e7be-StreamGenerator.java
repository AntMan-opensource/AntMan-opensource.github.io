package org.apache.cocoon.generation;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import javax.servlet.http.HttpServletRequest;
import org.apache.avalon.framework.service.ServiceException;
import org.apache.excalibur.xml.sax.SAXParser;
import org.apache.cocoon.ProcessingException;
import org.apache.cocoon.ResourceNotFoundException;
import org.apache.cocoon.environment.ObjectModelHelper;
import org.apache.cocoon.environment.Request;
import org.apache.cocoon.environment.http.HttpEnvironment;
import org.apache.cocoon.servlet.multipart.Part;
import org.apache.cocoon.util.PostInputStream;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
public class StreamGenerator extends ServiceableGenerator {
    public static final String FORM_NAME = "form-name";
    public void generate() throws IOException, SAXException, ProcessingException {
        SAXParser parser = null;
        int len = 0;
        String contentType;
        Request request = ObjectModelHelper.getRequest(this.objectModel);
        try {
            contentType = request.getContentType();
            if (contentType == null) {
                contentType = parameters.getParameter("defaultContentType", null);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("no Content-Type header - using contentType parameter: " + contentType);
                }
                
                if (contentType == null) {
                    throw new IOException("Both Content-Type header and defaultContentType parameter are not set");
                }
                
            }
            
            InputSource source;
            if (contentType.startsWith("application/x-www-form-urlencoded") || contentType.startsWith("multipart/form-data")) {
                String parameter = parameters.getParameter(FORM_NAME, null);
                if (parameter == null) {
                    throw new ProcessingException("StreamGenerator expects a sitemap parameter called '" + FORM_NAME + "' for handling form data");
                }
                
                Object xmlObject = request.get(parameter);
                Reader xmlReader;
                if (xmlObject instanceof String) {
                    xmlReader = new StringReader((String) xmlObject);
                }
                 else if (xmlObject instanceof Part) {
                    xmlReader = new InputStreamReader(((Part) xmlObject).getInputStream());
                }
                 else {
                    throw new ProcessingException("Unknown request object encountered named " +  parameter + " : " + xmlObject);
                }
                
                source = new InputSource(xmlReader);
            }
             else if (contentType.startsWith("text/plain") || contentType.startsWith("text/xml") || contentType.startsWith("application/xhtml+xml") || contentType.startsWith("application/xml")) {
                HttpServletRequest httpRequest = (HttpServletRequest) objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);
                if (httpRequest == null) {
                    throw new ProcessingException("This feature is only available in an http environment.");
                }
                
                len = request.getContentLength();
                if (len <= 0) {
                    throw new IOException("getContentLen() == 0");
                }
                
                PostInputStream anStream = new PostInputStream(httpRequest.getInputStream(), len);
                source = new InputSource(anStream);
            }
             else {
                throw new IOException("Unexpected getContentType(): " + request.getContentType());
            }
            
            if (getLogger().isDebugEnabled()) {
                getLogger().debug("Processing stream ContentType=" + contentType + " ContentLength=" + len);
            }
            
            String charset = getCharacterEncoding(request, contentType);
            if (charset != null) {
                source.setEncoding(charset);
            }
            
            parser = (SAXParser) this.manager.lookup(SAXParser.ROLE);
            parser.parse(source, super.xmlConsumer);
        }
         catch (IOException e) {
            getLogger().error("StreamGenerator.generate()", e);
            throw new ResourceNotFoundException("StreamGenerator could not find resource", e);
        }
         catch (SAXException e) {
            getLogger().error("StreamGenerator.generate()", e);
            throw(e);
        }
         catch (ServiceException e) {
            getLogger().error("Could not get parser", e);
            throw new ProcessingException("Exception in StreamGenerator.generate()", e);
        }
         finally {
            this.manager.release(parser);
        }
        
    }
    
    public String getCharacterEncoding(Request req, String contentType) {
        if (contentType == null) {
            return null;
        }
        
        int idx = contentType.indexOf("charset=");
        if (idx == -1) {
            return null;
        }
        
        String encoding;
        try {
            encoding = req.getCharacterEncoding();
            if (encoding != null) {
                encoding = cleanup(encoding);
                if (getLogger().isDebugEnabled()) {
                    getLogger().debug("Using charset from container: " + encoding);
                }
                
                return encoding;
            }
            
        }
         catch (Throwable e) {
        }
        
        encoding = contentType.substring(idx + "charset=".length());
        int idxEnd = encoding.indexOf(";");
        if (idxEnd != -1) {
            encoding = encoding.substring(0, idxEnd);
        }
        
        encoding = cleanup(encoding);
        if (getLogger().isDebugEnabled()) {
            getLogger().debug("Using charset from header: " + encoding);
        }
        
        return encoding;
    }
    
    private String cleanup(String encoding) {
        encoding = encoding.trim();
        if (encoding.length() > 2 && encoding.startsWith("\"") && encoding.endsWith("\"")) {
            encoding = encoding.substring(1, encoding.length() - 1);
        }
        
        return encoding;
    }
    
}


