package hudson.cli.declarative;
import static java.util.logging.Level.SEVERE;
import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.AbortException;
import hudson.Extension;
import hudson.ExtensionComponent;
import hudson.ExtensionFinder;
import hudson.Functions;
import hudson.Util;
import hudson.cli.CLICommand;
import hudson.cli.CloneableCLICommand;
import hudson.model.Hudson;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.Stack;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;
import jenkins.ExtensionComponentSet;
import jenkins.ExtensionRefreshException;
import jenkins.model.Jenkins;
import org.jvnet.hudson.annotation_indexer.Index;
import org.jvnet.localizer.ResourceBundleHolder;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
public class CLIRegisterer extends ExtensionFinder {
    public ExtensionComponentSet refresh() throws ExtensionRefreshException {
        return ExtensionComponentSet.EMPTY;
    }
    
    public <T> Collection<ExtensionComponent<T>> find(Class<T> type, Hudson jenkins) {
        if (type == CLICommand.class){
            return (List) discover(jenkins);
}
        else{
            return Collections.emptyList();
}
    }
    
    private Method findResolver(Class type) throws IOException {
        List<Method> resolvers = Util.filter(Index.list(CLIResolver.class, Jenkins.get().getPluginManager().uberClassLoader), Method.class);
        for ( ; type != null; type = type.getSuperclass()){
            for (Method m : resolvers){
                if (m.getReturnType() == type){
                    return m;
}
}
        return null;
}
    }
    
    private List<ExtensionComponent<CLICommand>> discover(@NonNull final Jenkins jenkins) {
        LOGGER.fine("Listing up @CLIMethod");
        List<ExtensionComponent<CLICommand>> r = new ArrayList<>();
        try {
            for (final Method m : Util.filter(Index.list(CLIMethod.class, jenkins.getPluginManager().uberClassLoader), Method.class)) {
                try {
                    final String name = m.getAnnotation(CLIMethod.class).name();
                    final ResourceBundleHolder res = loadMessageBundle(m);
                    res.format("CLI." + name + ".shortDescription");   
                    r.add(new ExtensionComponent<>(new CloneableCLICommand() {
                        public String getName() {
                            return name;
                        }
                        
                        public String getShortDescription() {
                            return res.format("CLI." + name + ".shortDescription");
                        }
                        
                        protected CmdLineParser getCmdLineParser() {
                            return bindMethod(new ArrayList<>());
                        }
                        
                        private CmdLineParser bindMethod(List<MethodBinder> binders) {
                            registerOptionHandlers();
                            CmdLineParser parser = new CmdLineParser(null);
                            Stack<Method> chains = new Stack<>();
                            Method method = m;
                            while (true) {
                                chains.push(method);
                                if (Modifier.isStatic(method.getModifiers())){
                                    break; 
}
                                Class<?> type = method.getDeclaringClass();
                                try {
                                    method = findResolver(type);
                                }
                                 catch (IOException ex) {
                                    throw new RuntimeException("Unable to find the resolver method annotated with @CLIResolver for " + type, ex);
                                }
                                
                                if (method == null) {
                                    throw new RuntimeException("Unable to find the resolver method annotated with @CLIResolver for " + type);
                                }
                                
                            }
                            
                            while (!chains.isEmpty()){
                                binders.add(new MethodBinder(chains.pop(), this, parser));
}
                            return parser;
                        }
                        
                        public int main(List<String> args, Locale locale, InputStream stdin, PrintStream stdout, PrintStream stderr) {
                            this.stdout = stdout;
                            this.stderr = stderr;
                            this.locale = locale;
                            List<MethodBinder> binders = new ArrayList<>();
                            CmdLineParser parser = bindMethod(binders);
                            try {
                                SecurityContext sc = SecurityContextHolder.getContext();
                                Authentication old = sc.getAuthentication();
                                try {
                                    parser.parseArgument(args);
                                    Authentication auth = getTransportAuthentication2();
                                    sc.setAuthentication(auth); 
                                    jenkins.checkPermission(Jenkins.READ);
                                    Object instance = null;
                                    for (MethodBinder binder : binders){
                                        instance = binder.call(instance);
}
                                    if (instance instanceof Integer){
                                        return (Integer) instance;
}
                                    else{
                                        return 0;
}
                                }
                                 catch (InvocationTargetException e) {
                                    Throwable t = e.getTargetException();
                                    if (t instanceof Exception){
                                        throw (Exception) t;
}
                                    throw e;
                                }
                                 finally {
                                    sc.setAuthentication(old); 
                                }
                                
                            }
                             catch (CmdLineException e) {
                                printError(e.getMessage());
                                printUsage(stderr, parser);
                                return 2;
                            }
                             catch (IllegalStateException e) {
                                printError(e.getMessage());
                                return 4;
                            }
                             catch (IllegalArgumentException e) {
                                printError(e.getMessage());
                                return 3;
                            }
                             catch (AbortException e) {
                                printError(e.getMessage());
                                return 5;
                            }
                             catch (AccessDeniedException e) {
                                printError(e.getMessage());
                                return 6;
                            }
                             catch (BadCredentialsException e) {
                                String id = UUID.randomUUID().toString();
                                logAndPrintError(e, "Bad Credentials. Search the server log for " + id + " for more details.", "CLI login attempt failed: " + id, Level.INFO);
                                return 7;
                            }
                             catch (Throwable e) {
                                final String errorMsg = "Unexpected exception occurred while performing " + getName() + " command.";
                                logAndPrintError(e, errorMsg, errorMsg, Level.WARNING);
                                Functions.printStackTrace(e, stderr);
                                return 1;
                            }
                            
                        }
                        
                        private void printError(String errorMessage) {
                            this.stderr.println();
                            this.stderr.println("ERROR: " + errorMessage);
                        }
                        
                        private void logAndPrintError(Throwable e, String errorMessage, String logMessage, Level logLevel) {
                            LOGGER.log(logLevel, logMessage, e);
                            printError(errorMessage);
                        }
                        
                        protected int run() throws Exception {
                            throw new UnsupportedOperationException();
                        }
                        
                    }
                    
));
                }
                 catch (ClassNotFoundException | MissingResourceException e) {
                    LOGGER.log(SEVERE, "Failed to process @CLIMethod: " + m, e);
                }
                
            }
            
        }
         catch (IOException e) {
            LOGGER.log(SEVERE, "Failed to discover @CLIMethod", e);
        }
        
        return r;
    }
    
    private ResourceBundleHolder loadMessageBundle(Method m) throws ClassNotFoundException {
        Class c = m.getDeclaringClass();
        Class<?> msg = c.getClassLoader().loadClass(c.getName().substring(0, c.getName().lastIndexOf(".")) + ".Messages");
        return ResourceBundleHolder.get(msg);
    }
    
    private static final Logger LOGGER = Logger.getLogger(CLIRegisterer.class.getName());
}


