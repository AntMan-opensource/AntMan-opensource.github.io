package com.usthe.sureness.util;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.*;
import io.jsonwebtoken.security.SignatureException;
import javax.xml.bind.DatatypeConverter;
import java.security.Key;
import java.util.*;
import java.util.regex.Pattern;
public class JsonWebTokenUtil {
    private static final String DEFAULT_SECRET_KEY = "MIIEowIBAl+f/dKhaX0csgOCTlCxq20yhmUea6H6JIpST3ST1SE2Rwp" + "LnfKefTjsIfJLBa2YkhEqE/GtcHDTNe4CU6+9y/S5z50Kik70LsP43r" + "RnLN7XNn4wARoQXizIv6MHUsIV+EFfiMw/x7R0ntu4aWr/CWuApcFaj" + "4mWEa6EwrPHTZmbT5Mt45AM2UYhzDHK+0F0rUq3MwH+oXsm+L3F/zjj" + "M6EByXIO+SV5+8tVt4bisXQ13rbN0oxhUZR73+LDj9mxa6rFhMW+lfx" + "CyaFv0bwq2Eik0jdrKUtsA6bx3sDJeFV643R+YYzGMRIqcBIp6AKA98" + "GM2RIqcBIp6-?::4390fsf4sdl6opf)4ZI:tdQMtcQQ14pkOAQdQ546";
    private static final int COUNT_3 = 3;
    private static final Pattern BASE64_PATTERN = Pattern.compile("^([A-Za-z0-9+/_-]+)(=*)$");
    private static Key secretKey;
    static {
        byte[] secretKeyBytes = DatatypeConverter.parseBase64Binary(DEFAULT_SECRET_KEY);
        secretKey = Keys.hmacShaKeyFor(secretKeyBytes);
    }
    
    public static String issueJwt(String id, String subject, String issuer, Long period, List<String> roles, List<String> permissions, Boolean isRefresh) {
        Map<String, Object> customClaimMap = new HashMap<>(4);
        customClaimMap.put(SurenessConstant.ROLES, roles);
        customClaimMap.put("perms", permissions);
        customClaimMap.put("isRefresh", isRefresh);
        return issueJwtAll(id, subject, issuer, period, null, null, null, null, customClaimMap);
    }
    
    public static String issueJwt(String id, String subject, String issuer, Long period, List<String> roles) {
        Map<String, Object> customClaimMap = Collections.singletonMap(SurenessConstant.ROLES, roles);
        return issueJwtAll(id, subject, issuer, period, null, null, null, null, customClaimMap);
    }
    
    public static String issueJwt(String id, String subject, String issuer, Long period, String audience, String payload, Long notBefore, List<String> roles, Map<String, Object> headerMap, Map<String, Object> customClaimMap){
        if (customClaimMap == null) {
            customClaimMap = Collections.singletonMap(SurenessConstant.ROLES, roles);
        }
         else {
            customClaimMap.put(SurenessConstant.ROLES, roles);
        }
        
        return issueJwtAll(id, subject, issuer, period, audience, payload, notBefore, headerMap, customClaimMap);
    }
    
    public static String issueJwt(String id, String subject, String issuer, Long period, List<String> roles, Map<String, Object> customClaimMap){
        if (customClaimMap == null) {
            customClaimMap = new HashMap<>(8);
        }
        
        if (roles != null && !roles.isEmpty()) {
            customClaimMap.put(SurenessConstant.ROLES, roles);
        }
        
        return issueJwtAll(id, subject, issuer, period, null, null, null, null, customClaimMap);
    }
    
    public static String issueJwt(String subject, Long period, List<String> roles, Map<String, Object> customClaimMap){
        String id = UUID.randomUUID().toString();
        String issuer = "sureness-token-server";
        return issueJwt(id, subject, issuer, period, roles, customClaimMap);
    }
    
    public static String issueJwt(String subject, Long period, List<String> roles){
        String id = UUID.randomUUID().toString();
        String issuer = "sureness-token-server";
        return issueJwt(id, subject, issuer, period, roles, null);
    }
    
    public static String issueJwt(String subject, Long period){
        String id = UUID.randomUUID().toString();
        String issuer = "sureness-token-server";
        return issueJwt(id, subject, issuer, period, null, null);
    }
    
    public static String issueJwt(String subject, Long period, Map<String, Object> customClaimMap){
        String id = UUID.randomUUID().toString();
        String issuer = "sureness-token-server";
        return issueJwt(id, subject, issuer, period, null, customClaimMap);
    }
    
    public static String issueJwtAll(String id, String subject, String issuer, Long period, String audience, String payload, Long notBefore, Map<String, Object> headerMap, Map<String, Object> customClaimMap){
        long currentTimeMillis = System.currentTimeMillis();
        JwtBuilder jwtBuilder = Jwts.builder();
        if (id != null) {
            jwtBuilder.setId(id);
        }
        
        if (subject != null) {
            jwtBuilder.setSubject(subject);
        }
        
        if (issuer != null) {
            jwtBuilder.setIssuer(issuer);
        }
        
        jwtBuilder.setIssuedAt(new Date(currentTimeMillis));
        if (null != period) {
            jwtBuilder.setExpiration(new Date(currentTimeMillis + period * 1000));
        }
        
        if (null != audience) {
            jwtBuilder.setAudience(audience);
        }
        
        if (null != payload) {
            jwtBuilder.setPayload(payload);
        }
        
        if (null != notBefore){
            jwtBuilder.setNotBefore(new Date(notBefore * 1000));
        }
        
        if(null != headerMap) {
            jwtBuilder.setHeader(headerMap);
        }
        
        if (null != customClaimMap) {
            customClaimMap.forEach(jwtBuilder::claim);
        }
        
        jwtBuilder.compressWith(CompressionCodecs.DEFLATE);
        jwtBuilder.signWith(secretKey);
        return jwtBuilder.compact();
    }
    
    public static boolean isNotJsonWebToken(String jwt) {
        if (jwt == null || "".equals(jwt)) {
            return true;
        }
        
        String[] jwtArr = jwt.split("\\.");
        if (jwtArr.length != COUNT_3) {
            return true;
        }
        
        for (String jwtTmp : jwtArr) {
            if (!BASE64_PATTERN.matcher(jwtTmp).matches()) {
                return true;
            }
            
        }
        
        return false;
    }
    
    public static Claims parseJwt(String jwt) throws ExpiredJwtException, UnsupportedJwtException, MalformedJwtException, SignatureException, IllegalArgumentException {
        return Jwts.parserBuilder().setSigningKey(secretKey).build() .parseClaimsJws(jwt).getBody();
    }
    
    public static void setDefaultSecretKey(String secretNowKeyValue) {
        byte[] secretKeyBytes = DatatypeConverter.parseBase64Binary(secretNowKeyValue);
        secretKey = Keys.hmacShaKeyFor(secretKeyBytes);
    }
    
}


