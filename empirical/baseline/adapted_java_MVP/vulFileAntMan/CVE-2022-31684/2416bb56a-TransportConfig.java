package reactor.netty.transport;
import java.net.SocketAddress;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;
import io.netty.buffer.ByteBufAllocator;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFactory;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.handler.logging.LoggingHandler;
import io.netty.util.AttributeKey;
import reactor.netty.ChannelPipelineConfigurer;
import reactor.netty.ConnectionObserver;
import reactor.netty.NettyPipeline;
import reactor.netty.channel.ChannelMetricsRecorder;
import reactor.netty.channel.ChannelOperations;
import reactor.netty.resources.LoopResources;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.Metrics;
import reactor.util.annotation.Nullable;
import static java.util.Objects.requireNonNull;
import static reactor.netty.ReactorNetty.format;
public abstract class TransportConfig {
	 public final Map<AttributeKey<?>, ?> attributes() {
		if (attrs.isEmpty()) {
			return Collections.emptyMap();
		}
		
		return Collections.unmodifiableMap(attrs);
	}
	
	public final Supplier<? extends SocketAddress> bindAddress() {
		return this.bindAddress;
	}
	
	public int channelHash() {
		return Objects.hash(attrs, bindAddress != null ? bindAddress.get() : 0, channelGroup, doOnChannelInit, loggingHandler, loopResources, metricsRecorder, observer, options, preferNative);
	}
	
	public final ChannelGroup channelGroup() {
		return channelGroup;
	}
	
	 public final ChannelInitializer<Channel> channelInitializer(ConnectionObserver connectionObserver, @Nullable SocketAddress remoteAddress, boolean onServer) {
		requireNonNull(connectionObserver, "connectionObserver");
		return new TransportChannelInitializer(this, connectionObserver, remoteAddress, onServer);
	}
	
	 public ChannelOperations.OnSetup channelOperationsProvider() {
		return ChannelOperations.OnSetup.empty();
	}
	
	 public final ConnectionObserver connectionObserver() {
		return observer;
	}
	
	 public final ChannelPipelineConfigurer doOnChannelInit() {
		return doOnChannelInit;
	}
	
	 public final boolean isPreferNative() {
		return this.preferNative;
	}
	
	public final LoggingHandler loggingHandler() {
		return loggingHandler;
	}
	
	 public final LoopResources loopResources() {
		return loopResources != null ? loopResources : defaultLoopResources();
	}
	
	public final Supplier<? extends ChannelMetricsRecorder> metricsRecorder() {
		return this.metricsRecorder != null ? () -> this.metricsRecorder : null;
	}
	
	 public final Map<ChannelOption<?>, ?> options() {
		if (options.isEmpty()) {
			return Collections.emptyMap();
		}
		
		return Collections.unmodifiableMap(options);
	}
	
	 Map<AttributeKey<?>, ?>                    attrs;
	Supplier<? extends SocketAddress>          bindAddress;
	ChannelGroup                               channelGroup;
	ChannelPipelineConfigurer                  doOnChannelInit;
	LoggingHandler                             loggingHandler;
	LoopResources                              loopResources;
	ChannelMetricsRecorder                     metricsRecorder;
	ConnectionObserver                         observer;
	Map<ChannelOption<?>, ?>                   options;
	boolean                                    preferNative;
	 protected TransportConfig(Map<ChannelOption<?>, ?> options) {
		this.attrs = Collections.emptyMap();
		this.doOnChannelInit = ChannelPipelineConfigurer.emptyConfigurer();
		this.observer = ConnectionObserver.emptyListener();
		this.options = requireNonNull(options, "options");
		this.preferNative = LoopResources.DEFAULT_NATIVE;
	}
	
	 protected TransportConfig(Map<ChannelOption<?>, ?> options, Supplier<? extends SocketAddress> bindAddress) {
		this.attrs = Collections.emptyMap();
		this.bindAddress = requireNonNull(bindAddress, "bindAddress");
		this.doOnChannelInit = ChannelPipelineConfigurer.emptyConfigurer();
		this.observer = ConnectionObserver.emptyListener();
		this.options = requireNonNull(options, "options");
		this.preferNative = LoopResources.DEFAULT_NATIVE;
	}
	
	 protected TransportConfig(TransportConfig parent) {
		this.attrs = parent.attrs;
		this.bindAddress = parent.bindAddress;
		this.channelGroup = parent.channelGroup;
		this.doOnChannelInit = parent.doOnChannelInit;
		this.loggingHandler = parent.loggingHandler;
		this.loopResources = parent.loopResources;
		this.metricsRecorder = parent.metricsRecorder;
		this.observer = parent.observer;
		this.options = parent.options;
		this.preferNative = parent.preferNative;
	}
	
	 protected abstract Class<? extends Channel> channelType(boolean isDomainSocket);
	 protected ChannelFactory<? extends Channel> connectionFactory(EventLoopGroup elg, boolean isDomainSocket) {
		return () -> loopResources().onChannel(channelType(isDomainSocket), elg);
	}
	
	 protected abstract ConnectionObserver defaultConnectionObserver();
	 protected abstract LoggingHandler defaultLoggingHandler();
	 protected abstract LoopResources defaultLoopResources();
	 protected abstract ChannelMetricsRecorder defaultMetricsRecorder();
	 protected abstract ChannelPipelineConfigurer defaultOnChannelInit();
	 protected abstract EventLoopGroup eventLoopGroup();
	protected void loggingHandler(LoggingHandler loggingHandler) {
		this.loggingHandler = loggingHandler;
	}
	
	 protected void metricsRecorder(@Nullable Supplier<? extends ChannelMetricsRecorder> metricsRecorderSupplier) {
		this.metricsRecorder = metricsRecorderSupplier != null ? metricsRecorderSupplier.get() : null;
	}
	
	protected ChannelMetricsRecorder metricsRecorderInternal() {
		return metricsRecorder;
	}
	
	protected static <K, V> Map<K, V> updateMap(Map<K, V> parentMap, Object key, @Nullable Object value) {
		if (parentMap.isEmpty()) {
			return value == null ? parentMap : Collections.singletonMap((K) key, (V) value);
		}
		
		else {
			Map<K, V> attrs = new HashMap<>(parentMap.size() + 1);
			attrs.putAll(parentMap);
			if (value == null) {
				attrs.remove(key);
			}
			
			else {
				attrs.put((K) key, (V) value);
			}
			
			return attrs;
		}
		
	}
	
	static final class TransportChannelInitializer extends ChannelInitializer<Channel> {
		final TransportConfig config;
		final ConnectionObserver connectionObserver;
		final boolean onServer;
		final SocketAddress remoteAddress;
		TransportChannelInitializer(TransportConfig config, ConnectionObserver connectionObserver, @Nullable SocketAddress remoteAddress, boolean onServer) {
			this.config = config;
			this.connectionObserver = connectionObserver;
			this.onServer = onServer;
			this.remoteAddress = remoteAddress;
		}
		
		protected void initChannel(Channel channel) {
			ChannelPipeline pipeline = channel.pipeline();
			if (config.metricsRecorder != null) {
				ChannelOperations.addMetricsHandler(channel, config.metricsRecorder, remoteAddress, onServer);
				if (Metrics.isInstrumentationAvailable()) {
					try {
						ByteBufAllocator alloc = channel.alloc();
						if (alloc instanceof PooledByteBufAllocator) {
							ByteBufAllocatorMetrics.INSTANCE.registerMetrics("pooled", ((PooledByteBufAllocator) alloc).metric(), alloc);
						}
						
						else if (alloc instanceof UnpooledByteBufAllocator) {
							ByteBufAllocatorMetrics.INSTANCE.registerMetrics("unpooled", ((UnpooledByteBufAllocator) alloc).metric(), alloc);
						}
						
						MicrometerEventLoopMeterRegistrar.INSTANCE.registerMetrics(channel.eventLoop());
					}
					
					catch (RuntimeException e) {
						log.warn("Exception caught while recording metrics.", e);
						 }
						 
				}
				
			}
			
			if (config.loggingHandler != null) {
				pipeline.addFirst(NettyPipeline.LoggingHandler, config.loggingHandler);
			}
			
			ChannelOperations.addReactiveBridge(channel, config.channelOperationsProvider(), connectionObserver);
			config.defaultOnChannelInit() .then(config.doOnChannelInit) .onChannelInit(connectionObserver, channel, remoteAddress);
			pipeline.remove(this);
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Initialized pipeline {}"), pipeline.toString());
			}
			
		}
		
	}
	
	static final Logger log = Loggers.getLogger(TransportConfig.class);
}

