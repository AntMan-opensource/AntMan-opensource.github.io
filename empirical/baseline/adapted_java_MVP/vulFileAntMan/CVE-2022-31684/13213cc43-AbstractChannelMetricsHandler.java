package reactor.netty.channel;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelDuplexHandler;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.channel.socket.DatagramPacket;
import reactor.netty.NettyPipeline;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;
import java.net.SocketAddress;
public abstract class AbstractChannelMetricsHandler extends ChannelDuplexHandler {
	private static final Logger log = Loggers.getLogger(AbstractChannelMetricsHandler.class);
	final SocketAddress remoteAddress;
	final boolean onServer;
	protected AbstractChannelMetricsHandler(@Nullable SocketAddress remoteAddress, boolean onServer) {
		this.remoteAddress = remoteAddress;
		this.onServer = onServer;
	}
	
	public void channelActive(ChannelHandlerContext ctx) {
		if (onServer) {
			try {
				recorder().recordServerConnectionOpened(ctx.channel().localAddress());
			}
			
			catch (RuntimeException e) {
				log.warn("Exception caught while recording metrics.", e);
				 }
				 
		}
		
		ctx.fireChannelActive();
	}
	
	public void channelInactive(ChannelHandlerContext ctx) {
		if (onServer) {
			try {
				recorder().recordServerConnectionClosed(ctx.channel().localAddress());
			}
			
			catch (RuntimeException e) {
				log.warn("Exception caught while recording metrics.", e);
				 }
				 
		}
		
		ctx.fireChannelInactive();
	}
	
	public void channelRegistered(ChannelHandlerContext ctx) {
		if (!onServer) {
			ctx.pipeline() .addAfter(NettyPipeline.ChannelMetricsHandler, NettyPipeline.ConnectMetricsHandler, connectMetricsHandler());
		}
		
		if (ctx.pipeline().get(NettyPipeline.SslHandler) != null) {
			ctx.pipeline() .addBefore(NettyPipeline.SslHandler, NettyPipeline.TlsMetricsHandler, tlsMetricsHandler());
		}
		
		ctx.fireChannelRegistered();
	}
	
	public void channelRead(ChannelHandlerContext ctx, Object msg) {
		try {
			if (msg instanceof ByteBuf) {
				ByteBuf buffer = (ByteBuf) msg;
				if (buffer.readableBytes() > 0) {
					recordRead(ctx, remoteAddress, buffer.readableBytes());
				}
				
			}
			
			else if (msg instanceof DatagramPacket) {
				DatagramPacket p = (DatagramPacket) msg;
				ByteBuf buffer = p.content();
				if (buffer.readableBytes() > 0) {
					recordRead(ctx, remoteAddress != null ? remoteAddress : p.sender(), buffer.readableBytes());
				}
				
			}
			
		}
		
		catch (RuntimeException e) {
			log.warn("Exception caught while recording metrics.", e);
			 }
			 
		ctx.fireChannelRead(msg);
	}
	
	public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
		try {
			if (msg instanceof ByteBuf) {
				ByteBuf buffer = (ByteBuf) msg;
				if (buffer.readableBytes() > 0) {
					recordWrite(ctx, remoteAddress, buffer.readableBytes());
				}
				
			}
			
			else if (msg instanceof DatagramPacket) {
				DatagramPacket p = (DatagramPacket) msg;
				ByteBuf buffer = p.content();
				if (buffer.readableBytes() > 0) {
					recordWrite(ctx, remoteAddress != null ? remoteAddress : p.recipient(), buffer.readableBytes());
				}
				
			}
			
		}
		
		catch (RuntimeException e) {
			log.warn("Exception caught while recording metrics.", e);
			 }
			 
		 ctx.write(msg, promise);
	}
	
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
		try {
			recordException(ctx, remoteAddress != null ? remoteAddress : ctx.channel().remoteAddress());
		}
		
		catch (RuntimeException e) {
			log.warn("Exception caught while recording metrics.", e);
			 }
			 
		ctx.fireExceptionCaught(cause);
	}
	
	public abstract ChannelHandler connectMetricsHandler();
	public abstract ChannelHandler tlsMetricsHandler();
	public abstract ChannelMetricsRecorder recorder();
	protected void recordException(ChannelHandlerContext ctx, SocketAddress address) {
		recorder().incrementErrorsCount(address);
	}
	
	protected void recordRead(ChannelHandlerContext ctx, SocketAddress address, long bytes) {
		recorder().recordDataReceived(address, bytes);
	}
	
	protected void recordWrite(ChannelHandlerContext ctx, SocketAddress address, long bytes) {
		recorder().recordDataSent(address, bytes);
	}
	
}


