package reactor.netty.transport;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.unix.DomainSocketAddress;
import io.netty.handler.codec.DecoderException;
import io.netty.util.AttributeKey;
import org.reactivestreams.Subscription;
import reactor.core.CoreSubscriber;
import reactor.core.publisher.Mono;
import reactor.core.publisher.MonoSink;
import reactor.core.publisher.Operators;
import reactor.netty.ChannelBindException;
import reactor.netty.Connection;
import reactor.netty.ConnectionObserver;
import reactor.netty.DisposableServer;
import reactor.netty.channel.AbortedException;
import reactor.netty.channel.ChannelOperations;
import reactor.netty.resources.ConnectionProvider;
import reactor.netty.resources.LoopResources;
import reactor.util.Logger;
import reactor.util.Loggers;
import reactor.util.annotation.Nullable;
import reactor.util.context.Context;
import static reactor.netty.ReactorNetty.format;
public abstract class ServerTransport<T extends ServerTransport<T, CONF>, CONF extends ServerTransportConfig<CONF>> extends Transport<T, CONF> {
	 public Mono<? extends DisposableServer> bind() {
		CONF config = configuration();
		Objects.requireNonNull(config.bindAddress(), "bindAddress");
		Mono<? extends DisposableServer> mono =  Mono.create(sink -> {
			SocketAddress local = Objects.requireNonNull(config.bindAddress().get(), "Bind Address supplier returned null");
			if (local instanceof InetSocketAddress) {
				InetSocketAddress localInet = (InetSocketAddress) local;
				if (localInet.isUnresolved()) {
					local = AddressUtils.createResolved(localInet.getHostName(), localInet.getPort());
				}
				
			}
			
			boolean isDomainSocket = false;
			DisposableBind disposableServer;
			if (local instanceof DomainSocketAddress) {
				isDomainSocket = true;
				disposableServer = new UdsDisposableBind(sink, config, local);
			}
			
			else {
				disposableServer = new InetDisposableBind(sink, config, local);
			}
			
			ConnectionObserver childObs = new ChildObserver(config.defaultChildObserver().then(config.childObserver()));
			Acceptor acceptor = new Acceptor(config.childEventLoopGroup(), config.channelInitializer(childObs, null, true), config.childOptions, config.childAttrs, isDomainSocket);
			TransportConnector.bind(config, new AcceptorInitializer(acceptor), local, isDomainSocket) .subscribe(disposableServer);
		}
		
);
		if (config.doOnBind() != null) {
			mono = mono.doOnSubscribe(s -> config.doOnBind().accept(config));
		}
		
		return mono;
	}
	
	 public final DisposableServer bindNow() {
		return bindNow(Duration.ofSeconds(45));
	}
	
	 public final DisposableServer bindNow(Duration timeout) {
		Objects.requireNonNull(timeout, "timeout");
		try {
			return Objects.requireNonNull(bind().block(timeout), "aborted");
		}
		
		catch (IllegalStateException e) {
			if (e.getMessage() .contains("blocking read")) {
				throw new IllegalStateException(getClass().getSimpleName() + " couldn't be started within " + timeout.toMillis() + "ms");
			}
			
			throw e;
		}
		
	}
	
	 public final void bindUntilJavaShutdown(Duration timeout, @Nullable Consumer<DisposableServer> onStart) {
		Objects.requireNonNull(timeout, "timeout");
		DisposableServer facade = Objects.requireNonNull(bindNow(), "facade");
		if (onStart != null) {
			onStart.accept(facade);
		}
		
		Runtime.getRuntime() .addShutdownHook(new Thread(() -> facade.disposeNow(timeout)));
		facade.onDispose() .block();
	}
	
	 public <A> T childAttr(AttributeKey<A> key, @Nullable A value) {
		Objects.requireNonNull(key, "key");
		T dup = duplicate();
		dup.configuration().childAttrs = TransportConfig.updateMap(configuration().childAttrs, key, value);
		return dup;
	}
	
	 public T childObserve(ConnectionObserver observer) {
		Objects.requireNonNull(observer, "observer");
		T dup = duplicate();
		ConnectionObserver current = configuration().childObserver;
		dup.configuration().childObserver = current == null ? observer : current.then(observer);
		return dup;
	}
	
	public <A> T childOption(ChannelOption<A> key, @Nullable A value) {
		Objects.requireNonNull(key, "key");
		 if (ChannelOption.AUTO_READ == key) {
			if (value instanceof Boolean && Boolean.TRUE.equals(value)) {
				log.error("ChannelOption.AUTO_READ is configured to be [false], it cannot be set to [true]");
			}
			
			@SuppressWarnings("unchecked")
			T dup = (T) this;
			return dup;
		}
		
		T dup = duplicate();
		dup.configuration().childOptions = TransportConfig.updateMap(configuration().childOptions, key, value);
		return dup;
	}
	
	 public T doOnBind(Consumer<? super CONF> doOnBind) {
		Objects.requireNonNull(doOnBind, "doOnBind");
		T dup = duplicate();
		@SuppressWarnings("unchecked")
		Consumer<CONF> current = (Consumer<CONF>) configuration().doOnBind;
		dup.configuration().doOnBind = current == null ? doOnBind : current.andThen(doOnBind);
		return dup;
	}
	
	 public T doOnBound(Consumer<? super DisposableServer> doOnBound) {
		Objects.requireNonNull(doOnBound, "doOnBound");
		T dup = duplicate();
		@SuppressWarnings("unchecked")
		Consumer<DisposableServer> current = (Consumer<DisposableServer>) configuration().doOnBound;
		dup.configuration().doOnBound = current == null ? doOnBound : current.andThen(doOnBound);
		return dup;
	}
	
	 public T doOnConnection(Consumer<? super Connection> doOnConnection) {
		Objects.requireNonNull(doOnConnection, "doOnConnected");
		T dup = duplicate();
		@SuppressWarnings("unchecked")
		Consumer<Connection> current = (Consumer<Connection>) configuration().doOnConnection;
		dup.configuration().doOnConnection = current == null ? doOnConnection : current.andThen(doOnConnection);
		return dup;
	}
	
	 public T doOnUnbound(Consumer<? super DisposableServer> doOnUnbound) {
		Objects.requireNonNull(doOnUnbound, "doOnUnbound");
		T dup = duplicate();
		@SuppressWarnings("unchecked")
		Consumer<DisposableServer> current = (Consumer<DisposableServer>) configuration().doOnUnbound;
		dup.configuration().doOnUnbound = current == null ? doOnUnbound : current.andThen(doOnUnbound);
		return dup;
	}
	
	 public T host(String host) {
		Objects.requireNonNull(host, "host");
		return bindAddress(() -> AddressUtils.updateHost(configuration().bindAddress(), host));
	}
	
	 public T port(int port) {
		return bindAddress(() -> AddressUtils.updatePort(configuration().bindAddress(), port));
	}
	
	 public Mono<Void> warmup() {
		return Mono.fromRunnable(() -> {
			 configuration().childEventLoopGroup();
			 configuration().eventLoopGroup();
		}
		
);
	}
	
	static final Logger log = Loggers.getLogger(ServerTransport.class);
	static class Acceptor extends ChannelInboundHandlerAdapter {
		final EventLoopGroup childGroup;
		final ChannelHandler childHandler;
		final Map<ChannelOption<?>, ?> childOptions;
		final Map<AttributeKey<?>, ?> childAttrs;
		final boolean isDomainSocket;
		Runnable enableAutoReadTask;
		Acceptor(EventLoopGroup childGroup, ChannelHandler childHandler, Map<ChannelOption<?>, ?> childOptions, Map<AttributeKey<?>, ?> childAttrs, boolean isDomainSocket) {
			this.childGroup = childGroup;
			this.childHandler = childHandler;
			this.childOptions = childOptions;
			this.childAttrs = childAttrs;
			this.isDomainSocket = isDomainSocket;
		}
		
		public void channelRead(ChannelHandlerContext ctx, Object msg) {
			final Channel child = (Channel) msg;
			child.pipeline().addLast(childHandler);
			TransportConnector.setChannelOptions(child, childOptions, isDomainSocket);
			TransportConnector.setAttributes(child, childAttrs);
			try {
				childGroup.register(child).addListener((ChannelFutureListener) future -> {
					if (!future.isSuccess()) {
						forceClose(child, future.cause());
					}
					
				}
				
);
			}
			
			catch (Throwable t) {
				forceClose(child, t);
			}
			
		}
		
		public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
			ChannelConfig config = ctx.channel().config();
			if (config.isAutoRead()) {
				 config.setAutoRead(false);
				ctx.channel() .eventLoop() .schedule(enableAutoReadTask, 1, TimeUnit.SECONDS) .addListener(future -> {
				       if (!future.isSuccess()) {
				           log.debug(format(ctx.channel(), "Cannot enable auto-read"), future.cause());
				       }
				       
				   }
				   
);
			}
			
		}
		
		void enableAutoReadTask(Channel channel) {
			 enableAutoReadTask = () -> channel.config().setAutoRead(true);
		}
		
		static void forceClose(Channel child, Throwable t) {
			child.unsafe().closeForcibly();
			log.warn(format(child, "Failed to register an accepted channel: {}"), child, t);
		}
		
	}
	
	static final class AcceptorInitializer extends ChannelInitializer<Channel> {
		final Acceptor acceptor;
		AcceptorInitializer(Acceptor acceptor) {
			this.acceptor = acceptor;
		}
		
		public void initChannel(final Channel ch) {
			ch.eventLoop().execute(() -> ch.pipeline().addLast(acceptor));
		}
		
	}
	
	static final class ChildObserver implements ConnectionObserver {
		final ConnectionObserver childObs;
		ChildObserver(ConnectionObserver childObs) {
			this.childObs = childObs;
		}
		
		public void onUncaughtException(Connection connection, Throwable error) {
			ChannelOperations<?, ?> ops = ChannelOperations.get(connection.channel());
			if (ops == null && (error instanceof IOException || AbortedException.isConnectionReset(error) || error instanceof DecoderException)) {
				if (log.isDebugEnabled()) {
					log.debug(format(connection.channel(), "onUncaughtException(" + connection + ")"), error);
				}
				
			}
			
			else {
				log.error(format(connection.channel(), "onUncaughtException(" + connection + ")"), error);
			}
			
			connection.dispose();
		}
		
		public void onStateChange(Connection connection, State newState) {
			if (newState == State.DISCONNECTING) {
				if (connection.channel().isActive() && !connection.isPersistent()) {
					connection.dispose();
				}
				
			}
			
			childObs.onStateChange(connection, newState);
		}
		
	}
	
	static class DisposableBind implements CoreSubscriber<Channel>, DisposableServer, Connection {
		final MonoSink<DisposableServer> sink;
		final Context                    currentContext;
		final TransportConfig            config;
		final SocketAddress              bindAddress;
		Channel channel;
		Subscription subscription;
		DisposableBind(MonoSink<DisposableServer> sink, TransportConfig config, SocketAddress bindAddress) {
			this.sink = sink;
			this.currentContext = Context.of(sink.contextView());
			this.config = config;
			this.bindAddress = bindAddress;
		}
		
		public Channel channel() {
			return channel;
		}
		
		public Context currentContext() {
			return currentContext;
		}
		
		public final void dispose() {
			if (channel != null) {
				if (channel.isActive()) {
					 channel.close();
					LoopResources loopResources = config.loopResources();
					if (loopResources instanceof ConnectionProvider) {
						((ConnectionProvider) loopResources).disposeWhen(bindAddress);
					}
					
				}
				
			}
			
			else {
				subscription.cancel();
			}
			
		}
		
		public void disposeNow(Duration timeout) {
			if (isDisposed()) {
				return;
			}
			
			dispose();
			Mono<Void> terminateSignals = Mono.empty();
			if (config.channelGroup != null) {
				List<Mono<Void>> channels = new ArrayList<>();
				 config.channelGroup.forEach(channel -> {
					ChannelOperations<?, ?> ops = ChannelOperations.get(channel);
					if (ops != null) {
						channels.add(ops.onTerminate().doFinally(sig -> ops.dispose()));
					}
					
					else {
						 channel.close();
					}
					
				}
				
);
				if (!channels.isEmpty()) {
					terminateSignals = Mono.when(channels);
				}
				
			}
			
			try {
				onDispose().then(terminateSignals) .block(timeout);
			}
			
			catch (IllegalStateException e) {
				if (e.getMessage() .contains("blocking read")) {
					throw new IllegalStateException("Socket couldn't be stopped within " + timeout.toMillis() + "ms");
				}
				
				throw e;
			}
			
		}
		
		public void onComplete() {
		}
		
		public void onError(Throwable t) {
			sink.error(ChannelBindException.fail(bindAddress, t));
		}
		
		public void onNext(Channel channel) {
			this.channel = channel;
			if (log.isDebugEnabled()) {
				log.debug(format(channel, "Bound new server"));
			}
			
			sink.success(this);
			config.defaultConnectionObserver() .then(config.connectionObserver()) .onStateChange(this, ConnectionObserver.State.CONNECTED);
		}
		
		public void onSubscribe(Subscription s) {
			if (Operators.validate(subscription, s)) {
				this.subscription = s;
				sink.onCancel(this);
				s.request(Long.MAX_VALUE);
			}
			
		}
		
	}
	
	static final class InetDisposableBind extends DisposableBind {
		InetDisposableBind(MonoSink<DisposableServer> sink, TransportConfig config, SocketAddress bindAddress) {
			super(sink, config, bindAddress);
		}
		
		public InetSocketAddress address() {
			return (InetSocketAddress) channel().localAddress();
		}
		
		public String host() {
			return address().getHostString();
		}
		
		public int port() {
			return address().getPort();
		}
		
	}
	
	static final class UdsDisposableBind extends DisposableBind {
		UdsDisposableBind(MonoSink<DisposableServer> sink, TransportConfig config, SocketAddress bindAddress) {
			super(sink, config, bindAddress);
		}
		
		public DomainSocketAddress address() {
			return (DomainSocketAddress) channel().localAddress();
		}
		
		public String path() {
			return address().path();
		}
		
	}
	
}

