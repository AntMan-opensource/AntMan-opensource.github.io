package org.opensearch.ad.transport;
import static org.opensearch.ad.constant.CommonErrorMessages.INVALID_SEARCH_QUERY_MSG;
import static org.opensearch.ad.settings.AnomalyDetectorSettings.MAX_ENTITIES_PER_QUERY;
import static org.opensearch.ad.settings.AnomalyDetectorSettings.PAGE_SIZE;
import java.net.ConnectException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.opensearch.ExceptionsHelper;
import org.opensearch.OpenSearchTimeoutException;
import org.opensearch.action.ActionListener;
import org.opensearch.action.ActionListenerResponseHandler;
import org.opensearch.action.ActionRequest;
import org.opensearch.action.search.SearchPhaseExecutionException;
import org.opensearch.action.search.ShardSearchFailure;
import org.opensearch.action.support.ActionFilters;
import org.opensearch.action.support.HandledTransportAction;
import org.opensearch.action.support.IndicesOptions;
import org.opensearch.action.support.ThreadedActionListener;
import org.opensearch.action.support.master.AcknowledgedResponse;
import org.opensearch.ad.AnomalyDetectorPlugin;
import org.opensearch.ad.NodeStateManager;
import org.opensearch.ad.breaker.ADCircuitBreakerService;
import org.opensearch.ad.cluster.HashRing;
import org.opensearch.ad.common.exception.AnomalyDetectionException;
import org.opensearch.ad.common.exception.ClientException;
import org.opensearch.ad.common.exception.EndRunException;
import org.opensearch.ad.common.exception.InternalFailure;
import org.opensearch.ad.common.exception.LimitExceededException;
import org.opensearch.ad.common.exception.NotSerializedADExceptionName;
import org.opensearch.ad.common.exception.ResourceNotFoundException;
import org.opensearch.ad.constant.CommonErrorMessages;
import org.opensearch.ad.constant.CommonName;
import org.opensearch.ad.feature.CompositeRetriever;
import org.opensearch.ad.feature.CompositeRetriever.PageIterator;
import org.opensearch.ad.feature.FeatureManager;
import org.opensearch.ad.feature.SinglePointFeatures;
import org.opensearch.ad.ml.ModelManager;
import org.opensearch.ad.ml.SingleStreamModelIdMapper;
import org.opensearch.ad.model.AnomalyDetector;
import org.opensearch.ad.model.Entity;
import org.opensearch.ad.model.FeatureData;
import org.opensearch.ad.model.IntervalTimeConfiguration;
import org.opensearch.ad.settings.AnomalyDetectorSettings;
import org.opensearch.ad.settings.EnabledSetting;
import org.opensearch.ad.stats.ADStats;
import org.opensearch.ad.stats.StatNames;
import org.opensearch.ad.task.ADTaskManager;
import org.opensearch.ad.util.ExceptionUtil;
import org.opensearch.ad.util.ParseUtils;
import org.opensearch.client.Client;
import org.opensearch.cluster.ClusterState;
import org.opensearch.cluster.block.ClusterBlockLevel;
import org.opensearch.cluster.metadata.IndexNameExpressionResolver;
import org.opensearch.cluster.node.DiscoveryNode;
import org.opensearch.cluster.node.DiscoveryNodes;
import org.opensearch.cluster.service.ClusterService;
import org.opensearch.common.inject.Inject;
import org.opensearch.common.io.stream.NotSerializableExceptionWrapper;
import org.opensearch.common.lease.Releasable;
import org.opensearch.common.settings.Settings;
import org.opensearch.common.transport.NetworkExceptionHelper;
import org.opensearch.common.util.concurrent.ThreadContext;
import org.opensearch.common.xcontent.NamedXContentRegistry;
import org.opensearch.index.IndexNotFoundException;
import org.opensearch.node.NodeClosedException;
import org.opensearch.rest.RestStatus;
import org.opensearch.tasks.Task;
import org.opensearch.threadpool.ThreadPool;
import org.opensearch.transport.ActionNotFoundTransportException;
import org.opensearch.transport.ConnectTransportException;
import org.opensearch.transport.NodeNotConnectedException;
import org.opensearch.transport.ReceiveTimeoutTransportException;
import org.opensearch.transport.TransportRequestOptions;
import org.opensearch.transport.TransportService;
public class AnomalyResultTransportAction extends HandledTransportAction<ActionRequest, AnomalyResultResponse> {
    private static final Logger LOG = LogManager.getLogger(AnomalyResultTransportAction.class);
    static final String NO_MODEL_ERR_MSG = "No RCF models are available either because RCF" + " models are not ready or all nodes are unresponsive or the system might have bugs.";
    static final String WAIT_FOR_THRESHOLD_ERR_MSG = "Exception in waiting for threshold result";
    static final String NODE_UNRESPONSIVE_ERR_MSG = "Model node is unresponsive.  Mute node";
    static final String READ_WRITE_BLOCKED = "Cannot read/write due to global block.";
    static final String INDEX_READ_BLOCKED = "Cannot read user index due to read block.";
    static final String NULL_RESPONSE = "Received null response from";
    static final String TROUBLE_QUERYING_ERR_MSG = "Having trouble querying data: ";
    static final String NO_ACK_ERR = "no acknowledgements from model hosting nodes.";
    private final TransportService transportService;
    private final NodeStateManager stateManager;
    private final FeatureManager featureManager;
    private final ModelManager modelManager;
    private final HashRing hashRing;
    private final TransportRequestOptions option;
    private final ClusterService clusterService;
    private final IndexNameExpressionResolver indexNameExpressionResolver;
    private final ADStats adStats;
    private final ADCircuitBreakerService adCircuitBreakerService;
    private final ThreadPool threadPool;
    private final Client client;
    private final ADTaskManager adTaskManager;
    private final Set<String> hcDetectors;
    private NamedXContentRegistry xContentRegistry;
    private Settings settings;
    private final float intervalRatioForRequest;
    private int maxEntitiesPerInterval;
    private int pageSize;
    public AnomalyResultTransportAction( ActionFilters actionFilters, TransportService transportService, Settings settings, Client client, NodeStateManager manager, FeatureManager featureManager, ModelManager modelManager, HashRing hashRing, ClusterService clusterService, IndexNameExpressionResolver indexNameExpressionResolver, ADCircuitBreakerService adCircuitBreakerService, ADStats adStats, ThreadPool threadPool, NamedXContentRegistry xContentRegistry, ADTaskManager adTaskManager ) {
        super(AnomalyResultAction.NAME, transportService, actionFilters, AnomalyResultRequest::new);
        this.transportService = transportService;
        this.settings = settings;
        this.client = client;
        this.stateManager = manager;
        this.featureManager = featureManager;
        this.modelManager = modelManager;
        this.hashRing = hashRing;
        this.option = TransportRequestOptions .builder() .withType(TransportRequestOptions.Type.REG) .withTimeout(AnomalyDetectorSettings.REQUEST_TIMEOUT.get(settings)) .build();
        this.clusterService = clusterService;
        this.indexNameExpressionResolver = indexNameExpressionResolver;
        this.adCircuitBreakerService = adCircuitBreakerService;
        this.adStats = adStats;
        this.threadPool = threadPool;
        this.hcDetectors = new HashSet<>();
        this.xContentRegistry = xContentRegistry;
        this.intervalRatioForRequest = AnomalyDetectorSettings.INTERVAL_RATIO_FOR_REQUESTS;
        this.maxEntitiesPerInterval = MAX_ENTITIES_PER_QUERY.get(settings);
        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ENTITIES_PER_QUERY, it -> maxEntitiesPerInterval = it);
        this.pageSize = PAGE_SIZE.get(settings);
        clusterService.getClusterSettings().addSettingsUpdateConsumer(PAGE_SIZE, it -> pageSize = it);
        this.adTaskManager = adTaskManager;
    }
    
    protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<AnomalyResultResponse> listener) {
        try (ThreadContext.StoredContext context = client.threadPool().getThreadContext().stashContext()) {
            AnomalyResultRequest request = AnomalyResultRequest.fromActionRequest(actionRequest);
            String adID = request.getAdID();
            ActionListener<AnomalyResultResponse> original = listener;
            listener = ActionListener.wrap(r -> {
                hcDetectors.remove(adID);
                original.onResponse(r);
            }, e -> {
                if (!(e instanceof AnomalyDetectionException) || ((AnomalyDetectionException) e).isCountedInStats()) {
                    adStats.getStat(StatNames.AD_EXECUTE_FAIL_COUNT.getName()).increment();
                    if (hcDetectors.contains(adID)) {
                        adStats.getStat(StatNames.AD_HC_EXECUTE_FAIL_COUNT.getName()).increment();
                    }
                    
                }
                
                hcDetectors.remove(adID);
                original.onFailure(e);
            }
            
);
            if (!EnabledSetting.isADPluginEnabled()) {
                throw new EndRunException(adID, CommonErrorMessages.DISABLED_ERR_MSG, true).countedInStats(false);
            }
            
            adStats.getStat(StatNames.AD_EXECUTE_REQUEST_COUNT.getName()).increment();
            if (adCircuitBreakerService.isOpen()) {
                listener.onFailure(new LimitExceededException(adID, CommonErrorMessages.MEMORY_CIRCUIT_BROKEN_ERR_MSG, false));
                return;
            }
            
            try {
                stateManager.getAnomalyDetector(adID, onGetDetector(listener, adID, request));
            }
             catch (Exception ex) {
                handleExecuteException(ex, listener, adID);
            }
            
        }
         catch (Exception e) {
            LOG.error(e);
            listener.onFailure(e);
        }
        
    }
    
    class PageListener implements ActionListener<CompositeRetriever.Page> {
        private PageIterator pageIterator;
        private String detectorId;
        private long dataStartTime;
        private long dataEndTime;
        PageListener(PageIterator pageIterator, String detectorId, long dataStartTime, long dataEndTime) {
            this.pageIterator = pageIterator;
            this.detectorId = detectorId;
            this.dataStartTime = dataStartTime;
            this.dataEndTime = dataEndTime;
        }
        
        public void onResponse(CompositeRetriever.Page entityFeatures) {
            if (entityFeatures != null && false == entityFeatures.isEmpty()) {
                threadPool.executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME).execute(() -> {
                    try {
                        Set<Entry<DiscoveryNode, Map<Entity, double[]>>> node2Entities = entityFeatures .getResults() .entrySet() .stream() .filter(e -> hashRing.getOwningNodeWithSameLocalAdVersionForRealtimeAD(e.getKey().toString()).isPresent()) .collect( Collectors .groupingBy( e -> hashRing.getOwningNodeWithSameLocalAdVersionForRealtimeAD(e.getKey().toString()).get(), Collectors.toMap(Entry::getKey, Entry::getValue) ) ) .entrySet();
                        Iterator<Entry<DiscoveryNode, Map<Entity, double[]>>> iterator = node2Entities.iterator();
                        while (iterator.hasNext()) {
                            Entry<DiscoveryNode, Map<Entity, double[]>> entry = iterator.next();
                            DiscoveryNode modelNode = entry.getKey();
                            if (modelNode == null) {
                                iterator.remove();
                                continue;
                            }
                            
                            String modelNodeId = modelNode.getId();
                            if (stateManager.isMuted(modelNodeId, detectorId)) {
                                LOG .info( String .format(Locale.ROOT, NODE_UNRESPONSIVE_ERR_MSG + " %s for detector %s", modelNodeId, detectorId) );
                                iterator.remove();
                            }
                            
                        }
                        
                        final AtomicReference<Exception> failure = new AtomicReference<>();
                        int nodeCount = node2Entities.size();
                        AtomicInteger responseCount = new AtomicInteger();
                        node2Entities.stream().forEach(nodeEntity -> {
                            DiscoveryNode node = nodeEntity.getKey();
                            transportService .sendRequest( node, EntityResultAction.NAME, new EntityResultRequest(detectorId, nodeEntity.getValue(), dataStartTime, dataEndTime), option, new ActionListenerResponseHandler<>( new EntityResultListener( node.getId(), detectorId, failure, nodeCount, pageIterator, this, responseCount ), AcknowledgedResponse::new, ThreadPool.Names.SAME ) );
                        }
                        
);
                    }
                     catch (Exception e) {
                        LOG.error("Unexpected exception", e);
                        handleException(e);
                    }
                    
                }
                
);
            }
            
        }
        
        public void onFailure(Exception e) {
            LOG.error("Unexpetected exception", e);
            handleException(e);
        }
        
        private void handleException(Exception e) {
            Exception convertedException = convertedQueryFailureException(e, detectorId);
            if (false == (convertedException instanceof AnomalyDetectionException)) {
                Throwable cause = ExceptionsHelper.unwrapCause(convertedException);
                convertedException = new InternalFailure(detectorId, cause);
            }
            
            stateManager.setException(detectorId, convertedException);
        }
        
    }
    
    private ActionListener<Optional<AnomalyDetector>> onGetDetector( ActionListener<AnomalyResultResponse> listener, String adID, AnomalyResultRequest request ) {
        return ActionListener.wrap(detectorOptional -> {
            if (!detectorOptional.isPresent()) {
                listener.onFailure(new EndRunException(adID, "AnomalyDetector is not available.", true));
                return;
            }
            
            AnomalyDetector anomalyDetector = detectorOptional.get();
            if (anomalyDetector.isMultientityDetector()) {
                hcDetectors.add(adID);
                adStats.getStat(StatNames.AD_HC_EXECUTE_REQUEST_COUNT.getName()).increment();
            }
            
            long delayMillis = Optional .ofNullable((IntervalTimeConfiguration) anomalyDetector.getWindowDelay()) .map(t -> t.toDuration().toMillis()) .orElse(0L);
            long dataStartTime = request.getStart() - delayMillis;
            long dataEndTime = request.getEnd() - delayMillis;
            adTaskManager .initRealtimeTaskCacheAndCleanupStaleCache( adID, anomalyDetector, transportService, ActionListener .runAfter( initRealtimeTaskCacheListener(adID), () -> executeAnomalyDetection(listener, adID, request, anomalyDetector, dataStartTime, dataEndTime) ) );
        }, exception -> handleExecuteException(exception, listener, adID));
    }
    
    private ActionListener<Boolean> initRealtimeTaskCacheListener(String detectorId) {
        return ActionListener.wrap(r -> {
            if (r) {
                LOG.debug("Realtime task cache initied for detector {}", detectorId);
            }
            
        }, e -> LOG.error("Failed to init realtime task cache for " + detectorId, e));
    }
    
    private void executeAnomalyDetection( ActionListener<AnomalyResultResponse> listener, String adID, AnomalyResultRequest request, AnomalyDetector anomalyDetector, long dataStartTime, long dataEndTime ) {
        if (anomalyDetector.isMultientityDetector()) {
            Optional<Exception> previousException = stateManager.fetchExceptionAndClear(adID);
            if (previousException.isPresent()) {
                Exception exception = previousException.get();
                LOG.error(new ParameterizedMessage("Previous exception of [{}]", adID), exception);
                if (exception instanceof EndRunException) {
                    EndRunException endRunException = (EndRunException) exception;
                    if (endRunException.isEndNow()) {
                        listener.onFailure(exception);
                        return;
                    }
                    
                }
                
            }
            
            long nextDetectionStartTime = request.getEnd() + (long) (anomalyDetector.getDetectorIntervalInMilliseconds() * intervalRatioForRequest);
            CompositeRetriever compositeRetriever = new CompositeRetriever( dataStartTime, dataEndTime, anomalyDetector, xContentRegistry, client, nextDetectionStartTime, settings, maxEntitiesPerInterval, pageSize, indexNameExpressionResolver, clusterService );
            PageIterator pageIterator = null;
            try {
                pageIterator = compositeRetriever.iterator();
            }
             catch (Exception e) {
                listener .onFailure( new EndRunException(anomalyDetector.getDetectorId(), CommonErrorMessages.INVALID_SEARCH_QUERY_MSG, e, false) );
                return;
            }
            
            PageListener getEntityFeatureslistener = new PageListener(pageIterator, adID, dataStartTime, dataEndTime);
            if (pageIterator.hasNext()) {
                pageIterator.next(getEntityFeatureslistener);
            }
            
            if (previousException.isPresent()) {
                listener.onFailure(previousException.get());
            }
             else {
                listener .onResponse( new AnomalyResultResponse( new ArrayList<FeatureData>(), null, null, anomalyDetector.getDetectorIntervalInMinutes(), true ) );
            }
            
            return;
        }
        
        String rcfModelID = SingleStreamModelIdMapper.getRcfModelId(adID, 0);
        Optional<DiscoveryNode> asRCFNode = hashRing.getOwningNodeWithSameLocalAdVersionForRealtimeAD(rcfModelID);
        if (!asRCFNode.isPresent()) {
            listener.onFailure(new InternalFailure(adID, "RCF model node is not available."));
            return;
        }
        
        DiscoveryNode rcfNode = asRCFNode.get();
        if (!shouldStart(listener, adID, anomalyDetector, rcfNode.getId(), rcfModelID)) {
            return;
        }
        
        featureManager .getCurrentFeatures( anomalyDetector, dataStartTime, dataEndTime, onFeatureResponseForSingleEntityDetector(adID, anomalyDetector, listener, rcfModelID, rcfNode, dataStartTime, dataEndTime) );
    }
    
    private ActionListener<SinglePointFeatures> onFeatureResponseForSingleEntityDetector( String adID, AnomalyDetector detector, ActionListener<AnomalyResultResponse> listener, String rcfModelId, DiscoveryNode rcfNode, long dataStartTime, long dataEndTime ) {
        return ActionListener.wrap(featureOptional -> {
            List<FeatureData> featureInResponse = null;
            if (featureOptional.getUnprocessedFeatures().isPresent()) {
                featureInResponse = ParseUtils.getFeatureData(featureOptional.getUnprocessedFeatures().get(), detector);
            }
            
            if (!featureOptional.getProcessedFeatures().isPresent()) {
                Optional<Exception> exception = coldStartIfNoCheckPoint(detector);
                if (exception.isPresent()) {
                    listener.onFailure(exception.get());
                    return;
                }
                
                if (!featureOptional.getUnprocessedFeatures().isPresent()) {
                    LOG.debug("No data in current detection window between {} and {} for {}", dataStartTime, dataEndTime, adID);
                    listener .onResponse( new AnomalyResultResponse( new ArrayList<FeatureData>(), "No data in current detection window", null, null, false ) );
                }
                 else {
                    LOG.debug("Return at least current feature value between {} and {} for {}", dataStartTime, dataEndTime, adID);
                    listener .onResponse( new AnomalyResultResponse(featureInResponse, "No full shingle in current detection window", null, null, false) );
                }
                
                return;
            }
            
            final AtomicReference<Exception> failure = new AtomicReference<Exception>();
            LOG.info("Sending RCF request to {} for model {}", rcfNode.getId(), rcfModelId);
            RCFActionListener rcfListener = new RCFActionListener( rcfModelId, failure, rcfNode.getId(), detector, listener, featureInResponse, adID );
            transportService .sendRequest( rcfNode, RCFResultAction.NAME, new RCFResultRequest(adID, rcfModelId, featureOptional.getProcessedFeatures().get()), option, new ActionListenerResponseHandler<>(rcfListener, RCFResultResponse::new) );
        }, exception -> { handleQueryFailure(exception, listener, adID); });
    }
    
    private void handleQueryFailure(Exception exception, ActionListener<AnomalyResultResponse> listener, String adID) {
        Exception convertedQueryFailureException = convertedQueryFailureException(exception, adID);
        if (convertedQueryFailureException instanceof EndRunException) {
            listener.onFailure(convertedQueryFailureException);
        }
         else {
            handleExecuteException(convertedQueryFailureException, listener, adID);
        }
        
    }
    
    private Exception convertedQueryFailureException(Exception exception, String adID) {
        if (ExceptionUtil.isIndexNotAvailable(exception)) {
            return new EndRunException(adID, TROUBLE_QUERYING_ERR_MSG + exception.getMessage(), false).countedInStats(false);
        }
         else if (exception instanceof SearchPhaseExecutionException && invalidQuery((SearchPhaseExecutionException) exception)) {
            return new EndRunException( adID, INVALID_SEARCH_QUERY_MSG + " " + ((SearchPhaseExecutionException) exception).getDetailedMessage(), exception, false ).countedInStats(false);
        }
        
        return exception;
    }
    
    private Exception coldStartIfNoModel(AtomicReference<Exception> failure, AnomalyDetector detector) throws Exception {
        Exception exp = failure.get();
        if (exp == null) {
            return null;
        }
        
        if (!(exp instanceof ResourceNotFoundException)) {
            return exp;
        }
        
        String adID = detector.getDetectorId();
        final Optional<Exception> previousException = stateManager.fetchExceptionAndClear(adID);
        if (previousException.isPresent()) {
            Exception exception = previousException.get();
            LOG.error("Previous exception of {}: {}", () -> adID, () -> exception);
            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {
                return exception;
            }
            
        }
        
        LOG.info("Trigger cold start for {}", detector.getDetectorId());
        coldStart(detector);
        return previousException.orElse(new InternalFailure(adID, NO_MODEL_ERR_MSG));
    }
    
    private void findException(Throwable cause, String adID, AtomicReference<Exception> failure, String nodeId) {
        if (cause == null) {
            LOG.error(new ParameterizedMessage("Null input exception"));
            return;
        }
        
        if (cause instanceof Error) {
            LOG.error(new ParameterizedMessage("Error during prediction for {}: ", adID), cause);
            return;
        }
        
        Exception causeException = (Exception) cause;
        if (causeException instanceof AnomalyDetectionException) {
            failure.set(causeException);
        }
         else if (causeException instanceof NotSerializableExceptionWrapper) {
            Optional<AnomalyDetectionException> actualException = NotSerializedADExceptionName .convertWrappedAnomalyDetectionException((NotSerializableExceptionWrapper) causeException, adID);
            if (actualException.isPresent()) {
                AnomalyDetectionException adException = actualException.get();
                failure.set(adException);
                if (adException instanceof ResourceNotFoundException) {
                    stateManager.addPressure(nodeId, adID);
                }
                
            }
             else {
                failure.set(new EndRunException(adID, CommonErrorMessages.BUG_RESPONSE, causeException, false));
            }
            
        }
         else if (causeException instanceof IndexNotFoundException && causeException.getMessage().contains(CommonName.CHECKPOINT_INDEX_NAME)) {
            failure.set(new ResourceNotFoundException(adID, causeException.getMessage()));
        }
         else if (causeException instanceof OpenSearchTimeoutException) {
            failure.set(new InternalFailure(adID, causeException));
        }
         else {
            failure.set(new EndRunException(adID, CommonErrorMessages.BUG_RESPONSE, causeException, false));
        }
        
    }
    
    void handleExecuteException(Exception ex, ActionListener<AnomalyResultResponse> listener, String adID) {
        if (ex instanceof ClientException) {
            listener.onFailure(ex);
        }
         else if (ex instanceof AnomalyDetectionException) {
            listener.onFailure(new InternalFailure((AnomalyDetectionException) ex));
        }
         else {
            Throwable cause = ExceptionsHelper.unwrapCause(ex);
            listener.onFailure(new InternalFailure(adID, cause));
        }
        
    }
    
    private boolean invalidQuery(SearchPhaseExecutionException ex) {
        for (ShardSearchFailure failure : ex.shardFailures()) {
            if (RestStatus.BAD_REQUEST != failure.status() || !(failure.getCause() instanceof IllegalArgumentException)) {
                return false;
            }
            
        }
        
        return true;
    }
    
    class RCFActionListener implements ActionListener<RCFResultResponse> {
        private String modelID;
        private AtomicReference<Exception> failure;
        private String rcfNodeID;
        private AnomalyDetector detector;
        private ActionListener<AnomalyResultResponse> listener;
        private List<FeatureData> featureInResponse;
        private final String adID;
        RCFActionListener( String modelID, AtomicReference<Exception> failure, String rcfNodeID, AnomalyDetector detector, ActionListener<AnomalyResultResponse> listener, List<FeatureData> features, String adID ) {
            this.modelID = modelID;
            this.failure = failure;
            this.rcfNodeID = rcfNodeID;
            this.detector = detector;
            this.listener = listener;
            this.featureInResponse = features;
            this.adID = adID;
        }
        
        public void onResponse(RCFResultResponse response) {
            try {
                stateManager.resetBackpressureCounter(rcfNodeID, adID);
                if (response != null) {
                    listener .onResponse( new AnomalyResultResponse( response.getAnomalyGrade(), response.getConfidence(), response.getRCFScore(), featureInResponse, null, response.getTotalUpdates(), detector.getDetectorIntervalInMinutes(), false, response.getRelativeIndex(), response.getAttribution(), response.getPastValues(), response.getExpectedValuesList(), response.getLikelihoodOfValues(), response.getThreshold() ) );
                }
                 else {
                    LOG.warn(NULL_RESPONSE + " {} for {}", modelID, rcfNodeID);
                    listener.onFailure(new InternalFailure(adID, NO_MODEL_ERR_MSG));
                }
                
            }
             catch (Exception ex) {
                LOG.error(new ParameterizedMessage("Unexpected exception for [{}]", adID), ex);
                handleExecuteException(ex, listener, adID);
            }
            
        }
        
        public void onFailure(Exception e) {
            try {
                handlePredictionFailure(e, adID, rcfNodeID, failure);
                Exception exception = coldStartIfNoModel(failure, detector);
                if (exception != null) {
                    listener.onFailure(exception);
                }
                 else {
                    listener.onFailure(new InternalFailure(adID, "Node connection problem or unexpected exception"));
                }
                
            }
             catch (Exception ex) {
                LOG.error(new ParameterizedMessage("Unexpected exception for [{}]", adID), ex);
                handleExecuteException(ex, listener, adID);
            }
            
        }
        
    }
    
    private void handlePredictionFailure(Exception e, String adID, String nodeID, AtomicReference<Exception> failure) {
        LOG.error(new ParameterizedMessage("Received an error from node {} while doing model inference for {}", nodeID, adID), e);
        if (e == null) {
            return;
        }
        
        Throwable cause = ExceptionsHelper.unwrapCause(e);
        if (hasConnectionIssue(cause)) {
            handleConnectionException(nodeID, adID);
        }
         else {
            findException(cause, adID, failure, nodeID);
        }
        
    }
    
    private boolean hasConnectionIssue(Throwable e) {
        return e instanceof ConnectTransportException || e instanceof NodeClosedException || e instanceof ReceiveTimeoutTransportException || e instanceof NodeNotConnectedException || e instanceof ConnectException || NetworkExceptionHelper.isCloseConnectionException(e) || e instanceof ActionNotFoundTransportException;
    }
    
    private void handleConnectionException(String node, String detectorId) {
        final DiscoveryNodes nodes = clusterService.state().nodes();
        if (!nodes.nodeExists(node)) {
            hashRing.buildCirclesForRealtimeAD();
            return;
        }
        
        stateManager.addPressure(node, detectorId);
    }
    
    private boolean checkGlobalBlock(ClusterState state) {
        return state.blocks().globalBlockedException(ClusterBlockLevel.READ) != null || state.blocks().globalBlockedException(ClusterBlockLevel.WRITE) != null;
    }
    
    private boolean checkIndicesBlocked(ClusterState state, ClusterBlockLevel level, String... indices) {
        String[] concreteIndices = indexNameExpressionResolver.concreteIndexNames(state, IndicesOptions.lenientExpandOpen(), indices);
        return state.blocks().indicesBlockedException(level, concreteIndices) != null;
    }
    
    private boolean shouldStart( ActionListener<AnomalyResultResponse> listener, String adID, AnomalyDetector detector, String rcfNodeId, String rcfModelID ) {
        ClusterState state = clusterService.state();
        if (checkGlobalBlock(state)) {
            listener.onFailure(new InternalFailure(adID, READ_WRITE_BLOCKED));
            return false;
        }
        
        if (stateManager.isMuted(rcfNodeId, adID)) {
            listener .onFailure( new InternalFailure( adID, String.format(Locale.ROOT, NODE_UNRESPONSIVE_ERR_MSG + " %s for rcf model %s", rcfNodeId, rcfModelID) ) );
            return false;
        }
        
        if (checkIndicesBlocked(state, ClusterBlockLevel.READ, detector.getIndices().toArray(new String[0]))) {
            listener.onFailure(new InternalFailure(adID, INDEX_READ_BLOCKED));
            return false;
        }
        
        return true;
    }
    
    private void coldStart(AnomalyDetector detector) {
        String detectorId = detector.getDetectorId();
        if (stateManager.isColdStartRunning(detectorId)) {
            return;
        }
        
        final Releasable coldStartFinishingCallback = stateManager.markColdStartRunning(detectorId);
        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {
            if (trainingData.isPresent()) {
                double[][] dataPoints = trainingData.get();
                ActionListener<Void> trainModelListener = ActionListener .wrap(res -> { LOG.info("Succeeded in training {}", detectorId); }, exception -> {
                        if (exception instanceof AnomalyDetectionException) {
                            stateManager.setException(detectorId, exception);
                        }
                         else if (exception instanceof IllegalArgumentException) {
                            stateManager .setException(detectorId, new EndRunException(detectorId, "Invalid training data", exception, false));
                        }
                         else if (exception instanceof OpenSearchTimeoutException) {
                            stateManager .setException( detectorId, new InternalFailure(detectorId, "Time out while indexing cold start checkpoint", exception) );
                        }
                         else {
                            stateManager .setException(detectorId, new EndRunException(detectorId, "Error while training model", exception, false));
                        }
                        
                    }
                    
);
                modelManager .trainModel( detector, dataPoints, new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false) );
            }
             else {
                stateManager.setException(detectorId, new EndRunException(detectorId, "Cannot get training data", false));
            }
            
        }, exception -> {
            if (exception instanceof OpenSearchTimeoutException) {
                stateManager.setException(detectorId, new InternalFailure(detectorId, "Time out while getting training data", exception));
            }
             else if (exception instanceof AnomalyDetectionException) {
                stateManager.setException(detectorId, exception);
            }
             else {
                stateManager.setException(detectorId, new EndRunException(detectorId, "Error while cold start", exception, false));
            }
            
        }
        
);
        final ActionListener<Optional<double[][]>> listenerWithReleaseCallback = ActionListener .runAfter(listener, coldStartFinishingCallback::close);
        threadPool .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME) .execute( () -> featureManager .getColdStartData( detector, new ThreadedActionListener<>( LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listenerWithReleaseCallback, false ) ) );
    }
    
    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {
        String detectorId = detector.getDetectorId();
        Optional<Exception> previousException = stateManager.fetchExceptionAndClear(detectorId);
        if (previousException.isPresent()) {
            Exception exception = previousException.get();
            LOG.error(new ParameterizedMessage("Previous exception of {}:", detectorId), exception);
            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {
                return previousException;
            }
            
        }
        
        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {
            if (!checkpointExists) {
                LOG.info("Trigger cold start for {}", detectorId);
                coldStart(detector);
            }
            
        }, exception -> {
            Throwable cause = ExceptionsHelper.unwrapCause(exception);
            if (cause instanceof IndexNotFoundException) {
                LOG.info("Trigger cold start for {}", detectorId);
                coldStart(detector);
            }
             else {
                String errorMsg = String.format(Locale.ROOT, "Fail to get checkpoint state for %s", detectorId);
                LOG.error(errorMsg, exception);
                stateManager.setException(detectorId, new AnomalyDetectionException(errorMsg, exception));
            }
            
        }
        
));
        return previousException;
    }
    
    class EntityResultListener implements ActionListener<AcknowledgedResponse> {
        private String nodeId;
        private final String adID;
        private AtomicReference<Exception> failure;
        private int nodeCount;
        private AtomicInteger responseCount;
        private PageIterator pageIterator;
        private PageListener pageListener;
        EntityResultListener( String nodeId, String adID, AtomicReference<Exception> failure, int nodeCount, PageIterator pageIterator, PageListener pageListener, AtomicInteger responseCount ) {
            this.nodeId = nodeId;
            this.adID = adID;
            this.failure = failure;
            this.nodeCount = nodeCount;
            this.pageIterator = pageIterator;
            this.responseCount = responseCount;
            this.pageListener = pageListener;
        }
        
        public void onResponse(AcknowledgedResponse response) {
            try {
                if (response.isAcknowledged() == false) {
                    LOG.error("Cannot send entities' features to {} for {}", nodeId, adID);
                    stateManager.addPressure(nodeId, adID);
                }
                 else {
                    stateManager.resetBackpressureCounter(nodeId, adID);
                }
                
            }
             catch (Exception ex) {
                LOG.error("Unexpected exception: {} for {}", ex, adID);
                handleException(ex);
            }
             finally {
                if (nodeCount == responseCount.incrementAndGet() && pageIterator != null && pageIterator.hasNext()) {
                    pageIterator.next(pageListener);
                }
                
            }
            
        }
        
        public void onFailure(Exception e) {
            try {
                LOG.error(new ParameterizedMessage("Cannot send entities' features to {} for {}", nodeId, adID), e);
                handleException(e);
            }
             catch (Exception ex) {
                LOG.error("Unexpected exception: {} for {}", ex, adID);
                handleException(ex);
            }
             finally {
                if (nodeCount == responseCount.incrementAndGet() && pageIterator != null && pageIterator.hasNext()) {
                    pageIterator.next(pageListener);
                }
                
            }
            
        }
        
        private void handleException(Exception e) {
            handlePredictionFailure(e, adID, nodeId, failure);
            if (failure.get() != null) {
                stateManager.setException(adID, failure.get());
            }
            
        }
        
    }
    
}


