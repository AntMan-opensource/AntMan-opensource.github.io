package org.apache.wiki.workflow;
import org.apache.commons.collections4.queue.CircularFifoQueue;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.wiki.api.core.Context;
import org.apache.wiki.api.core.Engine;
import org.apache.wiki.api.core.Session;
import org.apache.wiki.api.exceptions.WikiException;
import org.apache.wiki.auth.AuthorizationManager;
import org.apache.wiki.auth.acl.UnresolvedPrincipal;
import org.apache.wiki.event.WikiEvent;
import org.apache.wiki.event.WikiEventEmitter;
import org.apache.wiki.event.WorkflowEvent;
import org.apache.wiki.util.TextUtil;
import java.io.*;
import java.security.Principal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
public class DefaultWorkflowManager implements WorkflowManager {
    private static final Logger LOG = LogManager.getLogger( DefaultWorkflowManager.class );
    static final String SERIALIZATION_FILE = "wkflmgr.ser";
    private static final long serialVersionUID = 6L;
    DecisionQueue m_queue;
    Set< Workflow > m_workflows;
    final Map< String, Principal > m_approvers;
    Queue< Workflow > m_completed;
    private Engine m_engine;
    private int retainCompleted;
    public DefaultWorkflowManager() {
        m_workflows = ConcurrentHashMap.newKeySet();
        m_approvers = new ConcurrentHashMap<>();
        m_queue = new DecisionQueue();
        WikiEventEmitter.attach( this );
    }
    
    public Set< Workflow > getWorkflows() {
        final Set< Workflow > workflows = ConcurrentHashMap.newKeySet();
        workflows.addAll( m_workflows );
        return workflows;
    }
    
    public List< Workflow > getCompletedWorkflows() {
        return new CopyOnWriteArrayList< >( m_completed );
    }
    
    public void initialize( final Engine engine, final Properties props ) {
        m_engine = engine;
        retainCompleted = TextUtil.getIntegerProperty( engine.getWikiProperties(), "jspwiki.workflow.completed.retain", 2048 );
        m_completed = new CircularFifoQueue<>( retainCompleted );
        for( final Object o : props.keySet() ) {
            final String prop = ( String )o;
            if( prop.startsWith( PROPERTY_APPROVER_PREFIX ) ) {
                final String key = prop.substring( PROPERTY_APPROVER_PREFIX.length() );
                if( key.length() > 0 ) {
                    final String approver = props.getProperty( prop );
                    if( approver != null && !approver.isEmpty() ) {
                        m_approvers.put( key, new UnresolvedPrincipal( approver ) );
                    }
                    
                }
                
            }
            
        }
        
        unserializeFromDisk( new File( m_engine.getWorkDir(), SERIALIZATION_FILE ) );
    }
    
    @SuppressWarnings( "unchecked" )
    synchronized long unserializeFromDisk( final File f ) {
        long saved = 0L;
        final StopWatch sw = new StopWatch();
        sw.start();
        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( new FileInputStream( f ) ) ) ) {             final long ver = in.readLong();
            if( ver != serialVersionUID ) {
                LOG.warn( "File format has changed; Unable to recover workflows and decision queue from disk." );
            }
             else {
                saved        = in.readLong();
                m_workflows  = ( Set< Workflow > )in.readObject();
                m_queue      = ( DecisionQueue )in.readObject();
                m_completed = new CircularFifoQueue<>( retainCompleted );
                m_completed.addAll( ( Collection< Workflow > )in.readObject() );
                LOG.debug( "Read serialized data successfully in " + sw );
            }
            
        }
         catch( final IOException | ClassNotFoundException e ) {
            LOG.warn( "unable to recover from disk workflows and decision queue: " + e.getMessage() );
        }
        
        sw.stop();
        return saved;
    }
    
    synchronized void serializeToDisk( final File f ) {
        try( final ObjectOutputStream out = new ObjectOutputStream( new BufferedOutputStream( new FileOutputStream( f ) ) ) ) {             final StopWatch sw = new StopWatch();
            sw.start();
            out.writeLong( serialVersionUID );
            out.writeLong( System.currentTimeMillis() ); 
            out.writeObject( m_workflows );
            out.writeObject( m_queue );
            out.writeObject( m_completed );
            sw.stop();
            LOG.debug( "serialization done - took " + sw );
        }
         catch( final IOException ioe ) {
            LOG.error( "Unable to serialize!", ioe );
        }
        
    }
    
    public boolean requiresApproval( final String messageKey ) {
        return  m_approvers.containsKey( messageKey );
    }
    
    public Principal getApprover( final String messageKey ) throws WikiException {
        Principal approver = m_approvers.get( messageKey );
        if ( approver == null ) {
            throw new WikiException( "Workflow '" + messageKey + "' does not require approval." );
        }
        
        if ( approver instanceof UnresolvedPrincipal ) {
            final String name = approver.getName();
            approver = m_engine.getManager( AuthorizationManager.class ).resolvePrincipal( name );
            if ( approver instanceof UnresolvedPrincipal ) {
                throw new WikiException( "Workflow approver '" + name + "' cannot not be resolved." );
            }
            
            m_approvers.put( messageKey, approver );
        }
        
        return approver;
    }
    
    protected Engine getEngine() {
        if ( m_engine == null ) {
            throw new IllegalStateException( "Engine cannot be null; please initialize WorkflowManager first." );
        }
        
        return m_engine;
    }
    
    public DecisionQueue getDecisionQueue() {
        return m_queue;
    }
    
    public List< Workflow > getOwnerWorkflows( final Session session ) {
        final List< Workflow > workflows = new ArrayList<>();
        if ( session.isAuthenticated() ) {
            final Principal[] sessionPrincipals = session.getPrincipals();
            for( final Workflow w : m_workflows ) {
                final Principal owner = w.getOwner();
                for ( final Principal sessionPrincipal : sessionPrincipals ) {
                    if ( sessionPrincipal.equals( owner ) ) {
                        workflows.add( w );
                        break;
                    }
                    
                }
                
            }
            
        }
        
        return workflows;
    }
    
    public void actionPerformed( final WikiEvent event ) {
        if( event instanceof WorkflowEvent ) {
            if( event.getSrc() instanceof Workflow ) {
                final Workflow workflow = event.getSrc();
                switch( event.getType() ) {
                case WorkflowEvent.ABORTED   :
                case WorkflowEvent.COMPLETED : remove( workflow ); break;
                case WorkflowEvent.CREATED   : add( workflow ); break;
                default: break;
                }
                
            }
             else if( event.getSrc() instanceof Decision ) {
                final Decision decision = event.getSrc();
                switch( event.getType() ) {
                case WorkflowEvent.DQ_ADDITION : addToDecisionQueue( decision ); break;
                case WorkflowEvent.DQ_REMOVAL  : removeFromDecisionQueue( decision, event.getArg( 0, Context.class ) ); break;
                default: break;
                }
                
            }
            
            serializeToDisk( new File( m_engine.getWorkDir(), SERIALIZATION_FILE ) );
        }
        
    }
    
    protected void add( final Workflow workflow ) {
        m_workflows.add( workflow );
    }
    
    protected void remove( final Workflow workflow ) {
        if( m_workflows.contains( workflow ) ) {
            m_workflows.remove( workflow );
            m_completed.add( workflow );
        }
        
    }
    
    protected void removeFromDecisionQueue( final Decision decision, final Context context ) {
        final int workflowId = decision.getWorkflowId();
        final Optional< Workflow > optw = m_workflows.stream().filter( w -> w.getId() == workflowId ).findAny();
        if( optw.isPresent() ) {
            final Workflow w = optw.get();
            if( w.getCurrentState() == Workflow.WAITING && decision.equals( w.getCurrentStep() ) ) {
                getDecisionQueue().remove( decision );
                try {
                    w.restart( context );
                }
                 catch( final WikiException e ) {
                    LOG.error( "restarting workflow #" + w.getId() + " caused " + e.getMessage(), e );
                }
                
            }
            
        }
        
    }
    
    protected void addToDecisionQueue( final Decision decision ) {
        getDecisionQueue().add( decision );
    }
    
}


