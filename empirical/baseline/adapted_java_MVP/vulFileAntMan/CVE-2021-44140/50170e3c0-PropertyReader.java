package org.apache.wiki.util;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import javax.servlet.ServletContext;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;
public final class PropertyReader {
	 private static final Logger LOG = LogManager.getLogger( PropertyReader.class );
	 public static final String DEFAULT_JSPWIKI_CONFIG = "/ini/jspwiki.properties";
    public static final String PARAM_CUSTOMCONFIG = "jspwiki.custom.config";
    public static final String PARAM_CUSTOMCONFIG_CASCADEPREFIX = "jspwiki.custom.cascade.";
    public static final String  CUSTOM_JSPWIKI_CONFIG = "/jspwiki-custom.properties";
    private static final String PARAM_VAR_DECLARATION = "var.";
    private static final String PARAM_VAR_IDENTIFIER  = "$";
    private PropertyReader() {}
    public static Properties loadWebAppProps( final ServletContext context ) {
        final String propertyFile = getInitParameter( context, PARAM_CUSTOMCONFIG );
        try( final InputStream propertyStream = loadCustomPropertiesFile(context, propertyFile) ) {
            final Properties props = getDefaultProperties();
            final Map< String, String > env = collectPropertiesFrom( System.getenv() );
            props.putAll( env );
            if( propertyStream == null ) {
                LOG.debug( "No custom property file found, relying on JSPWiki defaults." );
            }
             else {
                props.load( propertyStream );
            }
            
            LOG.debug( "Loading cascading properties..." );
            loadWebAppPropsCascade( context, props );
            final Map< String, String > sysprops = collectPropertiesFrom( System.getProperties().entrySet().stream() .collect( Collectors.toMap( Object::toString, Object::toString ) ) );
            props.putAll( sysprops );
            expandVars( props );
            return props;
        }
         catch( final Exception e ) {
            LOG.error( "JSPWiki: Unable to load and setup properties from jspwiki.properties. " + e.getMessage(), e );
        }
        
        return null;
    }
    
    static Map< String, String > collectPropertiesFrom( final Map< String, String > map ) {
        return map.entrySet().stream() .filter( entry -> entry.getKey().toLowerCase().startsWith( "jspwiki" ) ) .map( entry -> new AbstractMap.SimpleEntry<>( entry.getKey().replace( "_", "." ), entry.getValue() ) ) .collect( Collectors.toMap( Map.Entry::getKey, Map.Entry::getValue ) );
    }
    
	static InputStream loadCustomPropertiesFile( final ServletContext context, final String propertyFile ) throws FileNotFoundException {
        final InputStream propertyStream;
		if( propertyFile == null ) {
		    LOG.debug( "No " + PARAM_CUSTOMCONFIG + " defined for this context, looking for custom properties file with default name of: " + CUSTOM_JSPWIKI_CONFIG );
		     propertyStream =  locateClassPathResource(context, CUSTOM_JSPWIKI_CONFIG);
		}
		 else {
		    LOG.debug( PARAM_CUSTOMCONFIG + " defined, using " + propertyFile + " as the custom properties file." );
		    propertyStream = new FileInputStream( propertyFile );
		}
		
		return propertyStream;
	}
	
    public static Properties getDefaultProperties() {
        final Properties props = new Properties();
        try( final InputStream in = PropertyReader.class.getResourceAsStream( DEFAULT_JSPWIKI_CONFIG ) ) {
            if( in != null ) {
                props.load( in );
            }
            
        }
         catch( final IOException e ) {
            LOG.error( "Unable to load default propertyfile '" + DEFAULT_JSPWIKI_CONFIG + "'" + e.getMessage(), e );
        }
        
        return props;
    }
    
    public static Properties getCombinedProperties( final String fileName ) {
        final Properties newPropertySet = getDefaultProperties();
        try( final InputStream in = PropertyReader.class.getResourceAsStream( fileName ) ) {
            if( in != null ) {
                newPropertySet.load( in );
            }
             else {
                LOG.error( "*** Custom property file \"" + fileName + "\" not found, relying on default file alone." );
            }
            
        }
         catch( final IOException e ) {
            LOG.error( "Unable to load propertyfile '" + fileName + "'" + e.getMessage(), e );
        }
        
        return newPropertySet;
    }
    
    private static String getInitParameter( final ServletContext context, final String name ) {
        final String value = context.getInitParameter( name );
        return value != null ? value : System.getProperty( name ) ;
    }
    
    private static void loadWebAppPropsCascade( final ServletContext context, final Properties defaultProperties ) {
        if( getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + "1" ) == null ) {
            LOG.debug( " No cascading properties defined for this context" );
            return;
        }
        
        int depth = 0;
        while( true ) {
            depth++;
            final String propertyFile = getInitParameter( context, PARAM_CUSTOMCONFIG_CASCADEPREFIX + depth );
            if( propertyFile == null ) {
                break;
            }
            
            try( final InputStream propertyStream = new FileInputStream( propertyFile ) ) {                 LOG.info( " Reading additional properties from " + propertyFile + " and merge to cascade." );
                final Properties additionalProps = new Properties();
                additionalProps.load( propertyStream );
                defaultProperties.putAll( additionalProps );
            }
             catch( final Exception e ) {
                LOG.error( "JSPWiki: Unable to load and setup properties from " + propertyFile + "." + e.getMessage() );
            }
            
        }
        
    }
    
    public static void expandVars( final Properties properties ) {
        final Map< String, String > vars = new HashMap<>();
        Enumeration< ? > propertyList = properties.propertyNames();
        while( propertyList.hasMoreElements() ) {
            final String propertyName = ( String )propertyList.nextElement();
            final String propertyValue = properties.getProperty( propertyName );
            if ( propertyName.startsWith( PARAM_VAR_DECLARATION ) ) {
                final String varName = propertyName.substring( 4 ).trim();
                final String varValue = propertyValue.trim();
                vars.put( varName, varValue );
            }
            
        }
        
        propertyList = properties.propertyNames();
        while( propertyList.hasMoreElements() ) {
            final String propertyName = ( String )propertyList.nextElement();
            String propertyValue = properties.getProperty( propertyName );
            if( propertyName.startsWith( PARAM_VAR_DECLARATION ) ) {
                continue;
            }
            
            for( final Map.Entry< String, String > entry : vars.entrySet() ) {
                final String varName = entry.getKey();
                final String varValue = entry.getValue();
                propertyValue = TextUtil.replaceString( propertyValue, PARAM_VAR_IDENTIFIER + varName, varValue );
                properties.put( propertyName, propertyValue );
            }
            
        }
        
    }
    
    public static InputStream locateClassPathResource( final ServletContext context, final String resourceName ) {
        InputStream result;
        String currResourceLocation;
        if( StringUtils.isEmpty( resourceName ) ) {
            return null;
        }
        
        currResourceLocation = createResourceLocation( "/WEB-INF/classes", resourceName );
        result = context.getResourceAsStream( currResourceLocation );
        if( result != null ) {
            LOG.debug( " Successfully located the following classpath resource : " + currResourceLocation );
            return result;
        }
        
        currResourceLocation = createResourceLocation( "", resourceName );
        result = PropertyReader.class.getResourceAsStream( currResourceLocation );
        if( result != null ) {
            LOG.debug( " Successfully located the following classpath resource : " + currResourceLocation );
            return result;
        }
        
        LOG.debug( " Unable to resolve the following classpath resource : " + resourceName );
        return result;
    }
    
    static String createResourceLocation( final String path, final String name ) {
        Validate.notEmpty( name, "name is empty" );
        final StringBuilder result = new StringBuilder();
        final String sanitizedPath = ( path != null && !path.isEmpty() && path.endsWith( "/" ) ? path.substring( 0, path.length() - 1 ) : path );
        final String sanitizedName = ( name.startsWith( "/" ) ? name.substring( 1 ) : name );
        if( sanitizedPath != null && !sanitizedPath.isEmpty() ) {
            if( !sanitizedPath.startsWith( "/" ) ) {
                result.append( "/" );
            }
            
            result.append( sanitizedPath );
        }
        
        result.append( "/" );
        result.append( sanitizedName );
        return result.toString();
    }
    
}


