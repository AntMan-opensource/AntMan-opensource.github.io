package org.apache.wiki.util;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;
public final class FileUtil {
    private static final int      BUFFER_SIZE = 8192;
    private static final Logger   log         = LogManager.getLogger(FileUtil.class);
    private FileUtil() {}
    public static File newTmpFile( final String content, final Charset encoding ) throws IOException {
        final File f = File.createTempFile( "jspwiki", null );
        try( final Reader in = new StringReader( content ); final Writer out = new OutputStreamWriter( new FileOutputStream( f ), encoding ) ) {             copyContents( in, out );
        }
        
        return f;
    }
    
    public static File newTmpFile( final String content ) throws IOException {
        return newTmpFile( content, StandardCharsets.ISO_8859_1 );
    }
    
    public static String runSimpleCommand( final String command, final String directory ) throws IOException, InterruptedException {
        log.info( "Running simple command " + command + " in " + directory );
        final StringBuilder result = new StringBuilder();
        final Process process = Runtime.getRuntime().exec( command, null, new File( directory ) );
        try( final BufferedReader stdout = new BufferedReader( new InputStreamReader( process.getInputStream() ) ); final BufferedReader stderr = new BufferedReader( new InputStreamReader( process.getErrorStream() ) ) ) {             String line;
            while( (line = stdout.readLine()) != null ) {
                result.append( line+"\n");
            }
            
            final StringBuilder error = new StringBuilder();
            while( (line = stderr.readLine()) != null ) {
                error.append( line+"\n");
            }
            
            if( error.length() > 0 ) {
                log.error("Command failed, error stream is: "+error);
            }
            
            process.waitFor();
        }
         finally {
            process.getInputStream().close();
        }
        
        return result.toString();
    }
    
    public static void copyContents( final Reader in, final Writer out ) throws IOException {
        final char[] buf = new char[BUFFER_SIZE];
        int bytesRead;
        while( ( bytesRead = in.read( buf ) ) > 0 ) {
            out.write( buf, 0, bytesRead );
        }
        
        out.flush();
    }
    
    public static void copyContents( final InputStream in, final OutputStream out ) throws IOException {
        final byte[] buf = new byte[BUFFER_SIZE];
        int bytesRead;
        while( ( bytesRead = in.read( buf ) ) > 0 ) {
            out.write( buf, 0, bytesRead );
        }
        
        out.flush();
        if( out instanceof FileOutputStream ) {
            final FileDescriptor fd = ( ( FileOutputStream )out ).getFD();
            fd.sync();
        }
        
    }
    
    public static String readContents(final InputStream input, final String encoding ) throws IOException {
        final ByteArrayOutputStream out = new ByteArrayOutputStream();
        FileUtil.copyContents( input, out );
        ByteBuffer     bbuf        = ByteBuffer.wrap( out.toByteArray() );
        final Charset        cset        = Charset.forName( encoding );
        final CharsetDecoder csetdecoder = cset.newDecoder();
        csetdecoder.onMalformedInput( CodingErrorAction.REPORT );
        csetdecoder.onUnmappableCharacter( CodingErrorAction.REPORT );
        try {
            final CharBuffer cbuf = csetdecoder.decode( bbuf );
            return cbuf.toString();
        }
        
        catch( final CharacterCodingException e ) {
            final Charset        latin1    = StandardCharsets.ISO_8859_1;
            final CharsetDecoder l1decoder = latin1.newDecoder();
            l1decoder.onMalformedInput( CodingErrorAction.REPORT );
            l1decoder.onUnmappableCharacter( CodingErrorAction.REPORT );
            try {
                bbuf = ByteBuffer.wrap( out.toByteArray() );
                final CharBuffer cbuf = l1decoder.decode( bbuf );
                return cbuf.toString();
            }
            
            catch( final CharacterCodingException ex ) {
                throw (CharacterCodingException) ex.fillInStackTrace();
            }
            
        }
        
    }
    
    public static String readContents( final Reader in ) throws IOException {
        try(final Writer out = new StringWriter() ) {             copyContents( in, out );
            return out.toString();
        }
        
    }
    
    public static String getThrowingMethod(final Throwable t ) {
        final StackTraceElement[] trace = t.getStackTrace();
        final StringBuilder sb = new StringBuilder();
        if( trace == null || trace.length == 0 ) {
            sb.append( "[Stack trace not available]" );
        }
        
        else{
            sb.append( trace[0].isNativeMethod() ? "native method" : "" );
            sb.append( trace[0].getClassName() );
            sb.append(".");
            sb.append(trace[0].getMethodName()+"(), line "+trace[0].getLineNumber());
        }
        
        return sb.toString();
    }
    
}


