package org.apache.wiki.references;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.wiki.InternalWikiException;
import org.apache.wiki.LinkCollector;
import org.apache.wiki.api.core.Attachment;
import org.apache.wiki.api.core.Context;
import org.apache.wiki.api.core.Engine;
import org.apache.wiki.api.core.Page;
import org.apache.wiki.api.exceptions.ProviderException;
import org.apache.wiki.api.filters.BasePageFilter;
import org.apache.wiki.api.providers.PageProvider;
import org.apache.wiki.api.providers.WikiProvider;
import org.apache.wiki.api.spi.Wiki;
import org.apache.wiki.attachment.AttachmentManager;
import org.apache.wiki.event.WikiEvent;
import org.apache.wiki.event.WikiEventManager;
import org.apache.wiki.event.WikiPageEvent;
import org.apache.wiki.pages.PageManager;
import org.apache.wiki.render.RenderingManager;
import org.apache.wiki.util.TextUtil;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
public class DefaultReferenceManager extends BasePageFilter implements ReferenceManager {
    private Map< String, Collection< String > > m_refersTo;
    private Map< String, Collection< String > > m_unmutableRefersTo;
    private Map< String, Set< String > > m_referredBy;
    private Map< String, Set< String > > m_unmutableReferredBy;
    private final boolean m_matchEnglishPlurals;
    private static final Logger log = LogManager.getLogger( DefaultReferenceManager.class);
    private static final String SERIALIZATION_FILE = "refmgr.ser";
    private static final String SERIALIZATION_DIR  = "refmgr-attr";
    private static final long serialVersionUID = 4L;
    public DefaultReferenceManager( final Engine engine ) {
        m_refersTo = new ConcurrentHashMap<>();
        m_referredBy = new ConcurrentHashMap<>();
        m_engine = engine;
        m_matchEnglishPlurals = TextUtil.getBooleanProperty( engine.getWikiProperties(), Engine.PROP_MATCHPLURALS, false );
        m_unmutableReferredBy = Collections.unmodifiableMap( m_referredBy );
        m_unmutableRefersTo   = Collections.unmodifiableMap( m_refersTo );
    }
    
    private void updatePageReferences( final Page page ) throws ProviderException {
        final String content = m_engine.getManager( PageManager.class ).getPageText( page.getName(), PageProvider.LATEST_VERSION );
        final Collection< String > links = scanWikiLinks( page, content );
        final TreeSet< String > res = new TreeSet<>( links );
        final List< Attachment > attachments = m_engine.getManager( AttachmentManager.class ).listAttachments( page );
        for( final Attachment att : attachments ) {
            res.add( att.getName() );
        }
        
        internalUpdateReferences( page.getName(), res );
    }
    
    public void initialize( final Collection< Page > pages ) throws ProviderException {
        log.debug( "Initializing new ReferenceManager with " + pages.size() + " initial pages." );
        final StopWatch sw = new StopWatch();
        sw.start();
        log.info( "Starting cross reference scan of WikiPages" );
        try {
            final long saved = unserializeFromDisk();
            for( final Page page : pages ) {
                unserializeAttrsFromDisk( page );
            }
            
            for( final Page page : pages ) {
                if( !( page instanceof Attachment ) ) {
                    final Page wp = m_engine.getManager( PageManager.class ).getPage( page.getName() );
                    if( wp.getLastModified() == null ) {
                        log.fatal( "Provider returns null lastModified.  Please submit a bug report." );
                    }
                     else if( wp.getLastModified().getTime() > saved ) {
                        updatePageReferences( wp );
                    }
                    
                }
                
            }
            
        }
         catch( final Exception e ) {
            log.info( "Unable to unserialize old refmgr information, rebuilding database: " + e.getMessage() );
            buildKeyLists( pages );
            for( final Page page : pages ) {
                if( !( page instanceof Attachment ) ) {
                    updatePageReferences( page );
                    serializeAttrsToDisk( page );
                }
                
            }
            
            serializeToDisk();
        }
        
        sw.stop();
        log.info( "Cross reference scan done in "+sw );
        WikiEventManager.addWikiEventListener( m_engine.getManager( PageManager.class ), this );
    }
    
    private synchronized long unserializeFromDisk() throws IOException, ClassNotFoundException {
        final long saved;
        final File f = new File( m_engine.getWorkDir(), SERIALIZATION_FILE );
        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( new FileInputStream( f ) ) ) ) {             final StopWatch sw = new StopWatch();
            sw.start();
            final long ver = in.readLong();
            if( ver != serialVersionUID ) {
                throw new IOException("File format has changed; I need to recalculate references.");
            }
            
            saved        = in.readLong();
            m_refersTo   = ( Map< String, Collection< String > > ) in.readObject();
            m_referredBy = ( Map< String, Set< String > > ) in.readObject();
            m_unmutableReferredBy = Collections.unmodifiableMap( m_referredBy );
            m_unmutableRefersTo   = Collections.unmodifiableMap( m_refersTo );
            sw.stop();
            log.debug("Read serialized data successfully in "+sw);
        }
        
        return saved;
    }
    
    private synchronized void serializeToDisk() {
        final File f = new File( m_engine.getWorkDir(), SERIALIZATION_FILE );
        try( final ObjectOutputStream out = new ObjectOutputStream( new BufferedOutputStream( new FileOutputStream( f ) ) ) ) {             final StopWatch sw = new StopWatch();
            sw.start();
            out.writeLong( serialVersionUID );
            out.writeLong( System.currentTimeMillis() ); 
            out.writeObject( m_refersTo );
            out.writeObject( m_referredBy );
            sw.stop();
            log.debug("serialization done - took "+sw);
        }
         catch( final IOException ioe ) {
            log.error("Unable to serialize!", ioe);
        }
        
    }
    
    private String getHashFileName( final String pageName ) {
        if( pageName == null ) {
            return null;
        }
        
		try {
            final MessageDigest digest = MessageDigest.getInstance( "MD5" );
            final byte[] dig = digest.digest( pageName.getBytes( StandardCharsets.UTF_8 ) );
	        return TextUtil.toHexString( dig ) + ".cache";
		}
		 catch( final NoSuchAlgorithmException e ) {
			log.fatal( "What do you mean - no such algorithm?", e );
			return null;
		}
		
    }
    
    private synchronized long unserializeAttrsFromDisk( final Page p ) throws IOException, ClassNotFoundException {
        long saved = 0L;
        final String hashName = getHashFileName( p.getName() );
        if( hashName != null ) {
        	File f = new File( m_engine.getWorkDir(), SERIALIZATION_DIR );
            f = new File( f, hashName );
            if( !f.exists() ) {
                return 0L;
            }
            
            try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( new FileInputStream( f ) ) ) ) {                 final StopWatch sw = new StopWatch();
                sw.start();
                log.debug( "Deserializing attributes for " + p.getName() );
                final long ver = in.readLong();
                if( ver != serialVersionUID ) {
                    log.debug("File format has changed; cannot deserialize.");
                    return 0L;
                }
                
                saved = in.readLong();
                final String name  = in.readUTF();
                if( !name.equals( p.getName() ) ) {
                    log.debug("File name does not match (" + name + "), skipping...");
                    return 0L; 
                }
                
                final long entries = in.readLong();
                for( int i = 0; i < entries; i++ ) {
                    final String key   = in.readUTF();
                    final Object value = in.readObject();
                    p.setAttribute( key, value );
                    log.debug("   attr: "+key+"="+value);
                }
                
                sw.stop();
                log.debug("Read serialized data for "+name+" successfully in "+sw);
                p.setHasMetadata();
            }
            
        }
        
        return saved;
    }
    
    private synchronized void serializeAttrsToDisk( final Page p ) {
        final StopWatch sw = new StopWatch();
        sw.start();
        final String hashName = getHashFileName( p.getName() );
        if( hashName != null ) {
        	File f = new File( m_engine.getWorkDir(), SERIALIZATION_DIR );
            if( !f.exists() ) {
                f.mkdirs();
            }
            
            f = new File( f, hashName );
            try( final ObjectOutputStream out =  new ObjectOutputStream( new BufferedOutputStream( new FileOutputStream( f ) ) ) ) {                  final Set< Map.Entry < String, Object > > entries = new HashSet<>( p.getAttributes().entrySet() );
                if( entries.size() == 0 ) {
                    f.delete();
                    return;
                }
                
                out.writeLong( serialVersionUID );
                out.writeLong( System.currentTimeMillis() ); 
                out.writeUTF( p.getName() );
                out.writeLong( entries.size() );
                for( final Map.Entry< String, Object > e : entries ) {
                    if( e.getValue() instanceof Serializable ) {
                        out.writeUTF( e.getKey() );
                        out.writeObject( e.getValue() );
                    }
                    
                }
                
            }
             catch( final IOException e ) {
                log.error( "Unable to serialize!", e );
            }
             finally {
                sw.stop();
                log.debug( "serialization for " + p.getName() + " done - took " + sw );
            }
            
        }
        
    }
    
	public void postSave( final Context context, final String content ) {
        final Page page = context.getPage();
        updateReferences( page.getName(), scanWikiLinks( page, content ) );
        serializeAttrsToDisk( page );
    }
    
    public Collection< String > scanWikiLinks( final Page page, final String pagedata ) {
        final LinkCollector localCollector = new LinkCollector();
        m_engine.getManager( RenderingManager.class ).textToHTML( Wiki.context().create( m_engine, page ), pagedata, localCollector, null, localCollector, false, true );
        return localCollector.getLinks();
    }
    
    public synchronized void pageRemoved( final Page page ) {
        pageRemoved( page.getName() );
    }
    
    private void pageRemoved( final String pageName ) {
        final Collection< String > refTo = m_refersTo.get( pageName );
        if( refTo != null ) {
            for( final String referredPageName : refTo ) {
                final Set< String > refBy = m_referredBy.get( referredPageName );
                if( refBy == null ) {
                    throw new InternalWikiException( "Refmgr out of sync: page " + pageName + " refers to " + referredPageName + ", which has null referrers." );
                }
                
                refBy.remove( pageName );
                m_referredBy.remove( referredPageName );
                if( !( refBy.isEmpty() && !m_engine.getManager( PageManager.class ).wikiPageExists( referredPageName ) ) ) {
                    m_referredBy.put( referredPageName, refBy );
                }
                
            }
            
            log.debug("Removing from m_refersTo HashMap key:value "+pageName+":"+m_refersTo.get( pageName ));
            m_refersTo.remove( pageName );
        }
        
        final Set< String > refBy = m_referredBy.get( pageName );
        if( refBy == null || refBy.isEmpty() ) {
            m_referredBy.remove( pageName );
        }
        
        serializeToDisk();
        final String hashName = getHashFileName( pageName );
        if( hashName != null ) {
        	File f = new File( m_engine.getWorkDir(), SERIALIZATION_DIR );
            f = new File( f, getHashFileName( pageName ) );
            if( f.exists() ) {
                f.delete();
            }
            
        }
        
    }
    
    public void updateReferences( final Page page ) {
        final String pageData = m_engine.getManager( PageManager.class ).getPureText( page.getName(), WikiProvider.LATEST_VERSION );
        updateReferences( page.getName(), scanWikiLinks( page, pageData ) );
    }
    
    public synchronized void updateReferences( final String page, final Collection< String > references ) {
        internalUpdateReferences( page, references );
        serializeToDisk();
    }
    
    private void internalUpdateReferences( String page, final Collection< String > references) {
        page = getFinalPageName( page );
        final Collection< String > oldRefTo = m_refersTo.get( page );
        m_refersTo.remove( page );
        final TreeSet< String > cleanedRefs = new TreeSet<>();
        for( final String ref : references ) {
            final String reference = getFinalPageName( ref );
            cleanedRefs.add( reference );
        }
        
        m_refersTo.put( page, cleanedRefs );
        if( !m_referredBy.containsKey( page ) ) {
            m_referredBy.put( page, new TreeSet<>() );
        }
        
        cleanReferredBy( page, oldRefTo, cleanedRefs );
        for( final String referredPageName : cleanedRefs ) {
            updateReferredBy( getFinalPageName( referredPageName ), page );
        }
        
    }
    
    protected Map< String, Collection< String > > getRefersTo() {
        return m_refersTo;
    }
    
    protected Map< String, Set< String > > getReferredBy() {
        return m_referredBy;
    }
    
    private void cleanReferredBy( final String referrer, final Collection< String > oldReferred, final Collection< String > newReferred ) {
        if( oldReferred == null ) {
            return;
        }
        
        for( final String referredPage : oldReferred ) {
            final Set< String > oldRefBy = m_referredBy.get( referredPage );
            if( oldRefBy != null ) {
                oldRefBy.remove( referrer );
            }
            
            if( ( oldRefBy == null || oldRefBy.isEmpty() ) && !m_engine.getManager( PageManager.class ).wikiPageExists( referredPage ) ) {
                m_referredBy.remove( referredPage );
            }
            
        }
        
    }
    
    private synchronized void buildKeyLists( final Collection< Page > pages ) {
        m_refersTo.clear();
        m_referredBy.clear();
        if( pages == null ) {
            return;
        }
        
        try {
            for( final Page page : pages ) {
                m_referredBy.put( page.getName(), new TreeSet<>() );
                m_refersTo.put( page.getName(), new TreeSet<>() );
            }
            
        }
         catch( final ClassCastException e ) {
            log.fatal( "Invalid collection entry in ReferenceManager.buildKeyLists().", e );
        }
        
    }
    
    private void updateReferredBy( final String page, final String referrer ) {
        if( m_matchEnglishPlurals ) {
            final String p2 = page.endsWith( "s" ) ? page.substring( 0, page.length() - 1 ) : page + "s";
            if( referrer.equals( p2 ) ) {
                return;
            }
            
        }
        
        final Set< String > referrers = m_referredBy.computeIfAbsent( page, k -> new TreeSet<>() );
        referrers.add( referrer );
    }
    
    public synchronized void clearPageEntries( String pagename ) {
        pagename = getFinalPageName( pagename );
        final Collection< String > c = m_refersTo.get( pagename );
        if( c != null ) {
            for( final String key : c ) {
                final Collection< ? > dref = m_referredBy.get( key );
                dref.remove( pagename );
            }
            
        }
        
        m_referredBy.remove( pagename );
        m_refersTo.remove( pagename );
    }
    
    public synchronized Collection< String > findUnreferenced() {
        final ArrayList< String > unref = new ArrayList<>();
        for( final String key : m_referredBy.keySet() ) {
            final Set< ? > refs = getReferenceList( m_referredBy, key );
            if( refs == null || refs.isEmpty() ) {
                unref.add( key );
            }
            
        }
        
        return unref;
    }
    
    public synchronized Collection< String > findUncreated() {
        final TreeSet< String > uncreated = new TreeSet<>();
        final Collection< Collection< String > > allReferences = m_refersTo.values();
        for( final Collection<String> refs : allReferences ) {
            if( refs != null ) {
                for( final String aReference : refs ) {
                    if( !m_engine.getManager( PageManager.class ).wikiPageExists( aReference ) ) {
                        uncreated.add( aReference );
                    }
                    
                }
                
            }
            
        }
        
        return uncreated;
    }
    
    private < T > Set< T > getReferenceList( final Map< String, Set< T > > coll, final String pagename ) {
        Set< T > refs = coll.get( pagename );
        if( m_matchEnglishPlurals ) {
            final Set< T > refs2;
            if( pagename.endsWith( "s" ) ) {
                refs2 = coll.get( pagename.substring( 0, pagename.length() - 1 ) );
            }
             else {
                refs2 = coll.get( pagename + "s" );
            }
            
            if( refs2 != null ) {
                if( refs != null ) {
                    refs.addAll( refs2 );
                }
                 else {
                    refs = refs2;
                }
                
            }
            
        }
        
        return refs;
    }
    
    public synchronized Set< String > findReferrers( final String pagename ) {
        final Set< String > refs = getReferenceList( m_referredBy, pagename );
        if( refs == null || refs.isEmpty() ) {
            return null;
        }
        
        return refs;
    }
    
    public Set< String > findReferredBy( final String pageName ) {
        return m_unmutableReferredBy.get( getFinalPageName(pageName) );
    }
    
    public Collection< String > findRefersTo( final String pageName ) {
        return m_unmutableRefersTo.get( getFinalPageName( pageName ) );
    }
    
    public int deepHashCode() {
        boolean failed = true;
        int signature = 0;
        while( failed ) {
            signature = 0;
            try {
                signature ^= m_referredBy.hashCode();
                signature ^= m_refersTo.hashCode();
                failed = false;
            }
             catch ( final ConcurrentModificationException e) {
                Thread.yield();
            }
            
        }
        
        return signature;
    }
    
    public Set< String > findCreated() {
        return new HashSet<>( m_refersTo.keySet() );
    }
    
    private String getFinalPageName( final String orig ) {
        try {
            final String s = m_engine.getFinalPageName( orig );
            return s != null ? s : orig;
        }
         catch( final ProviderException e ) {
            log.error("Error while trying to fetch a page name; trying to cope with the situation.",e);
            return orig;
        }
        
    }
    
	public void actionPerformed( final WikiEvent event ) {
        if( event instanceof WikiPageEvent && event.getType() == WikiPageEvent.PAGE_DELETED ) {
            final String pageName = ( ( WikiPageEvent ) event ).getPageName();
            if( pageName != null ) {
                pageRemoved( pageName );
            }
            
        }
        
    }
    
}


