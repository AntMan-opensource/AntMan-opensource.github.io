package org.apache.wiki.providers;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.wiki.InternalWikiException;
import org.apache.wiki.api.core.Engine;
import org.apache.wiki.api.core.Page;
import org.apache.wiki.api.exceptions.NoRequiredPropertyException;
import org.apache.wiki.api.exceptions.ProviderException;
import org.apache.wiki.api.providers.PageProvider;
import org.apache.wiki.api.providers.WikiProvider;
import org.apache.wiki.api.spi.Wiki;
import org.apache.wiki.util.FileUtil;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Properties;
public class VersioningFileProvider extends AbstractFileProvider {
    private static final Logger log = LogManager.getLogger( VersioningFileProvider.class );
    public static final String PAGEDIR = "OLD";
    public static final String PROPERTYFILE = "page.properties";
    private CachedProperties m_cachedProperties;
    public void initialize( final Engine engine, final Properties properties ) throws NoRequiredPropertyException, IOException {
        super.initialize( engine, properties );
        final File oldpages = new File( getPageDirectory(), PAGEDIR );
        if( !oldpages.exists() ) {
            if( !oldpages.mkdirs() ) {
                throw new IOException( "Failed to create page version directory " + oldpages.getAbsolutePath() );
            }
            
        }
         else {
            if( !oldpages.isDirectory() ) {
                throw new IOException( "Page version directory is not a directory: " + oldpages.getAbsolutePath() );
            }
            
            if( !oldpages.canWrite() ) {
                throw new IOException( "Page version directory is not writable: " + oldpages.getAbsolutePath() );
            }
            
        }
        
        log.info( "Using directory " + oldpages.getAbsolutePath() + " for storing old versions of pages" );
    }
    
    private File findOldPageDir( final String page ) {
        if( page == null ) {
            throw new InternalWikiException( "Page may NOT be null in the provider!" );
        }
        
        final File oldpages = new File( getPageDirectory(), PAGEDIR );
        return new File( oldpages, mangleName( page ) );
    }
    
    private int findLatestVersion( final String page ) {
        int version = -1;
        try {
            final Properties props = getPageProperties( page );
            for( final Object o : props.keySet() ) {
                final String key = ( String )o;
                if( key.endsWith( ".author" ) ) {
                    final int cutpoint = key.indexOf( '.' );
                    if( cutpoint > 0 ) {
                        final String pageNum = key.substring( 0, cutpoint );
                        try {
                            final int res = Integer.parseInt( pageNum );
                            if( res > version ) {
                                version = res;
                            }
                            
                        }
                         catch( final NumberFormatException e ) {
                        }
                         
                    }
                    
                }
                
            }
            
        }
         catch( final IOException e ) {
            log.error( "Unable to figure out latest version - dying...", e );
        }
        
        return version;
    }
    
    private Properties getPageProperties( final String page ) throws IOException {
        final File propertyFile = new File( findOldPageDir(page), PROPERTYFILE );
        if( propertyFile.exists() ) {
            final long lastModified = propertyFile.lastModified();
            CachedProperties cp = m_cachedProperties;
            if( cp != null && cp.m_page.equals( page ) && cp.m_lastModified == lastModified ) {
                return cp.m_props;
            }
            
            try( final InputStream in = new BufferedInputStream(new FileInputStream( propertyFile ) ) ) {                 final Properties props = new Properties();
                props.load( in );
                cp = new CachedProperties( page, props, lastModified );
                m_cachedProperties = cp; 
                return props;
            }
            
        }
        
        return new Properties(); 
    }
    
    private void putPageProperties( final String page, final Properties properties ) throws IOException {
        final File propertyFile = new File( findOldPageDir(page), PROPERTYFILE );
        try( final OutputStream out = new FileOutputStream( propertyFile ) ) {             properties.store( out, " JSPWiki page properties for "+page+". DO NOT MODIFY!" );
        }
        
        final CachedProperties cp = new CachedProperties( page, properties, propertyFile.lastModified() );
        m_cachedProperties = cp; 
    }
    
    private int realVersion( final String page, final int requestedVersion ) throws NoSuchVersionException {
        if( requestedVersion == WikiProvider.LATEST_VERSION ) {
            return -1;
        }
        
        final int latest = findLatestVersion(page);
        if( requestedVersion == latest || (requestedVersion == 1 && latest == -1 ) ) {
            return -1;
        }
         else if( requestedVersion <= 0 || requestedVersion > latest ) {
            throw new NoSuchVersionException( "Requested version " + requestedVersion + ", but latest is " + latest );
        }
        
        return requestedVersion;
    }
    
    public synchronized String getPageText( final String page, int version ) throws ProviderException {
        final File dir = findOldPageDir( page );
        version = realVersion( page, version );
        if( version == -1 ) {
            return super.getPageText( page, PageProvider.LATEST_VERSION );
        }
        
        final File pageFile = new File( dir, ""+version+FILE_EXT );
        if( !pageFile.exists() ) {
            throw new NoSuchVersionException("Version "+version+"does not exist.");
        }
        
        return readFile( pageFile );
    }
    
    private String readFile( final File pagedata ) throws ProviderException {
        String result = null;
        if( pagedata.exists() ) {
            if( pagedata.canRead() ) {
                try( final InputStream in = new FileInputStream( pagedata ) ) {                     result = FileUtil.readContents( in, m_encoding );
                }
                 catch( final IOException e ) {
                    log.error("Failed to read", e);
                    throw new ProviderException("I/O error: "+e.getMessage());
                }
                
            }
             else {
                log.warn("Failed to read page from '"+pagedata.getAbsolutePath()+"', possibly a permissions problem");
                throw new ProviderException("I cannot read the requested page.");
            }
            
        }
         else {
            log.info("New page");
        }
        
        return result;
    }
    
    public synchronized void putPageText( final Page page, final String text ) throws ProviderException {
        final int  latest  = findLatestVersion( page.getName() );
        final File pageDir = findOldPageDir( page.getName() );
        if( !pageDir.exists() ) {
            pageDir.mkdirs();
        }
        
        try {
            final File oldFile = findPage( page.getName() );
            int versionNumber = (latest > 0) ? latest : 1;
            final boolean firstUpdate = (versionNumber == 1);
            if( oldFile != null && oldFile.exists() ) {
                final File pageFile = new File( pageDir, versionNumber + FILE_EXT );
                try( final InputStream in = new BufferedInputStream( new FileInputStream( oldFile ) ); final OutputStream out = new BufferedOutputStream( new FileOutputStream( pageFile ) ) ) {                     FileUtil.copyContents( in, out );
                    pageFile.setLastModified( oldFile.lastModified() );
                    versionNumber++;
                }
                
            }
            
            super.putPageText( page, text );
            final Properties props = getPageProperties( page.getName() );
            String authorFirst = null;
            final File pagePropFile = new File(getPageDirectory() + File.separator + PAGEDIR + File.separator + mangleName(page.getName()) + File.separator + "page" + FileSystemProvider.PROP_EXT);
            if( firstUpdate && ! pagePropFile.exists() ) {
                final Properties props2 = getHeritagePageProperties( page.getName() );
                authorFirst = props2.getProperty( "1.author", "unknown" );
                props.setProperty( "1.author", authorFirst );
            }
            
            String newAuthor = page.getAuthor();
            if ( newAuthor == null ) {
                newAuthor = ( authorFirst != null ) ? authorFirst : "unknown";
            }
            
            page.setAuthor(newAuthor);
            props.setProperty( versionNumber + ".author", newAuthor );
            final String changeNote = page.getAttribute( Page.CHANGENOTE );
            if( changeNote != null ) {
                props.setProperty( versionNumber + ".changenote", changeNote );
            }
            
            getCustomProperties( page, props );
            putPageProperties( page.getName(), props );
        }
         catch( final IOException e ) {
            log.error( "Saving failed", e );
            throw new ProviderException("Could not save page text: "+e.getMessage());
        }
        
    }
    
    public Page getPageInfo( final String page, final int version ) throws ProviderException {
        final int latest = findLatestVersion( page );
        final int realVersion;
        Page p = null;
        if( version == PageProvider.LATEST_VERSION || version == latest || (version == 1 && latest == -1) ) {
            realVersion = (latest >= 0) ? latest : 1;
            p = super.getPageInfo( page, PageProvider.LATEST_VERSION );
            if( p != null ) {
                p.setVersion( realVersion );
            }
            
        }
         else {
            realVersion = version;
            final File dir = findOldPageDir( page );
            if( !dir.exists() || !dir.isDirectory() ) {
                return null;
            }
            
            final File file = new File( dir, version + FILE_EXT );
            if( file.exists() ) {
                p = Wiki.contents().page( m_engine, page );
                p.setLastModified( new Date( file.lastModified() ) );
                p.setVersion( version );
            }
            
        }
        
        if( p != null ) {
            try {
                final Properties props = getPageProperties( page );
                String author = props.getProperty( realVersion + ".author" );
                if( author == null ) {
                    final Properties props2 = getHeritagePageProperties( page );
                    author = props2.getProperty( Page.AUTHOR );
                }
                
                if( author != null ) {
                    p.setAuthor( author );
                }
                
                final String changenote = props.getProperty( realVersion + ".changenote" );
                if( changenote != null ) {
                    p.setAttribute( Page.CHANGENOTE, changenote );
                }
                
                setCustomProperties( p, props );
            }
             catch( final IOException e ) {
                log.error( "Cannot get author for page" + page + ": ", e );
            }
            
        }
        
        return p;
    }
    
    public boolean pageExists( final String pageName, final int version ) {
        if (version == PageProvider.LATEST_VERSION || version == findLatestVersion( pageName ) ) {
            return pageExists(pageName);
        }
        
        final File dir = findOldPageDir( pageName );
        if( !dir.exists() || !dir.isDirectory() ) {
            return false;
        }
        
        return new File( dir, version + FILE_EXT ).exists();
    }
    
    public List< Page > getVersionHistory( final String page ) throws ProviderException {
        final ArrayList< Page > list = new ArrayList<>();
        final int latest = findLatestVersion( page );
        for( int i = latest; i > 0; i-- ) {
            final Page info = getPageInfo( page, i );
            if( info != null ) {
                list.add( info );
            }
            
        }
        
        return list;
    }
    
    private Properties getHeritagePageProperties( final String page ) throws IOException {
        final File propertyFile = new File( getPageDirectory(), mangleName( page ) + FileSystemProvider.PROP_EXT );
        if ( propertyFile.exists() ) {
            final long lastModified = propertyFile.lastModified();
            CachedProperties cp = m_cachedProperties;
            if ( cp != null && cp.m_page.equals(page) && cp.m_lastModified == lastModified ) {
                return cp.m_props;
            }
            
            try( final InputStream in = new BufferedInputStream( new FileInputStream( propertyFile ) ) ) {                 final Properties props = new Properties();
                props.load( in );
                final String originalAuthor = props.getProperty( Page.AUTHOR );
                if ( !originalAuthor.isEmpty() ) {
                    props.setProperty( "1.author", originalAuthor );
                    cp = new CachedProperties( page, props, propertyFile.lastModified() );
                    m_cachedProperties = cp; 
                }
                
                return props;
            }
            
        }
        
        return new Properties(); 
    }
    
    public void deletePage( final String page ) throws ProviderException {
        super.deletePage( page );
        final File dir = findOldPageDir( page );
        if( dir.exists() && dir.isDirectory() ) {
            final File[] files = dir.listFiles( new WikiFileFilter() );
            for( final File file : files ) {
                file.delete();
            }
            
            final File propfile = new File( dir, PROPERTYFILE );
            if( propfile.exists() ) {
                propfile.delete();
            }
            
            dir.delete();
        }
        
    }
    
    public void deleteVersion( final String page, final int version ) throws ProviderException {
        final File dir = findOldPageDir( page );
        int latest = findLatestVersion( page );
        if( version == PageProvider.LATEST_VERSION || version == latest || (version == 1 && latest == -1) ) {
            try {
                final Properties props = getPageProperties( page );
                props.remove( ((latest > 0) ? latest : 1)+".author" );
                putPageProperties( page, props );
            }
             catch( final IOException e ) {
                log.error("Unable to modify page properties",e);
                throw new ProviderException("Could not modify page properties: " + e.getMessage());
            }
            
            super.deleteVersion( page, PageProvider.LATEST_VERSION );
            latest = findLatestVersion( page );
            final File pageDir = findOldPageDir( page );
            final File previousFile = new File( pageDir, latest + FILE_EXT );
            final File pageFile = findPage(page);
            try( final InputStream in = new BufferedInputStream( new FileInputStream( previousFile ) ); final OutputStream out = new BufferedOutputStream( new FileOutputStream( pageFile ) ) ) {                 if( previousFile.exists() ) { FileUtil.copyContents( in, out );
                    pageFile.setLastModified( previousFile.lastModified() );
                }
                
            }
             catch( final IOException e ) {
                log.fatal("Something wrong with the page directory - you may have just lost data!",e);
            }
            
            return;
        }
        
        final File pageFile = new File( dir, ""+version+FILE_EXT );
        if( pageFile.exists() ) {
            if( !pageFile.delete() ) {
                log.error("Unable to delete page." + pageFile.getPath() );
            }
            
        }
         else {
            throw new NoSuchVersionException("Page "+page+", version="+version);
        }
        
    }
    
    public Collection< Page > getAllPages() throws ProviderException {
        final Collection< Page > pages = super.getAllPages();
        final Collection< Page > returnedPages = new ArrayList<>();
        for( final Page page : pages ) {
            final Page info = getPageInfo( page.getName(), WikiProvider.LATEST_VERSION );
            returnedPages.add( info );
        }
        
        return returnedPages;
    }
    
    public String getProviderInfo() {
        return "";
    }
    
    public void movePage( final String from, final String to ) {
        final File fromFile = findPage( from );
        final File toFile = findPage( to );
        fromFile.renameTo( toFile );
        final File fromOldDir = findOldPageDir( from );
        final File toOldDir = findOldPageDir( to );
        fromOldDir.renameTo( toOldDir );
    }
    
    private static class CachedProperties {
        String m_page;
        Properties m_props;
        long m_lastModified;
        public CachedProperties( final String pageName, final Properties props, final long lastModified ) {
            if ( pageName == null ) {
                throw new NullPointerException ( "pageName must not be null!" );
            }
            
            this.m_page = pageName;
            if ( props == null ) {
                throw new NullPointerException ( "properties must not be null!" );
            }
            
            m_props = props;
            this.m_lastModified = lastModified;
        }
        
    }
    
}


