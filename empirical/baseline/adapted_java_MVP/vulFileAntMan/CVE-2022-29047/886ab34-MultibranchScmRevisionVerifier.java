package org.jenkinsci.plugins.workflow.libs;
import hudson.AbortException;
import hudson.model.Job;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.scm.SCM;
import jenkins.branch.Branch;
import jenkins.scm.api.SCMHead;
import jenkins.scm.api.SCMRevision;
import jenkins.scm.api.SCMRevisionAction;
import jenkins.scm.api.SCMSource;
import jenkins.scm.api.SCMSourceOwner;
import org.jenkinsci.plugins.variant.OptionalExtension;
import org.jenkinsci.plugins.workflow.multibranch.BranchJobProperty;
import java.io.IOException;
public class MultibranchScmRevisionVerifier implements SCMSourceRetrieverVerifier {
    public void verify(Run<?, ?> run, TaskListener listener, SCM libraryScm, String name) throws IOException, InterruptedException {
        Job<?, ?> job = run.getParent();
        BranchJobProperty property = job.getProperty(BranchJobProperty.class);
        if (property == null || !(job.getParent() instanceof SCMSourceOwner)) {
            return;
        }
        
        Branch pipelineBranch = property.getBranch();
        SCMSource pipelineScmSource = ((SCMSourceOwner)job.getParent()).getSCMSource(pipelineBranch.getSourceId());
        if (pipelineScmSource == null) {
            throw new IllegalStateException(pipelineBranch.getSourceId() + " not found");
        }
        
        SCMHead head = pipelineBranch.getHead();
        SCMRevision headRevision;
        SCMRevisionAction action = run.getAction(SCMRevisionAction.class);
        if (action != null) {
            headRevision = action.getRevision();
        }
         else {
            headRevision = pipelineScmSource.fetch(head, listener);
            if (headRevision == null) {
                throw new AbortException("Could not determine exact tip revision of " + pipelineBranch.getName());
            }
            
            run.addAction(new SCMRevisionAction(pipelineScmSource, headRevision));
        }
        
        SCMRevision trustedRevision = pipelineScmSource.getTrustedRevision(headRevision, listener);
        if (!headRevision.equals(trustedRevision) && libraryScm.getKey().equals(pipelineScmSource.build(head, headRevision).getKey())) {
            throw new AbortException("Library '" + name + "' has been modified in an untrusted revision");
        }
        
    }
    
}


