package com.esotericsoftware.yamlbeans;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
import com.esotericsoftware.yamlbeans.Beans.Property;
import com.esotericsoftware.yamlbeans.emitter.EmitterConfig;
import com.esotericsoftware.yamlbeans.scalar.DateSerializer;
import com.esotericsoftware.yamlbeans.scalar.ScalarSerializer;
public class YamlConfig {
	 public final WriteConfig writeConfig = new WriteConfig();
	 public final ReadConfig readConfig = new ReadConfig();
	final Map<String, String> classNameToTag = new HashMap();
	final Map<String, Class> tagToClass = new HashMap();
	final Map<Class, ScalarSerializer> scalarSerializers = new IdentityHashMap();
	final Map<Property, Class> propertyToElementType = new HashMap();
	final Map<Property, Class> propertyToDefaultType = new HashMap();
	boolean beanProperties = true;
	boolean privateFields;
	boolean privateConstructors = true;
	boolean allowDuplicates = true;
	String tagSuffix;
	public YamlConfig () {
		scalarSerializers.put(Date.class, new DateSerializer());
		tagToClass.put("tag:yaml.org,2002:str", String.class);
		tagToClass.put("tag:yaml.org,2002:int", Integer.class);
		tagToClass.put("tag:yaml.org,2002:seq", ArrayList.class);
		tagToClass.put("tag:yaml.org,2002:map", HashMap.class);
		tagToClass.put("tag:yaml.org,2002:float", Float.class);
	}
	
	 public void setAllowDuplicates (boolean allowDuplicates) {
		this.allowDuplicates = allowDuplicates;
	}
	
	 public void setClassTag (String tag, Class type) {
		if (tag == null) throw new IllegalArgumentException("tag cannot be null.");
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (!tag.startsWith("!")) tag = "!" + tag;
		classNameToTag.put(type.getName(), tag);
		tagToClass.put(tag, type);
	}
	
	 public void setScalarSerializer (Class type, ScalarSerializer serializer) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		scalarSerializers.put(type, serializer);
	}
	
	 public void setPropertyElementType (Class type, String propertyName, Class elementType) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (propertyName == null) throw new IllegalArgumentException("propertyName cannot be null.");
		if (elementType == null) throw new IllegalArgumentException("propertyType cannot be null.");
		Property property = Beans.getProperty(type, propertyName, beanProperties, privateFields, this);
		if (property == null){
			throw new IllegalArgumentException("The class " + type.getName() + " does not have a property named: " + propertyName);
}
		if (!Collection.class.isAssignableFrom(property.getType()) && !Map.class.isAssignableFrom(property.getType())) {
			throw new IllegalArgumentException("The '" + propertyName + "' property on the " + type.getName() + " class must be a Collection or Map: " + property.getType());
		}
		
		propertyToElementType.put(property, elementType);
	}
	
	 public void setPropertyDefaultType (Class type, String propertyName, Class defaultType) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (propertyName == null) throw new IllegalArgumentException("propertyName cannot be null.");
		if (defaultType == null) throw new IllegalArgumentException("defaultType cannot be null.");
		Property property = Beans.getProperty(type, propertyName, beanProperties, privateFields, this);
		if (property == null){
			throw new IllegalArgumentException("The class " + type.getName() + " does not have a property named: " + propertyName);
}
		propertyToDefaultType.put(property, defaultType);
	}
	
	 public void setBeanProperties (boolean beanProperties) {
		this.beanProperties = beanProperties;
	}
	
	 public void setPrivateFields (boolean privateFields) {
		this.privateFields = privateFields;
	}
	
	 public void setPrivateConstructors (boolean privateConstructors) {
		this.privateConstructors = privateConstructors;
	}
	
	 public void setTagSuffix (String tagSuffix) {
		this.tagSuffix = tagSuffix;
	}
	
	static public class WriteConfig {
		boolean explicitFirstDocument = false;
		boolean explicitEndDocument = false;
		boolean writeDefaultValues = false;
		boolean writeRootTags = true;
		boolean writeRootElementTags = true;
		boolean autoAnchor = true;
		boolean keepBeanPropertyOrder = false;
		WriteClassName writeClassName = WriteClassName.AUTO;
		Quote quote = Quote.NONE;
		Version version;
		Map<String, String> tags;
		boolean flowStyle;
		EmitterConfig emitterConfig = new EmitterConfig();
		WriteConfig () {
			emitterConfig.setUseVerbatimTags(false);
		}
		
		 public void setExplicitFirstDocument (boolean explicitFirstDocument) {
			this.explicitFirstDocument = explicitFirstDocument;
		}
		
		 public void setExplicitEndDocument (boolean explicitEndDocument) {
			this.explicitEndDocument = explicitEndDocument;
		}
		
		 public void setWriteRootTags (boolean writeRootTags) {
			this.writeRootTags = writeRootTags;
		}
		
		 public void setWriteRootElementTags (boolean writeRootElementTags) {
			this.writeRootElementTags = writeRootElementTags;
		}
		
		 public void setWriteDefaultValues (boolean writeDefaultValues) {
			this.writeDefaultValues = writeDefaultValues;
		}
		
		 public void setAutoAnchor (boolean autoAnchor) {
			this.autoAnchor = autoAnchor;
		}
		
		 public void setKeepBeanPropertyOrder (boolean keepBeanPropertyOrder) {
			this.keepBeanPropertyOrder = keepBeanPropertyOrder;
		}
		
		 public void setVersion (Version version) {
			this.version = version;
		}
		
		 public void setTags (Map<String, String> tags) {
			this.tags = tags;
		}
		
		 public void setCanonical (boolean canonical) {
			emitterConfig.setCanonical(canonical);
		}
		
		 public void setIndentSize (int indentSize) {
			emitterConfig.setIndentSize(indentSize);
		}
		
		 public void setWrapColumn (int wrapColumn) {
			emitterConfig.setWrapColumn(wrapColumn);
		}
		
		 public void setUseVerbatimTags (boolean useVerbatimTags) {
			emitterConfig.setUseVerbatimTags(useVerbatimTags);
		}
		
		 public void setEscapeUnicode (boolean escapeUnicode) {
			emitterConfig.setEscapeUnicode(escapeUnicode);
		}
		
		 public void setWriteClassname (WriteClassName write) {
			writeClassName = write;
		}
		
		 public void setQuoteChar (Quote quote) {
			this.quote = quote;
		}
		
		public Quote getQuote () {
			return quote;
		}
		
		 public void setFlowStyle (boolean flowStyle) {
			this.flowStyle = flowStyle;
		}
		
		public boolean isFlowStyle () {
			return flowStyle;
		}
		
		 public void setPrettyFlow (boolean prettyFlow) {
			emitterConfig.setPrettyFlow(prettyFlow);
		}
		
	}
	
	static public class ReadConfig {
		Version defaultVersion = Version.DEFAULT_VERSION;
		ClassLoader classLoader;
		final Map<Class, ConstructorParameters> constructorParameters = new IdentityHashMap();
		boolean ignoreUnknownProperties;
		boolean autoMerge = true;
		boolean classTags = true;
		boolean guessNumberTypes;
		ReadConfig () {
		}
		
		 public void setDefaultVersion (Version defaultVersion) {
			if (defaultVersion == null) throw new IllegalArgumentException("defaultVersion cannot be null.");
			this.defaultVersion = defaultVersion;
		}
		
		 public void setClassLoader (ClassLoader classLoader) {
			this.classLoader = classLoader;
		}
		
		 public void setConstructorParameters (Class type, Class[] parameterTypes, String[] parameterNames) {
			if (type == null) throw new IllegalArgumentException("type cannot be null.");
			if (parameterTypes == null) throw new IllegalArgumentException("parameterTypes cannot be null.");
			if (parameterNames == null) throw new IllegalArgumentException("parameterNames cannot be null.");
			ConstructorParameters parameters = new ConstructorParameters();
			try {
				parameters.constructor = type.getConstructor(parameterTypes);
			}
			 catch (Exception ex) {
				throw new IllegalArgumentException( "Unable to find constructor: " + type.getName() + "(" + Arrays.toString(parameterTypes) + ")", ex);
			}
			
			parameters.parameterNames = parameterNames;
			constructorParameters.put(type, parameters);
		}
		
		 public void setIgnoreUnknownProperties (boolean allowUnknownProperties) {
			this.ignoreUnknownProperties = allowUnknownProperties;
		}
		
		 public void setClassTags (boolean classTags) {
			this.classTags = classTags;
		}
		
		 public void setAutoMerge (boolean autoMerge) {
			this.autoMerge = autoMerge;
		}
		
		 public void setGuessNumberTypes (boolean guessNumberTypes) {
			this.guessNumberTypes = guessNumberTypes;
		}
		
	}
	
	static class ConstructorParameters {
		public Constructor constructor;
		public String[] parameterNames;
	}
	
	public static enum WriteClassName {
		ALWAYS, NEVER, AUTO }
	public static enum Quote {
		NONE('\0'), SINGLE('\''), DOUBLE('"'), LITERAL('|'), FOLDED('>');
		char c;
		Quote (char c) {
			this.c = c;
		}
		
		public char getStyle () {
			return c;
		}
		
	}
	
}


