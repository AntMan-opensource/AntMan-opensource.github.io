package org.apache.pinot.controller.api.resources;
import com.fasterxml.jackson.core.type.TypeReference;
import com.google.common.base.Preconditions;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiKeyAuthDefinition;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.Authorization;
import io.swagger.annotations.SecurityDefinition;
import io.swagger.annotations.SwaggerDefinition;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Map;
import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.Suspended;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import org.apache.pinot.common.auth.AuthProviderUtils;
import org.apache.pinot.controller.ControllerConf;
import org.apache.pinot.controller.api.access.AccessType;
import org.apache.pinot.controller.api.access.Authenticate;
import org.apache.pinot.controller.api.exception.ControllerApplicationException;
import org.apache.pinot.controller.helix.core.PinotHelixResourceManager;
import org.apache.pinot.controller.util.FileIngestionHelper;
import org.apache.pinot.controller.util.FileIngestionHelper.DataPayload;
import org.apache.pinot.spi.auth.AuthProvider;
import org.apache.pinot.spi.config.table.TableConfig;
import org.apache.pinot.spi.config.table.TableType;
import org.apache.pinot.spi.data.Schema;
import org.apache.pinot.spi.utils.CommonConstants;
import org.apache.pinot.spi.utils.JsonUtils;
import org.apache.pinot.spi.utils.builder.TableNameBuilder;
import org.glassfish.jersey.media.multipart.FormDataMultiPart;
import org.glassfish.jersey.server.ManagedAsync;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static org.apache.pinot.spi.utils.CommonConstants.SWAGGER_AUTHORIZATION_KEY;
@Api(tags = Constants.TABLE_TAG, authorizations = {@Authorization(value = SWAGGER_AUTHORIZATION_KEY)})
@SwaggerDefinition(securityDefinition = @SecurityDefinition(apiKeyAuthDefinitions = @ApiKeyAuthDefinition(name = HttpHeaders.AUTHORIZATION, in = ApiKeyAuthDefinition.ApiKeyLocation.HEADER, key = SWAGGER_AUTHORIZATION_KEY)))
public class PinotIngestionRestletResource {
  private static final Logger LOGGER = LoggerFactory.getLogger(PinotIngestionRestletResource.class);
  private static final String INGESTION_DIR = "ingestion_dir";
  @Inject
  PinotHelixResourceManager _pinotHelixResourceManager;
  @Inject
  ControllerConf _controllerConf;
  @ApiOperation(value = "Ingest a file", notes = "Creates a segment using given file and pushes it to Pinot. " + "\n All steps happen on the controller. This API is NOT meant for production environments/large input files. " + "\n Example usage (query params need encoding):" + "\n```" + "\ncurl -X POST -F file=@data.json -H \"Content-Type: multipart/form-data\" " + "\"http://localhost:9000/ingestFromFile?tableNameWithType=foo_OFFLINE&" + "\nbatchConfigMapStr={" + "\n  \"inputFormat\":\"csv\"," + "\n  \"recordReader.prop.delimiter\":\"|\"" + "\n}\" " + "\n```")
  public void ingestFromFile( @ApiParam(value = "Name of the table to upload the file to", required = true) @QueryParam("tableNameWithType") String tableNameWithType, @ApiParam(value = "Batch config Map as json string. Must pass inputFormat, and optionally record reader properties. e.g. " + "{\"inputFormat\":\"json\"}", required = true) @QueryParam("batchConfigMapStr") String batchConfigMapStr, FormDataMultiPart fileUpload, @Suspended final AsyncResponse asyncResponse) {
    try {
      asyncResponse.resume(ingestData(tableNameWithType, batchConfigMapStr, new DataPayload(fileUpload)));
    }
     catch (IllegalArgumentException e) {
      asyncResponse.resume(new ControllerApplicationException(LOGGER, String .format("Got illegal argument when ingesting file into table: %s. %s", tableNameWithType, e.getMessage()), Response.Status.BAD_REQUEST, e));
    }
     catch (Exception e) {
      asyncResponse.resume(new ControllerApplicationException(LOGGER, String.format("Caught exception when ingesting file into table: %s. %s", tableNameWithType, e.getMessage()), Response.Status.INTERNAL_SERVER_ERROR, e));
    }
    
  }
  
  @ApiOperation(value = "Ingest from the given URI", notes = "Creates a segment using file at the given URI and pushes it to Pinot. " + "\n All steps happen on the controller. This API is NOT meant for production environments/large input " + "files. " + "\nExample usage (query params need encoding):" + "\n```" + "\ncurl -X POST \"http://localhost:9000/ingestFromURI?tableNameWithType=foo_OFFLINE" + "\n&batchConfigMapStr={" + "\n  \"inputFormat\":\"json\"," + "\n  \"input.fs.className\":\"org.apache.pinot.plugin.filesystem.S3PinotFS\"," + "\n  \"input.fs.prop.region\":\"us-central\"," + "\n  \"input.fs.prop.accessKey\":\"foo\"," + "\n  \"input.fs.prop.secretKey\":\"bar\"" + "\n}" + "\n&sourceURIStr=s3://test.bucket/path/to/json/data/data.json\"" + "\n```")
  public void ingestFromURI( @ApiParam(value = "Name of the table to upload the file to", required = true) @QueryParam("tableNameWithType") String tableNameWithType, @ApiParam(value = "Batch config Map as json string. Must pass inputFormat, and optionally input FS properties. e.g. " + "{\"inputFormat\":\"json\"}", required = true) @QueryParam("batchConfigMapStr") String batchConfigMapStr, @ApiParam(value = "URI of file to upload", required = true) @QueryParam("sourceURIStr") String sourceURIStr, @Suspended final AsyncResponse asyncResponse) {
    try {
      asyncResponse.resume(ingestData(tableNameWithType, batchConfigMapStr, new DataPayload(new URI(sourceURIStr))));
    }
     catch (IllegalArgumentException e) {
      asyncResponse.resume(new ControllerApplicationException(LOGGER, String .format("Got illegal argument when ingesting file into table: %s. %s", tableNameWithType, e.getMessage()), Response.Status.BAD_REQUEST, e));
    }
     catch (Exception e) {
      asyncResponse.resume(new ControllerApplicationException(LOGGER, String.format("Caught exception when ingesting file into table: %s. %s", tableNameWithType, e.getMessage()), Response.Status.INTERNAL_SERVER_ERROR, e));
    }
    
  }
  
  private SuccessResponse ingestData(String tableNameWithType, String batchConfigMapStr, DataPayload payload) throws Exception {
    TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableNameWithType);
    Preconditions .checkState(tableType != null, "Must provide table name with type suffix for table: %s", tableNameWithType);
    Preconditions .checkState(TableType.REALTIME != tableType, "Cannot ingest file into REALTIME table: %s", tableNameWithType);
    TableConfig tableConfig = _pinotHelixResourceManager.getTableConfig(tableNameWithType);
    Preconditions.checkState(tableConfig != null, "Table: %s not found", tableNameWithType);
    Map<String, String> batchConfigMap = JsonUtils.stringToObject(batchConfigMapStr, new TypeReference<Map<String, String>>() {         });
    Schema schema = _pinotHelixResourceManager.getTableSchema(tableNameWithType);
    AuthProvider authProvider = AuthProviderUtils.extractAuthProvider(_controllerConf, CommonConstants.Controller.PREFIX_OF_CONFIG_OF_SEGMENT_FETCHER_FACTORY + ".auth");
    FileIngestionHelper fileIngestionHelper = new FileIngestionHelper(tableConfig, schema, batchConfigMap, getControllerUri(), new File(_controllerConf.getLocalTempDir(), INGESTION_DIR), authProvider);
    return fileIngestionHelper.buildSegmentAndPush(payload);
  }
  
  private URI getControllerUri() {
    try {
      return new URI(_controllerConf.generateVipUrl());
    }
     catch (URISyntaxException e) {
      throw new IllegalStateException("Controller VIP uri is invalid", e);
    }
    
  }
  
}


