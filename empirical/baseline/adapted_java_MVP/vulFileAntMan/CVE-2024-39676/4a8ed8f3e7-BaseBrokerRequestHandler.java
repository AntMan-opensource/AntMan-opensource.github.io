package org.apache.pinot.broker.requesthandler;
import com.fasterxml.jackson.databind.JsonNode;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.annotation.concurrent.ThreadSafe;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.URI;
import org.apache.commons.httpclient.methods.DeleteMethod;
import org.apache.commons.lang3.StringUtils;
import org.apache.pinot.broker.api.RequesterIdentity;
import org.apache.pinot.broker.broker.AccessControlFactory;
import org.apache.pinot.broker.querylog.QueryLogger;
import org.apache.pinot.broker.queryquota.QueryQuotaManager;
import org.apache.pinot.broker.routing.BrokerRoutingManager;
import org.apache.pinot.common.config.provider.TableCache;
import org.apache.pinot.common.exception.QueryException;
import org.apache.pinot.common.http.MultiHttpRequest;
import org.apache.pinot.common.metrics.BrokerGauge;
import org.apache.pinot.common.metrics.BrokerMeter;
import org.apache.pinot.common.metrics.BrokerMetrics;
import org.apache.pinot.common.metrics.BrokerQueryPhase;
import org.apache.pinot.common.metrics.BrokerTimer;
import org.apache.pinot.common.request.BrokerRequest;
import org.apache.pinot.common.request.DataSource;
import org.apache.pinot.common.request.Expression;
import org.apache.pinot.common.request.ExpressionType;
import org.apache.pinot.common.request.Function;
import org.apache.pinot.common.request.Identifier;
import org.apache.pinot.common.request.Literal;
import org.apache.pinot.common.request.PinotQuery;
import org.apache.pinot.common.response.BrokerResponse;
import org.apache.pinot.common.response.ProcessingException;
import org.apache.pinot.common.response.broker.BrokerResponseNative;
import org.apache.pinot.common.response.broker.ResultTable;
import org.apache.pinot.common.utils.DataSchema;
import org.apache.pinot.common.utils.config.QueryOptionsUtils;
import org.apache.pinot.common.utils.request.RequestUtils;
import org.apache.pinot.core.query.optimizer.QueryOptimizer;
import org.apache.pinot.core.routing.RoutingTable;
import org.apache.pinot.core.routing.TimeBoundaryInfo;
import org.apache.pinot.core.transport.ServerInstance;
import org.apache.pinot.core.util.GapfillUtils;
import org.apache.pinot.spi.config.table.FieldConfig;
import org.apache.pinot.spi.config.table.QueryConfig;
import org.apache.pinot.spi.config.table.TableConfig;
import org.apache.pinot.spi.config.table.TableType;
import org.apache.pinot.spi.data.Schema;
import org.apache.pinot.spi.env.PinotConfiguration;
import org.apache.pinot.spi.exception.BadQueryRequestException;
import org.apache.pinot.spi.trace.RequestContext;
import org.apache.pinot.spi.trace.Tracing;
import org.apache.pinot.spi.utils.BytesUtils;
import org.apache.pinot.spi.utils.CommonConstants;
import org.apache.pinot.spi.utils.CommonConstants.Broker;
import org.apache.pinot.spi.utils.TimestampIndexUtils;
import org.apache.pinot.spi.utils.builder.TableNameBuilder;
import org.apache.pinot.sql.FilterKind;
import org.apache.pinot.sql.parsers.CalciteSqlCompiler;
import org.apache.pinot.sql.parsers.CalciteSqlParser;
import org.apache.pinot.sql.parsers.SqlNodeAndOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public abstract class BaseBrokerRequestHandler implements BrokerRequestHandler {
  private static final Logger LOGGER = LoggerFactory.getLogger(BaseBrokerRequestHandler.class);
  private static final String IN_SUBQUERY = "insubquery";
  private static final String IN_ID_SET = "inidset";
  private static final Expression FALSE = RequestUtils.getLiteralExpression(false);
  private static final Expression TRUE = RequestUtils.getLiteralExpression(true);
  private static final Expression STAR = RequestUtils.getIdentifierExpression("*");
  private static final int MAX_UNAVAILABLE_SEGMENTS_TO_PRINT_IN_QUERY_EXCEPTION = 10;
  protected final PinotConfiguration _config;
  protected final BrokerRoutingManager _routingManager;
  protected final AccessControlFactory _accessControlFactory;
  protected final QueryQuotaManager _queryQuotaManager;
  protected final TableCache _tableCache;
  protected final BrokerMetrics _brokerMetrics;
  protected final BrokerRequestIdGenerator _brokerIdGenerator;
  protected final QueryOptimizer _queryOptimizer = new QueryOptimizer();
  protected final String _brokerId;
  protected final long _brokerTimeoutMs;
  protected final int _queryResponseLimit;
  private final QueryLogger _queryLogger;
  private final boolean _disableGroovy;
  private final boolean _useApproximateFunction;
  private final int _defaultHllLog2m;
  private final boolean _enableQueryLimitOverride;
  private final boolean _enableDistinctCountBitmapOverride;
  private final Map<Long, QueryServers> _queriesById;
  public BaseBrokerRequestHandler(PinotConfiguration config, String brokerId, BrokerRoutingManager routingManager, AccessControlFactory accessControlFactory, QueryQuotaManager queryQuotaManager, TableCache tableCache, BrokerMetrics brokerMetrics) {
    _brokerId = brokerId;
    _brokerIdGenerator = new BrokerRequestIdGenerator(brokerId);
    _config = config;
    _routingManager = routingManager;
    _accessControlFactory = accessControlFactory;
    _queryQuotaManager = queryQuotaManager;
    _tableCache = tableCache;
    _brokerMetrics = brokerMetrics;
    _disableGroovy = _config.getProperty(Broker.DISABLE_GROOVY, Broker.DEFAULT_DISABLE_GROOVY);
    _useApproximateFunction = _config.getProperty(Broker.USE_APPROXIMATE_FUNCTION, false);
    _defaultHllLog2m = _config.getProperty(CommonConstants.Helix.DEFAULT_HYPERLOGLOG_LOG2M_KEY, CommonConstants.Helix.DEFAULT_HYPERLOGLOG_LOG2M);
    _enableQueryLimitOverride = _config.getProperty(Broker.CONFIG_OF_ENABLE_QUERY_LIMIT_OVERRIDE, false);
    _enableDistinctCountBitmapOverride = _config.getProperty(CommonConstants.Helix.ENABLE_DISTINCT_COUNT_BITMAP_OVERRIDE_KEY, false);
    _brokerTimeoutMs = config.getProperty(Broker.CONFIG_OF_BROKER_TIMEOUT_MS, Broker.DEFAULT_BROKER_TIMEOUT_MS);
    _queryResponseLimit = config.getProperty(Broker.CONFIG_OF_BROKER_QUERY_RESPONSE_LIMIT, Broker.DEFAULT_BROKER_QUERY_RESPONSE_LIMIT);
    _queryLogger = new QueryLogger(config);
    boolean enableQueryCancellation = Boolean.parseBoolean(config.getProperty(Broker.CONFIG_OF_BROKER_ENABLE_QUERY_CANCELLATION));
    _queriesById = enableQueryCancellation ? new ConcurrentHashMap<>() : null;
    LOGGER.info( "Broker Id: {}, timeout: {}ms, query response limit: {}, query log length: {}, query log max rate: {}qps, " + "enabling query cancellation: {}", _brokerId, _brokerTimeoutMs, _queryResponseLimit, _queryLogger.getMaxQueryLengthToLog(), _queryLogger.getLogRateLimit(), enableQueryCancellation);
  }
  
  public Map<Long, String> getRunningQueries() {
    Preconditions.checkState(_queriesById != null, "Query cancellation is not enabled on broker");
    return _queriesById.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue()._query));
  }
  
  @VisibleForTesting
  Set<ServerInstance> getRunningServers(long requestId) {
    Preconditions.checkState(_queriesById != null, "Query cancellation is not enabled on broker");
    QueryServers queryServers = _queriesById.get(requestId);
    return queryServers != null ? queryServers._servers : Collections.emptySet();
  }
  
  public boolean cancelQuery(long requestId, int timeoutMs, Executor executor, HttpConnectionManager connMgr, Map<String, Integer> serverResponses) throws Exception {
    Preconditions.checkState(_queriesById != null, "Query cancellation is not enabled on broker");
    QueryServers queryServers = _queriesById.get(requestId);
    if (queryServers == null) {
      return false;
    }
    
    String globalQueryId = getGlobalQueryId(requestId);
    List<String> serverUrls = new ArrayList<>();
    for (ServerInstance serverInstance : queryServers._servers) {
      serverUrls.add(String.format("%s/query/%s", serverInstance.getAdminEndpoint(), globalQueryId));
    }
    
    LOGGER.debug("Cancelling the query: {} via server urls: {}", queryServers._query, serverUrls);
    CompletionService<DeleteMethod> completionService = new MultiHttpRequest(executor, connMgr).execute(serverUrls, null, timeoutMs, "DELETE", DeleteMethod::new);
    List<String> errMsgs = new ArrayList<>(serverUrls.size());
    for (int i = 0; i < serverUrls.size(); i++) {
      DeleteMethod deleteMethod = null;
      try {
        deleteMethod = completionService.take().get();
        URI uri = deleteMethod.getURI();
        int status = deleteMethod.getStatusCode();
        if (status != 200 && status != 404) {
          throw new Exception(String.format("Unexpected status=%d and response='%s' from uri='%s'", status, deleteMethod.getResponseBodyAsString(), uri));
        }
        
        if (serverResponses != null) {
          serverResponses.put(uri.getHost() + ":" + uri.getPort(), status);
        }
        
      }
       catch (Exception e) {
        LOGGER.error("Failed to cancel query: {}", queryServers._query, e);
        errMsgs.add(e.getMessage());
      }
       finally {
        if (deleteMethod != null) {
          deleteMethod.releaseConnection();
        }
        
      }
      
    }
    
    if (errMsgs.size() > 0) {
      throw new Exception("Unexpected responses from servers: " + StringUtils.join(errMsgs, ","));
    }
    
    return true;
  }
  
  public BrokerResponse handleRequest(JsonNode request, @Nullable SqlNodeAndOptions sqlNodeAndOptions, @Nullable RequesterIdentity requesterIdentity, RequestContext requestContext) throws Exception {
    long requestId = _brokerIdGenerator.get();
    requestContext.setRequestId(requestId);
    requestContext.setRequestArrivalTimeMillis(System.currentTimeMillis());
    boolean hasAccess = _accessControlFactory.create().hasAccess(requesterIdentity);
    if (!hasAccess) {
      _brokerMetrics.addMeteredGlobalValue(BrokerMeter.REQUEST_DROPPED_DUE_TO_ACCESS_ERROR, 1);
      LOGGER.info("Access denied for requestId {}", requestId);
      requestContext.setErrorCode(QueryException.ACCESS_DENIED_ERROR_CODE);
      throw new WebApplicationException("Permission denied", Response.Status.FORBIDDEN);
    }
    
    JsonNode sql = request.get(Broker.Request.SQL);
    if (sql == null) {
      throw new BadQueryRequestException("Failed to find 'sql' in the request: " + request);
    }
    
    String query = sql.asText();
    requestContext.setQuery(query);
    BrokerResponse brokerResponse = handleRequest(requestId, query, sqlNodeAndOptions, request, requesterIdentity, requestContext);
    if (request.has(Broker.Request.QUERY_OPTIONS)) {
      String queryOptions = request.get(Broker.Request.QUERY_OPTIONS).asText();
      Map<String, String> optionsFromString = RequestUtils.getOptionsFromString(queryOptions);
      if (QueryOptionsUtils.shouldDropResults(optionsFromString)) {
        brokerResponse.setResultTable(null);
      }
      
    }
    
    brokerResponse.setRequestId(String.valueOf(requestId));
    brokerResponse.setBrokerId(_brokerId);
    brokerResponse.setBrokerReduceTimeMs(requestContext.getReduceTimeMillis());
    return brokerResponse;
  }
  
  private BrokerResponseNative handleRequest(long requestId, String query, @Nullable SqlNodeAndOptions sqlNodeAndOptions, JsonNode request, @Nullable RequesterIdentity requesterIdentity, RequestContext requestContext) throws Exception {
    LOGGER.debug("SQL query for request {}: {}", requestId, query);
    Tracing.ThreadAccountantOps.setupRunner(String.valueOf(requestId));
    try {
      long compilationStartTimeNs;
      PinotQuery pinotQuery;
      try {
        sqlNodeAndOptions = sqlNodeAndOptions != null ? sqlNodeAndOptions : RequestUtils.parseQuery(query, request);
        compilationStartTimeNs = System.nanoTime();
        pinotQuery = CalciteSqlParser.compileToPinotQuery(sqlNodeAndOptions);
      }
       catch (Exception e) {
        LOGGER.info("Caught exception while compiling SQL request {}: {}, {}", requestId, query, e.getMessage());
        _brokerMetrics.addMeteredGlobalValue(BrokerMeter.REQUEST_COMPILATION_EXCEPTIONS, 1);
        requestContext.setErrorCode(QueryException.SQL_PARSING_ERROR_CODE);
        return new BrokerResponseNative(QueryException.getException(QueryException.SQL_PARSING_ERROR, e));
      }
      
      if (isLiteralOnlyQuery(pinotQuery)) {
        LOGGER.debug("Request {} contains only Literal, skipping server query: {}", requestId, query);
        try {
          if (pinotQuery.isExplain()) {
            return BrokerResponseNative.BROKER_ONLY_EXPLAIN_PLAN_OUTPUT;
          }
          
          return processLiteralOnlyQuery(pinotQuery, compilationStartTimeNs, requestContext);
        }
         catch (Exception e) {
          LOGGER.warn("Unable to execute literal request {}: {} at broker, fallback to server query. {}", requestId, query, e.getMessage());
        }
        
      }
      
      PinotQuery serverPinotQuery = GapfillUtils.stripGapfill(pinotQuery);
      DataSource dataSource = serverPinotQuery.getDataSource();
      if (dataSource == null) {
        LOGGER.info("Data source (FROM clause) not found in request {}: {}", request, query);
        requestContext.setErrorCode(QueryException.QUERY_VALIDATION_ERROR_CODE);
        return new BrokerResponseNative( QueryException.getException(QueryException.QUERY_VALIDATION_ERROR, "Data source (FROM clause) not found"));
      }
      
      if (dataSource.getJoin() != null) {
        LOGGER.info("JOIN is not supported in request {}: {}", request, query);
        requestContext.setErrorCode(QueryException.QUERY_VALIDATION_ERROR_CODE);
        return new BrokerResponseNative( QueryException.getException(QueryException.QUERY_VALIDATION_ERROR, "JOIN is not supported"));
      }
      
      if (dataSource.getTableName() == null) {
        LOGGER.info("Table name not found in request {}: {}", request, query);
        requestContext.setErrorCode(QueryException.QUERY_VALIDATION_ERROR_CODE);
        return new BrokerResponseNative( QueryException.getException(QueryException.QUERY_VALIDATION_ERROR, "Table name not found"));
      }
      
      try {
        handleSubquery(serverPinotQuery, requestId, request, requesterIdentity, requestContext);
      }
       catch (Exception e) {
        LOGGER.info("Caught exception while handling the subquery in request {}: {}, {}", requestId, query, e.getMessage());
        requestContext.setErrorCode(QueryException.QUERY_EXECUTION_ERROR_CODE);
        return new BrokerResponseNative(QueryException.getException(QueryException.QUERY_EXECUTION_ERROR, e));
      }
      
      String tableName = getActualTableName(dataSource.getTableName(), _tableCache);
      dataSource.setTableName(tableName);
      String rawTableName = TableNameBuilder.extractRawTableName(tableName);
      requestContext.setTableName(rawTableName);
      try {
        boolean isCaseInsensitive = _tableCache.isIgnoreCase();
        Map<String, String> columnNameMap = _tableCache.getColumnNameMap(rawTableName);
        if (columnNameMap != null) {
          updateColumnNames(rawTableName, serverPinotQuery, isCaseInsensitive, columnNameMap);
        }
        
      }
       catch (Exception e) {
        if (e instanceof BadQueryRequestException) {
          LOGGER.info("Caught exception while checking column names in request {}: {}, {}", requestId, query, e.getMessage());
          requestContext.setErrorCode(QueryException.UNKNOWN_COLUMN_ERROR_CODE);
          _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.UNKNOWN_COLUMN_EXCEPTIONS, 1);
          return new BrokerResponseNative(QueryException.getException(QueryException.UNKNOWN_COLUMN_ERROR, e));
        }
        
        LOGGER.warn("Caught exception while updating column names in request {}: {}, {}", requestId, query, e.getMessage());
      }
      
      if (_defaultHllLog2m > 0) {
        handleHLLLog2mOverride(serverPinotQuery, _defaultHllLog2m);
      }
      
      if (_enableQueryLimitOverride) {
        handleQueryLimitOverride(serverPinotQuery, _queryResponseLimit);
      }
      
      handleSegmentPartitionedDistinctCountOverride(serverPinotQuery, getSegmentPartitionedColumns(_tableCache, tableName));
      if (_enableDistinctCountBitmapOverride) {
        handleDistinctCountBitmapOverride(serverPinotQuery);
      }
      
      long compilationEndTimeNs = System.nanoTime();
      _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.REQUEST_COMPILATION, (compilationEndTimeNs - compilationStartTimeNs) + sqlNodeAndOptions.getParseTimeNs());
      BrokerRequest brokerRequest = CalciteSqlCompiler.convertToBrokerRequest(pinotQuery);
      BrokerRequest serverBrokerRequest = serverPinotQuery == pinotQuery ? brokerRequest : CalciteSqlCompiler.convertToBrokerRequest(serverPinotQuery);
      boolean hasTableAccess = _accessControlFactory.create().hasAccess(requesterIdentity, serverBrokerRequest);
      if (!hasTableAccess) {
        _brokerMetrics.addMeteredTableValue(tableName, BrokerMeter.REQUEST_DROPPED_DUE_TO_ACCESS_ERROR, 1);
        LOGGER.info("Access denied for request {}: {}, table: {}", requestId, query, tableName);
        requestContext.setErrorCode(QueryException.ACCESS_DENIED_ERROR_CODE);
        throw new WebApplicationException("Permission denied", Response.Status.FORBIDDEN);
      }
      
      _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.AUTHORIZATION, System.nanoTime() - compilationEndTimeNs);
      String offlineTableName = null;
      String realtimeTableName = null;
      TableType tableType = TableNameBuilder.getTableTypeFromTableName(tableName);
      if (tableType == TableType.OFFLINE) {
        if (_routingManager.routingExists(tableName)) {
          offlineTableName = tableName;
        }
        
      }
       else if (tableType == TableType.REALTIME) {
        if (_routingManager.routingExists(tableName)) {
          realtimeTableName = tableName;
        }
        
      }
       else {
        String offlineTableNameToCheck = TableNameBuilder.OFFLINE.tableNameWithType(tableName);
        if (_routingManager.routingExists(offlineTableNameToCheck)) {
          offlineTableName = offlineTableNameToCheck;
        }
        
        String realtimeTableNameToCheck = TableNameBuilder.REALTIME.tableNameWithType(tableName);
        if (_routingManager.routingExists(realtimeTableNameToCheck)) {
          realtimeTableName = realtimeTableNameToCheck;
        }
        
      }
      
      TableConfig offlineTableConfig = _tableCache.getTableConfig(TableNameBuilder.OFFLINE.tableNameWithType(rawTableName));
      TableConfig realtimeTableConfig = _tableCache.getTableConfig(TableNameBuilder.REALTIME.tableNameWithType(rawTableName));
      if (offlineTableName == null && realtimeTableName == null) {
        if (realtimeTableConfig == null && offlineTableConfig == null) {
          LOGGER.info("Table not found for request {}: {}", requestId, query);
          requestContext.setErrorCode(QueryException.TABLE_DOES_NOT_EXIST_ERROR_CODE);
          return BrokerResponseNative.TABLE_DOES_NOT_EXIST;
        }
        
        LOGGER.info("No table matches for request {}: {}", requestId, query);
        requestContext.setErrorCode(QueryException.BROKER_RESOURCE_MISSING_ERROR_CODE);
        _brokerMetrics.addMeteredGlobalValue(BrokerMeter.RESOURCE_MISSING_EXCEPTIONS, 1);
        return BrokerResponseNative.NO_TABLE_RESULT;
      }
      
      if (offlineTableName == null) {
        offlineTableConfig = null;
      }
      
      if (realtimeTableName == null) {
        realtimeTableConfig = null;
      }
      
      HandlerContext handlerContext = getHandlerContext(offlineTableConfig, realtimeTableConfig);
      if (handlerContext._disableGroovy) {
        rejectGroovyQuery(serverPinotQuery);
      }
      
      if (handlerContext._useApproximateFunction) {
        handleApproximateFunctionOverride(serverPinotQuery);
      }
      
      if (!_queryQuotaManager.acquire(tableName)) {
        String errorMessage = String.format("Request %d: %s exceeds query quota for table: %s", requestId, query, tableName);
        LOGGER.info(errorMessage);
        requestContext.setErrorCode(QueryException.TOO_MANY_REQUESTS_ERROR_CODE);
        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.QUERY_QUOTA_EXCEEDED, 1);
        return new BrokerResponseNative(QueryException.getException(QueryException.QUOTA_EXCEEDED_ERROR, errorMessage));
      }
      
      try {
        validateRequest(serverPinotQuery, _queryResponseLimit);
      }
       catch (Exception e) {
        LOGGER.info("Caught exception while validating request {}: {}, {}", requestId, query, e.getMessage());
        requestContext.setErrorCode(QueryException.QUERY_VALIDATION_ERROR_CODE);
        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.QUERY_VALIDATION_EXCEPTIONS, 1);
        return new BrokerResponseNative(QueryException.getException(QueryException.QUERY_VALIDATION_ERROR, e));
      }
      
      _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.QUERIES, 1);
      _brokerMetrics.addValueToTableGauge(rawTableName, BrokerGauge.REQUEST_SIZE, query.length());
      BrokerRequest offlineBrokerRequest = null;
      BrokerRequest realtimeBrokerRequest = null;
      TimeBoundaryInfo timeBoundaryInfo = null;
      Schema schema = _tableCache.getSchema(rawTableName);
      if (offlineTableName != null && realtimeTableName != null) {
        timeBoundaryInfo = _routingManager.getTimeBoundaryInfo(offlineTableName);
        if (timeBoundaryInfo == null) {
          LOGGER.debug("No time boundary info found for hybrid table: {}", rawTableName);
          offlineTableName = null;
        }
        
      }
      
      if (offlineTableName != null && realtimeTableName != null) {
        PinotQuery offlinePinotQuery = serverPinotQuery.deepCopy();
        offlinePinotQuery.getDataSource().setTableName(offlineTableName);
        attachTimeBoundary(offlinePinotQuery, timeBoundaryInfo, true);
        handleExpressionOverride(offlinePinotQuery, _tableCache.getExpressionOverrideMap(offlineTableName));
        handleTimestampIndexOverride(offlinePinotQuery, offlineTableConfig);
        _queryOptimizer.optimize(offlinePinotQuery, offlineTableConfig, schema);
        offlineBrokerRequest = CalciteSqlCompiler.convertToBrokerRequest(offlinePinotQuery);
        PinotQuery realtimePinotQuery = serverPinotQuery.deepCopy();
        realtimePinotQuery.getDataSource().setTableName(realtimeTableName);
        attachTimeBoundary(realtimePinotQuery, timeBoundaryInfo, false);
        handleExpressionOverride(realtimePinotQuery, _tableCache.getExpressionOverrideMap(realtimeTableName));
        handleTimestampIndexOverride(realtimePinotQuery, realtimeTableConfig);
        _queryOptimizer.optimize(realtimePinotQuery, realtimeTableConfig, schema);
        realtimeBrokerRequest = CalciteSqlCompiler.convertToBrokerRequest(realtimePinotQuery);
        requestContext.setFanoutType(RequestContext.FanoutType.HYBRID);
        requestContext.setOfflineServerTenant(getServerTenant(offlineTableName));
        requestContext.setRealtimeServerTenant(getServerTenant(realtimeTableName));
      }
       else if (offlineTableName != null) {
        setTableName(serverBrokerRequest, offlineTableName);
        handleExpressionOverride(serverPinotQuery, _tableCache.getExpressionOverrideMap(offlineTableName));
        handleTimestampIndexOverride(serverPinotQuery, offlineTableConfig);
        _queryOptimizer.optimize(serverPinotQuery, offlineTableConfig, schema);
        offlineBrokerRequest = serverBrokerRequest;
        requestContext.setFanoutType(RequestContext.FanoutType.OFFLINE);
        requestContext.setOfflineServerTenant(getServerTenant(offlineTableName));
      }
       else {
        setTableName(serverBrokerRequest, realtimeTableName);
        handleExpressionOverride(serverPinotQuery, _tableCache.getExpressionOverrideMap(realtimeTableName));
        handleTimestampIndexOverride(serverPinotQuery, realtimeTableConfig);
        _queryOptimizer.optimize(serverPinotQuery, realtimeTableConfig, schema);
        realtimeBrokerRequest = serverBrokerRequest;
        requestContext.setFanoutType(RequestContext.FanoutType.REALTIME);
        requestContext.setRealtimeServerTenant(getServerTenant(realtimeTableName));
      }
      
      if (offlineBrokerRequest != null && isFilterAlwaysFalse(offlineBrokerRequest.getPinotQuery())) {
        offlineBrokerRequest = null;
      }
      
      if (realtimeBrokerRequest != null && isFilterAlwaysFalse(realtimeBrokerRequest.getPinotQuery())) {
        realtimeBrokerRequest = null;
      }
      
      if (offlineBrokerRequest == null && realtimeBrokerRequest == null) {
        return getEmptyBrokerOnlyResponse(requestId, query, requesterIdentity, requestContext, pinotQuery, tableName);
      }
      
      if (offlineBrokerRequest != null && isFilterAlwaysTrue(offlineBrokerRequest.getPinotQuery())) {
        offlineBrokerRequest.getPinotQuery().setFilterExpression(null);
      }
      
      if (realtimeBrokerRequest != null && isFilterAlwaysTrue(realtimeBrokerRequest.getPinotQuery())) {
        realtimeBrokerRequest.getPinotQuery().setFilterExpression(null);
      }
      
      long routingStartTimeNs = System.nanoTime();
      Map<ServerInstance, List<String>> offlineRoutingTable = null;
      Map<ServerInstance, List<String>> realtimeRoutingTable = null;
      List<String> unavailableSegments = new ArrayList<>();
      int numPrunedSegmentsTotal = 0;
      if (offlineBrokerRequest != null) {
        RoutingTable routingTable = _routingManager.getRoutingTable(offlineBrokerRequest, requestId);
        if (routingTable != null) {
          unavailableSegments.addAll(routingTable.getUnavailableSegments());
          Map<ServerInstance, List<String>> serverInstanceToSegmentsMap = routingTable.getServerInstanceToSegmentsMap();
          if (!serverInstanceToSegmentsMap.isEmpty()) {
            offlineRoutingTable = serverInstanceToSegmentsMap;
          }
           else {
            offlineBrokerRequest = null;
          }
          
          numPrunedSegmentsTotal += routingTable.getNumPrunedSegments();
        }
         else {
          offlineBrokerRequest = null;
        }
        
      }
      
      if (realtimeBrokerRequest != null) {
        RoutingTable routingTable = _routingManager.getRoutingTable(realtimeBrokerRequest, requestId);
        if (routingTable != null) {
          unavailableSegments.addAll(routingTable.getUnavailableSegments());
          Map<ServerInstance, List<String>> serverInstanceToSegmentsMap = routingTable.getServerInstanceToSegmentsMap();
          if (!serverInstanceToSegmentsMap.isEmpty()) {
            realtimeRoutingTable = serverInstanceToSegmentsMap;
          }
           else {
            realtimeBrokerRequest = null;
          }
          
          numPrunedSegmentsTotal += routingTable.getNumPrunedSegments();
        }
         else {
          realtimeBrokerRequest = null;
        }
        
      }
      
      int numUnavailableSegments = unavailableSegments.size();
      requestContext.setNumUnavailableSegments(numUnavailableSegments);
      List<ProcessingException> exceptions = new ArrayList<>();
      if (numUnavailableSegments > 0) {
        String errorMessage;
        if (numUnavailableSegments > MAX_UNAVAILABLE_SEGMENTS_TO_PRINT_IN_QUERY_EXCEPTION) {
          errorMessage = String.format("%d segments unavailable, sampling %d: %s", numUnavailableSegments, MAX_UNAVAILABLE_SEGMENTS_TO_PRINT_IN_QUERY_EXCEPTION, unavailableSegments.subList(0, MAX_UNAVAILABLE_SEGMENTS_TO_PRINT_IN_QUERY_EXCEPTION));
        }
         else {
          errorMessage = String.format("%d segments unavailable: %s", numUnavailableSegments, unavailableSegments);
        }
        
        exceptions.add(QueryException.getException(QueryException.BROKER_SEGMENT_UNAVAILABLE_ERROR, errorMessage));
      }
      
      if (offlineBrokerRequest == null && realtimeBrokerRequest == null) {
        if (!exceptions.isEmpty()) {
          LOGGER.info("No server found for request {}: {}", requestId, query);
          _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.NO_SERVER_FOUND_EXCEPTIONS, 1);
          return new BrokerResponseNative(exceptions);
        }
         else {
          return getEmptyBrokerOnlyResponse(requestId, query, requesterIdentity, requestContext, pinotQuery, tableName);
        }
        
      }
      
      long routingEndTimeNs = System.nanoTime();
      _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_ROUTING, routingEndTimeNs - routingStartTimeNs);
      long timeSpentMs = TimeUnit.NANOSECONDS.toMillis(routingEndTimeNs - compilationStartTimeNs);
      long remainingTimeMs = 0;
      try {
        if (offlineBrokerRequest != null) {
          remainingTimeMs = setQueryTimeout(offlineTableName, offlineBrokerRequest.getPinotQuery().getQueryOptions(), timeSpentMs);
        }
        
        if (realtimeBrokerRequest != null) {
          remainingTimeMs = Math.max(remainingTimeMs, setQueryTimeout(realtimeTableName, realtimeBrokerRequest.getPinotQuery().getQueryOptions(), timeSpentMs));
        }
        
      }
       catch (TimeoutException e) {
        String errorMessage = e.getMessage();
        LOGGER.info("{} {}: {}", errorMessage, requestId, query);
        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.REQUEST_TIMEOUT_BEFORE_SCATTERED_EXCEPTIONS, 1);
        exceptions.add(QueryException.getException(QueryException.BROKER_TIMEOUT_ERROR, errorMessage));
        return new BrokerResponseNative(exceptions);
      }
      
      ServerStats serverStats = new ServerStats();
      if (pinotQuery.isExplain()) {
        if (offlineRoutingTable != null) {
          realtimeBrokerRequest = null;
          realtimeRoutingTable = null;
        }
        
      }
      
      BrokerResponseNative brokerResponse;
      if (_queriesById != null) {
        _queriesById.put(requestId, new QueryServers(query, offlineRoutingTable, realtimeRoutingTable));
        LOGGER.debug("Keep track of running query: {}", requestId);
        try {
          brokerResponse = processBrokerRequest(requestId, brokerRequest, serverBrokerRequest, offlineBrokerRequest, offlineRoutingTable, realtimeBrokerRequest, realtimeRoutingTable, remainingTimeMs, serverStats, requestContext);
        }
         finally {
          _queriesById.remove(requestId);
          LOGGER.debug("Remove track of running query: {}", requestId);
        }
        
      }
       else {
        brokerResponse = processBrokerRequest(requestId, brokerRequest, serverBrokerRequest, offlineBrokerRequest, offlineRoutingTable, realtimeBrokerRequest, realtimeRoutingTable, remainingTimeMs, serverStats, requestContext);
      }
      
      brokerResponse.setExceptions(exceptions);
      brokerResponse.setNumSegmentsPrunedByBroker(numPrunedSegmentsTotal);
      long executionEndTimeNs = System.nanoTime();
      _brokerMetrics.addPhaseTiming(rawTableName, BrokerQueryPhase.QUERY_EXECUTION, executionEndTimeNs - routingEndTimeNs);
      if (brokerResponse.isNumGroupsLimitReached()) {
        _brokerMetrics.addMeteredTableValue(rawTableName, BrokerMeter.BROKER_RESPONSES_WITH_NUM_GROUPS_LIMIT_REACHED, 1);
      }
      
      long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(executionEndTimeNs - compilationStartTimeNs);
      brokerResponse.setTimeUsedMs(totalTimeMs);
      requestContext.setQueryProcessingTime(totalTimeMs);
      augmentStatistics(requestContext, brokerResponse);
      _brokerMetrics.addTimedTableValue(rawTableName, BrokerTimer.QUERY_TOTAL_TIME_MS, totalTimeMs, TimeUnit.MILLISECONDS);
      _queryLogger.log( new QueryLogger.QueryLogParams(requestId, query, requestContext, tableName, numUnavailableSegments, serverStats, brokerResponse, totalTimeMs, requesterIdentity));
      return brokerResponse;
    }
     finally {
      Tracing.ThreadAccountantOps.clear();
    }
    
  }
  
  private BrokerResponseNative getEmptyBrokerOnlyResponse(long requestId, String query, RequesterIdentity requesterIdentity, RequestContext requestContext, PinotQuery pinotQuery, String tableName) {
    if (pinotQuery.isExplain()) {
      return BrokerResponseNative.BROKER_ONLY_EXPLAIN_PLAN_OUTPUT;
    }
    
    BrokerResponseNative brokerResponse = BrokerResponseNative.empty();
    _queryLogger.log(new QueryLogger.QueryLogParams(requestId, query, requestContext, tableName, 0, new ServerStats(), brokerResponse, System.nanoTime(), requesterIdentity));
    return brokerResponse;
  }
  
  private void handleTimestampIndexOverride(PinotQuery pinotQuery, @Nullable TableConfig tableConfig) {
    if (tableConfig == null || tableConfig.getFieldConfigList() == null) {
      return;
    }
    
    Set<String> timestampIndexColumns = _tableCache.getTimestampIndexColumns(tableConfig.getTableName());
    if (CollectionUtils.isEmpty(timestampIndexColumns)) {
      return;
    }
    
    for (Expression expression : pinotQuery.getSelectList()) {
      setTimestampIndexExpressionOverrideHints(expression, timestampIndexColumns, pinotQuery);
    }
    
    setTimestampIndexExpressionOverrideHints(pinotQuery.getFilterExpression(), timestampIndexColumns, pinotQuery);
    setTimestampIndexExpressionOverrideHints(pinotQuery.getHavingExpression(), timestampIndexColumns, pinotQuery);
    List<Expression> groupByList = pinotQuery.getGroupByList();
    if (CollectionUtils.isNotEmpty(groupByList)) {
      groupByList.forEach( expression -> setTimestampIndexExpressionOverrideHints(expression, timestampIndexColumns, pinotQuery));
    }
    
    List<Expression> orderByList = pinotQuery.getOrderByList();
    if (CollectionUtils.isNotEmpty(orderByList)) {
      orderByList.forEach( expression -> setTimestampIndexExpressionOverrideHints(expression, timestampIndexColumns, pinotQuery));
    }
    
  }
  
  private void setTimestampIndexExpressionOverrideHints(@Nullable Expression expression, Set<String> timestampIndexColumns, PinotQuery pinotQuery) {
    if (expression == null || expression.getFunctionCall() == null) {
      return;
    }
    
    Function function = expression.getFunctionCall();
    switch (function.getOperator()) {
      case "datetrunc":
        String granularString = function.getOperands().get(0).getLiteral().getStringValue().toUpperCase();
        Expression timeExpression = function.getOperands().get(1);
        if (((function.getOperandsSize() == 2) || (function.getOperandsSize() == 3 && "MILLISECONDS".equalsIgnoreCase( function.getOperands().get(2).getLiteral().getStringValue()))) && TimestampIndexUtils.isValidGranularity( granularString) && timeExpression.getIdentifier() != null) {
          String timeColumn = timeExpression.getIdentifier().getName();
          String timeColumnWithGranularity = TimestampIndexUtils.getColumnWithGranularity(timeColumn, granularString);
          if (timestampIndexColumns.contains(timeColumnWithGranularity)) {
            pinotQuery.putToExpressionOverrideHints(expression, RequestUtils.getIdentifierExpression(timeColumnWithGranularity));
          }
          
        }
        
        break;
      default: break;
    }
    
    function.getOperands() .forEach(operand -> setTimestampIndexExpressionOverrideHints(operand, timestampIndexColumns, pinotQuery));
  }
  
  private boolean isFilterAlwaysFalse(PinotQuery pinotQuery) {
    return FALSE.equals(pinotQuery.getFilterExpression());
  }
  
  private boolean isFilterAlwaysTrue(PinotQuery pinotQuery) {
    return TRUE.equals(pinotQuery.getFilterExpression());
  }
  
  private String getServerTenant(String tableNameWithType) {
    TableConfig tableConfig = _tableCache.getTableConfig(tableNameWithType);
    if (tableConfig == null) {
      LOGGER.debug("Table config is not available for table {}", tableNameWithType);
      return "unknownTenant";
    }
    
    return tableConfig.getTenantConfig().getServer();
  }
  
  private void handleSubquery(PinotQuery pinotQuery, long requestId, JsonNode jsonRequest, @Nullable RequesterIdentity requesterIdentity, RequestContext requestContext) throws Exception {
    Expression filterExpression = pinotQuery.getFilterExpression();
    if (filterExpression != null) {
      handleSubquery(filterExpression, requestId, jsonRequest, requesterIdentity, requestContext);
    }
    
  }
  
  private void handleSubquery(Expression expression, long requestId, JsonNode jsonRequest, @Nullable RequesterIdentity requesterIdentity, RequestContext requestContext) throws Exception {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    List<Expression> operands = function.getOperands();
    if (function.getOperator().equals(IN_SUBQUERY)) {
      Preconditions.checkState(operands.size() == 2, "IN_SUBQUERY requires 2 arguments: expression, subquery");
      Literal subqueryLiteral = operands.get(1).getLiteral();
      Preconditions.checkState(subqueryLiteral != null, "Second argument of IN_SUBQUERY must be a literal (subquery)");
      String subquery = subqueryLiteral.getStringValue();
      BrokerResponseNative response = handleRequest(requestId, subquery, null, jsonRequest, requesterIdentity, requestContext);
      if (response.getExceptionsSize() != 0) {
        throw new RuntimeException("Caught exception while executing subquery: " + subquery);
      }
      
      String serializedIdSet = (String) response.getResultTable().getRows().get(0)[0];
      function.setOperator(IN_ID_SET);
      operands.set(1, RequestUtils.getLiteralExpression(serializedIdSet));
    }
     else {
      for (Expression operand : operands) {
        handleSubquery(operand, requestId, jsonRequest, requesterIdentity, requestContext);
      }
      
    }
    
  }
  
  @VisibleForTesting
  static String getActualTableName(String tableName, TableCache tableCache) {
    String actualTableName = tableCache.getActualTableName(tableName);
    if (actualTableName != null) {
      return actualTableName;
    }
    
    String[] tableNameSplits = StringUtils.split(tableName, ".", 2);
    if (tableNameSplits.length == 2) {
      actualTableName = tableCache.getActualTableName(tableNameSplits[1]);
      if (actualTableName != null) {
        return actualTableName;
      }
      
    }
    
    return tableName;
  }
  
  private static Set<String> getSegmentPartitionedColumns(TableCache tableCache, String tableName) {
    final TableConfig offlineTableConfig = tableCache.getTableConfig(TableNameBuilder.OFFLINE.tableNameWithType(tableName));
    final TableConfig realtimeTableConfig = tableCache.getTableConfig(TableNameBuilder.REALTIME.tableNameWithType(tableName));
    if (offlineTableConfig == null) {
      return getSegmentPartitionedColumns(realtimeTableConfig);
    }
    
    if (realtimeTableConfig == null) {
      return getSegmentPartitionedColumns(offlineTableConfig);
    }
    
    Set<String> segmentPartitionedColumns = getSegmentPartitionedColumns(offlineTableConfig);
    segmentPartitionedColumns.retainAll(getSegmentPartitionedColumns(realtimeTableConfig));
    return segmentPartitionedColumns;
  }
  
  private static Set<String> getSegmentPartitionedColumns(@Nullable TableConfig tableConfig) {
    Set<String> segmentPartitionedColumns = new HashSet<>();
    if (tableConfig == null) {
      return segmentPartitionedColumns;
    }
    
    List<FieldConfig> fieldConfigs = tableConfig.getFieldConfigList();
    if (fieldConfigs != null) {
      for (FieldConfig fieldConfig : fieldConfigs) {
        if (fieldConfig.getProperties() != null && Boolean.parseBoolean( fieldConfig.getProperties().get(FieldConfig.IS_SEGMENT_PARTITIONED_COLUMN_KEY))) {
          segmentPartitionedColumns.add(fieldConfig.getName());
        }
        
      }
      
    }
    
    return segmentPartitionedColumns;
  }
  
  private void setTableName(BrokerRequest brokerRequest, String tableName) {
    brokerRequest.getQuerySource().setTableName(tableName);
    brokerRequest.getPinotQuery().getDataSource().setTableName(tableName);
  }
  
  private static void handleHLLLog2mOverride(PinotQuery pinotQuery, int hllLog2mOverride) {
    List<Expression> selectList = pinotQuery.getSelectList();
    for (Expression expression : selectList) {
      handleHLLLog2mOverride(expression, hllLog2mOverride);
    }
    
    List<Expression> orderByList = pinotQuery.getOrderByList();
    if (orderByList != null) {
      for (Expression expression : orderByList) {
        handleHLLLog2mOverride(expression.getFunctionCall().getOperands().get(0), hllLog2mOverride);
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      handleHLLLog2mOverride(havingExpression, hllLog2mOverride);
    }
    
  }
  
  private static void handleHLLLog2mOverride(Expression expression, int hllLog2mOverride) {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    switch (function.getOperator()) {
      case "distinctcounthll":
      case "distinctcounthllmv":
      case "distinctcountrawhll":
      case "distinctcountrawhllmv":
        if (function.getOperandsSize() == 1) {
          function.addToOperands(RequestUtils.getLiteralExpression(hllLog2mOverride));
        }
        
        return;
      default: break;
    }
    
    for (Expression operand : function.getOperands()) {
      handleHLLLog2mOverride(operand, hllLog2mOverride);
    }
    
  }
  
  @VisibleForTesting
  static void handleQueryLimitOverride(PinotQuery pinotQuery, int queryLimit) {
    if (queryLimit > 0 && pinotQuery.getLimit() > queryLimit) {
      pinotQuery.setLimit(queryLimit);
    }
    
  }
  
  @VisibleForTesting
  static void handleSegmentPartitionedDistinctCountOverride(PinotQuery pinotQuery, Set<String> segmentPartitionedColumns) {
    if (segmentPartitionedColumns.isEmpty()) {
      return;
    }
    
    for (Expression expression : pinotQuery.getSelectList()) {
      handleSegmentPartitionedDistinctCountOverride(expression, segmentPartitionedColumns);
    }
    
    List<Expression> orderByExpressions = pinotQuery.getOrderByList();
    if (orderByExpressions != null) {
      for (Expression expression : orderByExpressions) {
        handleSegmentPartitionedDistinctCountOverride(expression.getFunctionCall().getOperands().get(0), segmentPartitionedColumns);
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      handleSegmentPartitionedDistinctCountOverride(havingExpression, segmentPartitionedColumns);
    }
    
  }
  
  private static void handleSegmentPartitionedDistinctCountOverride(Expression expression, Set<String> segmentPartitionedColumns) {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    if (function.getOperator().equals("distinctcount")) {
      List<Expression> operands = function.getOperands();
      if (operands.size() == 1 && operands.get(0).isSetIdentifier() && segmentPartitionedColumns.contains( operands.get(0).getIdentifier().getName())) {
        function.setOperator("segmentpartitioneddistinctcount");
      }
      
    }
     else {
      for (Expression operand : function.getOperands()) {
        handleSegmentPartitionedDistinctCountOverride(operand, segmentPartitionedColumns);
      }
      
    }
    
  }
  
  private static void handleDistinctCountBitmapOverride(PinotQuery pinotQuery) {
    for (Expression expression : pinotQuery.getSelectList()) {
      handleDistinctCountBitmapOverride(expression);
    }
    
    List<Expression> orderByExpressions = pinotQuery.getOrderByList();
    if (orderByExpressions != null) {
      for (Expression expression : orderByExpressions) {
        handleDistinctCountBitmapOverride(expression.getFunctionCall().getOperands().get(0));
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      handleDistinctCountBitmapOverride(havingExpression);
    }
    
  }
  
  private static void handleDistinctCountBitmapOverride(Expression expression) {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    if (function.getOperator().equals("distinctcount")) {
      function.setOperator("distinctcountbitmap");
    }
     else {
      for (Expression operand : function.getOperands()) {
        handleDistinctCountBitmapOverride(operand);
      }
      
    }
    
  }
  
  private HandlerContext getHandlerContext(@Nullable TableConfig offlineTableConfig, @Nullable TableConfig realtimeTableConfig) {
    Boolean disableGroovyOverride = null;
    Boolean useApproximateFunctionOverride = null;
    if (offlineTableConfig != null && offlineTableConfig.getQueryConfig() != null) {
      QueryConfig offlineTableQueryConfig = offlineTableConfig.getQueryConfig();
      Boolean disableGroovyOfflineTableOverride = offlineTableQueryConfig.getDisableGroovy();
      if (disableGroovyOfflineTableOverride != null) {
        disableGroovyOverride = disableGroovyOfflineTableOverride;
      }
      
      Boolean useApproximateFunctionOfflineTableOverride = offlineTableQueryConfig.getUseApproximateFunction();
      if (useApproximateFunctionOfflineTableOverride != null) {
        useApproximateFunctionOverride = useApproximateFunctionOfflineTableOverride;
      }
      
    }
    
    if (realtimeTableConfig != null && realtimeTableConfig.getQueryConfig() != null) {
      QueryConfig realtimeTableQueryConfig = realtimeTableConfig.getQueryConfig();
      Boolean disableGroovyRealtimeTableOverride = realtimeTableQueryConfig.getDisableGroovy();
      if (disableGroovyRealtimeTableOverride != null) {
        if (disableGroovyOverride == null) {
          disableGroovyOverride = disableGroovyRealtimeTableOverride;
        }
         else {
          disableGroovyOverride |= disableGroovyRealtimeTableOverride;
        }
        
      }
      
      Boolean useApproximateFunctionRealtimeTableOverride = realtimeTableQueryConfig.getUseApproximateFunction();
      if (useApproximateFunctionRealtimeTableOverride != null) {
        if (useApproximateFunctionOverride == null) {
          useApproximateFunctionOverride = useApproximateFunctionRealtimeTableOverride;
        }
         else {
          useApproximateFunctionOverride &= useApproximateFunctionRealtimeTableOverride;
        }
        
      }
      
    }
    
    boolean disableGroovy = disableGroovyOverride != null ? disableGroovyOverride : _disableGroovy;
    boolean useApproximateFunction = useApproximateFunctionOverride != null ? useApproximateFunctionOverride : _useApproximateFunction;
    return new HandlerContext(disableGroovy, useApproximateFunction);
  }
  
  private static class HandlerContext {
    final boolean _disableGroovy;
    final boolean _useApproximateFunction;
    HandlerContext(boolean disableGroovy, boolean useApproximateFunction) {
      _disableGroovy = disableGroovy;
      _useApproximateFunction = useApproximateFunction;
    }
    
  }
  
  @VisibleForTesting
  static void rejectGroovyQuery(PinotQuery pinotQuery) {
    List<Expression> selectList = pinotQuery.getSelectList();
    for (Expression expression : selectList) {
      rejectGroovyQuery(expression);
    }
    
    List<Expression> orderByList = pinotQuery.getOrderByList();
    if (orderByList != null) {
      for (Expression expression : orderByList) {
        rejectGroovyQuery(expression.getFunctionCall().getOperands().get(0));
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      rejectGroovyQuery(havingExpression);
    }
    
    Expression filterExpression = pinotQuery.getFilterExpression();
    if (filterExpression != null) {
      rejectGroovyQuery(filterExpression);
    }
    
    List<Expression> groupByList = pinotQuery.getGroupByList();
    if (groupByList != null) {
      for (Expression expression : groupByList) {
        rejectGroovyQuery(expression);
      }
      
    }
    
  }
  
  private static void rejectGroovyQuery(Expression expression) {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    if (function.getOperator().equals("groovy")) {
      throw new BadQueryRequestException("Groovy transform functions are disabled for queries");
    }
    
    for (Expression operandExpression : function.getOperands()) {
      rejectGroovyQuery(operandExpression);
    }
    
  }
  
  @VisibleForTesting
  static void handleApproximateFunctionOverride(PinotQuery pinotQuery) {
    for (Expression expression : pinotQuery.getSelectList()) {
      handleApproximateFunctionOverride(expression);
    }
    
    List<Expression> orderByExpressions = pinotQuery.getOrderByList();
    if (orderByExpressions != null) {
      for (Expression expression : orderByExpressions) {
        handleApproximateFunctionOverride(expression.getFunctionCall().getOperands().get(0));
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      handleApproximateFunctionOverride(havingExpression);
    }
    
  }
  
  private static void handleApproximateFunctionOverride(Expression expression) {
    Function function = expression.getFunctionCall();
    if (function == null) {
      return;
    }
    
    String functionName = function.getOperator();
    if (functionName.equals("distinctcount") || functionName.equals("distinctcountmv")) {
      function.setOperator("distinctcountsmarthll");
    }
     else if (functionName.startsWith("percentile")) {
      String remainingFunctionName = functionName.substring(10);
      if (remainingFunctionName.isEmpty() || remainingFunctionName.equals("mv")) {
        function.setOperator("percentilesmarttdigest");
      }
       else if (remainingFunctionName.matches("\\d+")) {
        try {
          int percentile = Integer.parseInt(remainingFunctionName);
          function.setOperator("percentilesmarttdigest");
          function.setOperands( Arrays.asList(function.getOperands().get(0), RequestUtils.getLiteralExpression(percentile)));
        }
         catch (Exception e) {
          throw new BadQueryRequestException("Illegal function name: " + functionName);
        }
        
      }
       else if (remainingFunctionName.matches("\\d+mv")) {
        try {
          int percentile = Integer.parseInt(remainingFunctionName.substring(0, remainingFunctionName.length() - 2));
          function.setOperator("percentilesmarttdigest");
          function.setOperands( Arrays.asList(function.getOperands().get(0), RequestUtils.getLiteralExpression(percentile)));
        }
         catch (Exception e) {
          throw new BadQueryRequestException("Illegal function name: " + functionName);
        }
        
      }
      
    }
     else {
      for (Expression operand : function.getOperands()) {
        handleApproximateFunctionOverride(operand);
      }
      
    }
    
  }
  
  private static void handleExpressionOverride(PinotQuery pinotQuery, @Nullable Map<Expression, Expression> expressionOverrideMap) {
    if (expressionOverrideMap == null) {
      return;
    }
    
    pinotQuery.getSelectList().replaceAll(o -> handleExpressionOverride(o, expressionOverrideMap));
    Expression filterExpression = pinotQuery.getFilterExpression();
    if (filterExpression != null) {
      pinotQuery.setFilterExpression(handleExpressionOverride(filterExpression, expressionOverrideMap));
    }
    
    List<Expression> groupByList = pinotQuery.getGroupByList();
    if (groupByList != null) {
      groupByList.replaceAll(o -> handleExpressionOverride(o, expressionOverrideMap));
    }
    
    List<Expression> orderByList = pinotQuery.getOrderByList();
    if (orderByList != null) {
      for (Expression expression : orderByList) {
        expression.getFunctionCall().getOperands().replaceAll(o -> handleExpressionOverride(o, expressionOverrideMap));
      }
      
    }
    
    Expression havingExpression = pinotQuery.getHavingExpression();
    if (havingExpression != null) {
      pinotQuery.setHavingExpression(handleExpressionOverride(havingExpression, expressionOverrideMap));
    }
    
  }
  
  private static Expression handleExpressionOverride(Expression expression, Map<Expression, Expression> expressionOverrideMap) {
    Expression override = expressionOverrideMap.get(expression);
    if (override != null) {
      return new Expression(override);
    }
    
    Function function = expression.getFunctionCall();
    if (function != null) {
      function.getOperands().replaceAll(o -> handleExpressionOverride(o, expressionOverrideMap));
    }
    
    return expression;
  }
  
  @VisibleForTesting
  static boolean isLiteralOnlyQuery(PinotQuery pinotQuery) {
    for (Expression expression : pinotQuery.getSelectList()) {
      if (!CalciteSqlParser.isLiteralOnlyExpression(expression)) {
        return false;
      }
      
    }
    
    return true;
  }
  
  private BrokerResponseNative processLiteralOnlyQuery(PinotQuery pinotQuery, long compilationStartTimeNs, RequestContext requestContext) {
    BrokerResponseNative brokerResponse = new BrokerResponseNative();
    List<String> columnNames = new ArrayList<>();
    List<DataSchema.ColumnDataType> columnTypes = new ArrayList<>();
    List<Object> row = new ArrayList<>();
    for (Expression expression : pinotQuery.getSelectList()) {
      computeResultsForExpression(expression, columnNames, columnTypes, row);
    }
    
    DataSchema dataSchema = new DataSchema(columnNames.toArray(new String[0]), columnTypes.toArray(new DataSchema.ColumnDataType[0]));
    List<Object[]> rows = new ArrayList<>();
    rows.add(row.toArray());
    ResultTable resultTable = new ResultTable(dataSchema, rows);
    brokerResponse.setResultTable(resultTable);
    long totalTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - compilationStartTimeNs);
    brokerResponse.setTimeUsedMs(totalTimeMs);
    requestContext.setQueryProcessingTime(totalTimeMs);
    augmentStatistics(requestContext, brokerResponse);
    return brokerResponse;
  }
  
  private void computeResultsForExpression(Expression e, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes, List<Object> row) {
    if (e.getType() == ExpressionType.LITERAL) {
      computeResultsForLiteral(e.getLiteral(), columnNames, columnTypes, row);
    }
    
    if (e.getType() == ExpressionType.FUNCTION) {
      if (e.getFunctionCall().getOperator().equals("as")) {
        String columnName = e.getFunctionCall().getOperands().get(1).getIdentifier().getName();
        computeResultsForExpression(e.getFunctionCall().getOperands().get(0), columnNames, columnTypes, row);
        columnNames.set(columnNames.size() - 1, columnName);
      }
       else {
        throw new IllegalStateException( "No able to compute results for function - " + e.getFunctionCall().getOperator());
      }
      
    }
    
  }
  
  private void computeResultsForLiteral(Literal literal, List<String> columnNames, List<DataSchema.ColumnDataType> columnTypes, List<Object> row) {
    Object fieldValue = literal.getFieldValue();
    columnNames.add(fieldValue.toString());
    switch (literal.getSetField()) {
      case BOOL_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.BOOLEAN);
        row.add(literal.getBoolValue());
        break;
      case BYTE_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.INT);
        row.add((int) literal.getByteValue());
        break;
      case SHORT_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.INT);
        row.add((int) literal.getShortValue());
        break;
      case INT_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.INT);
        row.add(literal.getIntValue());
        break;
      case LONG_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.LONG);
        row.add(literal.getLongValue());
        break;
      case DOUBLE_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.DOUBLE);
        row.add(literal.getDoubleValue());
        break;
      case STRING_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.STRING);
        row.add(literal.getStringValue());
        break;
      case BINARY_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.BYTES);
        row.add(BytesUtils.toHexString(literal.getBinaryValue()));
        break;
      case NULL_VALUE:
        columnTypes.add(DataSchema.ColumnDataType.UNKNOWN);
        row.add(null);
        break;
      default: break;
    }
    
  }
  
  @VisibleForTesting
  static void updateColumnNames(String rawTableName, PinotQuery pinotQuery, boolean isCaseInsensitive, Map<String, String> columnNameMap) {
    Map<String, String> aliasMap = new HashMap<>();
    if (pinotQuery != null) {
      boolean hasStar = false;
      for (Expression expression : pinotQuery.getSelectList()) {
        fixColumnName(rawTableName, expression, columnNameMap, aliasMap, isCaseInsensitive);
        if (!hasStar && expression.equals(STAR)) {
          hasStar = true;
        }
        
      }
      
      if (hasStar) {
        expandStarExpressionsToActualColumns(pinotQuery, columnNameMap);
      }
      
      Expression filterExpression = pinotQuery.getFilterExpression();
      if (filterExpression != null) {
        fixColumnName(rawTableName, filterExpression, columnNameMap, aliasMap, isCaseInsensitive);
      }
      
      List<Expression> groupByList = pinotQuery.getGroupByList();
      if (groupByList != null) {
        for (Expression expression : groupByList) {
          fixColumnName(rawTableName, expression, columnNameMap, aliasMap, isCaseInsensitive);
        }
        
      }
      
      List<Expression> orderByList = pinotQuery.getOrderByList();
      if (orderByList != null) {
        for (Expression expression : orderByList) {
          fixColumnName(rawTableName, expression.getFunctionCall().getOperands().get(0), columnNameMap, aliasMap, isCaseInsensitive);
        }
        
      }
      
      Expression havingExpression = pinotQuery.getHavingExpression();
      if (havingExpression != null) {
        fixColumnName(rawTableName, havingExpression, columnNameMap, aliasMap, isCaseInsensitive);
      }
      
    }
    
  }
  
  private static void expandStarExpressionsToActualColumns(PinotQuery pinotQuery, Map<String, String> columnNameMap) {
    List<Expression> originalSelections = pinotQuery.getSelectList();
    List<Expression> expandedSelections = new ArrayList<>();
    for (String tableCol : columnNameMap.values()) {
      Expression newSelection = RequestUtils.getIdentifierExpression(tableCol);
      if (tableCol.charAt(0) != '$') {
        expandedSelections.add(newSelection);
      }
      
    }
    
    expandedSelections.sort(null);
    List<Expression> newSelections = new ArrayList<>();
    for (Expression originalSelection : originalSelections) {
      if (originalSelection.equals(STAR)) {
        newSelections.addAll(expandedSelections);
      }
       else {
        newSelections.add(originalSelection);
      }
      
    }
    
    pinotQuery.setSelectList(newSelections);
  }
  
  private static void fixColumnName(String rawTableName, Expression expression, Map<String, String> columnNameMap, Map<String, String> aliasMap, boolean ignoreCase) {
    ExpressionType expressionType = expression.getType();
    if (expressionType == ExpressionType.IDENTIFIER) {
      Identifier identifier = expression.getIdentifier();
      identifier.setName(getActualColumnName(rawTableName, identifier.getName(), columnNameMap, aliasMap, ignoreCase));
    }
     else if (expressionType == ExpressionType.FUNCTION) {
      final Function functionCall = expression.getFunctionCall();
      switch (functionCall.getOperator()) {
        case "as":
          fixColumnName(rawTableName, functionCall.getOperands().get(0), columnNameMap, aliasMap, ignoreCase);
          final Expression rightAsExpr = functionCall.getOperands().get(1);
          if (rightAsExpr.isSetIdentifier()) {
            String rightColumn = rightAsExpr.getIdentifier().getName();
            if (ignoreCase) {
              aliasMap.put(rightColumn.toLowerCase(), rightColumn);
            }
             else {
              aliasMap.put(rightColumn, rightColumn);
            }
            
          }
          
          break;
        case "lookup":
          break;
        default: for (Expression operand : functionCall.getOperands()) {
            fixColumnName(rawTableName, operand, columnNameMap, aliasMap, ignoreCase);
          }
          
          break;
      }
      
    }
    
  }
  
  @VisibleForTesting
  static String getActualColumnName(String rawTableName, String columnName, @Nullable Map<String, String> columnNameMap, @Nullable Map<String, String> aliasMap, boolean ignoreCase) {
    if ("*".equals(columnName)) {
      return columnName;
    }
    
    String columnNameToCheck;
    if (columnName.regionMatches(ignoreCase, 0, rawTableName, 0, rawTableName.length()) && columnName.length() > rawTableName.length() && columnName.charAt(rawTableName.length()) == '.') {
      columnNameToCheck = ignoreCase ? columnName.substring(rawTableName.length() + 1).toLowerCase() : columnName.substring(rawTableName.length() + 1);
    }
     else {
      columnNameToCheck = ignoreCase ? columnName.toLowerCase() : columnName;
    }
    
    if (columnNameMap != null) {
      String actualColumnName = columnNameMap.get(columnNameToCheck);
      if (actualColumnName != null) {
        return actualColumnName;
      }
      
    }
    
    if (aliasMap != null) {
      String actualAlias = aliasMap.get(columnNameToCheck);
      if (actualAlias != null) {
        return actualAlias;
      }
      
    }
    
    if (columnName.charAt(0) == '$') {
      return columnName;
    }
    
    throw new BadQueryRequestException("Unknown columnName '" + columnName + "' found in the query");
  }
  
  private boolean forceLog(BrokerResponse brokerResponse, long totalTimeMs) {
    if (brokerResponse.isNumGroupsLimitReached()) {
      return true;
    }
    
    if (brokerResponse.getExceptionsSize() > 0) {
      return true;
    }
    
    return totalTimeMs > 1000L;
  }
  
  private long setQueryTimeout(String tableNameWithType, Map<String, String> queryOptions, long timeSpentMs) throws TimeoutException {
    long queryTimeoutMs;
    Long queryLevelTimeoutMs = QueryOptionsUtils.getTimeoutMs(queryOptions);
    if (queryLevelTimeoutMs != null) {
      queryTimeoutMs = queryLevelTimeoutMs;
    }
     else {
      Long tableLevelTimeoutMs = _routingManager.getQueryTimeoutMs(tableNameWithType);
      if (tableLevelTimeoutMs != null) {
        queryTimeoutMs = tableLevelTimeoutMs;
      }
       else {
        queryTimeoutMs = _brokerTimeoutMs;
      }
      
    }
    
    long remainingTimeMs = queryTimeoutMs - timeSpentMs;
    if (remainingTimeMs <= 0) {
      String errorMessage = String.format("Query timed out (time spent: %dms, timeout: %dms) for table: %s before scattering the request", timeSpentMs, queryTimeoutMs, tableNameWithType);
      throw new TimeoutException(errorMessage);
    }
    
    queryOptions.put(Broker.Request.QueryOptionKey.TIMEOUT_MS, Long.toString(remainingTimeMs));
    return remainingTimeMs;
  }
  
  @VisibleForTesting
  static void validateRequest(PinotQuery pinotQuery, int queryResponseLimit) {
    int limit = pinotQuery.getLimit();
    if (limit > queryResponseLimit) {
      throw new IllegalStateException( "Value for 'LIMIT' (" + limit + ") exceeds maximum allowed value of " + queryResponseLimit);
    }
    
    Map<String, String> queryOptions = pinotQuery.getQueryOptions();
    try {
      Integer numReplicaGroupsToQuery = QueryOptionsUtils.getNumReplicaGroupsToQuery(queryOptions);
      if (numReplicaGroupsToQuery != null) {
        Preconditions.checkState(numReplicaGroupsToQuery > 0, "numReplicaGroups must be " + "positive number, got: %d", numReplicaGroupsToQuery);
      }
      
    }
     catch (NumberFormatException e) {
      String numReplicaGroupsToQuery = queryOptions.get(Broker.Request.QueryOptionKey.NUM_REPLICA_GROUPS_TO_QUERY);
      throw new IllegalStateException( String.format("numReplicaGroups must be a positive number, got: %s", numReplicaGroupsToQuery));
    }
    
    if (pinotQuery.getDataSource().getSubquery() != null) {
      validateRequest(pinotQuery.getDataSource().getSubquery(), queryResponseLimit);
    }
    
  }
  
  private static void attachTimeBoundary(PinotQuery pinotQuery, TimeBoundaryInfo timeBoundaryInfo, boolean isOfflineRequest) {
    String timeColumn = timeBoundaryInfo.getTimeColumn();
    String timeValue = timeBoundaryInfo.getTimeValue();
    Expression timeFilterExpression = RequestUtils.getFunctionExpression( isOfflineRequest ? FilterKind.LESS_THAN_OR_EQUAL.name() : FilterKind.GREATER_THAN.name());
    timeFilterExpression.getFunctionCall().setOperands( Arrays.asList(RequestUtils.getIdentifierExpression(timeColumn), RequestUtils.getLiteralExpression(timeValue)));
    Expression filterExpression = pinotQuery.getFilterExpression();
    if (filterExpression != null) {
      Expression andFilterExpression = RequestUtils.getFunctionExpression(FilterKind.AND.name());
      andFilterExpression.getFunctionCall().setOperands(Arrays.asList(filterExpression, timeFilterExpression));
      pinotQuery.setFilterExpression(andFilterExpression);
    }
     else {
      pinotQuery.setFilterExpression(timeFilterExpression);
    }
    
  }
  
  protected abstract BrokerResponseNative processBrokerRequest(long requestId, BrokerRequest originalBrokerRequest, BrokerRequest serverBrokerRequest, @Nullable BrokerRequest offlineBrokerRequest, @Nullable Map<ServerInstance, List<String>> offlineRoutingTable, @Nullable BrokerRequest realtimeBrokerRequest, @Nullable Map<ServerInstance, List<String>> realtimeRoutingTable, long timeoutMs, ServerStats serverStats, RequestContext requestContext) throws Exception;
  protected static void augmentStatistics(RequestContext statistics, BrokerResponse response) {
    statistics.setTotalDocs(response.getTotalDocs());
    statistics.setNumDocsScanned(response.getNumDocsScanned());
    statistics.setNumEntriesScannedInFilter(response.getNumEntriesScannedInFilter());
    statistics.setNumEntriesScannedPostFilter(response.getNumEntriesScannedPostFilter());
    statistics.setNumSegmentsQueried(response.getNumSegmentsQueried());
    statistics.setNumSegmentsProcessed(response.getNumSegmentsProcessed());
    statistics.setNumSegmentsMatched(response.getNumSegmentsMatched());
    statistics.setNumServersQueried(response.getNumServersQueried());
    statistics.setNumSegmentsProcessed(response.getNumSegmentsProcessed());
    statistics.setNumServersResponded(response.getNumServersResponded());
    statistics.setNumGroupsLimitReached(response.isNumGroupsLimitReached());
    statistics.setNumExceptions(response.getExceptionsSize());
    statistics.setOfflineThreadCpuTimeNs(response.getOfflineThreadCpuTimeNs());
    statistics.setRealtimeThreadCpuTimeNs(response.getRealtimeThreadCpuTimeNs());
    statistics.setOfflineSystemActivitiesCpuTimeNs(response.getOfflineSystemActivitiesCpuTimeNs());
    statistics.setRealtimeSystemActivitiesCpuTimeNs(response.getRealtimeSystemActivitiesCpuTimeNs());
    statistics.setOfflineResponseSerializationCpuTimeNs(response.getOfflineResponseSerializationCpuTimeNs());
    statistics.setRealtimeResponseSerializationCpuTimeNs(response.getRealtimeResponseSerializationCpuTimeNs());
    statistics.setOfflineTotalCpuTimeNs(response.getOfflineTotalCpuTimeNs());
    statistics.setRealtimeTotalCpuTimeNs(response.getRealtimeTotalCpuTimeNs());
    statistics.setNumRowsResultSet(response.getNumRowsResultSet());
  }
  
  private String getGlobalQueryId(long requestId) {
    return _brokerId + "_" + requestId;
  }
  
  public static class ServerStats {
    private String _serverStats;
    public String getServerStats() {
      return _serverStats;
    }
    
    public void setServerStats(String serverStats) {
      _serverStats = serverStats;
    }
    
  }
  
  private static class QueryServers {
    final String _query;
    final Set<ServerInstance> _servers = new HashSet<>();
    QueryServers(String query, @Nullable Map<ServerInstance, List<String>> offlineRoutingTable, @Nullable Map<ServerInstance, List<String>> realtimeRoutingTable) {
      _query = query;
      if (offlineRoutingTable != null) {
        _servers.addAll(offlineRoutingTable.keySet());
      }
      
      if (realtimeRoutingTable != null) {
        _servers.addAll(realtimeRoutingTable.keySet());
      }
      
    }
    
  }
  
}


