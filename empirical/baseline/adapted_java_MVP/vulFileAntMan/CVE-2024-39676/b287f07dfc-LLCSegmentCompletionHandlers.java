package org.apache.pinot.controller.api.resources;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.file.Files;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import org.apache.commons.io.FileUtils;
import org.apache.pinot.common.metrics.ControllerGauge;
import org.apache.pinot.common.protocols.SegmentCompletionProtocol;
import org.apache.pinot.common.utils.LLCSegmentName;
import org.apache.pinot.common.utils.TarGzCompressionUtils;
import org.apache.pinot.common.utils.URIUtils;
import org.apache.pinot.common.utils.fetcher.SegmentFetcherFactory;
import org.apache.pinot.controller.api.access.AccessType;
import org.apache.pinot.controller.api.access.Authenticate;
import org.apache.pinot.controller.helix.core.realtime.SegmentCompletionManager;
import org.apache.pinot.controller.helix.core.realtime.segment.CommittingSegmentDescriptor;
import org.apache.pinot.controller.util.SegmentCompletionUtils;
import org.apache.pinot.segment.spi.V1Constants;
import org.apache.pinot.segment.spi.index.metadata.SegmentMetadataImpl;
import org.apache.pinot.spi.filesystem.PinotFS;
import org.apache.pinot.spi.filesystem.PinotFSFactory;
import org.glassfish.jersey.media.multipart.FormDataBodyPart;
import org.glassfish.jersey.media.multipart.FormDataMultiPart;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class LLCSegmentCompletionHandlers {
  private static final Logger LOGGER = LoggerFactory.getLogger(LLCSegmentCompletionHandlers.class);
  private static final Object SEGMENT_UPLOAD_LOCK = new Object();
  private static final String SCHEME = "file://";
  @Inject
  SegmentCompletionManager _segmentCompletionManager;
  public static String getScheme() {
    return SCHEME;
  }
  
  public String extendBuildTime(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_EXTRA_TIME_SEC) int extraTimeSec) {
    if (instanceId == null || segmentName == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error("Invalid call: offset={}, segmentName={}, instanceId={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, streamPartitionMsgOffset);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    if (extraTimeSec <= 0) {
      LOGGER.warn("Invalid value {} for extra build time from instance {} for segment {}", extraTimeSec, instanceId, segmentName);
      extraTimeSec = SegmentCompletionProtocol.getDefaultMaxSegmentCommitTimeSeconds();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withExtraTimeSec(extraTimeSec);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing extendBuildTime:{}", requestParams.toString());
    SegmentCompletionProtocol.Response response = _segmentCompletionManager.extendBuildTime(requestParams);
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to extendBuildTime:{}", responseStr);
    return responseStr;
  }
  
  private void extractOffsetFromParams(SegmentCompletionProtocol.Request.Params requestParams, String streamPartitionMsgOffset, long offset) {
    if (streamPartitionMsgOffset != null) {
      requestParams.withStreamPartitionMsgOffset(streamPartitionMsgOffset);
    }
     else {
      requestParams.withStreamPartitionMsgOffset(Long.toString(offset));
    }
    
  }
  
  public String segmentConsumed(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_REASON) String stopReason, @QueryParam(SegmentCompletionProtocol.PARAM_MEMORY_USED_BYTES) long memoryUsedBytes, @QueryParam(SegmentCompletionProtocol.PARAM_ROW_COUNT) int numRows) {
    if (instanceId == null || segmentName == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error("Invalid call: offset={}, segmentName={}, instanceId={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, streamPartitionMsgOffset);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withReason(stopReason) .withMemoryUsedBytes(memoryUsedBytes).withNumRows(numRows);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentConsumed:{}", requestParams.toString());
    SegmentCompletionProtocol.Response response = _segmentCompletionManager.segmentConsumed(requestParams);
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to segmentConsumed for segment:{} is :{}", segmentName, responseStr);
    return responseStr;
  }
  
  public String segmentStoppedConsuming(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_REASON) String stopReason) {
    if (instanceId == null || segmentName == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error("Invalid call: offset={}, segmentName={}, instanceId={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, streamPartitionMsgOffset);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withReason(stopReason);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentStoppedConsuming:{}", requestParams.toString());
    SegmentCompletionProtocol.Response response = _segmentCompletionManager.segmentStoppedConsuming(requestParams);
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to segmentStoppedConsuming for segment:{} is:{}", segmentName, responseStr);
    return responseStr;
  }
  
  public String segmentCommitStart(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_MEMORY_USED_BYTES) long memoryUsedBytes, @QueryParam(SegmentCompletionProtocol.PARAM_BUILD_TIME_MILLIS) long buildTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_WAIT_TIME_MILLIS) long waitTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_ROW_COUNT) int numRows, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_SIZE_BYTES) long segmentSizeBytes) {
    if (instanceId == null || segmentName == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error("Invalid call: offset={}, segmentName={}, instanceId={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, streamPartitionMsgOffset);
      LOGGER.error("Invalid call: offset={}, segmentName={}, instanceId={}", offset, segmentName, instanceId);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withMemoryUsedBytes(memoryUsedBytes) .withBuildTimeMillis(buildTimeMillis).withWaitTimeMillis(waitTimeMillis).withNumRows(numRows) .withSegmentSizeBytes(segmentSizeBytes);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentCommitStart:{}", requestParams.toString());
    SegmentCompletionProtocol.Response response = _segmentCompletionManager.segmentCommitStart(requestParams);
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to segmentCommitStart for segment:{} is:{}", segmentName, responseStr);
    return responseStr;
  }
  
  public String segmentCommitEnd(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_LOCATION) String segmentLocation, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_MEMORY_USED_BYTES) long memoryUsedBytes, @QueryParam(SegmentCompletionProtocol.PARAM_BUILD_TIME_MILLIS) long buildTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_WAIT_TIME_MILLIS) long waitTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_ROW_COUNT) int numRows, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_SIZE_BYTES) long segmentSizeBytes) {
    if (instanceId == null || segmentName == null || segmentLocation == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error( "Invalid call: offset={}, segmentName={}, instanceId={}, segmentLocation={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, segmentLocation, streamPartitionMsgOffset);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentMetadataImpl segmentMetadata;
    try {
      segmentMetadata = extractMetadataFromSegmentFileURI(new URI(segmentLocation), segmentName);
    }
     catch (Exception e) {
      LOGGER.error("Caught exception while extracting metadata from segment: {} at location: {} from instance: {}", segmentName, segmentLocation, instanceId, e);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withSegmentLocation(segmentLocation) .withSegmentSizeBytes(segmentSizeBytes).withBuildTimeMillis(buildTimeMillis).withWaitTimeMillis(waitTimeMillis) .withNumRows(numRows).withMemoryUsedBytes(memoryUsedBytes);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentCommitEnd:{}", requestParams.toString());
    final boolean isSuccess = true;
    final boolean isSplitCommit = true;
    CommittingSegmentDescriptor committingSegmentDescriptor = CommittingSegmentDescriptor.fromSegmentCompletionReqParamsAndMetadata(requestParams, segmentMetadata);
    SegmentCompletionProtocol.Response response = _segmentCompletionManager .segmentCommitEnd(requestParams, isSuccess, isSplitCommit, committingSegmentDescriptor);
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to segmentCommitEnd for segment:{} is:{}", segmentName, responseStr);
    return responseStr;
  }
  
  public String segmentCommit(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_MEMORY_USED_BYTES) long memoryUsedBytes, @QueryParam(SegmentCompletionProtocol.PARAM_BUILD_TIME_MILLIS) long buildTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_WAIT_TIME_MILLIS) long waitTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_SIZE_BYTES) long segmentSizeBytes, @QueryParam(SegmentCompletionProtocol.PARAM_ROW_COUNT) int numRows, FormDataMultiPart multiPart) {
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withSegmentSizeBytes(segmentSizeBytes) .withBuildTimeMillis(buildTimeMillis).withWaitTimeMillis(waitTimeMillis).withNumRows(numRows) .withMemoryUsedBytes(memoryUsedBytes);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentCommit:{}", requestParams.toString());
    final SegmentCompletionManager segmentCompletionManager = _segmentCompletionManager;
    SegmentCompletionProtocol.Response response = segmentCompletionManager.segmentCommitStart(requestParams);
    CommittingSegmentDescriptor committingSegmentDescriptor = CommittingSegmentDescriptor.fromSegmentCompletionReqParams(requestParams);
    boolean success = false;
    if (response.equals(SegmentCompletionProtocol.RESP_COMMIT_CONTINUE)) {
      File localTempFile = null;
      try {
        localTempFile = extractSegmentFromFormToLocalTempFile(multiPart, segmentName);
        SegmentMetadataImpl segmentMetadata = extractMetadataFromLocalSegmentFile(localTempFile);
        String rawTableName = new LLCSegmentName(segmentName).getTableName();
        URI segmentFileURI = URIUtils .getUri(ControllerFilePathProvider.getInstance().getDataDirURI().toString(), rawTableName, URIUtils.encode(segmentName));
        PinotFS pinotFS = PinotFSFactory.create(segmentFileURI.getScheme());
        synchronized (SEGMENT_UPLOAD_LOCK) {
          if (pinotFS.exists(segmentFileURI)) {
            LOGGER.warn("Segment file: {} already exists. Replacing it with segment: {} from instance: {}", segmentFileURI, segmentName, instanceId);
            pinotFS.delete(segmentFileURI, true);
          }
          
          pinotFS.copyFromLocalFile(localTempFile, segmentFileURI);
        }
        
        committingSegmentDescriptor = CommittingSegmentDescriptor.fromSegmentCompletionReqParamsAndMetadata(requestParams, segmentMetadata);
        committingSegmentDescriptor.setSegmentLocation(segmentFileURI.toString());
        success = true;
      }
       catch (Exception e) {
        LOGGER.error("Caught exception while committing segment: {} from instance: {}", segmentName, instanceId, e);
      }
       finally {
        FileUtils.deleteQuietly(localTempFile);
      }
      
    }
    
    response = segmentCompletionManager.segmentCommitEnd(requestParams, success, false, committingSegmentDescriptor);
    LOGGER.info("Response to segmentCommit: instance={}  segment={} status={} offset={}, streamMsgOffset={}", requestParams.getInstanceId(), requestParams.getSegmentName(), response.getStatus(), response.getOffset(), response.getStreamPartitionMsgOffset());
    return response.toJsonString();
  }
  
  @TrackedByGauge(gauge = ControllerGauge.SEGMENT_UPLOADS_IN_PROGRESS)
  public String segmentUpload(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, FormDataMultiPart multiPart) {
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentUpload:{}", requestParams.toString());
    File localTempFile = null;
    try {
      localTempFile = extractSegmentFromFormToLocalTempFile(multiPart, segmentName);
      String rawTableName = new LLCSegmentName(segmentName).getTableName();
      URI segmentFileURI = URIUtils .getUri(ControllerFilePathProvider.getInstance().getDataDirURI().toString(), rawTableName, URIUtils.encode(SegmentCompletionUtils.generateSegmentFileName(segmentName)));
      PinotFSFactory.create(segmentFileURI.getScheme()).copyFromLocalFile(localTempFile, segmentFileURI);
      SegmentCompletionProtocol.Response.Params responseParams = new SegmentCompletionProtocol.Response.Params() .withStreamPartitionMsgOffset(requestParams.getStreamPartitionMsgOffset()) .withSegmentLocation(segmentFileURI.toString()) .withStatus(SegmentCompletionProtocol.ControllerResponseStatus.UPLOAD_SUCCESS);
      String response = new SegmentCompletionProtocol.Response(responseParams).toJsonString();
      LOGGER.info("Response to segmentUpload for segment:{} is:{}", segmentName, response);
      return response;
    }
     catch (Exception e) {
      LOGGER.error("Caught exception while uploading segment: {} from instance: {}", segmentName, instanceId, e);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
     finally {
      FileUtils.deleteQuietly(localTempFile);
    }
    
  }
  
  public String segmentCommitEndWithMetadata(@QueryParam(SegmentCompletionProtocol.PARAM_INSTANCE_ID) String instanceId, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_NAME) String segmentName, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_LOCATION) String segmentLocation, @QueryParam(SegmentCompletionProtocol.PARAM_OFFSET) long offset, @QueryParam(SegmentCompletionProtocol.PARAM_STREAM_PARTITION_MSG_OFFSET) String streamPartitionMsgOffset, @QueryParam(SegmentCompletionProtocol.PARAM_MEMORY_USED_BYTES) long memoryUsedBytes, @QueryParam(SegmentCompletionProtocol.PARAM_BUILD_TIME_MILLIS) long buildTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_WAIT_TIME_MILLIS) long waitTimeMillis, @QueryParam(SegmentCompletionProtocol.PARAM_ROW_COUNT) int numRows, @QueryParam(SegmentCompletionProtocol.PARAM_SEGMENT_SIZE_BYTES) long segmentSizeBytes, FormDataMultiPart metadataFiles) {
    if (instanceId == null || segmentName == null || segmentLocation == null || metadataFiles == null || (offset == -1 && streamPartitionMsgOffset == null)) {
      LOGGER.error( "Invalid call: offset={}, segmentName={}, instanceId={}, segmentLocation={}, streamPartitionMsgOffset={}", offset, segmentName, instanceId, segmentLocation, streamPartitionMsgOffset);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    SegmentCompletionProtocol.Request.Params requestParams = new SegmentCompletionProtocol.Request.Params();
    requestParams.withInstanceId(instanceId).withSegmentName(segmentName).withSegmentLocation(segmentLocation) .withSegmentSizeBytes(segmentSizeBytes).withBuildTimeMillis(buildTimeMillis).withWaitTimeMillis(waitTimeMillis) .withNumRows(numRows).withMemoryUsedBytes(memoryUsedBytes);
    extractOffsetFromParams(requestParams, streamPartitionMsgOffset, offset);
    LOGGER.info("Processing segmentCommitEndWithMetadata:{}", requestParams.toString());
    SegmentMetadataImpl segmentMetadata;
    try {
      segmentMetadata = extractSegmentMetadataFromForm(metadataFiles, segmentName);
    }
     catch (Exception e) {
      LOGGER.error("Caught exception while extracting metadata for segment: {} from instance: {}", segmentName, instanceId, e);
      return SegmentCompletionProtocol.RESP_FAILED.toJsonString();
    }
    
    final boolean isSuccess = true;
    final boolean isSplitCommit = true;
    SegmentCompletionProtocol.Response response = _segmentCompletionManager .segmentCommitEnd(requestParams, isSuccess, isSplitCommit, CommittingSegmentDescriptor.fromSegmentCompletionReqParamsAndMetadata(requestParams, segmentMetadata));
    final String responseStr = response.toJsonString();
    LOGGER.info("Response to segmentCommitEndWithMetadata for segment:{} is:{}", segmentName, responseStr);
    return responseStr;
  }
  
  private static File extractSegmentFromFormToLocalTempFile(FormDataMultiPart form, String segmentName) throws IOException {
    try {
      Map<String, List<FormDataBodyPart>> map = form.getFields();
      Preconditions.checkState(PinotSegmentUploadDownloadRestletResource.validateMultiPart(map, segmentName), "Invalid multi-part for segment: %s", segmentName);
      FormDataBodyPart bodyPart = map.values().iterator().next().get(0);
      File localTempFile = org.apache.pinot.common.utils.FileUtils.concatAndValidateFile( ControllerFilePathProvider.getInstance().getFileUploadTempDir(), getTempSegmentFileName(segmentName), "Invalid segment name: %s", segmentName);
      try (InputStream inputStream = bodyPart.getValueAs(InputStream.class)) {
        Files.copy(inputStream, localTempFile.toPath());
      }
       catch (Exception e) {
        FileUtils.deleteQuietly(localTempFile);
        throw e;
      }
      
      return localTempFile;
    }
     finally {
      form.cleanup();
    }
    
  }
  
  private static SegmentMetadataImpl extractMetadataFromLocalSegmentFile(File segmentFile) throws Exception {
    File tempIndexDir = org.apache.pinot.common.utils.FileUtils.concatAndValidateFile( ControllerFilePathProvider.getInstance().getUntarredFileTempDir(), segmentFile.getName(), "Invalid segment file: %s", segmentFile);
    try {
      FileUtils.forceMkdir(tempIndexDir);
      TarGzCompressionUtils.untarOneFile(segmentFile, V1Constants.MetadataKeys.METADATA_FILE_NAME, new File(tempIndexDir, V1Constants.MetadataKeys.METADATA_FILE_NAME));
      TarGzCompressionUtils.untarOneFile(segmentFile, V1Constants.SEGMENT_CREATION_META, new File(tempIndexDir, V1Constants.SEGMENT_CREATION_META));
      return new SegmentMetadataImpl(tempIndexDir);
    }
     finally {
      FileUtils.deleteQuietly(tempIndexDir);
    }
    
  }
  
  private static SegmentMetadataImpl extractSegmentMetadataFromForm(FormDataMultiPart form, String segmentName) throws IOException {
    File tempIndexDir = org.apache.pinot.common.utils.FileUtils.concatAndValidateFile( ControllerFilePathProvider.getInstance().getUntarredFileTempDir(), getTempSegmentFileName(segmentName), "Invalid segment name: %s", segmentName);
    try {
      FileUtils.forceMkdir(tempIndexDir);
      extractFileFromForm(form, V1Constants.MetadataKeys.METADATA_FILE_NAME, tempIndexDir);
      extractFileFromForm(form, V1Constants.SEGMENT_CREATION_META, tempIndexDir);
      return new SegmentMetadataImpl(tempIndexDir);
    }
     finally {
      FileUtils.deleteQuietly(tempIndexDir);
    }
    
  }
  
  private static void extractFileFromForm(FormDataMultiPart form, String fileName, File outputDir) throws IOException {
    FormDataBodyPart bodyPart = form.getField(fileName);
    Preconditions.checkState(bodyPart != null, "Failed to find: %s", fileName);
    try (InputStream inputStream = bodyPart.getValueAs(InputStream.class)) {
      Files.copy(inputStream, new File(outputDir, fileName).toPath());
    }
    
  }
  
  private static SegmentMetadataImpl extractMetadataFromSegmentFileURI(URI segmentFileURI, String segmentName) throws Exception {
    File localTempFile = org.apache.pinot.common.utils.FileUtils.concatAndValidateFile( ControllerFilePathProvider.getInstance().getFileUploadTempDir(), getTempSegmentFileName(segmentName), "Invalid segment name: %s", segmentName);
    try {
      SegmentFetcherFactory.fetchSegmentToLocal(segmentFileURI, localTempFile);
      return extractMetadataFromLocalSegmentFile(localTempFile);
    }
     finally {
      FileUtils.deleteQuietly(localTempFile);
    }
    
  }
  
  private static String getTempSegmentFileName(String segmentName) {
    return segmentName + "." + UUID.randomUUID();
  }
  
}


