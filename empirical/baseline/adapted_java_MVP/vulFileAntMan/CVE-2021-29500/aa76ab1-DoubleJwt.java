package cn.fxbin.bubble.plugin.token;
import cn.fxbin.bubble.fireworks.core.util.*;
import cn.fxbin.bubble.fireworks.core.util.time.DateUtils;
import cn.fxbin.bubble.plugin.token.constant.TokenConstants;
import cn.fxbin.bubble.plugin.token.exception.InvalidClaimException;
import cn.fxbin.bubble.plugin.token.exception.TokenExpiredException;
import cn.fxbin.bubble.plugin.token.model.TokenPayload;
import cn.fxbin.bubble.plugin.token.model.Tokens;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import java.security.Key;
import java.util.Date;
import java.util.Map;
public class DoubleJwt {
    private long accessExpire;
    private long refreshExpire;
    private SignatureAlgorithm algorithm;
    private Key key;
    private String secret;
    public DoubleJwt(long accessExpire, long refreshExpire, SignatureAlgorithm algorithm, Key key, String secret) {
        this.accessExpire = accessExpire;
        this.refreshExpire = refreshExpire;
        this.algorithm = algorithm;
        this.key = key;
        this.secret = secret;
    }
    
    public DoubleJwt(long accessExpire, long refreshExpire, SignatureAlgorithm algorithm, String secret) {
        this.accessExpire = accessExpire;
        this.refreshExpire = refreshExpire;
        this.algorithm = algorithm;
        this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret));
    }
    
    public DoubleJwt(long accessExpire, long refreshExpire, String secret) {
        this.accessExpire = accessExpire;
        this.refreshExpire = refreshExpire;
        this.algorithm = SignatureAlgorithm.HS512;
        this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret));
    }
    
    public String generateToken(String tokenType, String identity, String scope, long expire) {
        TokenPayload claims = TokenPayload.builder() .type(tokenType) .identity(identity) .scope(scope) .build();
        return generateToken(claims, expire);
    }
    
    public String generateToken(String tokenType, long identity, String scope, long expire) {
        TokenPayload claims = TokenPayload.builder() .type(tokenType) .identity(String.valueOf(identity)) .scope(scope) .build();
        return generateToken(claims, expire);
    }
    
    public String generateToken(String tokenType, long identity, String scope, long expire, Map<String, Object> extra) {
        return generateToken(tokenType, String.valueOf(identity), scope, expire, extra);
    }
    
    public String generateToken(String tokenType, String identity, String scope, long expire, Map<String, Object> extra) {
        TokenPayload claims = TokenPayload.builder() .type(tokenType) .identity(identity) .scope(scope) .extra(extra) .build();
        return generateToken(claims, expire);
    }
    
    public String generateToken(TokenPayload tokenPayload, long expire) {
        Map<String, Object> extra = tokenPayload.getExtra();
        tokenPayload.setExtra(null);
        Map<String, Object> claims = BeanUtils.object2Map(tokenPayload);
        if (CollectionUtils.isNotEmpty(extra)) {
            extra.keySet().stream().filter(key -> ObjectUtils.isNotEmpty(extra.get(key))) .forEach(key -> claims.put(key, extra.get(key)));
        }
        
        Date now = DateUtils.toDate(SystemClock.INSTANCE.currentTimeMillis());
        Date expireDate = DateUtils.toDate(now.getTime() + expire * 1000);
        return Jwts.builder() .setId(StringUtils.getUUID()) .setHeaderParam("typ", "JWT") .setSubject(String.valueOf(tokenPayload.getIdentity())) .setClaims(claims) .setIssuedAt(now) .setExpiration(expireDate) .signWith(key, algorithm) .compact();
    }
    
    public TokenPayload parseToken(String token) {
        Map<String, Object> mapObj = (Map<String, Object>) Jwts.parserBuilder() .setSigningKey(key) .build() .parse(token) .getBody();
        TokenPayload payload = BeanUtils.map2Object(mapObj, TokenPayload.class);
        checkTokenExpired(payload.getExp());
        return payload;
    }
    
    public TokenPayload parseAccessToken(String token) {
        return this.parseAccessToken(token, TokenConstants.BUBBLE_FIREWORKS_SCOPE);
    }
    
    public TokenPayload parseAccessToken(String token, String scope) {
        TokenPayload payload = parseToken(token);
        checkTokenScope(payload.getScope(), scope);
        checkTokenType(payload.getType(), TokenConstants.ACCESS_TYPE);
        return payload;
    }
    
    public TokenPayload parseRefreshToken(String token) {
       return this.parseRefreshToken(token, TokenConstants.BUBBLE_FIREWORKS_SCOPE);
    }
    
    public TokenPayload parseRefreshToken(String token, String scope) {
        TokenPayload payload = parseToken(token);
        checkTokenScope(payload.getScope(), scope);
        checkTokenType(payload.getType(), TokenConstants.REFRESH_TYPE);
        return payload;
    }
    
    private void checkTokenExpired(Integer exp) {
        long nowSeconds = SystemClock.INSTANCE.currentTimeMillis() / 1000;
        if (nowSeconds > exp.longValue()) {
            throw new TokenExpiredException("token is expired");
        }
        
    }
    
    private void checkTokenScope(String scope, String certScope) {
        if (scope == null || !scope.equals(certScope)) {
            throw new InvalidClaimException("token scope is invalid");
        }
        
    }
    
    private void checkTokenType(String type, String accessType) {
        if (type == null || !type.equals(accessType)) {
            throw new InvalidClaimException("token type is invalid");
        }
        
    }
    
    public String generateAccessToken(long identity) {
        return generateToken(TokenConstants.ACCESS_TYPE, identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE, this.accessExpire);
    }
    
    public String generateAccessToken(String identity) {
        return generateToken(TokenConstants.ACCESS_TYPE, identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE, this.accessExpire);
    }
    
    public String generateRefreshToken(long identity) {
        return generateToken(TokenConstants.REFRESH_TYPE, identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE, this.refreshExpire);
    }
    
    public String generateRefreshToken(String identity) {
        return generateToken(TokenConstants.REFRESH_TYPE, identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE, this.refreshExpire);
    }
    
    public Tokens generateTokens(long identity) {
        return this.generateTokens(String.valueOf(identity));
    }
    
    public Tokens generateTokens(String identity) {
        return this.generateTokens(identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE);
    }
    
    public Tokens generateTokens(long identity, String scope) {
        return this.generateTokens(String.valueOf(identity), scope, null);
    }
    
    public Tokens generateTokens(String identity, String scope) {
        return this.generateTokens(identity, scope, null);
    }
    
    public Tokens generateTokens(long identity, Map<String, Object> extra) {
        return this.generateTokens(String.valueOf(identity), TokenConstants.BUBBLE_FIREWORKS_SCOPE, extra);
    }
    
    public Tokens generateTokens(String identity, Map<String, Object> extra) {
        return this.generateTokens(identity, TokenConstants.BUBBLE_FIREWORKS_SCOPE, extra);
    }
    
    public Tokens generateTokens(String identity, String scope, Map<String, Object> extra) {
        String access = this.generateToken(TokenConstants.ACCESS_TYPE, identity, scope, this.accessExpire, extra);
        String refresh = this.generateToken(TokenConstants.REFRESH_TYPE, identity, scope, this.refreshExpire, extra);
        return new Tokens(access, refresh);
    }
    
    public SignatureAlgorithm getAlgorithm() {
        return algorithm;
    }
    
    public Key getKey() {
        return key;
    }
    
}


