package org.silverpeas.core.web.filter;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.silverpeas.core.admin.user.model.User;
import org.silverpeas.core.cache.service.CacheAccessorProvider;
import org.silverpeas.core.persistence.jdbc.DBUtil;
import org.silverpeas.kernel.util.StringUtil;
import org.silverpeas.core.util.URLUtil;
import org.silverpeas.kernel.logging.SilverLogger;
import org.silverpeas.core.util.security.SecuritySettings;
import org.silverpeas.core.web.SilverpeasWebResource;
import org.silverpeas.core.web.filter.exception.WebSecurityException;
import org.silverpeas.core.web.filter.exception.WebSqlInjectionSecurityException;
import org.silverpeas.core.web.filter.exception.WebXssInjectionSecurityException;
import org.silverpeas.core.web.http.HttpRequest;
import org.silverpeas.core.jcr.webdav.WebDavProtocol;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.core.UriBuilder;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import static java.util.Optional.ofNullable;
import static org.silverpeas.core.util.URLUtil.getCurrentServerURL;
public class MassiveWebSecurityFilter implements Filter {
  private static final SilverLogger logger = SilverLogger.getLogger("silverpeas.core.security");
  private static final String WEB_SERVICES_URI_PREFIX = SilverpeasWebResource.getBasePathBuilder().build().toString();
  private static final String WEB_PAGES_URI_PREFIX = UriBuilder.fromUri(URLUtil.getApplicationURL()).path("RwebPages").build().toString();
  private static final String CMIS_URI_PREFIX = UriBuilder.fromPath(URLUtil.getApplicationURL()).path("cmis").build().toString();
  private static final List<Pattern> SQL_SKIPPED_PARAMETER_PATTERNS;
  private static final List<Pattern> XSS_SKIPPED_PARAMETER_PATTERNS;
  private static final List<Pattern> SQL_PATTERNS;
  private static final List<Pattern> XSS_PATTERNS;
  private static final Pattern ENDS_WITH_WORD_CHARACTER_OR_NUMERIC_PATTERN = Pattern.compile("(?ui)[a-z\\d\\-_éèçàëäüïöâêûîôµù]$");
  private static final Pattern SQL_SELECT_FROM_PATTERN = Pattern.compile("(?i)select.*from");
  private static final Pattern SQL_INSERT_VALUES_PATTERN = Pattern.compile("(?i)insert( .*|.* )into.*values");
  private static final Pattern SQL_UPDATE_PATTERN = Pattern.compile("(?i)update.*set");
  private static final Pattern SQL_DELETE_PATTERN = Pattern.compile("(?i)delete( .*|.* )from");
  private static String sqlSelectPatternInspectDeeplyCacheKey = null;
  static {
    SQL_SKIPPED_PARAMETER_PATTERNS = new ArrayList<>(1);
    if (StringUtil.isDefined(SecuritySettings.skippedParametersAboutWebSqlInjectionSecurity())) {
      SQL_SKIPPED_PARAMETER_PATTERNS.add( Pattern.compile(SecuritySettings.skippedParametersAboutWebSqlInjectionSecurity()));
    }
    
    XSS_SKIPPED_PARAMETER_PATTERNS = new ArrayList<>(1);
    if (StringUtil.isDefined(SecuritySettings.skippedParametersAboutWebXssInjectionSecurity())) {
      XSS_SKIPPED_PARAMETER_PATTERNS.add( Pattern.compile(SecuritySettings.skippedParametersAboutWebXssInjectionSecurity()));
    }
    
    SQL_PATTERNS = new ArrayList<>(6);
    SQL_PATTERNS.add( Pattern.compile("(?i)(grant|revoke)(( .*|.* )(select|insert|update|delete))+( .*|.* )on"));
    SQL_PATTERNS.add( Pattern.compile("(?i)(grant|revoke)(( .*|.* )(references|alter|index|all))+( .*|.* )on"));
    SQL_PATTERNS.add(Pattern.compile("(?i)(create|drop|alter)( .*|.* )(table|database|schema)"));
    SQL_PATTERNS.add(SQL_SELECT_FROM_PATTERN);
    SQL_PATTERNS.add(SQL_INSERT_VALUES_PATTERN);
    SQL_PATTERNS.add(SQL_UPDATE_PATTERN);
    SQL_PATTERNS.add(SQL_DELETE_PATTERN);
    XSS_PATTERNS = new ArrayList<>(1);
    XSS_PATTERNS.add(Pattern.compile("(?i)<[\\s/]*(script|iframe)"));
  }
  
  public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {
    final HttpRequest httpRequest = (HttpRequest) request;
    final HttpServletResponse httpResponse = (HttpServletResponse) response;
    try {
      setDefaultSecurity(httpRequest, httpResponse);
      checkSecurity(httpRequest, httpResponse);
      chain.doFilter(httpRequest, httpResponse);
    }
     catch (WebSecurityException wse) {
      logger.error("The request for path {0} (uid={1}) isn''t valid: {2}", pathOf(httpRequest), ofNullable(User.getCurrentRequester()).map(User::getId).orElse("N/A"), wse.getMessage());
      httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN, wse.getMessage());
    }
    
  }
  
  private void setDefaultSecurity(final HttpServletRequest request, final HttpServletResponse response) {
    response.setHeader("X-Content-Type-Options", "nosniff");
    if (request.isSecure() && SecuritySettings.isStrictTransportSecurityEnabled()) {
      response.setHeader("Strict-Transport-Security", "max-age=" + SecuritySettings.getStrictTransportSecurityExpirationTime() + "; preload");
    }
    
  }
  
  private void checkSecurity(final HttpRequest httpRequest, final HttpServletResponse httpResponse) throws WebSqlInjectionSecurityException, WebXssInjectionSecurityException {
    String requestURI = httpRequest.getRequestURI();
    boolean isCmisService = requestURI.startsWith(CMIS_URI_PREFIX);
    boolean isWebServiceMultipart = requestURI.startsWith(WEB_SERVICES_URI_PREFIX) && httpRequest.isContentInMultipart();
    boolean isWebPageMultiPart = requestURI.startsWith(WEB_PAGES_URI_PREFIX) && httpRequest.isContentInMultipart();
    if (!(isCmisService || isWebServiceMultipart || isWebPageMultiPart)) {
      checkWebInjection(httpRequest, httpResponse);
      setUpSecurityContentPolicy(httpRequest, httpResponse);
    }
    
  }
  
  private void setUpSecurityContentPolicy(final HttpRequest httpRequest, final HttpServletResponse httpResponse) {
    boolean isCSPEnabled = SecuritySettings.isWebContentInjectionSecurityEnabled();
    if (isCSPEnabled) {
      final User currentUser = User.getCurrentRequester();
      final String secure = " https: " + (httpRequest.isSecure() ? WebDavProtocol.SECURED_WEBDAV_SCHEME + ": " : WebDavProtocol.WEBDAV_SCHEME + ": ");
      final String ws = " " + getCurrentServerURL().replaceFirst("^http", "ws") + " ";
      final String font = currentUser == null ? "" : "; font-src * data:";
      final String img = currentUser == null ? "" : "; img-src * data: blob:";
      httpResponse.setHeader("Content-Security-Policy", "default-src 'self' blob: mailto: " + secure + ws + SecuritySettings.getAllowedDefaultSourcesInCSP() + font + img + "; script-src 'self' blob: 'unsafe-inline' 'unsafe-eval' " + secure + SecuritySettings.getAllowedScriptSourcesInCSP() + "; style-src 'self' 'unsafe-inline' " + secure + SecuritySettings.getAllowedStyleSourcesInCSP() + "; style-src-elem 'self' blob: 'unsafe-inline' " + SecuritySettings.getAllowedStyleSourcesInCSP());
    }
    
  }
  
  private void checkWebInjection(final HttpRequest httpRequest, final HttpServletResponse httpResponse) throws WebSqlInjectionSecurityException, WebXssInjectionSecurityException {
    boolean isWebSqlInjectionSecurityEnabled = SecuritySettings.isWebSqlInjectionSecurityEnabled();
    boolean isWebXssInjectionSecurityEnabled = SecuritySettings.isWebXssInjectionSecurityEnabled();
    if (isWebSqlInjectionSecurityEnabled || isWebXssInjectionSecurityEnabled) {
      if (isWebXssInjectionSecurityEnabled) {
        httpResponse.setHeader("X-XSS-Protection", "1");
      }
      
      checkRequestParametersForInjection(httpRequest, isWebSqlInjectionSecurityEnabled, isWebXssInjectionSecurityEnabled);
    }
    
  }
  
  private void checkRequestParametersForInjection(final HttpRequest httpRequest, final boolean isWebSqlInjectionSecurityEnabled, final boolean isWebXssInjectionSecurityEnabled) throws WebSqlInjectionSecurityException, WebXssInjectionSecurityException {
    long start = System.currentTimeMillis();
    try {
      for (Map.Entry<String, String[]> parameterEntry : httpRequest.getParameterMap().entrySet()) {
        boolean sqlInjectionToVerify = isWebSqlInjectionSecurityEnabled && mustTheParameterBeVerifiedForSqlVerifications(parameterEntry.getKey());
        boolean xssInjectionToVerify = isWebXssInjectionSecurityEnabled && mustTheParameterBeVerifiedForXssVerifications(parameterEntry.getKey());
        if (!sqlInjectionToVerify && !xssInjectionToVerify) {
          continue;
        }
        
        checkParameterValues(parameterEntry, sqlInjectionToVerify, xssInjectionToVerify);
      }
      
    }
     finally {
      long end = System.currentTimeMillis();
      logger.debug("Massive Web Security Verify duration : " + DurationFormatUtils.formatDurationHMS(end - start));
    }
    
  }
  
  private void checkParameterValues(final Map.Entry<String, String[]> parameterEntry, final boolean sqlInjectionToVerify, final boolean xssInjectionToVerify) throws WebSqlInjectionSecurityException, WebXssInjectionSecurityException {
    Matcher patternMatcherFound;
    for (String parameterValue : parameterEntry.getValue()) {
      parameterValue = parameterValue.replaceAll("\\s+", " ");
      if (sqlInjectionToVerify && (patternMatcherFound = findPatternMatcherFromString(SQL_PATTERNS, parameterValue, true)) != null) {
        if (!verifySqlDeeply(patternMatcherFound, parameterValue)) {
          patternMatcherFound = null;
        }
        
        if (patternMatcherFound != null) {
          throw new WebSqlInjectionSecurityException();
        }
        
      }
      
      if (xssInjectionToVerify && findPatternMatcherFromString(XSS_PATTERNS, parameterValue, false) != null) {
        throw new WebXssInjectionSecurityException();
      }
      
    }
    
  }
  
  private boolean verifySqlDeeply(final Matcher matcherFound, String statement) {
    boolean isVerified = true;
    if (matcherFound.pattern() == SQL_SELECT_FROM_PATTERN || matcherFound.pattern() == SQL_INSERT_VALUES_PATTERN || matcherFound.pattern() == SQL_UPDATE_PATTERN || matcherFound.pattern() == SQL_DELETE_PATTERN) {
      isVerified = false;
      Pattern tableNamesPattern = getSqlTableNamesPattern();
      Matcher tableNameMatcher = tableNamesPattern.matcher(statement);
      while (tableNameMatcher.find()) {
        isVerified = tableNamesPattern.matcher(extractTableNameWholeWord(tableNameMatcher, statement)) .matches();
        if (isVerified) {
          break;
        }
        
      }
      
    }
    
    return isVerified;
  }
  
  private String extractTableNameWholeWord(Matcher matcher, String matchedString) {
    StringBuilder tableName = new StringBuilder(matchedString.substring(matcher.start(), matcher.end()));
    int index = matcher.start() - 1;
    while (index >= 0) {
      if (ENDS_WITH_WORD_CHARACTER_OR_NUMERIC_PATTERN.matcher( String.valueOf(matchedString.charAt(index))).matches()) {
        tableName.insert(0, matchedString.charAt(index));
      }
       else {
        break;
      }
      
      index--;
    }
    
    index = matcher.end();
    while (index < matchedString.length()) {
      if (ENDS_WITH_WORD_CHARACTER_OR_NUMERIC_PATTERN.matcher( String.valueOf(matchedString.charAt(index))).matches()) {
        tableName.append(matchedString.charAt(index));
      }
       else {
        break;
      }
      
      index++;
    }
    
    return tableName.toString();
  }
  
  private synchronized Pattern getSqlTableNamesPattern() {
    Pattern pattern = (sqlSelectPatternInspectDeeplyCacheKey != null) ? CacheAccessorProvider.getApplicationCacheAccessor() .getCache() .get(sqlSelectPatternInspectDeeplyCacheKey, Pattern.class) : null;
    if (pattern == null) {
      StringBuilder sbPattern = new StringBuilder("(");
      for (String tableName : DBUtil.getAllTableNames()) {
        if (sbPattern.length() > 1) {
          sbPattern.append("|");
        }
        
        sbPattern.append(tableName);
      }
      
      sbPattern.append(")");
      pattern = Pattern.compile("(?i)" + sbPattern);
      sqlSelectPatternInspectDeeplyCacheKey = CacheAccessorProvider.getApplicationCacheAccessor().getCache().add(pattern);
    }
    
    return pattern;
  }
  
  private boolean mustTheParameterBeVerifiedForSqlVerifications(String parameterName) {
    return findPatternMatcherFromString(SQL_SKIPPED_PARAMETER_PATTERNS, parameterName, false) == null;
  }
  
  private boolean mustTheParameterBeVerifiedForXssVerifications(String parameterName) {
    return findPatternMatcherFromString(XSS_SKIPPED_PARAMETER_PATTERNS, parameterName, false) == null;
  }
  
  private Matcher findPatternMatcherFromString(List<Pattern> patterns, String string, boolean startsAndEndsByWholeWord) {
    Matcher isMatcherFound = null;
    for (Pattern pattern : patterns) {
      Matcher matcher = pattern.matcher(string);
      if (matcher.find() && !(startsAndEndsByWholeWord && (!verifyMatcherStartingByAWord(matcher, string) || !verifyMatcherEndingByAWord(matcher, string)))) {
        isMatcherFound = matcher;
        break;
      }
      
    }
    
    return isMatcherFound;
  }
  
  private boolean verifyMatcherStartingByAWord(Matcher matcher, String matchedString) {
    return matcher.start() == 0 || !ENDS_WITH_WORD_CHARACTER_OR_NUMERIC_PATTERN.matcher( matchedString.substring(0, matcher.start())).find();
  }
  
  private boolean verifyMatcherEndingByAWord(Matcher matcher, String matchedString) {
    return matcher.end(0) == matchedString.length() || !ENDS_WITH_WORD_CHARACTER_OR_NUMERIC_PATTERN.matcher( String.valueOf(matchedString.charAt(matcher.end(0)))).find();
  }
  
  private String pathOf(HttpServletRequest request) {
    return request.getRequestURI();
  }
  
  public void init(final FilterConfig filterConfig) throws ServletException {
  }
  
  public void destroy() {
  }
  
}


