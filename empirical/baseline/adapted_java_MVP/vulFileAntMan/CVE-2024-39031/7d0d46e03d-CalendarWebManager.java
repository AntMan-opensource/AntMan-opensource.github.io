package org.silverpeas.core.webapi.calendar;
import org.apache.commons.lang3.tuple.Pair;
import org.silverpeas.core.ResourceReference;
import org.silverpeas.kernel.SilverpeasRuntimeException;
import org.silverpeas.core.admin.component.model.PersonalComponent;
import org.silverpeas.core.admin.component.model.PersonalComponentInstance;
import org.silverpeas.core.admin.component.model.SilverpeasPersonalComponentInstance;
import org.silverpeas.core.admin.user.model.User;
import org.silverpeas.kernel.annotation.Base;
import org.silverpeas.core.annotation.Service;
import org.silverpeas.core.calendar.Attendee;
import org.silverpeas.core.calendar.Attendee.ParticipationStatus;
import org.silverpeas.core.calendar.Calendar;
import org.silverpeas.core.calendar.CalendarEvent;
import org.silverpeas.core.calendar.CalendarEvent.EventOperationResult;
import org.silverpeas.core.calendar.CalendarEventOccurrence;
import org.silverpeas.core.calendar.CalendarEventOccurrenceGenerator;
import org.silverpeas.core.calendar.ICalendarEventImportProcessor;
import org.silverpeas.core.calendar.ICalendarImportResult;
import org.silverpeas.core.calendar.PlannableOnCalendar;
import org.silverpeas.core.calendar.icalendar.ICalendarExporter;
import org.silverpeas.core.calendar.view.CalendarEventInternalParticipationView;
import org.silverpeas.core.contribution.attachment.model.SimpleDocumentPK;
import org.silverpeas.core.date.Period;
import org.silverpeas.core.importexport.ExportDescriptor;
import org.silverpeas.core.importexport.ExportException;
import org.silverpeas.core.importexport.ImportException;
import org.silverpeas.core.persistence.datasource.model.IdentifiableEntity;
import org.silverpeas.kernel.bundle.LocalizationBundle;
import org.silverpeas.kernel.util.Mutable;
import org.silverpeas.kernel.bundle.ResourceLocator;
import org.silverpeas.core.util.ServiceProvider;
import org.silverpeas.kernel.bundle.SettingBundle;
import org.silverpeas.kernel.logging.SilverLogger;
import org.silverpeas.core.web.mvc.webcomponent.WebMessager;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Inject;
import javax.inject.Named;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import java.io.InputStream;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static java.util.Collections.*;
import static org.silverpeas.core.calendar.CalendarEventOccurrence.COMPARATOR_BY_DATE_ASC;
import static org.silverpeas.core.calendar.CalendarEventUtil.getDateWithOffset;
import static org.silverpeas.core.contribution.attachment.AttachmentServiceProvider.getAttachmentService;
import static org.silverpeas.core.contribution.content.wysiwyg.service.WysiwygController.wysiwygPlaceHaveChanged;
import static org.silverpeas.kernel.util.StringUtil.isNotDefined;
import static org.silverpeas.core.webapi.calendar.OccurrenceEventActionMethodType.ALL;
import static org.silverpeas.core.webapi.calendar.OccurrenceEventActionMethodType.UNIQUE;
@Named("default" + CalendarWebManager.NAME_SUFFIX)
public class CalendarWebManager {
  public static final String NAME_SUFFIX = "CalendarWebManager";
  private static final SettingBundle settings = ResourceLocator.getSettingBundle("org.silverpeas.calendar.settings.calendar");
  private final SilverLogger silverLogger = SilverLogger.getLogger(PlannableOnCalendar.class);
  private static final int END_YEAR_OFFSET = 3;
  private static final int DEFAULT_NB_MAX_NEXT_OCC = 10;
  private ICalendarExporter iCalendarExporter;
  private CalendarEventOccurrenceGenerator generator;
  private ICalendarEventImportProcessor iCalendarEventImportProcessor;
  protected CalendarWebManager() {
  }
  
  public static CalendarWebManager get(final String componentInstanceIdOrComponentName) {
    if (isNotDefined(componentInstanceIdOrComponentName)) {
      return ServiceProvider.getService(CalendarWebManager.class, new AnnotationLiteral<Base>() {});
    }
    
    return ServiceProvider .getService(componentInstanceIdOrComponentName, NAME_SUFFIX);
  }
  
  static void assertDataConsistency(final String componentInstanceId, final Calendar originalCalendar) {
    assertEntityIsDefined(originalCalendar);
    if (!originalCalendar.getComponentInstanceId().equals(componentInstanceId)) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
  }
  
  static void assertDataConsistency(final String componentInstanceId, final Calendar originalCalendar, final CalendarEvent event) {
    assertDataConsistency(componentInstanceId, originalCalendar);
    assertEntityIsDefined(event.asCalendarComponent());
    if (!originalCalendar.getComponentInstanceId().equals(componentInstanceId) || !event.getCalendar().getComponentInstanceId().equals(componentInstanceId)) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    if (!event.getCalendar().getId().equals(originalCalendar.getId())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
  }
  
  static void assertDataConsistency(final String componentInstanceId, final Calendar originalCalendar, final CalendarEvent previousOne, final CalendarEventOccurrence occurrence) {
    assertDataConsistency(componentInstanceId, originalCalendar, previousOne);
    assertEntityIsDefined(occurrence);
    if (!occurrence.getCalendarEvent().getCalendar().getComponentInstanceId() .equals(componentInstanceId)) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    if (!previousOne.getId().equals(occurrence.getCalendarEvent().getId())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
  }
  
  static void assertEntityIsDefined(final IdentifiableEntity entity) {
    if (entity == null || isNotDefined(entity.getId())) {
      throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
    
  }
  
  public CalendarEvent createEvent(Calendar calendar, CalendarEvent event, String volatileEventId) {
    if (!calendar.canBeAccessedBy(User.getCurrentRequester())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    event.planOn(calendar);
    final String finalEventId = event.getId();
    final String instanceId = calendar.getComponentInstanceId();
    final ResourceReference volatileAttachmentSourcePK = new ResourceReference(volatileEventId, instanceId);
    final ResourceReference finalAttachmentSourcePK = new ResourceReference(finalEventId, instanceId);
    final List<SimpleDocumentPK> movedDocumentPks = getAttachmentService() .moveAllDocuments(volatileAttachmentSourcePK, finalAttachmentSourcePK);
    if (!movedDocumentPks.isEmpty()) {
      wysiwygPlaceHaveChanged(instanceId, volatileEventId, instanceId, finalEventId);
    }
    
    successMessage("calendar.message.event.created", event.getTitle());
    return event;
  }
  
  public LocalizationBundle getLocalizationBundle(String locale) {
    return ResourceLocator.getLocalizationBundle("org.silverpeas.calendar.multilang.calendarBundle", locale);
  }
  
  public List<Calendar> getCalendarsHandledBy(final String componentInstanceId) {
    return getCalendarsHandledBy(singleton(componentInstanceId));
  }
  
  public List<Calendar> getCalendarsHandledBy(final Collection<String> componentInstanceIds) {
    return Calendar.getByComponentInstanceIds(componentInstanceIds);
  }
  
  protected Calendar saveCalendar(Calendar calendar) {
    User owner = User.getCurrentRequester();
    String successfulMessageKey = calendar.isPersisted() ? "calendar.message.calendar.updated" : "calendar.message.calendar.created";
    if (calendar.isPersisted() && !calendar.canBeModifiedBy(User.getCurrentRequester())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    calendar.save();
    String userLanguage = owner.getUserPreferences().getLanguage();
    getMessager().addSuccess( getLocalizationBundle(userLanguage).getStringWithParams(successfulMessageKey, calendar.getTitle()));
    return calendar;
  }
  
  protected void deleteCalendar(Calendar calendar) {
    User owner = User.getCurrentRequester();
    if (!calendar.canBeDeletedBy(User.getCurrentRequester())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    calendar.delete();
    String userLanguage = owner.getUserPreferences().getLanguage();
    getMessager().addSuccess(getLocalizationBundle(userLanguage) .getStringWithParams("calendar.message.calendar.deleted", calendar.getTitle()));
  }
  
  protected void exportCalendarAsICalendarFormat(final Calendar calendar, final ExportDescriptor descriptor) throws ExportException {
    final Mutable<User> currentUser = Mutable.ofNullable(User.getCurrentRequester());
    if (!currentUser.isPresent()) {
      SilverpeasPersonalComponentInstance.getById(calendar.getComponentInstanceId()) .ifPresent(i -> currentUser.set(i.getUser()));
    }
    
    if (currentUser.isPresent() && calendar.isMainPersonalOf(currentUser.get())) {
      iCalendarExporter.exports(descriptor, () -> Stream.concat( Calendar.getEvents().filter(f -> f.onCalendar(calendar)).stream(), Calendar.getEvents().filter(f -> f.onParticipants(currentUser.get())).stream()) .distinct());
    }
     else {
      iCalendarExporter.exports(descriptor, () -> Calendar.getEvents().filter(f -> f.onCalendar(calendar)).stream());
    }
    
  }
  
  protected void synchronizeCalendar(final Calendar calendar) throws ImportException {
    if (calendar.getExternalCalendarUrl() == null) {
      throw new WebApplicationException("aimed calendar is not a synchronized one", Response.Status.FORBIDDEN);
    }
    
    final String calendarTitle = calendar.getTitle();
    final String calendarId = calendar.getId();
    silverLogger .info("start event synchronization of calendar {0} (id={1})", calendarTitle, calendarId);
    ICalendarImportResult result = calendar.synchronize();
    silverLogger.info( "end event synchronization of calendar {0} (id={1}), with {2} created events, {3} updated" + " events and {4} deleted events", calendarTitle, calendarId, result.added(), result.updated(), result.deleted());
    successMessage("calendar.message.calendar.synchronized", calendar.getTitle(), result.added(), result.updated(), result.deleted());
  }
  
  protected void importEventsAsICalendarFormat(final Calendar calendar, final InputStream inputStream) throws ImportException {
    final String calendarTitle = calendar.getTitle();
    final String calendarId = calendar.getId();
    silverLogger.info("start event import into calendar {0} (id={1})", calendarTitle, calendarId);
    ICalendarImportResult result = iCalendarEventImportProcessor.importInto(calendar, inputStream);
    silverLogger.info( "end event import into calendar {0} (id={1}), with {2} created events and {3} updated " + "events", calendarTitle, calendarId, result.added(), result.updated());
    successMessage("calendar.message.event.imported", calendarTitle, result.added(), result.updated());
  }
  
  protected List<CalendarEvent> saveOccurrence(final CalendarEventOccurrence occurrence, OccurrenceEventActionMethodType updateMethodType, final ZoneId zoneId) {
    if (!occurrence.getCalendarEvent().canBeModifiedBy(User.getCurrentRequester())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    OccurrenceEventActionMethodType methodType = updateMethodType == null ? ALL : updateMethodType;
    final String originalTitle = occurrence.getCalendarEvent().getTitle();
    final Temporal originalStartDate = occurrence.getOriginalStartDate();
    final EventOperationResult result;
    switch (methodType) {
      case FROM:
        result = occurrence.updateSinceMe();
        break;
      case UNIQUE:
        result = occurrence.update();
        break;
      default: final CalendarEvent event = occurrence.getCalendarEvent();
        occurrence.asCalendarComponent().copyTo(event.asCalendarComponent());
        result = event.update();
        break;
    }
    
    final List<CalendarEvent> events = new ArrayList<>();
    Optional<CalendarEvent> createdEvent = result.created();
    Optional<CalendarEvent> updatedEvent = result.updated();
    Optional<CalendarEventOccurrence> updatedOccurrence = result.instance();
    updatedOccurrence.ifPresent(o -> {
      final CalendarEvent event = o.getCalendarEvent();
      successMessage("calendar.message.event.occurrence.updated.unique", originalTitle, getMessager().formatDate( getDateWithOffset(event.asCalendarComponent(), originalStartDate, zoneId)));
      events.add(event);
    }
    
);
    updatedEvent.ifPresent(e -> {
      if (createdEvent.isEmpty()) {
        successMessage("calendar.message.event.updated", e.getTitle());
      }
       else {
        final Temporal endDate = e.getRecurrence().getRecurrenceEndDate().get();
        successMessage("calendar.message.event.occurrence.updated.from", e.getTitle(), getMessager().formatDate(getDateWithOffset(e.asCalendarComponent(), endDate, zoneId)));
      }
      
      events.add(e);
    }
    
);
    createdEvent.ifPresent(e -> {
      events.add(e);
      successMessage("calendar.message.event.created", e.getTitle());
    }
    
);
    return events;
  }
  
  protected CalendarEvent deleteOccurrence(CalendarEventOccurrence occurrence, OccurrenceEventActionMethodType deleteMethodType, final ZoneId zoneId) {
    if (!occurrence.getCalendarEvent().canBeDeletedBy(User.getCurrentRequester())) {
      throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
    OccurrenceEventActionMethodType methodType = deleteMethodType == null ? ALL : deleteMethodType;
    final EventOperationResult result;
    switch (methodType) {
      case FROM:
        result = occurrence.deleteSinceMe();
        break;
      case UNIQUE:
        result = occurrence.delete();
        break;
      default: result = occurrence.getCalendarEvent().delete();
        break;
    }
    
    Optional<CalendarEvent> updatedEvent = result.updated();
    if (updatedEvent.isEmpty() || !updatedEvent.get().isRecurrent()) {
      successMessage("calendar.message.event.deleted", occurrence.getTitle());
    }
     else {
      final String bundleKey;
      final Temporal endDate;
      if (methodType == UNIQUE) {
        bundleKey = "calendar.message.event.occurrence.deleted.unique";
        endDate = occurrence.getOriginalStartDate();
      }
       else {
        bundleKey = "calendar.message.event.occurrence.deleted.from";
        endDate = updatedEvent.get() .getRecurrence() .getRecurrenceEndDate() .orElseThrow(() -> new SilverpeasRuntimeException("No Recurrence end date!"));
      }
      
      successMessage(bundleKey, occurrence.getTitle(), getMessager() .formatDate(getDateWithOffset(occurrence.asCalendarComponent(), endDate, zoneId)));
    }
    
    return updatedEvent.orElse(null);
  }
  
  protected CalendarEvent updateOccurrenceAttendeeParticipation(CalendarEventOccurrence occurrence, String attendeeId, ParticipationStatus participationStatus, OccurrenceEventActionMethodType answerMethodType, final ZoneId zoneId) {
    OccurrenceEventActionMethodType methodType = answerMethodType == null ? ALL : answerMethodType;
    final Mutable<CalendarEvent> modifiedEvent = Mutable.empty();
    if (methodType == UNIQUE) {
      Optional<EventOperationResult> optionalResult = updateSingleOccurrenceAttendeeParticipation(occurrence, attendeeId, participationStatus);
      optionalResult.ifPresent(r -> {
        modifiedEvent.set(r.instance() .orElseThrow(() -> new SilverpeasRuntimeException( "No event occurrence in the operation result!")) .getCalendarEvent());
        successMessage("calendar.message.event.occurrence.attendee.participation.updated.unique", occurrence.getTitle(), getMessager().formatDate( getDateWithOffset(occurrence.asCalendarComponent(), occurrence.getOriginalStartDate(), zoneId)));
      }
      
);
    }
     else if (methodType == ALL) {
      Optional<EventOperationResult> optionalResult = updateEventAttendeeParticipation(occurrence, attendeeId, participationStatus);
      optionalResult.ifPresent(r -> {
        r.updated().ifPresentOrElse(modifiedEvent::set, () -> modifiedEvent.set(r.instance() .orElseThrow(() -> new SilverpeasRuntimeException( "No event occurrence in the operation result!")) .getCalendarEvent()));
        successMessage("calendar.message.event.attendee.participation.updated", occurrence.getCalendarEvent().getTitle());
      }
      
);
    }
    
    return modifiedEvent .orElseThrow(() -> new WebApplicationException(Response.Status.FORBIDDEN));
  }
  
  private Optional<EventOperationResult> updateEventAttendeeParticipation( final CalendarEventOccurrence occurrence, final String attendeeId, final ParticipationStatus participationStatus) {
    EventOperationResult result = null;
    final Optional<Attendee> attendee = occurrence.getCalendarEvent().getAttendees().stream() .filter(a -> a.getId().equals(attendeeId)).findFirst();
    if (attendee.isPresent()) {
      setAttendeeStatus(participationStatus, attendee.get());
      result = occurrence.getCalendarEvent().update();
    }
     else {
      List<CalendarEventOccurrence> allOccurrences = occurrence.getCalendarEvent().getPersistedOccurrences();
      for (CalendarEventOccurrence eventOccurrence : allOccurrences) {
        Optional<EventOperationResult> optionalResult = updateSingleOccurrenceAttendeeParticipation(eventOccurrence, attendeeId, participationStatus);
        if (result == null && optionalResult.isPresent()) {
          result = optionalResult.get();
        }
        
      }
      
    }
    
    return Optional.ofNullable(result);
  }
  
  private Optional<EventOperationResult> updateSingleOccurrenceAttendeeParticipation( final CalendarEventOccurrence occurrence, final String attendeeId, final ParticipationStatus participationStatus) {
    final Optional<Attendee> attendee = occurrence.getAttendees().stream().filter(a -> a.getId().equals(attendeeId)).findFirst();
    if (attendee.isPresent()) {
      setAttendeeStatus(participationStatus, attendee.get());
      return Optional.of(occurrence.update());
    }
    
    return Optional.empty();
  }
  
  private void setAttendeeStatus(final ParticipationStatus participationStatus, final Attendee attendee) {
    switch (participationStatus) {
      case ACCEPTED:
        attendee.accept();
        break;
      case DECLINED:
        attendee.decline();
        break;
      case TENTATIVE:
        attendee.tentativelyAccept();
        break;
      default: throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    
  }
  
  public CalendarEventOccurrence getFirstCalendarEventOccurrenceFromEventId(final String eventId) {
    CalendarEvent event = CalendarEvent.getById(eventId);
    final Temporal startTemporal = event.getStartDate();
    final Temporal endTemporal;
    if (!event.isRecurrent()) {
      endTemporal = event.getEndDate();
    }
     else {
      endTemporal = event.getEndDate().plus(END_YEAR_OFFSET, ChronoUnit.YEARS);
    }
    
    return generator .generateOccurrencesOf(singletonList(event), Period.between(startTemporal, endTemporal)) .get(0);
  }
  
  public List<CalendarEventOccurrence> getEventOccurrencesOf(LocalDate startDate, LocalDate endDate, List<Calendar> calendars) {
    return getEventOccurrencesOf(startDate, endDate, calendars, User.getCurrentRequester());
  }
  
  public List<CalendarEventOccurrence> getEventOccurrencesOf(LocalDate startDate, LocalDate endDate, List<Calendar> calendars, User currentRequester) {
    if (currentRequester == null) {
      throw new IllegalArgumentException("Current requester MUST be defined");
    }
    
    return calendars.isEmpty() ? emptyList() : Calendar .getTimeWindowBetween(startDate, endDate) .filter(f -> f.onCalendar(calendars)) .getEventOccurrences();
  }
  
  protected Map<String, List<CalendarEventOccurrence>> getAllEventOccurrencesByUserIds( final Pair<List<String>, User> currentUserAndComponentInstanceId, LocalDate startDate, LocalDate endDate, Collection<User> users) {
    final List<Calendar> personalCalendars = new ArrayList<>();
    users.forEach(u -> personalCalendars.addAll(getCalendarsHandledBy( PersonalComponentInstance.from(u, PersonalComponent.getByName("userCalendar").orElse(null)) .getId())));
    final List<CalendarEventOccurrence> entities = personalCalendars.isEmpty() ? emptyList() : Calendar.getTimeWindowBetween(startDate, endDate) .filter(f -> f.onCalendar(personalCalendars)) .getEventOccurrences();
    entities.addAll( Calendar.getTimeWindowBetween(startDate, endDate) .filter(f -> f.onParticipants(users)) .getEventOccurrences());
    Map<String, List<CalendarEventOccurrence>> result = new CalendarEventInternalParticipationView(users) .apply(entities.stream().distinct().collect(Collectors.toList()));
    final String currentUserId = currentUserAndComponentInstanceId.getRight().getId();
    if (result.containsKey(currentUserId)) {
      List<CalendarEventOccurrence> currentUserOccurrences = result.get(currentUserId);
      currentUserOccurrences.removeIf(calendarEventOccurrence -> {
        CalendarEvent event = calendarEventOccurrence.getCalendarEvent();
        return currentUserAndComponentInstanceId.getLeft() .contains(event.getCalendar().getComponentInstanceId()) && event.getCreator().getId().equals(currentUserId);
      }
      
);
    }
     else {
      result.put(currentUserId, emptyList());
    }
    
    return result;
  }
  
  public Stream<CalendarEventOccurrence> getNextEventOccurrences(final List<String> componentIds, final Set<String> calendarIdsToExclude, final Set<User> usersToInclude, final Set<String> calendarIdsToInclude, final ZoneId zoneId, final Integer limit) {
    final User currentRequester = User.getCurrentRequester();
    final List<Calendar> calendars = getCalendarsHandledBy(componentIds);
    calendarIdsToInclude.removeAll(calendarIdsToExclude);
    calendars.removeIf(c -> calendarIdsToExclude.contains(c.getId()));
    if (!calendarIdsToInclude.isEmpty()) {
      calendars.forEach(c -> calendarIdsToInclude.remove(c.getId()));
      calendarIdsToInclude.forEach(i -> {
        Calendar calendarToInclude = Calendar.getById(i);
        if (calendarToInclude.canBeAccessedBy(currentRequester)) {
          calendars.add(calendarToInclude);
        }
        
      }
      
);
    }
    
    final int nbOccLimit = (limit != null && limit > 0 && limit <= 500) ? limit : DEFAULT_NB_MAX_NEXT_OCC;
    final LocalDate startDate = zoneId != null ? LocalDateTime.now(zoneId).toLocalDate() : LocalDate.now();
    final Set<CalendarEventOccurrence> occurrences = new HashSet<>();
    for (int nbMonthsToAdd : getNextEventTimeWindows()) {
      occurrences.clear();
      LocalDate endDate = startDate.plusMonths(nbMonthsToAdd);
      occurrences.addAll(getEventOccurrencesOf(startDate, endDate, calendars));
      if (!usersToInclude.isEmpty()) {
        getAllEventOccurrencesByUserIds(Pair.of(componentIds, currentRequester), startDate, endDate, usersToInclude).forEach((u, o) -> occurrences.addAll(o));
      }
      
      if (occurrences.size() >= nbOccLimit) {
        break;
      }
      
    }
    
    return occurrences.stream().sorted(COMPARATOR_BY_DATE_ASC).limit(nbOccLimit);
  }
  
  protected Integer[] getNextEventTimeWindows() {
    final String[] timeWindows = settings.getString("calendar.nextEvents.time.windows").split(",");
    return Arrays.stream(timeWindows).map(w -> Integer.parseInt(w.trim())).toArray(Integer[]::new);
  }
  
  private void successMessage(String messageKey, Object... params) {
    User owner = User.getCurrentRequester();
    String userLanguage = owner.getUserPreferences().getLanguage();
    getMessager().addSuccess( getLocalizationBundle(userLanguage).getStringWithParams(messageKey, params));
  }
  
  private WebMessager getMessager() {
    return WebMessager.getInstance();
  }
  
}


