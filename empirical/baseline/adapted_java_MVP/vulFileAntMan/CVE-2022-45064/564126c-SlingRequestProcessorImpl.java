package org.apache.sling.engine.impl;
import static org.apache.sling.api.SlingConstants.ERROR_SERVLET_NAME;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.security.AccessControlException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.servlet.FilterChain;
import javax.servlet.Servlet;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.sling.api.SlingConstants;
import org.apache.sling.api.SlingException;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.apache.sling.api.SlingServletException;
import org.apache.sling.api.adapter.AdapterManager;
import org.apache.sling.api.request.RequestPathInfo;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceNotFoundException;
import org.apache.sling.api.resource.ResourceResolver;
import org.apache.sling.api.servlets.ServletResolver;
import org.apache.sling.api.wrappers.SlingHttpServletResponseWrapper;
import org.apache.sling.commons.mime.MimeTypeService;
import org.apache.sling.engine.SlingRequestProcessor;
import org.apache.sling.engine.impl.debug.RequestInfoProviderImpl;
import org.apache.sling.engine.impl.filter.ErrorFilterChainStatus;
import org.apache.sling.engine.impl.filter.ErrorFilterChainThrowable;
import org.apache.sling.engine.impl.filter.FilterHandle;
import org.apache.sling.engine.impl.filter.RequestSlingFilterChain;
import org.apache.sling.engine.impl.filter.ServletFilterManager;
import org.apache.sling.engine.impl.filter.ServletFilterManager.FilterChainType;
import org.apache.sling.engine.impl.helper.SlingServletContext;
import org.apache.sling.engine.impl.filter.SlingComponentFilterChain;
import org.apache.sling.engine.impl.parameters.ParameterSupport;
import org.apache.sling.engine.impl.request.ContentData;
import org.apache.sling.engine.impl.request.RequestData;
import org.apache.sling.engine.servlets.ErrorHandler;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Modified;
import org.osgi.service.component.annotations.Reference;
import org.osgi.service.component.annotations.ReferenceCardinality;
import org.osgi.service.component.annotations.ReferencePolicy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Component(service = {SlingRequestProcessor.class, SlingRequestProcessorImpl.class}, configurationPid = Config.PID)
public class SlingRequestProcessorImpl implements SlingRequestProcessor {
    private final Logger log = LoggerFactory.getLogger(SlingRequestProcessorImpl.class);
    private ServletResolver servletResolver;
    private ServletFilterManager filterManager;
    private RequestProcessorMBeanImpl mbean;
    @Reference(target = SlingServletContext.TARGET)
    private ServletContext slingServletContext;
    @Reference(cardinality=ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)
    private volatile AdapterManager adapterManager;
    @Reference(policy = ReferencePolicy.DYNAMIC, cardinality = ReferenceCardinality.OPTIONAL)
    private volatile MimeTypeService mimeTypeService;
    private final DefaultErrorHandler errorHandler = new DefaultErrorHandler();
    private volatile int maxCallCounter = Config.DEFAULT_MAX_CALL_COUNTER;
    private volatile int maxInclusionCounter = Config.DEFAULT_MAX_INCLUSION_COUNTER;
    private volatile List<StaticResponseHeader> additionalResponseHeaders = Collections.emptyList();
    public void activate(final Config config) {
        this.errorHandler.setServerInfo(this.slingServletContext.getServerInfo());
        this.modified(config);
    }
    
    public void modified(final Config config) {
        final List<StaticResponseHeader> mappings = new ArrayList<>();
        final String[] props = config.sling_additional_response_headers();
        if ( props != null ) {
            for (final String prop : props) {
                if (prop != null && prop.trim().length() > 0 ) {
                    try {
                        final StaticResponseHeader mapping = new StaticResponseHeader(prop.trim());
                        mappings.add(mapping);
                    }
                     catch (final IllegalArgumentException iae) {
                        log.info("configure: Ignoring '{}': {}", prop, iae.getMessage());
                    }
                    
                }
                
            }
            
        }
        
        this.additionalResponseHeaders = mappings;
        this.maxInclusionCounter = config.sling_max_inclusions();
        this.maxCallCounter = config.sling_max_calls();
    }
    
    @Reference(name = "ErrorHandler", cardinality=ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC, unbind = "unsetErrorHandler")
    void setErrorHandler(final ErrorHandler errorHandler) {
        this.errorHandler.setDelegate(errorHandler);
    }
    
    void unsetErrorHandler(final ErrorHandler errorHandler) {
        this.errorHandler.setDelegate(null);
    }
    
    public int getMaxCallCounter() {
        return maxCallCounter;
    }
    
    public int getMaxIncludeCounter() {
        return maxInclusionCounter;
    }
    
    public List<StaticResponseHeader> getAdditionalResponseHeaders() {
        return this.additionalResponseHeaders;
    }
    
    public <Type> Type adaptTo(Object object, Class<Type> type) {
        final AdapterManager adapterManager = this.adapterManager;
        if (adapterManager != null) {
            return adapterManager.getAdapter(object, type);
        }
        
        return null;
    }
    
    public void doProcessRequest(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse, final ResourceResolver resourceResolver) throws IOException {
        final ServletResolver sr = this.servletResolver;
        if (resourceResolver == null || sr == null) {
            final int status = HttpServletResponse.SC_SERVICE_UNAVAILABLE;
            String errorMessage = "Required service missing (";
            if ( resourceResolver == null ) {
                errorMessage = errorMessage.concat("ResourceResolver");
                if ( sr == null ) {
                    errorMessage = errorMessage.concat(", ");
                }
                
            }
            
            if ( sr == null ) {
                errorMessage = errorMessage.concat("ServletResolver");
            }
            
            log.debug("{}), cannot service requests, sending status {}", errorMessage, status);
            servletResponse.sendError(status, errorMessage);
            return;
        }
        
        final RequestData requestData = new RequestData(this, servletRequest, servletResponse);
        final SlingHttpServletRequest request = requestData.getSlingRequest();
        final SlingHttpServletResponse response = requestData.getSlingResponse();
        final boolean isInclude = request.getAttribute(SlingConstants.ATTR_INCLUDE_CONTEXT_PATH) != null;
        try {
            final Resource resource = requestData.initResource(resourceResolver);
            requestData.initServlet(resource, sr);
            final FilterHandle[] filters = filterManager.getFilters(FilterChainType.REQUEST);
            final FilterChain processor = new RequestSlingFilterChain(this, filters);
            request.getRequestProgressTracker().log("Applying ".concat(FilterChainType.REQUEST.name()).concat("filters"));
            processor.doFilter(request, response);
        }
         catch ( final SlingHttpServletResponseImpl.WriterAlreadyClosedException wace ) {
            log.error("Writer has already been closed.", wace);
        }
         catch (final ResourceNotFoundException rnfe) {
            log.debug("service: Resource {} not found", rnfe.getResource());
            if ( isInclude ) {
                throw rnfe;
            }
            
            handleError(HttpServletResponse.SC_NOT_FOUND, rnfe.getMessage(), request, response);
        }
         catch (final SlingException se) {
            if ( isInclude ) {
                throw se;
            }
            
            if (requestData.getActiveServletName() != null) {
                request.setAttribute(ERROR_SERVLET_NAME, requestData.getActiveServletName());
            }
            
            Throwable t = se;
            while ( t instanceof SlingException && t.getCause() != null ) {
                t = t.getCause();
            }
            
            log.error("service: Uncaught SlingException ", t);
            handleError(t, request, response);
        }
         catch (final AccessControlException ace) {
            if ( isInclude ) {
                throw ace;
            }
            
            log.debug( "service: Authenticated user {} does not have enough rights to executed requested action", request.getRemoteUser());
            handleError(HttpServletResponse.SC_FORBIDDEN, null, request, response);
        }
         catch (final IOException ioe) {
            throw ioe;
        }
         catch (final Throwable t) {
            if ( isInclude ) {
                if ( t instanceof RuntimeException ) {
                    throw (RuntimeException)t;
                }
                
                if ( t instanceof Error ) {
                    throw (Error)t;
                }
                
                throw new SlingException(t.getMessage(), t);
            }
            
            if (requestData.getActiveServletName() != null) {
                request.setAttribute(ERROR_SERVLET_NAME, requestData.getActiveServletName());
            }
            
            log.error("service: Uncaught Throwable", t);
            handleError(t, request, response);
        }
         finally {
            RequestInfoProviderImpl.recordRequest(request);
            if (mbean != null) {
                mbean.addRequestData(requestData);
            }
            
        }
        
    }
    
    public void processRequest(final HttpServletRequest servletRequest, final HttpServletResponse servletResponse, final ResourceResolver resourceResolver) throws IOException {
        final Object oldValue = servletRequest.getAttribute(ParameterSupport.MARKER_IS_SERVICE_PROCESSING);
        servletRequest.setAttribute(ParameterSupport.MARKER_IS_SERVICE_PROCESSING, Boolean.TRUE);
        try {
            this.doProcessRequest(servletRequest, servletResponse, resourceResolver);
        }
         finally {
            if ( oldValue != null ) {
                servletRequest.setAttribute(ParameterSupport.MARKER_IS_SERVICE_PROCESSING, oldValue);
            }
             else {
                servletRequest.removeAttribute(ParameterSupport.MARKER_IS_SERVICE_PROCESSING);
            }
            
        }
        
    }
    
    public void processComponent(SlingHttpServletRequest request, SlingHttpServletResponse response, final FilterChainType filterChainType) throws IOException, ServletException {
        final FilterHandle filters[] = filterManager.getFilters(filterChainType);
        FilterChain processor = new SlingComponentFilterChain(filters);
        request.getRequestProgressTracker().log( "Applying " + filterChainType + "filters");
        processor.doFilter(request, response);
    }
    
    public void dispatchRequest(final ServletRequest request, final ServletResponse response, final Resource resource, final RequestPathInfo resolvedURL,  final boolean include, final boolean protectHeadersOnInclude) throws IOException, ServletException {
        final SlingHttpServletRequest cRequest = RequestData.toSlingHttpServletRequest(request);
        final SlingHttpServletResponse cResponse = RequestData.toSlingHttpServletResponse(response);
        final RequestData requestData = RequestData.getRequestData(cRequest);
        final ContentData oldContentData = requestData.getContentData();
        final ContentData contentData = requestData.setContent(resource, resolvedURL);
        try {
            Servlet servlet = servletResolver.resolveServlet(cRequest);
            contentData.setServlet(servlet);
            FilterChainType type = include ? FilterChainType.INCLUDE : FilterChainType.FORWARD;
            processComponent(cRequest, include && protectHeadersOnInclude ? new IncludeResponseWrapper(cResponse) : cResponse, type);
        }
         finally {
            requestData.resetContent(oldContentData);
        }
        
    }
    
    private void handleError(final FilterChain errorFilterChain, final SlingHttpServletRequest request, final SlingHttpServletResponse response)  throws IOException {
        request.getRequestProgressTracker().log("Applying " + FilterChainType.ERROR + " filters");
        try {
            errorFilterChain.doFilter(request, new ErrorResponseWrapper(response));
        }
         catch (final ServletException se) {
            throw new SlingServletException(se);
        }
        
    }
    
    void handleError(final int status, final String message, final SlingHttpServletRequest request, final SlingHttpServletResponse response) throws IOException {
        final FilterHandle[] filters = filterManager.getFilters(FilterChainType.ERROR);
        final FilterChain processor = new ErrorFilterChainStatus(filters, errorHandler, status, message);
        this.handleError(processor, request, response);
    }
    
    private void handleError(final Throwable throwable, final SlingHttpServletRequest request, final SlingHttpServletResponse response) throws IOException {
        final FilterHandle[] filters = filterManager.getFilters(FilterChainType.ERROR);
        final FilterChain processor = new ErrorFilterChainThrowable(filters, errorHandler, throwable);
        this.handleError(processor, request, response);
    }
    
    private static class ErrorResponseWrapper extends SlingHttpServletResponseWrapper {
        private PrintWriter writer;
        public ErrorResponseWrapper(SlingHttpServletResponse wrappedResponse) {
            super(wrappedResponse);
        }
        
        public PrintWriter getWriter() throws IOException {
            if (writer == null) {
                try {
                    writer = super.getWriter();
                }
                 catch (IllegalStateException ise) {
                    OutputStream out = getOutputStream();
                    String encoding = getCharacterEncoding();
                    if (encoding == null) {
                        encoding = "ISO-8859-1";
                        setCharacterEncoding(encoding);
                    }
                    
                    Writer w = new OutputStreamWriter(out, encoding);
                    writer = new PrintWriter(w);
                }
                
            }
            
            return writer;
        }
        
        public void flushBuffer() throws IOException {
            if (writer != null) {
                writer.flush();
            }
            
            super.flushBuffer();
        }
        
    }
    
    public String getMimeType(final String name) {
        MimeTypeService mtservice = mimeTypeService;
        if (mtservice != null) {
            return mtservice.getMimeType(name);
        }
        
        log.debug( "getMimeType: MimeTypeService not available, cannot resolve mime type for {}", name);
        return null;
    }
    
}


