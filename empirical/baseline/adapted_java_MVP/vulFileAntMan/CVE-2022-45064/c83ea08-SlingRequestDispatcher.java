package org.apache.sling.engine.impl.request;
import java.io.IOException;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.sling.api.SlingConstants;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.request.RequestDispatcherOptions;
import org.apache.sling.api.request.RequestProgressTracker;
import org.apache.sling.api.resource.Resource;
import org.apache.sling.api.resource.ResourceWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SlingRequestDispatcher implements RequestDispatcher {
    private final Logger log = LoggerFactory.getLogger(getClass());
    private Resource resource;
    private RequestDispatcherOptions options;
    private String path;
    public SlingRequestDispatcher(String path, RequestDispatcherOptions options) {
        this.path = path;
        this.options = options;
        this.resource = null;
    }
    
    public SlingRequestDispatcher(Resource resource, RequestDispatcherOptions options) {
        this.resource = resource;
        this.options = options;
        this.path = resource.getPath();
    }
    
    public void include(ServletRequest request, ServletResponse sResponse) throws ServletException, IOException {
        final ContentData cd;
        try {
            cd = RequestData.getRequestData(request).getContentData();
        }
         catch (IllegalArgumentException iae) {
            throw new ServletException(iae.getMessage());
        }
        
        final HttpServletRequest hRequest = (HttpServletRequest) request;
        final Object v1 = setAttribute(request, SlingConstants.ATTR_REQUEST_CONTENT, cd.getResource());
        final Object v2 = setAttribute(request, SlingConstants.ATTR_REQUEST_SERVLET, cd.getServlet());
        final Object v3 = setAttribute(request, SlingConstants.ATTR_REQUEST_PATH_INFO, cd.getRequestPathInfo());
        final Object v4 = setAttribute(request, SlingConstants.ATTR_INCLUDE_CONTEXT_PATH, hRequest.getContextPath());
        final Object v5 = setAttribute(request, SlingConstants.ATTR_INCLUDE_PATH_INFO, hRequest.getPathInfo());
        final Object v6 = setAttribute(request, SlingConstants.ATTR_INCLUDE_QUERY_STRING, hRequest.getQueryString());
        final Object v7 = setAttribute(request, SlingConstants.ATTR_INCLUDE_REQUEST_URI, hRequest.getRequestURI());
        final Object v8 = setAttribute(request, SlingConstants.ATTR_INCLUDE_SERVLET_PATH, hRequest.getServletPath());
        try {
            dispatch(request, sResponse, true);
        }
         finally {
            request.setAttribute(SlingConstants.ATTR_REQUEST_CONTENT, v1);
            request.setAttribute(SlingConstants.ATTR_REQUEST_SERVLET, v2);
            request.setAttribute(SlingConstants.ATTR_REQUEST_PATH_INFO, v3);
            request.setAttribute(SlingConstants.ATTR_INCLUDE_CONTEXT_PATH, v4);
            request.setAttribute(SlingConstants.ATTR_INCLUDE_PATH_INFO, v5);
            request.setAttribute(SlingConstants.ATTR_INCLUDE_QUERY_STRING, v6);
            request.setAttribute(SlingConstants.ATTR_INCLUDE_REQUEST_URI, v7);
            request.setAttribute(SlingConstants.ATTR_INCLUDE_SERVLET_PATH, v8);
        }
        
    }
    
    public void forward(ServletRequest request, ServletResponse response) throws ServletException, IOException {
        if (response.isCommitted()) {
            throw new IllegalStateException("Response already committed");
        }
        
        response.resetBuffer();
        request.removeAttribute(SlingConstants.ATTR_REQUEST_CONTENT);
        request.removeAttribute(SlingConstants.ATTR_REQUEST_SERVLET);
        request.removeAttribute(SlingConstants.ATTR_REQUEST_PATH_INFO);
        request.removeAttribute(SlingConstants.ATTR_INCLUDE_CONTEXT_PATH);
        request.removeAttribute(SlingConstants.ATTR_INCLUDE_PATH_INFO);
        request.removeAttribute(SlingConstants.ATTR_INCLUDE_QUERY_STRING);
        request.removeAttribute(SlingConstants.ATTR_INCLUDE_REQUEST_URI);
        request.removeAttribute(SlingConstants.ATTR_INCLUDE_SERVLET_PATH);
        dispatch(request, response, false);
        response.flushBuffer();
    }
    
    private String getAbsolutePath(SlingHttpServletRequest request, String path) {
        if (path.startsWith("/")) {
            return path;
        }
        
        String uri = request.getResource().getPath();
        int lastSlash = uri.lastIndexOf('/');
        if (lastSlash >= 0) {
            uri = uri.substring(0, lastSlash);
        }
        
        return uri + '/' + path;
    }
    
    private void dispatch(final ServletRequest request, final ServletResponse response, final boolean include) throws ServletException, IOException {
        SlingHttpServletRequest cRequest = RequestData.unwrap(request);
        RequestData rd = RequestData.getRequestData(cRequest);
        String absPath = getAbsolutePath(cRequest, path);
        RequestProgressTracker requestProgressTracker = cRequest.getRequestProgressTracker();
        if (!(response instanceof HttpServletResponse)) {
            log.error("include: Failed to include {}, response has wrong type", absPath);
            return;
        }
        
        if (resource == null) {
            String timerName = "resolveIncludedResource(" + absPath + ")";
            requestProgressTracker.startTimer(timerName);
            resource = cRequest.getResourceResolver().resolve(absPath);
            if (resource == null) {
                log.error( "include: Could not resolve {} to a resource, not including", absPath);
                return;
            }
            
            requestProgressTracker.logTimer(timerName, "path={0} resolves to Resource={1}", absPath, resource);
        }
        
        SlingRequestPathInfo info = getMergedRequestPathInfo(cRequest);
        requestProgressTracker.log( "Including resource {0} ({1})", resource, info);
        final boolean protectHeaders = this.options != null ? this.options.isProtectHeadersOnInclude() : false;
        rd.getSlingRequestProcessor().dispatchRequest(request, response, resource, info, include, protectHeaders);
    }
    
    private SlingRequestPathInfo getMergedRequestPathInfo( final SlingHttpServletRequest cRequest) {
        SlingRequestPathInfo info = new SlingRequestPathInfo(resource);
        info = info.merge(cRequest.getRequestPathInfo());
        if (options != null) {
            info = info.merge(options);
            String rtOverwrite = options.getForceResourceType();
            if (rtOverwrite != null && !rtOverwrite.equals(resource.getResourceType())) {
                resource = new TypeOverwritingResourceWrapper(resource, rtOverwrite);
            }
            
        }
        
        return info;
    }
    
    private Object setAttribute(final ServletRequest request, final String name, final Object value) {
        final Object oldValue = request.getAttribute(name);
        request.setAttribute(name, value);
        return oldValue;
    }
    
    private static class TypeOverwritingResourceWrapper extends ResourceWrapper {
        private final String resourceType;
        TypeOverwritingResourceWrapper(Resource delegatee, String resourceType) {
            super(delegatee);
            this.resourceType = resourceType;
        }
        
        public String getResourceType() {
            return resourceType;
        }
        
        public String getResourceSuperType() {
            return null;
        }
        
        public boolean isResourceType(final String resourceType) {
            return this.getResourceResolver().isResourceType(this, resourceType);
        }
        
    }
    
}


