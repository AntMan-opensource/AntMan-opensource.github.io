package hudson;
import static hudson.init.InitMilestone.COMPLETED;
import static hudson.init.InitMilestone.PLUGINS_LISTED;
import static hudson.init.InitMilestone.PLUGINS_PREPARED;
import static hudson.init.InitMilestone.PLUGINS_STARTED;
import static java.util.logging.Level.FINE;
import static java.util.logging.Level.INFO;
import static java.util.logging.Level.WARNING;
import static java.util.stream.Collectors.toList;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import hudson.PluginWrapper.Dependency;
import hudson.init.InitMilestone;
import hudson.init.InitStrategy;
import hudson.init.InitializerFinder;
import hudson.model.AbstractItem;
import hudson.model.AbstractModelObject;
import hudson.model.AdministrativeMonitor;
import hudson.model.Api;
import hudson.model.Descriptor;
import hudson.model.DownloadService;
import hudson.model.Failure;
import hudson.model.ItemGroupMixIn;
import hudson.model.UpdateCenter;
import hudson.model.UpdateCenter.DownloadJob;
import hudson.model.UpdateCenter.InstallationJob;
import hudson.model.UpdateSite;
import hudson.security.ACL;
import hudson.security.ACLContext;
import hudson.security.Permission;
import hudson.security.PermissionScope;
import hudson.util.CyclicGraphDetector;
import hudson.util.CyclicGraphDetector.CycleDetectedException;
import hudson.util.FormValidation;
import hudson.util.PersistedList;
import hudson.util.Retrier;
import hudson.util.Service;
import hudson.util.VersionNumber;
import hudson.util.XStream2;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.lang.reflect.Method;
import java.net.JarURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.security.CodeSource;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.TreeMap;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Future;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.xml.XMLConstants;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import jenkins.ClassLoaderReflectionToolkit;
import jenkins.ExtensionRefreshException;
import jenkins.InitReactorRunner;
import jenkins.MissingDependencyException;
import jenkins.RestartRequiredException;
import jenkins.YesNoMaybe;
import jenkins.install.InstallState;
import jenkins.install.InstallUtil;
import jenkins.model.Jenkins;
import jenkins.plugins.DetachedPluginsUtil;
import jenkins.security.CustomClassFilter;
import jenkins.util.SystemProperties;
import jenkins.util.io.OnMaster;
import jenkins.util.xml.RestrictiveEntityResolver;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.LogFactory;
import org.jenkinsci.Symbol;
import org.jvnet.hudson.reactor.Executable;
import org.jvnet.hudson.reactor.Reactor;
import org.jvnet.hudson.reactor.TaskBuilder;
import org.jvnet.hudson.reactor.TaskGraphBuilder;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.DoNotUse;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.HttpRedirect;
import org.kohsuke.stapler.HttpResponse;
import org.kohsuke.stapler.HttpResponses;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerFallback;
import org.kohsuke.stapler.StaplerOverridable;
import org.kohsuke.stapler.StaplerProxy;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.export.Exported;
import org.kohsuke.stapler.export.ExportedBean;
import org.kohsuke.stapler.interceptor.RequirePOST;
import org.kohsuke.stapler.verb.POST;
import org.springframework.security.core.Authentication;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
public abstract class PluginManager extends AbstractModelObject implements OnMaster, StaplerOverridable, StaplerProxy {
    public static final String CUSTOM_PLUGIN_MANAGER = PluginManager.class.getName() + ".className";
    private static final Logger LOGGER = Logger.getLogger(PluginManager.class.getName());
     static int CHECK_UPDATE_SLEEP_TIME_MILLIS;
     static int CHECK_UPDATE_ATTEMPTS;
    static {
        try {
            CHECK_UPDATE_SLEEP_TIME_MILLIS = SystemProperties.getInteger(PluginManager.class.getName() + ".checkUpdateSleepTimeMillis", 1000);
            CHECK_UPDATE_ATTEMPTS = SystemProperties.getInteger(PluginManager.class.getName() + ".checkUpdateAttempts", 1);
        }
         catch (RuntimeException e) {
            LOGGER.warning(String.format("There was an error initializing the PluginManager. Exception: %s", e));
        }
         finally {
            CHECK_UPDATE_ATTEMPTS = CHECK_UPDATE_ATTEMPTS > 0 ? CHECK_UPDATE_ATTEMPTS : 1;
            CHECK_UPDATE_SLEEP_TIME_MILLIS = CHECK_UPDATE_SLEEP_TIME_MILLIS > 0 ? CHECK_UPDATE_SLEEP_TIME_MILLIS : 1000;
        }
        
    }
    
    private enum PMConstructor {
        JENKINS {
            @NonNull
            PluginManager doCreate(@NonNull Class<? extends PluginManager> klass, @NonNull Jenkins jenkins) throws ReflectiveOperationException {
                return klass.getConstructor(Jenkins.class).newInstance(jenkins);
            }
            
        }, SC_FILE {
            @NonNull PluginManager doCreate(@NonNull Class<? extends PluginManager> klass, @NonNull Jenkins jenkins) throws ReflectiveOperationException { return klass.getConstructor(ServletContext.class, File.class).newInstance(jenkins.servletContext, jenkins.getRootDir()); }
        }, FILE {
            @NonNull PluginManager doCreate(@NonNull Class<? extends PluginManager> klass, @NonNull Jenkins jenkins) throws ReflectiveOperationException { return klass.getConstructor(File.class).newInstance(jenkins.getRootDir()); }
        };
        final @CheckForNull PluginManager create(@NonNull Class<? extends PluginManager> klass, @NonNull Jenkins jenkins) throws ReflectiveOperationException {
            try {
                return doCreate(klass, jenkins);
            }
             catch (NoSuchMethodException e) {
                return null;
            }
            
        }
        
        abstract @NonNull PluginManager doCreate(@NonNull Class<? extends PluginManager> klass, @NonNull Jenkins jenkins) throws ReflectiveOperationException;
    }
    
    public static @NonNull PluginManager createDefault(@NonNull Jenkins jenkins) {
        String pmClassName = SystemProperties.getString(CUSTOM_PLUGIN_MANAGER);
        if (!StringUtils.isBlank(pmClassName)) {
            LOGGER.log(FINE, String.format("Use of custom plugin manager [%s] requested.", pmClassName));
            try {
                final Class<? extends PluginManager> klass = Class.forName(pmClassName).asSubclass(PluginManager.class);
                for (PMConstructor c : PMConstructor.values()) {
                    PluginManager pm = c.create(klass, jenkins);
                    if (pm != null) {
                        return pm;
                    }
                    
                }
                
                LOGGER.log(WARNING, String.format("Provided custom plugin manager [%s] does not provide any of the suitable constructors. Using default.", pmClassName));
            }
             catch (ClassCastException e) {
                LOGGER.log(WARNING, String.format("Provided class [%s] does not extend PluginManager. Using default.", pmClassName));
            }
             catch (Exception e) {
                LOGGER.log(WARNING, String.format("Unable to instantiate custom plugin manager [%s]. Using default.", pmClassName), e);
            }
            
        }
        
        return new LocalPluginManager(jenkins);
    }
    
    protected final List<PluginWrapper> plugins = new CopyOnWriteArrayList<>();
    protected final List<PluginWrapper> activePlugins = new CopyOnWriteArrayList<>();
    protected final List<FailedPlugin> failedPlugins = new ArrayList<>();
    public final File rootDir;
    private String lastErrorCheckUpdateCenters = null;
    private final File workDir;
    public final ServletContext context;
    public final ClassLoader uberClassLoader = new UberClassLoader(activePlugins);
    public volatile boolean pluginUploaded = false;
    private boolean pluginListed = false;
    private final PluginStrategy strategy;
    protected PluginManager(ServletContext context, File rootDir) {
        this.context = context;
        this.rootDir = rootDir;
        try {
            Util.createDirectories(rootDir.toPath());
        }
         catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        
        String workDir = SystemProperties.getString(PluginManager.class.getName() + ".workDir");
        this.workDir = StringUtils.isBlank(workDir) ? null : new File(workDir);
        strategy = createPluginStrategy();
    }
    
    public Api getApi() {
        Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);
        return new Api(this);
    }
    
    public File getWorkDir() {
        return workDir;
    }
    
    public Collection<PluginManagerStaplerOverride> getOverrides() {
        return PluginManagerStaplerOverride.all();
    }
    
    public TaskBuilder initTasks(final InitStrategy initStrategy) {
        TaskBuilder builder;
        if (!pluginListed) {
            builder = new TaskGraphBuilder() {                 List<File> archives;
                Collection<String> bundledPlugins;{
                    Handle loadBundledPlugins = add("Loading bundled plugins", new Executable() {
                        public void run(Reactor session) throws Exception {
                            bundledPlugins = loadBundledPlugins();
                        }
                        
                    }
                    
);
                    Handle listUpPlugins = requires(loadBundledPlugins).add("Listing up plugins", new Executable() {
                        public void run(Reactor session) throws Exception {
                            archives = initStrategy.listPluginArchives(PluginManager.this);
                        }
                        
                    }
                    
);
                    requires(listUpPlugins).attains(PLUGINS_LISTED).add("Preparing plugins", new Executable() {
                        public void run(Reactor session) throws Exception {
                            TaskGraphBuilder g = new TaskGraphBuilder();
                            final Map<String, File> inspectedShortNames = new HashMap<>();
                            for (final File arc : archives) {
                                g.followedBy().notFatal().attains(PLUGINS_LISTED).add("Inspecting plugin " + arc, new Executable() {
                                    public void run(Reactor session1) throws Exception {
                                        try {
                                            PluginWrapper p = strategy.createPluginWrapper(arc);
                                            if (isDuplicate(p)) return;
                                            p.isBundled = containsHpiJpi(bundledPlugins, arc.getName());
                                            plugins.add(p);
                                        }
                                         catch (IOException e) {
                                            failedPlugins.add(new FailedPlugin(arc.getName(), e));
                                            throw e;
                                        }
                                        
                                    }
                                    
                                    private boolean isDuplicate(PluginWrapper p) {
                                        String shortName = p.getShortName();
                                        if (inspectedShortNames.containsKey(shortName)) {
                                            LOGGER.info("Ignoring " + arc + " because " + inspectedShortNames.get(shortName) + " is already loaded");
                                            return true;
                                        }
                                        
                                        inspectedShortNames.put(shortName, arc);
                                        return false;
                                    }
                                    
                                }
                                
);
                            }
                            
                            g.followedBy().attains(PLUGINS_LISTED).add("Checking cyclic dependencies", new Executable() {                                 

                                public void run(Reactor reactor) throws Exception {
                                    try {
                                        CyclicGraphDetector<PluginWrapper> cgd = new CyclicGraphDetector<>() {
                                            protected List<PluginWrapper> getEdges(PluginWrapper p) {
                                                List<PluginWrapper> next = new ArrayList<>();
                                                addTo(p.getDependencies(), next);
                                                addTo(p.getOptionalDependencies(), next);
                                                return next;
                                            }
                                            
                                            private void addTo(List<Dependency> dependencies, List<PluginWrapper> r) {
                                                for (Dependency d : dependencies) {
                                                    PluginWrapper p = getPlugin(d.shortName);
                                                    if (p != null){
                                                        r.add(p);
}
                                                }
                                                
                                            }
                                            
                                            protected void reactOnCycle(PluginWrapper q, List<PluginWrapper> cycle) {
                                                LOGGER.log(Level.SEVERE, "found cycle in plugin dependencies: (root=" + q + ", deactivating all involved) " + cycle.stream().map(Object::toString).collect(Collectors.joining(" -> ")));
                                                for (PluginWrapper pluginWrapper : cycle) {
                                                    pluginWrapper.setHasCycleDependency(true);
                                                    failedPlugins.add(new FailedPlugin(pluginWrapper, new CycleDetectedException(cycle)));
                                                }
                                                
                                            }
                                            
                                        };
                                        cgd.run(getPlugins());
                                        for (PluginWrapper p : cgd.getSorted()) {
                                            if (p.isActive()){
                                                activePlugins.add(p);
}
                                        }
                                        
                                    }
                                     catch (CycleDetectedException e) { 
                                        stop(); 
                                        throw e;    
                                    }
                                    
                                }
                                
                            }
                            
);
                            session.addAll(g.discoverTasks(session));
                            pluginListed = true; 
                        }
                        
                    }
                    
);
                }
                
            };
        }
         else {
            builder = TaskBuilder.EMPTY_BUILDER;
        }
        
        final InitializerFinder initializerFinder = new InitializerFinder(uberClassLoader);        
        return TaskBuilder.union(initializerFinder,  builder, new TaskGraphBuilder() {{             requires(PLUGINS_LISTED).attains(PLUGINS_PREPARED).add("Loading plugins", new Executable() { 
                public void run(Reactor session) throws Exception {
                    Jenkins.get().lookup.set(PluginInstanceStore.class, new PluginInstanceStore());
                    TaskGraphBuilder g = new TaskGraphBuilder();
                    for (final PluginWrapper p : activePlugins.toArray(new PluginWrapper[0])) {
                        g.followedBy().notFatal().attains(PLUGINS_PREPARED).add(String.format("Loading plugin %s v%s (%s)", p.getLongName(), p.getVersion(), p.getShortName()), new Executable() {
                            public void run(Reactor session) throws Exception {
                                try {
                                    p.resolvePluginDependencies();
                                    strategy.load(p);
                                }
                                 catch (MissingDependencyException e) {
                                    failedPlugins.add(new FailedPlugin(p, e));
                                    activePlugins.remove(p);
                                    plugins.remove(p);
                                    p.releaseClassLoader();
                                    LOGGER.log(Level.SEVERE, "Failed to install {0}: {1}", new Object[] { p.getShortName(), e.getMessage() });
                                }
                                 catch (IOException e) {
                                    failedPlugins.add(new FailedPlugin(p, e));
                                    activePlugins.remove(p);
                                    plugins.remove(p);
                                    p.releaseClassLoader();
                                    throw e;
                                }
                                
                            }
                            
                        }
                        
);
                    }
                    
                    for (final PluginWrapper p : activePlugins.toArray(new PluginWrapper[0])) {
                        g.followedBy().notFatal().attains(PLUGINS_STARTED).add("Initializing plugin " + p.getShortName(), new Executable() {
                            public void run(Reactor session) throws Exception {
                                if (!activePlugins.contains(p)) {
                                    return;
                                }
                                
                                try {
                                    p.getPluginOrFail().postInitialize();
                                }
                                 catch (Exception e) {
                                    failedPlugins.add(new FailedPlugin(p, e));
                                    activePlugins.remove(p);
                                    plugins.remove(p);
                                    p.releaseClassLoader();
                                    throw e;
                                }
                                
                            }
                            
                        }
                        
);
                    }
                    
                    g.followedBy().attains(PLUGINS_STARTED).add("Discovering plugin initialization tasks", new Executable() {
                        public void run(Reactor reactor) throws Exception {
                            reactor.addAll(initializerFinder.discoverTasks(reactor));
                        }
                        
                    }
                    
);
                    session.addAll(g.discoverTasks(session));
                }
                
            }
            
);
            requires(PLUGINS_PREPARED).attains(COMPLETED).add("Resolving Dependent Plugins Graph", new Executable() {
                public void run(Reactor reactor) throws Exception {
                    resolveDependentPlugins();
                }
                
            }
            
);
        }
        }
);
    }
    
    void considerDetachedPlugin(String shortName) {
        if (new File(rootDir, shortName + ".jpi").isFile() || new File(rootDir, shortName + ".hpi").isFile() || new File(rootDir, shortName + ".jpl").isFile() || new File(rootDir, shortName + ".hpl").isFile()) {             LOGGER.fine(() -> "not considering loading a detached dependency " + shortName + " as it is already on disk");
            return;
        }
        
        LOGGER.fine(() -> "considering loading a detached dependency " + shortName);
        for (String loadedFile : loadPluginsFromWar(getDetachedLocation(), (dir, name) -> normalisePluginName(name).equals(shortName))) {
            String loaded = normalisePluginName(loadedFile);
            File arc = new File(rootDir, loaded + ".jpi");
            LOGGER.info(() -> "Loading a detached plugin as a dependency: " + arc);
            try {
                plugins.add(strategy.createPluginWrapper(arc));
            }
             catch (IOException e) {
                failedPlugins.add(new FailedPlugin(arc.getName(), e));
            }
            
        }
        
    }
    
    protected @NonNull String getDetachedLocation() {
        return "/WEB-INF/detached-plugins";
    }
    
    protected @NonNull Set<String> loadPluginsFromWar(@NonNull String fromPath) {
        return loadPluginsFromWar(fromPath, null);
    }
    
    @SuppressFBWarnings(value = "DMI_COLLECTION_OF_URLS", justification = "Plugin loading happens only once on Jenkins startup")
    protected @NonNull Set<String> loadPluginsFromWar(@NonNull String fromPath, @CheckForNull FilenameFilter filter) {
        Set<String> names = new HashSet<>();
        ServletContext context = Jenkins.get().servletContext;
        Set<String> plugins = Util.fixNull(context.getResourcePaths(fromPath));
        Set<URL> copiedPlugins = new HashSet<>();
        Set<URL> dependencies = new HashSet<>();
        for (String pluginPath : plugins) {
            String fileName = pluginPath.substring(pluginPath.lastIndexOf('/') + 1);
            if (fileName.length() == 0) {
                continue;
            }
            
            try {
                URL url = context.getResource(pluginPath);
                if (filter != null && url != null) {
                    if (!filter.accept(new File(url.getFile()).getParentFile(), fileName)) {
                        continue;
                    }
                    
                }
                
                names.add(fileName);
                copyBundledPlugin(Objects.requireNonNull(url), fileName);
                copiedPlugins.add(url);
                try {
                    addDependencies(url, fromPath, dependencies);
                }
                 catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Failed to resolve dependencies for the bundled plugin " + fileName, e);
                }
                
            }
             catch (IOException e) {
                LOGGER.log(Level.SEVERE, "Failed to extract the bundled plugin " + fileName, e);
            }
            
        }
        
        for (URL dependency : dependencies) {
            if (copiedPlugins.contains(dependency)) {
                continue;
            }
            
            String fileName = new File(dependency.getFile()).getName();
            try {
                names.add(fileName);
                copyBundledPlugin(dependency, fileName);
                copiedPlugins.add(dependency);
            }
             catch (IOException e) {
                LOGGER.log(Level.SEVERE, "Failed to extract the bundled dependency plugin " + fileName, e);
            }
            
        }
        
        return names;
    }
    
    @SuppressFBWarnings(value = "DMI_COLLECTION_OF_URLS", justification = "Plugin loading happens only once on Jenkins startup")
    protected static void addDependencies(URL hpiResUrl, String fromPath, Set<URL> dependencySet) throws URISyntaxException, MalformedURLException {
        if (dependencySet.contains(hpiResUrl)) {
            return;
        }
        
        Manifest manifest = parsePluginManifest(hpiResUrl);
        String dependencySpec = manifest.getMainAttributes().getValue("Plugin-Dependencies");
        if (dependencySpec != null) {
            String[] dependencyTokens = dependencySpec.split(",");
            ServletContext context = Jenkins.get().servletContext;
            for (String dependencyToken : dependencyTokens) {
                if (dependencyToken.endsWith(";resolution:=optional")) {
                    continue;
                }
                
                String[] artifactIdVersionPair = dependencyToken.split(":");
                String artifactId = artifactIdVersionPair[0];
                VersionNumber dependencyVersion = new VersionNumber(artifactIdVersionPair[1]);
                PluginManager manager = Jenkins.get().getPluginManager();
                VersionNumber installedVersion = manager.getPluginVersion(manager.rootDir, artifactId);
                if (installedVersion != null && !installedVersion.isOlderThan(dependencyVersion)) {
                    continue;
                }
                
                URL dependencyURL = context.getResource(fromPath + "/" + artifactId + ".hpi");
                if (dependencyURL == null) {
                    dependencyURL = context.getResource(fromPath + "/" + artifactId + ".jpi");
                }
                
                if (dependencyURL != null) {
                    addDependencies(dependencyURL, fromPath, dependencySet);
                    dependencySet.add(dependencyURL);
                }
                
            }
            
        }
        
    }
    
    protected void loadDetachedPlugins() {
        VersionNumber lastExecVersion = new VersionNumber(InstallUtil.getLastExecVersion());
        if (lastExecVersion.isNewerThan(InstallUtil.NEW_INSTALL_VERSION) && lastExecVersion.isOlderThan(Jenkins.getVersion())) {
            LOGGER.log(INFO, "Upgrading Jenkins. The last running version was {0}. This Jenkins is version {1}.", new Object[] {lastExecVersion, Jenkins.VERSION});
            final List<DetachedPluginsUtil.DetachedPlugin> detachedPlugins = DetachedPluginsUtil.getDetachedPlugins(lastExecVersion);
            Set<String> loadedDetached = loadPluginsFromWar(getDetachedLocation(), new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    name = normalisePluginName(name);
                    if (DetachedPluginsUtil.isDetachedPlugin(name)) {
                        VersionNumber installedVersion = getPluginVersion(rootDir, name);
                        VersionNumber bundledVersion = getPluginVersion(dir, name);
                        if (installedVersion != null && bundledVersion != null) {
                            return installedVersion.isOlderThan(bundledVersion);
                        }
                        
                    }
                    
                    for (DetachedPluginsUtil.DetachedPlugin detachedPlugin : detachedPlugins) {
                        if (detachedPlugin.getShortName().equals(name)) {
                            return true;
                        }
                        
                    }
                    
                    return false;
                }
                
            }
            
);
            LOGGER.log(INFO, "Upgraded Jenkins from version {0} to version {1}. Loaded detached plugins (and dependencies): {2}", new Object[] {lastExecVersion, Jenkins.VERSION, loadedDetached});
        }
         else {
            final Set<DetachedPluginsUtil.DetachedPlugin> forceUpgrade = new HashSet<>();
            for (DetachedPluginsUtil.DetachedPlugin p : DetachedPluginsUtil.getDetachedPlugins()) {
                VersionNumber installedVersion = getPluginVersion(rootDir, p.getShortName());
                VersionNumber requiredVersion = p.getRequiredVersion();
                if (installedVersion != null && installedVersion.isOlderThan(requiredVersion)) {
                    LOGGER.log(Level.WARNING, "Detached plugin {0} found at version {1}, required minimum version is {2}", new Object[]{p.getShortName(), installedVersion, requiredVersion});
                    forceUpgrade.add(p);
                }
                
            }
            
            if (!forceUpgrade.isEmpty()) {
                Set<String> loadedDetached = loadPluginsFromWar(getDetachedLocation(), new FilenameFilter() {
                    public boolean accept(File dir, String name) {
                        name = normalisePluginName(name);
                        for (DetachedPluginsUtil.DetachedPlugin detachedPlugin : forceUpgrade) {
                            if (detachedPlugin.getShortName().equals(name)) {
                                return true;
                            }
                            
                        }
                        
                        return false;
                    }
                    
                }
                
);
                LOGGER.log(INFO, "Upgraded detached plugins (and dependencies): {0}", new Object[]{loadedDetached});
            }
            
        }
        
    }
    
    private String normalisePluginName(@NonNull String name) {
        return name.replace(".jpi", "").replace(".hpi", "");
    }
    
    private @CheckForNull VersionNumber getPluginVersion(@NonNull File dir, @NonNull String pluginId) {
        VersionNumber version = getPluginVersion(new File(dir, pluginId + ".jpi"));
        if (version == null) {
            version = getPluginVersion(new File(dir, pluginId + ".hpi"));
        }
        
        return version;
    }
    
    private @CheckForNull VersionNumber getPluginVersion(@NonNull File pluginFile) {
        if (!pluginFile.exists()) {
            return null;
        }
        
        try {
            return getPluginVersion(pluginFile.toURI().toURL());
        }
         catch (MalformedURLException e) {
            return null;
        }
        
    }
    
    private @CheckForNull VersionNumber getPluginVersion(@NonNull URL pluginURL) {
        Manifest manifest = parsePluginManifest(pluginURL);
        if (manifest == null) {
            return null;
        }
        
        String versionSpec = manifest.getMainAttributes().getValue("Plugin-Version");
        return new VersionNumber(versionSpec);
    }
    
    private boolean containsHpiJpi(Collection<String> bundledPlugins, String name) {
        return bundledPlugins.contains(name.replaceAll("\\.hpi", ".jpi")) || bundledPlugins.contains(name.replaceAll("\\.jpi", ".hpi"));
    }
    
    public @CheckForNull Manifest getBundledPluginManifest(String shortName) {
        return null;
    }
    
    public void dynamicLoad(File arc) throws IOException, InterruptedException, RestartRequiredException {
        dynamicLoad(arc, false, null);
    }
    
    public void dynamicLoad(File arc, boolean removeExisting, @CheckForNull List<PluginWrapper> batch) throws IOException, InterruptedException, RestartRequiredException {
        try (ACLContext context = ACL.as2(ACL.SYSTEM2)) {
            LOGGER.log(FINE, "Attempting to dynamic load {0}", arc);
            PluginWrapper p = null;
            String sn;
            try {
                sn = strategy.getShortName(arc);
            }
             catch (AbstractMethodError x) {
                LOGGER.log(WARNING, "JENKINS-12753 fix not active: {0}", x.getMessage());
                p = strategy.createPluginWrapper(arc);
                sn = p.getShortName();
            }
            
            PluginWrapper pw = getPlugin(sn);
            if (pw != null) {
                if (removeExisting) { 
                    for (Iterator<PluginWrapper> i = plugins.iterator(); i.hasNext();) {
                        pw = i.next();
                        if (sn.equals(pw.getShortName())) {
                            i.remove();
                            break;
                        }
                        
                    }
                    
                }
                 else {
                    throw new RestartRequiredException(Messages._PluginManager_PluginIsAlreadyInstalled_RestartRequired(sn));
                }
                
            }
            
            if (p == null) {
                p = strategy.createPluginWrapper(arc);
            }
            
            if (p.supportsDynamicLoad() == YesNoMaybe.NO){
                throw new RestartRequiredException(Messages._PluginManager_PluginDoesntSupportDynamicLoad_RestartRequired(sn));
}
            plugins.add(p);
            if (p.isActive()){
                activePlugins.add(p);
}
            ((UberClassLoader) uberClassLoader).loaded.clear();
            CustomClassFilter.Contributed.load();
            try {
                p.resolvePluginDependencies();
                strategy.load(p);
                if (batch != null) {
                    batch.add(p);
                }
                 else {
                    start(List.of(p));
                }
                
            }
             catch (Exception e) {
                failedPlugins.add(new FailedPlugin(p, e));
                activePlugins.remove(p);
                plugins.remove(p);
                p.releaseClassLoader();
                throw new IOException("Failed to install " + sn + " plugin", e);
            }
            
            LOGGER.log(FINE, "Plugin {0}:{1} dynamically {2}", new Object[] {p.getShortName(), p.getVersion(), batch != null ? "loaded but not yet started" : "installed"});
        }
        
    }
    
    public void start(List<PluginWrapper> plugins) throws Exception {
      try (ACLContext context = ACL.as2(ACL.SYSTEM2)) {
        Map<String, PluginWrapper> pluginsByName = plugins.stream().collect(Collectors.toMap(PluginWrapper::getShortName, p -> p));
        for (PluginWrapper depender : this.plugins) {
            if (plugins.contains(depender)) {
                continue;
            }
            
            for (Dependency d : depender.getOptionalDependencies()) {
                PluginWrapper dependee = pluginsByName.get(d.shortName);
                if (dependee != null) {
                    getPluginStrategy().updateDependency(depender, dependee);
                    break;
                }
                
            }
            
        }
        
        resolveDependentPlugins();
        try {
            Jenkins.get().refreshExtensions();
        }
         catch (ExtensionRefreshException e) {
            throw new IOException("Failed to refresh extensions after installing some plugins", e);
        }
        
        for (PluginWrapper p : plugins) {
          p.getPluginOrFail().postInitialize();
        }
        
        Reactor r = new Reactor(InitMilestone.ordering());
        Set<ClassLoader> loaders = plugins.stream().map(p -> p.classLoader).collect(Collectors.toSet());
        r.addAll(new InitializerFinder(uberClassLoader) {
          protected boolean filter(Method e) {
            return !loaders.contains(e.getDeclaringClass().getClassLoader()) || super.filter(e);
          }
          
        }
        .discoverTasks(r));
        new InitReactorRunner().run(r);
      }
      
    }
    
    public synchronized void resolveDependentPlugins() {
        for (PluginWrapper plugin : plugins) {
            Set<String> optionalDependents = new HashSet<>();
            Set<String> dependents = new HashSet<>();
            for (PluginWrapper possibleDependent : plugins) {
                if (possibleDependent.getShortName().equals(plugin.getShortName())) {
                    continue;
                }
                
                if (possibleDependent.isDeleted()) {
                    continue;
                }
                
                List<Dependency> dependencies = possibleDependent.getDependencies();
                for (Dependency dependency : dependencies) {
                    if (dependency.shortName.equals(plugin.getShortName())) {
                        dependents.add(possibleDependent.getShortName());
                        if (dependency.optional) {
                            optionalDependents.add(possibleDependent.getShortName());
                        }
                        
                        break;
                    }
                    
                }
                
            }
            
            plugin.setDependents(dependents);
            plugin.setOptionalDependents(optionalDependents);
        }
        
    }
    
    protected abstract Collection<String> loadBundledPlugins() throws Exception;
    protected void copyBundledPlugin(URL src, String fileName) throws IOException {
        LOGGER.log(FINE, "Copying {0}", src);
        fileName = fileName.replace(".hpi", ".jpi"); 
        String legacyName = fileName.replace(".jpi", ".hpi");
        long lastModified = getModificationDate(src);
        File file = new File(rootDir, fileName);
        rename(new File(rootDir, legacyName), file);
        if (!file.exists() || file.lastModified() != lastModified) {
            FileUtils.copyURLToFile(src, file);
            Files.setLastModifiedTime(Util.fileToPath(file), FileTime.fromMillis(getModificationDate(src)));
        }
        
    }
    
     static @CheckForNull Manifest parsePluginManifest(URL bundledJpi) {
        try (URLClassLoader cl = new URLClassLoader(new URL[]{bundledJpi})) {
            InputStream in = null;
            try {
                URL res = cl.findResource(PluginWrapper.MANIFEST_FILENAME);
                if (res != null) {
                    in = getBundledJpiManifestStream(res);
                    return new Manifest(in);
                }
                
            }
             finally {
                Util.closeAndLogFailures(in, LOGGER, PluginWrapper.MANIFEST_FILENAME, bundledJpi.toString());
            }
            
        }
         catch (IOException e) {
            LOGGER.log(WARNING, "Failed to parse manifest of " + bundledJpi, e);
        }
        
        return null;
    }
    
    @NonNull
     static InputStream getBundledJpiManifestStream(@NonNull URL url) throws IOException {
        URLConnection uc = url.openConnection();
        InputStream in = null;
        if (uc instanceof JarURLConnection) {
            final JarURLConnection jarURLConnection = (JarURLConnection) uc;
            final String entryName = jarURLConnection.getEntryName();
            try (JarFile jarFile = jarURLConnection.getJarFile()) {
                final JarEntry entry = entryName != null && jarFile != null ? jarFile.getJarEntry(entryName) : null;
                if (entry != null) {
                    try (InputStream i = jarFile.getInputStream(entry)) {
                        byte[] manifestBytes = IOUtils.toByteArray(i);
                        in = new ByteArrayInputStream(manifestBytes);
                    }
                    
                }
                 else {
                    LOGGER.log(Level.WARNING, "Failed to locate the JAR file for {0}" + "The default URLConnection stream access will be used, file descriptor may be leaked.", url);
                }
                
            }
            
        }
        
        if (in == null) {
            in = url.openStream();
        }
        
        return in;
    }
    
    @NonNull
     static long getModificationDate(@NonNull URL url) throws IOException {
        URLConnection uc = url.openConnection();
        if (uc instanceof JarURLConnection) {
            final JarURLConnection connection = (JarURLConnection) uc;
            final URL jarURL = connection.getJarFileURL();
            if (jarURL.getProtocol().equals("file")) {
                String file = jarURL.getFile();
                return new File(file).lastModified();
            }
             else {
                if (connection.getEntryName() != null) {
                    LOGGER.log(WARNING, "Accessing modification date of {0} file, which is an entry in JAR file. " + "The access protocol is not file:, falling back to the default logic (risk of file descriptor leak).", url);
                }
                
            }
            
        }
        
        return uc.getLastModified();
    }
    
    private void rename(File legacyFile, File newFile) throws IOException {
        if (!legacyFile.exists())   return;
        if (newFile.exists()) {
            Util.deleteFile(newFile);
        }
        
        if (!legacyFile.renameTo(newFile)) {
            LOGGER.warning("Failed to rename " + legacyFile + " to " + newFile);
        }
        
    }
    
    protected PluginStrategy createPluginStrategy() {
        String strategyName = SystemProperties.getString(PluginStrategy.class.getName());
        if (strategyName != null) {
            try {
                Class<?> klazz = getClass().getClassLoader().loadClass(strategyName);
                Object strategy = klazz.getConstructor(PluginManager.class) .newInstance(this);
                if (strategy instanceof PluginStrategy) {
                    LOGGER.info("Plugin strategy: " + strategyName);
                    return (PluginStrategy) strategy;
                }
                 else {
                    LOGGER.warning("Plugin strategy (" + strategyName + ") is not an instance of hudson.PluginStrategy");
                }
                
            }
             catch (ClassNotFoundException e) {
                LOGGER.warning("Plugin strategy class not found: " + strategyName);
            }
             catch (Exception e) {
                LOGGER.log(WARNING, "Could not instantiate plugin strategy: " + strategyName + ". Falling back to ClassicPluginStrategy", e);
            }
            
            LOGGER.info("Falling back to ClassicPluginStrategy");
        }
        
        return new ClassicPluginStrategy(this);
    }
    
    public PluginStrategy getPluginStrategy() {
        return strategy;
    }
    
    public boolean isPluginUploaded() {
        return pluginUploaded;
    }
    
    public List<PluginWrapper> getPlugins() {
        return Collections.unmodifiableList(plugins);
    }
    
    public List<FailedPlugin> getFailedPlugins() {
        return failedPlugins;
    }
    
    public PluginWrapper getPlugin(String shortName) {
        for (PluginWrapper p : getPlugins()) {
            if (p.getShortName().equals(shortName)){
                return p;
}
        }
        
        return null;
    }
    
    public PluginWrapper getPlugin(Class<? extends Plugin> pluginClazz) {
        for (PluginWrapper p : getPlugins()) {
            if (pluginClazz.isInstance(p.getPlugin())){
                return p;
}
        }
        
        return null;
    }
    
    public List<PluginWrapper> getPlugins(Class<? extends Plugin> pluginSuperclass) {
        List<PluginWrapper> result = new ArrayList<>();
        for (PluginWrapper p : getPlugins()) {
            if (pluginSuperclass.isInstance(p.getPlugin())){
                result.add(p);
}
        }
        
        return Collections.unmodifiableList(result);
    }
    
    public String getDisplayName() {
        return Messages.PluginManager_DisplayName();
    }
    
    public String getSearchUrl() {
        return "pluginManager";
    }
    
    public <T> Collection<Class<? extends T>> discover(Class<T> spi) {
        Set<Class<? extends T>> result = new HashSet<>();
        for (PluginWrapper p : activePlugins) {
            Service.load(spi, p.classLoader, result);
        }
        
        return result;
    }
    
    public PluginWrapper whichPlugin(Class c) {
        PluginWrapper oneAndOnly = null;
        ClassLoader cl = c.getClassLoader();
        for (PluginWrapper p : activePlugins) {
            if (p.classLoader == cl) {
                if (oneAndOnly != null){
                    return null;    
}
                oneAndOnly = p;
            }
            
        }
        
        if (oneAndOnly == null && Main.isUnitTest) {
            CodeSource cs = c.getProtectionDomain().getCodeSource();
            if (cs != null) {
                URL loc = cs.getLocation();
                if (loc != null) {
                    if ("file".equals(loc.getProtocol())) {
                        File file;
                        try {
                            file = Paths.get(loc.toURI()).toFile();
                        }
                         catch (InvalidPathException | URISyntaxException e) {
                            LOGGER.log(Level.WARNING, "could not inspect " + loc, e);
                            return null;
                        }
                        
                        if (file.isFile()) { 
                            try (JarFile jf = new JarFile(file)) {
                                Manifest mf = jf.getManifest();
                                if (mf != null) {
                                    java.util.jar.Attributes attr = mf.getMainAttributes();
                                    if (attr.getValue("Plugin-Version") != null) {
                                        String shortName = attr.getValue("Short-Name");
                                        LOGGER.fine(() -> "found " + shortName + " for " + c);
                                        return getPlugin(shortName);
                                    }
                                    
                                }
                                
                            }
                             catch (IOException e) {
                                LOGGER.log(Level.WARNING, "could not inspect " + loc, e);
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
        return oneAndOnly;
    }
    
    public synchronized void stop() {
        for (PluginWrapper p : activePlugins) {
            p.stop();
        }
        
        List<PluginWrapper> pluginsCopy = new ArrayList<>(plugins);
        for (PluginWrapper p : pluginsCopy) {
            activePlugins.remove(p);
            plugins.remove(p);
            p.releaseClassLoader();
        }
        
        LogFactory.release(uberClassLoader);
    }
    
    public static boolean isNonMetaLabel(String label) {
        return !("adopt-this-plugin".equals(label) || "deprecated".equals(label));
    }
    
    public static class UpdateCenterProxy implements StaplerFallback {
        public Object getStaplerFallback() {
            return Jenkins.get().getUpdateCenter();
        }
        
    }
    
    public UpdateCenterProxy getUpdates() {
        return new UpdateCenterProxy();
    }
    
    public HttpResponse doPluginsSearch(@QueryParameter String query, @QueryParameter Integer limit) {
        List<JSONObject> plugins = new ArrayList<>();
        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSiteList()) {
            List<JSONObject> sitePlugins = site.getAvailables().stream() .filter(plugin -> {
                    if (StringUtils.isBlank(query)) {
                        return true;
                    }
                    
                    return StringUtils.containsIgnoreCase(plugin.name, query) || StringUtils.containsIgnoreCase(plugin.title, query) || StringUtils.containsIgnoreCase(plugin.excerpt, query) || plugin.hasCategory(query) || plugin.getCategoriesStream() .map(UpdateCenter::getCategoryDisplayName) .anyMatch(category -> StringUtils.containsIgnoreCase(category, query)) || plugin.hasWarnings() && query.equalsIgnoreCase("warning:");
                }
) .limit(Math.max(limit - plugins.size(), 1)) .sorted((o1, o2) -> {
                    String o1DisplayName = o1.getDisplayName();
                    if (o1.name.equalsIgnoreCase(query) || o1DisplayName.equalsIgnoreCase(query)) {
                        return -1;
                    }
                    
                    String o2DisplayName = o2.getDisplayName();
                    if (o2.name.equalsIgnoreCase(query) || o2DisplayName.equalsIgnoreCase(query)) {
                        return 1;
                    }
                    
                    if (o1.name.equals(o2.name)) {
                        return 0;
                    }
                    
                    final int pop = Double.compare(o2.popularity, o1.popularity);
                    if (pop != 0) {
                        return pop; 
                    }
                    
                    return o1DisplayName.compareTo(o2DisplayName);
                }
) .map(plugin -> {
                    JSONObject jsonObject = new JSONObject();
                    jsonObject.put("name", plugin.name);
                    jsonObject.put("sourceId", plugin.sourceId);
                    jsonObject.put("title", plugin.title);
                    jsonObject.put("displayName", plugin.getDisplayName());
                    jsonObject.put("wiki", plugin.wiki);
                    jsonObject.put("categories", plugin.getCategoriesStream() .filter(PluginManager::isNonMetaLabel) .map(UpdateCenter::getCategoryDisplayName) .collect(toList()) );
                    if (hasAdoptThisPluginLabel(plugin)) {
                        jsonObject.put("adoptMe", Messages.PluginManager_adoptThisPlugin());
                    }
                    
                    if (plugin.isDeprecated()) {
                        jsonObject.put("deprecated", Messages.PluginManager_deprecationWarning(plugin.getDeprecation().url));
                    }
                    
                    jsonObject.put("excerpt", plugin.excerpt);
                    jsonObject.put("version", plugin.version);
                    jsonObject.put("popularity", plugin.popularity);
                    if (plugin.isForNewerHudson()) {
                        jsonObject.put("newerCoreRequired", Messages.PluginManager_coreWarning(plugin.requiredCore));
                    }
                    
                    if (plugin.hasWarnings()) {
                        JSONObject unresolvedSecurityWarnings = new JSONObject();
                        unresolvedSecurityWarnings.put("text", Messages.PluginManager_securityWarning());
                        Set<UpdateSite.Warning> pluginWarnings = plugin.getWarnings();
                        if (pluginWarnings == null) {
                            throw new IllegalStateException("warnings cannot be null here");
                        }
                        
                        List<JSONObject> warnings = pluginWarnings.stream() .map(warning -> {
                                JSONObject jsonWarning = new JSONObject();
                                jsonWarning.put("url", warning.url);
                                jsonWarning.put("message", warning.message);
                                return jsonWarning;
                            }
).collect(toList());
                        unresolvedSecurityWarnings.put("warnings", warnings);
                        jsonObject.put("unresolvedSecurityWarnings", unresolvedSecurityWarnings);
                    }
                    
                    if (plugin.releaseTimestamp != null) {
                        JSONObject releaseTimestamp = new JSONObject();
                        releaseTimestamp.put("iso8601", Functions.iso8601DateTime(plugin.releaseTimestamp));
                        releaseTimestamp.put("displayValue", Messages.PluginManager_ago(Functions.getTimeSpanString(plugin.releaseTimestamp)));
                        jsonObject.put("releaseTimestamp", releaseTimestamp);
                    }
                    
                    return jsonObject;
                }
) .collect(toList());
            plugins.addAll(sitePlugins);
            if (plugins.size() >= limit) {
                break;
            }
            
        }
        
        JSONArray mappedPlugins = new JSONArray();
        mappedPlugins.addAll(plugins);
        return hudson.util.HttpResponses.okJSON(mappedPlugins);
    }
    
    public HttpResponse doPlugins() {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        JSONArray response = new JSONArray();
        Map<String, JSONObject> allPlugins = new HashMap<>();
        for (PluginWrapper plugin : plugins) {
            JSONObject pluginInfo = new JSONObject();
            pluginInfo.put("installed", true);
            pluginInfo.put("name", plugin.getShortName());
            pluginInfo.put("title", plugin.getDisplayName());
            pluginInfo.put("active", plugin.isActive());
            pluginInfo.put("enabled", plugin.isEnabled());
            pluginInfo.put("bundled", plugin.isBundled);
            pluginInfo.put("deleted", plugin.isDeleted());
            pluginInfo.put("downgradable", plugin.isDowngradable());
            pluginInfo.put("website", plugin.getUrl());
            List<Dependency> dependencies = plugin.getDependencies();
            if (dependencies != null && !dependencies.isEmpty()) {
                Map<String, String> dependencyMap = new HashMap<>();
                for (Dependency dependency : dependencies) {
                    dependencyMap.put(dependency.shortName, dependency.version);
                }
                
                pluginInfo.put("dependencies", dependencyMap);
            }
             else {
                pluginInfo.put("dependencies", Collections.emptyMap());
            }
            
            response.add(pluginInfo);
        }
        
        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSiteList()) {
            for (UpdateSite.Plugin plugin : site.getAvailables()) {
                JSONObject pluginInfo = allPlugins.get(plugin.name);
                if (pluginInfo == null) {
                    pluginInfo = new JSONObject();
                    pluginInfo.put("installed", false);
                }
                
                pluginInfo.put("name", plugin.name);
                pluginInfo.put("title", plugin.getDisplayName());
                pluginInfo.put("excerpt", plugin.excerpt);
                pluginInfo.put("site", site.getId());
                pluginInfo.put("dependencies", plugin.dependencies);
                pluginInfo.put("website", plugin.wiki);
                response.add(pluginInfo);
            }
            
        }
        
        return hudson.util.HttpResponses.okJSON(response);
    }
    
    public HttpResponse doUpdateSources(StaplerRequest req) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        if (req.hasParameter("remove")) {
            UpdateCenter uc = Jenkins.get().getUpdateCenter();
            BulkChange bc = new BulkChange(uc);
            try {
                for (String id : req.getParameterValues("sources")){
                    uc.getSites().remove(uc.getById(id));
}
            }
             finally {
                bc.commit();
            }
            
        }
         else if (req.hasParameter("add")) return new HttpRedirect("addSite");
        return new HttpRedirect("./sites");
    }
    
    public void doInstallPluginsDone() {
        Jenkins j = Jenkins.get();
        j.checkPermission(Jenkins.ADMINISTER);
        InstallUtil.proceedToNextStateFrom(InstallState.INITIAL_PLUGINS_INSTALLING);
    }
    
    public void doInstall(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        Set<String> plugins = new LinkedHashSet<>();
        Enumeration<String> en = req.getParameterNames();
        while (en.hasMoreElements()) {
            String n =  en.nextElement();
            if (n.startsWith("plugin.")) {
                n = n.substring(7);
                plugins.add(n);
            }
            
        }
        
        boolean dynamicLoad = req.getParameter("dynamicLoad") != null;
        install(plugins, dynamicLoad);
        rsp.sendRedirect("updates/");
    }
    
    public HttpResponse doInstallPlugins(StaplerRequest req) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        String payload = IOUtils.toString(req.getInputStream(), req.getCharacterEncoding());
        JSONObject request = JSONObject.fromObject(payload);
        JSONArray pluginListJSON = request.getJSONArray("plugins");
        List<String> plugins = new ArrayList<>();
        for (int i = 0; i < pluginListJSON.size(); i++) {
            plugins.add(pluginListJSON.getString(i));
        }
        
        UUID correlationId = UUID.randomUUID();
        try {
            boolean dynamicLoad = request.getBoolean("dynamicLoad");
            install(plugins, dynamicLoad, correlationId);
            JSONObject responseData = new JSONObject();
            responseData.put("correlationId", correlationId.toString());
            return hudson.util.HttpResponses.okJSON(responseData);
        }
         catch (RuntimeException e) {
            return hudson.util.HttpResponses.errorJSON(e.getMessage());
        }
        
    }
    
    public List<Future<UpdateCenter.UpdateCenterJob>> install(@NonNull Collection<String> plugins, boolean dynamicLoad) {
        return install(plugins, dynamicLoad, null);
    }
    
    private List<Future<UpdateCenter.UpdateCenterJob>> install(@NonNull Collection<String> plugins, boolean dynamicLoad, @CheckForNull UUID correlationId) {
        List<Future<UpdateCenter.UpdateCenterJob>> installJobs = new ArrayList<>();
        LOGGER.log(INFO, "Starting installation of a batch of {0} plugins plus their dependencies", plugins.size());
        long start = System.nanoTime();
        List<PluginWrapper> batch = new ArrayList<>();
        for (String n : plugins) {
            int index = n.indexOf('.');
            UpdateSite.Plugin p = null;
            if (index == -1) {
                p = getPlugin(n, UpdateCenter.ID_DEFAULT);
            }
             else {
                while (index != -1) {
                    if (index + 1 >= n.length()) {
                        break;
                    }
                    
                    String pluginName = n.substring(0, index);
                    String siteName = n.substring(index + 1);
                    UpdateSite.Plugin plugin = getPlugin(pluginName, siteName);
                    if (plugin != null) {
                        if (p != null) {
                            throw new Failure("Ambiguous plugin: " + n);
                        }
                        
                        p = plugin;
                    }
                    
                    index = n.indexOf('.', index + 1);
                }
                
            }
            
            if (p == null) {
                throw new Failure("No such plugin: " + n);
            }
            
            Future<UpdateCenter.UpdateCenterJob> jobFuture = p.deploy(dynamicLoad, correlationId, batch, false);
            installJobs.add(jobFuture);
        }
        
        final Jenkins jenkins = Jenkins.get();
        final UpdateCenter updateCenter = jenkins.getUpdateCenter();
        if (dynamicLoad) {
            installJobs.add(updateCenter.addJob(updateCenter.new CompleteBatchJob(batch, start, correlationId)));
        }
        
        final Authentication currentAuth = Jenkins.getAuthentication2();
        if (!jenkins.getInstallState().isSetupComplete()) {
            jenkins.setInstallState(InstallState.INITIAL_PLUGINS_INSTALLING);
            updateCenter.persistInstallStatus();
            new Thread() {
                public void run() {
                    boolean failures = false;
                    INSTALLING: while (true) {
                        try {
                            updateCenter.persistInstallStatus();
                            Thread.sleep(500);
                            failures = false;
                            for (Future<UpdateCenter.UpdateCenterJob> jobFuture : installJobs) {
                                if (!jobFuture.isDone() && !jobFuture.isCancelled()) {
                                    continue INSTALLING;
                                }
                                
                                UpdateCenter.UpdateCenterJob job = jobFuture.get();
                                if (job instanceof InstallationJob && ((InstallationJob) job).status instanceof DownloadJob.Failure) {
                                    failures = true;
                                }
                                
                            }
                            
                        }
                         catch (Exception e) {
                            LOGGER.log(WARNING, "Unexpected error while waiting for initial plugin set to install.", e);
                        }
                        
                        break;
                    }
                    
                    updateCenter.persistInstallStatus();
                    if (!failures) {
                        try (ACLContext acl = ACL.as2(currentAuth)) {
                            InstallUtil.proceedToNextStateFrom(InstallState.INITIAL_PLUGINS_INSTALLING);
                        }
                        
                    }
                    
                }
                
            }
            .start();
        }
        
        return installJobs;
    }
    
    private UpdateSite.Plugin getPlugin(String pluginName, String siteName) {
        UpdateSite updateSite = Jenkins.get().getUpdateCenter().getById(siteName);
        if (updateSite == null) {
            throw new Failure("No such update center: " + siteName);
        }
        
        return updateSite.getPlugin(pluginName);
    }
    
    public HttpResponse doSiteConfigure(@QueryParameter String site) throws IOException {
        Jenkins hudson = Jenkins.get();
        hudson.checkPermission(Jenkins.ADMINISTER);
        UpdateCenter uc = hudson.getUpdateCenter();
        PersistedList<UpdateSite> sites = uc.getSites();
        sites.removeIf(s -> s.getId().equals(UpdateCenter.ID_DEFAULT));
        sites.add(new UpdateSite(UpdateCenter.ID_DEFAULT, site));
        return new HttpRedirect("advanced");
    }
    
    public HttpResponse doProxyConfigure(StaplerRequest req) throws IOException, ServletException {
        Jenkins jenkins = Jenkins.get();
        jenkins.checkPermission(Jenkins.ADMINISTER);
        ProxyConfiguration pc = req.bindJSON(ProxyConfiguration.class, req.getSubmittedForm());
        if (pc.name == null) {
            jenkins.proxy = null;
            ProxyConfiguration.getXmlFile().delete();
        }
         else {
            jenkins.proxy = pc;
            jenkins.proxy.save();
        }
        
        return new HttpRedirect("advanced");
    }
    
    interface PluginCopier {
        void copy(File target) throws Exception;
        void cleanup();
    }
    
    static class FileUploadPluginCopier implements PluginCopier {
        private FileItem fileItem;
        FileUploadPluginCopier(FileItem fileItem) {
            this.fileItem = fileItem;
        }
        
        public void copy(File target) throws Exception {
            fileItem.write(target);
        }
        
        public void cleanup() {
            fileItem.delete();
        }
        
    }
    
    static class UrlPluginCopier implements PluginCopier {
        private String url;
        UrlPluginCopier(String url) {
            this.url = url;
        }
        
        public void copy(File target) throws Exception {
            try (InputStream input =  ProxyConfiguration.getInputStream(new URL(url))) {
                Files.copy(input, target.toPath());
            }
            
        }
        
        public void cleanup() {
        }
        
    }
    
    public HttpResponse doUploadPlugin(StaplerRequest req) throws IOException, ServletException {
        try {
            Jenkins.get().checkPermission(Jenkins.ADMINISTER);
            String fileName = "";
            PluginCopier copier;
            ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());
            List<FileItem> items = upload.parseRequest(req);
            if (StringUtils.isNotBlank(items.get(1).getString())) {
                fileName = items.get(1).getString();
                copier = new UrlPluginCopier(fileName);
            }
             else {
                FileItem fileItem = items.get(0);
                fileName = Util.getFileName(fileItem.getName());
                copier = new FileUploadPluginCopier(fileItem);
            }
            
            if ("".equals(fileName)) {
                return new HttpRedirect("advanced");
            }
            
            if (!fileName.endsWith(".jpi") && !fileName.endsWith(".hpi")) {
                throw new Failure(hudson.model.Messages.Hudson_NotAPlugin(fileName));
            }
            
            File t = File.createTempFile("uploaded", ".jpi");
            t.deleteOnExit();
            Files.delete(Util.fileToPath(t));
            try {
                copier.copy(t);
            }
             catch (Exception e) {
                throw new ServletException(e);
            }
            
            copier.cleanup();
            final String baseName = identifyPluginShortName(t);
            pluginUploaded = true;
            JSONArray dependencies = new JSONArray();
            try {
                Manifest m;
                try (JarFile jarFile = new JarFile(t)) {
                    m = jarFile.getManifest();
                }
                
                String deps = m.getMainAttributes().getValue("Plugin-Dependencies");
                if (StringUtils.isNotBlank(deps)) {
                    String[] plugins = deps.split(",");
                    for (String p : plugins) {
                        String[] attrs = p.split("[:;]");
                        dependencies.add(new JSONObject() .element("name", attrs[0]) .element("version", attrs[1]) .element("optional", p.contains("resolution:=optional")));
                    }
                    
                }
                
            }
             catch (IOException e) {
                LOGGER.log(WARNING, "Unable to setup dependency list for plugin upload", e);
            }
            
            JSONObject cfg = new JSONObject(). element("name", baseName). element("version", "0").  element("url", t.toURI().toString()). element("dependencies", dependencies);
            new UpdateSite(UpdateCenter.ID_UPLOAD, null).new Plugin(UpdateCenter.ID_UPLOAD, cfg).deploy(true);
            return new HttpRedirect("updates/");
        }
         catch (FileUploadException e) {
            throw new ServletException(e);
        }
        
    }
    
    @RequirePOST public FormValidation doCheckPluginUrl(StaplerRequest request, @QueryParameter String value) throws IOException { if (StringUtils.isNotBlank(value)) { try { URL url = new URL(value);
                if (!url.getProtocol().startsWith("http")) {
                    return FormValidation.error(Messages.PluginManager_invalidUrl());
                }
                
                if (!url.getProtocol().equals("https")) {
                    return FormValidation.warning(Messages.PluginManager_insecureUrl());
                }
                
            }
             catch (MalformedURLException e) {
                return FormValidation.error(e.getMessage());
            }
            
        }
        
        return FormValidation.ok();
    }
    
    @RequirePOST public FormValidation doCheckUpdateSiteUrl(StaplerRequest request, @QueryParameter String value) throws InterruptedException { Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        return checkUpdateSiteURL(value);
    }
    
    @Restricted(DoNotUse.class) 
    FormValidation checkUpdateSiteURL(@CheckForNull String value) throws InterruptedException {
        value = Util.fixEmptyAndTrim(value);
        if (value == null) {
            return FormValidation.error(Messages.PluginManager_emptyUpdateSiteUrl());
        }
        
        final URI baseUri;
        try {
            baseUri = new URI(value);
        }
         catch (URISyntaxException ex) {
            return FormValidation.error(ex, Messages.PluginManager_invalidUrl());
        }
        
        if ("file".equalsIgnoreCase(baseUri.getScheme())) {
            File f = new File(baseUri);
            if (f.isFile()) {
                return FormValidation.ok();
            }
            
            return FormValidation.error(Messages.PluginManager_connectionFailed());
        }
        
        if ("https".equalsIgnoreCase(baseUri.getScheme()) || "http".equalsIgnoreCase(baseUri.getScheme())) {
            final URI uriWithQuery;
            try {
                if (baseUri.getRawQuery() == null) {
                    uriWithQuery = new URI(value + "?version=" + Jenkins.VERSION + "&uctest");
                }
                 else {
                    uriWithQuery = new URI(value + "&version=" + Jenkins.VERSION + "&uctest");
                }
                
            }
             catch (URISyntaxException e) {
                return FormValidation.error(e, Messages.PluginManager_invalidUrl());
            }
            
            HttpClient httpClient = ProxyConfiguration.newHttpClientBuilder() .connectTimeout(Duration.ofSeconds(5)) .build();
            HttpRequest httpRequest;
            try {
                httpRequest = ProxyConfiguration.newHttpRequestBuilder(uriWithQuery) .method("HEAD", HttpRequest.BodyPublishers.noBody()) .build();
            }
             catch (IllegalArgumentException e) {
                return FormValidation.error(e, Messages.PluginManager_invalidUrl());
            }
            
            try {
                java.net.http.HttpResponse<Void> httpResponse = httpClient.send( httpRequest, java.net.http.HttpResponse.BodyHandlers.discarding());
                if (100 <= httpResponse.statusCode() && httpResponse.statusCode() <= 399) {
                    return FormValidation.ok();
                }
                
                LOGGER.log(Level.FINE, "Obtained a non OK ({0}) response from the update center", new Object[] {httpResponse.statusCode(), baseUri});
                return FormValidation.error(Messages.PluginManager_connectionFailed());
            }
             catch (IOException e) {
                LOGGER.log(Level.FINE, "Failed to check update site", e);
                return FormValidation.error(e, Messages.PluginManager_connectionFailed());
            }
            
        }
        
        return FormValidation.error(Messages.PluginManager_invalidUrl());
    }
    
    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException { Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);
        Retrier<FormValidation> updateServerRetrier = new Retrier.Builder<>( this::checkUpdatesServer, (currentAttempt, result) -> result.kind == FormValidation.Kind.OK, "check updates server") .withAttempts(CHECK_UPDATE_ATTEMPTS) .withDelay(CHECK_UPDATE_SLEEP_TIME_MILLIS) .withDuringActionExceptions(new Class[] {Exception.class}) .withDuringActionExceptionListener((attempt, e) -> FormValidation.errorWithMarkup(e.getClass().getSimpleName() + ": " + e.getLocalizedMessage())) .build();
        try {
            FormValidation result = updateServerRetrier.start();
            if (!FormValidation.Kind.OK.equals(result.kind)) {
                LOGGER.log(Level.SEVERE, Messages.PluginManager_UpdateSiteError(CHECK_UPDATE_ATTEMPTS, result.getMessage()));
                if (CHECK_UPDATE_ATTEMPTS > 1 && !Logger.getLogger(Retrier.class.getName()).isLoggable(Level.WARNING)) {
                    LOGGER.log(Level.SEVERE, Messages.PluginManager_UpdateSiteChangeLogLevel(Retrier.class.getName()));
                }
                
                lastErrorCheckUpdateCenters = Messages.PluginManager_CheckUpdateServerError(result.getMessage());
            }
             else {
                lastErrorCheckUpdateCenters = null;
            }
            
        }
         catch (Exception e) {
            LOGGER.log(Level.WARNING, Messages.PluginManager_UnexpectedException(), e);
            throw new IOException(e);
        }
        
        return HttpResponses.forwardToPreviousPage();
    }
    
    private FormValidation checkUpdatesServer() throws Exception {
        for (UpdateSite site : Jenkins.get().getUpdateCenter().getSites()) {
            FormValidation v = site.updateDirectlyNow();
            if (v.kind != FormValidation.Kind.OK) {
                return v;
            }
            
        }
        
        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {
            FormValidation v = d.updateNow();
            if (v.kind != FormValidation.Kind.OK) {
                return v;
            }
            
        }
        
        return FormValidation.ok();
    }
    
    public String getLastErrorCheckUpdateCenters() {
        return lastErrorCheckUpdateCenters;
    }
    
    protected String identifyPluginShortName(File t) {
        try {
            try (JarFile j = new JarFile(t)) {
                String name = j.getManifest().getMainAttributes().getValue("Short-Name");
                if (name != null) return name;
            }
            
        }
         catch (IOException e) {
            LOGGER.log(WARNING, "Failed to identify the short name from " + t, e);
        }
        
        return FilenameUtils.getBaseName(t.getName());    
    }
    
    public Descriptor<ProxyConfiguration> getProxyDescriptor() {
        return Jenkins.get().getDescriptor(ProxyConfiguration.class);
    }
    
    public List<Future<UpdateCenter.UpdateCenterJob>> prevalidateConfig(InputStream configXml) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        List<Future<UpdateCenter.UpdateCenterJob>> jobs = new ArrayList<>();
        UpdateCenter uc = Jenkins.get().getUpdateCenter();
        for (Map.Entry<String, VersionNumber> requestedPlugin : parseRequestedPlugins(configXml).entrySet()) {
            PluginWrapper pw = getPlugin(requestedPlugin.getKey());
            if (pw == null) { 
                UpdateSite.Plugin toInstall = uc.getPlugin(requestedPlugin.getKey(), requestedPlugin.getValue());
                if (toInstall == null) {
                    LOGGER.log(WARNING, "No such plugin {0} to install", requestedPlugin.getKey());
                    continue;
                }
                
                logPluginWarnings(requestedPlugin, toInstall);
                jobs.add(toInstall.deploy(true));
            }
             else if (pw.isOlderThan(requestedPlugin.getValue())) { 
                UpdateSite.Plugin toInstall = uc.getPlugin(requestedPlugin.getKey(), requestedPlugin.getValue());
                if (toInstall == null) {
                    LOGGER.log(WARNING, "No such plugin {0} to upgrade", requestedPlugin.getKey());
                    continue;
                }
                
                if (!pw.isOlderThan(new VersionNumber(toInstall.version))) {
                    LOGGER.log(WARNING, "{0}@{1} is no newer than what we already have", new Object[] {toInstall.name, toInstall.version});
                    continue;
                }
                
                logPluginWarnings(requestedPlugin, toInstall);
                if (!toInstall.isCompatibleWithInstalledVersion()) {
                    LOGGER.log(WARNING, "{0}@{1} is incompatible with the installed @{2}", new Object[] {toInstall.name, toInstall.version, pw.getVersion()});
                }
                
                jobs.add(toInstall.deploy(true)); 
            }
             
        }
        
        return jobs;
    }
    
    private void logPluginWarnings(Map.Entry<String, VersionNumber> requestedPlugin, UpdateSite.Plugin toInstall) {
        if (new VersionNumber(toInstall.version).compareTo(requestedPlugin.getValue()) < 0) {
            LOGGER.log(WARNING, "{0} can only be satisfied in @{1}", new Object[] {requestedPlugin, toInstall.version});
        }
        
        if (toInstall.isForNewerHudson()) {
            LOGGER.log(WARNING, "{0}@{1} was built for a newer Jenkins", new Object[] {toInstall.name, toInstall.version});
        }
        
    }
    
    public JSONArray doPrevalidateConfig(StaplerRequest req) throws IOException {
        Jenkins.get().checkPermission(Jenkins.ADMINISTER);
        JSONArray response = new JSONArray();
        for (Map.Entry<String, VersionNumber> p : parseRequestedPlugins(req.getInputStream()).entrySet()) {
            PluginWrapper pw = getPlugin(p.getKey());
            JSONObject j = new JSONObject() .accumulate("name", p.getKey()) .accumulate("version", p.getValue().toString());
            if (pw == null) { 
                response.add(j.accumulate("mode", "missing"));
            }
             else if (pw.isOlderThan(p.getValue())) { 
                response.add(j.accumulate("mode", "old"));
            }
             
        }
        
        return response;
    }
    
    public HttpResponse doInstallNecessaryPlugins(StaplerRequest req) throws IOException {
        prevalidateConfig(req.getInputStream());
        return HttpResponses.redirectViaContextPath("updates/");
    }
    
    public Map<String, VersionNumber> parseRequestedPlugins(InputStream configXml) throws IOException {
        final Map<String, VersionNumber> requestedPlugins = new TreeMap<>();
        try {
            SAXParserFactory spf = SAXParserFactory.newInstance();
            spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
            spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
            spf.newSAXParser().parse(configXml, new DefaultHandler() {
 public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
                    String plugin = attributes.getValue("plugin");
                    if (plugin == null) {
                        return;
                    }
                    
                    if (!plugin.matches("[^@]+@[^@]+")) {
                        throw new SAXException("Malformed plugin attribute: " + plugin);
                    }
                    
                    int at = plugin.indexOf('@');
                    String shortName = plugin.substring(0, at);
                    VersionNumber existing = requestedPlugins.get(shortName);
                    VersionNumber requested = new VersionNumber(plugin.substring(at + 1));
                    if (existing == null || existing.compareTo(requested) < 0) {
                        requestedPlugins.put(shortName, requested);
                    }
                    
                }
                
 public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {
                    return RestrictiveEntityResolver.INSTANCE.resolveEntity(publicId, systemId);
                }
                
            }
            
);
        }
         catch (SAXException x) {
            throw new IOException("Failed to parse XML", x);
        }
         catch (ParserConfigurationException e) {
            throw new AssertionError(e); 
        }
        
        return requestedPlugins;
    }
    
    public MetadataCache createCache() {
        return new MetadataCache();
    }
    
    public @NonNull List<PluginWrapper.PluginDisableResult> disablePlugins(@NonNull PluginWrapper.PluginDisableStrategy strategy, @NonNull List<String> plugins) throws IOException {
        List<PluginWrapper.PluginDisableResult> results = new ArrayList<>(plugins.size());
        for (String pluginName : plugins) {
            PluginWrapper plugin = this.getPlugin(pluginName);
            if (plugin == null) {
                results.add(new PluginWrapper.PluginDisableResult(pluginName, PluginWrapper.PluginDisableStatus.NO_SUCH_PLUGIN, Messages.PluginWrapper_NoSuchPlugin(pluginName)));
            }
             else {
                results.add(plugin.disable(strategy));
            }
            
        }
        
        return results;
    }
    
    public static final class MetadataCache {
        private final Map<String, Object> data = new HashMap<>();
        public <T> T of(String key, Class<T> type, Supplier<T> func) {
            return type.cast(data.computeIfAbsent(key, _ignored -> func.get()));
        }
        
    }
    
    public static final class UberClassLoader extends ClassLoader {
        private final List<PluginWrapper> activePlugins;
        private final ConcurrentMap<String, Optional<Class<?>>> loaded = new ConcurrentHashMap<>();
        static {
            registerAsParallelCapable();
        }
        
        public UberClassLoader(List<PluginWrapper> activePlugins) {
            super(PluginManager.class.getClassLoader());
            this.activePlugins = activePlugins;
        }
        
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            if (name.startsWith("SimpleTemplateScript")) { 
                throw new ClassNotFoundException("ignoring " + name);
            }
            
            return loaded.computeIfAbsent(name, this::computeValue).orElseThrow(() -> new ClassNotFoundException(name));
        }
        
        private Optional<Class<?>> computeValue(String name) {
            for (PluginWrapper p : activePlugins) {
                try {
                    if (FAST_LOOKUP) {
                        return Optional.of(ClassLoaderReflectionToolkit.loadClass(p.classLoader, name));
                    }
                     else {
                        return Optional.of(p.classLoader.loadClass(name));
                    }
                    
                }
                 catch (ClassNotFoundException e) {
                }
                
            }
            
            return Optional.empty();
        }
        
        protected URL findResource(String name) {
            for (PluginWrapper p : activePlugins) {
                URL url;
                if (FAST_LOOKUP) {
                    url = ClassLoaderReflectionToolkit._findResource(p.classLoader, name);
                }
                 else {
                    url = p.classLoader.getResource(name);
                }
                
                if (url != null) {
                    return url;
                }
                
            }
            
            return null;
        }
        
        protected Enumeration<URL> findResources(String name) throws IOException {
            List<URL> resources = new ArrayList<>();
            for (PluginWrapper p : activePlugins) {
                if (FAST_LOOKUP) {
                    resources.addAll(Collections.list(ClassLoaderReflectionToolkit._findResources(p.classLoader, name)));
                }
                 else {
                    resources.addAll(Collections.list(p.classLoader.getResources(name)));
                }
                
            }
            
            return Collections.enumeration(resources);
        }
        
        public String toString() {
            return "classLoader " +  getClass().getName();
        }
        
    }
    
    @SuppressFBWarnings(value = "MS_SHOULD_BE_FINAL", justification = "for script console")
    public static boolean FAST_LOOKUP = !SystemProperties.getBoolean(PluginManager.class.getName() + ".noFastLookup");
    public static final Permission UPLOAD_PLUGINS = new Permission(Jenkins.PERMISSIONS, "UploadPlugins", Messages._PluginManager_UploadPluginsPermission_Description(), Jenkins.ADMINISTER, PermissionScope.JENKINS);
    public static final Permission CONFIGURE_UPDATECENTER = new Permission(Jenkins.PERMISSIONS, "ConfigureUpdateCenter", Messages._PluginManager_ConfigureUpdateCenterPermission_Description(), Jenkins.ADMINISTER, PermissionScope.JENKINS);
    public static final class FailedPlugin {
        public final String name;
        public final Exception cause;
        public final PluginWrapper pluginWrapper;
        public FailedPlugin(String name, Exception cause) {
            this.name = name;
            this.cause = cause;
            this.pluginWrapper = null;
        }
        
        public FailedPlugin(PluginWrapper pluginWrapper, Exception cause) {
            this.name = pluginWrapper.getShortName();
            this.cause = cause;
            this.pluginWrapper = pluginWrapper;
        }
        
        public String getExceptionString() {
            return Functions.printThrowable(cause);
        }
        
    }
    
     static final class PluginInstanceStore {
        final Map<PluginWrapper, Plugin> store = new ConcurrentHashMap<>();
    }
    
    @Extension @Symbol("pluginCycleDependencies")
    public static final class PluginCycleDependenciesMonitor extends AdministrativeMonitor {
        public String getDisplayName() {
            return Messages.PluginManager_PluginCycleDependenciesMonitor_DisplayName();
        }
        
        private transient volatile boolean isActive = false;
        private transient volatile List<PluginWrapper> pluginsWithCycle;
        public boolean isActivated() {
            if (pluginsWithCycle == null) {
                pluginsWithCycle = new ArrayList<>();
                for (PluginWrapper p : Jenkins.get().getPluginManager().getPlugins()) {
                    if (p.hasCycleDependency()) {
                        pluginsWithCycle.add(p);
                        isActive = true;
                    }
                    
                }
                
            }
            
            return isActive;
        }
        
        public List<PluginWrapper> getPluginsWithCycle() {
            return pluginsWithCycle;
        }
        
    }
    
    @Extension @Symbol("pluginUpdate")
    public static final class PluginUpdateMonitor extends AdministrativeMonitor {
        private Map<String, PluginUpdateInfo> pluginsToBeUpdated = new HashMap<>();
        public static PluginUpdateMonitor getInstance() {
            return ExtensionList.lookupSingleton(PluginUpdateMonitor.class);
        }
        
        public void ifPluginOlderThenReport(String pluginName, String requiredVersion, String message) {
            Plugin plugin = Jenkins.get().getPlugin(pluginName);
            if (plugin != null) {
                if (plugin.getWrapper().getVersionNumber().isOlderThan(new VersionNumber(requiredVersion))) {
                    pluginsToBeUpdated.put(pluginName, new PluginUpdateInfo(pluginName, message));
                }
                
            }
            
        }
        
        public boolean isActivated() {
            return !pluginsToBeUpdated.isEmpty();
        }
        
        public String getDisplayName() {
            return Messages.PluginManager_PluginUpdateMonitor_DisplayName();
        }
        
        public void addPluginToUpdate(String pluginName, String message) {
            this.pluginsToBeUpdated.put(pluginName, new PluginUpdateInfo(pluginName, message));
        }
        
        public Collection<PluginUpdateInfo> getPluginsToBeUpdated() {
            return pluginsToBeUpdated.values();
        }
        
        public static class PluginUpdateInfo {
            public final String pluginName;
            public final String message;
            private PluginUpdateInfo(String pluginName, String message) {
                this.pluginName = pluginName;
                this.message = message;
            }
            
        }
        
    }
    
    public static final class PluginDeprecationMonitor extends AdministrativeMonitor {
        public String getDisplayName() {
            return Messages.PluginManager_PluginDeprecationMonitor_DisplayName();
        }
        
        public boolean isActivated() {
            return !getDeprecatedPlugins().isEmpty();
        }
        
        public Map<PluginWrapper, String> getDeprecatedPlugins() {
            return Jenkins.get().getPluginManager().getPlugins().stream() .filter(PluginWrapper::isDeprecated) .collect(Collectors.toMap(Function.identity(), it -> it.getDeprecations().get(0).url));
        }
        
    }
    
    public String unscientific(double d) {
        return String.format(Locale.US, "%15.4f", d);
    }
    
    public Object getTarget() {
        if (!SKIP_PERMISSION_CHECK) {
            Jenkins.get().checkPermission(Jenkins.SYSTEM_READ);
        }
        
        return this;
    }
    
    public boolean isMetaLabel(String label) {
        return "adopt-this-plugin".equals(label) || "deprecated".equals(label);
    }
    
    public boolean hasAdoptThisPluginLabel(UpdateSite.Plugin plugin) {
        return plugin.hasCategory("adopt-this-plugin");
    }
    
    public boolean hasAdoptThisPluginLabel(PluginWrapper plugin) {
        final UpdateSite.Plugin pluginMeta = Jenkins.get().getUpdateCenter().getPlugin(plugin.getShortName());
        if (pluginMeta == null) {
            return false;
        }
        
        return pluginMeta.hasCategory("adopt-this-plugin");
    }
    
    @SuppressFBWarnings(value = "MS_SHOULD_BE_FINAL", justification = "for script console")
    public static  boolean SKIP_PERMISSION_CHECK = SystemProperties.getBoolean(PluginManager.class.getName() + ".skipPermissionCheck");
}


