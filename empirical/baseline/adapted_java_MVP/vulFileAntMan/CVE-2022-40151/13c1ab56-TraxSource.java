package com.thoughtworks.xstream.io.xml;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.Supplier;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLFilter;
import org.xml.sax.XMLReader;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.core.util.CustomObjectOutputStream;
import com.thoughtworks.xstream.core.util.ListWrappingQueue;
import com.thoughtworks.xstream.io.StreamException;
import com.thoughtworks.xstream.mapper.Mapper;
public class TraxSource extends SAXSource {
    public final static String XSTREAM_FEATURE = "http://com.thoughtworks.xstream/XStreamSource/feature";
    private final static Mapper.Null NULL = new Mapper.Null();
    private XMLReader xmlReader = null;
    private SaxWriter saxWriter = null;
    private XStream xstream = null;
    private Queue<?> source = null;
    public TraxSource() {
        super(new InputSource());
    }
    
    public TraxSource(final Object source) {
        super(new InputSource());
        setSource(source);
    }
    
    public TraxSource(final Object source, final XStream xstream) {
        super(new InputSource());
        setSource(source);
        setXStream(xstream);
    }
    
    public TraxSource(final List<?> source) {
        super(new InputSource());
        setSourceAsList(source);
    }
    
    public TraxSource(final List<?> source, final XStream xstream) {
        super(new InputSource());
        setSourceAsList(source);
        setXStream(xstream);
    }
    
    public void setInputSource(final InputSource inputSource) {
        throw new UnsupportedOperationException();
    }
    
    public void setXMLReader(final XMLReader reader) {
        createXMLReader(reader);
    }
    
    public XMLReader getXMLReader() {
        if (xmlReader == null) {
            createXMLReader(null);
        }
        
        return xmlReader;
    }
    
    public void setXStream(final XStream xstream) {
        if (xstream == null) {
            throw new IllegalArgumentException("xstream");
        }
        
        this.xstream = xstream;
        configureXMLReader();
    }
    
    public void setSource(final Object obj) {
        if (obj == null) {
            throw new IllegalArgumentException("obj");
        }
        
        final List<Object> list = new LinkedList<>();
        list.add(obj);
        setSourceAsList(list);
    }
    
    public void setSourceAsList(final List<?> list) {
        if (list == null || list.isEmpty()) {
            throw new IllegalArgumentException("list");
        }
        
        @SuppressWarnings("unchecked")
        final List<Object> olist = (List<Object>)list;
        source = list instanceof Queue ? (Queue<?>)list : new ListWrappingQueue<Object>(olist);
        configureXMLReader();
    }
    
    private void createXMLReader(final XMLReader filterChain) {
        if (filterChain == null) {
            xmlReader = saxWriter = new SaxWriter();
        }
         else {
            if (filterChain instanceof XMLFilter) {
                XMLFilter filter = (XMLFilter)filterChain;
                while (filter.getParent() instanceof XMLFilter) {
                    filter = (XMLFilter)filter.getParent();
                }
                
                if (!(filter.getParent() instanceof SaxWriter)) {
                    saxWriter = new SaxWriter();
                    filter.setParent(saxWriter);
                }
                
                xmlReader = filterChain;
            }
             else {
                throw new UnsupportedOperationException();
            }
            
        }
        
        configureXMLReader();
    }
    
    private void configureXMLReader() {
        if (xmlReader != null) {
            try {
                if (xstream != null) {
                    xmlReader.setProperty(SaxWriter.CONFIGURED_XSTREAM_PROPERTY, xstream);
                }
                
                if (source != null) {
                    xmlReader.setProperty(SaxWriter.SOURCE_OBJECT_QUEUE_PROPERTY, source);
                }
                
            }
             catch (final SAXException e) {
                throw new IllegalArgumentException(e.getMessage());
            }
            
        }
        
    }
    
    public ObjectOutputStream createObjectOutputStream(final Source stylesheet,  final OutputStream target) throws IOException, TransformerConfigurationException {
        return createObjectOutputStream(stylesheet, new OutputStreamWriter(target, StandardCharsets.UTF_8));
    }
    
    public ObjectOutputStream createObjectOutputStream(final Templates stylesheet, final OutputStream target) throws IOException {
        return createObjectOutputStream(stylesheet, new OutputStreamWriter(target, StandardCharsets.UTF_8));
    }
    
    public ObjectOutputStream createObjectOutputStream(final Source stylesheet, final Writer writer) throws IOException, TransformerConfigurationException {
        return createObjectOutputStream(stylesheet, writer, "object-stream");
    }
    
    public ObjectOutputStream createObjectOutputStream(final Templates stylesheet, final Writer writer) throws IOException {
        return createObjectOutputStream(stylesheet, writer, "object-stream");
    }
    
    public ObjectOutputStream createObjectOutputStream(final Source stylesheet, final OutputStream target, final String rootNodeName) throws IOException, TransformerConfigurationException {
        return createObjectOutputStream(stylesheet, new OutputStreamWriter(target, StandardCharsets.UTF_8), rootNodeName);
    }
    
    public ObjectOutputStream createObjectOutputStream(final Templates stylesheet, final OutputStream target, final String rootNodeName) throws IOException {
        return createObjectOutputStream(stylesheet, new OutputStreamWriter(target, StandardCharsets.UTF_8), rootNodeName);
    }
    
    public ObjectOutputStream createObjectOutputStream(final Source stylesheet, final Writer writer, final String rootNodeName) throws IOException, TransformerConfigurationException {
        final Templates templates = TransformerFactory.newInstance().newTemplates(stylesheet);
        return createObjectOutputStream(templates, writer, rootNodeName);
    }
    
    public ObjectOutputStream createObjectOutputStream(final Templates stylesheet, final Writer writer, final String rootNodeName) throws IOException {
        getXMLReader();
        final CompletableFuture<CustomObjectOutputStream> future = new CompletableFuture<>();
        final BlockingQueue<Object> queue = new LinkedBlockingQueue<>();
        final Supplier<CustomObjectOutputStream> supplier = () -> {
            try {
                @SuppressWarnings("resource")
                final CustomObjectOutputStream customObjectOutputStream = (CustomObjectOutputStream)xstream .createObjectOutputStream(saxWriter, rootNodeName);
                future.complete(customObjectOutputStream);
                return customObjectOutputStream;
            }
             catch (final IOException e) {
                throw new StreamException(e);
            }
            
        };
        try {
            xmlReader.setProperty(SaxWriter.OOS_SUPPLIER_PROPERTY, supplier);
            xmlReader.setProperty(SaxWriter.SOURCE_OBJECT_QUEUE_PROPERTY, queue);
        }
         catch (SAXNotRecognizedException | SAXNotSupportedException e) {
            throw new IllegalArgumentException(e.getMessage());
        }
        
        final TransformerException transEx[] = new TransformerException[1];
        final Thread t = new Thread(() -> {
            Transformer transformer;
            try {
                transformer = stylesheet.newTransformer();
                transformer.transform(this, new StreamResult(writer));
            }
             catch (final TransformerException e) {
                transEx[0] = e;
            }
            
        }
        
);
        t.start();
        t.setName("XStream OutputObjectStream Transformer");
        try {
            final CustomObjectOutputStream customObjectOutputStream = future.get();
            final CustomObjectOutputStream.StreamCallback callback = customObjectOutputStream.popCallback();
            customObjectOutputStream.pushCallback(new CustomObjectOutputStream.StreamCallback() {
                public void writeToStream(final Object object) throws IOException {
                    if (Thread.currentThread() == t) {
                        callback.writeToStream(object == NULL ? null : object);
                    }
                     else {
                        TraxSource.checkException(transEx[0]);
                        try {
                            queue.put(object == null ? NULL : object);
                        }
                         catch (final InterruptedException e) {
                            throw new InterruptedIOException();
                        }
                        
                    }
                    
                }
                
                public void writeFieldsToStream(final Map<String, Object> fields) throws IOException {
                    callback.writeFieldsToStream(fields);
                }
                
                public void defaultWriteObject() throws IOException {
                    callback.defaultWriteObject();
                }
                
                public void flush() throws IOException {
                    callback.flush();
                }
                
                public void close() throws IOException {
                    if (Thread.currentThread() == t) {
                        callback.close();
                    }
                     else {
                        TraxSource.checkException(transEx[0]);
                        writeToStream(SaxWriter.EOS);
                        try {
                            t.join();
                        }
                         catch (final InterruptedException e) {
                            throw new InterruptedIOException();
                        }
                        
                    }
                    
                }
                
            }
            
);
            checkException(transEx[0]);
            return customObjectOutputStream;
        }
         catch (InterruptedException | ExecutionException e) {
            throw new StreamException("Failed to communicate with transformation thread", e);
        }
        
    }
    
    private static void checkException(final TransformerException transformerException) throws Error, IOException {
        if (transformerException != null) {
            final Throwable e = transformerException.getCause();
            if (e instanceof Error) {
                throw (Error)e;
            }
             else if (e instanceof RuntimeException) {
                throw (RuntimeException)e;
            }
             else if (e instanceof IOException) {
                throw (IOException)e;
            }
            
            throw new StreamException("XSLT transformation failed", transformerException);
        }
        
    }
    
}


