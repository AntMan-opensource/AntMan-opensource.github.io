package org.elasticsearch.ingest;
import org.elasticsearch.common.Strings;
import org.elasticsearch.common.util.LazyMap;
import org.elasticsearch.index.VersionType;
import org.elasticsearch.index.mapper.IdFieldMapper;
import org.elasticsearch.index.mapper.IndexFieldMapper;
import org.elasticsearch.index.mapper.RoutingFieldMapper;
import org.elasticsearch.index.mapper.SourceFieldMapper;
import org.elasticsearch.index.mapper.TypeFieldMapper;
import org.elasticsearch.index.mapper.VersionFieldMapper;
import org.elasticsearch.script.TemplateScript;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiConsumer;
public final class IngestDocument {
    public static final String INGEST_KEY = "_ingest";
    public static final String PIPELINE_CYCLE_ERROR_MESSAGE = "Cycle detected for pipeline: ";
    private static final String INGEST_KEY_PREFIX = INGEST_KEY + ".";
    private static final String SOURCE_PREFIX = SourceFieldMapper.NAME + ".";
    static final String TIMESTAMP = "timestamp";
    private final Map<String, Object> sourceAndMetadata;
    private final Map<String, Object> ingestMetadata;
    private final Set<String> executedPipelines = new LinkedHashSet<>();
    public IngestDocument( String index, String type, String id, String routing, Long version, VersionType versionType, Map<String, Object> source ) {
        this.sourceAndMetadata = new HashMap<>();
        this.sourceAndMetadata.putAll(source);
        this.sourceAndMetadata.put(Metadata.INDEX.getFieldName(), index);
        this.sourceAndMetadata.put(Metadata.TYPE.getFieldName(), type);
        this.sourceAndMetadata.put(Metadata.ID.getFieldName(), id);
        if (routing != null) {
            this.sourceAndMetadata.put(Metadata.ROUTING.getFieldName(), routing);
        }
        
        if (version != null) {
            sourceAndMetadata.put(Metadata.VERSION.getFieldName(), version);
        }
        
        if (versionType != null) {
            sourceAndMetadata.put(Metadata.VERSION_TYPE.getFieldName(), VersionType.toString(versionType));
        }
        
        this.ingestMetadata = new HashMap<>();
        this.ingestMetadata.put(TIMESTAMP, ZonedDateTime.now(ZoneOffset.UTC));
    }
    
    public IngestDocument(IngestDocument other) {
        this(deepCopyMap(other.sourceAndMetadata), deepCopyMap(other.ingestMetadata));
    }
    
    public IngestDocument(Map<String, Object> sourceAndMetadata, Map<String, Object> ingestMetadata) {
        this.sourceAndMetadata = sourceAndMetadata;
        this.ingestMetadata = ingestMetadata;
    }
    
    public <T> T getFieldValue(String path, Class<T> clazz) {
        FieldPath fieldPath = new FieldPath(path);
        Object context = fieldPath.initialContext;
        for (String pathElement : fieldPath.pathElements) {
            context = resolve(pathElement, path, context);
        }
        
        return cast(path, context, clazz);
    }
    
    public <T> T getFieldValue(String path, Class<T> clazz, boolean ignoreMissing) {
        try {
            return getFieldValue(path, clazz);
        }
         catch (IllegalArgumentException e) {
            if (ignoreMissing && hasField(path) != true) {
                return null;
            }
             else {
                throw e;
            }
            
        }
        
    }
    
    public <T> T getFieldValue(TemplateScript.Factory pathTemplate, Class<T> clazz) {
        return getFieldValue(renderTemplate(pathTemplate), clazz);
    }
    
    public byte[] getFieldValueAsBytes(String path) {
        return getFieldValueAsBytes(path, false);
    }
    
    public byte[] getFieldValueAsBytes(String path, boolean ignoreMissing) {
        Object object = getFieldValue(path, Object.class, ignoreMissing);
        if (object == null) {
            return null;
        }
         else if (object instanceof byte[]) {
            return (byte[]) object;
        }
         else if (object instanceof String) {
            return Base64.getDecoder().decode(object.toString());
        }
         else {
            throw new IllegalArgumentException( "Content field [" + path + "] of unknown type [" + object.getClass().getName() + "], must be string or byte array" );
        }
        
    }
    
    public boolean hasField(TemplateScript.Factory fieldPathTemplate) {
        return hasField(renderTemplate(fieldPathTemplate));
    }
    
    public boolean hasField(String path) {
        return hasField(path, false);
    }
    
    public boolean hasField(String path, boolean failOutOfRange) {
        FieldPath fieldPath = new FieldPath(path);
        Object context = fieldPath.initialContext;
        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {
            String pathElement = fieldPath.pathElements[i];
            if (context == null) {
                return false;
            }
            
            if (context instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> map = (Map<String, Object>) context;
                context = map.get(pathElement);
            }
             else if (context instanceof List) {
                @SuppressWarnings("unchecked")
                List<Object> list = (List<Object>) context;
                try {
                    int index = Integer.parseInt(pathElement);
                    if (index < 0 || index >= list.size()) {
                        if (failOutOfRange) {
                            throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]" );
                        }
                         else {
                            return false;
                        }
                        
                    }
                    
                    context = list.get(index);
                }
                 catch (NumberFormatException e) {
                    return false;
                }
                
            }
             else {
                return false;
            }
            
        }
        
        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];
        if (context instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> map = (Map<String, Object>) context;
            return map.containsKey(leafKey);
        }
        
        if (context instanceof List) {
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) context;
            try {
                int index = Integer.parseInt(leafKey);
                if (index >= 0 && index < list.size()) {
                    return true;
                }
                 else {
                    if (failOutOfRange) {
                        throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]" );
                    }
                     else {
                        return false;
                    }
                    
                }
                
            }
             catch (NumberFormatException e) {
                return false;
            }
            
        }
        
        return false;
    }
    
    public void removeField(TemplateScript.Factory fieldPathTemplate) {
        removeField(renderTemplate(fieldPathTemplate));
    }
    
    public void removeField(String path) {
        FieldPath fieldPath = new FieldPath(path);
        Object context = fieldPath.initialContext;
        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {
            context = resolve(fieldPath.pathElements[i], path, context);
        }
        
        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];
        if (context instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> map = (Map<String, Object>) context;
            if (map.containsKey(leafKey)) {
                map.remove(leafKey);
                return;
            }
            
            throw new IllegalArgumentException("field [" + leafKey + "] not present as part of path [" + path + "]");
        }
        
        if (context instanceof List) {
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) context;
            int index;
            try {
                index = Integer.parseInt(leafKey);
            }
             catch (NumberFormatException e) {
                throw new IllegalArgumentException( "[" + leafKey + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e );
            }
            
            if (index < 0 || index >= list.size()) {
                throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]" );
            }
            
            list.remove(index);
            return;
        }
        
        if (context == null) {
            throw new IllegalArgumentException("cannot remove [" + leafKey + "] from null as part of path [" + path + "]");
        }
        
        throw new IllegalArgumentException( "cannot remove [" + leafKey + "] from object of type [" + context.getClass().getName() + "] as part of path [" + path + "]" );
    }
    
    private static Object resolve(String pathElement, String fullPath, Object context) {
        if (context == null) {
            throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from null as part of path [" + fullPath + "]");
        }
        
        if (context instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> map = (Map<String, Object>) context;
            if (map.containsKey(pathElement)) {
                return map.get(pathElement);
            }
            
            throw new IllegalArgumentException("field [" + pathElement + "] not present as part of path [" + fullPath + "]");
        }
        
        if (context instanceof List) {
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) context;
            int index;
            try {
                index = Integer.parseInt(pathElement);
            }
             catch (NumberFormatException e) {
                throw new IllegalArgumentException( "[" + pathElement + "] is not an integer, cannot be used as an index as part of path [" + fullPath + "]", e );
            }
            
            if (index < 0 || index >= list.size()) {
                throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + fullPath + "]" );
            }
            
            return list.get(index);
        }
        
        throw new IllegalArgumentException( "cannot resolve [" + pathElement + "] from object of type [" + context.getClass().getName() + "] as part of path [" + fullPath + "]" );
    }
    
    public void appendFieldValue(String path, Object value) {
        appendFieldValue(path, value, true);
    }
    
    public void appendFieldValue(String path, Object value, boolean allowDuplicates) {
        setFieldValue(path, value, true, allowDuplicates);
    }
    
    public void appendFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource) {
        Map<String, Object> model = createTemplateModel();
        appendFieldValue(fieldPathTemplate.newInstance(model).execute(), valueSource.copyAndResolve(model));
    }
    
    public void appendFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource, boolean allowDuplicates) {
        Map<String, Object> model = createTemplateModel();
        appendFieldValue(fieldPathTemplate.newInstance(model).execute(), valueSource.copyAndResolve(model), allowDuplicates);
    }
    
    public void setFieldValue(String path, Object value) {
        setFieldValue(path, value, false);
    }
    
    public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource) {
        Map<String, Object> model = createTemplateModel();
        setFieldValue(fieldPathTemplate.newInstance(model).execute(), valueSource.copyAndResolve(model), false);
    }
    
    public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource, boolean ignoreEmptyValue) {
        Map<String, Object> model = createTemplateModel();
        Object value = valueSource.copyAndResolve(model);
        if (ignoreEmptyValue && valueSource instanceof ValueSource.TemplatedValue) {
            if (value == null) {
                return;
            }
            
            String valueStr = (String) value;
            if (valueStr.isEmpty()) {
                return;
            }
            
        }
        
        setFieldValue(fieldPathTemplate.newInstance(model).execute(), value, false);
    }
    
    public void setFieldValue(TemplateScript.Factory fieldPathTemplate, Object value, boolean ignoreEmptyValue) {
        Map<String, Object> model = createTemplateModel();
        if (ignoreEmptyValue) {
            if (value == null) {
                return;
            }
            
            if (value instanceof String) {
                String valueStr = (String) value;
                if (valueStr.isEmpty()) {
                    return;
                }
                
            }
            
        }
        
        setFieldValue(fieldPathTemplate.newInstance(model).execute(), value, false);
    }
    
    private void setFieldValue(String path, Object value, boolean append) {
        setFieldValue(path, value, append, true);
    }
    
    private void setFieldValue(String path, Object value, boolean append, boolean allowDuplicates) {
        FieldPath fieldPath = new FieldPath(path);
        Object context = fieldPath.initialContext;
        for (int i = 0; i < fieldPath.pathElements.length - 1; i++) {
            String pathElement = fieldPath.pathElements[i];
            if (context == null) {
                throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from null as part of path [" + path + "]");
            }
            
            if (context instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, Object> map = (Map<String, Object>) context;
                if (map.containsKey(pathElement)) {
                    context = map.get(pathElement);
                }
                 else {
                    HashMap<Object, Object> newMap = new HashMap<>();
                    map.put(pathElement, newMap);
                    context = newMap;
                }
                
            }
             else if (context instanceof List) {
                @SuppressWarnings("unchecked")
                List<Object> list = (List<Object>) context;
                int index;
                try {
                    index = Integer.parseInt(pathElement);
                }
                 catch (NumberFormatException e) {
                    throw new IllegalArgumentException( "[" + pathElement + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e );
                }
                
                if (index < 0 || index >= list.size()) {
                    throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]" );
                }
                
                context = list.get(index);
            }
             else {
                throw new IllegalArgumentException( "cannot resolve [" + pathElement + "] from object of type [" + context.getClass().getName() + "] as part of path [" + path + "]" );
            }
            
        }
        
        String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1];
        if (context == null) {
            throw new IllegalArgumentException("cannot set [" + leafKey + "] with null parent as part of path [" + path + "]");
        }
        
        if (context instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> map = (Map<String, Object>) context;
            if (append) {
                if (map.containsKey(leafKey)) {
                    Object object = map.get(leafKey);
                    Object list = appendValues(object, value, allowDuplicates);
                    if (list != object) {
                        map.put(leafKey, list);
                    }
                    
                }
                 else {
                    List<Object> list = new ArrayList<>();
                    appendValues(list, value);
                    map.put(leafKey, list);
                }
                
                return;
            }
            
            map.put(leafKey, value);
        }
         else if (context instanceof List) {
            @SuppressWarnings("unchecked")
            List<Object> list = (List<Object>) context;
            int index;
            try {
                index = Integer.parseInt(leafKey);
            }
             catch (NumberFormatException e) {
                throw new IllegalArgumentException( "[" + leafKey + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e );
            }
            
            if (index < 0 || index >= list.size()) {
                throw new IllegalArgumentException( "[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]" );
            }
            
            if (append) {
                Object object = list.get(index);
                Object newList = appendValues(object, value, allowDuplicates);
                if (newList != object) {
                    list.set(index, newList);
                }
                
                return;
            }
            
            list.set(index, value);
        }
         else {
            throw new IllegalArgumentException( "cannot set [" + leafKey + "] with parent object of type [" + context.getClass().getName() + "] as part of path [" + path + "]" );
        }
        
    }
    
    private static Object appendValues(Object maybeList, Object value, boolean allowDuplicates) {
        List<Object> list;
        if (maybeList instanceof List) {
            list = (List<Object>) maybeList;
        }
         else {
            list = new ArrayList<>();
            list.add(maybeList);
        }
        
        if (allowDuplicates) {
            appendValues(list, value);
            return list;
        }
         else {
            return appendValuesWithoutDuplicates(list, value) ? list : maybeList;
        }
        
    }
    
    private static void appendValues(List<Object> list, Object value) {
        if (value instanceof List) {
            list.addAll((List<?>) value);
        }
         else {
            list.add(value);
        }
        
    }
    
    private static boolean appendValuesWithoutDuplicates(List<Object> list, Object value) {
        boolean valuesWereAppended = false;
        if (value instanceof List) {
            List<?> valueList = (List<?>) value;
            for (Object val : valueList) {
                if (list.contains(val) == false) {
                    list.add(val);
                    valuesWereAppended = true;
                }
                
            }
            
        }
         else {
            if (list.contains(value) == false) {
                list.add(value);
                valuesWereAppended = true;
            }
            
        }
        
        return valuesWereAppended;
    }
    
    private static <T> T cast(String path, Object object, Class<T> clazz) {
        if (object == null) {
            return null;
        }
        
        if (clazz.isInstance(object)) {
            return clazz.cast(object);
        }
        
        throw new IllegalArgumentException( "field [" + path + "] of type [" + object.getClass().getName() + "] cannot be cast to [" + clazz.getName() + "]" );
    }
    
    public String renderTemplate(TemplateScript.Factory template) {
        return template.newInstance(createTemplateModel()).execute();
    }
    
    private Map<String, Object> createTemplateModel() {
        return new LazyMap<>(() -> {
            Map<String, Object> model = new HashMap<>(sourceAndMetadata);
            model.put(SourceFieldMapper.NAME, sourceAndMetadata);
            model.put(INGEST_KEY, ingestMetadata);
            return model;
        }
        
);
    }
    
    public Map<Metadata, Object> extractMetadata() {
        Map<Metadata, Object> metadataMap = new EnumMap<>(Metadata.class);
        for (Metadata metadata : Metadata.values()) {
            metadataMap.put(metadata, sourceAndMetadata.remove(metadata.getFieldName()));
        }
        
        return metadataMap;
    }
    
    public Map<Metadata, Object> getMetadata() {
        Map<Metadata, Object> metadataMap = new EnumMap<>(Metadata.class);
        for (Metadata metadata : Metadata.values()) {
            metadataMap.put(metadata, sourceAndMetadata.get(metadata.getFieldName()));
        }
        
        return metadataMap;
    }
    
    public Map<String, Object> getIngestMetadata() {
        return this.ingestMetadata;
    }
    
    public Map<String, Object> getSourceAndMetadata() {
        return this.sourceAndMetadata;
    }
    
    public static <K, V> Map<K, V> deepCopyMap(Map<K, V> source) {
        return (Map<K, V>) deepCopy(source);
    }
    
    public static Object deepCopy(Object value) {
        if (value instanceof Map) {
            Map<?, ?> mapValue = (Map<?, ?>) value;
            Map<Object, Object> copy = new HashMap<>(mapValue.size());
            for (Map.Entry<?, ?> entry : mapValue.entrySet()) {
                copy.put(entry.getKey(), deepCopy(entry.getValue()));
            }
            
            return copy;
        }
         else if (value instanceof List) {
            List<?> listValue = (List<?>) value;
            List<Object> copy = new ArrayList<>(listValue.size());
            for (Object itemValue : listValue) {
                copy.add(deepCopy(itemValue));
            }
            
            return copy;
        }
         else if (value instanceof Set) {
            Set<?> setValue = (Set<?>) value;
            Set<Object> copy = new HashSet<>(setValue.size());
            for (Object itemValue : setValue) {
                copy.add(deepCopy(itemValue));
            }
            
            return copy;
        }
         else if (value instanceof byte[]) {
            byte[] bytes = (byte[]) value;
            return Arrays.copyOf(bytes, bytes.length);
        }
         else if (value == null || value instanceof String || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double || value instanceof Boolean || value instanceof ZonedDateTime) {
                return value;
            }
             else if (value instanceof Date) {
                return ((Date) value).clone();
            }
             else {
                throw new IllegalArgumentException("unexpected value type [" + value.getClass() + "]");
            }
            
    }
    
    public void executePipeline(Pipeline pipeline, BiConsumer<IngestDocument, Exception> handler) {
        if (executedPipelines.add(pipeline.getId())) {
            Object previousPipeline = ingestMetadata.put("pipeline", pipeline.getId());
            pipeline.execute(this, (result, e) -> {
                executedPipelines.remove(pipeline.getId());
                if (previousPipeline != null) {
                    ingestMetadata.put("pipeline", previousPipeline);
                }
                 else {
                    ingestMetadata.remove("pipeline");
                }
                
                handler.accept(result, e);
            }
            
);
        }
         else {
            handler.accept(null, new IllegalStateException(PIPELINE_CYCLE_ERROR_MESSAGE + pipeline.getId()));
        }
        
    }
    
    List<String> getPipelineStack() {
        List<String> pipelineStack = new ArrayList<>(executedPipelines);
        Collections.reverse(pipelineStack);
        return pipelineStack;
    }
    
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        
        IngestDocument other = (IngestDocument) obj;
        return Objects.equals(sourceAndMetadata, other.sourceAndMetadata) && Objects.equals(ingestMetadata, other.ingestMetadata);
    }
    
    public int hashCode() {
        return Objects.hash(sourceAndMetadata, ingestMetadata);
    }
    
    public String toString() {
        return "IngestDocument{" + " sourceAndMetadata=" + sourceAndMetadata + ", ingestMetadata=" + ingestMetadata + '}';
    }
    
    public enum Metadata {
        INDEX(IndexFieldMapper.NAME), TYPE(TypeFieldMapper.NAME), ID(IdFieldMapper.NAME), ROUTING(RoutingFieldMapper.NAME), VERSION(VersionFieldMapper.NAME), VERSION_TYPE("_version_type"), IF_SEQ_NO("_if_seq_no"), IF_PRIMARY_TERM("_if_primary_term"), DYNAMIC_TEMPLATES("_dynamic_templates");
        private final String fieldName;
        Metadata(String fieldName) {
            this.fieldName = fieldName;
        }
        
        public String getFieldName() {
            return fieldName;
        }
        
    }
    
    private class FieldPath {
        private final String[] pathElements;
        private final Object initialContext;
        private FieldPath(String path) {
            if (Strings.isEmpty(path)) {
                throw new IllegalArgumentException("path cannot be null nor empty");
            }
            
            String newPath;
            if (path.startsWith(INGEST_KEY_PREFIX)) {
                initialContext = ingestMetadata;
                newPath = path.substring(INGEST_KEY_PREFIX.length(), path.length());
            }
             else {
                initialContext = sourceAndMetadata;
                if (path.startsWith(SOURCE_PREFIX)) {
                    newPath = path.substring(SOURCE_PREFIX.length(), path.length());
                }
                 else {
                    newPath = path;
                }
                
            }
            
            this.pathElements = newPath.split("\\.");
            if (pathElements.length == 1 && pathElements[0].isEmpty()) {
                throw new IllegalArgumentException("path [" + path + "] is not valid");
            }
            
        }
        
    }
    
}


