package org.jenkinsci.plugins.workflow.cps.replay;
import com.cloudbees.diff.Diff;
import com.google.common.collect.ImmutableList;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import hudson.Extension;
import hudson.ExtensionList;
import hudson.Functions;
import hudson.init.InitMilestone;
import hudson.init.Initializer;
import hudson.model.Action;
import hudson.model.Cause;
import hudson.model.CauseAction;
import hudson.model.Item;
import hudson.model.ParametersAction;
import hudson.model.Queue;
import hudson.model.Run;
import hudson.model.queue.QueueTaskFuture;
import hudson.security.Permission;
import hudson.security.PermissionScope;
import hudson.util.FormValidation;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import javax.servlet.ServletException;
import hudson.util.HttpResponses;
import jenkins.model.Jenkins;
import jenkins.model.ParameterizedJobMixIn;
import jenkins.model.TransientActionFactory;
import jenkins.scm.api.SCMRevisionAction;
import net.sf.json.JSON;
import net.sf.json.JSONObject;
import org.acegisecurity.AccessDeniedException;
import org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition;
import org.jenkinsci.plugins.workflow.cps.CpsFlowExecution;
import org.jenkinsci.plugins.workflow.flow.FlowExecution;
import org.jenkinsci.plugins.workflow.flow.FlowExecutionOwner;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.DoNotUse;
import org.kohsuke.stapler.AncestorInPath;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.kohsuke.stapler.interceptor.RequirePOST;
import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;
public class ReplayAction implements Action {
    private static final Logger LOGGER = Logger.getLogger(ReplayAction.class.getName());
    private final Run run;
    private ReplayAction(Run run) {
        this.run = run;
    }
    
 public String getDisplayName() {
        return isEnabled() ? Messages.ReplayAction_displayName() : Messages.ReplayAction_rebuild_displayName();
    }
    
 public String getIconFileName() {
        return isEnabled() || isRebuildEnabled() ? "redo.png" : null;
    }
    
 public String getUrlName() {
        return isEnabled() || isRebuildEnabled() ? "replay" : null;
    }
    
    private @CheckForNull CpsFlowExecution getExecutionLazy() {
        FlowExecutionOwner owner = ((FlowExecutionOwner.Executable) run).asFlowExecutionOwner();
        if (owner == null) {
            return null;
        }
        
        FlowExecution exec = owner.getOrNull();
        return exec instanceof CpsFlowExecution ? (CpsFlowExecution) exec : null;
    }
    
    private @CheckForNull CpsFlowExecution getExecutionBlocking() {
        FlowExecutionOwner owner = ((FlowExecutionOwner.Executable) run).asFlowExecutionOwner();
        if (owner == null) {
            return null;
        }
        
        try {
            FlowExecution exec = owner.get();
            return exec instanceof CpsFlowExecution ? (CpsFlowExecution) exec : null;
        }
         catch (IOException ioe) {
            LOGGER.log(Level.WARNING, "Error fetching execution for replay", ioe);
        }
        
        return null;
    }
    
     public boolean isRebuildEnabled() {
        if (!run.hasPermission(Item.BUILD)) {
            return false;
        }
        
        if (!run.getParent().isBuildable()) {
            return false;
        }
        
        return true;
    }
    
     public boolean isEnabled() {
        if (!run.hasPermission(REPLAY)) {
            return false;
        }
        
        if (!run.getParent().isBuildable()) {
            return false;
        }
        
        CpsFlowExecution exec = getExecutionLazy();
        if (exec != null) {
            return exec.isSandbox() || Jenkins.get().hasPermission(Jenkins.RUN_SCRIPTS); 
        }
         else {
            return true;
        }
        
    }
    
     public boolean isReplayableSandboxTest() {
        CpsFlowExecution exec = getExecutionBlocking();
        if (exec != null) {
            if (!exec.isSandbox()) {
                return Jenkins.get().hasPermission(Jenkins.RUN_SCRIPTS);
            }
            
            return true;
        }
        
        return false;
    }
    
     public String getOriginalScript() {
        CpsFlowExecution execution = getExecutionBlocking();
        return execution != null ? execution.getScript() : "???";
    }
    
     public Map<String,String> getOriginalLoadedScripts() {
        CpsFlowExecution execution = getExecutionBlocking();
        if (execution == null) { 
            return Collections.<String,String>emptyMap();
        }
        
        Map<String,String> scripts = new TreeMap<>();
        for (OriginalLoadedScripts replayer : ExtensionList.lookup(OriginalLoadedScripts.class)) {
            scripts.putAll(replayer.loadScripts(execution));
        }
        
        return scripts;
    }
    
     public Run getOwner() {
        return run;
    }
    
    public void doRun(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {
        if (!isEnabled() || !(isReplayableSandboxTest())) {
            throw new AccessDeniedException("not allowed to replay"); 
        }
        
        JSONObject form = req.getSubmittedForm();
        Map<String,String> replacementLoadedScripts = new HashMap<>();
        for (Map.Entry<String,String> entry : getOriginalLoadedScripts().entrySet()) {
            replacementLoadedScripts.put(entry.getKey(), form.optString(entry.getKey().replace('.', '_'), entry.getValue()));
        }
        
        if (run(form.getString("mainScript"), replacementLoadedScripts) == null) {
            throw HttpResponses.error(SC_CONFLICT, new IOException(run.getParent().getFullName() + " is not buildable"));
        }
        
        rsp.sendRedirect("../.."); 
    }
    
    public void doRebuild(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {
        if (!isRebuildEnabled()) {
            throw new AccessDeniedException("not allowed to replay"); 
        }
        
        if (run(getOriginalScript(), getOriginalLoadedScripts()) == null) {
            throw HttpResponses.error(SC_CONFLICT, new IOException(run.getParent().getFullName() + " is not buildable"));
        }
        
        rsp.sendRedirect("../.."); 
    }
    
    private static final Iterable<Class<? extends Action>> COPIED_ACTIONS = ImmutableList.of( ParametersAction.class, SCMRevisionAction.class );
    public @CheckForNull QueueTaskFuture run(@NonNull String replacementMainScript, @NonNull Map<String,String> replacementLoadedScripts) {
        Queue.Item item = run2(replacementMainScript, replacementLoadedScripts);
        return item == null ? null : item.getFuture();
    }
    
    public @CheckForNull Queue.Item run2(@NonNull String replacementMainScript, @NonNull Map<String,String> replacementLoadedScripts) {
        List<Action> actions = new ArrayList<>();
        CpsFlowExecution execution = getExecutionBlocking();
        if (execution == null) {
            return null;
        }
        
        actions.add(new ReplayFlowFactoryAction(replacementMainScript, replacementLoadedScripts, execution.isSandbox()));
        actions.add(new CauseAction(new Cause.UserIdCause(), new ReplayCause(run)));
        for (Class<? extends Action> c : COPIED_ACTIONS) {
            actions.addAll(run.getActions(c));
        }
        
        return ParameterizedJobMixIn.scheduleBuild2(run.getParent(), 0, actions.toArray(new Action[actions.size()]));
    }
    
    public static @NonNull Set<String> replacementsIn(@NonNull CpsFlowExecution execution) throws IOException {
        Queue.Executable executable = execution.getOwner().getExecutable();
        if (executable instanceof Run) {
            ReplayFlowFactoryAction action = ((Run) executable).getAction(ReplayFlowFactoryAction.class);
            if (action != null) {
                return action.replaceableScripts();
            }
             else {
                LOGGER.log(Level.FINE, "{0} was not a replay", executable);
            }
            
        }
         else {
            LOGGER.log(Level.FINE, "{0} was not a run at all", executable);
        }
        
        return Collections.emptySet();
    }
    
    public static @CheckForNull String replace(@NonNull CpsFlowExecution execution, @NonNull String clazz) throws IOException {
        Queue.Executable executable = execution.getOwner().getExecutable();
        if (executable instanceof Run) {
            ReplayFlowFactoryAction action = ((Run) executable).getAction(ReplayFlowFactoryAction.class);
            if (action != null) {
                return action.replace(clazz);
            }
             else {
                LOGGER.log(Level.FINE, "{0} was not a replay", executable);
            }
            
        }
         else {
            LOGGER.log(Level.FINE, "{0} was not a run at all", executable);
        }
        
        return null;
    }
    
    public String getDiff() {
        Run<?,?> original = run;
        ReplayCause cause;
        while ((cause = original.getCause(ReplayCause.class)) != null) {
            Run<?,?> earlier = cause.getOriginal();
            if (earlier == null) {
                break;
            }
            
            original = earlier;
        }
        
        ReplayAction originalAction = original.getAction(ReplayAction.class);
        if (originalAction == null) {
            return "???";
        }
        
        try {
            StringBuilder diff = new StringBuilder(diff("Jenkinsfile", originalAction.getOriginalScript(), getOriginalScript()));
            Map<String,String> originalLoadedScripts = originalAction.getOriginalLoadedScripts();
            for (Map.Entry<String,String> entry : getOriginalLoadedScripts().entrySet()) {
                String script = entry.getKey();
                String originalScript = originalLoadedScripts.get(script);
                if (originalScript != null) {
                    diff.append(diff(script, originalScript, entry.getValue()));
                }
                
            }
            
            return diff.toString();
        }
         catch (IOException x) {
            return Functions.printThrowable(x);
        }
        
    }
    
    private static String diff(String script, String oldText, String nueText) throws IOException {
        Diff hunks = Diff.diff(new StringReader(oldText), new StringReader(nueText), false);
        return hunks.isEmpty() ? "" : hunks.toUnifiedDiff("old/" + script, "new/" + script, new StringReader(oldText), new StringReader(nueText), 3);
    }
    
    public FormValidation doCheckScript() {
        return FormValidation.ok();
    }
    
    public JSON doCheckScriptCompile(@AncestorInPath Item job, @QueryParameter String value) {
        return Jenkins.get().getDescriptorByType(CpsFlowDefinition.DescriptorImpl.class).doCheckScriptCompile(job, value);
    }
    
    public static final Permission REPLAY = new Permission(Run.PERMISSIONS, "Replay", Messages._Replay_permission_description(), Item.CONFIGURE, PermissionScope.RUN);
    @SuppressFBWarnings(value="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT", justification="getEnabled return value discarded")
    @Initializer(after=InitMilestone.PLUGINS_STARTED, before=InitMilestone.EXTENSIONS_AUGMENTED)
    public static void ensurePermissionRegistered() {
        REPLAY.getEnabled();
    }
    
    @Extension public static class Factory extends TransientActionFactory<Run> { @Override public Class<Run> type() { return Run.class; }
 public Collection<? extends Action> createFor(Run run) {
            return run instanceof FlowExecutionOwner.Executable && run.getParent() instanceof ParameterizedJobMixIn.ParameterizedJob ? Collections.<Action>singleton(new ReplayAction(run)) : Collections.<Action>emptySet();
        }
        
    }
    
}


