package nonapi.io.github.classgraph.utils;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Properties;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Document;
import io.github.classgraph.ClassGraph;
public final class VersionFinder {
    private static final String MAVEN_PACKAGE = "io.github.classgraph";
    private static final String MAVEN_ARTIFACT = "classgraph";
    public static final OperatingSystem OS;
    public static final String JAVA_VERSION = getProperty("java.version");
    public static final int JAVA_MAJOR_VERSION;
    public static final int JAVA_MINOR_VERSION;
    public static final int JAVA_SUB_VERSION;
    public static final boolean JAVA_IS_EA_VERSION;
    static {
        int javaMajorVersion = 0;
        int javaMinorVersion = 0;
        int javaSubVersion = 0;
        final List<Integer> versionParts = new ArrayList<>();
        if (JAVA_VERSION != null) {
            for (final String versionPart : JAVA_VERSION.split("[^0-9]+")) {
                try {
                    versionParts.add(Integer.parseInt(versionPart));
                }
                 catch (final NumberFormatException e) {
                }
                
            }
            
            if (!versionParts.isEmpty() && versionParts.get(0) == 1) {
                versionParts.remove(0);
            }
            
            if (versionParts.isEmpty()) {
                throw new RuntimeException("Could not determine Java version: " + JAVA_VERSION);
            }
            
            javaMajorVersion = versionParts.get(0);
            if (versionParts.size() > 1) {
                javaMinorVersion = versionParts.get(1);
            }
            
            if (versionParts.size() > 2) {
                javaSubVersion = versionParts.get(2);
            }
            
        }
        
        JAVA_MAJOR_VERSION = javaMajorVersion;
        JAVA_MINOR_VERSION = javaMinorVersion;
        JAVA_SUB_VERSION = javaSubVersion;
        JAVA_IS_EA_VERSION = JAVA_VERSION != null && JAVA_VERSION.endsWith("-ea");
    }
    
    public enum OperatingSystem {
        Windows, MacOSX, Linux, Solaris, BSD, Unix, Unknown }
    static {
        final String osName = getProperty("os.name", "unknown").toLowerCase(Locale.ENGLISH);
        if (osName == null) {
            OS = OperatingSystem.Unknown;
        }
         else if (osName.contains("mac") || osName.contains("darwin")) {
            OS = OperatingSystem.MacOSX;
        }
         else if (osName.contains("win")) {
            OS = OperatingSystem.Windows;
        }
         else if (osName.contains("nux")) {
            OS = OperatingSystem.Linux;
        }
         else if (osName.contains("sunos") || osName.contains("solaris")) {
            OS = OperatingSystem.Solaris;
        }
         else if (osName.contains("bsd")) {
            OS = OperatingSystem.Unix;
        }
         else if (osName.contains("nix") || osName.contains("aix")) {
            OS = OperatingSystem.Unix;
        }
         else {
            OS = OperatingSystem.Unknown;
        }
        
    }
    
    private VersionFinder() {
    }
    
    public static String getProperty(final String propName) {
        try {
            return System.getProperty(propName);
        }
         catch (final SecurityException e) {
            return null;
        }
        
    }
    
    public static String getProperty(final String propName, final String defaultVal) {
        try {
            return System.getProperty(propName, defaultVal);
        }
         catch (final SecurityException e) {
            return null;
        }
        
    }
    
    public static synchronized String getVersion() {
        final Class<?> cls = ClassGraph.class;
        try {
            final String className = cls.getName();
            final URL classpathResource = cls.getResource("/" + JarUtils.classNameToClassfilePath(className));
            if (classpathResource != null) {
                final Path absolutePackagePath = Paths.get(classpathResource.toURI()).getParent();
                final int packagePathSegments = className.length() - className.replace(".", "").length();
                Path path = absolutePackagePath;
                for (int i = 0; i < packagePathSegments && path != null; i++) {
                    path = path.getParent();
                }
                
                for (int i = 0; i < 3 && path != null; i++, path = path.getParent()) {
                    final Path pom = path.resolve("pom.xml");
                    try (InputStream is = Files.newInputStream(pom)) {
                        final Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);
                        doc.getDocumentElement().normalize();
                        String version = (String) XPathFactory.newInstance().newXPath().compile("/project/version") .evaluate(doc, XPathConstants.STRING);
                        if (version != null) {
                            version = version.trim();
                            if (!version.isEmpty()) {
                                return version;
                            }
                            
                        }
                        
                    }
                     catch (final IOException e) {
                    }
                    
                }
                
            }
            
        }
         catch (final Exception e) {
        }
        
        try (InputStream is = cls.getResourceAsStream( "/META-INF/maven/" + MAVEN_PACKAGE + "/" + MAVEN_ARTIFACT + "/pom.properties")) {
            if (is != null) {
                final Properties p = new Properties();
                p.load(is);
                final String version = p.getProperty("version", "").trim();
                if (!version.isEmpty()) {
                    return version;
                }
                
            }
            
        }
         catch (final IOException e) {
        }
        
        final Package pkg = cls.getPackage();
        if (pkg != null) {
            String version = pkg.getImplementationVersion();
            if (version == null) {
                version = "";
            }
            
            version = version.trim();
            if (version.isEmpty()) {
                version = pkg.getSpecificationVersion();
                if (version == null) {
                    version = "";
                }
                
                version = version.trim();
            }
            
            if (!version.isEmpty()) {
                return version;
            }
            
        }
        
        return "unknown";
    }
    
}


