package org.springframework.kafka.listener;
import java.time.Duration;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.common.TopicPartition;
import org.apache.kafka.common.errors.WakeupException;
import org.springframework.classify.BinaryExceptionClassifier;
import org.springframework.core.log.LogAccessor;
import org.springframework.kafka.KafkaException;
import org.springframework.kafka.support.KafkaUtils;
import org.springframework.util.backoff.BackOff;
import org.springframework.util.backoff.BackOffExecution;
public final class ErrorHandlingUtils {
	static Runnable NO_OP = () -> { };
	private ErrorHandlingUtils() {
	}
	
	public static void retryBatch(Exception thrownException, ConsumerRecords<?, ?> records, Consumer<?, ?> consumer, MessageListenerContainer container, Runnable invokeListener, BackOff backOff, CommonErrorHandler seeker, BiConsumer<ConsumerRecords<?, ?>, Exception> recoverer, LogAccessor logger, KafkaException.Level logLevel, List<RetryListener> retryListeners, BinaryExceptionClassifier classifier) {
		retryBatch(thrownException, records, consumer, container, invokeListener, backOff, seeker, recoverer, logger, logLevel, retryListeners, classifier, false);
	}
	
	 public static void retryBatch(Exception thrownException, ConsumerRecords<?, ?> records, Consumer<?, ?> consumer, MessageListenerContainer container, Runnable invokeListener, BackOff backOff, CommonErrorHandler seeker, BiConsumer<ConsumerRecords<?, ?>, Exception> recoverer, LogAccessor logger, KafkaException.Level logLevel, List<RetryListener> retryListeners, BinaryExceptionClassifier classifier, boolean reClassifyOnExceptionChange) {
		BackOffExecution execution = backOff.start();
		long nextBackOff = execution.nextBackOff();
		String failed = null;
		Set<TopicPartition> assignment = consumer.assignment();
		consumer.pause(assignment);
		int attempt = 1;
		listen(retryListeners, records, thrownException, attempt++);
		ConsumerRecord<?, ?> first = records.iterator().next();
		MessageListenerContainer childOrSingle = container.getContainerFor(first.topic(), first.partition());
		if (childOrSingle instanceof ConsumerPauseResumeEventPublisher) {
			((ConsumerPauseResumeEventPublisher) childOrSingle) .publishConsumerPausedEvent(assignment, "For batch retry");
		}
		
		try {
			Exception recoveryException = thrownException;
			Exception lastException = unwrapIfNeeded(thrownException);
			Boolean retryable = classifier.classify(lastException);
			while (Boolean.TRUE.equals(retryable) && nextBackOff != BackOffExecution.STOP) {
				try {
					consumer.poll(Duration.ZERO);
				}
				
				catch (WakeupException we) {
					seeker.handleBatch(thrownException, records, consumer, container, NO_OP);
					throw new KafkaException("Woken up during retry", logLevel, we);
				}
				
				try {
					ListenerUtils.conditionalSleep( () -> container.isRunning() && !container.isPauseRequested() && records.partitions().stream().noneMatch(container::isPartitionPauseRequested), nextBackOff );
				}
				
				catch (InterruptedException e1) {
					Thread.currentThread().interrupt();
					seeker.handleBatch(thrownException, records, consumer, container, NO_OP);
					throw new KafkaException("Interrupted during retry", logLevel, e1);
				}
				
				if (!container.isRunning()) {
					throw new KafkaException("Container stopped during retries");
				}
				
				if (container.isPauseRequested() || records.partitions().stream().anyMatch(container::isPartitionPauseRequested)) {
					seeker.handleBatch(thrownException, records, consumer, container, NO_OP);
					throw new KafkaException("Container paused requested during retries");
				}
				
				try {
					consumer.poll(Duration.ZERO);
				}
				
				catch (WakeupException we) {
					seeker.handleBatch(thrownException, records, consumer, container, NO_OP);
					throw new KafkaException("Woken up during retry", logLevel, we);
				}
				
				try {
					invokeListener.run();
					return;
				}
				
				catch (Exception ex) {
					listen(retryListeners, records, ex, attempt++);
					if (failed == null) {
						failed = recordsToString(records);
					}
					
					String toLog = failed;
					logger.debug(ex, () -> "Retry failed for: " + toLog);
					recoveryException = ex;
					Exception newException = unwrapIfNeeded(ex);
					if (reClassifyOnExceptionChange && !newException.getClass().equals(lastException.getClass()) && !classifier.classify(newException)) {
						break;
					}
					
				}
				
				nextBackOff = execution.nextBackOff();
			}
			
			try {
				recoverer.accept(records, recoveryException);
				final Exception finalRecoveryException = recoveryException;
				retryListeners.forEach(listener -> listener.recovered(records, finalRecoveryException));
			}
			
			catch (Exception ex) {
				logger.error(ex, () -> "Recoverer threw an exception; re-seeking batch");
				retryListeners.forEach(listener -> listener.recoveryFailed(records, thrownException, ex));
				seeker.handleBatch(thrownException, records, consumer, container, NO_OP);
			}
			
		}
		
		finally {
			Set<TopicPartition> assignment2 = consumer.assignment();
			consumer.resume(assignment2);
			if (childOrSingle instanceof ConsumerPauseResumeEventPublisher) {
				((ConsumerPauseResumeEventPublisher) childOrSingle).publishConsumerResumedEvent(assignment2);
			}
			
		}
		
	}
	 
	private static void listen(List<RetryListener> listeners, ConsumerRecords<?, ?> records, Exception thrownException, int attempt) {
		listeners.forEach(listener -> listener.failedDelivery(records, thrownException, attempt));
	}
	
	 public static String recordsToString(ConsumerRecords<?, ?> records) {
		StringBuffer sb = new StringBuffer();
		records.spliterator().forEachRemaining(rec -> sb .append(KafkaUtils.format(rec)) .append(','));
		sb.deleteCharAt(sb.length() - 1);
		return sb.toString();
	}
	
	 public static Exception unwrapIfNeeded(Exception exception) {
		Exception theEx = exception;
		if (theEx instanceof TimestampedException && theEx.getCause() instanceof Exception cause) {
			theEx = cause;
		}
		
		if (theEx instanceof ListenerExecutionFailedException && theEx.getCause() instanceof Exception cause) {
			theEx = cause;
		}
		
		return theEx;
	}
	
	 public static Exception findRootCause(Exception exception) {
		Exception realException = exception;
		while ((realException  instanceof ListenerExecutionFailedException || realException instanceof TimestampedException) && realException.getCause() instanceof Exception cause) {
			realException = cause;
		}
		
		return realException;
	}
	
}


