package org.springframework.kafka.listener;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.apache.commons.logging.LogFactory;
import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.DescribeTopicsResult;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRebalanceListener;
import org.apache.kafka.common.TopicPartition;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.ApplicationEventPublisherAware;
import org.springframework.core.log.LogAccessor;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.KafkaAdmin;
import org.springframework.kafka.event.ContainerStoppedEvent;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.kafka.support.TopicPartitionOffset;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
public abstract class AbstractMessageListenerContainer<K, V> implements GenericMessageListenerContainer<K, V>, BeanNameAware, ApplicationEventPublisherAware, ApplicationContextAware {
	private static final String VERSION_2_8 = "2.8";
	 public static final int DEFAULT_PHASE = Integer.MAX_VALUE - 100; 
	private static final int DEFAULT_TOPIC_CHECK_TIMEOUT = 30;
	protected final LogAccessor logger = new LogAccessor(LogFactory.getLog(this.getClass())); 
	protected final ConsumerFactory<K, V> consumerFactory; 
	private final ContainerProperties containerProperties;
	protected final Object lifecycleMonitor = new Object(); 
	private final Set<TopicPartition> pauseRequestedPartitions = ConcurrentHashMap.newKeySet();
	private String beanName = "noBeanNameSet";
	private ApplicationEventPublisher applicationEventPublisher;
	private GenericErrorHandler<?> errorHandler;
	private CommonErrorHandler commonErrorHandler;
	private boolean autoStartup = true;
	private int phase = DEFAULT_PHASE;
	private AfterRollbackProcessor<? super K, ? super V> afterRollbackProcessor = new DefaultAfterRollbackProcessor<>();
	private int topicCheckTimeout = DEFAULT_TOPIC_CHECK_TIMEOUT;
	private RecordInterceptor<K, V> recordInterceptor;
	private BatchInterceptor<K, V> batchInterceptor;
	private boolean interceptBeforeTx = true;
	private byte[] listenerInfo;
	private ApplicationContext applicationContext;
	private volatile boolean running = false;
	private volatile boolean paused;
	private volatile boolean stoppedNormally = true;
	private String mainListenerId;
	private boolean changeConsumerThreadName;
	private Function<MessageListenerContainer, String> threadNameSupplier = container -> container.getListenerId();
	private KafkaAdmin kafkaAdmin;
	protected AbstractMessageListenerContainer(ConsumerFactory<? super K, ? super V> consumerFactory, ContainerProperties containerProperties) {
		Assert.notNull(containerProperties, "'containerProperties' cannot be null");
		Assert.notNull(consumerFactory, "'consumerFactory' cannot be null");
		this.consumerFactory = (ConsumerFactory<K, V>) consumerFactory;
		String[] topics = containerProperties.getTopics();
		if (topics != null) {
			this.containerProperties = new ContainerProperties(topics);
		}
		
		else {
			Pattern topicPattern = containerProperties.getTopicPattern();
			if (topicPattern != null) {
				this.containerProperties = new ContainerProperties(topicPattern);
			}
			
			else {
				TopicPartitionOffset[] topicPartitions = containerProperties.getTopicPartitions();
				if (topicPartitions != null) {
					this.containerProperties = new ContainerProperties(topicPartitions);
				}
				
				else {
					throw new IllegalStateException("topics, topicPattern, or topicPartitions must be provided");
				}
				
			}
			
		}
		
		BeanUtils.copyProperties(containerProperties, this.containerProperties, "topics", "topicPartitions", "topicPattern", "ackCount", "ackTime", "subBatchPerPartition");
		if (containerProperties.getAckCount() > 0) {
			this.containerProperties.setAckCount(containerProperties.getAckCount());
		}
		
		if (containerProperties.getAckTime() > 0) {
			this.containerProperties.setAckTime(containerProperties.getAckTime());
		}
		
		Boolean subBatchPerPartition = containerProperties.getSubBatchPerPartition();
		if (subBatchPerPartition != null) {
			this.containerProperties.setSubBatchPerPartition(subBatchPerPartition);
		}
		
		if (this.containerProperties.getConsumerRebalanceListener() == null) {
			this.containerProperties.setConsumerRebalanceListener(createSimpleLoggingConsumerRebalanceListener());
		}
		
	}
	
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	
	protected ApplicationContext getApplicationContext() {
		return this.applicationContext;
	}
	
	public void setBeanName(String name) {
		this.beanName = name;
	}
	
	public String getBeanName() {
		return this.beanName;
	}
	
	public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
		this.applicationEventPublisher = applicationEventPublisher;
	}
	
	public ApplicationEventPublisher getApplicationEventPublisher() {
		return this.applicationEventPublisher;
	}
	
	 @Deprecated
(since = VERSION_2_8, forRemoval = true) 
	public void setErrorHandler(ErrorHandler errorHandler) {
		this.errorHandler = errorHandler;
	}
	
	 @Deprecated
(since = VERSION_2_8, forRemoval = true) 
	public void setGenericErrorHandler(@Nullable GenericErrorHandler<?> errorHandler) {
		this.errorHandler = errorHandler;
	}
	
	 @Deprecated
(since = VERSION_2_8, forRemoval = true) 
	public void setBatchErrorHandler(BatchErrorHandler errorHandler) {
		this.errorHandler = errorHandler;
	}
	
	 @Deprecated
(since = VERSION_2_8, forRemoval = true) 
	public GenericErrorHandler<?> getGenericErrorHandler() {
		return this.errorHandler;
	}
	
	public CommonErrorHandler getCommonErrorHandler() {
		return this.commonErrorHandler;
	}
	
	 public void setCommonErrorHandler(@Nullable CommonErrorHandler commonErrorHandler) {
		this.commonErrorHandler = commonErrorHandler;
	}
	
	protected boolean isStoppedNormally() {
		return this.stoppedNormally;
	}
	
	protected void setStoppedNormally(boolean stoppedNormally) {
		this.stoppedNormally = stoppedNormally;
	}
	
	public boolean isAutoStartup() {
		return this.autoStartup;
	}
	
	public void setAutoStartup(boolean autoStartup) {
		this.autoStartup = autoStartup;
	}
	
	protected void setRunning(boolean running) {
		this.running = running;
	}
	
	public boolean isRunning() {
		return this.running;
	}
	
	protected boolean isPaused() {
		return this.paused;
	}
	
	public boolean isPartitionPauseRequested(TopicPartition topicPartition) {
		return this.pauseRequestedPartitions.contains(topicPartition);
	}
	
	public void pausePartition(TopicPartition topicPartition) {
		this.pauseRequestedPartitions.add(topicPartition);
	}
	
	public void resumePartition(TopicPartition topicPartition) {
		this.pauseRequestedPartitions.remove(topicPartition);
	}
	
	public boolean isPauseRequested() {
		return this.paused;
	}
	
	public void setPhase(int phase) {
		this.phase = phase;
	}
	
	public int getPhase() {
		return this.phase;
	}
	
	 public AfterRollbackProcessor<? super K, ? super V> getAfterRollbackProcessor() {
		return this.afterRollbackProcessor;
	}
	
	 public void setAfterRollbackProcessor(AfterRollbackProcessor<? super K, ? super V> afterRollbackProcessor) {
		Assert.notNull(afterRollbackProcessor, "'afterRollbackProcessor' cannot be null");
		this.afterRollbackProcessor = afterRollbackProcessor;
	}
	
	public ContainerProperties getContainerProperties() {
		return this.containerProperties;
	}
	
	public String getGroupId() {
		return this.containerProperties.getGroupId() == null ? (String) this.consumerFactory.getConfigurationProperties().get(ConsumerConfig.GROUP_ID_CONFIG) : this.containerProperties.getGroupId();
	}
	
	public String getListenerId() {
		return this.beanName; 
	}
	
	 public void setMainListenerId(String id) {
		this.mainListenerId = id;
	}
	
	public String getMainListenerId() {
		return this.mainListenerId;
	}
	
	public byte[] getListenerInfo() {
		return this.listenerInfo != null ? Arrays.copyOf(this.listenerInfo, this.listenerInfo.length) : null;
	}
	
	 public void setListenerInfo(@Nullable byte[] listenerInfo) {
		this.listenerInfo = listenerInfo != null ? Arrays.copyOf(listenerInfo, listenerInfo.length) : null;
	}
	
	 public void setTopicCheckTimeout(int topicCheckTimeout) {
		this.topicCheckTimeout = topicCheckTimeout;
	}
	
	 public boolean isChangeConsumerThreadName() {
		return this.changeConsumerThreadName;
	}
	
	 public void setChangeConsumerThreadName(boolean changeConsumerThreadName) {
		this.changeConsumerThreadName = changeConsumerThreadName;
	}
	
	 public Function<MessageListenerContainer, String> getThreadNameSupplier() {
		return this.threadNameSupplier;
	}
	
	 public void setThreadNameSupplier(Function<MessageListenerContainer, String> threadNameSupplier) {
		Assert.notNull(threadNameSupplier, "'threadNameSupplier' cannot be null");
		this.threadNameSupplier = threadNameSupplier;
	}
	
	public KafkaAdmin getKafkaAdmin() {
		return this.kafkaAdmin;
	}
	
	 public void setKafkaAdmin(KafkaAdmin kafkaAdmin) {
		this.kafkaAdmin = kafkaAdmin;
	}
	
	protected RecordInterceptor<K, V> getRecordInterceptor() {
		return this.recordInterceptor;
	}
	
	 public void setRecordInterceptor(RecordInterceptor<K, V> recordInterceptor) {
		this.recordInterceptor = recordInterceptor;
	}
	
	protected BatchInterceptor<K, V> getBatchInterceptor() {
		return this.batchInterceptor;
	}
	
	 public void setBatchInterceptor(BatchInterceptor<K, V> batchInterceptor) {
		this.batchInterceptor = batchInterceptor;
	}
	
	protected boolean isInterceptBeforeTx() {
		return this.interceptBeforeTx;
	}
	
	 public void setInterceptBeforeTx(boolean interceptBeforeTx) {
		this.interceptBeforeTx = interceptBeforeTx;
	}
	
	public void setupMessageListener(Object messageListener) {
		this.containerProperties.setMessageListener(messageListener);
	}
	
	public final void start() {
		checkGroupId();
		synchronized (this.lifecycleMonitor) {
			if (!isRunning()) {
				Assert.state(this.containerProperties.getMessageListener() instanceof GenericMessageListener, () -> "A " + GenericMessageListener.class.getName() + " implementation must be provided");
				doStart();
			}
			
		}
		
	}
	
	protected void checkTopics() {
		if (this.containerProperties.isMissingTopicsFatal() && this.containerProperties.getTopicPattern() == null) {
			Map<String, Object> configs = this.consumerFactory.getConfigurationProperties() .entrySet() .stream() .filter(entry -> AdminClientConfig.configNames().contains(entry.getKey())) .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
			List<String> missing = null;
			try (AdminClient client = AdminClient.create(configs)) { 
				if (client != null) {
					String[] topics = this.containerProperties.getTopics();
					if (topics == null) {
						topics = Arrays.stream(this.containerProperties.getTopicPartitions()) .map(TopicPartitionOffset::getTopic) .toArray(String[]::new);
					}
					
					DescribeTopicsResult result = client.describeTopics(Arrays.asList(topics));
					missing = result.topicNameValues() .entrySet() .stream() .filter(entry -> {
								try {
									entry.getValue().get(this.topicCheckTimeout, TimeUnit.SECONDS);
									return false;
								}
								
								catch (InterruptedException ex) {
									Thread.currentThread().interrupt();
									return true;
								}
								
								catch (@SuppressWarnings("unused") Exception ex) {
									return true;
								}
								
							}
) .map(Entry::getKey) .collect(Collectors.toList());
				}
				
			}
			
			catch (Exception e) {
				this.logger.error(e, "Failed to check topic existence");
			}
			
			if (missing != null && missing.size() > 0) {
				throw new IllegalStateException( "Topic(s) " + missing.toString() + " is/are not present and missingTopicsFatal is true");
			}
			
		}
		
	}
	
	public void checkGroupId() {
		if (this.containerProperties.getTopicPartitions() == null) {
			boolean hasGroupIdConsumerConfig = true; 
			if (this.consumerFactory != null) { 
				Object groupIdConfig = this.consumerFactory.getConfigurationProperties() .get(ConsumerConfig.GROUP_ID_CONFIG);
				hasGroupIdConsumerConfig = groupIdConfig instanceof String && StringUtils.hasText((String) groupIdConfig);
			}
			
			Assert.state(hasGroupIdConsumerConfig || StringUtils.hasText(this.containerProperties.getGroupId()), "No group.id found in consumer config, container properties, or @KafkaListener annotation; " + "a group.id is required when group management is used.");
		}
		
	}
	
	protected abstract void doStart();
	public final void stop() {
		stop(true);
	}
	
	 public final void stop(boolean wait) {
		synchronized (this.lifecycleMonitor) {
			if (isRunning()) {
				if (wait) {
					final CountDownLatch latch = new CountDownLatch(1);
					doStop(latch::countDown);
					try {
						latch.await(this.containerProperties.getShutdownTimeout(), TimeUnit.MILLISECONDS); 
						publishContainerStoppedEvent();
					}
					
					catch (@SuppressWarnings("unused") InterruptedException e) {
						Thread.currentThread().interrupt();
					}
					
				}
				
				else {
					doStop(this::publishContainerStoppedEvent);
				}
				
			}
			
		}
		
	}
	
	public void pause() {
		this.paused = true;
	}
	
	public void resume() {
		this.paused = false;
	}
	
	public void stop(Runnable callback) {
		synchronized (this.lifecycleMonitor) {
			if (isRunning()) {
				doStop(callback);
			}
			
			else {
				callback.run();
			}
			
		}
		
	}
	
	public void stopAbnormally(Runnable callback) {
		doStop(callback, false);
		publishContainerStoppedEvent();
	}
	
	protected void doStop(Runnable callback) {
		doStop(callback, true);
		publishContainerStoppedEvent();
	}
	
	 protected abstract void doStop(Runnable callback, boolean normal);
	 protected final ConsumerRebalanceListener createSimpleLoggingConsumerRebalanceListener() {
		return new ConsumerRebalanceListener() {  

			public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
				AbstractMessageListenerContainer.this.logger.info(() -> getGroupId() + ": partitions revoked: " + partitions);
			}
			
			public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
				AbstractMessageListenerContainer.this.logger.info(() -> getGroupId() + ": partitions assigned: " + partitions);
			}
			
			public void onPartitionsLost(Collection<TopicPartition> partitions) {
				AbstractMessageListenerContainer.this.logger.info(() -> getGroupId() + ": partitions lost: " + partitions);
			}
			
		};
	}
	
	protected void publishContainerStoppedEvent() {
		ApplicationEventPublisher eventPublisher = getApplicationEventPublisher();
		if (eventPublisher != null) {
			eventPublisher.publishEvent(new ContainerStoppedEvent(this, parentOrThis()));
		}
		
	}
	
	 protected AbstractMessageListenerContainer<?, ?> parentOrThis() {
		return this;
	}
	
}


