package org.codehaus.janino;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.codehaus.commons.compiler.CompileException;
import org.codehaus.commons.compiler.Cookable;
import org.codehaus.commons.compiler.ErrorHandler;
import org.codehaus.commons.compiler.IClassBodyEvaluator;
import org.codehaus.commons.compiler.ICookable;
import org.codehaus.commons.compiler.IExpressionEvaluator;
import org.codehaus.commons.compiler.IScriptEvaluator;
import org.codehaus.commons.compiler.ISimpleCompiler;
import org.codehaus.commons.compiler.InternalCompilerException;
import org.codehaus.commons.compiler.Location;
import org.codehaus.commons.compiler.MultiCookable;
import org.codehaus.commons.compiler.WarningHandler;
import org.codehaus.commons.nullanalysis.Nullable;
import org.codehaus.janino.util.AbstractTraverser;
public class ExpressionEvaluator extends MultiCookable implements IExpressionEvaluator {
    private int                      sourceVersion = -1;
    @Nullable private WarningHandler warningHandler;
    private final ScriptEvaluator se = new ScriptEvaluator();{
        this.se.setClassName(IExpressionEvaluator.DEFAULT_CLASS_NAME);
        this.se.setDefaultReturnType(IExpressionEvaluator.DEFAULT_EXPRESSION_TYPE);
    }
    
    public ExpressionEvaluator(String expression, Class<?> expressionType, String[] parameterNames, Class<?>[] parameterTypes) throws CompileException {
        this.setExpressionType(expressionType);
        this.setParameters(parameterNames, parameterTypes);
        this.cook(expression);
    }
    
    public ExpressionEvaluator( String                expression, Class<?>              expressionType, String[]              parameterNames, Class<?>[]            parameterTypes, Class<?>[]            thrownExceptions, @Nullable ClassLoader parentClassLoader ) throws CompileException {
        this.setExpressionType(expressionType);
        this.setParameters(parameterNames, parameterTypes);
        this.setThrownExceptions(thrownExceptions);
        this.setParentClassLoader(parentClassLoader);
        this.cook(expression);
    }
    
    public ExpressionEvaluator( String                expression, Class<?>              expressionType, String[]              parameterNames, Class<?>[]            parameterTypes, Class<?>[]            thrownExceptions, Class<?>              extendedClass, Class<?>[]            implementedTypes, @Nullable ClassLoader parentClassLoader ) throws CompileException {
        this.setExpressionType(expressionType);
        this.setParameters(parameterNames, parameterTypes);
        this.setThrownExceptions(thrownExceptions);
        this.setExtendedClass(extendedClass);
        this.setImplementedInterfaces(implementedTypes);
        this.setParentClassLoader(parentClassLoader);
        this.cook(expression);
    }
    
    public ExpressionEvaluator( Scanner               scanner, String                className, @Nullable Class<?>    extendedType, Class<?>[]            implementedTypes, boolean               staticMethod, Class<?>              expressionType, String                methodName, String[]              parameterNames, Class<?>[]            parameterTypes, Class<?>[]            thrownExceptions, @Nullable ClassLoader parentClassLoader ) throws CompileException, IOException {
        this.setClassName(className);
        this.setExtendedClass(extendedType);
        this.setImplementedInterfaces(implementedTypes);
        this.setStaticMethod(staticMethod);
        this.setExpressionType(expressionType);
        this.setMethodName(methodName);
        this.setParameters(parameterNames, parameterTypes);
        this.setThrownExceptions(thrownExceptions);
        this.setParentClassLoader(parentClassLoader);
        this.cook(scanner);
    }
    
    public ExpressionEvaluator() {}
 public void setParentClassLoader(@Nullable ClassLoader parentClassLoader) {
        this.se.setParentClassLoader(parentClassLoader);
    }
    
 public void setDebuggingInformation(boolean debugSource, boolean debugLines, boolean debugVars) {
        this.se.setDebuggingInformation(debugSource, debugLines, debugVars);
    }
    
 public void setSourceVersion(int version) {
        this.se.setSourceVersion(version);
        this.sourceVersion = version;
      }
      
 public void setTargetVersion(int version) { this.se.setTargetVersion(version); }
 public void setCompileErrorHandler(@Nullable ErrorHandler compileErrorHandler) {
        this.se.setCompileErrorHandler(compileErrorHandler);
    }
    
 public void setWarningHandler(@Nullable WarningHandler warningHandler) {
        this.se.setWarningHandler(warningHandler);
        this.warningHandler = warningHandler;
    }
    
 public void setDefaultImports(String... defaultImports) { this.se.setDefaultImports(defaultImports); }
 public String[] getDefaultImports() { return this.se.getDefaultImports(); }
    public EnumSet<JaninoOption> options() { return this.se.options(); }
    public ExpressionEvaluator options(EnumSet<JaninoOption> options) {
        this.se.options(options);
        return this;
    }
    
 public void setDefaultExpressionType(Class<?> defaultExpressionType) { this.se.setDefaultReturnType(defaultExpressionType); }
 public Class<?> getDefaultExpressionType() { return this.se.getDefaultReturnType(); }
 public void setImplementedInterfaces(Class<?>[] implementedTypes) { this.se.setImplementedInterfaces(implementedTypes); }
 public void setReturnType(Class<?> returnType) { this.se.setReturnType(returnType); }
 public void setExpressionType(Class<?> expressionType) { this.se.setReturnType(expressionType); }
 public void setExpressionTypes(Class<?>[] expressionTypes) { this.se.setReturnTypes(expressionTypes); }
 public void setOverrideMethod(boolean overrideMethod) { this.se.setOverrideMethod(overrideMethod); }
 public void setOverrideMethod(boolean[] overrideMethod) { this.se.setOverrideMethod(overrideMethod); }
 public void setParameters(String[] parameterNames, Class<?>[] parameterTypes) {
        this.se.setParameters(parameterNames, parameterTypes);
    }
    
 public void setParameters(String[][] parameterNames, Class<?>[][] parameterTypes) {
        this.se.setParameters(parameterNames, parameterTypes);
    }
    
 public void setClassName(String className) { this.se.setClassName(className); }
 public void setExtendedClass(@Nullable Class<?> extendedType) { this.se.setExtendedClass(extendedType); }
 public void setStaticMethod(boolean staticMethod) { this.se.setStaticMethod(staticMethod); }
 public void setStaticMethod(boolean[] staticMethod) { this.se.setStaticMethod(staticMethod); }
 public void setMethodName(String methodName) { this.se.setMethodName(methodName); }
 public void setMethodNames(String[] methodNames) { this.se.setMethodNames(methodNames); }
 public void setThrownExceptions(Class<?>[] thrownExceptions) { this.se.setThrownExceptions(thrownExceptions); }
 public void setThrownExceptions(Class<?>[][] thrownExceptions) { this.se.setThrownExceptions(thrownExceptions); }
 public Method getMethod() { return this.se.getMethod(); }
 public Method getMethod(int idx) { return this.se.getMethod(idx); }
 public Method[] getResult() { return this.se.getResult(); }
 public void cook(@Nullable String fileName, Reader reader) throws CompileException, IOException {
        this.cook(new Scanner(fileName, reader));
    }
    
 public void cook(String[] fileNames, Reader[] readers) throws CompileException, IOException {
        final int count = fileNames.length;
        Scanner[] scanners = new Scanner[count];
        for (int i = 0; i < count; i++) scanners[i] = new Scanner(fileNames[i], readers[i]);
        this.cook(scanners);
    }
    
    public final void cook(Scanner scanner) throws CompileException, IOException { this.cook(new Scanner[] { scanner }); }
    public final void cook(Scanner... scanners) throws CompileException, IOException {
        Parser[] parsers = new Parser[scanners.length];
        for (int i = 0; i < scanners.length; ++i) {
            parsers[i] = new Parser(scanners[i]);
            parsers[i].setSourceVersion(this.sourceVersion);
            parsers[i].setWarningHandler(this.warningHandler);
        }
        
        this.cook(parsers);
    }
    
    public final void cook(Parser... parsers) throws CompileException, IOException {
        int count = parsers.length;
        this.se.setScriptCount(count);
        String fileName = parsers.length >= 1 ? parsers[0].getScanner().getFileName() : null;
        final Java.AbstractCompilationUnit.ImportDeclaration[] importDeclarations = this.se.parseImports(parsers.length == 1 ? parsers[0] : null);
        Java.BlockStatement[][]   statementss   = new Java.BlockStatement[count][];
        Java.MethodDeclarator[][] localMethodss = new Java.MethodDeclarator[count][];
        for (int i = 0; i < parsers.length; ++i) {
            Class<?> et     = this.se.getReturnType(i);
            Parser   parser = parsers[i];
            Java.Rvalue value = parser.parseExpression();
            Java.BlockStatement statement;
            if (et == void.class) {
                statement = new Java.ExpressionStatement(value);
            }
             else {
                statement = new Java.ReturnStatement(parser.location(), value);
            }
            
            if (!parser.peek(TokenType.END_OF_INPUT)) {
                throw new CompileException("Unexpected token \"" + parser.peek() + "\"", parser.location());
            }
            
            statementss[i]   = new Java.BlockStatement[] { statement };
            localMethodss[i] = new Java.MethodDeclarator[0];
        }
        
        this.se.cook(fileName, importDeclarations, statementss, localMethodss);
    }
    
    protected Java.Type[] classesToTypes(Location location, @Nullable Class<?>... classes) {
        if (classes == null) return new Java.Type[0];
        Java.Type[] types = new Java.Type[classes.length];
        for (int i = 0; i < classes.length; ++i) {
            types[i] = this.classToType(location, classes[i]);
        }
        
        return types;
    }
    
    @Nullable protected Java.Type optionalClassToType(final Location location, @Nullable final Class<?> clazz) { return this.se.optionalClassToType(location, clazz); }
    protected Java.Type classToType(final Location location, final Class<?> clazz) { return this.se.classToType(location, clazz); }
 @Nullable public Object evaluate() throws InvocationTargetException { return this.evaluate(new Object[0]); }
 @Nullable public Object evaluate(@Nullable Object[] arguments) throws InvocationTargetException { return this.evaluate(0, arguments); }
 @Nullable public Object evaluate(int idx, @Nullable Object[] arguments) throws InvocationTargetException {
        Method method = this.getMethod(idx);
        try {
            return method.invoke(null, arguments);
        }
         catch (IllegalAccessException ex) {
            throw new InternalCompilerException(ex.toString(), ex);
        }
        
    }
    
 public Class<?> getClazz() { return this.se.getClazz(); }
 public Map<String, byte[]> getBytecodes() { return this.se.getBytecodes(); }
 public static Object createFastExpressionEvaluator( String                expression, Class<?>              interfaceToImplement, String[]              parameterNames, @Nullable ClassLoader parentClassLoader ) throws CompileException {
        try {
            return ExpressionEvaluator.createFastExpressionEvaluator( new Scanner(null, new StringReader(expression)),  IExpressionEvaluator.DEFAULT_CLASS_NAME,          null,                                             interfaceToImplement,                             parameterNames,                                   null                                              );
        }
         catch (IOException ioe) {
            final AssertionError ae = new AssertionError("IOException despite StringReader");
            ae.initCause(ioe);
            throw ae;
        }
        
    }
    
 public static Object createFastExpressionEvaluator( Scanner               scanner, String                className, @Nullable Class<?>    extendedType, Class<?>              interfaceToImplement, String[]              parameterNames, @Nullable ClassLoader parentClassLoader ) throws CompileException, IOException {
        return ExpressionEvaluator.createFastExpressionEvaluator( scanner,               new String[0],         className,             extendedType,          interfaceToImplement,  parameterNames,        parentClassLoader      );
    }
    
 public static Object createFastExpressionEvaluator( Scanner               scanner, String[]              defaultImports, String                className, @Nullable Class<?>    extendedType, Class<?>              interfaceToImplement, String[]              parameterNames, @Nullable ClassLoader parentClassLoader ) throws CompileException, IOException {
        ExpressionEvaluator ee = new ExpressionEvaluator();
        ee.setClassName(className);
        ee.setExtendedClass(extendedType);
        ee.setDefaultImports(defaultImports);
        ee.setParentClassLoader(parentClassLoader);
        return ee.createFastEvaluator(scanner, interfaceToImplement, parameterNames);
    }
    
 public <T> T createFastEvaluator(Reader reader, Class<? extends T> interfaceToImplement, String... parameterNames) throws CompileException, IOException {
        return this.createFastEvaluator(new Scanner(null, reader), interfaceToImplement, parameterNames);
    }
    
 public <T> T createFastEvaluator(String script, Class<? extends T> interfaceToImplement, String... parameterNames) throws CompileException {
        try {
            return this.createFastEvaluator( new StringReader(script), interfaceToImplement, parameterNames );
        }
         catch (IOException ex) {
            throw new InternalCompilerException("IOException despite StringReader", ex);
        }
        
    }
    
    public <T> T createFastEvaluator(Scanner scanner, Class<T> interfaceToImplement, String... parameterNames) throws CompileException, IOException {
        if (!interfaceToImplement.isInterface()) {
            throw new InternalCompilerException("\"" + interfaceToImplement + "\" is not an interface");
        }
        
        Method methodToImplement;{
            Method[] methods = interfaceToImplement.getDeclaredMethods();
            if (methods.length != 1) {
                throw new InternalCompilerException( "Interface \"" + interfaceToImplement + "\" must declare exactly one method" );
            }
            
            methodToImplement = methods[0];
        }
        
        this.setImplementedInterfaces(new Class[] { interfaceToImplement });
        this.setOverrideMethod(true);
        this.setStaticMethod(false);
        if (this instanceof IExpressionEvaluator) {
            ((IExpressionEvaluator) this).setExpressionType(methodToImplement.getReturnType());
        }
         else {
            this.setExpressionType(methodToImplement.getReturnType());
        }
        
        this.setMethodName(methodToImplement.getName());
        this.setParameters(parameterNames, methodToImplement.getParameterTypes());
        this.setThrownExceptions(methodToImplement.getExceptionTypes());
        this.cook(scanner);
        @SuppressWarnings("unchecked") Class<? extends T> actualClass = (Class<? extends T>) this.getMethod().getDeclaringClass();
        try {
            return actualClass.newInstance();
        }
         catch (InstantiationException e) {
            throw new InternalCompilerException(e.toString(), e);
        }
         catch (IllegalAccessException e) {
            throw new InternalCompilerException(e.toString(), e);
        }
        
    }
    
    public static String[] guessParameterNames(Scanner scanner) throws CompileException, IOException {
        Parser parser = new Parser(scanner);
        while (parser.peek("import")) parser.parseImportDeclaration();
        Java.Rvalue rvalue = parser.parseExpression();
        if (!parser.peek(TokenType.END_OF_INPUT)) {
            throw new CompileException("Unexpected token \"" + parser.peek() + "\"", scanner.location());
        }
        
        final Set<String> parameterNames = new HashSet<>();
        new AbstractTraverser<RuntimeException>() { 

 public void traverseAmbiguousName(Java.AmbiguousName an) {
                for (String identifier : an.identifiers) {
                    if (Character.isUpperCase(identifier.charAt(0))) return;
                }
                
                parameterNames.add(an.identifiers[0]);
            }
            
        }
        .visitAtom(rvalue);
        return (String[]) parameterNames.toArray(new String[parameterNames.size()]);
    }
    
}


