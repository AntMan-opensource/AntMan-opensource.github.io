package hudson.plugins.jobConfigHistory;
import hudson.Extension;
import hudson.FilePath;
import hudson.XmlFile;
import hudson.maven.MavenModule;
import hudson.model.AbstractItem;
import hudson.model.Item;
import hudson.model.Node;
import jenkins.model.Jenkins;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;
import java.util.logging.Logger;
import static java.util.logging.Level.FINEST;
import static java.util.logging.Level.WARNING;
public class FileHistoryDao extends JobConfigHistoryStrategy implements Purgeable {
    private static final Logger LOG = Logger .getLogger(FileHistoryDao.class.getName());
    private static final int CLASH_SLEEP_TIME = 500;
    private final File historyRootDir;
    private final File jenkinsHome;
    private final MimickedUser currentUser;
    private final int maxHistoryEntries;
    private final boolean saveDuplicates;
    public FileHistoryDao() {
        this(null, null, null, 0, false);
    }
    
    public FileHistoryDao(final File historyRootDir, final File jenkinsHome, final MimickedUser currentUser, final int maxHistoryEntries, final boolean saveDuplicates) {
        this.historyRootDir = historyRootDir;
        this.jenkinsHome = jenkinsHome;
        this.currentUser = currentUser;
        this.maxHistoryEntries = maxHistoryEntries;
        this.saveDuplicates = saveDuplicates;
    }
    
    static void copyConfigFile(final File currentConfig, final File timestampedDir) throws FileNotFoundException, IOException {
        try (BufferedOutputStream configCopy = new BufferedOutputStream( new FileOutputStream( new File(timestampedDir, currentConfig.getName())))) {
            try (FileInputStream configOriginal = new FileInputStream( currentConfig)) {
                IOUtils.copy(configOriginal, configCopy);
            }
            
        }
        
    }
    
    static SimpleDateFormat getIdFormatter() {
        return new SimpleDateFormat(JobConfigHistoryConsts.ID_FORMATTER);
    }
    
    @SuppressWarnings("SleepWhileInLoop")
    static File createNewHistoryDir(final File itemHistoryDir, final AtomicReference<Calendar> timestampHolder) throws IOException {
        Calendar timestamp;
        File f;
        while (true) {
            timestamp = new GregorianCalendar();
            f = new File(itemHistoryDir, getIdFormatter().format(timestamp.getTime()));
            if (f.isDirectory()) {
                LOG.log(Level.FINE, "clash on {0}, will wait a moment", f);
                try {
                    Thread.sleep(CLASH_SLEEP_TIME);
                }
                 catch (InterruptedException x) {
                    throw new RuntimeException(x);
                }
                
            }
             else {
                timestampHolder.set(timestamp);
                break;
            }
            
        }
        
        final File jenkinsRootDir = Jenkins.get().getRootDir();
        boolean hasWritePermission = false;
        File firstExistingFile = null;
        boolean foundfirstExistingFile = false;
        File currentFile = f;
        while (currentFile != null && !currentFile.equals(jenkinsRootDir.getParentFile())) {
            if (currentFile.exists() && !foundfirstExistingFile) {
                foundfirstExistingFile = true;
                hasWritePermission = currentFile.canWrite();
                firstExistingFile = currentFile;
            }
            
            currentFile = currentFile.getParentFile();
        }
        
        if (!hasWritePermission) {
            String msg = "Could not create history entry's root directory \"" + f + "\": no write rights on \"" + firstExistingFile + "\".";
            LOG.log(WARNING, msg);
            throw new IOException(msg);
        }
        
        if (!(f.mkdirs() || f.exists())) {
            throw new RuntimeException("Could not create rootDir " + f);
        }
        
        return f;
    }
    
    public static File getConfigFile(final File historyDir) {
        File configFile = null;
        if (HistoryFileFilter.accepts(historyDir)) {
            try {
                final File[] listing = historyDir.listFiles();
                for (final File file : listing) {
                    if (!file.getName() .equals(JobConfigHistoryConsts.HISTORY_FILE) && file.getName().matches(".*\\.xml$")) {
                        configFile = file;
                    }
                    
                }
                
            }
             catch (NullPointerException e) {
                LOG.log(Level.WARNING, "History dir is null. ", e);
            }
            
        }
        
        return configFile;
    }
    
    File getRootDir(final XmlFile xmlFile, final AtomicReference<Calendar> timestampHolder) throws IOException {
        final File configFile = xmlFile.getFile();
        final File itemHistoryDir = getHistoryDir(configFile);
        purgeOldEntries(itemHistoryDir, maxHistoryEntries);
        return createNewHistoryDir(itemHistoryDir, timestampHolder);
    }
    
    void createHistoryXmlFile(final Calendar timestamp, final File timestampedDir, final String operation, final String newName, String oldName, String changeReasonComment) throws IOException {
        oldName = ((oldName == null) ? "" : oldName);
        final String user = currentUser != null ? currentUser.getFullName() : JobConfigHistoryConsts.UNKNOWN_USER_NAME;
        final String userId = currentUser != null ? currentUser.getId() : JobConfigHistoryConsts.UNKNOWN_USER_ID;
        final XmlFile historyDescription = getHistoryXmlFile(timestampedDir);
        final HistoryDescr myDescr = new HistoryDescr(user, userId, operation, getIdFormatter().format(timestamp.getTime()), (newName == null) ? "" : newName, (newName == null) ? "" : ((newName.equals(oldName)) ? "" : oldName), changeReasonComment);
        historyDescription.write(myDescr);
    }
    
    private XmlFile getHistoryXmlFile(final File directory) {
        return new XmlFile( new File(directory, JobConfigHistoryConsts.HISTORY_FILE));
    }
    
    public void createNewItem(final Item item) {
        final AbstractItem aItem = (AbstractItem) item;
        createNewHistoryEntryAndCopyConfig(aItem.getConfigFile(), Messages.ConfigHistoryListenerHelper_CREATED(), null, null, Optional.empty());
    }
    
    private void createNewHistoryEntryAndCopyConfig(final XmlFile configFile, final String operation, final String newName, final String oldName, final Optional<String> changeReasonCommentOptional) {
        final File timestampedDir = createNewHistoryEntry(configFile, operation, newName, oldName, changeReasonCommentOptional.orElse(null));
        try {
            copyConfigFile(configFile.getFile(), timestampedDir);
        }
         catch (IOException ex) {
            throw new RuntimeException("Unable to copy " + configFile, ex);
        }
        
    }
    
    private Optional<String> removeChangeReasonComment(final XmlFile configFile) throws IOException, SAXException, TransformerException, ParserConfigurationException {
        Document configFiledocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(configFile.getFile());
        NodeList jobLocalConfigurationNodes = configFiledocument.getElementsByTagName(JobConfigHistoryConsts.JOB_LOCAL_CONFIGURATION_XML_TAG);
        if (jobLocalConfigurationNodes.getLength() > 1) {
            LOG.log(FINEST, "tag \"{0}\" found twice in {1}, not saving the change reason comment.", new Object[]{JobConfigHistoryConsts.JOB_LOCAL_CONFIGURATION_XML_TAG, configFile.getFile()});
            return Optional.empty();
        }
         else if (jobLocalConfigurationNodes.getLength() == 1) {
            org.w3c.dom.Node jobLocalConfiguration = jobLocalConfigurationNodes.item(0);
            NodeList jlcChildren = jobLocalConfiguration.getChildNodes();
            org.w3c.dom.Node changeReasonCommentNode = null;
            for (int i = 0; i < jlcChildren.getLength(); ++i) {
                org.w3c.dom.Node node = jlcChildren.item(i);
                if (node.getNodeName().equals(JobConfigHistoryConsts.CHANGE_REASON_COMMENT_XML_TAG)) {
                    changeReasonCommentNode = node;
                }
                
            }
            
            if (changeReasonCommentNode != null) {
                String changeReasonComment = changeReasonCommentNode.getTextContent();
                if (changeReasonComment != null) {
                    jobLocalConfiguration.getParentNode().removeChild(jobLocalConfiguration);
                    TransformerFactory.newInstance().newTransformer() .transform(new DOMSource(configFiledocument), new StreamResult(configFile.getFile()));
                    return changeReasonComment.isEmpty() ? Optional.empty() : Optional.of(changeReasonComment);
                }
                 else return Optional.empty();
            }
             else return Optional.empty();
        }
         else {
            LOG.log(FINEST, "tag \"{0}\" not found in {1}, no comment could be found.", new Object[]{JobConfigHistoryConsts.JOB_LOCAL_CONFIGURATION_XML_TAG, configFile.getFile()});
            return Optional.empty();
        }
        
    }
    
    public void saveItem(final XmlFile file) {
        Optional<String> changeReasonCommentOptional;
        try {
            changeReasonCommentOptional = removeChangeReasonComment(file);
        }
         catch (IOException | SAXException | TransformerException | ParserConfigurationException e) {
            LOG.log(WARNING, "Error occurred while trying to extract changeReasonComment from config file: {0}", e);
            changeReasonCommentOptional = Optional.empty();
        }
        
        if (checkDuplicate(file)) {
            createNewHistoryEntryAndCopyConfig(file, Messages.ConfigHistoryListenerHelper_CHANGED(), null, null, changeReasonCommentOptional);
        }
        
    }
    
    public void deleteItem(final Item item) {
        final AbstractItem aItem = (AbstractItem) item;
        createNewHistoryEntry(aItem.getConfigFile(), Messages.ConfigHistoryListenerHelper_DELETED(), null, null, null);
        final File configFile = aItem.getConfigFile().getFile();
        final File currentHistoryDir = getHistoryDir(configFile);
        final SimpleDateFormat buildDateFormat = new SimpleDateFormat( "yyyyMMdd_HHmmss_SSS");
        final String timestamp = buildDateFormat.format(new Date());
        final String deletedHistoryName = item.getName() + DeletedFileFilter.DELETED_MARKER + timestamp;
        final File deletedHistoryDir = new File( currentHistoryDir.getParentFile(), deletedHistoryName);
        if (!currentHistoryDir.renameTo(deletedHistoryDir)) {
            LOG.log(Level.WARNING, "unable to rename deleted history dir to: {0}", deletedHistoryDir);
        }
        
    }
    
    private File getHistoryDir(Item item) {
        return new File(getHistoryDir(item.getRootDir()), item.getName());
    }
    
    public void changeItemLocation(Item item, String oldFullName, String newFullName) {
        final String onLocationChangedDescription = "old full name: " + oldFullName + ", new full name: " + newFullName;
        if (historyRootDir != null) {
            final String jobsStr;
            final File newHistoryDir = getHistoryDir(item);
            if (SystemUtils.IS_OS_UNIX) {
                jobsStr = "/jobs/";
            }
             else {
                jobsStr = "\\jobs\\";
            }
            
            final File oldHistoryDir = new File(newHistoryDir.getAbsolutePath() .replaceFirst( newFullName.replaceAll("/", jobsStr), oldFullName.replaceAll("/", jobsStr) ) );
            if (oldHistoryDir.exists()) {
                final FilePath newHistoryFilePath = new FilePath(newHistoryDir);
                final FilePath oldHistoryFilePath = new FilePath(oldHistoryDir);
                try {
                    oldHistoryFilePath.copyRecursiveTo(newHistoryFilePath);
                    oldHistoryFilePath.deleteRecursive();
                    LOG.log(FINEST, "completed move of old history files on location change {0}{1}", onLocationChangedDescription);
                }
                 catch (IOException e) {
                    final String ioExceptionStr = "unable to move old history on location change." + onLocationChangedDescription;
                    LOG.log(Level.SEVERE, ioExceptionStr, e);
                }
                 catch (InterruptedException e) {
                    final String irExceptionStr = "interrupted while moving old history on location change." + onLocationChangedDescription;
                    LOG.log(Level.WARNING, irExceptionStr, e);
                }
                
            }
            
        }
        
    }
    
    public void renameItem(final Item item, final String oldName, final String newName) {
        final AbstractItem aItem = (AbstractItem) item;
        final String onRenameDesc = " old name: " + oldName + ", new name: " + newName;
        if (historyRootDir != null) {
            final File configFile = aItem.getConfigFile().getFile();
            final File currentHistoryDir = getHistoryDir(configFile);
            final File historyParentDir = currentHistoryDir.getParentFile();
            final File oldHistoryDir = new File(historyParentDir, oldName);
            if (oldHistoryDir.exists()) {
                final FilePath fp = new FilePath(oldHistoryDir);
                try {
                    fp.copyRecursiveTo(new FilePath(currentHistoryDir));
                    fp.deleteRecursive();
                    LOG.log(FINEST, "completed move of old history files on rename.{0}", onRenameDesc);
                }
                 catch (IOException e) {
                    final String ioExceptionStr = "unable to move old history on rename." + onRenameDesc;
                    LOG.log(Level.SEVERE, ioExceptionStr, e);
                }
                 catch (InterruptedException e) {
                    final String irExceptionStr = "interrupted while moving old history on rename." + onRenameDesc;
                    LOG.log(Level.WARNING, irExceptionStr, e);
                }
                
            }
            
        }
        
        createNewHistoryEntryAndCopyConfig(aItem.getConfigFile(), Messages.ConfigHistoryListenerHelper_RENAMED(), newName, oldName, Optional.empty());
    }
    
    public SortedMap<String, HistoryDescr> getRevisions(final XmlFile xmlFile) {
        return getRevisions(xmlFile.getFile());
    }
    
    private SortedMap<String, HistoryDescr> getRevisions( final File configFile) {
        final File historiesDir = getHistoryDir(configFile);
        return getRevisionsFromHistoriesDir(historiesDir);
    }
    
    private SortedMap<String, HistoryDescr> getRevisionsFromHistoriesDir( final File historiesDir) {
        final File[] historyDirsOfItem = historiesDir .listFiles(HistoryFileFilter.INSTANCE);
        final TreeMap<String, HistoryDescr> map = new TreeMap<>();
        if (historyDirsOfItem == null) {
            return map;
        }
         else {
            for (File historyDir : historyDirsOfItem) {
                final XmlFile historyXml = getHistoryXmlFile(historyDir);
                final LazyHistoryDescr historyDescription = new LazyHistoryDescr( historyXml);
                map.put(historyDir.getName(), historyDescription);
            }
            
            return map;
        }
        
    }
    
    public int getRevisionAmount(XmlFile xmlFile) {
        final File configFile = xmlFile.getFile();
        final File historiesDir = getHistoryDir(configFile);
        final File[] historyDirsOfItem = historiesDir.listFiles(HistoryFileFilter.INSTANCE);
        if (historyDirsOfItem == null) {
            LOG.log(WARNING, "Error occurred while trying to calculate the current revision amount: {0}.listFiles(..) returned null.", historiesDir);
        }
        
        return historyDirsOfItem != null ? historyDirsOfItem.length : -1;
    }
    
    public int getSystemRevisionAmount(String sysConfigName) {
        return getSystemHistory(sysConfigName).size();
    }
    
    public int getSystemRevisionAmount() {
        return countSubDirs(getSystemConfigs());
    }
    
    public int getJobRevisionAmount() {
        return countSubDirs(getJobs()) + getDeletedJobAmount();
    }
    
    public int getDeletedJobAmount() {
        return getDeletedJobs().length;    
    }
    
    public int getJobRevisionAmount(String jobName) {
        return getJobHistory(jobName).size();
    }
    
    public int getTotalRevisionAmount() {
        return getJobRevisionAmount() + getSystemRevisionAmount();
    }
    
    private int countSubDirs(File[] files) {
        return Arrays.stream(files) .map(file -> file.listFiles(HistoryFileFilter.INSTANCE).length) .reduce(Integer::sum) .orElse(0);
    }
    
    public XmlFile getOldRevision(final AbstractItem item, final String identifier) {
        final File configFile = item.getConfigFile().getFile();
        final File historyDir = new File(getHistoryDir(configFile), identifier);
        if (PluginUtils.isMavenPluginAvailable() && item instanceof MavenModule) {
            final String path = historyDir + ((MavenModule) item).getParent().getFullName() .replace("/", "/jobs/") + "/modules/" + ((MavenModule) item).getModuleName().toFileSystemName() + "/" + identifier;
            return new XmlFile(getConfigFile(new File(path)));
        }
         else {
            return new XmlFile(getConfigFile(historyDir));
        }
        
    }
    
    public XmlFile getOldRevision(final XmlFile xmlFile, final String identifier) {
        final File configFile = xmlFile.getFile();
        return getOldRevision(configFile, identifier);
    }
    
    private XmlFile getOldRevision(final File configFile, final String identifier) {
        final File historyDir = new File(getHistoryDir(configFile), identifier);
        return new XmlFile(getConfigFile(historyDir));
    }
    
    public XmlFile getOldRevision(final String configFileName, final String identifier) {
        final File historyDir = new File( new File(historyRootDir, configFileName), identifier);
        final File configFile = getConfigFile(historyDir);
        if (configFile == null) {
            throw new IllegalArgumentException("Could not find " + historyDir);
        }
        
        return new XmlFile(configFile);
    }
    
    public void deleteRevision(AbstractItem abstractItem, String identifier) {
        final File configFile = abstractItem.getConfigFile().getFile();
        final File currentHistoryDir = getHistoryDir(configFile);
        final File timestampDir;
        try {
            timestampDir = getSubDirectory(currentHistoryDir, identifier);
            try {
                FileUtils.deleteDirectory(timestampDir);
            }
             catch (IOException e) {
                LOG.log(Level.WARNING, "unable to delete revision {0}: {1}", new Object[]{identifier, e.getMessage()});
            }
            
        }
         catch (FileNotFoundException e) {
            LOG.log(Level.WARNING, "unable to delete revision {0}: file not found.", identifier);
        }
        
        LOG.log(FINEST, "{0} 's revision {1} deleted.", new Object[]{abstractItem.getFullName(), identifier});
    }
    
    public void deleteRevision(Node node, String identifier) {
        final File timestampDir = getOldRevision(node, identifier).getFile().getParentFile();
        try {
            FileUtils.deleteDirectory(timestampDir);
        }
         catch (IOException e) {
            LOG.log(Level.WARNING, "unable to delete revision {0}: {1}", new Object[]{identifier, e.getMessage()});
        }
        
        LOG.log(FINEST, "{0} 's revision {1} deleted.", new Object[]{node.getDisplayName(), identifier});
    }
    
    public void deleteRevision(File historyDir, String identifier) {
        final File timestampDir;
        try {
            timestampDir = getSubDirectory(historyDir, identifier);
            try {
                FileUtils.deleteDirectory(timestampDir);
            }
             catch (IOException e) {
                LOG.log(Level.WARNING, "unable to delete revision {0}: {1}", new Object[]{identifier, e.getMessage()});
            }
            
        }
         catch (FileNotFoundException e) {
            LOG.log(Level.WARNING, "unable to delete revision {0}: file not found.", identifier);
        }
        
        LOG.log(FINEST, "{0} 's revision {1} deleted.", new Object[]{historyDir.getName(), identifier});
    }
    
    public boolean revisionEqualsCurrent(AbstractItem project, String identifier1) {
        try {
            return FileUtils.contentEquals( getConfigFile(getSubDirectory(getHistoryDir(project), identifier1)), project.getConfigFile().getFile() );
        }
         catch (IOException e) {
            LOG.log(Level.WARNING, " could not access config file while trying to check revision equality.");
            e.printStackTrace();
            return false;
        }
        
    }
    
    public boolean revisionEqualsCurrent(Node node, String identifier1) {
        String currentContent = Jenkins.XSTREAM2.toXML(node);
        try {
            return StringUtils.equals( FileUtils.readFileToString(getOldRevision(node, identifier1).getFile(), "UTF-8"), currentContent );
        }
         catch (IOException e) {
            LOG.log(Level.WARNING, " could not access config file while trying to check revision equality.");
            e.printStackTrace();
            return false;
        }
        
    }
    
    public boolean hasOldRevision(final XmlFile xmlFile, final String identifier) {
        final File configFile = xmlFile.getFile();
        final XmlFile oldRevision = getOldRevision(configFile, identifier);
        return oldRevision.getFile() != null && oldRevision.getFile().exists();
    }
    
    public File getHistoryDir(final File configFile) {
        final String configRootDir = configFile.getParent();
        final String jenkinsRootDir = jenkinsHome.getPath();
        if (!configRootDir.startsWith(jenkinsRootDir)) {
            throw new IllegalArgumentException( "Trying to get history dir for object outside of Jenkins: " + configFile);
        }
        
        String underRootDir = null;
        if (configRootDir.equals(jenkinsRootDir)) {
            final String fileName = configFile.getName();
            underRootDir = fileName.substring(0, fileName.lastIndexOf('.'));
        }
        
        final File historyDir;
        if (underRootDir == null) {
            final String remainingPath = configRootDir .substring(jenkinsRootDir.length() + JobConfigHistoryConsts.JOBS_HISTORY_DIR.length() + 1);
            historyDir = new File(getJobHistoryRootDir(), remainingPath);
        }
         else {
            historyDir = new File(historyRootDir, underRootDir);
        }
        
        return historyDir;
    }
    
    File getJobHistoryRootDir() {
        return new File(historyRootDir, "/" + JobConfigHistoryConsts.JOBS_HISTORY_DIR);
    }
    
    public void purgeOldEntries(final File itemHistoryRoot, final int maxEntries) {
        if (maxEntries > 0) {
            LOG.log(Level.FINE, "checking for history files to purge ({0} max allowed)", maxEntries);
            final int entriesToLeave = maxEntries - 1;
            final File[] historyDirs = itemHistoryRoot .listFiles(HistoryFileFilter.INSTANCE);
            if (historyDirs != null && historyDirs.length >= entriesToLeave) {
                Arrays.sort(historyDirs, Collections.reverseOrder());
                for (int i = entriesToLeave; i < historyDirs.length; i++) {
                    if (isCreatedEntry(historyDirs[i])) {
                        continue;
                    }
                    
                    LOG.log(Level.FINE, "purging old directory from history logs: {0}", historyDirs[i]);
                    deleteDirectory(historyDirs[i]);
                }
                
            }
            
        }
        
    }
    
    public boolean isCreatedEntry(final File historyDir) {
        final XmlFile historyXml = getHistoryXmlFile(historyDir);
        try {
            final HistoryDescr histDescr = (HistoryDescr) historyXml.read();
            LOG.log(Level.FINEST, "historyDir: {0}", historyDir);
            LOG.log(Level.FINEST, "histDescr.getOperation(): {0}", histDescr.getOperation());
            if ("Created".equals(histDescr.getOperation())) {
                return true;
            }
            
        }
         catch (IOException ex) {
            LOG.log(Level.FINEST, "Unable to retrieve history file for {0}", historyDir);
        }
        
        return false;
    }
    
    private void deleteDirectory(final File dir) {
        try {
            for (File file : dir.listFiles()) {
                if (!file.delete()) {
                    LOG.log(Level.WARNING, "problem deleting history file: {0}", file);
                }
                
            }
            
            if (!dir.delete()) {
                LOG.log(Level.WARNING, "problem deleting history directory: {0}", dir);
            }
            
        }
         catch (NullPointerException e) {
            LOG.log(Level.WARNING, "Directory already deleted or null. ", e);
        }
        
    }
    
    boolean hasDuplicateHistory(final XmlFile xmlFile) {
        boolean isDuplicated = false;
        final ArrayList<String> timeStamps = new ArrayList<>( getRevisions(xmlFile).keySet());
        if (!timeStamps.isEmpty()) {
            timeStamps.sort(Collections.reverseOrder());
            final XmlFile lastRevision = getOldRevision(xmlFile, timeStamps.get(0));
            try {
                if (xmlFile.asString().equals(lastRevision.asString())) {
                    isDuplicated = true;
                }
                
            }
             catch (IOException e) {
                LOG.log(Level.WARNING, "unable to check for duplicate previous history file: {0}\n{1}", new Object[]{lastRevision, e});
            }
            
        }
        
        return isDuplicated;
    }
    
    boolean checkDuplicate(final XmlFile xmlFile) {
        if (!saveDuplicates && hasDuplicateHistory(xmlFile)) {
            LOG.log(Level.FINE, "found duplicate history, skipping save of {0}", xmlFile);
            return false;
        }
         else {
            return true;
        }
        
    }
    
    public File[] getDeletedJobs() {
        return returnEmptyFileArrayForNull(getJobFilesIncludingThoseInFolders(DeletedFileFilter.INSTANCE));
    }
    
    public File[] getDeletedJobs(final String folderName) {
        return returnEmptyFileArrayForNull( getJobDirectoryIncludingFolder(folderName) .listFiles(DeletedFileFilter.INSTANCE));
    }
    
    public File[] getJobs() {
        return returnEmptyFileArrayForNull(getJobFilesIncludingThoseInFolders(NonDeletedFileFilter.INSTANCE));
    }
    
    public File[] getJobs(final String folderName) {
        return returnEmptyFileArrayForNull( getJobDirectoryIncludingFolder(folderName) .listFiles(NonDeletedFileFilter.INSTANCE));
    }
    
    private File getJobDirectoryIncludingFolder(final String folderName) {
        final String realFolderName = folderName.isEmpty() ? folderName : folderName + "/jobs";
        return new File(getJobHistoryRootDir(), realFolderName);
    }
    
    private File[] getJobFilesIncludingThoseInFolders(final FileFilter fileFilter) {
        final List<File> folderFiles = getJobFilesIncludingThoseInFolders();
        return folderFiles.stream().filter(fileFilter::accept).toArray(File[]::new);
    }
    
    private List<File> getJobFilesIncludingThoseInFolders() {
        return getJobFilesIncludingThoseInFolders(getJobHistoryRootDir());
    }
    
    private boolean isFolder(File file) {
        boolean hasJobsSubdirectory = false;
        File[] files = file.listFiles();
        if (files == null) {
            return false;
        }
        
        for (File child : files) {
            if (child.getName().equals("jobs")) {
                hasJobsSubdirectory = true;
                break;
            }
            
        }
        
        return file.getParentFile().getName().equals("jobs") && file.isDirectory() && hasJobsSubdirectory;
    }
    
    private boolean isJobFile(File file) {
        return file.getParentFile().getName().equals("jobs");
    }
    
    private File getSubDirectory(File file, String subdirectoryName) throws FileNotFoundException {
        FileNotFoundException up = new FileNotFoundException("File " + new File(file, subdirectoryName) + " not found.");
        File[] files = file.listFiles();
        if (files == null) {
            throw up;
        }
        
        for (File child : files) {
            if (child.getName().equals(subdirectoryName)) {
                return child;
            }
            
        }
        
        throw up;
    }
    
    private List<File> getJobFilesIncludingThoseInFolders(File fromFile) {
        List<File> folderNames = new LinkedList<>();
        File[] currentChildren = fromFile.listFiles();
        if (currentChildren == null) {
            return folderNames;
        }
        
        for (File child : currentChildren) {
            if (isFolder(child)) {
                try {
                    folderNames.addAll(getJobFilesIncludingThoseInFolders(getSubDirectory(child, "jobs")));
                }
                 catch (FileNotFoundException e) {
                    LOG.log(Level.SEVERE, "File not found although it should have been found: " + new File(child, "jobs"));
                }
                
            }
             else if (isJobFile(child)) {
                folderNames.add(child);
            }
            
        }
        
        return folderNames;
    }
    
    public File[] getSystemConfigs() {
        return returnEmptyFileArrayForNull( historyRootDir.listFiles(NonJobsDirectoryFileFilter.INSTANCE));
    }
    
    public SortedMap<String, HistoryDescr> getSystemConfigsMap() {
        File[] systemConfigsArr = getSystemConfigs();
        if (systemConfigsArr.length == 0) {
            return Collections.emptySortedMap();
        }
         else {
            final TreeMap<String, HistoryDescr> map = new TreeMap<>();
            for (File historyDir : systemConfigsArr) {
                final XmlFile historyXml = getHistoryXmlFile(historyDir);
                final LazyHistoryDescr historyDescription = new LazyHistoryDescr( historyXml);
                map.put(historyDir.getName(), historyDescription);
            }
            
            return map;
        }
        
    }
    
    private File[] returnEmptyFileArrayForNull(final File[] array) {
        if (array != null) {
            return array;
        }
         else {
            return new File[0];
        }
        
    }
    
    public SortedMap<String, HistoryDescr> getJobHistory(final String jobName) {
        File jobHistoryRootDir = getJobHistoryRootDir();
        File jobNameSubFolder = new File(jobHistoryRootDir, jobName);
        if(!fileIsContainedInDirectory(jobNameSubFolder, jobHistoryRootDir)) {
            return new TreeMap<>();
        }
        
        return getRevisionsFromHistoriesDir(jobNameSubFolder);
    }
    
    public SortedMap<String, HistoryDescr> getSystemHistory(final String name) {
        File systemSubFolder = new File(historyRootDir, name);
        if(!fileIsContainedInDirectory(systemSubFolder, historyRootDir)) {
            return new TreeMap<>();
        }
        
        return getRevisionsFromHistoriesDir(systemSubFolder);
    }
    
    public void copyHistoryAndDelete(final String oldName, final String newName) {
        final File oldFile = new File(getJobHistoryRootDir(), oldName);
        final File newFile = new File(getJobHistoryRootDir(), newName);
        try {
            FileUtils.copyDirectory(oldFile, newFile);
            FileUtils.deleteDirectory(oldFile);
        }
         catch (IOException ex) {
            throw new IllegalArgumentException( "Unable to move from " + oldFile + " to " + newFile, ex);
        }
        
    }
    
    public void createNewNode(final Node node) {
        final String content = Jenkins.XSTREAM2.toXML(node);
        createNewHistoryEntryAndSaveConfig(node, content, Messages.ConfigHistoryListenerHelper_CREATED(), null, null);
    }
    
    private void createNewHistoryEntryAndSaveConfig(final Node node, final String content, final String operation, final String newName, final String oldName) {
        final File timestampedDir = createNewHistoryEntry(node, operation, newName, oldName, null);
        final File nodeConfigHistoryFile = new File(timestampedDir, "config.xml");
        try (PrintStream stream = new PrintStream(nodeConfigHistoryFile, "UTF-8")) {
            stream.print(content);
        }
         catch (IOException ex) {
            throw new RuntimeException( "Unable to write " + nodeConfigHistoryFile, ex);
        }
        
    }
    
    public void deleteNode(final Node node) {
        createNewHistoryEntry(node, Messages.ConfigHistoryListenerHelper_DELETED(), null, null, null);
        final File currentHistoryDir = getHistoryDirForNode(node);
        final SimpleDateFormat buildDateFormat = new SimpleDateFormat( "yyyyMMdd_HHmmss_SSS");
        final String timestamp = buildDateFormat.format(new Date());
        final String deletedHistoryName = node.getNodeName() + DeletedFileFilter.DELETED_MARKER + timestamp;
        final File deletedHistoryDir = new File( currentHistoryDir.getParentFile(), deletedHistoryName);
        if (!currentHistoryDir.renameTo(deletedHistoryDir)) {
            LOG.log(Level.WARNING, "unable to rename deleted history dir to: {0}", deletedHistoryDir);
        }
        
    }
    
    public void renameNode(final Node node, final String oldName, final String newName) {
        final String onRenameDesc = " old name: " + oldName + ", new name: " + newName;
        if (historyRootDir != null) {
            final File currentHistoryDir = getHistoryDirForNode(node);
            final File historyParentDir = currentHistoryDir.getParentFile();
            final File oldHistoryDir = new File(historyParentDir, oldName);
            if (oldHistoryDir.exists()) {
                final FilePath fp = new FilePath(oldHistoryDir);
                try {
                    fp.copyRecursiveTo(new FilePath(currentHistoryDir));
                    fp.deleteRecursive();
                    LOG.log(Level.FINEST, "completed move of old history files on rename.{0}", onRenameDesc);
                }
                 catch (IOException e) {
                    final String ioExceptionStr = "unable to move old history on rename." + onRenameDesc;
                    LOG.log(Level.SEVERE, ioExceptionStr, e);
                }
                 catch (InterruptedException e) {
                    final String irExceptionStr = "interrupted while moving old history on rename." + onRenameDesc;
                    LOG.log(Level.WARNING, irExceptionStr, e);
                }
                
            }
            
        }
        
        final String content = Jenkins.XSTREAM2.toXML(node);
        createNewHistoryEntryAndSaveConfig(node, content, Messages.ConfigHistoryListenerHelper_RENAMED(), newName, oldName);
    }
    
    public SortedMap<String, HistoryDescr> getRevisions(final Node node) {
        final File historiesDir = getHistoryDirForNode(node);
        final File[] historyDirsOfItem = historiesDir .listFiles(HistoryFileFilter.INSTANCE);
        final TreeMap<String, HistoryDescr> map = new TreeMap<>();
        if (historyDirsOfItem == null) {
            return map;
        }
         else {
            for (File historyDir : historyDirsOfItem) {
                final XmlFile historyXml = getHistoryXmlFile(historyDir);
                final HistoryDescr historyDescription;
                try {
                    historyDescription = (HistoryDescr) historyXml.read();
                }
                 catch (IOException ex) {
                    throw new RuntimeException("Unable to read history for " + node.getDisplayName(), ex);
                }
                
                map.put(historyDir.getName(), historyDescription);
            }
            
            return map;
        }
        
    }
    
    private File getRootDir(final Node node, final AtomicReference<Calendar> timestampHolder) throws IOException {
        final File itemHistoryDir = getHistoryDirForNode(node);
        purgeOldEntries(itemHistoryDir, maxHistoryEntries);
        return createNewHistoryDir(itemHistoryDir, timestampHolder);
    }
    
    private File createNewHistoryEntry(final Node node, final String operation, final String newName, final String oldName, String changeReasonComment) {
        try {
            final AtomicReference<Calendar> timestampHolder = new AtomicReference<>();
            final File timestampedDir = getRootDir(node, timestampHolder);
            LOG.log(Level.FINE, "{0} on {1}", new Object[]{this, timestampedDir});
            createHistoryXmlFile(timestampHolder.get(), timestampedDir, operation, newName, oldName, changeReasonComment);
            assert timestampHolder.get() != null;
            return timestampedDir;
        }
         catch (IOException e) {
            throw new RuntimeException( "Unable to create history entry for configuration file of node " + "\"" + node.getDisplayName() + "\": " + e.getMessage(), e);
        }
        
    }
    
    File createNewHistoryEntry(final XmlFile xmlFile, final String operation, final String newName, final String oldName, String changeReasonComment) {
        try {
            final AtomicReference<Calendar> timestampHolder = new AtomicReference<>();
            final File timestampedDir = getRootDir(xmlFile, timestampHolder);
            LOG.log(Level.FINE, "{0} on {1}", new Object[]{this, timestampedDir});
            createHistoryXmlFile(timestampHolder.get(), timestampedDir, operation, newName, oldName, changeReasonComment);
            assert timestampHolder.get() != null;
            return timestampedDir;
        }
         catch (IOException e) {
            throw new RuntimeException( "Unable to create history entry for configuration file " + "\"" + xmlFile.getFile().getAbsolutePath() + "\": " + e.getMessage(), e);
        }
        
    }
    
    private File getHistoryDirForNode(final Node node) {
        final String name = node.getNodeName();
        final File configHistoryDir = getNodeHistoryRootDir();
        return new File(configHistoryDir, name);
    }
    
    File getNodeHistoryRootDir() {
        return new File(historyRootDir, "/" + JobConfigHistoryConsts.NODES_HISTORY_DIR);
    }
    
    public boolean hasDuplicateHistory(final Node node) {
        final String content = Jenkins.XSTREAM2.toXML(node);
        boolean isDuplicated = false;
        final ArrayList<String> timeStamps = new ArrayList<>( getRevisions(node).keySet());
        if (!timeStamps.isEmpty()) {
            timeStamps.sort(Collections.reverseOrder());
            final XmlFile lastRevision = getOldRevision(node, timeStamps.get(0));
            try {
                if (content.equals(lastRevision.asString())) {
                    isDuplicated = true;
                }
                
            }
             catch (IOException e) {
                LOG.log(Level.WARNING, "unable to check for duplicate previous history file: {0}\n{1}", new Object[]{lastRevision, e});
            }
            
        }
        
        return isDuplicated;
    }
    
    private boolean checkDuplicate(final Node node) {
        if (!saveDuplicates && hasDuplicateHistory(node)) {
            LOG.log(Level.FINE, "found duplicate history, skipping save of {0}", node.getDisplayName());
            return false;
        }
         else {
            return true;
        }
        
    }
    
    public void saveNode(final Node node) {
        final String content = Jenkins.XSTREAM2.toXML(node);
        if (checkDuplicate(node)) {
            createNewHistoryEntryAndSaveConfig(node, content, Messages.ConfigHistoryListenerHelper_CHANGED(), null, null);
        }
        
    }
    
    public XmlFile getOldRevision(final Node node, final String identifier) {
        final File historyDir = new File(getHistoryDirForNode(node), identifier);
        return new XmlFile(getConfigFile(historyDir));
    }
    
    private boolean fileIsContainedInDirectory(File file, File directory) {
        try {
            return file.toPath().toRealPath().startsWith(directory.toPath().toRealPath());
        }
         catch (IOException ignored) {

}

        return false;
    }
    
    public boolean hasOldRevision(final Node node, final String identifier) {
        final XmlFile oldRevision = getOldRevision(node, identifier);
        return oldRevision.getFile() != null && oldRevision.getFile().exists();
    }
    
}


