package hudson.plugins.emailext.plugins.content;
import hudson.FilePath;
import hudson.Plugin;
import hudson.model.AbstractBuild;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.plugins.emailext.ExtendedEmailPublisher;
import hudson.remoting.VirtualChannel;
import hudson.security.ACL;
import hudson.security.ACLContext;
import hudson.util.FormValidation;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import jenkins.MasterToSlaveFileCallable;
import jenkins.model.Jenkins;
import org.apache.commons.io.FilenameUtils;
import org.jenkinsci.lib.configprovider.ConfigProvider;
import org.jenkinsci.lib.configprovider.model.Config;
import org.jenkinsci.plugins.configfiles.ConfigFiles;
import org.jenkinsci.plugins.scriptsecurity.scripts.Language;
import org.jenkinsci.plugins.scriptsecurity.scripts.ScriptApproval;
import org.jenkinsci.plugins.tokenmacro.DataBoundTokenMacro;
import org.jenkinsci.plugins.tokenmacro.MacroEvaluationException;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
public abstract class AbstractEvalContent extends DataBoundTokenMacro {
    protected static final String EMAIL_TEMPLATES_DIRECTORY = "email-templates";
    protected final String macroName;
    public AbstractEvalContent(String macroName) {
        this.macroName = macroName;
    }
    
    public String evaluate(AbstractBuild<?, ?> build, TaskListener listener, String macroName) throws MacroEvaluationException, IOException, InterruptedException {
        return evaluate(build, build.getWorkspace(), listener, macroName);
    }
    
    public abstract String evaluate(Run<?, ?> run, FilePath workspace, TaskListener listener, String macroName) throws MacroEvaluationException, IOException, InterruptedException;
    public boolean acceptsMacroName(String macroName) {
        return macroName.equals(this.macroName);
    }
    
    public static File scriptsFolder() {
        return new File(Jenkins.get().getRootDir(), EMAIL_TEMPLATES_DIRECTORY);
    }
    
    protected abstract Class<? extends ConfigProvider> getProviderClass();
    public boolean hasNestedContent() {
        return false;
    }
    
    protected InputStream getFileInputStream(Run<?, ?> run, FilePath workspace, String fileName, String extension) throws IOException, InterruptedException {
        InputStream inputStream = null;
        if(fileName.startsWith("managed:")) {
            String managedFileName = fileName.substring(8);
            try {
                inputStream = getManagedFile(run, managedFileName);
            }
             catch(NoClassDefFoundError e) {
                inputStream = null;
            }
            
            if(inputStream == null) {
                throw new FileNotFoundException(String.format("Managed file '%s' not found", managedFileName));
            }
            
            return inputStream;
        }
        
        String fileExt = FilenameUtils.getExtension(fileName);
        if ("".equals(fileExt)) {
            fileName += extension;
        }
            
        if(workspace != null) {
            FilePath file = workspace.child(fileName);
            if(file.exists() && isChildOf(file, workspace)) { 
                inputStream = new UserProvidedContentInputStream(file.read());
            }
            
        }
        
        if(inputStream == null) {        
            inputStream = getClass().getClassLoader().getResourceAsStream( "hudson/plugins/emailext/templates/" + fileName);
            if (inputStream == null) {
                File templateFile = new File(scriptsFolder(), fileName);
                if(!templateFile.exists()) {
                    fileName += extension;
                    templateFile = new File(scriptsFolder(), fileName);
                }
                
                if (!templateFile.exists() || !isChildOf(new FilePath(templateFile), new FilePath(scriptsFolder()))) {                      throw new FileNotFoundException(fileName); 
                }
                 else {
                    inputStream = new FileInputStream(templateFile);
                }
                
            }
            
        }
        
        return inputStream;
    }
    
    public static boolean isChildOf(final FilePath potentialChild, final FilePath parent) throws IOException, InterruptedException {
        return parent.act(new IsChildFileCallable(potentialChild));
    }
    
    private InputStream getManagedFile(Run<?, ?> run, String fileName) {
        InputStream stream = null;
        Plugin plugin = Jenkins.get().getPlugin("config-file-provider");
        if (plugin != null) {
            Config config = null;
            List<Config> configs = ConfigFiles.getConfigsInContext(run.getParent().getParent(), getProviderClass());
            for (Config c : configs) {
                if (c.name.equalsIgnoreCase(fileName)) {
                    config = c;
                    break;
                }
                
            }
            
            if (config != null) {
               stream = new ByteArrayInputStream(config.content.getBytes(StandardCharsets.UTF_8));
            }
            
        }
        
        return stream;
    }
    
    protected String generateMissingFile(String type, String fileName) {
        return type + " file [" + fileName + "] was not found in $JENKINS_HOME/" + EMAIL_TEMPLATES_DIRECTORY + ".";
    }
    
    protected String getCharset(Run<?, ?> build) {
        return ExtendedEmailPublisher.descriptor().getCharset();
    }
    
    public static boolean isApprovedScript(final String script, final Language language) {
        final ScriptApproval approval = ScriptApproval.get();
        try {
            try (ACLContext context = ACL.as2(Jenkins.ANONYMOUS2)) {
                return approval.checking(script, language).kind == FormValidation.Kind.OK;
            }
            
        }
         catch (Exception e) {
            Logger.getLogger(AbstractEvalContent.class.getName()).log(Level.WARNING, "Could not determine approval state of script.", e);
            return false;
        }
        
    }
    
    private static class IsChildFileCallable extends MasterToSlaveFileCallable<Boolean> {
        private final FilePath potentialChild;
        private IsChildFileCallable(FilePath potentialChild) {
            this.potentialChild = potentialChild;
        }
        
        public Boolean invoke(File parent, VirtualChannel channel) {
            if (potentialChild.isRemote()) {
                return false;
            }
            
            FilePath test = potentialChild.getParent();
            FilePath target = new FilePath(parent);
            while(test != null && !target.equals(test)) {
                test = test.getParent();
            }
            
            return target.equals(test);
        }
        
    }
    
}


