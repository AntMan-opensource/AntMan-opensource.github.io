package com.itextpdf.kernel.utils;
import com.itextpdf.io.LogMessageConstant;
import com.itextpdf.io.font.PdfEncodings;
import com.itextpdf.io.util.FileUtil;
import com.itextpdf.io.util.GhostscriptHelper;
import com.itextpdf.io.util.ImageMagickHelper;
import com.itextpdf.io.util.MessageFormatUtil;
import com.itextpdf.io.util.UrlUtil;
import com.itextpdf.kernel.counter.event.IMetaInfo;
import com.itextpdf.kernel.geom.Rectangle;
import com.itextpdf.kernel.pdf.DocumentProperties;
import com.itextpdf.kernel.pdf.PdfArray;
import com.itextpdf.kernel.pdf.PdfBoolean;
import com.itextpdf.kernel.pdf.PdfDictionary;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfDocumentInfo;
import com.itextpdf.kernel.pdf.PdfIndirectReference;
import com.itextpdf.kernel.pdf.PdfName;
import com.itextpdf.kernel.pdf.PdfNumber;
import com.itextpdf.kernel.pdf.PdfObject;
import com.itextpdf.kernel.pdf.PdfReader;
import com.itextpdf.kernel.pdf.PdfStream;
import com.itextpdf.kernel.pdf.PdfString;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.kernel.pdf.ReaderProperties;
import com.itextpdf.kernel.pdf.StampingProperties;
import com.itextpdf.kernel.pdf.annot.PdfAnnotation;
import com.itextpdf.kernel.pdf.annot.PdfLinkAnnotation;
import com.itextpdf.kernel.pdf.canvas.PdfCanvas;
import com.itextpdf.kernel.xmp.PdfConst;
import com.itextpdf.kernel.xmp.XMPConst;
import com.itextpdf.kernel.xmp.XMPMeta;
import com.itextpdf.kernel.xmp.XMPMetaFactory;
import com.itextpdf.kernel.xmp.XMPUtils;
import com.itextpdf.kernel.xmp.options.ParseOptions;
import com.itextpdf.kernel.xmp.options.SerializeOptions;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.TreeSet;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
public class CompareTool {
    private static final String FILE_PROTOCOL = "file://";
    private static final String UNEXPECTED_NUMBER_OF_PAGES = "Unexpected number of pages for <filename>.";
    private static final String DIFFERENT_PAGES = "File " + FILE_PROTOCOL + "<filename> differs on page <pagenumber>.";
    private static final String IGNORED_AREAS_PREFIX = "ignored_areas_";
    private static final String VERSION_REGEXP = "(iText\u00ae( pdfX(FA|fa)| DITO)?|iTextSharp\u2122) (\\d+\\.)+\\d+(-SNAPSHOT)?";
    private static final String VERSION_REPLACEMENT = "iText\u00ae <version>";
    private static final String COPYRIGHT_REGEXP = "\u00a9\\d+-\\d+ iText Group NV";
    private static final String COPYRIGHT_REPLACEMENT = "\u00a9<copyright years> iText Group NV";
    private static final String NEW_LINES = "\\r|\\n";
    private String cmpPdf;
    private String cmpPdfName;
    private String cmpImage;
    private String outPdf;
    private String outPdfName;
    private String outImage;
    private ReaderProperties outProps;
    private ReaderProperties cmpProps;
    private List<PdfIndirectReference> outPagesRef;
    private List<PdfIndirectReference> cmpPagesRef;
    private int compareByContentErrorsLimit = 1000;
    private boolean generateCompareByContentXmlReport = false;
    private boolean encryptionCompareEnabled = false;
    private boolean useCachedPagesForComparison = true;
    private IMetaInfo metaInfo;
    private String gsExec;
    private String compareExec;
    public CompareTool() {
    }
    
    CompareTool(String gsExec, String compareExec) {
        this.gsExec = gsExec;
        this.compareExec = compareExec;
    }
    
    public CompareResult compareByCatalog(PdfDocument outDocument, PdfDocument cmpDocument) throws IOException {
        CompareResult compareResult = null;
        compareResult = new CompareResult(compareByContentErrorsLimit);
        ObjectPath catalogPath = new ObjectPath(cmpDocument.getCatalog().getPdfObject().getIndirectReference(), outDocument.getCatalog().getPdfObject().getIndirectReference());
        Set<PdfName> ignoredCatalogEntries = new LinkedHashSet<>(Arrays.asList(PdfName.Metadata));
        compareDictionariesExtended(outDocument.getCatalog().getPdfObject(), cmpDocument.getCatalog().getPdfObject(), catalogPath, compareResult, ignoredCatalogEntries);
        if (cmpPagesRef == null || outPagesRef == null) {
            return compareResult;
        }
        
        if (outPagesRef.size() != cmpPagesRef.size() && !compareResult.isMessageLimitReached()) {
            compareResult.addError(catalogPath, "Documents have different numbers of pages.");
        }
        
        for (int i = 0; i < Math.min(cmpPagesRef.size(), outPagesRef.size()); i++) {
            if (compareResult.isMessageLimitReached()) {
                break;
            }
            
            ObjectPath currentPath = new ObjectPath(cmpPagesRef.get(i), outPagesRef.get(i));
            PdfDictionary outPageDict = (PdfDictionary) outPagesRef.get(i).getRefersTo();
            PdfDictionary cmpPageDict = (PdfDictionary) cmpPagesRef.get(i).getRefersTo();
            compareDictionariesExtended(outPageDict, cmpPageDict, currentPath, compareResult);
        }
        
        return compareResult;
    }
    
    public CompareTool disableCachedPagesComparison() {
        this.useCachedPagesForComparison = false;
        return this;
    }
    
    public CompareTool setCompareByContentErrorsLimit(int compareByContentMaxErrorCount) {
        this.compareByContentErrorsLimit = compareByContentMaxErrorCount;
        return this;
    }
    
    public CompareTool setGenerateCompareByContentXmlReport(boolean generateCompareByContentXmlReport) {
        this.generateCompareByContentXmlReport = generateCompareByContentXmlReport;
        return this;
    }
    
    public void setEventCountingMetaInfo(IMetaInfo metaInfo) {
        this.metaInfo = metaInfo;
    }
    
    public CompareTool enableEncryptionCompare() {
        this.encryptionCompareEnabled = true;
        return this;
    }
    
    public ReaderProperties getOutReaderProperties() {
        if (outProps == null) {
            outProps = new ReaderProperties();
        }
        
        return outProps;
    }
    
    public ReaderProperties getCmpReaderProperties() {
        if (cmpProps == null) {
            cmpProps = new ReaderProperties();
        }
        
        return cmpProps;
    }
    
    public String compareVisually(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix) throws InterruptedException, IOException {
        return compareVisually(outPdf, cmpPdf, outPath, differenceImagePrefix, null);
    }
    
    public String compareVisually(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas) throws InterruptedException, IOException {
        init(outPdf, cmpPdf);
        System.out.println("Out pdf: " + UrlUtil.getNormalizedFileUriString(outPdf));
        System.out.println("Cmp pdf: " + UrlUtil.getNormalizedFileUriString(cmpPdf)+ "\n");
        return compareVisually(outPath, differenceImagePrefix, ignoredAreas);
    }
    
    public String compareByContent(String outPdf, String cmpPdf, String outPath) throws InterruptedException, IOException {
        return compareByContent(outPdf, cmpPdf, outPath, null, null, null, null);
    }
    
    public String compareByContent(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix) throws InterruptedException, IOException {
        return compareByContent(outPdf, cmpPdf, outPath, differenceImagePrefix, null, null, null);
    }
    
    public String compareByContent(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix, byte[] outPass, byte[] cmpPass) throws InterruptedException, IOException {
        return compareByContent(outPdf, cmpPdf, outPath, differenceImagePrefix, null, outPass, cmpPass);
    }
    
    public String compareByContent(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas) throws InterruptedException, IOException {
        return compareByContent(outPdf, cmpPdf, outPath, differenceImagePrefix, ignoredAreas, null, null);
    }
    
    public String compareByContent(String outPdf, String cmpPdf, String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas, byte[] outPass, byte[] cmpPass) throws InterruptedException, IOException {
        init(outPdf, cmpPdf);
        System.out.println("Out pdf: " + UrlUtil.getNormalizedFileUriString(outPdf));
        System.out.println("Cmp pdf: " + UrlUtil.getNormalizedFileUriString(cmpPdf)+ "\n");
        setPassword(outPass, cmpPass);
        return compareByContent(outPath, differenceImagePrefix, ignoredAreas);
    }
    
    public boolean compareDictionaries(PdfDictionary outDict, PdfDictionary cmpDict) throws IOException {
        return compareDictionariesExtended(outDict, cmpDict, null, null);
    }
    
    public CompareResult compareDictionariesStructure(PdfDictionary outDict, PdfDictionary cmpDict) {
        return compareDictionariesStructure(outDict, cmpDict, null);
    }
    
    public CompareResult compareDictionariesStructure(PdfDictionary outDict, PdfDictionary cmpDict, Set<PdfName> excludedKeys) {
        if (outDict.getIndirectReference() == null || cmpDict.getIndirectReference() == null) {
            throw new IllegalArgumentException("The 'outDict' and 'cmpDict' objects shall have indirect references.");
        }
        
        CompareResult compareResult = new CompareResult(compareByContentErrorsLimit);
        CompareTool.ObjectPath currentPath = new ObjectPath(cmpDict.getIndirectReference(), outDict.getIndirectReference());
        if (!compareDictionariesExtended(outDict, cmpDict, currentPath, compareResult, excludedKeys)) {
            assert !compareResult.isOk();
            System.out.println(compareResult.getReport());
            return compareResult;
        }
        
        assert compareResult.isOk();
        return null;
    }
    
    public CompareResult compareStreamsStructure(PdfStream outStream, PdfStream cmpStream) {
        CompareResult compareResult = new CompareResult(compareByContentErrorsLimit);
        CompareTool.ObjectPath currentPath = new ObjectPath(cmpStream.getIndirectReference(), outStream.getIndirectReference());
        if (!compareStreamsExtended(outStream, cmpStream, currentPath, compareResult)) {
            assert !compareResult.isOk();
            System.out.println(compareResult.getReport());
            return compareResult;
        }
        
        assert compareResult.isOk();
        return null;
    }
    
    public boolean compareStreams(PdfStream outStream, PdfStream cmpStream) throws IOException {
        return compareStreamsExtended(outStream, cmpStream, null, null);
    }
    
    public boolean compareArrays(PdfArray outArray, PdfArray cmpArray) throws IOException {
        return compareArraysExtended(outArray, cmpArray, null, null);
    }
    
    public boolean compareNames(PdfName outName, PdfName cmpName) {
        return cmpName.equals(outName);
    }
    
    public boolean compareNumbers(PdfNumber outNumber, PdfNumber cmpNumber) {
        return cmpNumber.getValue() == outNumber.getValue();
    }
    
    public boolean compareStrings(PdfString outString, PdfString cmpString) {
        return cmpString.getValue().equals(outString.getValue());
    }
    
    public boolean compareBooleans(PdfBoolean outBoolean, PdfBoolean cmpBoolean) {
        return cmpBoolean.getValue() == outBoolean.getValue();
    }
    
    public String compareXmp(String outPdf, String cmpPdf) {
        return compareXmp(outPdf, cmpPdf, false);
    }
    
    public String compareXmp(String outPdf, String cmpPdf, boolean ignoreDateAndProducerProperties) {
        init(outPdf, cmpPdf);
        try (PdfReader readerCmp = new PdfReader(this.cmpPdf); PdfDocument cmpDocument = new PdfDocument(readerCmp, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); PdfReader readerOut = new PdfReader(this.outPdf); PdfDocument outDocument = new PdfDocument(readerOut, new DocumentProperties().setEventCountingMetaInfo(metaInfo))) {
            byte[] cmpBytes = cmpDocument.getXmpMetadata(), outBytes = outDocument.getXmpMetadata();
            if (ignoreDateAndProducerProperties) {
                XMPMeta xmpMeta = XMPMetaFactory.parseFromBuffer(cmpBytes, new ParseOptions().setOmitNormalization(true));
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.CreateDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.ModifyDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.MetadataDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_PDF, PdfConst.Producer, true, true);
                cmpBytes = XMPMetaFactory.serializeToBuffer(xmpMeta, new SerializeOptions(SerializeOptions.SORT));
                xmpMeta = XMPMetaFactory.parseFromBuffer(outBytes, new ParseOptions().setOmitNormalization(true));
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.CreateDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.ModifyDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_XMP, PdfConst.MetadataDate, true, true);
                XMPUtils.removeProperties(xmpMeta, XMPConst.NS_PDF, PdfConst.Producer, true, true);
                outBytes = XMPMetaFactory.serializeToBuffer(xmpMeta, new SerializeOptions(SerializeOptions.SORT));
            }
            
            if (!compareXmls(cmpBytes, outBytes)) {
                return "The XMP packages different!";
            }
            
        }
         catch (Exception ex) {
            return "XMP parsing failure!";
        }
        
        return null;
    }
    
    public boolean compareXmls(byte[] xml1, byte[] xml2) throws ParserConfigurationException, SAXException, IOException {
        return XmlUtils.compareXmls(new ByteArrayInputStream(xml1), new ByteArrayInputStream(xml2));
    }
    
    public boolean compareXmls(String outXmlFile, String cmpXmlFile) throws ParserConfigurationException, SAXException, IOException {
        System.out.println("Out xml: " + UrlUtil.getNormalizedFileUriString(outXmlFile));
        System.out.println("Cmp xml: " + UrlUtil.getNormalizedFileUriString(cmpXmlFile) + "\n");
        try (InputStream outXmlStream = FileUtil.getInputStreamForFile(outXmlFile); InputStream cmpXmlStream = FileUtil.getInputStreamForFile(cmpXmlFile)) {
            return XmlUtils.compareXmls(outXmlStream, cmpXmlStream);
        }
        
    }
    
    public String compareDocumentInfo(String outPdf, String cmpPdf, byte[] outPass, byte[] cmpPass) throws IOException {
        System.out.print("[itext] INFO  Comparing document info.......");
        String message = null;
        setPassword(outPass, cmpPass);
        try (PdfReader readerOut = new PdfReader(outPdf, getOutReaderProperties()); PdfDocument outDocument = new PdfDocument(readerOut, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); PdfReader readerCmp = new PdfReader(cmpPdf, getCmpReaderProperties()); PdfDocument cmpDocument = new PdfDocument(readerCmp, new DocumentProperties().setEventCountingMetaInfo(metaInfo))) {
            String[] cmpInfo = convertInfo(cmpDocument.getDocumentInfo());
            String[] outInfo = convertInfo(outDocument.getDocumentInfo());
            for (int i = 0; i < cmpInfo.length; ++i) {
                if (!cmpInfo[i].equals(outInfo[i])) {
                    message = MessageFormatUtil.format("Document info fail. Expected: \"{0}\", actual: \"{1}\"", cmpInfo[i], outInfo[i]);
                    break;
                }
                
            }
            
        }
        
        if (message == null){
            System.out.println("OK");
}
        else{
            System.out.println("Fail");
}
        System.out.flush();
        return message;
    }
    
    public String compareDocumentInfo(String outPdf, String cmpPdf) throws IOException {
        return compareDocumentInfo(outPdf, cmpPdf, null, null);
    }
    
    public String compareLinkAnnotations(String outPdf, String cmpPdf) throws IOException {
        System.out.print("[itext] INFO  Comparing link annotations....");
        String message = null;
        try (PdfReader readerOut = new PdfReader(outPdf); PdfDocument outDocument = new PdfDocument(readerOut, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); PdfReader readerCmp = new PdfReader(cmpPdf); PdfDocument cmpDocument = new PdfDocument(readerCmp, new DocumentProperties().setEventCountingMetaInfo(metaInfo))){
            for (int i = 0; i < outDocument.getNumberOfPages() && i < cmpDocument.getNumberOfPages(); i++) {
                List<PdfLinkAnnotation> outLinks = getLinkAnnotations(i + 1, outDocument);
                List<PdfLinkAnnotation> cmpLinks = getLinkAnnotations(i + 1, cmpDocument);
                if (cmpLinks.size() != outLinks.size()) {
                    message = MessageFormatUtil.format("Different number of links on page {0}.", i + 1);
                    break;
                }
                
                for (int j = 0; j < cmpLinks.size(); j++) {
                    if (!compareLinkAnnotations(cmpLinks.get(j), outLinks.get(j), cmpDocument, outDocument)) {
                        message = MessageFormatUtil.format("Different links on page {0}.\n{1}\n{2}", i + 1, cmpLinks.get(j).toString(), outLinks.get(j).toString());
                        break;
                    }
                    
                }
                
            }
            
        }
        
        if (message == null){
            System.out.println("OK");
}
        else{
            System.out.println("Fail");
}
        System.out.flush();
        return message;
    }
    
    public String compareTagStructures(String outPdf, String cmpPdf) throws IOException, ParserConfigurationException, SAXException {
        System.out.print("[itext] INFO  Comparing tag structures......");
        String outXmlPath = outPdf.replace(".pdf", ".xml");
        String cmpXmlPath = outPdf.replace(".pdf", ".cmp.xml");
        String message = null;
        try (PdfReader readerOut = new PdfReader(outPdf); PdfDocument docOut = new PdfDocument(readerOut, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); FileOutputStream xmlOut = new FileOutputStream(outXmlPath)) {
            new TaggedPdfReaderTool(docOut).setRootTag("root").convertToXml(xmlOut);
        }
        
        try (PdfReader readerCmp = new PdfReader(cmpPdf); PdfDocument docCmp = new PdfDocument(readerCmp, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); FileOutputStream xmlCmp = new FileOutputStream(cmpXmlPath)) {
            new TaggedPdfReaderTool(docCmp).setRootTag("root").convertToXml(xmlCmp);
        }
        
        if (!compareXmls(outXmlPath, cmpXmlPath)) {
            message = "The tag structures are different.";
        }
        
        if (message == null){
            System.out.println("OK");
}
        else{
            System.out.println("Fail");
}
        System.out.flush();
        return message;
    }
    
    String[] convertInfo(PdfDocumentInfo info) {         String[] convertedInfo = new String[]{"", "", "", "", ""};
        String infoValue = info.getTitle();
        if (infoValue != null){
            convertedInfo[0] = infoValue;
}
        infoValue = info.getAuthor();
        if (infoValue != null){
            convertedInfo[1] = infoValue;
}
        infoValue = info.getSubject();
        if (infoValue != null){
            convertedInfo[2] = infoValue;
}
        infoValue = info.getKeywords();
        if (infoValue != null){
            convertedInfo[3] = infoValue;
}
        infoValue = info.getProducer();
        if (infoValue != null) {
            convertedInfo[4] = convertProducerLine(infoValue);
        }
        
        return convertedInfo;
    }
    
    String convertProducerLine(String producer) {
        return producer.replaceAll(VERSION_REGEXP, VERSION_REPLACEMENT).replaceAll(COPYRIGHT_REGEXP, COPYRIGHT_REPLACEMENT);
    }
    
    private void init(String outPdf, String cmpPdf) {
        this.outPdf = outPdf;
        this.cmpPdf = cmpPdf;
        outPdfName = new File(outPdf).getName();
        cmpPdfName = new File(cmpPdf).getName();
        outImage = outPdfName + "-%03d.png";
        if (cmpPdfName.startsWith("cmp_")) cmpImage = cmpPdfName + "-%03d.png";
        else cmpImage = "cmp_" + cmpPdfName + "-%03d.png";
    }
    
    private void setPassword(byte[] outPass, byte[] cmpPass) {
        if (outPass != null) {
            getOutReaderProperties().setPassword(outPass);
        }
        
        if (cmpPass != null) {
            getCmpReaderProperties().setPassword(outPass);
        }
        
    }
    
    private String compareVisually(String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas) throws InterruptedException, IOException {
        return compareVisually(outPath, differenceImagePrefix, ignoredAreas, null);
    }
    
    private String compareVisually(String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas, List<Integer> equalPages) throws IOException, InterruptedException {
        if (!outPath.endsWith("/")) {
            outPath = outPath + "/";
        }
        
        if (differenceImagePrefix == null) {
            String fileBasedPrefix = "";
            if (outPdfName != null) {
                fileBasedPrefix = outPdfName + "_";
            }
            
            differenceImagePrefix = "diff_" + fileBasedPrefix;
        }
        
        prepareOutputDirs(outPath, differenceImagePrefix);
        System.out.println("Comparing visually..........");
        if (ignoredAreas != null && !ignoredAreas.isEmpty()) {
            createIgnoredAreasPdfs(outPath, ignoredAreas);
        }
        
        GhostscriptHelper ghostscriptHelper = null;
        try {
            ghostscriptHelper = new GhostscriptHelper(gsExec);
        }
         catch (IllegalArgumentException e) {
            throw new CompareToolExecutionException(e.getMessage());
        }
        
        ghostscriptHelper.runGhostScriptImageGeneration(outPdf, outPath, outImage);
        ghostscriptHelper.runGhostScriptImageGeneration(cmpPdf, outPath, cmpImage);
        return compareImagesOfPdfs(outPath, differenceImagePrefix, equalPages);
    }
    
    private String compareImagesOfPdfs(String outPath, String differenceImagePrefix, List<Integer> equalPages) throws IOException, InterruptedException {
        File[] imageFiles = FileUtil.listFilesInDirectoryByFilter(outPath, new PngFileFilter());
        File[] cmpImageFiles = FileUtil.listFilesInDirectoryByFilter(outPath, new CmpPngFileFilter());
        boolean bUnexpectedNumberOfPages = false;
        if (imageFiles.length != cmpImageFiles.length) {
            bUnexpectedNumberOfPages = true;
        }
        
        int cnt = Math.min(imageFiles.length, cmpImageFiles.length);
        if (cnt < 1) {
            throw new CompareToolExecutionException( "No files for comparing. The result or sample pdf file is not processed by GhostScript.");
        }
        
        Arrays.sort(imageFiles, new ImageNameComparator());
        Arrays.sort(cmpImageFiles, new ImageNameComparator());
        boolean compareExecIsOk;
        String imageMagickInitError = null;
        ImageMagickHelper imageMagickHelper = null;
        try {
            imageMagickHelper = new ImageMagickHelper(compareExec);
            compareExecIsOk = true;
        }
         catch (IllegalArgumentException e) {
            compareExecIsOk = false;
            imageMagickInitError = e.getMessage();
            LoggerFactory.getLogger(CompareTool.class).warn(e.getMessage());
        }
        
        List<Integer> diffPages = new ArrayList<>();
        String differentPagesFail = null;
        for (int i = 0; i < cnt; i++) {
            if (equalPages != null && equalPages.contains(i)){
                continue;
}
            System.out.println("Comparing page " + Integer.toString(i + 1) + ": " + UrlUtil.getNormalizedFileUriString(imageFiles[i].getName()) + " ...");
            System.out.println("Comparing page " + Integer.toString(i + 1) + ": " + UrlUtil.getNormalizedFileUriString(imageFiles[i].getName()) + " ...");
            FileInputStream is1 = new FileInputStream(imageFiles[i].getAbsolutePath());
            FileInputStream is2 = new FileInputStream(cmpImageFiles[i].getAbsolutePath());
            boolean cmpResult = compareStreams(is1, is2);
            is1.close();
            is2.close();
            if (!cmpResult) {
                differentPagesFail = "Page is different!";
                diffPages.add(i + 1);
                if (compareExecIsOk) {
                    String diffName = outPath + differenceImagePrefix + Integer.toString(i + 1) + ".png";
                    if (!imageMagickHelper.runImageMagickImageCompare(imageFiles[i].getAbsolutePath(), cmpImageFiles[i].getAbsolutePath(), diffName)) {
                        File diffFile = new File(diffName);
                        differentPagesFail += "\nPlease, examine " + FILE_PROTOCOL + UrlUtil.toNormalizedURI(diffFile).getPath() + " for more details.";
                    }
                    
                }
                
                System.out.println(differentPagesFail);
            }
             else {
                System.out.println(" done.");
            }
            
        }
        
        if (differentPagesFail != null) {
            String errorMessage = DIFFERENT_PAGES.replace("<filename>", UrlUtil.toNormalizedURI(outPdf).getPath()).replace("<pagenumber>", listDiffPagesAsString(diffPages));
            if (!compareExecIsOk) {
                errorMessage += "\n" + imageMagickInitError;
            }
            
            return errorMessage;
        }
         else {
            if (bUnexpectedNumberOfPages){
                return UNEXPECTED_NUMBER_OF_PAGES.replace("<filename>", outPdf);
}
        }
        
        return null;
    }
    
    private String listDiffPagesAsString(List<Integer> diffPages) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < diffPages.size(); i++) {
            sb.append(diffPages.get(i));
            if (i < diffPages.size() - 1) {
                sb.append(", ");
            }
            
        }
        
        sb.append("]");
        return sb.toString();
    }
    
    private void createIgnoredAreasPdfs(String outPath, Map<Integer, List<Rectangle>> ignoredAreas) throws IOException {
        StampingProperties properties = new StampingProperties();
        properties.setEventCountingMetaInfo(metaInfo);
        try (PdfWriter outWriter = new PdfWriter(outPath + IGNORED_AREAS_PREFIX + outPdfName); PdfReader readerOut = new PdfReader(outPdf); PdfDocument pdfOutDoc = new PdfDocument(readerOut, outWriter, properties); PdfWriter cmpWriter = new PdfWriter(outPath + IGNORED_AREAS_PREFIX + cmpPdfName); PdfReader readerCmp = new PdfReader(cmpPdf); PdfDocument pdfCmpDoc = new PdfDocument(readerCmp, cmpWriter, properties)) {
            for (Map.Entry<Integer, List<Rectangle>> entry : ignoredAreas.entrySet()) {
                int pageNumber = entry.getKey();
                List<Rectangle> rectangles = entry.getValue();
                if (rectangles != null && !rectangles.isEmpty()) {
                    PdfCanvas outCanvas = new PdfCanvas(pdfOutDoc.getPage(pageNumber));
                    PdfCanvas cmpCanvas = new PdfCanvas(pdfCmpDoc.getPage(pageNumber));
                    outCanvas.saveState();
                    cmpCanvas.saveState();
                    for (Rectangle rect : rectangles) {
                        outCanvas.rectangle(rect).fill();
                        cmpCanvas.rectangle(rect).fill();
                    }
                    
                    outCanvas.restoreState();
                    cmpCanvas.restoreState();
                }
                
            }
            
        }
        
        init(outPath + IGNORED_AREAS_PREFIX + outPdfName, outPath + IGNORED_AREAS_PREFIX + cmpPdfName);
    }
    
    private void prepareOutputDirs(String outPath, String differenceImagePrefix) {
        File[] imageFiles;
        File[] cmpImageFiles;
        File[] diffFiles;
        if (!FileUtil.directoryExists(outPath)) {
            FileUtil.createDirectories(outPath);
        }
         else {
            imageFiles = FileUtil.listFilesInDirectoryByFilter(outPath, new PngFileFilter());
            for (File file : imageFiles) {
                file.delete();
            }
            
            cmpImageFiles = FileUtil.listFilesInDirectoryByFilter(outPath, new CmpPngFileFilter());
            for (File file : cmpImageFiles) {
                file.delete();
            }
            
            diffFiles = FileUtil.listFilesInDirectoryByFilter(outPath, new DiffPngFileFilter(differenceImagePrefix));
            for (File file : diffFiles) {
                file.delete();
            }
            
        }
        
    }
    
    private void printOutCmpDirectories() {
        System.out.println("Out file folder: " + FILE_PROTOCOL + UrlUtil.toNormalizedURI(new File(outPdf).getParentFile()).getPath());
        System.out.println("Cmp file folder: " + FILE_PROTOCOL + UrlUtil.toNormalizedURI(new File(cmpPdf).getParentFile()).getPath());
    }
    
    private String compareByContent(String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas) throws InterruptedException, IOException {
        printOutCmpDirectories();
        System.out.print("Comparing by content..........");
        try (PdfReader readerOut = new PdfReader(outPdf, getOutReaderProperties()); PdfDocument outDocument = new PdfDocument(readerOut, new DocumentProperties().setEventCountingMetaInfo(metaInfo)); PdfReader readerCmp = new PdfReader(cmpPdf, getCmpReaderProperties()); PdfDocument cmpDocument = new PdfDocument(readerCmp, new DocumentProperties().setEventCountingMetaInfo(metaInfo))) {
            List<PdfDictionary> outPages = new ArrayList<>();
            outPagesRef = new ArrayList<>();
            loadPagesFromReader(outDocument, outPages, outPagesRef);
            List<PdfDictionary> cmpPages = new ArrayList<>();
            cmpPagesRef = new ArrayList<>();
            loadPagesFromReader(cmpDocument, cmpPages, cmpPagesRef);
            if (outPages.size() != cmpPages.size()){
                return compareVisuallyAndCombineReports("Documents have different numbers of pages.", outPath, differenceImagePrefix, ignoredAreas, null);
}
            CompareResult compareResult = new CompareResult(compareByContentErrorsLimit);
            List<Integer> equalPages = new ArrayList<>(cmpPages.size());
            for (int i = 0; i < cmpPages.size(); i++) {
                ObjectPath currentPath = new ObjectPath(cmpPagesRef.get(i), outPagesRef.get(i));
                if (compareDictionariesExtended(outPages.get(i), cmpPages.get(i), currentPath, compareResult)){
                    equalPages.add(i);
}
            }
            
            ObjectPath catalogPath = new ObjectPath(cmpDocument.getCatalog().getPdfObject().getIndirectReference(), outDocument.getCatalog().getPdfObject().getIndirectReference());
            Set<PdfName> ignoredCatalogEntries = new LinkedHashSet<>(Arrays.asList(PdfName.Pages, PdfName.Metadata));
            compareDictionariesExtended(outDocument.getCatalog().getPdfObject(), cmpDocument.getCatalog().getPdfObject(), catalogPath, compareResult, ignoredCatalogEntries);
            if (encryptionCompareEnabled) {
                compareDocumentsEncryption(outDocument, cmpDocument, compareResult);
            }
            
            if (generateCompareByContentXmlReport) {
                String outPdfName = new File(outPdf).getName();
                FileOutputStream xml = new FileOutputStream(outPath + "/" + outPdfName.substring(0, outPdfName.length() - 3) + "report.xml");
                try {
                    compareResult.writeReportToXml(xml);
                }
                 catch (Exception e) {
                    throw new RuntimeException(e.getMessage(), e);
                }
                 finally {
                    xml.close();
                }
                
            }
            
            if (equalPages.size() == cmpPages.size() && compareResult.isOk()) {
                System.out.println("OK");
                System.out.flush();
                return null;
            }
             else {
                return compareVisuallyAndCombineReports(compareResult.getReport(), outPath, differenceImagePrefix, ignoredAreas, equalPages);
            }
            
        }
        
    }
    
    private String compareVisuallyAndCombineReports(String compareByFailContentReason, String outPath, String differenceImagePrefix, Map<Integer, List<Rectangle>> ignoredAreas, List<Integer> equalPages) throws IOException, InterruptedException {
        System.out.println("Fail");
        System.out.flush();
        String compareByContentReport = "Compare by content report:\n" + compareByFailContentReason;
        System.out.println(compareByContentReport);
        System.out.flush();
        String message = compareVisually(outPath, differenceImagePrefix, ignoredAreas, equalPages);
        if (message == null || message.length() == 0){
            return "Compare by content fails. No visual differences";
}
        return message;
    }
    
    private void loadPagesFromReader(PdfDocument doc, List<PdfDictionary> pages, List<PdfIndirectReference> pagesRef) {
        int numOfPages = doc.getNumberOfPages();
        for (int i = 0; i < numOfPages; ++i) {
            pages.add(doc.getPage(i + 1).getPdfObject());
            pagesRef.add(pages.get(i).getIndirectReference());
        }
        
    }
    
    private void compareDocumentsEncryption(PdfDocument outDocument, PdfDocument cmpDocument, CompareResult compareResult) {
        PdfDictionary outEncrypt = outDocument.getTrailer().getAsDictionary(PdfName.Encrypt);
        PdfDictionary cmpEncrypt = cmpDocument.getTrailer().getAsDictionary(PdfName.Encrypt);
        if (outEncrypt == null && cmpEncrypt == null) {
            return;
        }
        
        TrailerPath trailerPath = new TrailerPath(cmpDocument, outDocument);
        if (outEncrypt == null) {
            compareResult.addError(trailerPath, "Expected encrypted document.");
            return;
        }
        
        if (cmpEncrypt == null) {
            compareResult.addError(trailerPath, "Expected not encrypted document.");
            return;
        }
        
        Set<PdfName> ignoredEncryptEntries = new LinkedHashSet<>(Arrays.asList(PdfName.O, PdfName.U, PdfName.OE, PdfName.UE, PdfName.Perms, PdfName.CF, PdfName.Recipients));
        ObjectPath objectPath = new ObjectPath(outEncrypt.getIndirectReference(), cmpEncrypt.getIndirectReference());
        compareDictionariesExtended(outEncrypt, cmpEncrypt, objectPath, compareResult, ignoredEncryptEntries);
        PdfDictionary outCfDict = outEncrypt.getAsDictionary(PdfName.CF);
        PdfDictionary cmpCfDict = cmpEncrypt.getAsDictionary(PdfName.CF);
        if (cmpCfDict != null || outCfDict != null) {
            if (cmpCfDict != null && outCfDict == null || cmpCfDict == null) {
                compareResult.addError(objectPath, "One of the dictionaries is null, the other is not.");
            }
             else {
                Set<PdfName> mergedKeys = new TreeSet<>(outCfDict.keySet());
                mergedKeys.addAll(cmpCfDict.keySet());
                for (PdfName key : mergedKeys) {
                    objectPath.pushDictItemToPath(key);
                    LinkedHashSet<PdfName> excludedKeys = new LinkedHashSet<>(Arrays.asList(PdfName.Recipients));
                    compareDictionariesExtended(outCfDict.getAsDictionary(key), cmpCfDict.getAsDictionary(key), objectPath, compareResult, excludedKeys);
                    objectPath.pop();
                }
                
            }
            
        }
        
    }
    
    private boolean compareStreams(InputStream is1, InputStream is2) throws IOException {
        byte[] buffer1 = new byte[64 * 1024];
        byte[] buffer2 = new byte[64 * 1024];
        int len1;
        int len2;
        for (; ; ) {
            len1 = is1.read(buffer1);
            len2 = is2.read(buffer2);
            if (len1 != len2){
                return false;
}
            if (!Arrays.equals(buffer1, buffer2)){
                return false;
}
            if (len1 == -1){
                break;
}
        }
        
        return true;
    }
    
    private boolean compareDictionariesExtended(PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult) {
        return compareDictionariesExtended(outDict, cmpDict, currentPath, compareResult, null);
    }
    
    private boolean compareDictionariesExtended(PdfDictionary outDict, PdfDictionary cmpDict, ObjectPath currentPath, CompareResult compareResult, Set<PdfName> excludedKeys) {
        if (cmpDict != null && outDict == null || outDict != null && cmpDict == null) {
            compareResult.addError(currentPath, "One of the dictionaries is null, the other is not.");
            return false;
        }
        
        boolean dictsAreSame = true;
        Set<PdfName> mergedKeys = new TreeSet<>(cmpDict.keySet());
        mergedKeys.addAll(outDict.keySet());
        for (PdfName key : mergedKeys) {
            if (!dictsAreSame && (currentPath == null || compareResult == null || compareResult.isMessageLimitReached())) {
                return false;
            }
            
            if (excludedKeys != null && excludedKeys.contains(key)) {
                continue;
            }
            
            if (key.equals(PdfName.Parent) || key.equals(PdfName.P) || key.equals(PdfName.ModDate)) continue;
            if (outDict.isStream() && cmpDict.isStream() && (key.equals(PdfName.Filter) || key.equals(PdfName.Length))){
                continue;
}
            if (key.equals(PdfName.BaseFont) || key.equals(PdfName.FontName)) {
                PdfObject cmpObj = cmpDict.get(key);
                if (cmpObj != null && cmpObj.isName() && cmpObj.toString().indexOf('+') > 0) {
                    PdfObject outObj = outDict.get(key);
                    if (!outObj.isName() || outObj.toString().indexOf('+') == -1) {
                        if (compareResult != null && currentPath != null){
                            compareResult.addError(currentPath, MessageFormatUtil.format("PdfDictionary {0} entry: Expected: {1}. Found: {2}", key.toString(), cmpObj.toString(), outObj.toString()));
}
                        dictsAreSame = false;
                    }
                     else {
                        String cmpName = cmpObj.toString().substring(cmpObj.toString().indexOf('+'));
                        String outName = outObj.toString().substring(outObj.toString().indexOf('+'));
                        if (!cmpName.equals(outName)) {
                            if (compareResult != null && currentPath != null){
                                compareResult.addError(currentPath, MessageFormatUtil.format("PdfDictionary {0} entry: Expected: {1}. Found: {2}", key.toString(), cmpObj.toString(), outObj.toString()));
}
                            dictsAreSame = false;
                        }
                        
                    }
                    
                    continue;
                }
                
            }
            
            if (key.equals(PdfName.ParentTree) || key.equals(PdfName.PageLabels)) {
                if (currentPath != null) {
                    currentPath.pushDictItemToPath(key);
                }
                
                PdfDictionary outNumTree = outDict.getAsDictionary(key);
                PdfDictionary cmpNumTree = cmpDict.getAsDictionary(key);
                LinkedList<PdfObject> outItems = new LinkedList<PdfObject>();
                LinkedList<PdfObject> cmpItems = new LinkedList<PdfObject>();
                PdfNumber outLeftover = flattenNumTree(outNumTree, null, outItems);
                PdfNumber cmpLeftover = flattenNumTree(cmpNumTree, null, cmpItems);
                if (outLeftover != null) {
                    LoggerFactory.getLogger(CompareTool.class).warn(LogMessageConstant.NUM_TREE_SHALL_NOT_END_WITH_KEY);
                    if (cmpLeftover == null) {
                        if (compareResult != null && currentPath != null) {
                            compareResult.addError(currentPath, "Number tree unexpectedly ends with a key");
                        }
                        
                        dictsAreSame = false;
                    }
                    
                }
                
                if (cmpLeftover != null) {
                    LoggerFactory.getLogger(CompareTool.class).warn(LogMessageConstant.NUM_TREE_SHALL_NOT_END_WITH_KEY);
                    if (outLeftover == null) {
                        if (compareResult != null && currentPath != null) {
                            compareResult.addError(currentPath, "Number tree was expected to end with a key (although it is invalid according to the specification), but ended with a value");
                        }
                        
                        dictsAreSame = false;
                    }
                    
                }
                
                if (outLeftover != null && cmpLeftover != null && !compareNumbers(outLeftover, cmpLeftover)) {
                    if (compareResult != null && currentPath != null) {
                        compareResult.addError(currentPath, "Number tree was expected to end with a different key (although it is invalid according to the specification)");
                    }
                    
                    dictsAreSame = false;
                }
                
                PdfArray outArray = new PdfArray(outItems, outItems.size());
                PdfArray cmpArray = new PdfArray(cmpItems, cmpItems.size());
                if (!compareArraysExtended(outArray, cmpArray, currentPath, compareResult)) {
                    if (compareResult != null && currentPath != null) {
                        compareResult.addError(currentPath, "Number trees were flattened, compared and found to be different.");
                    }
                    
                    dictsAreSame = false;
                }
                
                if (currentPath != null) {
                    currentPath.pop();
                }
                
                continue;
            }
            
            if (currentPath != null) {
                currentPath.pushDictItemToPath(key);
            }
            
            dictsAreSame = compareObjects(outDict.get(key, false), cmpDict.get(key, false), currentPath, compareResult) && dictsAreSame;
            if (currentPath != null) {
                currentPath.pop();
            }
            
        }
        
        return dictsAreSame;
    }
    
    private PdfNumber flattenNumTree(PdfDictionary dictionary, PdfNumber leftOver, LinkedList<PdfObject> items ) {
        PdfArray nums = dictionary.getAsArray(PdfName.Nums);
        if (nums != null) {
            for (int k = 0; k < nums.size(); k++) {
                PdfNumber number;
                if (leftOver == null){
                    number = nums.getAsNumber(k++);
}
                else {
                    number = leftOver;
                    leftOver = null;
                }
                
                if (k < nums.size()) {
                    items.addLast(number);
                    items.addLast(nums.get(k, false));
                }
                 else {
                    return number;
                }
                
            }
            
        }
         else if ((nums = dictionary.getAsArray(PdfName.Kids)) != null) {
            for (int k = 0; k < nums.size(); k++) {
                PdfDictionary kid = nums.getAsDictionary(k);
                leftOver = flattenNumTree(kid, leftOver, items);
            }
            
        }
        
        return null;
    }
    
    protected boolean compareObjects(PdfObject outObj, PdfObject cmpObj, ObjectPath currentPath, CompareResult compareResult) {
        PdfObject outDirectObj = null;
        PdfObject cmpDirectObj = null;
        if (outObj != null){
            outDirectObj = outObj.isIndirectReference() ? ((PdfIndirectReference) outObj).getRefersTo(false) : outObj;
}
        if (cmpObj != null){
            cmpDirectObj = cmpObj.isIndirectReference() ? ((PdfIndirectReference) cmpObj).getRefersTo(false) : cmpObj;
}
        if (cmpDirectObj == null && outDirectObj == null){
            return true;
}
        if (outDirectObj == null) {
            compareResult.addError(currentPath, "Expected object was not found.");
            return false;
        }
         else if (cmpDirectObj == null) {
            compareResult.addError(currentPath, "Found object which was not expected to be found.");
            return false;
        }
         else if (cmpDirectObj.getType() != outDirectObj.getType()) {
            compareResult.addError(currentPath, MessageFormatUtil.format("Types do not match. Expected: {0}. Found: {1}.", cmpDirectObj.getClass().getSimpleName(), outDirectObj.getClass().getSimpleName()));
            return false;
        }
         else if (cmpObj.isIndirectReference() && !outObj.isIndirectReference()) {
            compareResult.addError(currentPath, "Expected indirect object.");
            return false;
        }
         else if (!cmpObj.isIndirectReference() && outObj.isIndirectReference()) {
            compareResult.addError(currentPath, "Expected direct object.");
            return false;
        }
        
        if (currentPath != null && cmpObj.isIndirectReference() && outObj.isIndirectReference()) {
            if (currentPath.isComparing((PdfIndirectReference) cmpObj, (PdfIndirectReference) outObj)){
                return true;
}
            currentPath = currentPath.resetDirectPath((PdfIndirectReference) cmpObj, (PdfIndirectReference) outObj);
        }
        
        if (cmpDirectObj.isDictionary() && PdfName.Page.equals(((PdfDictionary) cmpDirectObj).getAsName(PdfName.Type)) && useCachedPagesForComparison) {
            if (!outDirectObj.isDictionary() || !PdfName.Page.equals(((PdfDictionary) outDirectObj).getAsName(PdfName.Type))) {
                if (compareResult != null && currentPath != null){
                    compareResult.addError(currentPath, "Expected a page. Found not a page.");
}
                return false;
            }
            
            PdfIndirectReference cmpRefKey = cmpObj.isIndirectReference() ? (PdfIndirectReference) cmpObj : cmpObj.getIndirectReference();
            PdfIndirectReference outRefKey = outObj.isIndirectReference() ? (PdfIndirectReference) outObj : outObj.getIndirectReference();
            if (cmpPagesRef == null) {
                cmpPagesRef = new ArrayList<>();
                for (int i = 1; i <= cmpRefKey.getDocument().getNumberOfPages(); ++i) {
                    cmpPagesRef.add(cmpRefKey.getDocument().getPage(i).getPdfObject().getIndirectReference());
                }
                
            }
            
            if (outPagesRef == null) {
                outPagesRef = new ArrayList<>();
                for (int i = 1; i <= outRefKey.getDocument().getNumberOfPages(); ++i) {
                    outPagesRef.add(outRefKey.getDocument().getPage(i).getPdfObject().getIndirectReference());
                }
                
            }
            
            if (cmpPagesRef.contains(cmpRefKey) || outPagesRef.contains(outRefKey)) {
                if (cmpPagesRef.contains(cmpRefKey) && cmpPagesRef.indexOf(cmpRefKey) == outPagesRef.indexOf(outRefKey)) {
                    return true;
                }
                
                if (compareResult != null && currentPath != null){
                    compareResult.addError(currentPath, MessageFormatUtil.format("The dictionaries refer to different pages. Expected page number: {0}. Found: {1}", cmpPagesRef.indexOf(cmpRefKey) + 1, outPagesRef.indexOf(outRefKey) + 1));
}
                return false;
            }
            
        }
        
        if (cmpDirectObj.isDictionary()) {
            return compareDictionariesExtended((PdfDictionary) outDirectObj, (PdfDictionary) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isStream()) {
            return compareStreamsExtended((PdfStream) outDirectObj, (PdfStream) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isArray()) {
            return compareArraysExtended((PdfArray) outDirectObj, (PdfArray) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isName()) {
            return compareNamesExtended((PdfName) outDirectObj, (PdfName) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isNumber()) {
            return compareNumbersExtended((PdfNumber) outDirectObj, (PdfNumber) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isString()) {
            return compareStringsExtended((PdfString) outDirectObj, (PdfString) cmpDirectObj, currentPath, compareResult);
        }
         else if (cmpDirectObj.isBoolean()) {
            return compareBooleansExtended((PdfBoolean) outDirectObj, (PdfBoolean) cmpDirectObj, currentPath, compareResult);
        }
         else if (outDirectObj.isNull() && cmpDirectObj.isNull()) {
            return true;
        }
         else {
            throw new UnsupportedOperationException();
        }
        
    }
    
    private boolean compareStreamsExtended(PdfStream outStream, PdfStream cmpStream, ObjectPath currentPath, CompareResult compareResult) {
        boolean toDecode = PdfName.FlateDecode.equals(outStream.get(PdfName.Filter));
        byte[] outStreamBytes = outStream.getBytes(toDecode);
        byte[] cmpStreamBytes = cmpStream.getBytes(toDecode);
        if (Arrays.equals(outStreamBytes, cmpStreamBytes)) {
            return compareDictionariesExtended(outStream, cmpStream, currentPath, compareResult);
        }
         else {
            StringBuilder errorMessage = new StringBuilder();
            if (cmpStreamBytes.length != outStreamBytes.length) {
                errorMessage.append(MessageFormatUtil.format("PdfStream. Lengths are different. Expected: {0}. Found: {1}\n", cmpStreamBytes.length, outStreamBytes.length));
            }
             else {
                errorMessage.append("PdfStream. Bytes are different.\n");
            }
            
            int firstDifferenceOffset = findBytesDifference(outStreamBytes, cmpStreamBytes, errorMessage);
            if (compareResult != null && currentPath != null) {
                currentPath.pushOffsetToPath(firstDifferenceOffset);
                compareResult.addError(currentPath, errorMessage.toString());
                currentPath.pop();
            }
            
            return false;
        }
        
    }
    
    private int findBytesDifference(byte[] outStreamBytes, byte[] cmpStreamBytes, StringBuilder errorMessage) {
        int numberOfDifferentBytes = 0;
        int firstDifferenceOffset = 0;
        int minLength = Math.min(cmpStreamBytes.length, outStreamBytes.length);
        for (int i = 0; i < minLength; i++) {
            if (cmpStreamBytes[i] != outStreamBytes[i]) { ++numberOfDifferentBytes;
                if (numberOfDifferentBytes == 1) {
                    firstDifferenceOffset = i;
                }
                
            }
            
        }
        
        String bytesDifference = null;
        if (numberOfDifferentBytes > 0) {
            int diffBytesAreaL = 10;
            int diffBytesAreaR = 10;
            int lCmp = Math.max(0, firstDifferenceOffset - diffBytesAreaL);
            int rCmp = Math.min(cmpStreamBytes.length, firstDifferenceOffset + diffBytesAreaR);
            int lOut = Math.max(0, firstDifferenceOffset - diffBytesAreaL);
            int rOut = Math.min(outStreamBytes.length, firstDifferenceOffset + diffBytesAreaR);
            String cmpByte = new String(new byte[]{cmpStreamBytes[firstDifferenceOffset]}, StandardCharsets.ISO_8859_1);
            String cmpByteNeighbours = new String(cmpStreamBytes, lCmp, rCmp - lCmp, StandardCharsets.ISO_8859_1).replaceAll(NEW_LINES, " ");
            String outByte = new String(new byte[]{outStreamBytes[firstDifferenceOffset]}, StandardCharsets.ISO_8859_1);
            String outBytesNeighbours = new String(outStreamBytes, lOut, rOut - lOut, StandardCharsets.ISO_8859_1).replaceAll(NEW_LINES, " ");
            bytesDifference = MessageFormatUtil.format("First bytes difference is encountered at index {0}. Expected: {1} ({2}). Found: {3} ({4}). Total number of different bytes: {5}", Integer.valueOf(firstDifferenceOffset).toString(), cmpByte, cmpByteNeighbours, outByte, outBytesNeighbours, numberOfDifferentBytes);
        }
         else {
            firstDifferenceOffset = minLength;
            bytesDifference = MessageFormatUtil.format("Bytes of the shorter array are the same as the first {0} bytes of the longer one.", minLength);
        }
        
        errorMessage.append(bytesDifference);
        return firstDifferenceOffset;
    }
    
    private boolean compareArraysExtended(PdfArray outArray, PdfArray cmpArray, ObjectPath currentPath, CompareResult compareResult) {
        if (outArray == null) {
            if (compareResult != null && currentPath != null){
                compareResult.addError(currentPath, "Found null. Expected PdfArray.");
}
            return false;
        }
         else if (outArray.size() != cmpArray.size()) {
            if (compareResult != null && currentPath != null){
                compareResult.addError(currentPath, MessageFormatUtil.format("PdfArrays. Lengths are different. Expected: {0}. Found: {1}.", cmpArray.size(), outArray.size()));
}
            return false;
        }
        
        boolean arraysAreEqual = true;
        for (int i = 0; i < cmpArray.size(); i++) {
            if (currentPath != null){
                currentPath.pushArrayItemToPath(i);
}
            arraysAreEqual = compareObjects(outArray.get(i, false), cmpArray.get(i, false), currentPath, compareResult) && arraysAreEqual;
            if (currentPath != null){
                currentPath.pop();
}
            if (!arraysAreEqual && (currentPath == null || compareResult == null || compareResult.isMessageLimitReached())){
                return false;
}
        }
        
        return arraysAreEqual;
    }
    
    private boolean compareNamesExtended(PdfName outName, PdfName cmpName, ObjectPath currentPath, CompareResult compareResult) {
        if (cmpName.equals(outName)) {
            return true;
        }
         else {
            if (compareResult != null && currentPath != null){
                compareResult.addError(currentPath, MessageFormatUtil.format("PdfName. Expected: {0}. Found: {1}", cmpName.toString(), outName.toString()));
}
            return false;
        }
        
    }
    
    private boolean compareNumbersExtended(PdfNumber outNumber, PdfNumber cmpNumber, ObjectPath currentPath, CompareResult compareResult) {
        if (cmpNumber.getValue() == outNumber.getValue()) {
            return true;
        }
         else {
            if (compareResult != null && currentPath != null){
                compareResult.addError(currentPath, MessageFormatUtil.format("PdfNumber. Expected: {0}. Found: {1}", cmpNumber, outNumber));
}
            return false;
        }
        
    }
    
    private boolean compareStringsExtended(PdfString outString, PdfString cmpString, ObjectPath currentPath, CompareResult compareResult) {
        if (Arrays.equals(convertPdfStringToBytes(cmpString), convertPdfStringToBytes(outString))) {
            return true;
        }
         else {
            String cmpStr = cmpString.toUnicodeString();
            String outStr = outString.toUnicodeString();
            StringBuilder errorMessage = new StringBuilder();
            if (cmpStr.length() != outStr.length()) {
                errorMessage.append(MessageFormatUtil.format("PdfString. Lengths are different. Expected: {0}. Found: {1}\n", cmpStr.length(), outStr.length()));
            }
             else {
                errorMessage.append("PdfString. Characters are different.\n");
            }
            
            int firstDifferenceOffset = findStringDifference(outStr, cmpStr, errorMessage);
            if (compareResult != null && currentPath != null) {
                currentPath.pushOffsetToPath(firstDifferenceOffset);
                compareResult.addError(currentPath, errorMessage.toString());
                currentPath.pop();
            }
            
            return false;
        }
        
    }
    
    private int findStringDifference(String outString, String cmpString, StringBuilder errorMessage) {
        int numberOfDifferentChars = 0;
        int firstDifferenceOffset = 0;
        int minLength = Math.min(cmpString.length(), outString.length());
        for (int i = 0; i < minLength; i++) {
            if (cmpString.charAt(i) != outString.charAt(i)) { ++numberOfDifferentChars;
                if (numberOfDifferentChars == 1) {
                    firstDifferenceOffset = i;
                }
                
            }
            
        }
        
        String stringDifference = null;
        if (numberOfDifferentChars > 0) {
            int diffBytesAreaL = 15;
            int diffBytesAreaR = 15;
            int lCmp = Math.max(0, firstDifferenceOffset - diffBytesAreaL);
            int rCmp = Math.min(cmpString.length(), firstDifferenceOffset + diffBytesAreaR);
            int lOut = Math.max(0, firstDifferenceOffset - diffBytesAreaL);
            int rOut = Math.min(outString.length(), firstDifferenceOffset + diffBytesAreaR);
            String cmpByte = String.valueOf(cmpString.charAt(firstDifferenceOffset));
            String cmpByteNeighbours = cmpString.substring(lCmp, rCmp).replaceAll(NEW_LINES, " ");
            String outByte = String.valueOf(outString.charAt(firstDifferenceOffset));
            String outBytesNeighbours = outString.substring(lOut, rOut).replaceAll(NEW_LINES, " ");
            stringDifference = MessageFormatUtil.format("First characters difference is encountered at index {0}.\nExpected: {1} ({2}).\nFound: {3} ({4}).\nTotal number of different characters: {5}", Integer.valueOf(firstDifferenceOffset).toString(), cmpByte, cmpByteNeighbours, outByte, outBytesNeighbours, numberOfDifferentChars);
        }
         else {
            firstDifferenceOffset = minLength;
            stringDifference = MessageFormatUtil.format("All characters of the shorter string are the same as the first {0} characters of the longer one.", minLength);
        }
        
        errorMessage.append(stringDifference);
        return firstDifferenceOffset;
    }
    
    private byte[] convertPdfStringToBytes(PdfString pdfString) {
        byte[] bytes;
        String value = pdfString.getValue();
        String encoding = pdfString.getEncoding();
        if (encoding != null && PdfEncodings.UNICODE_BIG.equals(encoding) && PdfEncodings.isPdfDocEncoding(value)){
            bytes = PdfEncodings.convertToBytes(value, PdfEncodings.PDF_DOC_ENCODING);
}
        else{
            bytes = PdfEncodings.convertToBytes(value, encoding);
}
        return bytes;
    }
    
    private boolean compareBooleansExtended(PdfBoolean outBoolean, PdfBoolean cmpBoolean, ObjectPath currentPath, CompareResult compareResult) {
        if (cmpBoolean.getValue() == outBoolean.getValue()) {
            return true;
        }
         else {
            if (compareResult != null && currentPath != null){
                compareResult.addError(currentPath, MessageFormatUtil.format("PdfBoolean. Expected: {0}. Found: {1}.", cmpBoolean.getValue(), outBoolean.getValue()));
}
            return false;
        }
        
    }
    
    private List<PdfLinkAnnotation> getLinkAnnotations(int pageNum, PdfDocument document) {
        List<PdfLinkAnnotation> linkAnnotations = new ArrayList<>();
        List<PdfAnnotation> annotations = document.getPage(pageNum).getAnnotations();
        for (PdfAnnotation annotation : annotations) {
            if (PdfName.Link.equals(annotation.getSubtype())) {
                linkAnnotations.add((PdfLinkAnnotation) annotation);
            }
            
        }
        
        return linkAnnotations;
    }
    
    private boolean compareLinkAnnotations(PdfLinkAnnotation cmpLink, PdfLinkAnnotation outLink, PdfDocument cmpDocument, PdfDocument outDocument) {
        PdfObject cmpDestObject = cmpLink.getDestinationObject();
        PdfObject outDestObject = outLink.getDestinationObject();
        if (cmpDestObject != null && outDestObject != null) {
            if (cmpDestObject.getType() != outDestObject.getType()){
                return false;
}
            else {
                PdfArray explicitCmpDest = null;
                PdfArray explicitOutDest = null;
                Map<String, PdfObject> cmpNamedDestinations = cmpDocument.getCatalog().getNameTree(PdfName.Dests).getNames();
                Map<String, PdfObject> outNamedDestinations = outDocument.getCatalog().getNameTree(PdfName.Dests).getNames();
                switch (cmpDestObject.getType()) {
                    case PdfObject.ARRAY:
                        explicitCmpDest = (PdfArray) cmpDestObject;
                        explicitOutDest = (PdfArray) outDestObject;
                        break;
                    case PdfObject.NAME:
                        explicitCmpDest = (PdfArray) cmpNamedDestinations.get(((PdfName) cmpDestObject).getValue());
                        explicitOutDest = (PdfArray) outNamedDestinations.get(((PdfName) outDestObject).getValue());
                        break;
                    case PdfObject.STRING:
                        explicitCmpDest = (PdfArray) cmpNamedDestinations.get(((PdfString) cmpDestObject).toUnicodeString());
                        explicitOutDest = (PdfArray) outNamedDestinations.get(((PdfString) outDestObject).toUnicodeString());
                        break;
                    default: break;
                }
                
                if (getExplicitDestinationPageNum(explicitCmpDest) != getExplicitDestinationPageNum(explicitOutDest)){
                    return false;
}
            }
            
        }
        
        PdfDictionary cmpDict = cmpLink.getPdfObject();
        PdfDictionary outDict = outLink.getPdfObject();
        if (cmpDict.size() != outDict.size()){
            return false;
}
        Rectangle cmpRect = cmpDict.getAsRectangle(PdfName.Rect);
        Rectangle outRect = outDict.getAsRectangle(PdfName.Rect);
        if (cmpRect.getHeight() != outRect.getHeight() || cmpRect.getWidth() != outRect.getWidth() || cmpRect.getX() != outRect.getX() || cmpRect.getY() != outRect.getY()){
            return false;
}
        for (Map.Entry<PdfName, PdfObject> cmpEntry : cmpDict.entrySet()) {
            PdfObject cmpObj = cmpEntry.getValue();
            if (!outDict.containsKey(cmpEntry.getKey())){
                return false;
}
            PdfObject outObj = outDict.get(cmpEntry.getKey());
            if (cmpObj.getType() != outObj.getType()){
                return false;
}
            switch (cmpObj.getType()) {
                case PdfObject.NULL:
                case PdfObject.BOOLEAN:
                case PdfObject.NUMBER:
                case PdfObject.STRING:
                case PdfObject.NAME:
                    if (!cmpObj.toString().equals(outObj.toString())){
                        return false;
}
                    break;
            }
            
        }
        
        return true;
    }
    
    private int getExplicitDestinationPageNum(PdfArray explicitDest) {
        PdfIndirectReference pageReference = (PdfIndirectReference) explicitDest.get(0, false);
        PdfDocument doc = pageReference.getDocument();
        for (int i = 1; i <= doc.getNumberOfPages(); ++i) {
            if (doc.getPage(i).getPdfObject().getIndirectReference().equals(pageReference)){
                return i;
}
        }
        
        throw new IllegalArgumentException("PdfLinkAnnotation comparison: Page not found.");
    }
    
    private class PngFileFilter implements FileFilter {
        public boolean accept(File pathname) {
            String ap = pathname.getName();
            boolean b1 = ap.endsWith(".png");
            boolean b2 = ap.contains("cmp_");
            return b1 && !b2 && ap.contains(outPdfName);
        }
        
    }
    
    private class CmpPngFileFilter implements FileFilter {
        public boolean accept(File pathname) {
            String ap = pathname.getName();
            boolean b1 = ap.endsWith(".png");
            boolean b2 = ap.contains("cmp_");
            return b1 && b2 && ap.contains(cmpPdfName);
        }
        
    }
    
    private class DiffPngFileFilter implements FileFilter {
        private String differenceImagePrefix;
        public DiffPngFileFilter(String differenceImagePrefix) {
            this.differenceImagePrefix = differenceImagePrefix;
        }
        
        public boolean accept(File pathname) {
            String ap = pathname.getName();
            boolean b1 = ap.endsWith(".png");
            boolean b2 = ap.startsWith(differenceImagePrefix);
            return b1 && b2;
        }
        
    }
    
    private class ImageNameComparator implements Comparator<File> {
        public int compare(File f1, File f2) {
            String f1Name = f1.getName();
            String f2Name = f2.getName();
            return f1Name.compareTo(f2Name);
        }
        
    }
    
    public class CompareResult {
        protected Map<ObjectPath, String> differences = new LinkedHashMap<>();
        protected int messageLimit = 1;
        public CompareResult(int messageLimit) {
            this.messageLimit = messageLimit;
        }
        
        public boolean isOk() {
            return differences.size() == 0;
        }
        
        public int getErrorCount() {
            return differences.size();
        }
        
        public String getReport() {
            StringBuilder sb = new StringBuilder();
            boolean firstEntry = true;
            for (Map.Entry<ObjectPath, String> entry : differences.entrySet()) {
                if (!firstEntry){
                    sb.append("-----------------------------").append("\n");
}
                ObjectPath diffPath = entry.getKey();
                sb.append(entry.getValue()).append("\n").append(diffPath.toString()).append("\n");
                firstEntry = false;
            }
            
            return sb.toString();
        }
        
        public Map<ObjectPath, String> getDifferences() {
            return differences;
        }
        
        public void writeReportToXml(OutputStream stream) throws ParserConfigurationException, TransformerException {
            Document xmlReport = XmlUtils.initNewXmlDocument();
            Element root = xmlReport.createElement("report");
            Element errors = xmlReport.createElement("errors");
            errors.setAttribute("count", String.valueOf(differences.size()));
            root.appendChild(errors);
            for (Map.Entry<ObjectPath, String> entry : differences.entrySet()) {
                Node errorNode = xmlReport.createElement("error");
                Node message = xmlReport.createElement("message");
                message.appendChild(xmlReport.createTextNode(entry.getValue()));
                Node path = entry.getKey().toXmlNode(xmlReport);
                errorNode.appendChild(message);
                errorNode.appendChild(path);
                errors.appendChild(errorNode);
            }
            
            xmlReport.appendChild(root);
            XmlUtils.writeXmlDocToStream(xmlReport, stream);
        }
        
        protected boolean isMessageLimitReached() {
            return differences.size() >= messageLimit;
        }
        
        protected void addError(ObjectPath path, String message) {
            if (differences.size() < messageLimit) {
                differences.put(((ObjectPath) path.clone()), message);
            }
            
        }
        
    }
    
    public class ObjectPath {
        protected PdfIndirectReference baseCmpObject;
        protected PdfIndirectReference baseOutObject;
        protected Stack<LocalPathItem> path = new Stack<LocalPathItem>();
        protected Stack<IndirectPathItem> indirects = new Stack<IndirectPathItem>();
        public ObjectPath() {
        }
        
        public ObjectPath(PdfIndirectReference baseCmpObject, PdfIndirectReference baseOutObject) {
            this.baseCmpObject = baseCmpObject;
            this.baseOutObject = baseOutObject;
            indirects.push(new IndirectPathItem(baseCmpObject, baseOutObject));
        }
        
        public ObjectPath(PdfIndirectReference baseCmpObject, PdfIndirectReference baseOutObject, Stack<LocalPathItem> path, Stack<IndirectPathItem> indirects) {
            this.baseCmpObject = baseCmpObject;
            this.baseOutObject = baseOutObject;
            this.path = path;
            this.indirects = indirects;
        }
        
        public ObjectPath resetDirectPath(PdfIndirectReference baseCmpObject, PdfIndirectReference baseOutObject) {
            ObjectPath newPath = new ObjectPath(baseCmpObject, baseOutObject, new Stack<LocalPathItem>(), (Stack<IndirectPathItem>) indirects.clone());
            newPath.indirects.push(new IndirectPathItem(baseCmpObject, baseOutObject));
            return newPath;
        }
        
        public boolean isComparing(PdfIndirectReference cmpObject, PdfIndirectReference outObject) {
            return indirects.contains(new IndirectPathItem(cmpObject, outObject));
        }
        
        public void pushArrayItemToPath(int index) {
            path.push(new ArrayPathItem(index));
        }
        
        public void pushDictItemToPath(PdfName key) {
            path.push(new DictPathItem(key));
        }
        
        public void pushOffsetToPath(int offset) {
            path.push(new OffsetPathItem(offset));
        }
        
        public void pop() {
            path.pop();
        }
        
        public Stack<LocalPathItem> getLocalPath() {
            return path;
        }
        
        public Stack<IndirectPathItem> getIndirectPath() {
            return indirects;
        }
        
        public PdfIndirectReference getBaseCmpObject() {
            return baseCmpObject;
        }
        
        public PdfIndirectReference getBaseOutObject() {
            return baseOutObject;
        }
        
        public Node toXmlNode(Document document) {
            Element element = document.createElement("path");
            Element baseNode = document.createElement("base");
            baseNode.setAttribute("cmp", MessageFormatUtil.format("{0} {1} obj", baseCmpObject.getObjNumber(), baseCmpObject.getGenNumber()));
            baseNode.setAttribute("out", MessageFormatUtil.format("{0} {1} obj", baseOutObject.getObjNumber(), baseOutObject.getGenNumber()));
            element.appendChild(baseNode);
            Stack<LocalPathItem> pathClone = (Stack<LocalPathItem>) path.clone();
            List<LocalPathItem> localPathItems = new ArrayList<>(path.size());
            for (int i = 0; i < path.size(); ++i) {
                localPathItems.add(pathClone.pop());
            }
            
            for (int i = localPathItems.size() - 1; i >= 0; --i) {
                element.appendChild(localPathItems.get(i).toXmlNode(document));
            }
            
            return element;
        }
        
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(MessageFormatUtil.format("Base cmp object: {0} obj. Base out object: {1} obj", baseCmpObject, baseOutObject));
            Stack<LocalPathItem> pathClone = (Stack<LocalPathItem>) path.clone();
            List<LocalPathItem> localPathItems = new ArrayList<>(path.size());
            for (int i = 0; i < path.size(); ++i) {
                localPathItems.add(pathClone.pop());
            }
            
            for (int i = localPathItems.size() - 1; i >= 0; --i) {
                sb.append("\n");
                sb.append(localPathItems.get(i).toString());
            }
            
            return sb.toString();
        }
        
        public int hashCode() {
            int baseCmpObjectHashCode = 0;
            if (baseCmpObject != null) {
                baseCmpObjectHashCode = baseCmpObject.getObjNumber() * 31 + baseCmpObject.getGenNumber();
            }
            
            int baseOutObjectHashCode = 0;
            if (baseOutObject != null) {
                baseOutObjectHashCode = baseOutObject.getObjNumber() * 31 + baseOutObject.getGenNumber();
            }
            
            int hashCode = baseCmpObjectHashCode * 31 + baseOutObjectHashCode;
            for (LocalPathItem pathItem : path) {
                hashCode *= 31;
                hashCode += pathItem.hashCode();
            }
            
            return hashCode;
        }
        
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            
            ObjectPath that = (ObjectPath) obj;
            boolean isBaseCmpObjectEqual;
            if (baseCmpObject == that.baseCmpObject) {
                isBaseCmpObjectEqual = true;
            }
             else if (baseCmpObject == null || that.baseCmpObject == null || baseCmpObject.getClass() != that.baseCmpObject.getClass()) {
                isBaseCmpObjectEqual = false;
            }
             else {
                isBaseCmpObjectEqual = baseCmpObject.getObjNumber() == that.baseCmpObject.getObjNumber() && baseCmpObject.getGenNumber() == that.baseCmpObject.getGenNumber();
            }
            
            boolean isBaseOutObjectEqual;
            if (baseOutObject == that.baseOutObject) {
                isBaseOutObjectEqual = true;
            }
             else if (baseOutObject == null || that.baseOutObject == null || baseOutObject.getClass() != that.baseOutObject.getClass()) {
                isBaseOutObjectEqual = false;
            }
             else {
                isBaseOutObjectEqual = baseOutObject.getObjNumber() == that.baseOutObject.getObjNumber() && baseOutObject.getGenNumber() == that.baseOutObject.getGenNumber();
            }
            
            return isBaseCmpObjectEqual && isBaseOutObjectEqual && path.equals(((ObjectPath) obj).path);
        }
        
        protected Object clone() {
            return new ObjectPath(baseCmpObject, baseOutObject, (Stack<LocalPathItem>) path.clone(), (Stack<IndirectPathItem>) indirects.clone());
        }
        
        public class IndirectPathItem {
            private PdfIndirectReference cmpObject;
            private PdfIndirectReference outObject;
            public IndirectPathItem(PdfIndirectReference cmpObject, PdfIndirectReference outObject) {
                this.cmpObject = cmpObject;
                this.outObject = outObject;
            }
            
            public PdfIndirectReference getCmpObject() {
                return cmpObject;
            }
            
            public PdfIndirectReference getOutObject() {
                return outObject;
            }
            
            public int hashCode() {
                return cmpObject.hashCode() * 31 + outObject.hashCode();
            }
            
            public boolean equals(Object obj) {
                return (obj.getClass() == getClass() && cmpObject.equals(((IndirectPathItem) obj).cmpObject) && outObject.equals(((IndirectPathItem) obj).outObject));
            }
            
        }
        
        public abstract class LocalPathItem {
            protected abstract Node toXmlNode(Document document);
        }
        
        public class DictPathItem extends LocalPathItem {
            PdfName key;
            public DictPathItem(PdfName key) {
                this.key = key;
            }
            
            public String toString() {
                return "Dict key: " + key;
            }
            
            public int hashCode() {
                return key.hashCode();
            }
            
            public boolean equals(Object obj) {
                return obj.getClass() == getClass() && key.equals(((DictPathItem) obj).key);
            }
            
            public PdfName getKey() {
                return key;
            }
            
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("dictKey");
                element.appendChild(document.createTextNode(key.toString()));
                return element;
            }
            
        }
        
        public class ArrayPathItem extends LocalPathItem {
            int index;
            public ArrayPathItem(int index) {
                this.index = index;
            }
            
            public String toString() {
                return "Array index: " + String.valueOf(index);
            }
            
            public int hashCode() {
                return index;
            }
            
            public boolean equals(Object obj) {
                return obj.getClass() == getClass() && index == ((ArrayPathItem) obj).index;
            }
            
            public int getIndex() {
                return index;
            }
            
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("arrayIndex");
                element.appendChild(document.createTextNode(String.valueOf(index)));
                return element;
            }
            
        }
        
        public class OffsetPathItem extends LocalPathItem {
            int offset;
            public OffsetPathItem(int offset) {
                this.offset = offset;
            }
            
            public int getOffset() {
                return offset;
            }
            
            public String toString() {
                return "Offset: " + String.valueOf(offset);
            }
            
            public int hashCode() {
                return offset;
            }
            
            public boolean equals(Object obj) {
                return obj.getClass() == getClass() && offset == ((OffsetPathItem) obj).offset;
            }
            
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("offset");
                element.appendChild(document.createTextNode(String.valueOf(offset)));
                return element;
            }
            
        }
        
    }
    
    private class TrailerPath extends ObjectPath {
        private PdfDocument outDocument;
        private PdfDocument cmpDocument;
        public TrailerPath(PdfDocument cmpDoc, PdfDocument outDoc) {
            outDocument = outDoc;
            cmpDocument = cmpDoc;
        }
        
        public TrailerPath(PdfDocument cmpDoc, PdfDocument outDoc, Stack<LocalPathItem> path) {
            this.outDocument = outDoc;
            this.cmpDocument = cmpDoc;
            this.path = path;
        }
        
        public Node toXmlNode(Document document) {
            Element element = document.createElement("path");
            Element baseNode = document.createElement("base");
            baseNode.setAttribute("cmp", "trailer");
            baseNode.setAttribute("out", "trailer");
            element.appendChild(baseNode);
            for (LocalPathItem pathItem : path) {
                element.appendChild(pathItem.toXmlNode(document));
            }
            
            return element;
        }
        
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Base cmp object: trailer. Base out object: trailer");
            for (LocalPathItem pathItem : path) {
                sb.append("\n");
                sb.append(pathItem.toString());
            }
            
            return sb.toString();
        }
        
        public int hashCode() {
            int hashCode = outDocument.hashCode() * 31 + cmpDocument.hashCode();
            for (LocalPathItem pathItem : path) {
                hashCode *= 31;
                hashCode += pathItem.hashCode();
            }
            
            return hashCode;
        }
        
        public boolean equals(Object obj) {
            return obj.getClass() == getClass() && outDocument.equals(((TrailerPath) obj).outDocument) && cmpDocument.equals(((TrailerPath) obj).cmpDocument) && path.equals(((ObjectPath) obj).path);
        }
        
        protected Object clone() {
            return new TrailerPath(cmpDocument, outDocument, (Stack<LocalPathItem>) path.clone());
        }
        
    }
    
    public class CompareToolExecutionException extends RuntimeException {
        public CompareToolExecutionException(String msg) {
            super(msg);
        }
        
    }
    
}


