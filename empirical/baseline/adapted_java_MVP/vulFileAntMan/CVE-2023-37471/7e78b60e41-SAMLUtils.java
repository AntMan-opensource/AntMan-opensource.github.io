package com.sun.identity.saml.common;
import static org.forgerock.openam.utils.Time.*;
import java.util.Collections;
import java.util.Date;
import java.util.Map;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Enumeration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.text.StringCharacterIterator;
import java.text.CharacterIterator;
import java.io.UnsupportedEncodingException;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.security.MessageDigest;
import java.net.URL;
import java.net.MalformedURLException;
import org.w3c.dom.*;
import com.sun.identity.common.PeriodicGroupRunnable;
import com.sun.identity.common.ScheduleableGroupAction;
import com.sun.identity.common.SystemConfigurationUtil;
import com.sun.identity.common.SystemConfigurationException;
import com.sun.identity.common.SystemTimerPool;
import com.sun.identity.common.TaskRunnable;
import com.sun.identity.common.TimerPool;
import com.sun.identity.shared.xml.XMLUtils;
import com.sun.identity.shared.encode.URLEncDec;
import com.sun.identity.shared.encode.Base64;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.xml.soap.MimeHeaders;
import javax.xml.soap.MimeHeader;
import com.sun.identity.saml.assertion.SubjectConfirmation;
import com.sun.identity.saml.assertion.Assertion;
import com.sun.identity.saml.assertion.Attribute;
import com.sun.identity.saml.assertion.AttributeStatement;
import com.sun.identity.saml.assertion.AuthenticationStatement;
import com.sun.identity.saml.assertion.AudienceRestrictionCondition;
import com.sun.identity.saml.assertion.Condition;
import com.sun.identity.saml.assertion.Conditions;
import com.sun.identity.saml.assertion.Statement;
import com.sun.identity.saml.assertion.SubjectStatement;
import com.sun.identity.saml.xmlsig.XMLSignatureManager;
import com.sun.identity.saml.plugins.PartnerAccountMapper;
import com.sun.identity.saml.protocol.*;
import com.sun.identity.saml.servlet.POSTCleanUpRunnable;
import com.sun.identity.plugin.session.SessionException;
import com.sun.identity.plugin.session.SessionManager;
import com.sun.identity.plugin.session.SessionProvider;
import com.sun.identity.saml.assertion.Subject;
import com.sun.identity.saml.SAMLClient;
import com.sun.identity.federation.common.FSUtils;
import javax.xml.parsers.DocumentBuilder;
import org.apache.xml.security.c14n.Canonicalizer;
public class SAMLUtils  extends SAMLUtilsCommon {
    public static final String HTTP_MAX_CONTENT_LENGTH = "com.sun.identity.saml.request.maxContentLength";
    public static final int defaultMaxLength = 16384;
    public static final String DEFAULT_CONTENT_LENGTH = String.valueOf(defaultMaxLength);
    private static final String ERROR_JSP = "/saml2/jsp/autosubmittingerror.jsp";
    private static int maxContentLength = 0;
    private static Map idTimeMap = Collections.synchronizedMap(new HashMap());
    private static TaskRunnable cGoThrough = null;
    private static TaskRunnable cPeriodic = null;
    private static Object ssoToken;
    static {
        org.apache.xml.security.Init.init();
        if (SystemConfigurationUtil.isServerMode()) {
            long period = ((Integer) SAMLServiceManager.getAttribute( SAMLConstants.CLEANUP_INTERVAL_NAME)).intValue() * 1000;
            cGoThrough = new POSTCleanUpRunnable(period, idTimeMap);
            TimerPool timerPool = SystemTimerPool.getTimerPool();
            timerPool.schedule(cGoThrough, new Date(((currentTimeMillis() + period) / 1000) * 1000));
            ScheduleableGroupAction periodicAction = new ScheduleableGroupAction() {                 public void doGroupAction(Object obj) { idTimeMap.remove(obj);
                }
                
            };
            cPeriodic = new PeriodicGroupRunnable(periodicAction, period, 180000, true);
            timerPool.schedule(cPeriodic, new Date(((currentTimeMillis() + period) / 1000) * 1000));
        }
        
        try {
            maxContentLength = Integer.parseInt(SystemConfigurationUtil. getProperty(SAMLUtils.HTTP_MAX_CONTENT_LENGTH, SAMLUtils.DEFAULT_CONTENT_LENGTH));
        }
         catch (NumberFormatException ne) {
            SAMLUtils.debug.error("Wrong format of SAML request max content " + "length. Take default value.");
            maxContentLength=  SAMLUtils.defaultMaxLength;
        }
        
    }
    
    private SAMLUtils() {
    }
    
    public static String generateAssertionID() {
        String encodedID = generateID();
        if (encodedID == null) {
            return null;
        }
        
        String id = null;
        try {
            id = SystemConfigurationUtil.getServerID( SAMLServiceManager.getServerProtocol(), SAMLServiceManager.getServerHost(), Integer.parseInt(SAMLServiceManager.getServerPort()), SAMLServiceManager.getServerURI());
        }
         catch (Exception ex) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtil:generateAssertionID: " + "exception obtain serverID:", ex);
            }
            
        }
        
        if (id == null) {
            return encodedID;
        }
         else {
            return (encodedID + id);
        }
        
    }
    
    public static boolean checkQuery(Element element, String queryname) {
        String tag = element.getLocalName();
        if (tag == null) {
            return false;
        }
         else if (tag.equals("Query") || tag.equals("SubjectQuery")) {
            NamedNodeMap nm = element.getAttributes();
            int len = nm.getLength();
            String attrName;
            Attr attr;
            boolean found = false;
            for (int j = 0; j < len; j++) {
                attr = (Attr) nm.item(j);
                attrName = attr.getLocalName();
                if ((attrName != null) && (attrName.equals("type")) && (attr.getNodeValue().equals(queryname + "Type"))) {
                    found = true;
                    break;
                }
                
            }
            
            if (!found) {
                return false;
            }
            
        }
         else if (!tag.equals(queryname)) {
            return false;
        }
        
        return true;
    }
    
    public static String generateSourceID(String siteURL) {
        if ((siteURL == null) || (siteURL.length() == 0)) {
            SAMLUtils.debug.error("SAMLUtils.genrateSourceID: empty siteURL.");
            return null;
        }
        
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA");
        }
         catch (Exception e) {
            SAMLUtils.debug.error("SAMLUtils.generateSourceID: Exception when" + " generating digest:",e);
            return null;
        }
        
        md.update(SAMLUtils.stringToByteArray(siteURL));
        byte byteResult[] = md.digest();
        String result = null;
        try {
            result = Base64.encode(byteResult).trim();
        }
         catch (Exception e) {
            SAMLUtils.debug.error("SAMLUtils.generateSourceID: Exception:",e);
        }
        
        return result;
    }
    
    public static String generateAssertionHandle() {
        if (random == null) {
            return null;
        }
        
        byte bytes[] = new byte[SAMLConstants.ID_LENGTH];
        random.nextBytes(bytes);
        String id = null;
        try {
            id = SystemConfigurationUtil.getServerID( SAMLServiceManager.getServerProtocol(), SAMLServiceManager.getServerHost(), Integer.parseInt(SAMLServiceManager.getServerPort()), SAMLServiceManager.getServerURI());
        }
         catch (Exception ex) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtil:generateAssertionHandle: " + "exception obtain serverID:", ex);
            }
            
        }
        
        if (id != null) {
            byte idBytes[] = stringToByteArray(id);
            if (idBytes.length < bytes.length) {
                for (int i = 1; i <= idBytes.length; i++) {
                    bytes[bytes.length - i] = idBytes[idBytes.length - i];
                }
                
            }
            
        }
        
        return byteArrayToString(bytes);
    }
    
    public static byte[] hexStringToByteArray(String hexString) {
        int read = hexString.length();
        byte[] byteArray = new byte[read/2];
        for (int i=0, j=0; i < read; i++, j++) {
            String part = hexString.substring(i,i+2);
            byteArray[j] = new Short(Integer.toString(Integer.parseInt(part,16))). byteValue();
            i++;
        }
        
        return byteArray;
    }
    
    public static String hexStringToBase64(String hexString) {
        int read = hexString.length();
        byte[] byteArray = new byte[read/2];
        for (int i=0, j=0; i < read; i++, j++) {
            String part = hexString.substring(i,i+2);
            byteArray[j] = new Short(Integer.toString(Integer.parseInt(part,16))). byteValue();
            i++;
        }
        
        String encodedID = null;
        try {
            encodedID = Base64.encode(byteArray).trim();
        }
         catch (Exception e) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtil:hexStringToBase64: " + "exception encode input:", e);
            }
            
        }
        
        if (SAMLUtils.debug.messageEnabled()) {
            SAMLUtils.debug.message("base 64 source id is :"+encodedID);
        }
        
        return encodedID;
    }
    
    public static SAMLServiceManager.SOAPEntry getSourceSite(String issuer) {
        if (issuer == null) {
            return null;
        }
        
        Map entries = (Map) SAMLServiceManager.getAttribute( SAMLConstants.PARTNER_URLS);
        if (entries == null) {
            SAMLUtils.debug.error("SAMLUtils.isOnPartnerURLList: PartnerURL " + "list is null.");
            return null;
        }
        
        Iterator entryIter = entries.values().iterator();
        boolean found = false;
        SAMLServiceManager.SOAPEntry srcSite = null;
        String theIssuer = null;
        while (entryIter.hasNext()) {
            srcSite = (SAMLServiceManager.SOAPEntry) entryIter.next();
            if ((srcSite != null) && ((theIssuer = srcSite.getIssuer()) != null) && (theIssuer.equals(issuer))) {
                found = true;
                break;
            }
            
        }
        
        if (found) {
            return srcSite;
        }
         else {
            return null;
        }
        
    }
    
    public static void main(String args[]) {
        if (args.length != 1) {
            System.out.println("usage : java SAMLUtils <host_name>");
            return;
        }
        
        System.out.println(generateSourceID(args[0]));
    }
    
    public static boolean isCorrectConfirmationMethod(SubjectConfirmation sc) {
        if (sc == null) {
            return false;
        }
        
        Set cmSet = sc.getConfirmationMethod();
        if ((cmSet == null) || (cmSet.size() != 1)) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtils.isCorrectConfirmationMethod:" + " missing ConfirmationMethod in the Subject.");
            }
            
            return false;
        }
        
        String conMethod = (String) cmSet.iterator().next();
        if ((conMethod == null) || (!conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_IS))) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtils.isCorrectConfirmationMethod:" + " wrong ConfirmationMethod value.");
            }
            
            return false;
        }
        
        return true;
    }
    
    public static boolean isAuthNAssertion(Assertion assertion) {
        if (assertion == null) {
            return false;
        }
        
        if ((!assertion.isTimeValid()) || (!assertion.isSignatureValid())) {
            return false;
        }
        
        Set statements = assertion.getStatement();
        Statement statement = null;
        Iterator iterator = statements.iterator();
        while (iterator.hasNext()) {
            statement = (Statement) iterator.next();
            if (statement.getStatementType() == Statement.AUTHENTICATION_STATEMENT) {
                return true;
            }
            
        }
         
        return false;
    }
    
    public static byte[] stringToByteArray(String input) {
        char chars[] = input.toCharArray();
        byte bytes[] = new byte[chars.length];
        for (int i = 0; i < chars.length; i++) {
            bytes[i] = (byte) chars[i];
        }
        
        return bytes;
    }
    
    public static String getServerID(String idTypeString) {
        if (idTypeString == null) {
            return null;
        }
        
        int len = idTypeString.length();
        String id = null;
        if (len >= SAMLConstants.SERVER_ID_LENGTH) {
            id = idTypeString.substring((len - SAMLConstants.SERVER_ID_LENGTH), len);
            return id;
        }
         else {
            return null;
        }
        
    }
    
    public static String getServerURL(String str) {
        String id = SAMLUtils.getServerID(str);
        if (id == null) {
            return null;
        }
        
        if (SAMLUtils.debug.messageEnabled()) {
            SAMLUtils.debug.message("SAMLUtils.getServerURL: id=" + id);
        }
        
        String remoteUrl = null;
        try {
            remoteUrl = SystemConfigurationUtil.getServerFromID(id);
        }
         catch (SystemConfigurationException se) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtils.getServerURL: ServerEntry" + "NotFoundException for " + id);
            }
            
            return null;
        }
        
        String thisUrl = SAMLServiceManager.getServerURL();
        if (SAMLUtils.debug.messageEnabled()) {
            SAMLUtils.debug.message("SAMLUtils.getServerURL: remoteUrl=" + remoteUrl + ", thisUrl=" + thisUrl);
        }
        
        if ((remoteUrl == null) || (thisUrl == null) || (remoteUrl.equalsIgnoreCase(thisUrl))) {
            return null;
        }
         else {
            return remoteUrl;
        }
        
    }
    
    public static String getFullServiceURL(String shortUrl) {
        String result = null;
        try {
            URL u = new URL(shortUrl);
            URL weburl = SystemConfigurationUtil.getServiceURL( SAMLConstants.SAML_AM_NAMING, u.getProtocol(), u.getHost(), u.getPort(), u.getPath());
            result = weburl.toString();
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtils.getFullServiceURL:" + "full remote URL is: " + result);
            }
            
        }
         catch (Exception e) {
            if (SAMLUtils.debug.warningEnabled()) {
                SAMLUtils.debug.warning("SAMLUtils.getFullServiceURL:" + "Exception:", e);
            }
            
        }
        
        return result;
    }
    
    public static void addEnvParamsFromAssertion(Map envParameters, Assertion assertion, com.sun.identity.saml.assertion.Subject subject) {
        Set statements = assertion.getStatement();
        Statement statement = null;
        Iterator stmtIter = null;
        List attrs = null;
        Iterator attrIter = null;
        Attribute attribute = null;
        Element attrValue = null;
        List attrValues = null;
        String attrName = null;
        String attrValueString = null;
        if ((statements != null) && (!statements.isEmpty())) {
            stmtIter = statements.iterator();
            while (stmtIter.hasNext()) {
                statement = (Statement) stmtIter.next();
                if (statement.getStatementType() == Statement.ATTRIBUTE_STATEMENT) {
                    if (!subject.equals( ((AttributeStatement)statement).getSubject())) {
                        continue;
                    }
                    
                    attrs = ((AttributeStatement) statement).getAttribute();
                    attrIter = attrs.iterator();
                    while (attrIter.hasNext()) {
                        attribute = (Attribute) attrIter.next();
                        try {
                            attrValues = attribute.getAttributeValue();
                        }
                         catch (Exception e) {
                            debug.error("SAMLUtils.addEnvParamsFromAssertion:"+ " cannot obtain attribute value:", e);
                            continue;
                        }
                        
                        attrName = attribute.getAttributeName();
                        List attrValueList = null;
                        for(Iterator avIter = attrValues.iterator();
                            avIter.hasNext(); ) {
                            attrValue = (Element) avIter.next();
                            if (!XMLUtils.hasElementChild(attrValue)) {
                                attrValueString = XMLUtils.getElementValue(attrValue);
                                if (attrValueList == null) {
                                    attrValueList = new ArrayList();
                                }
                                
                                attrValueList.add(attrValueString);
                            }
                            
                        }
                        
                        if (attrValueList != null) {
                            if (debug.messageEnabled()) {
                                debug.message( "SAMLUtils.addEnvParamsFromAssertion:" + " attrName = " + attrName + " attrValue = " + attrValueList);
                            }
                            
                            String[] attrValueStrs = (String[])attrValueList. toArray(new String[attrValueList.size()]);
                            try {
                                envParameters.put(attrName, attrValueStrs);
                            }
                             catch (Exception ex) {
                                if (debug.messageEnabled()) {
                                    debug.message( "SAMLUtils.addEnvParamsFromAssertion:", ex);
                                }
                                
                            }
                            
                        }
                         else if (debug.messageEnabled()) {
                            if (debug.messageEnabled()) {
                                debug.message( "SAMLUtils.addEnvParamsFromAssertion:" + " attrName = " + attrName + " has no value");
                            }
                            
                        }
                        
                    }
                    
                }
                 
            }
            
        }
        
    }
    
    public static int getMaxContentLength() {
        return maxContentLength;
    }
    
    public static void checkHTTPContentLength(HttpServletRequest request) throws ServletException {
        if (maxContentLength != 0) {
            int length =  request.getContentLength();
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("HttpRequest content length= " +length);
            }
            
            if (length > maxContentLength) {
                if (SAMLUtils.debug.messageEnabled()) {
                    SAMLUtils.debug.message( "content length too large" + length);
                }
                
                throw new ServletException( SAMLUtils.bundle.getString("largeContentLength"));
            }
            
        }
        
    }
    
    public static void postToTarget(HttpServletResponse response, PrintWriter out, List assertion, String targeturl, Map attrMap) throws IOException {
        out.println("<HTML>");
        out.println("<HEAD>\n");
        out.println("<TITLE>Access rights validated</TITLE>\n");
        out.println("</HEAD>\n");
        out.println("<BODY Onload=\"document.forms[0].submit()\">");
        Iterator it = null;
        if (SAMLUtils.debug.messageEnabled()) {
            out.println("<H1>Access rights validated</H1>\n");
            out.println("<meta http-equiv=\"refresh\" content=\"20\">\n");
            out.println("<P>We have verified your access rights <STRONG>" + "</STRONG> according to the assertion shown " +"below. \n");
            out.println("You are being redirected to the resource.\n");
            out.println("Please wait ......\n");
            out.println("</P>\n");
            out.println("<HR><P>\n");
            if (assertion != null) {
                it = assertion.iterator();
                while (it.hasNext()) {
                    out.println(SAMLUtils.displayXML((String)it.next()));
                }
                
            }
            
            out.println("</P>\n");
        }
        
        out.println("<FORM METHOD=\"POST\" ACTION=\"" + targeturl + "\">");
        if (assertion != null) {
            it = assertion.iterator();
            while (it.hasNext()) {
                out.println("<INPUT TYPE=\"HIDDEN\" NAME=\""+ SAMLConstants.POST_ASSERTION_NAME + "\"");
                out.println("VALUE=\"" + URLEncDec.encode((String)it.next()) + "\">");
            }
            
        }
        
        if (attrMap != null && !attrMap.isEmpty()) {
            StringBuffer attrNamesSB = new StringBuffer();
            Set entrySet = attrMap.entrySet();
            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry)iter.next();
                String attrName = HTMLEncode((String)entry.getKey(), '\"');
                String attrValue = HTMLEncode((String)entry.getValue(), '\"');
                out.println("<INPUT TYPE=\"HIDDEN\" NAME=\""+ attrName + "\" VALUE=\"" + attrValue + "\">");
                if (attrNamesSB.length() > 0) {
                    attrNamesSB.append(":");
                }
                
                attrNamesSB.append(attrName);
            }
            
            out.println("<INPUT TYPE=\"HIDDEN\" NAME=\""+ SAMLConstants.POST_ATTR_NAMES + "\" VALUE=\"" + attrNamesSB + "\">");
        }
        
        out.println("</FORM>");
        out.println("</BODY></HTML>");
        out.close();
    }
    
    public static boolean postYN(String targetIn) {
        SAMLUtils.debug.message("Inside postYN()");
        if ((targetIn == null) || (targetIn.length() == 0)) {
            return false;
        }
        
        Set targets = (Set) SAMLServiceManager. getAttribute(SAMLConstants.POST_TO_TARGET_URLS);
        if ((targets == null) || (targets.size() == 0)) {
            return false;
        }
        
        URL targetUrl = null;
        try {
            targetUrl = new URL(targetIn);
        }
         catch (MalformedURLException me ) {
            SAMLUtils.debug.error("SAMLUtils:postYN(): Malformed URL passed");
            return false;
        }
        
        String targetInHost = targetUrl.getHost();
        int targetInPort = targetUrl.getPort();
        String targetInPath = targetUrl.getPath();
        String targetToCompare = new StringBuffer(targetInHost.toLowerCase()) .append(":").append(String.valueOf(targetInPort)) .append("/").append(targetInPath).toString();
        if (targets.contains(targetToCompare)) {
            return true;
        }
         else {
            return false;
        }
        
    }
    
    public static String HTMLEncode(String srcStr, char ch) {
        if (srcStr == null) {
            return null;
        }
        
        int fromIndex = 0;
        int toIndex;
        StringBuffer dstSB = new StringBuffer();
        while((toIndex = srcStr.indexOf(ch, fromIndex)) != -1) {
            dstSB.append(srcStr.substring(fromIndex, toIndex)) .append("&#" + (int)ch + ";");
            fromIndex = toIndex + 1;
        }
        
        dstSB.append(srcStr.substring(fromIndex));
        return dstSB.toString();
    }
    
    public static String displayXML(String input) {
        debug.message("In displayXML ");
        StringCharacterIterator iter = new StringCharacterIterator(input);
        StringBuffer buf = new StringBuffer();
        for(char c = iter.first();c != CharacterIterator.DONE;c = iter.next()) {
            if (c=='>') {
                buf.append("&gt;");
            }
             else if (c=='<') {
                buf.append("&lt;");
            }
             else if (c=='\n'){
                buf.append("<BR>\n");
            }
             else {
                buf.append(c);
            }
            
        }
        
        return buf.toString();
    }
    
    public static List getListOfAssertions(List assertions) {
        List returnAssertions = new ArrayList();
        try {
            if (assertions != null) {
                Iterator it = assertions.iterator();
                while (it.hasNext()) {
                    Document doc = XMLUtils.toDOMDocument((String)it.next(), debug);
                    Element root = doc.getDocumentElement();
                    if (root != null) {
                        Assertion assertion = new Assertion(root);
                        returnAssertions.add(assertion);
                    }
                    
                }
                
            }
            
        }
         catch (Exception e) {
            if (debug.messageEnabled()) {
                debug.message("SAMLUtils.getListOfAssertions : " + "Exception : ", e);
            }
            
        }
        
        return returnAssertions;
    }
    
    public static byte[] getResponseBytes(Response samlResponse) throws SAMLException {
        byte ret[] = null;
        try {
            ret = samlResponse.toString(true, true, true). getBytes(SAMLConstants.DEFAULT_ENCODING);
        }
         catch (UnsupportedEncodingException ue) {
            if (debug.messageEnabled()) {
                debug.message("getResponseBytes : " , ue);
            }
            
            throw new SAMLException(ue.getMessage());
        }
        
        return ret;
    }
    
    public static Response getResponse(byte [] bytes) {
        Response temp = null;
        if (bytes == null) {
            return null;
        }
        
        try {
            temp = Response.parseXML(new ByteArrayInputStream(bytes));
        }
         catch (SAMLException se) {
            debug.error("getResponse : " , se);
        }
        
        return temp;
    }
    
    public static boolean verifyResponse(Response response, String requestUrl, HttpServletRequest request) {
        if (!response.isSignatureValid()) {
            debug.message("verifyResponse: Response's signature is invalid.");
            return false;
        }
        
        String recipient = response.getRecipient();
        if ((recipient == null) || (recipient.length() == 0) || ((!equalURL(recipient, requestUrl)) && (!equalURL(recipient,getLBURL(requestUrl, request))))) {
            debug.error("verifyResponse : Incorrect Recipient.");
            return false;
        }
        
        if (!response.getStatus().getStatusCode().getValue().endsWith( SAMLConstants.STATUS_CODE_SUCCESS_NO_PREFIX)) {
            debug.error("verifyResponse : Incorrect StatusCode value.");
            return false;
        }
        
        return true;
    }
    
    private static String getLBURL(String requestUrl, HttpServletRequest request) {
        String host = request.getHeader("host");
        if (host == null) {
            return requestUrl;
        }
        
        int index = requestUrl.indexOf("//");
        if (index == -1) {
            return requestUrl;
        }
        
        StringBuffer sb = new StringBuffer(200);
        sb.append(requestUrl.substring(0, index + 2)).append(host);
        String rest = requestUrl.substring(index +2, requestUrl.length());
        if ((index = rest.indexOf("/")) != -1) {
            sb.append(rest.substring(index, rest.length()));
        }
        
        if (debug.messageEnabled()) {
            debug.message("getLBURL: LBURL = " + sb.toString());
        }
        
        return sb.toString().trim();
    }
    
    public static List getStrAssertions(List assertions) {
        List returnAssertions = new ArrayList();
        if (assertions != null) {
            Iterator it = assertions.iterator();
            while (it.hasNext()) {
                returnAssertions.add( ((Assertion)(it.next())).toString(true,true));
            }
            
        }
        
        return returnAssertions;
    }
    
    public static boolean verifySignature(Response samlResponse) {
        if ((samlResponse != null) && (!samlResponse.isSigned() || (!samlResponse.isSignatureValid()))) {
            return false;
        }
        
        return true;
    }
    
    public static Map getAttributeMap( SAMLServiceManager.SOAPEntry partnerdest, List assertions, com.sun.identity.saml.assertion.Subject subject, String target) throws Exception {
        String srcID = partnerdest.getSourceID();
        String name = null;
        String org = null;
        Map attrMap = new HashMap();
        PartnerAccountMapper paMapper = partnerdest.getPartnerAccountMapper();
        if (paMapper != null) {
            Map map = paMapper.getUser(assertions, srcID, target);
            name = (String) map.get(PartnerAccountMapper.NAME);
            org =  (String) map.get(PartnerAccountMapper.ORG);
            attrMap = (Map) map.get(PartnerAccountMapper.ATTRIBUTE);
        }
        
        if (attrMap == null) {
            attrMap = new HashMap();
        }
        
        attrMap.put(SAMLConstants.USER_NAME, name);
        if ((org != null) && (org.length() != 0)) {
            attrMap.put(SessionProvider.REALM, org);
        }
         else {
            attrMap.put(SessionProvider.REALM, "/");
        }
        
        if (debug.messageEnabled()) {
            debug.message("getAttributeMap : " + "name = " + name + ", realm=" + org + ", attrMap = " + attrMap);
        }
        
        return attrMap;
    }
    
    public static Map verifyAssertionAndGetSSMap(Response response) {
        com.sun.identity.saml.assertion.Subject subject = null;
        SAMLServiceManager.SOAPEntry srcSite = null;
        List assertions = response.getAssertion();
        Iterator iter = assertions.iterator();
        Assertion assertion = null;
        String aIDString = null;
        String issuer = null;
        Iterator stmtIter = null;
        Statement statement = null;
        int stmtType = Statement.NOT_SUPPORTED;
        com.sun.identity.saml.assertion.Subject sub = null;
        SubjectConfirmation subConf = null;
        Set confMethods = null;
        String confMethod = null;
        Date date = null;
        while (iter.hasNext()) {
            assertion = (Assertion) iter.next();
            aIDString = assertion.getAssertionID();
            if (idTimeMap.containsKey(aIDString)) {
                debug.error("verifyAssertion " + "AndGetSSMap: Assertion: " + aIDString + " is used.");
                return null;
            }
            
            issuer = assertion.getIssuer();
            if ((srcSite = SAMLUtils.getSourceSite(issuer)) == null) {
                debug.error("verifyAsserti " + "onAndGetSSMap: issuer is not on the Partner list.");
                return null;
            }
            
            if (!assertion.isSignatureValid()) {
                debug.error("verifyAssertion " + "AndGetSSMap: assertion's signature is not valid.");
                return null;
            }
            
            if (!assertion.isTimeValid()) {
                debug.error("verifyAssertion " + "AndGetSSMap: assertion's time is not valid.");
                return null;
            }
            
            stmtIter = assertion.getStatement().iterator();
            while (stmtIter.hasNext()) {
                statement = (Statement) stmtIter.next();
                stmtType = statement.getStatementType();
                if ((stmtType == Statement.AUTHENTICATION_STATEMENT) || (stmtType == Statement.ATTRIBUTE_STATEMENT) || (stmtType == Statement.AUTHORIZATION_DECISION_STATEMENT)) {
                    sub = ((SubjectStatement)statement).getSubject();
                    if (((subConf = sub.getSubjectConfirmation()) == null) || ((confMethods = subConf.getConfirmationMethod()) == null) || (confMethods.size() != 1)) {
                        debug.error("verify " + "AssertionAndGetSSMap: missing or extra " + "ConfirmationMethod.");
                        return null;
                    }
                    
                    if (((confMethod = (String) confMethods.iterator().next()) == null) || (!confMethod.equals( SAMLConstants.CONFIRMATION_METHOD_BEARER))) {
                        debug.error("verify " + "AssertionAndGetSSMap:wrong ConfirmationMethod.");
                        return null;
                    }
                    
                    if (stmtType == Statement.AUTHENTICATION_STATEMENT) {
                        if (subject == null) {
                            subject = sub;
                        }
                        
                    }
                    
                }
                
            }
            
            if (debug.messageEnabled()) {
                debug.message("Adding " + aIDString + " to idTimeMap.");
            }
            
            Conditions conds = assertion.getConditions();
            if ((conds != null) && ((date = conds.getNotOnorAfter()) != null)) {
                cGoThrough.addElement(aIDString);
                idTimeMap.put(aIDString, new Long(date.getTime()));
            }
             else {
                cPeriodic.addElement(aIDString);
                idTimeMap.put(aIDString, aIDString);
            }
            
        }
        
        if ((subject == null) || (srcSite == null)) {
            debug.error("verifyAssertion AndGetSSMap: couldn't find Subject.");
            return null;
        }
        
        Map ssMap = new HashMap();
        ssMap.put(SAMLConstants.SUBJECT, subject);
        ssMap.put(SAMLConstants.SOURCE_SITE_SOAP_ENTRY, srcSite);
        ssMap.put(SAMLConstants.POST_ASSERTION, assertions);
        return ssMap;
    }
    
    private static boolean checkCondition(Assertion assertion) throws IOException {
        if (assertion == null) {
            return false;
        }
        
        if (!assertion.isSignatureValid()) {
            debug.error(bundle.getString("assertionSignatureNotValid"));
            return false;
        }
        
        if (!(assertion.isTimeValid())) {
            debug.error(bundle.getString("assertionTimeNotValid"));
            return false;
        }
        
        Conditions cnds = assertion.getConditions();
        Set audienceCnd = new HashSet();
        audienceCnd = cnds.getAudienceRestrictionCondition();
        Iterator it = null;
        if (audienceCnd != null) {
            if (!audienceCnd.isEmpty()) {
                it = audienceCnd.iterator();
                while (it.hasNext()) {
                    if ((((AudienceRestrictionCondition) it.next()). evaluate()) == Condition.INDETERMINATE ) {
                        if (debug.messageEnabled()) {
                            debug.message("Audience " + "RestrictionConditions is indeterminate.");
                        }
                        
                    }
                     else {
                        debug.error("Failed AudienceRestrictionCondition");
                        return false;
                    }
                    
                }
                
            }
            
        }
        
        return true;
    }
    
    public static com.sun.identity.saml.assertion.Subject examAssertions( List assertions) throws IOException {
        if (assertions == null) {
            return null;
        }
        
        boolean validation = false;
        com.sun.identity.saml.assertion.Subject subject = null;
        Iterator iter = assertions.iterator();
        while (iter.hasNext()) {
            Assertion assertion = (Assertion)iter.next();
            if (!checkCondition(assertion)) {
                return null;
            }
            
            debug.message("Passed checking Conditions!");
            Set statements = new HashSet();
            statements = assertion.getStatement();
            if (statements == null || statements.isEmpty()) {
                debug.error(bundle.getString("noStatement"));
                return null;
            }
            
            Iterator iterator = statements.iterator();
            while (iterator.hasNext()) {
                Statement statement = (Statement) iterator.next();
                subject = ((SubjectStatement)statement).getSubject();
                SubjectConfirmation sc = subject.getSubjectConfirmation();
                Set cm = new HashSet();
                cm =  sc.getConfirmationMethod();
                if (cm == null || cm.isEmpty()) {
                    debug.error("Subject confirmation method is null");
                    return null;
                }
                
                String conMethod = (String) cm.iterator().next();
                if ((conMethod != null) && (assertion.getMajorVersion() == SAMLConstants.ASSERTION_MAJOR_VERSION) && (((assertion.getMinorVersion() == SAMLConstants.ASSERTION_MINOR_VERSION_ONE) && conMethod.equals(SAMLConstants.CONFIRMATION_METHOD_ARTIFACT)) || ((assertion.getMinorVersion() == SAMLConstants.ASSERTION_MINOR_VERSION_ZERO) && (conMethod.equals( SAMLConstants.DEPRECATED_CONFIRMATION_METHOD_ARTIFACT))))) {
                    if (debug.messageEnabled()) {
                        debug.message("Correct Confirmation method");
                    }
                    
                }
                 else {
                    debug.error("Wrong Confirmation Method.");
                    return null;
                }
                
                if (statement instanceof AuthenticationStatement) {
                    validation = true;
                }
                
            }
              
        }
         
        if (!validation) {
            debug.error(bundle.getString("noSSOAssertion"));
            return null;
        }
        
        return subject;
    }
    
    public static boolean checkSignatureValid(String xmlString,  String idAttribute,  String issuer) {
            String certAlias = null;
            boolean valid = true; 
            Map entries = (Map) SAMLServiceManager.getAttribute( SAMLConstants.PARTNER_URLS);
        if (entries != null) {
            SAMLServiceManager.SOAPEntry srcSite = (SAMLServiceManager.SOAPEntry) entries.get(issuer);
            if (srcSite != null) {
                certAlias = srcSite.getCertAlias();
            }
            
        }
        
        try {
            SAMLUtils.debug.message("SAMLUtils.checkSignatureValid for certAlias {}", certAlias);
            XMLSignatureManager manager = XMLSignatureManager.getInstance();
            valid = manager.verifyXMLSignature(xmlString,  idAttribute, certAlias);
        }
         catch (Exception e) {
            SAMLUtils.debug.warning("SAMLUtils.checkSignatureValid:"+ " signature validation exception", e);
            valid = false;
        }
        
        if (!valid) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message("SAMLUtils.checkSignatureValid:"+ " Couldn't verify signature.");
            }
            
        }
        
        return valid;
    }
    
    public static void setMimeHeaders( MimeHeaders headers, HttpServletResponse response) {
         if(headers == null || response == null) {
            debug.message("SAMLUtils.setMimeHeaders : null input");
            return;
         }
         
         for (Iterator iter = headers.getAllHeaders(); iter.hasNext();){
              MimeHeader header = (MimeHeader)iter.next();
              String[] values = headers.getHeader(header.getName());
              if (values.length == 1) {
                  response.setHeader(header.getName(), header.getValue());
              }
               else {
                  StringBuffer concat = new StringBuffer();
                  int i = 0;
                  while (i < values.length) {
                      if (i != 0) {
                          concat.append(',');
                      }
                      
                      concat.append(values[i++]);
                   }
                   
                   response.setHeader(header.getName(),concat.toString());
              }
              
         }
         
         return; 
    }
    
    public static MimeHeaders getMimeHeaders(HttpServletRequest req) {
         MimeHeaders headers = new MimeHeaders();
         if(req == null) {
            debug.message("SAMLUtils.getMimeHeaders: null input");
            return headers;
         }
         
         Enumeration enumerator = req.getHeaderNames();
         while(enumerator.hasMoreElements()) {
             String headerName = (String)enumerator.nextElement();
             String headerValue = req.getHeader(headerName);
             StringTokenizer values = new StringTokenizer(headerValue, ",");
             while(values.hasMoreTokens()) {
                 headers.addHeader(headerName, values.nextToken().trim());
             }
             
         }
         
         return headers; 
    }
    
    public static String getLoginRedirectURL(HttpServletRequest req) {
        String qs = req.getQueryString();
        String gotoUrl = req.getRequestURL().toString();
        String key = null; 
        if (qs != null && qs.length() > 0) {
            gotoUrl = gotoUrl + "?" + qs;
            int startIdx = -1;
            int endIdx = -1; 
            StringBuffer result = new StringBuffer(); 
            if ((startIdx = qs.indexOf((String) SAMLServiceManager. getAttribute(SAMLConstants.TARGET_SPECIFIER))) > 0) {
                result.append(qs.substring(0, startIdx - 1)); 
            }
                
            if ((endIdx = qs.indexOf("&", startIdx)) != -1) {
                if (startIdx == 0) {
                    result.append(qs.substring(endIdx + 1)); 
                }
                 else {
                    result.append(qs.substring(endIdx));
                }
                    
            }
             
            key = result.toString();
        }
        
        String reqUrl = req.getScheme() + "://" + req.getServerName() + ":" + req.getServerPort() + req.getContextPath();
        String redirectUrl = null;
        if (key == null || key.equals("")) {
            redirectUrl = reqUrl +"/UI/Login?goto=" +   URLEncDec.encode(gotoUrl);
        }
         else {
            redirectUrl = reqUrl +"/UI/Login?" + key + "&goto="+  URLEncDec.encode(gotoUrl);
        }
        
        if (SAMLUtils.debug.messageEnabled()) {
            SAMLUtils.debug.message("Redirect to auth login via:" + redirectUrl);
        }
            
        return redirectUrl; 
    }
        
    public static Map processArtifact(String[] artifact, String target)  throws SAMLException {
        List assts = null;  
        Subject assertionSubject = null; 
        AssertionArtifact firstArtifact = null;  
        Map sessMap = null; 
        try {
            assts = SAMLClient.artifactQueryHandler(artifact, (String) null);
            if ((assertionSubject = examAssertions(assts)) == null) {
                return null; 
            }
            
            firstArtifact = new AssertionArtifact(artifact[0]);
            String sid = firstArtifact.getSourceID();
            Map partner = (Map) SAMLServiceManager.getAttribute( SAMLConstants.PARTNER_URLS);
            if (partner == null) {
                throw new SAMLException(bundle.getString ("nullPartnerUrl"));
            }
            
            SAMLServiceManager.SOAPEntry partnerdest =  (SAMLServiceManager.SOAPEntry) partner.get(sid);
            if (partnerdest == null) {
                throw new SAMLException(bundle.getString ("failedAccountMapping"));
            }
            
            sessMap = getAttributeMap(partnerdest, assts, assertionSubject, target); 
        }
         catch (Exception se) {
            debug.error("SAMLUtils.processArtifact :" , se);
            throw new SAMLException( bundle.getString("failProcessArtifact"));
        }
            
        return sessMap;   
    }
    
    public static Object generateSession(HttpServletRequest request, HttpServletResponse response,  Map attrMap) throws SAMLException {  
        Map sessionInfoMap = new HashMap();
        String realm = (String) attrMap.get(SessionProvider.REALM);
        if ((realm == null) || (realm.length() == 0)) {
            realm = "/";
        }
         
        sessionInfoMap.put(SessionProvider.REALM, realm);
        String principalName =  (String) attrMap.get(SessionProvider.PRINCIPAL_NAME);
        if (principalName == null) {
            principalName = (String) attrMap.get(SAMLConstants.USER_NAME);
        }
        
        sessionInfoMap.put(SessionProvider.PRINCIPAL_NAME, principalName);
        Object session = null;  
        try {  
            SessionProvider sessionProvider = SessionManager.getProvider();
            session = sessionProvider.createSession( sessionInfoMap, request, response, null);
            setAttrMapInSession(sessionProvider, attrMap, session);
        }
         catch (SessionException se) {
            if (debug.messageEnabled()) {
                debug.message("SAMLUtils.generateSession:", se);
            }
            
            throw new SAMLException(se);
        }
        
        return session;
    }
    
    public static Map processResponse(Response samlResponse, String target)  throws SAMLException {
        List assertions = null;    
        SAMLServiceManager.SOAPEntry partnerdest = null;
        Subject assertionSubject = null;
        if (samlResponse.isSigned()) {
            boolean isSignedandValid = verifySignature(samlResponse);
            if (!isSignedandValid) {
                throw new SAMLException(bundle.getString("invalidResponse"));
            }
            
        }
        
        Map ssMap = verifyAssertionAndGetSSMap(samlResponse);
        if (debug.messageEnabled()) {
            debug.message("processResponse: ssMap = " + ssMap);
        }
        
        if (ssMap == null) {
            throw new SAMLException(bundle.getString("invalidAssertion"));
        }
        
        assertionSubject = (com.sun.identity.saml.assertion.Subject) ssMap.get(SAMLConstants.SUBJECT);
        if (assertionSubject == null) {
            throw new SAMLException(bundle.getString("nullSubject"));
        }
        
        partnerdest = (SAMLServiceManager.SOAPEntry)ssMap .get(SAMLConstants.SOURCE_SITE_SOAP_ENTRY);
        if (partnerdest == null) {
            throw new SAMLException(bundle.getString("failedAccountMapping"));
        }
        
        assertions = (List)ssMap.get(SAMLConstants.POST_ASSERTION);
        Map sessMap = null;
        try { 
            sessMap = getAttributeMap(partnerdest, assertions, assertionSubject, target); 
        }
         catch (Exception se) {
            debug.error("SAMLUtils.processResponse :" , se);
            throw new SAMLException( bundle.getString("failProcessResponse"));
        }
        
        return sessMap;
    }
    
    private static void setAttrMapInSession( SessionProvider sessionProvider, Map attrMap, Object session) throws SessionException {
        if (attrMap != null && !attrMap.isEmpty()) {
            Set entrySet = attrMap.entrySet();
            for(Iterator iter = entrySet.iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry)iter.next();
                String attrName = (String)entry.getKey();
                String[] attrValues = null;
                if (attrName.equals(SAMLConstants.USER_NAME) || attrName.equals(SessionProvider.PRINCIPAL_NAME)) {
                    String attrValue = (String)entry.getValue();
                    attrValues = new String[1];
                    attrValues[0] = attrValue;
                }
                 else if (attrName.equals(SessionProvider.REALM) || attrName.equals(SessionProvider.AUTH_LEVEL)) {
                    continue; 
                }
                 else {
                    attrValues = (String[])entry.getValue();
                }
                
                sessionProvider.setProperty(session, attrName, attrValues);
                if (debug.messageEnabled()) {
                    debug.message("SAMLUtils.setAttrMapInSessioin: attrName ="+ attrName);
                }
                
            }
            
        }
         
    }
    
    private static boolean equalURL(String url1, String url2) {
        try {
            URL u1 = new URL(url1);
            URL u2 = new URL(url2);
            int port1 = u1.getPort();
            if (port1 == -1) {
                port1 = u1.getDefaultPort();
            }
            
            int port2 = u2.getPort();
            if (port2 == -1) {
                port2 = u2.getDefaultPort();
            }
            
            if ((u1.getProtocol().equalsIgnoreCase(u2.getProtocol())) && (u1.getHost().equalsIgnoreCase(u2.getHost())) && (port1 == port2) && (u1.getPath().equalsIgnoreCase(u2.getPath()))) {
                return true;
            }
             else {
                return false;
            }
            
        }
         catch (MalformedURLException m) {
            debug.message("Error in SAMLUtils.equalURL", m);
            return false;
        }
        
    }
    
      public static Element getCanonicalElement(Node node) {
          try {
              Canonicalizer c14n = Canonicalizer.getInstance( "http://www.w3.org/TR/2001/REC-xml-c14n-20010315");
              byte outputBytes[] = c14n.canonicalizeSubtree(node);
              DocumentBuilder documentBuilder =  XMLUtils.getSafeDocumentBuilder(false);
              Document doc = documentBuilder.parse( new ByteArrayInputStream(outputBytes));
              Element result = doc.getDocumentElement();
              return result;
          }
           catch (Exception e) {
              SAMLUtils.debug.error("Response:getCanonicalElement: " + "Error while performing canonicalization on " + "the input Node.");
              return null;
          }
          
      }
      
     public static void sendError(HttpServletRequest request, HttpServletResponse response, int httpStatusCode, String errorCode, String errorMsg) {
                 String errorUrl = SystemConfigurationUtil.getProperty( SAMLConstants.ERROR_PAGE_URL, SAMLConstants.DEFAULT_ERROR_PAGE_URL);
         if(debug.messageEnabled()) {
            debug.message("SAMLUtils.sendError: error page" + errorUrl);
         }
         
         String tmp = errorUrl.toLowerCase();
         if (!tmp.startsWith("http://") && !tmp.startsWith("https://")) {
             String jointString = "?";
             if (errorUrl.indexOf("?") != -1) {
                 jointString = "&";
             }
             
             String newUrl = errorUrl.trim() + jointString + SAMLConstants.ERROR_CODE + "=" + errorCode + "&" + SAMLConstants.HTTP_STATUS_CODE + "=" + httpStatusCode + "&" + SAMLConstants.ERROR_MESSAGE + "=" + URLEncDec.encode(errorMsg);
             forwardRequest(newUrl, request, response);
         }
          else {
           String binding = SystemConfigurationUtil.getProperty( SAMLConstants.ERROR_PAGE_HTTP_BINDING, SAMLConstants.HTTP_POST);
           if(SAMLConstants.HTTP_REDIRECT.equals(binding)) {
              String jointString = "?";
              if (errorUrl.indexOf("?") != -1) {
                  jointString = "&";
              }
              
              String newUrl = errorUrl.trim() + jointString + SAMLConstants.ERROR_CODE + "=" + errorCode + "&" + SAMLConstants.HTTP_STATUS_CODE + "=" + httpStatusCode + "&" + SAMLConstants.ERROR_MESSAGE + "=" + URLEncDec.encode(errorMsg);
              FSUtils.forwardRequest(request, response, newUrl) ;
           }
            else {
               request.setAttribute("ERROR_URL", errorUrl);
               request.setAttribute("ERROR_CODE_NAME", SAMLConstants.ERROR_CODE);
               request.setAttribute("ERROR_CODE", errorCode);
               request.setAttribute("ERROR_MESSAGE_NAME", SAMLConstants.ERROR_MESSAGE);
               request.setAttribute("ERROR_MESSAGE", URLEncDec.encode(errorMsg));
               request.setAttribute("HTTP_STATUS_CODE_NAME", SAMLConstants.HTTP_STATUS_CODE);
               request.setAttribute("HTTP_STATUS_CODE", httpStatusCode);
               request.setAttribute("SAML_ERROR_KEY", bundle.getString("samlErrorKey"));
               forwardRequest(ERROR_JSP, request, response);
           }
           
         }
         
     }
     
    private static void forwardRequest(String url, HttpServletRequest request, HttpServletResponse response) {
        try {
            request.getRequestDispatcher(url).forward(request, response);
        }
         catch (ServletException sE) {
            handleForwardError(url, sE, response);
        }
         catch (IOException ioE) {
            handleForwardError(url, ioE, response);
        }
        
    }
    
    private static void handleForwardError(String url, Exception exception, HttpServletResponse response) {
        debug.error("SAMLUtils.sendError: Exception occurred while trying to forward to resource: " + url, exception);
        try {
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, exception.getMessage());
        }
         catch (IOException ioE) {
            debug.error("Failed to inform the response of caught exception", ioE);
        }
        
    }
    
}


