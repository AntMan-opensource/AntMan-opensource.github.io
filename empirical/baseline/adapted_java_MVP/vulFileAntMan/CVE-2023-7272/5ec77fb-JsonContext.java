package org.eclipse.parsson;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import jakarta.json.JsonException;
import jakarta.json.stream.JsonGenerator;
import org.eclipse.parsson.api.BufferPool;
import org.eclipse.parsson.api.JsonConfig;
final class JsonContext {
    private static final int DEFAULT_MAX_BIGINTEGER_SCALE = 100000;
    private static final int DEFAULT_MAX_BIGDECIMAL_LEN = 1100;
    static final String PROPERTY_BUFFER_POOL = BufferPool.class.getName();
    private final Map<String, ?> config;
    private final int bigIntegerScaleLimit;
    private final int bigDecimalLengthLimit;
    private final boolean prettyPrinting;
    private final boolean rejectDuplicateKeys;
    private final BufferPool bufferPool;
    JsonContext(Map<String, ?> config, BufferPool defaultPool) {
        this.bigIntegerScaleLimit = getIntConfig(JsonConfig.MAX_BIGINTEGER_SCALE, config, DEFAULT_MAX_BIGINTEGER_SCALE);
        this.bigDecimalLengthLimit = getIntConfig(JsonConfig.MAX_BIGDECIMAL_LEN, config, DEFAULT_MAX_BIGDECIMAL_LEN);
        this.prettyPrinting = getBooleanConfig(JsonGenerator.PRETTY_PRINTING, config);
        this.rejectDuplicateKeys = getBooleanConfig(JsonConfig.REJECT_DUPLICATE_KEYS, config);
        this.bufferPool = getBufferPool(config, defaultPool);
        this.config = config != null ? Collections.unmodifiableMap(config) : null;
    }
    
    JsonContext(Map<String, ?> config, BufferPool defaultPool, String... properties) {
        this.bigIntegerScaleLimit = getIntConfig(JsonConfig.MAX_BIGINTEGER_SCALE, config, DEFAULT_MAX_BIGINTEGER_SCALE);
        this.bigDecimalLengthLimit = getIntConfig(JsonConfig.MAX_BIGDECIMAL_LEN, config, DEFAULT_MAX_BIGDECIMAL_LEN);
        this.prettyPrinting = getBooleanConfig(JsonGenerator.PRETTY_PRINTING, config);
        this.rejectDuplicateKeys = getBooleanConfig(JsonConfig.REJECT_DUPLICATE_KEYS, config);
        this.bufferPool = getBufferPool(config, defaultPool);
        this.config = config != null ? Collections.unmodifiableMap(copyPropertiesMap(this, config, properties)) : null;
    }
    
    Map<String, ?> config() {
        return config;
    }
    
    Object config(String propertyName) {
        return config != null ? config.get(propertyName) : null;
    }
    
    int bigIntegerScaleLimit() {
        return bigIntegerScaleLimit;
    }
    
    int bigDecimalLengthLimit() {
        return bigDecimalLengthLimit;
    }
    
    boolean prettyPrinting() {
        return prettyPrinting;
    }
    
    boolean rejectDuplicateKeys() {
        return rejectDuplicateKeys;
    }
    
    BufferPool bufferPool() {
        return bufferPool;
    }
    
    private static BufferPool getBufferPool(Map<String, ?> config, BufferPool defaultrPool) {
        BufferPool pool = config != null ? (BufferPool)config.get(PROPERTY_BUFFER_POOL) : null;
        return pool != null ? pool : defaultrPool;
    }
    
    private static int getIntConfig(String propertyName, Map<String, ?> config, int defaultValue) throws JsonException {
        Integer intConfig = config != null ? getIntProperty(propertyName, config) : null;
        if (intConfig != null) {
            return intConfig;
        }
        
        intConfig = getIntSystemProperty(propertyName);
        return intConfig != null ? intConfig : defaultValue;
    }
    
    private static boolean getBooleanConfig(String propertyName, Map<String, ?> config) throws JsonException {
        Boolean booleanConfig = config != null ? getBooleanProperty(propertyName, config) : null;
        if (booleanConfig != null) {
            return booleanConfig;
        }
        
        return getBooleanSystemProperty(propertyName);
    }
    
    private static Integer getIntProperty(String propertyName, Map<String, ?> config) throws JsonException {
        Object property = config.get(propertyName);
        if (property == null) {
            return null;
        }
        
        if (property instanceof Number) {
            return ((Number) property).intValue();
        }
        
        if (property instanceof String) {
            return propertyStringToInt(propertyName, (String) property);
        }
        
        throw new JsonException( String.format("Could not convert %s property of type %s to Integer", propertyName, property.getClass().getName()));
    }
    
    private static Boolean getBooleanProperty(String propertyName, Map<String, ?> config) throws JsonException {
        return config.containsKey(propertyName) ? true : null;
    }
    
    private static Integer getIntSystemProperty(String propertyName) throws JsonException {
        String systemProperty = getSystemProperty(propertyName);
        if (systemProperty == null) {
            return null;
        }
        
        return propertyStringToInt(propertyName, systemProperty);
    }
    
    private static boolean getBooleanSystemProperty(String propertyName) throws JsonException {
        return getSystemProperty(propertyName) != null;
    }
    
    private static String getSystemProperty(String propertyName) throws JsonException {
        if (System.getSecurityManager() != null) {
            return AccessController.doPrivileged( (PrivilegedAction<String>) () -> System.getProperty(propertyName));
        }
         else {
            return System.getProperty(propertyName);
        }
        
    }
    
    private static int propertyStringToInt(String propertyName, String propertyValue) throws JsonException {
        try {
            return Integer.parseInt(propertyValue);
        }
         catch (NumberFormatException ex) {
            throw new JsonException( String.format("Value of %s property is not a number", propertyName), ex);
        }
        
    }
    
    private static Map<String, ?> copyPropertiesMap(JsonContext instance, Map<String, ?> config, String... properties) {
        Objects.requireNonNull(config, "Map of provider specific properties is null");
        if (properties == null || properties.length == 0) {
            return Collections.emptyMap();
        }
        
        Map<String, Object> newConfig = new HashMap<>(properties.length);
        for (String propertyName : properties) {
            switch (propertyName) {
                case JsonGenerator.PRETTY_PRINTING:
                    if (instance.prettyPrinting) {
                        newConfig.put(JsonGenerator.PRETTY_PRINTING, true);
                    }
                    
                    break;
                case JsonConfig.REJECT_DUPLICATE_KEYS:
                    if (instance.rejectDuplicateKeys) {
                        newConfig.put(JsonConfig.REJECT_DUPLICATE_KEYS, true);
                    }
                    
                default: if (config.containsKey(propertyName)) {
                        newConfig.put(propertyName, config.get(propertyName));
                    }
                    
            }
            
        }
        
        return newConfig;
    }
    
}


