package org.apache.geode.distributed;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.lang3.StringUtils.join;
import static org.apache.commons.lang3.StringUtils.lowerCase;
import static org.apache.geode.distributed.ConfigurationProperties.NAME;
import static org.apache.geode.internal.lang.ClassUtils.forName;
import static org.apache.geode.internal.lang.StringUtils.defaultString;
import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.net.BindException;
import java.net.InetAddress;
import java.net.URISyntaxException;
import java.net.URL;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Logger;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.geode.annotations.Immutable;
import org.apache.geode.distributed.internal.InternalDistributedSystem;
import org.apache.geode.distributed.internal.unsafe.RegisterSignalHandlerSupport;
import org.apache.geode.internal.GemFireVersion;
import org.apache.geode.internal.membership.utils.AvailablePort;
import org.apache.geode.internal.process.PidUnavailableException;
import org.apache.geode.internal.process.ProcessUtils;
import org.apache.geode.internal.util.ArgumentRedactor;
import org.apache.geode.internal.util.SunAPINotFoundException;
import org.apache.geode.logging.internal.OSProcess;
import org.apache.geode.util.internal.GeodeGlossary;
public abstract class AbstractLauncher<T extends Comparable<T>> implements Runnable {
  public static final String MEMBER_NAME_ERROR_MESSAGE = "The member name of the %s must be provided as an argument to the launcher, or a path to gemfire.properties must be specified, which assumes the %s member name will be set using the name property.";
  public static final String WORKING_DIRECTORY_OPTION_NOT_VALID_ERROR_MESSAGE = "Specifying the --dir option is not valid when starting a %s with the %sLauncher.";
  public static final String WORKING_DIRECTORY_NOT_FOUND_ERROR_MESSAGE = "The working directory for the %s could not be found.";
  protected static final Boolean DEFAULT_FORCE = Boolean.FALSE;
  protected static final long READ_PID_FILE_TIMEOUT_MILLIS = 2 * 1000;
  public static final String DEFAULT_WORKING_DIRECTORY = CURRENT_DIRECTORY;
  public static final String SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY = GeodeGlossary.GEMFIRE_PREFIX + "launcher.registerSignalHandlers";
  protected static final String OPTION_PREFIX = "-";
  private static final String SUN_SIGNAL_API_CLASS_NAME = "sun.misc.Signal";
  private volatile boolean debug;
  protected final transient AtomicBoolean running = new AtomicBoolean(false);
  protected Logger logger = Logger.getLogger(getClass().getName());
  public AbstractLauncher() {
    try {
      if (Boolean.getBoolean(SIGNAL_HANDLER_REGISTRATION_SYSTEM_PROPERTY)) {
        forName(SUN_SIGNAL_API_CLASS_NAME, new SunAPINotFoundException( "WARNING!!! Not running a Sun JVM.  Could not find the sun.misc.Signal class; Signal handling disabled."));
        RegisterSignalHandlerSupport.registerSignalHandlers();
      }
      
    }
     catch (SunAPINotFoundException handled) {
      info(handled.getMessage());
    }
    
  }
  
  protected static void assertPortAvailable(final int port) throws BindException {
    assertPortAvailable(null, port);
  }
  
  protected static void assertPortAvailable(final InetAddress bindAddress, final int port) throws BindException {
    if (!AvailablePort.isPortAvailable(port, AvailablePort.SOCKET, bindAddress)) {
      throw new BindException( String.format("Network is unreachable; port (%1$d) is not available on %2$s.", port, bindAddress != null ? bindAddress.getCanonicalHostName() : "localhost"));
    }
    
  }
  
  protected static boolean isSet(final Properties properties, final String propertyName) {
    return isNotBlank(properties.getProperty(propertyName));
  }
  
  protected static Properties loadGemFireProperties(final URL url) {
    if (url == null) {
      return new Properties();
    }
    
    Properties properties = new Properties();
    try (FileReader reader = new FileReader(new File(url.toURI()))) {
      properties.load(reader);
    }
     catch (IOException | URISyntaxException handled) {
      loadGemFirePropertiesFromClassPath(properties);
    }
    
    return properties;
  }
  
  private static void loadGemFirePropertiesFromClassPath(Properties properties) {
    try {
      properties .load(AbstractLauncher.class.getResourceAsStream(DistributedSystem.getPropertiesFile()));
    }
     catch (IOException | NullPointerException handled) {
    }
    
  }
  
  public boolean isDebugging() {
    return this.debug;
  }
  
  public void setDebug(final boolean debug) {
    this.debug = debug;
  }
  
  public boolean isRunning() {
    return this.running.get();
  }
  
  protected Properties getDistributedSystemProperties() {
    return getDistributedSystemProperties(null);
  }
  
  protected Properties getDistributedSystemProperties(final Properties defaults) {
    final Properties distributedSystemProperties = new Properties();
    if (defaults != null) {
      distributedSystemProperties.putAll(defaults);
    }
    
    if (isNotBlank(getMemberName())) {
      distributedSystemProperties.setProperty(NAME, getMemberName());
    }
    
    return distributedSystemProperties;
  }
  
  protected File getLogFile() {
    return new File(getWorkingDirectory(), getLogFileName());
  }
  
  protected String getLogFileCanonicalPath() {
    try {
      return getLogFile().getCanonicalPath();
    }
     catch (IOException handled) {
      return getLogFileName();
    }
    
  }
  
  public abstract String getLogFileName();
  public String getMember() {
    if (isNotBlank(getMemberName())) {
      return getMemberName();
    }
    
    if (isNotBlank(getMemberId())) {
      return getMemberId();
    }
    
    return null;
  }
  
  public String getMemberId() {
    final InternalDistributedSystem distributedSystem = InternalDistributedSystem.getConnectedInstance();
    return distributedSystem != null ? distributedSystem.getMemberId() : null;
  }
  
  public String getMemberName() {
    final InternalDistributedSystem distributedSystem = InternalDistributedSystem.getConnectedInstance();
    return distributedSystem != null ? distributedSystem.getConfig().getName() : null;
  }
  
  public abstract Integer getPid();
  public abstract String getServiceName();
  public String getWorkingDirectory() {
    return DEFAULT_WORKING_DIRECTORY;
  }
  
  protected void debug(final String message, final Object... args) {
    if (isDebugging()) {
      if (args != null && args.length > 0) {
        System.err.printf(message, args);
      }
       else {
        System.err.print(message);
      }
      
    }
    
  }
  
  protected void debug(final Throwable t) {
    if (isDebugging()) {
      t.printStackTrace(System.err);
    }
    
  }
  
  protected void info(final Object message, final Object... args) {
    if (args != null && args.length > 0) {
      System.err.printf(message.toString(), args);
    }
     else {
      System.err.print(message);
    }
    
  }
  
  protected void redirectOutput(final DistributedSystem distributedSystem) throws IOException {
    if (distributedSystem instanceof InternalDistributedSystem) {
      OSProcess .redirectOutput(((InternalDistributedSystem) distributedSystem).getConfig().getLogFile());
    }
    
  }
  
  public String version() {
    return GemFireVersion.getGemFireVersion();
  }
  
  int identifyPid() throws PidUnavailableException {
    return ProcessUtils.identifyPid();
  }
  
  int identifyPidOrNot() {
    try {
      return identifyPid();
    }
     catch (PidUnavailableException handled) {
      return -1;
    }
    
  }
  
  boolean isPidInProcess() {
    Integer pid = getPid();
    return pid != null && pid == identifyPidOrNot();
  }
  
  public abstract static class ServiceState<T extends Comparable<T>> {
    protected static final String JSON_CLASSPATH = "classpath";
    protected static final String JSON_GEMFIREVERSION = "gemFireVersion";
    protected static final String JSON_HOST = "bindAddress";
    protected static final String JSON_JAVAVERSION = "javaVersion";
    protected static final String JSON_JVMARGUMENTS = "jvmArguments";
    protected static final String JSON_LOCATION = "location";
    protected static final String JSON_LOGFILE = "logFileName";
    protected static final String JSON_MEMBERNAME = "memberName";
    protected static final String JSON_PID = "pid";
    protected static final String JSON_PORT = "port";
    protected static final String JSON_STATUS = "status";
    protected static final String JSON_STATUSMESSAGE = "statusMessage";
    protected static final String JSON_TIMESTAMP = "timestamp";
    protected static final String JSON_UPTIME = "uptime";
    protected static final String JSON_WORKINGDIRECTORY = "workingDirectory";
    static final String TO_STRING_PROCESS_ID = "Process ID: ";
    static final String TO_STRING_JAVA_VERSION = "Java Version: ";
    static final String TO_STRING_LOG_FILE = "Log File: ";
    static final String TO_STRING_JVM_ARGUMENTS = "JVM Arguments: ";
    static final String TO_STRING_CLASS_PATH = "Class-Path: ";
    static final String TO_STRING_UPTIME = "Uptime: ";
    static final String TO_STRING_GEODE_VERSION = "Geode Version: ";
    private static final String DATE_TIME_FORMAT_PATTERN = "MM/dd/yyyy hh:mm a";
    private final Integer pid;
    private final List<String> jvmArguments;
    private final Long uptime;
    private final Status status;
    private final String classpath;
    private final String gemfireVersion;
    private final String host;
    private final String javaVersion;
    private final String logFile;
    private final String memberName;
    private final String port;
    private final String serviceLocation;
    private final String statusMessage;
    private final String workingDirectory;
    private final Timestamp timestamp;
    protected static String format(final Date timestamp) {
      return timestamp == null ? "" : new SimpleDateFormat(DATE_TIME_FORMAT_PATTERN).format(timestamp);
    }
    
    protected static Integer identifyPid() {
      try {
        return ProcessUtils.identifyPid();
      }
       catch (PidUnavailableException handled) {
        return null;
      }
      
    }
    
    protected static String toDaysHoursMinutesSeconds(final Long milliseconds) {
      final StringBuilder buffer = new StringBuilder();
      if (milliseconds != null) {
        long millisecondsRemaining = milliseconds;
        final long days = TimeUnit.MILLISECONDS.toDays(millisecondsRemaining);
        millisecondsRemaining -= TimeUnit.DAYS.toMillis(days);
        final long hours = TimeUnit.MILLISECONDS.toHours(millisecondsRemaining);
        millisecondsRemaining -= TimeUnit.HOURS.toMillis(hours);
        final long minutes = TimeUnit.MILLISECONDS.toMinutes(millisecondsRemaining);
        millisecondsRemaining -= TimeUnit.MINUTES.toMillis(minutes);
        final long seconds = TimeUnit.MILLISECONDS.toSeconds(millisecondsRemaining);
        if (days > 0) {
          buffer.append(days).append(days > 1 ? " days " : " day ");
        }
        
        if (hours > 0) {
          buffer.append(hours).append(hours > 1 ? " hours " : " hour ");
        }
        
        if (minutes > 0) {
          buffer.append(minutes).append(minutes > 1 ? " minutes " : " minute ");
        }
        
        buffer.append(seconds).append(seconds == 0 || seconds > 1 ? " seconds" : " second");
      }
      
      return buffer.toString();
    }
    
    protected ServiceState(final Status status, final String statusMessage, final long timestamp, final String serviceLocation, final Integer pid, final Long uptime, final String workingDirectory, final List<String> jvmArguments, final String classpath, final String gemfireVersion, final String javaVersion, final String logFile, final String host, final String port, final String memberName) {
      assert status != null : "The status of the GemFire service cannot be null!";
      this.status = status;
      this.statusMessage = statusMessage;
      this.timestamp = new Timestamp(timestamp);
      this.serviceLocation = serviceLocation;
      this.pid = pid;
      this.uptime = uptime;
      this.workingDirectory = workingDirectory;
      this.jvmArguments = Collections.unmodifiableList(jvmArguments);
      this.classpath = classpath;
      this.gemfireVersion = gemfireVersion;
      this.javaVersion = javaVersion;
      this.logFile = logFile;
      this.host = host;
      this.port = port;
      this.memberName = memberName;
    }
    
    public String toJson() {
      final Map<String, Object> map = new HashMap<>();
      map.put(JSON_CLASSPATH, getClasspath());
      map.put(JSON_GEMFIREVERSION, getGemFireVersion());
      map.put(JSON_HOST, getHost());
      map.put(JSON_JAVAVERSION, getJavaVersion());
      map.put(JSON_JVMARGUMENTS, getJvmArguments());
      map.put(JSON_LOCATION, getServiceLocation());
      map.put(JSON_LOGFILE, getLogFile());
      map.put(JSON_MEMBERNAME, getMemberName());
      map.put(JSON_PID, getPid());
      map.put(JSON_PORT, getPort());
      map.put(JSON_STATUS, getStatus().getDescription());
      map.put(JSON_STATUSMESSAGE, getStatusMessage());
      map.put(JSON_TIMESTAMP, getTimestamp().getTime());
      map.put(JSON_UPTIME, getUptime());
      map.put(JSON_WORKINGDIRECTORY, getWorkingDirectory());
      String jsonStatus = null;
      try {
        jsonStatus = new ObjectMapper().writeValueAsString(map);
      }
       catch (JsonProcessingException e) {
      }
      
      return jsonStatus;
    }
    
    public static boolean isStartingNotRespondingOrNull(final ServiceState serviceState) {
      return serviceState == null || serviceState.isStartingOrNotResponding();
    }
    
    public boolean isStartingOrNotResponding() {
      return Status.NOT_RESPONDING == getStatus() || Status.STARTING == getStatus();
    }
    
    public boolean isVmWithProcessIdRunning() {
      return ProcessUtils.isProcessAlive(this.getPid());
    }
    
    public String getClasspath() {
      return classpath;
    }
    
    public String getGemFireVersion() {
      return gemfireVersion;
    }
    
    public String getJavaVersion() {
      return javaVersion;
    }
    
    public List<String> getJvmArguments() {
      return jvmArguments;
    }
    
    public String getMemberName() {
      return this.memberName;
    }
    
    public Integer getPid() {
      return pid;
    }
    
    public String getServiceLocation() {
      return this.serviceLocation;
    }
    
    protected abstract String getServiceName();
    public Status getStatus() {
      return status;
    }
    
    public String getStatusMessage() {
      return statusMessage;
    }
    
    public Timestamp getTimestamp() {
      return (Timestamp) timestamp.clone();
    }
    
    public Long getUptime() {
      return uptime;
    }
    
    public String getWorkingDirectory() {
      return workingDirectory != null ? workingDirectory : DEFAULT_WORKING_DIRECTORY;
    }
    
    public String getLogFile() {
      return this.logFile;
    }
    
    public String getHost() {
      return this.host;
    }
    
    public String getPort() {
      return this.port;
    }
    
    public String toString() {
      StringBuilder sb = new StringBuilder();
      switch (getStatus()) {
        case STARTING:
          sb.append("Starting %s in %s on %s as %s at %s").append(System.lineSeparator());
          sb.append(TO_STRING_PROCESS_ID).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_JAVA_VERSION).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_LOG_FILE).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_JVM_ARGUMENTS).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_CLASS_PATH).append("%s");
          return String.format(sb.toString(), getServiceName(), getWorkingDirectory(), getServiceLocation(), getMemberName(), toString(getTimestamp()), toString(getPid()), toString(getGemFireVersion()), toString(getJavaVersion()), getLogFile(), ArgumentRedactor.redact(getJvmArguments()), toString(getClasspath()));
        case ONLINE:
          sb.append("%s in %s on %s as %s is currently %s.").append(System.lineSeparator());
          sb.append(TO_STRING_PROCESS_ID).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_UPTIME).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_GEODE_VERSION).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_JAVA_VERSION).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_LOG_FILE).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_JVM_ARGUMENTS).append("%s").append(System.lineSeparator());
          sb.append(TO_STRING_CLASS_PATH).append("%s");
          return String.format(sb.toString(), getServiceName(), getWorkingDirectory(), getServiceLocation(), getMemberName(), getStatus(), toString(getPid()), toDaysHoursMinutesSeconds(getUptime()), toString(getGemFireVersion()), toString(getJavaVersion()), getLogFile(), ArgumentRedactor.redact(getJvmArguments()), toString(getClasspath()));
        case STOPPED:
          sb.append("%s in %s on %s has been requested to stop.");
          return String.format(sb.toString(), getServiceName(), getWorkingDirectory(), getServiceLocation());
        default:  sb.append("%s in %s on %s is currently %s.");
          return String.format(sb.toString(), getServiceName(), getWorkingDirectory(), getServiceLocation(), getStatus());
      }
      
    }
    
    protected String toString(final Date dateTime) {
      return format(dateTime);
    }
    
    protected String toString(final Number value) {
      return defaultString(value);
    }
    
    protected String toString(final Object... values) {
      return values == null ? "" : join(values, " ");
    }
    
    protected String toString(final String value) {
      return value != null ? value : "";
    }
    
  }
  
  public enum Status {
    NOT_RESPONDING("not responding"), ONLINE("online"), STARTING("starting"), STOPPED("stopped");
    private final String description;
    Status(final String description) {
      assert isNotBlank(description) : "The Status description must be specified!";
      this.description = lowerCase(description);
    }
    
    public static Status valueOfDescription(final String description) {
      for (Status status : values()) {
        if (status.getDescription().equalsIgnoreCase(description)) {
          return status;
        }
        
      }
      
      return null;
    }
    
    public String getDescription() {
      return description;
    }
    
    public String toString() {
      return getDescription();
    }
    
  }
  
}


