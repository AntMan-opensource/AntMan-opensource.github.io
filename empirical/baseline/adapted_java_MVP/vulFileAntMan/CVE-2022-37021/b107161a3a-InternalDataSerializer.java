package org.apache.geode.internal;
import static org.apache.geode.internal.serialization.filter.SanctionedSerializables.loadSanctionedSerializablesServices;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.NotSerializableException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.OutputStream;
import java.io.Serializable;
import java.io.UTFDataFormatException;
import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.lang.reflect.Proxy;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.SocketException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Properties;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.UUID;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.Logger;
import org.apache.geode.CancelException;
import org.apache.geode.CanonicalInstantiator;
import org.apache.geode.DataSerializable;
import org.apache.geode.DataSerializer;
import org.apache.geode.GemFireConfigException;
import org.apache.geode.GemFireIOException;
import org.apache.geode.GemFireRethrowable;
import org.apache.geode.Instantiator;
import org.apache.geode.SerializationException;
import org.apache.geode.SystemFailure;
import org.apache.geode.ToDataException;
import org.apache.geode.annotations.Immutable;
import org.apache.geode.annotations.VisibleForTesting;
import org.apache.geode.annotations.internal.MakeNotStatic;
import org.apache.geode.annotations.internal.MutableForTesting;
import org.apache.geode.cache.CacheClosedException;
import org.apache.geode.cache.execute.Function;
import org.apache.geode.distributed.internal.ClusterDistributionManager;
import org.apache.geode.distributed.internal.DMStats;
import org.apache.geode.distributed.internal.DistributionConfig;
import org.apache.geode.distributed.internal.InternalDistributedSystem;
import org.apache.geode.distributed.internal.LonerDistributionManager;
import org.apache.geode.distributed.internal.SerialDistributionMessage;
import org.apache.geode.internal.cache.EnumListenerEvent;
import org.apache.geode.internal.cache.EventID;
import org.apache.geode.internal.cache.GemFireCacheImpl;
import org.apache.geode.internal.cache.InternalCache;
import org.apache.geode.internal.cache.PoolManagerImpl;
import org.apache.geode.internal.cache.tier.sockets.CacheClientNotifier;
import org.apache.geode.internal.cache.tier.sockets.CacheServerHelper;
import org.apache.geode.internal.cache.tier.sockets.ClientDataSerializerMessage;
import org.apache.geode.internal.cache.tier.sockets.ClientProxyMembershipID;
import org.apache.geode.internal.cache.tier.sockets.OldClientSupportService;
import org.apache.geode.internal.cache.tier.sockets.Part;
import org.apache.geode.internal.classloader.ClassPathLoader;
import org.apache.geode.internal.lang.ClassUtils;
import org.apache.geode.internal.logging.log4j.LogMarker;
import org.apache.geode.internal.serialization.BasicSerializable;
import org.apache.geode.internal.serialization.DSCODE;
import org.apache.geode.internal.serialization.DSFIDSerializer;
import org.apache.geode.internal.serialization.DSFIDSerializerFactory;
import org.apache.geode.internal.serialization.DataSerializableFixedID;
import org.apache.geode.internal.serialization.DataSerializableFixedIdRegistrant;
import org.apache.geode.internal.serialization.DeserializationContext;
import org.apache.geode.internal.serialization.DscodeHelper;
import org.apache.geode.internal.serialization.KnownVersion;
import org.apache.geode.internal.serialization.ObjectDeserializer;
import org.apache.geode.internal.serialization.ObjectSerializer;
import org.apache.geode.internal.serialization.SerializationContext;
import org.apache.geode.internal.serialization.SerializationVersions;
import org.apache.geode.internal.serialization.StaticSerialization;
import org.apache.geode.internal.serialization.VersionedDataStream;
import org.apache.geode.internal.serialization.filter.SanctionedSerializablesService;
import org.apache.geode.internal.util.concurrent.CopyOnWriteHashMap;
import org.apache.geode.logging.internal.log4j.api.LogService;
import org.apache.geode.pdx.NonPortableClassException;
import org.apache.geode.pdx.PdxInstance;
import org.apache.geode.pdx.PdxSerializable;
import org.apache.geode.pdx.PdxSerializer;
import org.apache.geode.pdx.internal.AutoSerializableManager;
import org.apache.geode.pdx.internal.AutoSerializableManager.AutoClassInfo;
import org.apache.geode.pdx.internal.EnumInfo;
import org.apache.geode.pdx.internal.PdxInputStream;
import org.apache.geode.pdx.internal.PdxInstanceEnum;
import org.apache.geode.pdx.internal.PdxInstanceImpl;
import org.apache.geode.pdx.internal.PdxOutputStream;
import org.apache.geode.pdx.internal.PdxReaderImpl;
import org.apache.geode.pdx.internal.PdxType;
import org.apache.geode.pdx.internal.PdxWriterImpl;
import org.apache.geode.pdx.internal.TypeRegistry;
import org.apache.geode.util.internal.GeodeGlossary;
public abstract class InternalDataSerializer extends DataSerializer {
  public static final boolean LOAD_CLASS_EACH_TIME = Boolean.getBoolean(GeodeGlossary.GEMFIRE_PREFIX + "loadClassOnEveryDeserialization");
  private static final Logger logger = LogService.getLogger();
  private static final Map<String, DataSerializer> classesToSerializers = new ConcurrentHashMap<>();
  private static final String SANCTIONED_SERIALIZABLES_DEPENDENCIES_PATTERN = "java.**" + ";javax.management.**" + ";javax.print.attribute.EnumSyntax" + ";antlr.**" + ";org.apache.commons.modeler.AttributeInfo" + ";org.apache.commons.modeler.FeatureInfo" + ";org.apache.commons.modeler.ManagedBean" + ";org.apache.geode.distributed.internal.DistributionConfigSnapshot" + ";org.apache.geode.distributed.internal.RuntimeDistributionConfigImpl" + ";org.apache.geode.distributed.internal.DistributionConfigImpl" + ";org.apache.geode.distributed.internal.membership.InternalDistributedMember" + ";org.apache.geode.internal.cache.persistence.PersistentMemberID" + ";org.apache.geode.internal.cache.persistence.DiskStoreID" + ";org.apache.geode.internal.cache.tier.sockets.VersionedObjectList" + ";org.apache.shiro.**" + ";org.apache.logging.log4j.Level" + ";org.apache.logging.log4j.spi.StandardLevel" + ";com.sun.proxy.$Proxy*" + ";com.healthmarketscience.rmiio.RemoteInputStream" + ";javax.rmi.ssl.SslRMIClientSocketFactory" + ";javax.net.ssl.SSLHandshakeException" + ";javax.net.ssl.SSLException" + ";sun.security.validator.ValidatorException" + ";sun.security.provider.certpath.SunCertPathBuilderException" + ";org.apache.geode.modules.util.SessionCustomExpiry" + ";";
  private static final String serializationVersionTxt = System.getProperty(GeodeGlossary.GEMFIRE_PREFIX + "serializationVersion");
  private static final SERIALIZATION_VERSION latestVersion = SERIALIZATION_VERSION.v662;
  private static final SERIALIZATION_VERSION serializationVersion = calculateSerializationVersion();
  private static final ConcurrentMap<Integer, Object > idsToSerializers = new ConcurrentHashMap<>();
  private static final ConcurrentHashMap<String, SerializerAttributesHolder> dsClassesToHolders = new ConcurrentHashMap<>();
  private static final ConcurrentHashMap<Integer, SerializerAttributesHolder> idsToHolders = new ConcurrentHashMap<>();
  private static final ConcurrentHashMap<String, SerializerAttributesHolder> supportedClassesToHolders = new ConcurrentHashMap<>();
  private static final Object listenersSync = new Object();
  private static final ThreadLocal<Boolean> pdxSerializationInProgress = new ThreadLocal<>();
  private static final CopyOnWriteHashMap<String, WeakReference<Class<?>>> classCache = LOAD_CLASS_EACH_TIME ? null : new CopyOnWriteHashMap<>();
  private static final Object cacheAccessLock = new Object();
  private static final String POST_GEODE_190_SERVER_CQIMPL = "org.apache.geode.cache.query.cq.internal.ServerCQImpl";
  private static final String PRE_GEODE_190_SERVER_CQIMPL = "org.apache.geode.cache.query.internal.cq.ServerCQImpl";
  private static final InputStreamFilter defaultSerializationFilter = new EmptyInputStreamFilter();
  private static InputStreamFilter serializationFilter = defaultSerializationFilter;
  private static OldClientSupportService oldClientSupportService;
  private static final DSFIDSerializer dsfidSerializer;
  private static final DSFIDFactory dsfidFactory;
  private static volatile Set<RegistrationListener> listeners = new HashSet<>();
  static {
    dsfidSerializer = new DSFIDSerializerFactory().setObjectSerializer(new ObjectSerializer() {
      public void writeObject(Object obj, DataOutput output) throws IOException {
        InternalDataSerializer.writeObject(obj, output);
      }
      
      public void invokeToData(Object ds, DataOutput out) throws IOException {
        InternalDataSerializer.invokeToData(ds, out);
      }
      
    }
).setObjectDeserializer(new ObjectDeserializer() {
      public <T> T readObject(DataInput input) throws IOException, ClassNotFoundException {
        return InternalDataSerializer.readObject(input);
      }
      
      public void invokeFromData(Object ds, DataInput in) throws IOException, ClassNotFoundException {
        InternalDataSerializer.invokeFromData(ds, in);
      }
      
    }
).create();
    initializeWellKnownSerializers();
    dsfidFactory = new DSFIDFactory(dsfidSerializer);
    ServiceLoader<DataSerializableFixedIdRegistrant> loaders = ServiceLoader.load( DataSerializableFixedIdRegistrant.class);
    for (DataSerializableFixedIdRegistrant loader : loaders) {
      try {
        loader.register(dsfidSerializer);
      }
       catch (Exception ex) {
        logger.warn("Data serializable fixed ID loader '{}' failed", loader.getClass().getName(), ex);
      }
      
    }
    
  }
  
  public static String processIncomingClassName(String nameArg) {
    final String name = StaticSerialization.processIncomingClassName(nameArg);
    if (name != nameArg) {
      return name;
    }
    
    if (name.equals(PRE_GEODE_190_SERVER_CQIMPL)) {
      return POST_GEODE_190_SERVER_CQIMPL;
    }
    
    OldClientSupportService svc = getOldClientSupportService();
    if (svc != null) {
      return svc.processIncomingClassName(name);
    }
    
    return name;
  }
  
  public static String processOutgoingClassName(final String nameArg, DataOutput out) {
    final String name = StaticSerialization.processOutgoingClassName(nameArg);
    if (name != nameArg) {
      return name;
    }
    
    if (out instanceof VersionedDataStream) {
      VersionedDataStream vout = (VersionedDataStream) out;
      KnownVersion version = vout.getVersion();
      if (null != version) {
        if (version.isOlderThan(KnownVersion.GEODE_1_9_0)) {
          if (name.equals(POST_GEODE_190_SERVER_CQIMPL)) {
            return PRE_GEODE_190_SERVER_CQIMPL;
          }
          
        }
        
      }
      
    }
    
    OldClientSupportService svc = getOldClientSupportService();
    if (svc != null) {
      return svc.processOutgoingClassName(name, out);
    }
    
    return name;
  }
  
  public static void initializeSerializationFilter(DistributionConfig distributionConfig) {
    initializeSerializationFilter(distributionConfig, loadSanctionedSerializablesServices());
  }
  
  public static void initializeSerializationFilter(DistributionConfig distributionConfig, Collection<SanctionedSerializablesService> services) {
    logger.info("initializing InternalDataSerializer with {} services", services.size());
    if (distributionConfig.getValidateSerializableObjects()) {
      if (!ClassUtils.isClassAvailable("sun.misc.ObjectInputFilter") && !ClassUtils.isClassAvailable("java.io.ObjectInputFilter")) {
        throw new GemFireConfigException( "A serialization filter has been specified but this version of Java does not support serialization filters - ObjectInputFilter is not available");
      }
      
      serializationFilter = new ObjectInputStreamFilterWrapper(SANCTIONED_SERIALIZABLES_DEPENDENCIES_PATTERN + distributionConfig.getSerializableObjectFilter() + ";!*", services);
    }
     else {
      clearSerializationFilter();
    }
    
  }
  
  @VisibleForTesting
  static void clearSerializationFilter() {
    serializationFilter = defaultSerializationFilter;
  }
  
  private static SERIALIZATION_VERSION calculateSerializationVersion() {
    if (serializationVersionTxt == null || serializationVersionTxt.isEmpty()) {
      return latestVersion;
    }
     else if (serializationVersionTxt.startsWith("6.6.0") || serializationVersionTxt.startsWith("6.6.1")) {
      return SERIALIZATION_VERSION.v660;
    }
     else if (serializationVersionTxt.startsWith("6.6.2")) {
      return SERIALIZATION_VERSION.v662;
    }
     else {
      return SERIALIZATION_VERSION.vINVALID;
    }
    
  }
  
  public static boolean is662SerializationEnabled() {
    return serializationVersion.ordinal() >= SERIALIZATION_VERSION.v662.ordinal();
  }
  
  public static void checkSerializationVersion() {
    if (serializationVersion == SERIALIZATION_VERSION.vINVALID) {
      throw new IllegalArgumentException( "The system property \"gemfire.serializationVersion\" was set to \"" + serializationVersionTxt + "\" which is not a valid serialization version. Valid versions must start with \"6.6.0\", \"6.6.1\", or \"6.6.2\"");
    }
    
  }
  
  private static void initializeWellKnownSerializers() {
    classesToSerializers.put("java.lang.String", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        try {
          writeString((String) o, out);
        }
         catch (UTFDataFormatException ex) {
          String s = "While writing a String of length " + ((String) o).length();
          UTFDataFormatException ex2 = new UTFDataFormatException(s);
          ex2.initCause(ex);
          throw ex2;
        }
        
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.net.InetAddress", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        InetAddress address = (InetAddress) o;
        out.writeByte(DSCODE.INET_ADDRESS.toByte());
        writeInetAddress(address, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.net.Inet4Address", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        InetAddress address = (InetAddress) o;
        out.writeByte(DSCODE.INET_ADDRESS.toByte());
        writeInetAddress(address, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.net.Inet6Address", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        InetAddress address = (InetAddress) o;
        out.writeByte(DSCODE.INET_ADDRESS.toByte());
        writeInetAddress(address, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Class", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Class c = (Class) o;
        if (c.isPrimitive()) {
          StaticSerialization.writePrimitiveClass(c, out);
        }
         else {
          out.writeByte(DSCODE.CLASS.toByte());
          writeClass(c, out);
        }
        
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Boolean", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Boolean value = (Boolean) o;
        out.writeByte(DSCODE.BOOLEAN.toByte());
        writeBoolean(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Character", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Character value = (Character) o;
        out.writeByte(DSCODE.CHARACTER.toByte());
        writeCharacter(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Byte", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Byte value = (Byte) o;
        out.writeByte(DSCODE.BYTE.toByte());
        writeByte(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Short", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Short value = (Short) o;
        out.writeByte(DSCODE.SHORT.toByte());
        writeShort(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Integer", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Integer value = (Integer) o;
        out.writeByte(DSCODE.INTEGER.toByte());
        writeInteger(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Long", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Long value = (Long) o;
        out.writeByte(DSCODE.LONG.toByte());
        writeLong(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Float", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Float value = (Float) o;
        out.writeByte(DSCODE.FLOAT.toByte());
        writeFloat(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.lang.Double", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Double value = (Double) o;
        out.writeByte(DSCODE.DOUBLE.toByte());
        writeDouble(value, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("[Z",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            out.writeByte(DSCODE.BOOLEAN_ARRAY.toByte());
            writeBooleanArray((boolean[]) o, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[B",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            byte[] array = (byte[]) o;
            out.writeByte(DSCODE.BYTE_ARRAY.toByte());
            writeByteArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[C",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            out.writeByte(DSCODE.CHAR_ARRAY.toByte());
            writeCharArray((char[]) o, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[D",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            double[] array = (double[]) o;
            out.writeByte(DSCODE.DOUBLE_ARRAY.toByte());
            writeDoubleArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[F",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            float[] array = (float[]) o;
            out.writeByte(DSCODE.FLOAT_ARRAY.toByte());
            writeFloatArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[I",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            int[] array = (int[]) o;
            out.writeByte(DSCODE.INT_ARRAY.toByte());
            writeIntArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[J",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            long[] array = (long[]) o;
            out.writeByte(DSCODE.LONG_ARRAY.toByte());
            writeLongArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[S",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            short[] array = (short[]) o;
            out.writeByte(DSCODE.SHORT_ARRAY.toByte());
            writeShortArray(array, out);
            return true;
          }
          
        }
        
);
    classesToSerializers.put("[Ljava.lang.String;",  new WellKnownPdxDS() {
          public boolean toData(Object o, DataOutput out) throws IOException {
            String[] array = (String[]) o;
            out.writeByte(DSCODE.STRING_ARRAY.toByte());
            writeStringArray(array, out);
            return true;
          }
          
        }
        
);
    WellKnownDS TIME_UNIT_SERIALIZER = new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        TimeUnit timeUnit = (TimeUnit) o;
        switch (timeUnit) {
          case NANOSECONDS: {
            out.writeByte(DSCODE.TIME_UNIT.toByte());
            out.writeByte(StaticSerialization.TIME_UNIT_NANOSECONDS);
            break;
          }
          
          case MICROSECONDS: {
            out.writeByte(DSCODE.TIME_UNIT.toByte());
            out.writeByte(StaticSerialization.TIME_UNIT_MICROSECONDS);
            break;
          }
          
          case MILLISECONDS: {
            out.writeByte(DSCODE.TIME_UNIT.toByte());
            out.writeByte(StaticSerialization.TIME_UNIT_MILLISECONDS);
            break;
          }
          
          case SECONDS: {
            out.writeByte(DSCODE.TIME_UNIT.toByte());
            out.writeByte(StaticSerialization.TIME_UNIT_SECONDS);
            break;
          }
          
          default: {
            writeGemFireEnum(timeUnit, out);
          }
          
        }
        
        return true;
      }
      
    };
    if (TimeUnit.NANOSECONDS.getClass().getName().equals(TimeUnit.SECONDS.getClass().getName())) {
      classesToSerializers.put(TimeUnit.class.getName(), TIME_UNIT_SERIALIZER);
    }
    
    else {
      classesToSerializers.put(TimeUnit.NANOSECONDS.getClass().getName(), TIME_UNIT_SERIALIZER);
      classesToSerializers.put(TimeUnit.MICROSECONDS.getClass().getName(), TIME_UNIT_SERIALIZER);
      classesToSerializers.put(TimeUnit.MILLISECONDS.getClass().getName(), TIME_UNIT_SERIALIZER);
      classesToSerializers.put(TimeUnit.SECONDS.getClass().getName(), TIME_UNIT_SERIALIZER);
    }
    
    classesToSerializers.put("java.util.Date", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Date date = (Date) o;
        out.writeByte(DSCODE.DATE.toByte());
        writeDate(date, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.io.File", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        File file = (File) o;
        out.writeByte(DSCODE.FILE.toByte());
        writeFile(file, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.ArrayList", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        ArrayList list = (ArrayList) o;
        out.writeByte(DSCODE.ARRAY_LIST.toByte());
        writeArrayList(list, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.LinkedList", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        LinkedList list = (LinkedList) o;
        out.writeByte(DSCODE.LINKED_LIST.toByte());
        writeLinkedList(list, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.Vector", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.VECTOR.toByte());
        writeVector((Vector) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.Stack", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.STACK.toByte());
        writeStack((Stack) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.HashSet", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        HashSet list = (HashSet) o;
        out.writeByte(DSCODE.HASH_SET.toByte());
        writeHashSet(list, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.LinkedHashSet", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.LINKED_HASH_SET.toByte());
        writeLinkedHashSet((LinkedHashSet) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.HashMap", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        HashMap list = (HashMap) o;
        out.writeByte(DSCODE.HASH_MAP.toByte());
        writeHashMap(list, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.IdentityHashMap", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.IDENTITY_HASH_MAP.toByte());
        writeIdentityHashMap((IdentityHashMap) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.Hashtable", new WellKnownPdxDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.HASH_TABLE.toByte());
        writeHashtable((Hashtable) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.Properties", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        Properties props = (Properties) o;
        out.writeByte(DSCODE.PROPERTIES.toByte());
        writeProperties(props, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.TreeMap", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.TREE_MAP.toByte());
        writeTreeMap((TreeMap) o, out);
        return true;
      }
      
    }
    
);
    classesToSerializers.put("java.util.TreeSet", new WellKnownDS() {
      public boolean toData(Object o, DataOutput out) throws IOException {
        out.writeByte(DSCODE.TREE_SET.toByte());
        writeTreeSet((TreeSet) o, out);
        return true;
      }
      
    }
    
);
    if (is662SerializationEnabled()) {
      classesToSerializers.put("java.math.BigInteger", new WellKnownDS() {
        public boolean toData(Object o, DataOutput out) throws IOException {
          out.writeByte(DSCODE.BIG_INTEGER.toByte());
          writeBigInteger((BigInteger) o, out);
          return true;
        }
        
      }
      
);
      classesToSerializers.put("java.math.BigDecimal", new WellKnownDS() {
        public boolean toData(Object o, DataOutput out) throws IOException {
          out.writeByte(DSCODE.BIG_DECIMAL.toByte());
          writeBigDecimal((BigDecimal) o, out);
          return true;
        }
        
      }
      
);
      classesToSerializers.put("java.util.UUID", new WellKnownDS() {
        public boolean toData(Object o, DataOutput out) throws IOException {
          out.writeByte(DSCODE.UUID.toByte());
          writeUUID((UUID) o, out);
          return true;
        }
        
      }
      
);
      classesToSerializers.put("java.sql.Timestamp", new WellKnownDS() {
        public boolean toData(Object o, DataOutput out) throws IOException {
          out.writeByte(DSCODE.TIMESTAMP.toByte());
          writeTimestamp((Timestamp) o, out);
          return true;
        }
        
      }
      
);
    }
    
  }
  
  private static int ubyteToInt(byte ub) {
    return ub & 0xFF;
  }
  
  public static OldClientSupportService getOldClientSupportService() {
    return oldClientSupportService;
  }
  
  public static void setOldClientSupportService(final OldClientSupportService svc) {
    oldClientSupportService = svc;
  }
  
  static DataSerializer newInstance(Class<? extends DataSerializer> c) throws IllegalArgumentException {
    if (!DataSerializer.class.isAssignableFrom(c)) {
      throw new IllegalArgumentException( String.format("%s does not extend DataSerializer.", c.getName()));
    }
    
    Constructor<? extends DataSerializer> init;
    try {
      init = c.getDeclaredConstructor();
    }
     catch (NoSuchMethodException ignored) {
      if (c.getDeclaringClass() != null) {
        String message = String.format( "Class %s does not have a zero-argument constructor. It is an inner class of %s. Should it be a static inner class?", c.getName(), c.getDeclaringClass());
        throw new IllegalArgumentException(message);
      }
      
      String message = String.format("Class %s does not have a zero-argument constructor.", c.getName());
      throw new IllegalArgumentException(message);
    }
    
    DataSerializer s;
    try {
      init.setAccessible(true);
      s = init.newInstance();
    }
     catch (IllegalAccessException ignored) {
      throw new IllegalArgumentException( String.format("Could not instantiate an instance of %s", c.getName()));
    }
     catch (InstantiationException ex) {
      throw new IllegalArgumentException( String.format("Could not instantiate an instance of %s", c.getName()), ex);
    }
     catch (InvocationTargetException ex) {
      throw new IllegalArgumentException( String.format("While instantiating an instance of %s", c.getName()), ex);
    }
    
    return s;
  }
  
  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute, EventID eventId, ClientProxyMembershipID context) {
    DataSerializer s = newInstance(c);
    s.setEventId(eventId);
    s.setContext(context);
    return _register(s, distribute);
  }
  
  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute) {
    final DataSerializer s = newInstance(c);
    return _register(s, distribute);
  }
  
  public static DataSerializer _register(DataSerializer s, boolean distribute) {
    final int id = s.getId();
    DataSerializer dsForMarkers = s;
    if (id == 0) {
      throw new IllegalArgumentException( "Cannot create a DataSerializer with id 0.");
    }
    
    final Class[] classes = s.getSupportedClasses();
    if (classes == null || classes.length == 0) {
      final String msg = "The DataSerializer %s has no supported classes. It's getSupportedClasses method must return at least one class";
      throw new IllegalArgumentException(String.format(msg, s.getClass().getName()));
    }
    
    for (Class aClass : classes) {
      if (aClass == null) {
        final String msg = "The DataSerializer getSupportedClasses method for %s returned an array that contained a null element.";
        throw new IllegalArgumentException(String.format(msg, s.getClass().getName()));
      }
       else if (aClass.isArray()) {
        final String msg = "The DataSerializer getSupportedClasses method for %s returned an array that contained an array class which is not allowed since arrays have built-in support.";
        throw new IllegalArgumentException(String.format(msg, s.getClass().getName()));
      }
      
    }
    
    final Integer idx = id;
    boolean retry;
    Marker oldMarker = null;
    final Marker m = new InitMarker();
    do {
      retry = false;
      Object oldSerializer = idsToSerializers.putIfAbsent(idx, m);
      if (oldSerializer != null) {
        if (oldSerializer instanceof Marker) {
          retry = !idsToSerializers.replace(idx, oldSerializer, m);
          if (!retry) {
            oldMarker = (Marker) oldSerializer;
          }
          
        }
         else if (oldSerializer.getClass().equals(s.getClass())) {
          if (distribute) {
            sendRegistrationMessage(s);
          }
          
          return (DataSerializer) oldSerializer;
        }
         else {
          DataSerializer other = (DataSerializer) oldSerializer;
          throw new IllegalStateException( String.format( "A DataSerializer of class %s is already registered with id %s.", other.getClass().getName(), other.getId()));
        }
        
      }
      
    }
     while (retry);
    try {
      for (int i = 0; i < classes.length; i++) {
        DataSerializer oldS = classesToSerializers.putIfAbsent(classes[i].getName(), s);
        if (oldS != null) {
          if (!s.equals(oldS)) {
            for (int j = 0; j < i; j++) {
              classesToSerializers.remove(classes[j].getName(), s);
            }
            
            dsForMarkers = null;
            String oldMsg;
            if (oldS.getId() == 0) {
              oldMsg = "DataSerializer has built-in support for class ";
            }
             else {
              oldMsg = "A DataSerializer of class " + oldS.getClass().getName() + " is already registered to support class ";
            }
            
            String msg = oldMsg + classes[i].getName() + " so the DataSerializer of class " + s.getClass().getName() + " could not be registered.";
            if (oldS.getId() == 0) {
              throw new IllegalArgumentException(msg);
            }
             else {
              throw new IllegalStateException(msg);
            }
            
          }
          
        }
        
      }
      
    }
     finally {
      if (dsForMarkers == null) {
        idsToSerializers.remove(idx, m);
      }
       else {
        idsToSerializers.replace(idx, m, dsForMarkers);
      }
      
      if (oldMarker != null) {
        oldMarker.setSerializer(dsForMarkers);
      }
      
      m.setSerializer(dsForMarkers);
    }
    
    InternalCache cache = getInternalCache();
    if (cache != null && s.getEventId() == null) {
      s.setEventId(new EventID(cache.getDistributedSystem()));
    }
    
    if (distribute) {
      sendRegistrationMessage(s);
      sendRegistrationMessageToServers(s);
    }
    
    sendRegistrationMessageToClients(s);
    fireNewDataSerializer(s);
    return s;
  }
  
  private static InternalCache getInternalCache() {
    return GemFireCacheImpl.getInstance();
  }
  
  public static void register(String className, boolean distribute, EventID eventId, ClientProxyMembershipID proxyId, int id) {
    register(className, distribute, new SerializerAttributesHolder(className, eventId, proxyId, id));
  }
  
  public static void register(String className, boolean distribute) {
    register(className, distribute, new SerializerAttributesHolder());
  }
  
  private static void register(String className, boolean distribute, SerializerAttributesHolder holder) {
    if (StringUtils.isBlank(className)) {
      throw new IllegalArgumentException("Class name cannot be null or empty.");
    }
    
    SerializerAttributesHolder oldValue = dsClassesToHolders.putIfAbsent(className, holder);
    if (oldValue != null) {
      if (oldValue.getId() != 0 && holder.getId() != 0 && oldValue.getId() != holder.getId()) {
        throw new IllegalStateException( String.format( "A DataSerializer of class %s is already registered with id %s.", oldValue.getClass().getName(), oldValue.getId()));
      }
      
    }
    
    idsToHolders.putIfAbsent(holder.getId(), holder);
    Object ds = idsToSerializers.get(holder.getId());
    if (ds instanceof Marker) {
      synchronized (ds) {
        ((Marker) ds).notifyAll();
      }
      
    }
    
    if (distribute) {
      sendRegistrationMessageToServers(holder);
    }
    
  }
  
  public static void updateSupportedClassesMap(Map<Integer, List<String>> map) {
    for (Entry<Integer, List<String>> e : map.entrySet()) {
      for (String supportedClassName : e.getValue()) {
        SerializerAttributesHolder serializerAttributesHolder = idsToHolders.get(e.getKey());
        if (serializerAttributesHolder != null) {
          supportedClassesToHolders.putIfAbsent(supportedClassName, serializerAttributesHolder);
        }
        
      }
      
    }
    
  }
  
  public static void updateSupportedClassesMap(String dsClassName, String supportedClassName) {
    SerializerAttributesHolder holder = dsClassesToHolders.get(dsClassName);
    if (holder != null) {
      supportedClassesToHolders.putIfAbsent(supportedClassName, holder);
    }
    
  }
  
  private static void sendRegistrationMessageToServers(DataSerializer dataSerializer) {
    PoolManagerImpl.allPoolsRegisterDataSerializers(dataSerializer);
  }
  
  private static void sendRegistrationMessageToServers(SerializerAttributesHolder holder) {
    PoolManagerImpl.allPoolsRegisterDataSerializers(holder);
  }
  
  private static void sendRegistrationMessageToClients(DataSerializer dataSerializer) {
    InternalCache cache = getInternalCache();
    if (cache == null) {
      return;
    }
    
    byte[][] serializedDataSerializer = new byte[2][];
    try {
      serializedDataSerializer[0] = CacheServerHelper.serialize(dataSerializer.getClass().toString().substring(6));
      byte[] idBytes = new byte[4];
      Part.encodeInt(dataSerializer.getId(), idBytes);
      serializedDataSerializer[1] = idBytes;
    }
     catch (IOException ignored) {
      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
        logger.trace(LogMarker.SERIALIZER_VERBOSE, "InternalDataSerializer encountered an IOException while serializing DataSerializer :{}", dataSerializer);
      }
      
    }
    
    ClientDataSerializerMessage clientDataSerializerMessage = new ClientDataSerializerMessage(EnumListenerEvent.AFTER_REGISTER_DATASERIALIZER, serializedDataSerializer, (ClientProxyMembershipID) dataSerializer.getContext(), (EventID) dataSerializer.getEventId(), new Class[][] {dataSerializer.getSupportedClasses()});
    CacheClientNotifier.routeClientMessage(clientDataSerializerMessage);
  }
  
  public static EventID generateEventId() {
    InternalCache cache = getInternalCache();
    if (cache == null) {
      return null;
    }
    
    return new EventID(InternalDistributedSystem.getAnyInstance());
  }
  
  public static void unregister(int id) {
    final Integer idx = id;
    Object o = idsToSerializers.remove(idx);
    if (o != null) {
      if (o instanceof InitMarker) {
        o = ((Marker) o).getSerializer();
      }
      
    }
    
    if (o instanceof DataSerializer) {
      DataSerializer s = (DataSerializer) o;
      Class[] classes = s.getSupportedClasses();
      for (Class aClass : classes) {
        classesToSerializers.remove(aClass.getName(), s);
        supportedClassesToHolders.remove(aClass.getName());
      }
      
      dsClassesToHolders.remove(s.getClass().getName());
      idsToHolders.remove(idx);
    }
    
  }
  
  public static void reinitialize() {
    idsToSerializers.clear();
    classesToSerializers.clear();
    supportedClassesToHolders.clear();
    dsClassesToHolders.clear();
    idsToHolders.clear();
    initializeWellKnownSerializers();
  }
  
  private static DataSerializer getSerializer(Class c) {
    DataSerializer ds = classesToSerializers.get(c.getName());
    if (ds == null) {
      SerializerAttributesHolder sah = supportedClassesToHolders.get(c.getName());
      if (sah != null) {
        Class<DataSerializer> dsClass;
        try {
          dsClass = InternalDataSerializer.getCachedClass(sah.getClassName());
          DataSerializer serializer = register(dsClass, false);
          dsClassesToHolders.remove(dsClass.getName());
          idsToHolders.remove(serializer.getId());
          for (Class clazz : serializer.getSupportedClasses()) {
            supportedClassesToHolders.remove(clazz.getName());
          }
          
          return serializer;
        }
         catch (ClassNotFoundException ignored) {
          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}", c.getName());
        }
        
      }
      
    }
    
    return ds;
  }
  
  public static DataSerializer getSerializer(int id) {
    final Integer idx = id;
    final GetMarker marker = new GetMarker();
    DataSerializer result = null;
    boolean timedOut = false;
    SerializerAttributesHolder sah = idsToHolders.get(idx);
    while (result == null && !timedOut && sah == null) {
      Object o = idsToSerializers.putIfAbsent(idx, marker);
      if (o == null) {
        result = marker.getSerializer();
        if (result == null) {
          timedOut = true;
          idsToSerializers.remove(idx, marker);
        }
        
      }
       else if (o instanceof Marker) {
        result = ((Marker) o).getSerializer();
      }
       else {
        result = (DataSerializer) o;
      }
      
    }
    
    if (result == null) {
      if (sah != null) {
        Class<DataSerializer> dsClass;
        try {
          dsClass = getCachedClass(sah.getClassName());
          DataSerializer ds = register(dsClass, false);
          dsClassesToHolders.remove(sah.getClassName());
          idsToHolders.remove(id);
          for (Class clazz : ds.getSupportedClasses()) {
            supportedClassesToHolders.remove(clazz.getName());
          }
          
          return ds;
        }
         catch (ClassNotFoundException ignored) {
          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}", sah.getClassName());
        }
        
      }
      
    }
    
    return result;
  }
  
  public static DataSerializer[] getSerializers() {
    final int size = idsToSerializers.size();
    List<DataSerializer> coll = new ArrayList<>(size);
    for (Object v : idsToSerializers.values()) {
      if (v instanceof InitMarker) {
        v = ((Marker) v).getSerializer();
      }
      
      if (v instanceof DataSerializer) {
        coll.add((DataSerializer) v);
      }
      
    }
    
    Iterator<Entry<String, SerializerAttributesHolder>> iterator = dsClassesToHolders.entrySet().iterator();
    while (iterator.hasNext()) {
      Entry<String, SerializerAttributesHolder> entry = iterator.next();
      String name = entry.getKey();
      SerializerAttributesHolder holder = entry.getValue();
      try {
        Class<? extends DataSerializer> cl = getCachedClass(name);
        DataSerializer ds;
        if (holder.getEventId() != null) {
          ds = register(cl, false, holder.getEventId(), holder.getProxyId());
        }
         else {
          ds = register(cl, false);
        }
        
        coll.add(ds);
        iterator.remove();
        idsToHolders.remove(ds.getId());
        for (Class clazz : ds.getSupportedClasses()) {
          supportedClassesToHolders.remove(clazz.getName());
        }
        
      }
       catch (ClassNotFoundException ignored) {
        logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}", name);
      }
      
    }
    
    return coll.toArray(new DataSerializer[0]);
  }
  
  public static SerializerAttributesHolder[] getSerializersForDistribution() {
    final int size = idsToSerializers.size() + dsClassesToHolders.size();
    Collection<SerializerAttributesHolder> coll = new ArrayList<>(size);
    for (Object v : idsToSerializers.values()) {
      if (v instanceof InitMarker) {
        v = ((Marker) v).getSerializer();
      }
      
      if (v instanceof DataSerializer) {
        DataSerializer s = (DataSerializer) v;
        coll.add(new SerializerAttributesHolder(s.getClass().getName(), (EventID) s.getEventId(), (ClientProxyMembershipID) s.getContext(), s.getId()));
      }
      
    }
    
    for (final Entry<String, SerializerAttributesHolder> stringSerializerAttributesHolderEntry : dsClassesToHolders .entrySet()) {
      SerializerAttributesHolder v = stringSerializerAttributesHolderEntry.getValue();
      coll.add(v);
    }
    
    return coll.toArray(new SerializerAttributesHolder[0]);
  }
  
  public static void addRegistrationListener(RegistrationListener l) {
    synchronized (listenersSync) {
      Set<RegistrationListener> newSet = new HashSet<>(listeners);
      newSet.add(l);
      listeners = newSet;
    }
    
  }
  
  public static void removeRegistrationListener(RegistrationListener l) {
    synchronized (listenersSync) {
      Set<RegistrationListener> newSet = new HashSet<>(listeners);
      newSet.remove(l);
      listeners = newSet;
    }
    
  }
  
  private static void fireNewDataSerializer(DataSerializer ds) {
    for (RegistrationListener listener : listeners) {
      listener.newDataSerializer(ds);
    }
    
  }
  
  static void fireNewInstantiator(Instantiator instantiator) {
    for (RegistrationListener listener : listeners) {
      listener.newInstantiator(instantiator);
    }
    
  }
  
  private static void sendRegistrationMessage(DataSerializer s) {
    InternalDistributedSystem system = InternalDistributedSystem.getConnectedInstance();
    if (system != null) {
      RegistrationMessage m = new RegistrationMessage(s);
      system.getDistributionManager().putOutgoing(m);
    }
    
  }
  
  public static void writeDSFIDHeader(int dsfid, DataOutput out) throws IOException {
    if (dsfid == DataSerializableFixedID.ILLEGAL) {
      throw new IllegalStateException( "attempted to serialize ILLEGAL dsfid");
    }
    
    if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
      out.writeByte(DSCODE.DS_FIXED_ID_BYTE.toByte());
      out.writeByte(dsfid);
    }
     else if (dsfid <= Short.MAX_VALUE && dsfid >= Short.MIN_VALUE) {
      out.writeByte(DSCODE.DS_FIXED_ID_SHORT.toByte());
      out.writeShort(dsfid);
    }
     else {
      out.writeByte(DSCODE.DS_FIXED_ID_INT.toByte());
      out.writeInt(dsfid);
    }
    
  }
  
  public static void writeDSFID(DataSerializableFixedID o, DataOutput out) throws IOException {
    int dsfid = o.getDSFID();
    try {
      if (dsfid != DataSerializableFixedID.NO_FIXED_ID) {
        dsfidSerializer.write(o, out);
        return;
      }
      
      out.writeByte(DSCODE.DS_NO_FIXED_ID.toByte());
      DataSerializer.writeClass(o.getClass(), out);
      invokeToData(o, out);
    }
     catch (IOException | CancelException | ToDataException | GemFireRethrowable io) {
      throw io;
    }
     catch (VirtualMachineError err) {
      SystemFailure.initiateFailure(err);
      throw err;
    }
     catch (Throwable t) {
      SystemFailure.checkFailure();
      throw new ToDataException("toData failed on dsfid=" + dsfid + " msg:" + t.getMessage(), t);
    }
    
  }
  
  private static boolean writeWellKnownObject(Object o, DataOutput out, boolean ensurePdxCompatibility) throws IOException {
    return writeUserObject(o, out, ensurePdxCompatibility);
  }
  
  private static boolean writeUserObject(Object o, DataOutput out, boolean ensurePdxCompatibility) throws IOException {
    final Class<?> c = o.getClass();
    final DataSerializer serializer = InternalDataSerializer.getSerializer(c);
    if (serializer != null) {
      int id = serializer.getId();
      if (id != 0) {
        checkPdxCompatible(o, ensurePdxCompatibility);
        if (id <= Byte.MAX_VALUE && id >= Byte.MIN_VALUE) {
          out.writeByte(DSCODE.USER_CLASS.toByte());
          out.writeByte((byte) id);
        }
         else if (id <= Short.MAX_VALUE && id >= Short.MIN_VALUE) {
          out.writeByte(DSCODE.USER_CLASS_2.toByte());
          out.writeShort(id);
        }
         else {
          out.writeByte(DSCODE.USER_CLASS_4.toByte());
          out.writeInt(id);
        }
        
      }
       else {
        if (ensurePdxCompatibility) {
          if (!(serializer instanceof WellKnownPdxDS)) {
            checkPdxCompatible(o, ensurePdxCompatibility);
          }
          
        }
        
      }
      
      boolean toDataResult;
      try {
        toDataResult = serializer.toData(o, out);
      }
       catch (IOException io) {
        if (serializer instanceof WellKnownDS) {
          throw io; 
        }
         else {
          throw new ToDataException( "toData failed on DataSerializer with id=" + id + " for class " + c, io);
        }
        
      }
       catch (CancelException | ToDataException | GemFireRethrowable ex) {
        throw ex;
      }
       catch (VirtualMachineError err) {
        SystemFailure.initiateFailure(err);
        throw err;
      }
       catch (Throwable t) {
        SystemFailure.checkFailure();
        throw new ToDataException( "toData failed on DataSerializer with id=" + id + " for class " + c, t);
      }
      
      if (toDataResult) {
        return true;
      }
       else {
        throw new ToDataException( String.format( "Serializer %s (a %s ) said that it could serialize an instance of %s , but its toData() method returned false.", serializer.getId(), serializer.getClass().getName(), o.getClass().getName()));
      }
      
    }
     else if (o instanceof byte[][]) {
      byte[][] byteArrays = (byte[][]) o;
      out.writeByte(DSCODE.ARRAY_OF_BYTE_ARRAYS.toByte());
      writeArrayOfByteArrays(byteArrays, out);
      return true;
    }
     else if (o instanceof Object[]) {
      Object[] array = (Object[]) o;
      out.writeByte(DSCODE.OBJECT_ARRAY.toByte());
      writeObjectArray(array, out, ensurePdxCompatibility);
      return true;
    }
     else if (is662SerializationEnabled() && (o.getClass().isEnum() || (o.getClass().getSuperclass() != null && o.getClass().getSuperclass().isEnum()))) {
      if (isPdxSerializationInProgress()) {
        writePdxEnum((Enum<?>) o, out);
      }
       else {
        checkPdxCompatible(o, ensurePdxCompatibility);
        writeGemFireEnum((Enum<?>) o, out);
      }
      
      return true;
    }
     else {
      PdxSerializer pdxSerializer = TypeRegistry.getPdxSerializer();
      return pdxSerializer != null && writePdx(out, null, o, pdxSerializer);
    }
    
  }
  
  public static boolean autoSerialized(Object o, DataOutput out) throws IOException {
    AutoSerializableManager asm = TypeRegistry.getAutoSerializableManager();
    if (asm != null) {
      AutoClassInfo aci = asm.getExistingClassInfo(o.getClass());
      if (aci != null) {
        InternalCache internalCache = GemFireCacheImpl .getForPdx("PDX registry is unavailable because the Cache has been closed.");
        TypeRegistry tr = internalCache.getPdxRegistry();
        PdxOutputStream os;
        if (out instanceof HeapDataOutputStream) {
          os = new PdxOutputStream((HeapDataOutputStream) out);
        }
         else {
          os = new PdxOutputStream();
        }
        
        PdxWriterImpl writer = new PdxWriterImpl(tr, o, aci, os);
        try {
          if (is662SerializationEnabled()) {
            boolean alreadyInProgress = isPdxSerializationInProgress();
            if (!alreadyInProgress) {
              setPdxSerializationInProgress(true);
              try {
                asm.writeData(writer, o, aci);
              }
               finally {
                setPdxSerializationInProgress(false);
              }
              
            }
             else {
              asm.writeData(writer, o, aci);
            }
            
          }
           else {
            asm.writeData(writer, o, aci);
          }
          
        }
         catch (ToDataException | CancelException | NonPortableClassException | GemFireRethrowable ex) {
          throw ex;
        }
         catch (VirtualMachineError err) {
          SystemFailure.initiateFailure(err);
          throw err;
        }
         catch (Throwable t) {
          SystemFailure.checkFailure();
          throw new ToDataException("PdxSerializer failed when calling toData on " + o.getClass(), t);
        }
        
        int bytesWritten = writer.completeByteStreamGeneration();
        getDMStats(internalCache).incPdxSerialization(bytesWritten);
        if (!(out instanceof HeapDataOutputStream)) {
          writer.sendTo(out);
        }
        
        return true;
      }
      
    }
    
    return false;
  }
  
  private static void checkPdxCompatible(Object o, boolean ensurePdxCompatibility) {
    if (ensurePdxCompatibility) {
      throw new NonPortableClassException( "Instances of " + o.getClass() + " are not compatible with non-java PDX.");
    }
    
  }
  
  static boolean isGemfireObject(Object o) {
    return (o instanceof Function  || o.getClass().getName().startsWith("org.apache.geode.")) && !(o instanceof PdxSerializerObject);
  }
  
  private static Object readUserObject(DataInput in, int serializerId) throws IOException, ClassNotFoundException {
    DataSerializer serializer = InternalDataSerializer.getSerializer(serializerId);
    if (serializer == null) {
      throw new IOException(String.format("Serializer with Id %s is not registered", serializerId));
    }
    
    return serializer.fromData(in);
  }
  
  public static void checkOut(DataOutput out) {
    if (out == null) {
      throw new NullPointerException("Null DataOutput");
    }
    
  }
  
  public static void checkIn(DataInput in) {
    if (in == null) {
      throw new NullPointerException("Null DataInput");
    }
    
  }
  
  public static void writeSet(Collection<?> set, DataOutput out) throws IOException {
    checkOut(out);
    if (set != null) {
      final int size = set.size();
      writeArrayLength(size, out);
      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
        logger .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", size, set);
      }
      
      for (Object element : set) {
        writeObject(element, out);
      }
      
    }
     else {
      writeArrayLength(-1, out);
      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
        logger .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", -1, null);
      }
      
    }
    
  }
  
  public static Set readSet(DataInput in) throws IOException, ClassNotFoundException {
    return readHashSet(in);
  }
  
  public static void writeSetOfLongs(Set set, boolean hasLongIDs, DataOutput out) throws IOException {
    if (set == null) {
      out.writeInt(-1);
    }
     else {
      out.writeInt(set.size());
      out.writeBoolean(hasLongIDs);
      for (Object aSet : set) {
        Long l = (Long) aSet;
        if (hasLongIDs) {
          out.writeLong(l);
        }
         else {
          out.writeInt((int) l.longValue());
        }
        
      }
      
    }
    
  }
  
  public static Set<Long> readSetOfLongs(DataInput in) throws IOException {
    int size = in.readInt();
    if (size < 0) {
      return null;
    }
     else {
      Set<Long> result = new HashSet<>(size);
      boolean longIDs = in.readBoolean();
      for (int i = 0; i < size; i++) {
        long l = longIDs ? in.readLong() : in.readInt();
        result.add(l);
      }
      
      return result;
    }
    
  }
  
  private static TimeUnit readTimeUnit(DataInput in) throws IOException {
    InternalDataSerializer.checkIn(in);
    byte type = in.readByte();
    TimeUnit unit;
    switch (type) {
      case StaticSerialization.TIME_UNIT_NANOSECONDS:
        unit = TimeUnit.NANOSECONDS;
        break;
      case StaticSerialization.TIME_UNIT_MICROSECONDS:
        unit = TimeUnit.MICROSECONDS;
        break;
      case StaticSerialization.TIME_UNIT_MILLISECONDS:
        unit = TimeUnit.MILLISECONDS;
        break;
      case StaticSerialization.TIME_UNIT_SECONDS:
        unit = TimeUnit.SECONDS;
        break;
      default: throw new IOException( String.format("Unknown TimeUnit type: %s", type));
    }
    
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read TimeUnit: {}", unit);
    }
    
    return unit;
  }
  
  private static void writeTimestamp(Timestamp o, DataOutput out) throws IOException {
    InternalDataSerializer.checkOut(out);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing Timestamp: {}", o);
    }
    
    DataSerializer.writePrimitiveLong(o.getTime(), out);
  }
  
  private static Timestamp readTimestamp(DataInput in) throws IOException {
    InternalDataSerializer.checkIn(in);
    Timestamp result = new Timestamp(DataSerializer.readPrimitiveLong(in));
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Timestamp: {}", result);
    }
    
    return result;
  }
  
  private static void writeUUID(java.util.UUID o, DataOutput out) throws IOException {
    InternalDataSerializer.checkOut(out);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing UUID: {}", o);
    }
    
    DataSerializer.writePrimitiveLong(o.getMostSignificantBits(), out);
    DataSerializer.writePrimitiveLong(o.getLeastSignificantBits(), out);
  }
  
  private static UUID readUUID(DataInput in) throws IOException {
    InternalDataSerializer.checkIn(in);
    long mb = DataSerializer.readPrimitiveLong(in);
    long lb = DataSerializer.readPrimitiveLong(in);
    UUID result = new UUID(mb, lb);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read UUID: {}", result);
    }
    
    return result;
  }
  
  private static void writeBigDecimal(BigDecimal o, DataOutput out) throws IOException {
    InternalDataSerializer.checkOut(out);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing BigDecimal: {}", o);
    }
    
    DataSerializer.writeString(o.toString(), out);
  }
  
  private static BigDecimal readBigDecimal(DataInput in) throws IOException {
    InternalDataSerializer.checkIn(in);
    BigDecimal result = new BigDecimal(DataSerializer.readString(in));
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read BigDecimal: {}", result);
    }
    
    return result;
  }
  
  private static void writeBigInteger(BigInteger o, DataOutput out) throws IOException {
    InternalDataSerializer.checkOut(out);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing BigInteger: {}", o);
    }
    
    DataSerializer.writeByteArray(o.toByteArray(), out);
  }
  
  private static BigInteger readBigInteger(DataInput in) throws IOException {
    InternalDataSerializer.checkIn(in);
    BigInteger result = new BigInteger(Objects.requireNonNull(DataSerializer.readByteArray(in)));
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read BigInteger: {}", result);
    }
    
    return result;
  }
  
  public static void writeUserDataSerializableHeader(int classId, DataOutput out) throws IOException {
    if (classId <= Byte.MAX_VALUE && classId >= Byte.MIN_VALUE) {
      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE.toByte());
      out.writeByte(classId);
    }
     else if (classId <= Short.MAX_VALUE && classId >= Short.MIN_VALUE) {
      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE_2.toByte());
      out.writeShort(classId);
    }
     else {
      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE_4.toByte());
      out.writeInt(classId);
    }
    
  }
  
  public static void writeCharArray(char[] array, DataOutput out) throws IOException {
    checkOut(out);
    if (array == null) {
      writeArrayLength(-1, out);
    }
     else {
      final int length = array.length;
      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing char array of length {}", length);
      }
      
      writeArrayLength(length, out);
      for (char character : array) {
        out.writeChar(character);
      }
      
    }
    
  }
  
  public static boolean isSerializedNull(byte[] serializedForm) {
    return serializedForm.length == 1 && serializedForm[0] == DSCODE.NULL.toByte();
  }
  
  public static void basicWriteObject(Object o, DataOutput out, boolean ensurePdxCompatibility) throws IOException {
    checkOut(out);
    final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE);
    if (isDebugEnabled_SERIALIZER) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "basicWriteObject: {}", o);
    }
    
    if (o == null) {
      out.writeByte(DSCODE.NULL.toByte());
    }
     else if (o instanceof BasicSerializable) {
      checkPdxCompatible(o, ensurePdxCompatibility);
      BasicSerializable bs = (BasicSerializable) o;
      dsfidSerializer.write(bs, out);
    }
     else if (autoSerialized(o, out)) {
    }
     else if (o instanceof DataSerializable.Replaceable) {
      Object replacement = ((DataSerializable.Replaceable) o).replace();
      basicWriteObject(replacement, out, ensurePdxCompatibility);
    }
     else if (o instanceof PdxSerializable) {
      writePdx(out, GemFireCacheImpl .getForPdx("PDX registry is unavailable because the Cache has been closed."), o, null);
    }
     else if (o instanceof DataSerializable) {
      if (isDebugEnabled_SERIALIZER) {
        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing DataSerializable: {}", o);
      }
      
      checkPdxCompatible(o, ensurePdxCompatibility);
      Class c = o.getClass();
      int classId = InternalInstantiator.getClassId(c);
      if (classId != 0) {
        writeUserDataSerializableHeader(classId, out);
      }
       else {
        out.writeByte(DSCODE.DATA_SERIALIZABLE.toByte());
        DataSerializer.writeClass(c, out);
      }
      
      invokeToData(o, out);
    }
     else if (o instanceof Sendable) {
      if (!(o instanceof PdxInstance) || o instanceof PdxInstanceEnum) {
        checkPdxCompatible(o, ensurePdxCompatibility);
      }
      
      ((Sendable) o).sendTo(out);
    }
     else if (writeWellKnownObject(o, out, ensurePdxCompatibility)) {
    }
     else {
      checkPdxCompatible(o, ensurePdxCompatibility);
      if (logger.isTraceEnabled(LogMarker.SERIALIZER_ANNOUNCE_TYPE_WRITTEN_VERBOSE)) {
        logger.trace(LogMarker.SERIALIZER_ANNOUNCE_TYPE_WRITTEN_VERBOSE, "DataSerializer Serializing an instance of {}", o.getClass().getName());
      }
      
      if (disallowJavaSerialization() && o instanceof Serializable) {
        throw new NotSerializableException( String.format("%s is not DataSerializable and Java Serialization is disallowed", o.getClass().getName()));
      }
      
      writeSerializableObject(o, out);
    }
    
  }
  
  private static boolean disallowJavaSerialization() {
    Boolean v = DISALLOW_JAVA_SERIALIZATION.get();
    return v != null && v;
  }
  
  private static void writePdxEnum(Enum<?> e, DataOutput out) throws IOException {
    TypeRegistry tr = GemFireCacheImpl.getForPdx("PDX registry is unavailable because the Cache has been closed.") .getPdxRegistry();
    int eId = tr.getEnumId(e);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "write PdxEnum id={} enum={}", eId, e);
    }
    
    writePdxEnumId(eId, out);
  }
  
  public static void writePdxEnumId(int eId, DataOutput out) throws IOException {
    out.writeByte(DSCODE.PDX_ENUM.toByte());
    out.writeByte(eId >> 24);
    writeArrayLength(eId & 0xFFFFFF, out);
  }
  
  private static Object readPdxEnum(DataInput in) throws IOException {
    int dsId = in.readByte();
    int tmp = readArrayLength(in);
    int enumId = dsId << 24 | tmp & 0xFFFFFF;
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "read PdxEnum id={}", enumId);
    }
    
    InternalCache internalCache = GemFireCacheImpl .getForPdx("PDX registry is unavailable because the Cache has been closed.");
    TypeRegistry tr = internalCache.getPdxRegistry();
    Object result = tr.getEnumById(enumId);
    if (result instanceof PdxInstance) {
      getDMStats(internalCache).incPdxInstanceCreations();
    }
    
    return result;
  }
  
  private static void writeGemFireEnum(Enum<?> e, DataOutput out) throws IOException {
    boolean isGemFireObject = isGemfireObject(e);
    DataSerializer.writePrimitiveByte( isGemFireObject ? DSCODE.GEMFIRE_ENUM.toByte() : DSCODE.PDX_INLINE_ENUM.toByte(), out);
    DataSerializer.writeString(e.getDeclaringClass().getName(), out);
    DataSerializer.writeString(e.name(), out);
    if (!isGemFireObject) {
      InternalDataSerializer.writeArrayLength(e.ordinal(), out);
    }
    
  }
  
  private static Enum<?> readGemFireEnum(DataInput in) throws IOException, ClassNotFoundException {
    String className = DataSerializer.readString(in);
    String enumName = DataSerializer.readString(in);
    @SuppressWarnings("rawtypes")
    Class c = getCachedClass(className);
    return Enum.valueOf(c, enumName);
  }
  
  private static Object readPdxInlineEnum(DataInput in) throws IOException, ClassNotFoundException {
    InternalCache internalCache = getInternalCache();
    if (internalCache != null && internalCache.getPdxReadSerializedByAnyGemFireServices()) {
      String className = DataSerializer.readString(in);
      String enumName = DataSerializer.readString(in);
      int enumOrdinal = InternalDataSerializer.readArrayLength(in);
      getDMStats(internalCache).incPdxInstanceCreations();
      return new PdxInstanceEnum(className, enumName, enumOrdinal);
    }
     else {
      Enum<?> e = readGemFireEnum(in);
      InternalDataSerializer.readArrayLength(in);
      return e;
    }
    
  }
  
  public static void writeSerializableObject(Object o, DataOutput out) throws IOException {
    out.writeByte(DSCODE.SERIALIZABLE.toByte());
    if (out instanceof ObjectOutputStream) {
      ((ObjectOutputStream) out).writeObject(o);
    }
     else {
      OutputStream stream;
      if (out instanceof OutputStream) {
        stream = (OutputStream) out;
      }
       else {
        final DataOutput out2 = out;
        stream = new OutputStream() {
          public void write(int b) throws IOException {
            out2.write(b);
          }
          
          public void write(byte[] b, int off, int len) throws IOException {
            out2.write(b, off, len);
          }
          
        };
      }
      
      boolean wasDoNotCopy = false;
      if (out instanceof HeapDataOutputStream) {
        wasDoNotCopy = ((HeapDataOutputStream) out).setDoNotCopy(false);
      }
      
      try {
        ObjectOutput oos = new ObjectOutputStream(stream);
        if (stream instanceof VersionedDataStream) {
          KnownVersion v = ((VersionedDataStream) stream).getVersion();
          if (v != null && v != KnownVersion.CURRENT) {
            oos = new VersionedObjectOutput(oos, v);
          }
          
        }
        
        oos.writeObject(o);
        oos.flush();
      }
       finally {
        if (wasDoNotCopy) {
          ((HeapDataOutputStream) out).setDoNotCopy(true);
        }
        
      }
      
    }
    
  }
  
  public static void invokeToData(Object serializableObject, DataOutput out) throws IOException {
    try {
      if (serializableObject instanceof BasicSerializable) {
        dsfidSerializer.invokeToData(serializableObject, out);
        return;
      }
      
      boolean invoked = false;
      KnownVersion v = StaticSerialization.getVersionForDataStreamOrNull(out);
      if (KnownVersion.CURRENT != v && v != null) {
        KnownVersion[] versions = null;
        if (serializableObject instanceof SerializationVersions) {
          SerializationVersions sv = (SerializationVersions) serializableObject;
          versions = sv.getSerializationVersions();
        }
        
        if (versions != null) {
          for (KnownVersion version : versions) {
            if (v.compareTo(version) < 0) {
              serializableObject.getClass().getMethod("toDataPre_" + version.getMethodSuffix(), new Class[] {DataOutput.class}).invoke(serializableObject, out);
              invoked = true;
              break;
            }
            
          }
          
        }
        
      }
      
      if (!invoked) {
        ((DataSerializable) serializableObject).toData(out);
      }
      
    }
     catch (IOException io) {
      throw new ToDataException( "toData failed on DataSerializable " + serializableObject.getClass(), io);
    }
     catch (CancelException | ToDataException | GemFireRethrowable ex) {
      throw ex;
    }
     catch (VirtualMachineError err) {
      SystemFailure.initiateFailure(err);
      throw err;
    }
     catch (Throwable t) {
      SystemFailure.checkFailure();
      throw new ToDataException( "toData failed on DataSerializable " + null == serializableObject ? "null" : serializableObject.getClass().toString(), t);
    }
    
  }
  
  public static void invokeFromData(Object deserializableObject, DataInput in) throws IOException, ClassNotFoundException {
    if (deserializableObject instanceof BasicSerializable) {
      dsfidSerializer.invokeFromData(deserializableObject, in);
      return;
    }
    
    try {
      boolean invoked = false;
      KnownVersion v = StaticSerialization.getVersionForDataStreamOrNull(in);
      if (KnownVersion.CURRENT != v && v != null) {
        KnownVersion[] versions = null;
        if (deserializableObject instanceof SerializationVersions) {
          SerializationVersions vds = (SerializationVersions) deserializableObject;
          versions = vds.getSerializationVersions();
        }
        
        if (versions != null) {
          for (KnownVersion version : versions) {
            if (v.compareTo(version) < 0) {
              deserializableObject.getClass() .getMethod("fromDataPre" + '_' + version.getMethodSuffix(), new Class[] {DataInput.class}) .invoke(deserializableObject, in);
              invoked = true;
              break;
            }
            
          }
          
        }
        
      }
      
      if (!invoked) {
        ((DataSerializable) deserializableObject).fromData(in);
        if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read DataSerializable {}", deserializableObject);
        }
        
      }
      
    }
     catch (EOFException | ClassNotFoundException | CacheClosedException | SocketException ex) {
      throw ex;
    }
     catch (Exception ex) {
      throw new SerializationException( String.format("Could not create an instance of %s .", deserializableObject.getClass().getName()), ex);
    }
    
  }
  
  private static Object readDataSerializable(final DataInput in) throws IOException, ClassNotFoundException {
    final Class<?> c = readClass(in);
    try {
      Constructor<?> init = c.getConstructor();
      init.setAccessible(true);
      Object o = init.newInstance();
      invokeFromData(o, in);
      return o;
    }
     catch (EOFException | SocketException ex) {
      throw ex;
    }
     catch (Exception ex) {
      throw new SerializationException( String.format("Could not create an instance of %s .", c.getName()), ex);
    }
    
  }
  
  public static void writeArrayLength(int len, DataOutput out) throws IOException {
    if (len == -1) {
      out.writeByte(StaticSerialization.NULL_ARRAY);
    }
     else if (len <= StaticSerialization.MAX_BYTE_ARRAY_LEN) {
      out.writeByte(len);
    }
     else if (len <= 0xFFFF) {
      out.writeByte(StaticSerialization.SHORT_ARRAY_LEN);
      out.writeShort(len);
    }
     else {
      out.writeByte(StaticSerialization.INT_ARRAY_LEN);
      out.writeInt(len);
    }
    
  }
  
  public static int readArrayLength(DataInput in) throws IOException {
    byte code = in.readByte();
    if (code == StaticSerialization.NULL_ARRAY) {
      return -1;
    }
     else {
      int result = ubyteToInt(code);
      if (result > StaticSerialization.MAX_BYTE_ARRAY_LEN) {
        if (code == StaticSerialization.SHORT_ARRAY_LEN) {
          return in.readUnsignedShort();
        }
         else if (code == StaticSerialization.INT_ARRAY_LEN) {
          return in.readInt();
        }
         else {
          throw new IllegalStateException("unexpected array length code=" + code);
        }
        
      }
      
      return result;
    }
    
  }
  
  private static Object readDSFID(final DataInput in, DSCODE dscode) throws IOException, ClassNotFoundException {
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "readDSFID: header={}", dscode);
    }
    
    switch (dscode) {
      case DS_FIXED_ID_BYTE:
        return dsfidFactory.create(in.readByte(), in);
      case DS_FIXED_ID_SHORT:
        return dsfidFactory.create(in.readShort(), in);
      case DS_NO_FIXED_ID:
        return readDataSerializable(in);
      case DS_FIXED_ID_INT:
        return dsfidFactory.create(in.readInt(), in);
      default: throw new IllegalStateException("unexpected byte: " + dscode + " while reading dsfid");
    }
    
  }
  
  public static Object readDSFID(final DataInput in) throws IOException, ClassNotFoundException {
    checkIn(in);
    return readDSFID(in, DscodeHelper.toDSCODE(in.readByte()));
  }
  
  private static String readString(DataInput in, DSCODE dscode) throws IOException {
    switch (dscode) {
      case STRING_BYTES:
        return readStringBytesFromDataInput(in, in.readUnsignedShort());
      case STRING:
        return readStringUTFFromDataInput(in);
      case NULL_STRING: {
        if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Reading NULL_STRING");
        }
        
        return null;
      }
      
      case HUGE_STRING_BYTES:
        return readStringBytesFromDataInput(in, in.readInt());
      case HUGE_STRING:
        return readHugeStringFromDataInput(in);
      default: throw new IOException("Unknown String header " + dscode);
    }
    
  }
  
  private static String readHugeStringFromDataInput(DataInput in) throws IOException {
    int len = in.readInt();
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Reading HUGE_STRING of len={}", len);
    }
    
    char[] buf = new char[len];
    for (int i = 0; i < len; i++) {
      buf[i] = in.readChar();
    }
    
    return new String(buf);
  }
  
  private static String readStringUTFFromDataInput(DataInput in) throws IOException {
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Reading utf STRING");
    }
    
    return in.readUTF();
  }
  
  private static String readStringBytesFromDataInput(DataInput dataInput, int len) throws IOException {
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Reading STRING_BYTES of len={}", len);
    }
    
    if (len == 0) {
      return "";
    }
    
    byte[] buf = StaticSerialization.getThreadLocalByteArray(len);
    dataInput.readFully(buf, 0, len);
    return new String(buf, 0, 0, len); 
  }
  
  public static String readString(DataInput in, byte header) throws IOException {
    return StaticSerialization.readString(in, header);
  }
  
  public static <T> T readNonPdxInstanceObject(final DataInput in) throws IOException, ClassNotFoundException {
    boolean wouldReadSerialized = PdxInstanceImpl.getPdxReadSerialized();
    if (!wouldReadSerialized) {
      return DataSerializer.readObject(in);
    }
     else {
      PdxInstanceImpl.setPdxReadSerialized(false);
      try {
        return DataSerializer.readObject(in);
      }
       finally {
        PdxInstanceImpl.setPdxReadSerialized(true);
      }
      
    }
    
  }
  
  public static Object basicReadObject(final DataInput in) throws IOException, ClassNotFoundException {
    checkIn(in);
    byte header = in.readByte();
    DSCODE headerDSCode = DscodeHelper.toDSCODE(header);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "basicReadObject: header={}", header);
    }
    
    if (headerDSCode == null) {
      throw new IOException("Unknown header byte: " + header);
    }
    
    switch (headerDSCode) {
      case DS_FIXED_ID_BYTE:
        return dsfidFactory.create(in.readByte(), in);
      case DS_FIXED_ID_SHORT:
        return dsfidFactory.create(in.readShort(), in);
      case DS_FIXED_ID_INT:
        return dsfidFactory.create(in.readInt(), in);
      case DS_NO_FIXED_ID:
      case DATA_SERIALIZABLE:
        return readDataSerializable(in);
      case NULL:
      case NULL_STRING:
        return null;
      case STRING:
        return readStringUTFFromDataInput(in);
      case HUGE_STRING:
        return readHugeStringFromDataInput(in);
      case STRING_BYTES:
        return readStringBytesFromDataInput(in, in.readUnsignedShort());
      case HUGE_STRING_BYTES:
        return readStringBytesFromDataInput(in, in.readInt());
      case CLASS:
        return readClass(in);
      case DATE:
        return readDate(in);
      case FILE:
        return readFile(in);
      case INET_ADDRESS:
        return readInetAddress(in);
      case BOOLEAN:
        return readBoolean(in);
      case CHARACTER:
        return readCharacter(in);
      case BYTE:
        return readByte(in);
      case SHORT:
        return readShort(in);
      case INTEGER:
        return readInteger(in);
      case LONG:
        return readLong(in);
      case FLOAT:
        return readFloat(in);
      case DOUBLE:
        return readDouble(in);
      case BYTE_ARRAY:
        return readByteArray(in);
      case ARRAY_OF_BYTE_ARRAYS:
        return readArrayOfByteArrays(in);
      case SHORT_ARRAY:
        return readShortArray(in);
      case STRING_ARRAY:
        return readStringArray(in);
      case INT_ARRAY:
        return readIntArray(in);
      case LONG_ARRAY:
        return readLongArray(in);
      case FLOAT_ARRAY:
        return readFloatArray(in);
      case DOUBLE_ARRAY:
        return readDoubleArray(in);
      case BOOLEAN_ARRAY:
        return readBooleanArray(in);
      case CHAR_ARRAY:
        return readCharArray(in);
      case OBJECT_ARRAY:
        return readObjectArray(in);
      case ARRAY_LIST:
        return readArrayList(in);
      case LINKED_LIST:
        return readLinkedList(in);
      case HASH_SET:
        return readHashSet(in);
      case LINKED_HASH_SET:
        return readLinkedHashSet(in);
      case HASH_MAP:
        return readHashMap(in);
      case IDENTITY_HASH_MAP:
        return readIdentityHashMap(in);
      case HASH_TABLE:
        return readHashtable(in);
      case CONCURRENT_HASH_MAP:
        return readConcurrentHashMap(in);
      case PROPERTIES:
        return readProperties(in);
      case TIME_UNIT:
        return readTimeUnit(in);
      case USER_CLASS:
        return readUserObject(in, in.readByte());
      case USER_CLASS_2:
        return readUserObject(in, in.readShort());
      case USER_CLASS_4:
        return readUserObject(in, in.readInt());
      case VECTOR:
        return readVector(in);
      case STACK:
        return readStack(in);
      case TREE_MAP:
        return readTreeMap(in);
      case TREE_SET:
        return readTreeSet(in);
      case BOOLEAN_TYPE:
        return Boolean.TYPE;
      case CHARACTER_TYPE:
        return Character.TYPE;
      case BYTE_TYPE:
        return Byte.TYPE;
      case SHORT_TYPE:
        return Short.TYPE;
      case INTEGER_TYPE:
        return Integer.TYPE;
      case LONG_TYPE:
        return Long.TYPE;
      case FLOAT_TYPE:
        return Float.TYPE;
      case DOUBLE_TYPE:
        return Double.TYPE;
      case VOID_TYPE:
        return Void.TYPE;
      case USER_DATA_SERIALIZABLE:
        return readUserDataSerializable(in, in.readByte());
      case USER_DATA_SERIALIZABLE_2:
        return readUserDataSerializable(in, in.readShort());
      case USER_DATA_SERIALIZABLE_4:
        return readUserDataSerializable(in, in.readInt());
      case SERIALIZABLE:
        return readSerializable(in);
      case PDX:
        return readPdxSerializable(in);
      case PDX_ENUM:
        return readPdxEnum(in);
      case GEMFIRE_ENUM:
        return readGemFireEnum(in);
      case PDX_INLINE_ENUM:
        return readPdxInlineEnum(in);
      case BIG_INTEGER:
        return readBigInteger(in);
      case BIG_DECIMAL:
        return readBigDecimal(in);
      case UUID:
        return readUUID(in);
      case TIMESTAMP:
        return readTimestamp(in);
      default: throw new IOException("Unknown header byte: " + header);
    }
    
  }
  
  private static Serializable readSerializable(DataInput in) throws IOException, ClassNotFoundException {
    final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE);
    Serializable serializableResult;
    if (in instanceof DSObjectInputStream) {
      serializableResult = (Serializable) ((DSObjectInputStream) in).readObject();
    }
     else {
      InputStream stream;
      if (in instanceof InputStream) {
        stream = (InputStream) in;
      }
       else {
        stream = new InputStream() {
          public int read() throws IOException {
            try {
              return in.readUnsignedByte(); 
            }
             catch (EOFException ignored) {
              return -1;
            }
            
          }
          
        };
      }
      
      ObjectInput ois = new DSObjectInputStream(stream);
      serializationFilter.setFilterOn((ObjectInputStream) ois);
      if (stream instanceof VersionedDataStream) {
        KnownVersion v = ((VersionedDataStream) stream).getVersion();
        if (KnownVersion.CURRENT != v && v != null) {
          ois = new VersionedObjectInput(ois, v);
        }
        
      }
      
      serializableResult = (Serializable) ois.readObject();
      if (isDebugEnabled_SERIALIZER) {
        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Serializable object: {}", serializableResult);
      }
      
    }
    
    if (isDebugEnabled_SERIALIZER) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "deserialized instanceof {}", serializableResult.getClass());
    }
    
    return serializableResult;
  }
  
  private static Object readUserDataSerializable(final DataInput in, int classId) throws IOException {
    Instantiator instantiator = InternalInstantiator.getInstantiator(classId);
    if (instantiator == null) {
      logger.error(LogMarker.SERIALIZER_MARKER, "No Instantiator has been registered for class with id {}", classId);
      throw new IOException( String.format("No Instantiator has been registered for class with id %s", classId));
    }
     else {
      try {
        DataSerializable ds;
        if (instantiator instanceof CanonicalInstantiator) {
          CanonicalInstantiator ci = (CanonicalInstantiator) instantiator;
          ds = ci.newInstance(in);
        }
         else {
          ds = instantiator.newInstance();
        }
        
        ds.fromData(in);
        return ds;
      }
       catch (Exception ex) {
        throw new SerializationException( String.format("Could not deserialize an instance of %s", instantiator.getInstantiatedClass().getName()), ex);
      }
      
    }
    
  }
  
  public static boolean isPdxSerializationInProgress() {
    Boolean v = pdxSerializationInProgress.get();
    return v != null && v;
  }
  
  public static void setPdxSerializationInProgress(boolean inProgress) {
    pdxSerializationInProgress.set(inProgress);
  }
  
  public static boolean writePdx(DataOutput out, InternalCache internalCache, Object pdx, PdxSerializer pdxSerializer) throws IOException {
    if (pdxSerializer != null && isGemfireObject(pdx)) {
      return false;
    }
    
    TypeRegistry tr = null;
    if (internalCache != null) {
      tr = internalCache.getPdxRegistry();
    }
    
    PdxOutputStream os;
    if (out instanceof HeapDataOutputStream) {
      os = new PdxOutputStream((HeapDataOutputStream) out);
    }
     else {
      os = new PdxOutputStream();
    }
    
    PdxWriterImpl writer = new PdxWriterImpl(tr, pdx, os);
    try {
      if (pdxSerializer != null) {
        if (is662SerializationEnabled()) {
          boolean alreadyInProgress = isPdxSerializationInProgress();
          if (!alreadyInProgress) {
            setPdxSerializationInProgress(true);
            try {
              if (!pdxSerializer.toData(pdx, writer)) {
                return false;
              }
              
            }
             finally {
              setPdxSerializationInProgress(false);
            }
            
          }
           else {
            if (!pdxSerializer.toData(pdx, writer)) {
              return false;
            }
            
          }
          
        }
         else {
          if (!pdxSerializer.toData(pdx, writer)) {
            return false;
          }
          
        }
        
      }
       else {
        if (is662SerializationEnabled()) {
          boolean alreadyInProgress = isPdxSerializationInProgress();
          if (!alreadyInProgress) {
            setPdxSerializationInProgress(true);
            try {
              ((PdxSerializable) pdx).toData(writer);
            }
             finally {
              setPdxSerializationInProgress(false);
            }
            
          }
           else {
            ((PdxSerializable) pdx).toData(writer);
          }
          
        }
         else {
          ((PdxSerializable) pdx).toData(writer);
        }
        
      }
      
    }
     catch (ToDataException | CancelException | NonPortableClassException | GemFireRethrowable ex) {
      throw ex;
    }
     catch (VirtualMachineError err) {
      SystemFailure.initiateFailure(err);
      throw err;
    }
     catch (Throwable t) {
      SystemFailure.checkFailure();
      if (pdxSerializer != null) {
        throw new ToDataException("PdxSerializer failed when calling toData on " + pdx.getClass(), t);
      }
       else {
        throw new ToDataException("toData failed on PdxSerializable " + pdx.getClass(), t);
      }
      
    }
    
    int bytesWritten = writer.completeByteStreamGeneration();
    getDMStats(internalCache).incPdxSerialization(bytesWritten);
    if (!(out instanceof HeapDataOutputStream)) {
      writer.sendTo(out);
    }
    
    return true;
  }
  
  public static DMStats getDMStats(InternalCache internalCache) {
    if (internalCache != null) {
      return internalCache.getDistributionManager().getStats();
    }
     else {
      DMStats result = InternalDistributedSystem.getDMStats();
      if (result == null) {
        result = new LonerDistributionManager.DummyDMStats();
      }
      
      return result;
    }
    
  }
  
  private static Object readPdxSerializable(final DataInput in) throws IOException, ClassNotFoundException {
    int len = in.readInt();
    int typeId = in.readInt();
    InternalCache internalCache = GemFireCacheImpl .getForPdx("PDX registry is unavailable because the Cache has been closed.");
    PdxType pdxType = internalCache.getPdxRegistry().getType(typeId);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "readPdxSerializable pdxType={}", pdxType);
    }
    
    if (pdxType == null) {
      throw new IllegalStateException("Unknown pdx type=" + typeId);
    }
    
    DMStats dmStats = getDMStats(internalCache);
    dmStats.incPdxDeserialization(len + 9);
    if (pdxType.getNoDomainClass() || internalCache.getPdxReadSerializedByAnyGemFireServices()) {
      dmStats.incPdxInstanceCreations();
      return new PdxInstanceImpl(pdxType, in, len);
    }
     else {
      PdxReaderImpl pdxReader = new PdxReaderImpl(pdxType, in, len);
      return pdxReader.getObject();
    }
    
  }
  
  public static PdxInstance readPdxInstance(final byte[] dataBytes, InternalCache internalCache) {
    try {
      byte type = dataBytes[0];
      if (type == DSCODE.PDX.toByte()) {
        PdxInputStream in = new PdxInputStream(dataBytes);
        in.readByte(); 
        int len = in.readInt();
        int typeId = in.readInt();
        PdxType pdxType = internalCache.getPdxRegistry().getType(typeId);
        if (pdxType == null) {
          throw new IllegalStateException("Unknown pdx type=" + typeId);
        }
        
        return new PdxInstanceImpl(pdxType, in, len);
      }
       else if (type == DSCODE.PDX_ENUM.toByte()) {
        try (PdxInputStream in = new PdxInputStream(dataBytes)) {
          in.readByte(); 
          int dsId = in.readByte();
          int tmp = readArrayLength(in);
          int enumId = dsId << 24 | tmp & 0xFFFFFF;
          TypeRegistry tr = internalCache.getPdxRegistry();
          EnumInfo ei = tr.getEnumInfoById(enumId);
          if (ei == null) {
            throw new IllegalStateException("Unknown pdx enum id=" + enumId);
          }
          
          return ei.getPdxInstance(enumId);
        }
        
      }
       else if (type == DSCODE.PDX_INLINE_ENUM.toByte()) {
        try (PdxInputStream in = new PdxInputStream(dataBytes)) {
          in.readByte(); 
          String className = DataSerializer.readString(in);
          String enumName = DataSerializer.readString(in);
          int enumOrdinal = InternalDataSerializer.readArrayLength(in);
          return new PdxInstanceEnum(className, enumName, enumOrdinal);
        }
        
      }
      
    }
     catch (IOException ignore) {
    }
    
    return null;
  }
  
  public static int getLoadedDataSerializers() {
    return idsToSerializers.size();
  }
  
  public static Map getDsClassesToHoldersMap() {
    return dsClassesToHolders;
  }
  
  public static Map getIdsToHoldersMap() {
    return idsToHolders;
  }
  
  public static Map getSupportedClassesToHoldersMap() {
    return supportedClassesToHolders;
  }
  
  public static void writeObjectArray(Object[] array, DataOutput out, boolean ensureCompatibility) throws IOException {
    InternalDataSerializer.checkOut(out);
    int length = -1;
    if (array != null) {
      length = array.length;
    }
    
    InternalDataSerializer.writeArrayLength(length, out);
    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing Object array of length {}", length);
    }
    
    if (length >= 0) {
      writeClass(array.getClass().getComponentType(), out);
      for (int i = 0; i < length; i++) {
        basicWriteObject(array[i], out, ensureCompatibility);
      }
      
    }
    
  }
  
  public static void writeVLOld(long data, DataOutput out) throws IOException {
    if (data < 0) {
      Assert.fail("Data expected to be >=0 is " + data);
    }
    
    if (data <= StaticSerialization.MAX_BYTE_VL) {
      out.writeByte((byte) data);
    }
     else if (data <= 0x7FFF) {
      out.write(((int) data >>> 8 | 0x80) & 0xFF);
      out.write((int) data & 0xFF);
    }
     else if (data <= Integer.MAX_VALUE) {
      out.writeByte(StaticSerialization.INT_VL);
      out.writeInt((int) data);
    }
     else {
      out.writeByte(StaticSerialization.LONG_VL);
      out.writeLong(data);
    }
    
  }
  
  public static long readVLOld(DataInput in) throws IOException {
    byte code = in.readByte();
    long result;
    if (code < 0) {
      result = code & 0x7F;
      result <<= 8;
      result |= in.readByte() & 0xFF;
    }
     else if (code <= StaticSerialization.MAX_BYTE_VL) {
      result = code;
    }
     else if (code == StaticSerialization.INT_VL) {
      result = in.readInt();
    }
     else {
      result = in.readLong();
    }
    
    return result;
  }
  
  public static void writeUnsignedVL(long data, DataOutput out) throws IOException {
    while (true) {
      if ((data & ~0x7FL) == 0) {
        out.writeByte((int) data);
        return;
      }
       else {
        out.writeByte((int) data & 0x7F | 0x80);
        data >>>= 7;
      }
      
    }
    
  }
  
  public static long readUnsignedVL(DataInput in) throws IOException {
    int shift = 0;
    long result = 0;
    while (shift < 64) {
      final byte b = in.readByte();
      result |= (long) (b & 0x7F) << shift;
      if ((b & 0x80) == 0) {
        return result;
      }
      
      shift += 7;
    }
    
    throw new GemFireIOException("Malformed variable length integer");
  }
  
  public static void writeSignedVL(long data, DataOutput out) throws IOException {
    writeUnsignedVL(encodeZigZag64(data), out);
  }
  
  public static long readSignedVL(DataInput in) throws IOException {
    return decodeZigZag64(readUnsignedVL(in));
  }
  
  private static long decodeZigZag64(final long n) {
    return n >>> 1 ^ -(n & 1);
  }
  
  private static long encodeZigZag64(final long n) {
    return n << 1 ^ n >> 63;
  }
  
  public static int calculateBytesForTSandDSID(int dsid) {
    HeapDataOutputStream out = new HeapDataOutputStream(4 + 8, KnownVersion.CURRENT);
    long now = System.currentTimeMillis();
    try {
      writeUnsignedVL(now, out);
      writeUnsignedVL(InternalDataSerializer.encodeZigZag64(dsid), out);
    }
     catch (IOException ignored) {
      return 0;
    }
    
    return out.size();
  }
  
  public static <T> Class<T> getCachedClass(String p_className) throws ClassNotFoundException {
    String className = processIncomingClassName(p_className);
    if (LOAD_CLASS_EACH_TIME) {
      return (Class<T>) ClassPathLoader.getLatest().forName(className);
    }
     else {
      Class<?> result = getExistingCachedClass(className);
      if (result == null) {
        result = ClassPathLoader.getLatest().forName(className);
        synchronized (cacheAccessLock) {
          Class<?> cachedClass = getExistingCachedClass(className);
          if (cachedClass == null) {
            classCache.put(className, new WeakReference<>(result));
          }
           else {
            result = cachedClass;
          }
          
        }
        
      }
      
      return (Class<T>) result;
    }
    
  }
  
  private static Class<?> getExistingCachedClass(String className) {
    WeakReference<Class<?>> wr = classCache.get(className);
    Class<?> result = null;
    if (wr != null) {
      result = wr.get();
    }
    
    return result;
  }
  
  public static void flushClassCache() {
    if (classCache != null) {
      classCache.clear();
    }
    
  }
  
  public static DSFIDSerializer getDSFIDSerializer() {
    return dsfidSerializer;
  }
  
  public static DeserializationContext createDeserializationContext(DataInput in) {
    return dsfidSerializer.createDeserializationContext(in);
  }
  
  public static SerializationContext createSerializationContext(DataOutput out) {
    return dsfidSerializer.createSerializationContext(out);
  }
  
  public static DSFIDFactory getDSFIDFactory() {
    return dsfidFactory;
  }
  
  private enum SERIALIZATION_VERSION {
    vINVALID, v660, v662 }
  public interface RegistrationListener {
    void newInstantiator(Instantiator instantiator);
    void newDataSerializer(DataSerializer ds);
  }
  
  public static class SerializerAttributesHolder {
    private String className = "";
    private EventID eventId = null;
    private ClientProxyMembershipID proxyId = null;
    private int id = 0;
    SerializerAttributesHolder() {}
    SerializerAttributesHolder(String name, EventID event, ClientProxyMembershipID proxy, int id) {
      this.className = name;
      this.eventId = event;
      this.proxyId = proxy;
      this.id = id;
    }
    
    public String getClassName() {
      return this.className;
    }
    
    public EventID getEventId() {
      return this.eventId;
    }
    
    public ClientProxyMembershipID getProxyId() {
      return this.proxyId;
    }
    
    public int getId() {
      return this.id;
    }
    
    public String toString() {
      return "SerializerAttributesHolder[name=" + this.className + ",id=" + this.id + ",eventId=" + this.eventId + ']';
    }
    
  }
  
  abstract static class Marker {
    protected DataSerializer serializer = null;
    boolean hasBeenSet = false;
    abstract DataSerializer getSerializer();
    void setSerializer(DataSerializer serializer) {
      synchronized (this) {
        this.hasBeenSet = true;
        this.serializer = serializer;
        this.notifyAll();
      }
      
    }
    
  }
  
  public static class GetMarker extends Marker {
    public static int WAIT_MS = Integer.getInteger( GeodeGlossary.GEMFIRE_PREFIX + "InternalDataSerializer.WAIT_MS", 60 * 1000);
    @Override
    DataSerializer getSerializer() {
      synchronized (this) {
        boolean firstTime = true;
        long endTime = 0;
        while (!this.hasBeenSet) {
          if (firstTime) {
            firstTime = false;
            endTime = System.currentTimeMillis() + WAIT_MS;
          }
          
          try {
            long remainingMs = endTime - System.currentTimeMillis();
            if (remainingMs > 0) {
              this.wait(remainingMs); 
            }
             else {
              setSerializer(null);
              break;
            }
            
          }
           catch (InterruptedException ignored) {
            Thread.currentThread().interrupt();
            return null;
          }
          
        }
        
        return this.serializer;
      }
      
    }
    
  }
  
  static class InitMarker extends Marker {
    @Override
    DataSerializer getSerializer() {
      synchronized (this) {
        while (!this.hasBeenSet) {
          try {
            this.wait(); 
          }
           catch (InterruptedException ignored) {
            Thread.currentThread().interrupt();
            return null;
          }
          
        }
        
        return this.serializer;
      }
      
    }
    
  }
  
  public static class RegistrationMessage extends SerialDistributionMessage {
    private static final KnownVersion[] dsfidVersions = new KnownVersion[] {};
    protected EventID eventId;
    private int id;
    private String className;
    public RegistrationMessage() {}
    public RegistrationMessage(DataSerializer s) {
      this.className = s.getClass().getName();
      this.id = s.getId();
      this.eventId = (EventID) s.getEventId();
    }
    
    static String getFullMessage(Throwable t) {
      StringBuffer sb = new StringBuffer();
      getFullMessage(sb, t);
      return sb.toString();
    }
    
    private static void getFullMessage(StringBuffer sb, Throwable t) {
      if (t.getMessage() != null) {
        sb.append(t.getMessage());
      }
       else {
        sb.append(t.getClass());
      }
      
      if (t.getCause() != null) {
        sb.append(" caused by: ");
        getFullMessage(sb, t.getCause());
      }
      
    }
    
    protected void process(ClusterDistributionManager dm) {
      if (CacheClientNotifier.getInstance() != null) {
        Class<? extends DataSerializer> c;
        try {
          c = getCachedClass(this.className);
        }
         catch (ClassNotFoundException ex) {
          logger.warn( "Could not load data serializer class {} so both clients of this server and this server will not have this data serializer. Load failed because: {}", this.className, getFullMessage(ex));
          return;
        }
        
        DataSerializer s;
        try {
          s = newInstance(c);
        }
         catch (IllegalArgumentException ex) {
          logger.warn( "Could not create an instance of data serializer for class {} so both clients of this server and this server will not have this data serializer. Create failed because: {}", this.className, getFullMessage(ex));
          return;
        }
        
        s.setEventId(this.eventId);
        try {
          InternalDataSerializer._register(s, false);
        }
         catch (IllegalArgumentException | IllegalStateException ex) {
          logger.warn( "Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}", this.className, getFullMessage(ex));
        }
        
      }
       else {
        try {
          InternalDataSerializer.register(this.className, false, this.eventId, null, this.id);
        }
         catch (IllegalArgumentException | IllegalStateException ex) {
          logger.warn( "Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}", this.className, getFullMessage(ex));
        }
        
      }
      
    }
    
    public int getDSFID() {
      return IDS_REGISTRATION_MESSAGE;
    }
    
    public void toData(DataOutput out, SerializationContext context) throws IOException {
      super.toData(out, context);
      DataSerializer.writeNonPrimitiveClassName(this.className, out);
      out.writeInt(this.id);
      DataSerializer.writeObject(this.eventId, out);
    }
    
    public void fromData(DataInput in, DeserializationContext context) throws IOException, ClassNotFoundException {
      super.fromData(in, context);
      InternalDataSerializer.checkIn(in);
      this.className = DataSerializer.readNonPrimitiveClassName(in);
      this.id = in.readInt();
      this.eventId = DataSerializer.readObject(in);
    }
    
    public String toString() {
      return String.format("Register DataSerializer %s of class %s", this.id, this.className);
    }
    
    public KnownVersion[] getSerializationVersions() {
      return dsfidVersions;
    }
    
  }
  
  private static class DSObjectInputStream extends ObjectInputStream {
    DSObjectInputStream(InputStream stream) throws IOException {
      super(stream);
    }
    
    protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
      String className = desc.getName();
      OldClientSupportService svc = getOldClientSupportService();
      if (svc != null) {
        className = svc.processIncomingClassName(className);
      }
      
      try {
        return getCachedClass(className);
      }
       catch (ClassNotFoundException ignored) {
        return super.resolveClass(desc);
      }
      
    }
    
    protected Class resolveProxyClass(String[] interfaces) throws ClassNotFoundException {
      ClassLoader nonPublicLoader = null;
      boolean hasNonPublicInterface = false;
      Class[] classObjs = new Class[interfaces.length];
      for (int i = 0; i < interfaces.length; i++) {
        Class cl = getCachedClass(interfaces[i]);
        if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {
          if (hasNonPublicInterface) {
            if (nonPublicLoader != cl.getClassLoader()) {
              String s = "conflicting non-public interface class loaders";
              throw new IllegalAccessError(s);
            }
            
          }
           else {
            nonPublicLoader = cl.getClassLoader();
            hasNonPublicInterface = true;
          }
          
        }
        
        classObjs[i] = cl;
      }
      
      try {
        if (hasNonPublicInterface) {
          return Proxy.getProxyClass(nonPublicLoader, classObjs);
        }
         else {
          return ClassPathLoader.getLatest().getProxyClass(classObjs);
        }
        
      }
       catch (IllegalArgumentException e) {
        throw new ClassNotFoundException(null, e);
      }
      
    }
    
  }
  
  protected abstract static class WellKnownDS extends DataSerializer {
    public int getId() {
      return 0;
    }
    
    public Class[] getSupportedClasses() {
      return null;
    }
    
    public Object fromData(DataInput in) throws IOException, ClassNotFoundException {
      throw new IllegalStateException("Should not be invoked");
    }
    
  }
  
  abstract static class WellKnownPdxDS extends WellKnownDS {
  }
  
}


