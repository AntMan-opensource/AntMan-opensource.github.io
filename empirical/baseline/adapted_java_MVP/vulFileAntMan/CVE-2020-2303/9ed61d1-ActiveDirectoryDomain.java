package hudson.plugins.active_directory;
import hudson.Extension;
import hudson.Functions;
import hudson.model.AbstractDescribableImpl;
import hudson.model.Descriptor;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import hudson.util.Secret;
import jenkins.model.Jenkins;
import org.acegisecurity.BadCredentialsException;
import org.apache.commons.lang.StringUtils;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.QueryParameter;
import javax.naming.CommunicationException;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.ServiceUnavailableException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.servlet.ServletException;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import static hudson.plugins.active_directory.ActiveDirectoryUnixAuthenticationProvider.toDC;
public class ActiveDirectoryDomain extends AbstractDescribableImpl<ActiveDirectoryDomain> implements Serializable {
    public String name;
    public String servers;
    public String site;
    public String bindName;
    public Secret bindPassword;
    protected TlsConfiguration tlsConfiguration;
    public enum Catalog {
        GC("_gc._tcp."), LDAP("_ldap._tcp.");
        private final String name;
        Catalog(String s) {
            name = s;
        }
        
        public String toString() {
            return this.name;
        }
        
    }
    
    public ActiveDirectoryDomain(String name, String servers) {
        this(name, servers, null, null, null);
    }
    
    public ActiveDirectoryDomain(String name, String servers, String site, String bindName, String bindPassword) {
        this(name, servers, site, bindName, bindPassword, TlsConfiguration.TRUST_ALL_CERTIFICATES);
    }
    
    public ActiveDirectoryDomain(String name, String servers, String site, String bindName, String bindPassword, TlsConfiguration tlsConfiguration) {
        this.name = name;
        servers = fixEmpty(servers);
        if (servers != null) {
            String[] serversArray = servers.split(",");
            for (int i = 0; i < serversArray.length; i++) {
                if (!serversArray[i].contains(":")) {
                    serversArray[i] += ":3268";
                }
                
            }
            
            servers = StringUtils.join(serversArray, ",");
        }
        
        this.servers = servers;
        this.site = fixEmpty(site);
        this.bindName = fixEmpty(bindName);
        this.bindPassword = Secret.fromString(fixEmpty(bindPassword));
        this.tlsConfiguration = tlsConfiguration;
    }
    
    public String getName() {
        return name;
    }
    
    public String getServers() {
        return servers;
    }
    
    public String getBindName() {
        return bindName;
    }
    
    public Secret getBindPassword() {
        return bindPassword;
    }
    
    public String getSite() {
        return site;
    }
    
    public TlsConfiguration getTlsConfiguration() {
        return tlsConfiguration;
    }
    
    public Attribute getRecordFromDomain(){
        DirContext ictx;
        Attribute a = null;
        try {
            LOGGER.log(Level.FINE, "Attempting to resolve {0} to NS record", name);
            ictx = createDNSLookupContext();
            Attributes attributes = ictx.getAttributes(name, new String[]{"NS"});
            a = attributes.get("NS");
            if (a == null) {
                LOGGER.log(Level.FINE, "Attempting to resolve {0} to A record", name);
                attributes = ictx.getAttributes(name, new String[]{"A"});
                a = attributes.get("A");
                if (a == null) {
                    throw new NamingException(name + " doesn't look like a domain name");
                }
                
            }
            
            LOGGER.log(Level.FINE, "{0} resolved to {1}", new Object[]{name, a});
        }
         catch (NamingException e) {
            LOGGER.log(Level.WARNING, String.format("Failed to resolve %s to A record", name), e);
        }
        
        return a;
    }
    
    public DirContext createDNSLookupContext() throws NamingException {
        Hashtable env = new Hashtable();
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory");
        env.put("java.naming.provider.url", "dns:");
        return new InitialDirContext(env);
    }
    
    public Attribute getServersOnCatalog(String catalog) {
        catalog = Catalog.valueOf(catalog).toString();
        String ldapServer = catalog + (site != null ? site + "._sites." : "") + this.name;
        LOGGER.log(Level.FINE, "Attempting to resolve {0} to SRV record", ldapServer);
        try {
            Attributes attributes = createDNSLookupContext().getAttributes(ldapServer, new String[] { "SRV" });
            return attributes.get("SRV");
        }
         catch (NamingException | NumberFormatException e) {
            LOGGER.log(Level.WARNING, String.format("Failed to resolve %s", ldapServer), e);
        }
        
        return null;
    }
    
    public static String fixEmpty(String s) {
        if(s==null || s.length()==0)    return null;
        return s;
    }
    
    public static class DescriptorImpl extends Descriptor<ActiveDirectoryDomain> {
        public String getDisplayName() { return ""; }
        public ListBoxModel doFillTlsConfigurationItems() {
            ListBoxModel model = new ListBoxModel();
            for (TlsConfiguration tlsConfiguration : TlsConfiguration.values()) {
                model.add(tlsConfiguration.getDisplayName(),tlsConfiguration.name());
            }
            
            return model;
        }
        
        public FormValidation doValidateTest(@QueryParameter(fixEmpty = true) String name, @QueryParameter(fixEmpty = true) String servers, @QueryParameter(fixEmpty = true) String site, @QueryParameter(fixEmpty = true) String bindName, @QueryParameter(fixEmpty = true) String bindPassword, @QueryParameter(fixEmpty = true) TlsConfiguration tlsConfiguration) throws IOException, ServletException, NamingException {
            ActiveDirectoryDomain domain = new ActiveDirectoryDomain(name, servers, site, bindName, bindPassword, tlsConfiguration);
            List<ActiveDirectoryDomain> domains = new ArrayList<>(1);
            domains.add(domain);
            ActiveDirectorySecurityRealm activeDirectorySecurityRealm = new ActiveDirectorySecurityRealm(null, domains, site, bindName, bindPassword, null, GroupLookupStrategy.AUTO, false, true, null, false, (ActiveDirectoryInternalUsersDatabase) null);
            ClassLoader ccl = Thread.currentThread().getContextClassLoader();
            Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
            try {
                Functions.checkPermission(Jenkins.ADMINISTER);
                if (activeDirectorySecurityRealm.getDescriptor().canDoNativeAuth() && name==null) {
                    try {
                        new ActiveDirectoryAuthenticationProvider();
                        return FormValidation.ok("Success");
                    }
                     catch (Exception e) {
                        return FormValidation.error(e, "Failed to contact Active Directory");
                    }
                    
                }
                
                if (name==null || name.isEmpty()) {
                    return FormValidation.error("No domain was set");
                }
                
                if (StringUtils.isBlank(bindName)) {
                    return FormValidation.warningWithMarkup("Leaving blank <b>`Bind DN`</b> means that any operation performed will use anonymous binding. Keep in mind that this is not recommended as some servers <a href=\"https://support.microsoft.com/en-us/help/326690/anonymous-ldap-operations-to-active-directory-are-disabled-on-windows\">do not allow it by default.</a>");
                }
                
                Attribute domainAttribute = domain.getRecordFromDomain();
                if (servers != null && servers.isEmpty() && domainAttribute == null || servers == null && domainAttribute == null ) {
                    return FormValidation.error(name + " doesn't look like a valid domain name");
                }
                
                Secret password = Secret.fromString(bindPassword);
                DirContext ictx = activeDirectorySecurityRealm.getDescriptor().createDNSLookupContext();
                List<SocketInfo> obtainerServers;
                try {
                    obtainerServers = activeDirectorySecurityRealm.getDescriptor().obtainLDAPServer(ictx, name, site, servers);
                }
                 catch (NamingException e) {
                    String msg = site == null ? "No LDAP server was found in " + name : "No LDAP server was found in the " + site + " site of " + name;
                    LOGGER.log(Level.WARNING, msg, e);
                    return FormValidation.error(e, msg);
                }
                
                if (bindName != null) {
                    try {
                        Hashtable<String, String> props = new Hashtable<>(0);
                        DirContext context = activeDirectorySecurityRealm.getDescriptor().bind(bindName, Secret.toString(password), obtainerServers, props, tlsConfiguration);
                        try {
                            Attributes userAttributes = new LDAPSearchBuilder(context, toDC(name)).subTreeScope().searchOne("(objectClass=user)");
                            if (userAttributes == null) {
                                return FormValidation.error(Messages.ActiveDirectorySecurityRealm_NoUsers());
                            }
                            
                        }
                         finally {
                            context.close();
                        }
                        
                    }
                     catch (BadCredentialsException e) {
                        Throwable t = e.getCause();
                        if (t instanceof CommunicationException) {
                            return FormValidation.error(e, "Any Domain Controller is reachable");
                        }
                        
                        return FormValidation.error(e, "Bad bind username or password");
                    }
                     catch (javax.naming.AuthenticationException e) {
                        return FormValidation.error(e, "Bad bind username or password");
                    }
                     catch (ServiceUnavailableException e) {
                        return FormValidation.error(e, "Domain Controller is reachable but the service on the specified port is not reachable");
                    }
                     catch (Exception e) {
                        return FormValidation.error(e, e.getMessage());
                    }
                    
                }
                 else {
                    IOException error = null;
                    for (SocketInfo si : obtainerServers) {
                        try {
                            si.connect().close();
                            break; 
                        }
                         catch (IOException e) {
                            LOGGER.log(Level.FINE, String.format("Failed to connect to %s", si), e);
                            error = e;
                        }
                        
                    }
                    
                    if (error != null) {
                        LOGGER.log(Level.WARNING, String.format("Failed to connect to %s", servers), error);
                        return FormValidation.error(error, "Failed to connect to " + servers);
                    }
                    
                }
                
                if (domainAttribute == null) {
                    return FormValidation.warning("Success - but " + name + " does not look like a valid domain name");
                }
                
                return FormValidation.ok("Success");
            }
             finally {
                Thread.currentThread().setContextClassLoader(ccl);
            }
            
        }
        
    }
    
    private static final Logger LOGGER = Logger.getLogger(ActiveDirectoryUnixAuthenticationProvider.class.getName());
}


