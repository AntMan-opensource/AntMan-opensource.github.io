package io.jenkins.plugins.analysis.core.model; 
import java.io.Serializable;
import java.lang.ref.WeakReference;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.factory.Maps;
import edu.hm.hafner.analysis.Report;
import edu.hm.hafner.analysis.Severity;
import edu.hm.hafner.echarts.Build;
import edu.hm.hafner.util.VisibleForTesting;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.jenkinsci.plugins.scriptsecurity.sandbox.whitelists.Whitelisted;
import hudson.model.Run;
import io.jenkins.plugins.analysis.core.charts.JenkinsBuild;
import io.jenkins.plugins.analysis.core.util.IssuesStatistics;
import io.jenkins.plugins.analysis.core.util.IssuesStatisticsBuilder;
import io.jenkins.plugins.analysis.core.util.QualityGateEvaluator;
import io.jenkins.plugins.analysis.core.util.QualityGateStatus;
import io.jenkins.plugins.analysis.core.util.StaticAnalysisRun;
import io.jenkins.plugins.forensics.blame.Blames;
import io.jenkins.plugins.forensics.blame.BlamesXmlStream;
import io.jenkins.plugins.forensics.miner.RepositoryStatistics;
import io.jenkins.plugins.forensics.miner.RepositoryStatisticsXmlStream;
import io.jenkins.plugins.util.JenkinsFacade;
@SuppressFBWarnings(value = "SE, DESERIALIZATION_GADGET", justification = "transient fields are restored using a Jenkins callback (or are checked for null)")
@SuppressWarnings({"PMD.TooManyFields", "PMD.ExcessiveClassLength", "PMD.GodClass", "checkstyle:ClassFanOutComplexity"})
public class AnalysisResult implements Serializable, StaticAnalysisRun {
    private static final long serialVersionUID = 1110545450292087475L;
    private static final Pattern ISSUES_FILE_NAME = Pattern.compile("issues.xml", Pattern.LITERAL);
    private static final int NO_BUILD = -1;
    private static final String NO_REFERENCE = StringUtils.EMPTY;
    private final String id;
    private IssuesStatistics totals;
    private final Map<String, Integer> sizePerOrigin;
    private final List<String> errors;
    private final List<String> messages;
    private final String referenceBuildId;
    private transient ReentrantLock lock = new ReentrantLock();
    private transient Run<?, ?> owner;
    private transient WeakReference<Report> outstandingIssuesReference;
    private transient WeakReference<Report> newIssuesReference;
    private transient WeakReference<Report> fixedIssuesReference;
    private transient WeakReference<Blames> blamesReference;
    private transient WeakReference<RepositoryStatistics> repositoryStatistics;
    private int noIssuesSinceBuild;
    private int successfulSinceBuild;
    private final QualityGateStatus qualityGateStatus;
    public AnalysisResult(final Run<?, ?> owner, final String id, final DeltaReport report, final Blames blames, final RepositoryStatistics totals, final QualityGateStatus qualityGateStatus, final Map<String, Integer> sizePerOrigin, final AnalysisResult previousResult) {
        this(owner, id, report, blames, totals, qualityGateStatus, sizePerOrigin, true);
        if (report.isEmpty()) {
            if (previousResult.noIssuesSinceBuild == NO_BUILD) {
                noIssuesSinceBuild = owner.getNumber();
            }
            
            else {
                noIssuesSinceBuild = previousResult.noIssuesSinceBuild;
            }
            
        }
        
        else {
            noIssuesSinceBuild = NO_BUILD;
        }
        
        if (this.qualityGateStatus == QualityGateStatus.PASSED) {
            if (previousResult.qualityGateStatus == QualityGateStatus.PASSED) {
                successfulSinceBuild = previousResult.successfulSinceBuild;
            }
            
            else {
                successfulSinceBuild = owner.getNumber();
            }
            
        }
        
        else {
            successfulSinceBuild = NO_BUILD;
        }
        
    }
    
    public AnalysisResult(final Run<?, ?> owner, final String id, final DeltaReport report, final Blames blames, final RepositoryStatistics totals, final QualityGateStatus qualityGateStatus, final Map<String, Integer> sizePerOrigin) {
        this(owner, id, report, blames, totals, qualityGateStatus, sizePerOrigin, true);
        if (report.isEmpty()) {
            noIssuesSinceBuild = owner.getNumber();
        }
        
        else {
            noIssuesSinceBuild = NO_BUILD;
        }
        
        if (this.qualityGateStatus == QualityGateStatus.PASSED) {
            successfulSinceBuild = owner.getNumber();
        }
        
        else {
            successfulSinceBuild = NO_BUILD;
        }
        
    }
    
    protected AnalysisResult(final Run<?, ?> owner, final String id, final DeltaReport report, final Blames blames, final RepositoryStatistics repositoryStatistics, final QualityGateStatus qualityGateStatus, final Map<String, Integer> sizePerOrigin, final boolean canSerialize) {
        this.owner = owner;
        Report allIssues = report.getAllIssues();
        this.id = id;
        totals = report.getStatistics();
        this.sizePerOrigin = new HashMap<>(sizePerOrigin);
        referenceBuildId = report.getReferenceBuildId();
        Report outstandingIssues = report.getOutstandingIssues();
        outstandingIssuesReference = new WeakReference<>(outstandingIssues);
        Report newIssues = report.getNewIssues();
        newIssuesReference = new WeakReference<>(newIssues);
        Report fixedIssues = report.getFixedIssues();
        fixedIssuesReference = new WeakReference<>(fixedIssues);
        List<String> aggregatedMessages = new ArrayList<>(allIssues.getInfoMessages());
        messages = new ArrayList<>(aggregatedMessages);
        errors = new ArrayList<>(allIssues.getErrorMessages());
        this.qualityGateStatus = qualityGateStatus;
        blamesReference = new WeakReference<>(blames);
        this.repositoryStatistics = new WeakReference<>(repositoryStatistics);
        if (canSerialize) {
            serializeIssues(outstandingIssues, newIssues, fixedIssues);
            serializeBlames(blames);
            serializeStatistics(repositoryStatistics);
        }
        
    }
    
    protected Object readResolve() {
        if (totals == null) {
            IssuesStatisticsBuilder builder = new IssuesStatisticsBuilder();
            builder.setTotalErrorSize(sizePerSeverity.getOrDefault(Severity.ERROR, 0));
            builder.setTotalHighSize(sizePerSeverity.getOrDefault(Severity.WARNING_HIGH, 0));
            builder.setTotalNormalSize(sizePerSeverity.getOrDefault(Severity.WARNING_NORMAL, 0));
            builder.setTotalLowSize(sizePerSeverity.getOrDefault(Severity.WARNING_LOW, 0));
            builder.setNewErrorSize(newSizePerSeverity.getOrDefault(Severity.ERROR, 0));
            builder.setNewHighSize(newSizePerSeverity.getOrDefault(Severity.WARNING_HIGH, 0));
            builder.setNewNormalSize(newSizePerSeverity.getOrDefault(Severity.WARNING_NORMAL, 0));
            builder.setNewLowSize(newSizePerSeverity.getOrDefault(Severity.WARNING_LOW, 0));
            builder.setFixedSize(fixedSize);
            totals = builder.build();
        }
        
        return this;
    }
    
    public Blames getBlames() {
        lock.lock();
        try {
            if (blamesReference == null) {
                return readBlames();
            }
            
            Blames result = blamesReference.get();
            if (result == null) {
                return readBlames();
            }
            
            return result;
        }
        
        finally {
            lock.unlock();
        }
        
    }
    
    public RepositoryStatistics getForensics() {
        lock.lock();
        try {
            if (repositoryStatistics == null) {
                return readStatistics();
            }
            
            RepositoryStatistics result = repositoryStatistics.get();
            if (result == null) {
                return readStatistics();
            }
            
            return result;
        }
        
        finally {
            lock.unlock();
        }
        
    }
    
    private void serializeBlames(final Blames blames) {
        new BlamesXmlStream().write(getBlamesPath(), blames);
    }
    
    private Path getBlamesPath() {
        return getOwner().getRootDir().toPath().resolve(id + "-blames.xml");
    }
    
    private Blames readBlames() {
        Blames blames = new BlamesXmlStream().read(getBlamesPath());
        blamesReference = new WeakReference<>(blames);
        return blames;
    }
    
    private void serializeStatistics(final RepositoryStatistics statistics) {
        new RepositoryStatisticsXmlStream().write(getStatisticsPath(), statistics);
    }
    
    private Path getStatisticsPath() {
        return getOwner().getRootDir().toPath().resolve(id + "-forensics.xml");
    }
    
    private RepositoryStatistics readStatistics() {
        RepositoryStatistics statistics = new RepositoryStatisticsXmlStream().read(getStatisticsPath());
        repositoryStatistics = new WeakReference<>(statistics);
        return statistics;
    }
    
    public String getId() {
        return id;
    }
    
    public Run<?, ?> getOwner() {
        return owner;
    }
    
    public void setOwner(final Run<?, ?> owner) {
        this.owner = owner;
        lock = new ReentrantLock();
    }
    
    public ImmutableList<String> getErrorMessages() {
        return Lists.immutable.withAll(errors);
    }
    
    public ImmutableList<String> getInfoMessages() {
        return Lists.immutable.withAll(messages);
    }
    
    private String getSerializationFileName() {
        return id + "-issues.xml";
    }
    
    private void serializeIssues(final Report outstandingIssues, final Report newIssues, final Report fixedIssues) {
        serializeIssues(outstandingIssues, "outstanding");
        serializeIssues(newIssues, "new");
        serializeIssues(fixedIssues, "fixed");
    }
    
    private void serializeIssues(final Report report, final String suffix) {
        new ReportXmlStream().write(getReportPath(suffix), report);
    }
    
    private Path getReportPath(final String suffix) {
        return getOwner().getRootDir().toPath().resolve(ISSUES_FILE_NAME.matcher(getSerializationFileName()) .replaceAll(Matcher.quoteReplacement(suffix + "-issues.xml")));
    }
    
    public Report getIssues() {
        Report merged = new Report();
        merged.addAll(getNewIssues(), getOutstandingIssues());
        return merged;
    }
    
    public boolean isEmpty() {
        return getTotals().getTotalSize() + getTotals().getFixedSize() == 0;
    }
    
    public boolean hasNoNewWarnings() {
        return getTotals().getNewSize() == 0;
    }
    
    public Report getOutstandingIssues() {
        return getIssues(AnalysisResult::getOutstandingIssuesReference, AnalysisResult::setOutstandingIssuesReference, "outstanding");
    }
    
    public Report getNewIssues() {
        return getIssues(AnalysisResult::getNewIssuesReference, AnalysisResult::setNewIssuesReference, "new");
    }
    
    public Report getFixedIssues() {
        return getIssues(AnalysisResult::getFixedIssuesReference, AnalysisResult::setFixedIssuesReference, "fixed");
    }
    
    private WeakReference<Report> getOutstandingIssuesReference() {
        return outstandingIssuesReference;
    }
    
    private void setOutstandingIssuesReference(final WeakReference<Report> outstandingIssuesReference) {
        this.outstandingIssuesReference = outstandingIssuesReference;
    }
    
    private WeakReference<Report> getNewIssuesReference() {
        return newIssuesReference;
    }
    
    private void setNewIssuesReference(final WeakReference<Report> newIssuesReference) {
        this.newIssuesReference = newIssuesReference;
    }
    
    private WeakReference<Report> getFixedIssuesReference() {
        return fixedIssuesReference;
    }
    
    private void setFixedIssuesReference(final WeakReference<Report> fixedIssuesReference) {
        this.fixedIssuesReference = fixedIssuesReference;
    }
    
    private Report getIssues(final Function<AnalysisResult, WeakReference<Report>> getter, final BiConsumer<AnalysisResult, WeakReference<Report>> setter, final String suffix) {
        lock.lock();
        try {
            if (getter.apply(this) == null) {
                return readIssues(setter, suffix);
            }
            
            Report result = getter.apply(this).get();
            if (result == null) {
                return readIssues(setter, suffix);
            }
            
            return result;
        }
        
        finally {
            lock.unlock();
        }
        
    }
    
    private Report readIssues(final BiConsumer<AnalysisResult, WeakReference<Report>> setter, final String suffix) {
        Report report = new ReportXmlStream().read(getReportPath(suffix));
        setter.accept(this, new WeakReference<>(report));
        return report;
    }
    
    public int getNoIssuesSinceBuild() {
        return noIssuesSinceBuild;
    }
    
    public int getSuccessfulSinceBuild() {
        return successfulSinceBuild;
    }
    
    public boolean isSuccessful() {
        return qualityGateStatus.isSuccessful();
    }
    
    public QualityGateStatus getQualityGateStatus() {
        return qualityGateStatus;
    }
    
    public String toString() {
        return getId() + " : " + getTotalSize() + " issues";
    }
    
    public Optional<Run<?, ?>> getReferenceBuild() {
        if (NO_REFERENCE.equals(referenceBuildId)) {
            return Optional.empty();
        }
        
        return new JenkinsFacade().getBuild(referenceBuildId);
    }
    
    public IssuesStatistics getTotals() {
        return totals;
    }
    
    public Map<String, Integer> getSizePerOrigin() {
        return Maps.immutable.ofAll(sizePerOrigin).toMap();
    }
    
    public Map<Severity, Integer> getSizePerSeverity() {
        return totals.getTotalSizePerSeverity().toMap();
    }
    
    public Map<Severity, Integer> getNewSizePerSeverity() {
        return totals.getTotalSizePerSeverity().toMap();
    }
    
    public int getTotalSize() {
        return totals.getTotalSize();
    }
    
    public int getTotalSizeOf(final Severity severity) {
        return totals.getTotalSizeOf(severity);
    }
    
    public int getTotalErrorsSize() {
        return getTotalSizeOf(Severity.ERROR);
    }
    
    public int getTotalHighPrioritySize() {
        return getTotalSizeOf(Severity.WARNING_HIGH);
    }
    
    public int getTotalNormalPrioritySize() {
        return getTotalSizeOf(Severity.WARNING_NORMAL);
    }
    
    public int getTotalLowPrioritySize() {
        return getTotalSizeOf(Severity.WARNING_LOW);
    }
    
    public int getNewSize() {
        return totals.getNewSize();
    }
    
    public int getNewSizeOf(final Severity severity) {
        return totals.getNewSizeOf(severity);
    }
    
    public int getNewErrorSize() {
        return getNewSizeOf(Severity.ERROR);
    }
    
    public int getNewHighPrioritySize() {
        return getNewSizeOf(Severity.WARNING_HIGH);
    }
    
    public int getNewNormalPrioritySize() {
        return getNewSizeOf(Severity.WARNING_NORMAL);
    }
    
    public int getNewLowPrioritySize() {
        return getNewSizeOf(Severity.WARNING_LOW);
    }
    
    public int getFixedSize() {
        return totals.getFixedSize();
    }
    
    public int getDeltaSize() {
        return totals.getDeltaSize();
    }
    
    private transient int size;
    private transient int newSize;
    private transient int fixedSize;
    @SuppressWarnings({"DeprecatedIsStillUsed", "MismatchedQueryAndUpdateOfCollection"})
    private final Map<Severity, Integer> sizePerSeverity = new HashMap<>();
    @SuppressWarnings({"DeprecatedIsStillUsed", "MismatchedQueryAndUpdateOfCollection"})
    private final Map<Severity, Integer> newSizePerSeverity = new HashMap<>();
    public Build getBuild() {
        return new JenkinsBuild(getOwner());
    }
    
}


