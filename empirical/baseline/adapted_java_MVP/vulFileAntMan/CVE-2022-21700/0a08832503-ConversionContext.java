package io.micronaut.core.convert;
import io.micronaut.core.annotation.AnnotationMetadataProvider;
import io.micronaut.core.type.Argument;
import io.micronaut.core.type.TypeVariableResolver;
import io.micronaut.core.util.ArgumentUtils;
import io.micronaut.core.util.ArrayUtils;
import io.micronaut.core.annotation.Nullable;
import java.lang.annotation.Annotation;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.*;
public interface ConversionContext extends AnnotationMetadataProvider, TypeVariableResolver, ErrorsContext {
    ConversionContext DEFAULT = new ConversionContext() {     };
    ArgumentConversionContext<Boolean> BOOLEAN = ConversionContext.of(Argument.BOOLEAN);
    ArgumentConversionContext<Integer> INT = ConversionContext.of(Argument.INT);
    ArgumentConversionContext<Long> LONG = ConversionContext.of(Argument.LONG);
    ArgumentConversionContext<String> STRING = ConversionContext.of(Argument.STRING);
    ArgumentConversionContext<List<String>> LIST_OF_STRING = ConversionContext.of(Argument.LIST_OF_STRING);
    ArgumentConversionContext<Map> MAP = ConversionContext.of(Argument.of(Map.class));
    @Override
    default Map<String, Argument<?>> getTypeVariables() {
        return Collections.emptyMap();
    }
    
    default Locale getLocale() {
        return Locale.getDefault();
    }
    
    default Charset getCharset() {
        return StandardCharsets.UTF_8;
    }
    
    @SuppressWarnings("unchecked")
    default <T> ArgumentConversionContext<T> with(Argument<T> argument) {
        ConversionContext childContext = ConversionContext.of(argument);
        ConversionContext thisContext = this;
        return new DefaultArgumentConversionContext(argument, thisContext.getLocale(), thisContext.getCharset()) {
            public <T extends Annotation> T synthesize(Class<T> annotationClass) {
                T annotation = childContext.synthesize(annotationClass);
                if (annotation == null) {
                    return thisContext.synthesize(annotationClass);
                }
                
                return annotation;
            }
            
            public Annotation[] synthesizeAll() {
                return ArrayUtils.concat(childContext.synthesizeAll(), thisContext.synthesizeAll());
            }
            
            public Annotation[] synthesizeDeclared() {
                return ArrayUtils.concat(childContext.synthesizeDeclared(), thisContext.synthesizeDeclared());
            }
            
            public void reject(Exception exception) {
                thisContext.reject(exception);
            }
            
            public void reject(Object value, Exception exception) {
                thisContext.reject(value, exception);
            }
            
            public Iterator<ConversionError> iterator() {
                return thisContext.iterator();
            }
            
            public Optional<ConversionError> getLastError() {
                return thisContext.getLastError();
            }
            
        };
    }
    
    static ConversionContext of(Map<String, Argument<?>> typeVariables) {
        return new ConversionContext() {
            public Map<String, Argument<?>> getTypeVariables() {
                return typeVariables;
            }
            
        };
    }
    
    static <T> ArgumentConversionContext<T> of(Argument<T> argument) {
        return of(argument, null, null);
    }
    
    static <T> ArgumentConversionContext<T> of(Class<T> argument) {
        ArgumentUtils.requireNonNull("argument", argument);
        return of(Argument.of(argument), null, null);
    }
    
    static <T> ArgumentConversionContext of(Argument<T> argument, @Nullable Locale locale) {
        return of(argument, locale, null);
    }
    
    static <T> ArgumentConversionContext<T> of(Argument<T> argument, @Nullable Locale locale, @Nullable Charset charset) {
        ArgumentUtils.requireNonNull("argument", argument);
        Charset finalCharset = charset != null ? charset : StandardCharsets.UTF_8;
        Locale finalLocale = locale != null ? locale : Locale.getDefault();
        return new DefaultArgumentConversionContext<>(argument, finalLocale, finalCharset);
    }
    
}


