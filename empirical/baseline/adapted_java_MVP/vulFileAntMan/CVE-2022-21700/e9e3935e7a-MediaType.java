package io.micronaut.http;
import io.micronaut.core.annotation.Internal;
import io.micronaut.core.annotation.NonNull;
import io.micronaut.core.annotation.TypeHint;
import io.micronaut.core.convert.ArgumentConversionContext;
import io.micronaut.core.convert.ConversionContext;
import io.micronaut.core.convert.ConversionService;
import io.micronaut.core.naming.NameUtils;
import io.micronaut.core.type.Argument;
import io.micronaut.core.util.CollectionUtils;
import io.micronaut.core.util.StringUtils;
import io.micronaut.core.value.OptionalValues;
import io.micronaut.http.annotation.Produces;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Pattern;
@TypeHint(value = MediaType[].class)
public class MediaType implements CharSequence {
    public static final String EXTENSION_JSON = "json";
    public static final String EXTENSION_XML = "xml";
    public static final String EXTENSION_PDF = "pdf";
    public static final String EXTENSION_XLSX = "xlsx";
    public static final String EXTENSION_XLS = "xls";
    public static final MediaType[] EMPTY_ARRAY = new MediaType[0];
    public static final String ALL = "*/*";
    public static final MediaType ALL_TYPE = new MediaType(ALL, "all");
    public static final String APPLICATION_FORM_URLENCODED = "application/x-www-form-urlencoded";
    public static final MediaType APPLICATION_FORM_URLENCODED_TYPE = new MediaType(APPLICATION_FORM_URLENCODED);
    public static final MediaType FORM = APPLICATION_FORM_URLENCODED_TYPE;
    public static final String MULTIPART_FORM_DATA = "multipart/form-data";
    public static final MediaType MULTIPART_FORM_DATA_TYPE = new MediaType(MULTIPART_FORM_DATA);
    public static final String TEXT_HTML = "text/html";
    public static final MediaType TEXT_HTML_TYPE = new MediaType(TEXT_HTML);
    public static final String TEXT_CSV = "text/csv";
    public static final MediaType TEXT_CSV_TYPE = new MediaType(TEXT_CSV);
    public static final String APPLICATION_XHTML = "application/xhtml+xml";
    public static final MediaType APPLICATION_XHTML_TYPE = new MediaType(APPLICATION_XHTML, "html");
    public static final String APPLICATION_XML = "application/xml";
    public static final MediaType APPLICATION_XML_TYPE = new MediaType(APPLICATION_XML);
    public static final String APPLICATION_JSON = "application/json";
    public static final MediaType APPLICATION_JSON_TYPE = new MediaType(MediaType.APPLICATION_JSON);
    public static final String APPLICATION_YAML = "application/x-yaml";
    public static final MediaType APPLICATION_YAML_TYPE = new MediaType(MediaType.APPLICATION_YAML);
    public static final String MICROSOFT_EXCEL_OPEN_XML = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    public static final MediaType MICROSOFT_EXCEL_OPEN_XML_TYPE = new MediaType(MICROSOFT_EXCEL_OPEN_XML, EXTENSION_XLSX);
    public static final String MICROSOFT_EXCEL = "application/vnd.ms-excel";
    public static final MediaType MICROSOFT_EXCEL_TYPE = new MediaType(MICROSOFT_EXCEL, EXTENSION_XLS);
    public static final String TEXT_XML = "text/xml";
    public static final MediaType TEXT_XML_TYPE = new MediaType(TEXT_XML);
    public static final String TEXT_JSON = "text/json";
    public static final MediaType TEXT_JSON_TYPE = new MediaType(TEXT_JSON);
    public static final String TEXT_PLAIN = "text/plain";
    public static final MediaType TEXT_PLAIN_TYPE = new MediaType(TEXT_PLAIN);
    public static final String APPLICATION_HAL_JSON = "application/hal+json";
    public static final MediaType APPLICATION_HAL_JSON_TYPE = new MediaType(APPLICATION_HAL_JSON);
    public static final String APPLICATION_HAL_XML = "application/hal+xml";
    public static final MediaType APPLICATION_HAL_XML_TYPE = new MediaType(APPLICATION_HAL_XML);
    public static final String APPLICATION_ATOM_XML = "application/atom+xml";
    public static final MediaType APPLICATION_ATOM_XML_TYPE = new MediaType(APPLICATION_ATOM_XML);
    public static final String APPLICATION_VND_ERROR = "application/vnd.error+json";
    public static final MediaType APPLICATION_VND_ERROR_TYPE = new MediaType(APPLICATION_VND_ERROR);
    public static final String TEXT_EVENT_STREAM = "text/event-stream";
    public static final MediaType TEXT_EVENT_STREAM_TYPE = new MediaType(TEXT_EVENT_STREAM);
    public static final String APPLICATION_JSON_STREAM = "application/x-json-stream";
    public static final MediaType APPLICATION_JSON_STREAM_TYPE = new MediaType(APPLICATION_JSON_STREAM);
    public static final String APPLICATION_OCTET_STREAM = "application/octet-stream";
    public static final MediaType APPLICATION_OCTET_STREAM_TYPE = new MediaType(APPLICATION_OCTET_STREAM);
    public static final String APPLICATION_GRAPHQL = "application/graphql";
    public static final MediaType APPLICATION_GRAPHQL_TYPE = new MediaType(APPLICATION_GRAPHQL);
    public static final String APPLICATION_PDF = "application/pdf";
    public static final MediaType APPLICATION_PDF_TYPE = new MediaType(APPLICATION_PDF);
    public static final String IMAGE_PNG = "image/png";
    public static final MediaType IMAGE_PNG_TYPE = new MediaType(IMAGE_PNG);
    public static final String IMAGE_JPEG = "image/jpeg";
    public static final MediaType IMAGE_JPEG_TYPE = new MediaType(IMAGE_JPEG);
    public static final String IMAGE_GIF = "image/gif";
    public static final MediaType IMAGE_GIF_TYPE = new MediaType(IMAGE_GIF);
    public static final String IMAGE_WEBP = "image/webp";
    public static final MediaType IMAGE_WEBP_TYPE = new MediaType(IMAGE_WEBP);
    public static final String CHARSET_PARAMETER = "charset";
    public static final String Q_PARAMETER = "q";
    public static final String V_PARAMETER = "v";
    @Internal
    static final Argument<MediaType> ARGUMENT = Argument.of(MediaType.class);
    @Internal
    static final ArgumentConversionContext<MediaType> CONVERSION_CONTEXT = ConversionContext.of(ARGUMENT);
    private static final char SEMICOLON = ';';
    private static final String MIME_TYPES_FILE_NAME = "META-INF/http/mime.types";
    private static Map<String, String> mediaTypeFileExtensions;
    private static final List<Pattern> textTypePatterns = new ArrayList<>(4);
    protected final String name;
    protected final String subtype;
    protected final String type;
    protected final String extension;
    protected final Map<CharSequence, String> parameters;
    private final String strRepr;
    private BigDecimal qualityNumberField = BigDecimal.ONE;
    static {
        ConversionService.SHARED.addConverter(CharSequence.class, MediaType.class, charSequence -> {
                    if (StringUtils.isNotEmpty(charSequence)) {
                        return of(charSequence.toString());
                    }
                    
                    return null;
                }
                 );
        textTypePatterns.add(Pattern.compile("^text/.*$"));
        textTypePatterns.add(Pattern.compile("^.*\\+json$"));
        textTypePatterns.add(Pattern.compile("^.*\\+text$"));
        textTypePatterns.add(Pattern.compile("^.*\\+xml$"));
        textTypePatterns.add(Pattern.compile("^application/javascript$"));
    }
    
    public MediaType(String name) {
        this(name, null, Collections.emptyMap());
    }
    
    public MediaType(String name, Map<String, String> params) {
        this(name, null, params);
    }
    
    public MediaType(String name, String extension) {
        this(name, extension, Collections.emptyMap());
    }
    
    public MediaType(String name, String extension, Map<String, String> params) {
        if (name == null) {
            throw new IllegalArgumentException("Argument [name] cannot be null");
        }
        
        name = name.trim();
        String withoutArgs;
        Iterator<String> splitIt = StringUtils.splitOmitEmptyStringsIterator(name, SEMICOLON);
        if (splitIt.hasNext()) {
            withoutArgs = splitIt.next();
            if (splitIt.hasNext()) {
                Map<CharSequence, String> parameters = null;
                while (splitIt.hasNext()) {
                    String paramExpression = splitIt.next();
                    int i = paramExpression.indexOf('=');
                    if (i > -1) {
                        String paramName = paramExpression.substring(0, i).trim();
                        String paramValue = paramExpression.substring(i + 1).trim();
                        if ("q".equals(paramName)) {
                            qualityNumberField = new BigDecimal(paramValue);
                        }
                        
                        if (parameters == null) {
                            parameters = new LinkedHashMap<>();
                        }
                        
                        parameters.put(paramName, paramValue);
                    }
                    
                }
                
                if (parameters == null) {
                    parameters = Collections.emptyMap();
                }
                
                this.parameters = parameters;
            }
             else if (params == null) {
                this.parameters = Collections.emptyMap();
            }
             else {
                this.parameters = (Map) params;
            }
            
        }
         else {
            if (params == null) {
                this.parameters = Collections.emptyMap();
            }
             else {
                this.parameters = (Map) params;
            }
            
            withoutArgs = name;
        }
        
        this.name = withoutArgs;
        int i = withoutArgs.indexOf('/');
        if (i > -1) {
            this.type = withoutArgs.substring(0, i);
            this.subtype = withoutArgs.substring(i + 1);
        }
         else {
            throw new IllegalArgumentException("Invalid mime type: " + name);
        }
        
        if (extension != null) {
            this.extension = extension;
        }
         else {
            int j = subtype.indexOf('+');
            if (j > -1) {
                this.extension = subtype.substring(j + 1);
            }
             else {
                this.extension = subtype;
            }
            
        }
        
        this.strRepr = toString0();
    }
    
    public static MediaType of(String mediaType) {
        switch (mediaType) {
            case ALL:
                return ALL_TYPE;
            case APPLICATION_FORM_URLENCODED:
                return APPLICATION_FORM_URLENCODED_TYPE;
            case MULTIPART_FORM_DATA:
                return MULTIPART_FORM_DATA_TYPE;
            case TEXT_HTML:
                return TEXT_HTML_TYPE;
            case TEXT_CSV:
                return TEXT_CSV_TYPE;
            case APPLICATION_XHTML:
                return APPLICATION_XHTML_TYPE;
            case APPLICATION_XML:
                return APPLICATION_XML_TYPE;
            case APPLICATION_JSON:
                return APPLICATION_JSON_TYPE;
            case APPLICATION_YAML:
                return APPLICATION_YAML_TYPE;
            case TEXT_XML:
                return TEXT_XML_TYPE;
            case TEXT_JSON:
                return TEXT_JSON_TYPE;
            case TEXT_PLAIN:
                return TEXT_PLAIN_TYPE;
            case APPLICATION_HAL_JSON:
                return APPLICATION_HAL_JSON_TYPE;
            case APPLICATION_HAL_XML:
                return APPLICATION_HAL_XML_TYPE;
            case APPLICATION_ATOM_XML:
                return APPLICATION_ATOM_XML_TYPE;
            case APPLICATION_VND_ERROR:
                return APPLICATION_VND_ERROR_TYPE;
            case TEXT_EVENT_STREAM:
                return TEXT_EVENT_STREAM_TYPE;
            case APPLICATION_JSON_STREAM:
                return APPLICATION_JSON_STREAM_TYPE;
            case APPLICATION_OCTET_STREAM:
                return APPLICATION_OCTET_STREAM_TYPE;
            case APPLICATION_GRAPHQL:
                return APPLICATION_GRAPHQL_TYPE;
            case APPLICATION_PDF:
                return APPLICATION_PDF_TYPE;
            case IMAGE_PNG:
                return IMAGE_PNG_TYPE;
            case IMAGE_JPEG:
                return IMAGE_JPEG_TYPE;
            case IMAGE_GIF:
                return IMAGE_GIF_TYPE;
            case IMAGE_WEBP:
                return IMAGE_WEBP_TYPE;
            default: return new MediaType(mediaType);
        }
        
    }
    
    public boolean matches(@NonNull MediaType expectedContentType) {
        if (expectedContentType == null) {
            return false;
        }
        
        if (expectedContentType == this) {
            return true;
        }
        
        String expectedType = expectedContentType.getType();
        String expectedSubtype = expectedContentType.getSubtype();
        boolean typeMatch = type.equals("*") || type.equalsIgnoreCase(expectedType);
        boolean subtypeMatch = subtype.equals("*") || subtype.equalsIgnoreCase(expectedSubtype);
        return typeMatch && subtypeMatch;
    }
    
    public String getName() {
        return name;
    }
    
    public String getType() {
        return this.type;
    }
    
    public String getSubtype() {
        return this.subtype;
    }
    
    public String getExtension() {
        return extension;
    }
    
    public OptionalValues<String> getParameters() {
        return OptionalValues.of(String.class, parameters);
    }
    
    public String getQuality() {
        return qualityNumberField.toString();
    }
    
    public BigDecimal getQualityAsNumber() {
        return this.qualityNumberField;
    }
    
    public String getVersion() {
        return parameters.getOrDefault(V_PARAMETER, null);
    }
    
    public Optional<Charset> getCharset() {
        return getParameters().get(CHARSET_PARAMETER).map(Charset::forName);
    }
    
    public int length() {
        return strRepr.length();
    }
    
    public char charAt(int index) {
        return strRepr.charAt(index);
    }
    
    public CharSequence subSequence(int start, int end) {
        return strRepr.subSequence(start, end);
    }
    
    public boolean isTextBased() {
        boolean matches = textTypePatterns.stream().anyMatch(p -> p.matcher(name).matches());
        if (!matches) {
            matches = subtype.equalsIgnoreCase("json") || subtype.equalsIgnoreCase("xml") || subtype.equalsIgnoreCase("x-yaml");
        }
        
        return matches;
    }
    
    public static boolean isTextBased(String contentType) {
        if (StringUtils.isEmpty(contentType)) {
            return false;
        }
        
        try {
            return of(contentType).isTextBased();
        }
         catch (IllegalArgumentException e) {
            return false;
        }
        
    }
    
    public String toString() {
        return strRepr;
    }
    
    private String toString0() {
        if (parameters.isEmpty()) {
            return name;
        }
         else {
            StringBuilder sb = new StringBuilder(name);
            parameters.forEach((name, value) -> {
                sb.append(";");
                sb.append(name);
                sb.append("=");
                sb.append(value);
            }
            
);
            return sb.toString();
        }
        
    }
    
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        
        MediaType mediaType = (MediaType) o;
        return name.equalsIgnoreCase(mediaType.name);
    }
    
    public int hashCode() {
        return name.hashCode();
    }
    
    public static List<MediaType> orderedOf(CharSequence... values) {
        return orderedOf(Arrays.asList(values));
    }
    
    public static List<MediaType> orderedOf(List<? extends CharSequence> values) {
        if (CollectionUtils.isNotEmpty(values)) {
            List<MediaType> mediaTypes = new LinkedList<>();
            for (CharSequence value : values) {
                for (String token : StringUtils.splitOmitEmptyStrings(value, ',')) {
                    try {
                        mediaTypes.add(MediaType.of(token));
                    }
                     catch (IllegalArgumentException e) {
                    }
                    
                }
                
            }
            
            mediaTypes = new ArrayList<>(mediaTypes);
            mediaTypes.sort((o1, o2) -> {
                if (o1.type.equals("*")) {
                    return 1;
                }
                 else if (o2.type.equals("*")) {
                    return -1;
                }
                
                if (o2.subtype.equals("*") && !o1.subtype.equals("*")) {
                    return -1;
                }
                 else if (o1.subtype.equals("*") && !o2.subtype.equals("*")) {
                    return 1;
                }
                
                return o2.getQualityAsNumber().compareTo(o1.getQualityAsNumber());
            }
            
);
            return Collections.unmodifiableList(mediaTypes);
        }
        
        return Collections.emptyList();
    }
    
    public static MediaType of(CharSequence mediaType) {
        return MediaType.of(mediaType.toString());
    }
    
    public static MediaType[] of(CharSequence... mediaType) {
        MediaType[] types = new MediaType[mediaType.length];
        for (int i = 0; i < mediaType.length; i++) {
            types[i] = MediaType.of(mediaType[i].toString());
        }
        
        return types;
    }
    
    public static Optional<MediaType> fromType(Class<?> type) {
        Produces producesAnn = type.getAnnotation(Produces.class);
        if (producesAnn != null) {
            for (String mimeType : producesAnn.value()) {
                return Optional.of(MediaType.of(mimeType));
            }
            
        }
        
        return Optional.empty();
    }
    
    public static Optional<MediaType> forExtension(String extension) {
        if (StringUtils.isNotEmpty(extension)) {
            String type = getMediaTypeFileExtensions().get(extension);
            if (type != null) {
                return Optional.of(new MediaType(type, extension));
            }
            
        }
        
        return Optional.empty();
    }
    
    public static MediaType forFilename(String filename) {
        if (StringUtils.isNotEmpty(filename)) {
            return forExtension(NameUtils.extension(filename)).orElse(MediaType.TEXT_PLAIN_TYPE);
        }
        
        return MediaType.TEXT_PLAIN_TYPE;
    }
    
    private static Map<String, String> getMediaTypeFileExtensions() {
        Map<String, String> extensions = mediaTypeFileExtensions;
        if (extensions == null) {
            synchronized (MediaType.class) { 
                extensions = mediaTypeFileExtensions;
                if (extensions == null) {
                    try {
                        extensions = loadMimeTypes();
                        mediaTypeFileExtensions = extensions;
                    }
                     catch (Exception e) {
                        mediaTypeFileExtensions = Collections.emptyMap();
                    }
                    
                }
                
            }
            
        }
        
        return extensions;
    }
    
    private static Map<String, String> loadMimeTypes() {
        try (InputStream is = MediaType.class.getClassLoader().getResourceAsStream(MIME_TYPES_FILE_NAME)) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.US_ASCII));
            Map<String, String> result = new LinkedHashMap<>(100);
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty() || line.charAt(0) == '#') {
                    continue;
                }
                
                String formattedLine = line.trim().replaceAll("\\s{2,}", " ").replaceAll("\\s", "|");
                String[] tokens = formattedLine.split("\\|");
                for (int i = 1; i < tokens.length; i++) {
                    String fileExtension = tokens[i].toLowerCase(Locale.ENGLISH);
                    result.put(fileExtension, tokens[0]);
                }
                
            }
            
            return result;
        }
         catch (IOException ex) {
            Logger logger = LoggerFactory.getLogger(MediaType.class);
            if (logger.isWarnEnabled()) {
                logger.warn("Failed to load mime types for file extension detection!");
            }
            
        }
        
        return Collections.emptyMap();
    }
    
}


