package org.apache.hadoop.ozone.om.helpers;
import java.io.IOException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apache.hadoop.fs.FileEncryptionInfo;
import org.apache.hadoop.hdds.protocol.proto.HddsProtos;
import org.apache.hadoop.ozone.OzoneAcl;
import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyInfo;
import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyLocationList;
import org.apache.hadoop.ozone.protocolPB.OMPBHelper;
import org.apache.hadoop.util.Time;
import com.google.common.base.Preconditions;
public final class OmKeyInfo extends WithObjectID {
  private final String volumeName;
  private final String bucketName;
  private String keyName;
  private long dataSize;
  private List<OmKeyLocationInfoGroup> keyLocationVersions;
  private final long creationTime;
  private long modificationTime;
  private HddsProtos.ReplicationType type;
  private HddsProtos.ReplicationFactor factor;
  private FileEncryptionInfo encInfo;
  private List<OzoneAcl> acls;
  @SuppressWarnings("parameternumber")
  OmKeyInfo(String volumeName, String bucketName, String keyName, List<OmKeyLocationInfoGroup> versions, long dataSize, long creationTime, long modificationTime, HddsProtos.ReplicationType type, HddsProtos.ReplicationFactor factor, Map<String, String> metadata, FileEncryptionInfo encInfo, List<OzoneAcl> acls, long objectID, long updateID) {
    this.volumeName = volumeName;
    this.bucketName = bucketName;
    this.keyName = keyName;
    this.dataSize = dataSize;
    long currentVersion = -1;
    for (OmKeyLocationInfoGroup version : versions) {
      Preconditions.checkArgument( currentVersion + 1 == version.getVersion());
      currentVersion = version.getVersion();
    }
    
    this.keyLocationVersions = versions;
    this.creationTime = creationTime;
    this.modificationTime = modificationTime;
    this.factor = factor;
    this.type = type;
    this.metadata = metadata;
    this.encInfo = encInfo;
    this.acls = acls;
    this.objectID = objectID;
    this.updateID = updateID;
  }
  
  public String getVolumeName() {
    return volumeName;
  }
  
  public String getBucketName() {
    return bucketName;
  }
  
  public HddsProtos.ReplicationType getType() {
    return type;
  }
  
  public HddsProtos.ReplicationFactor getFactor() {
    return factor;
  }
  
  public String getKeyName() {
    return keyName;
  }
  
  public void setKeyName(String keyName) {
    this.keyName = keyName;
  }
  
  public long getDataSize() {
    return dataSize;
  }
  
  public void setDataSize(long size) {
    this.dataSize = size;
  }
  
  public synchronized OmKeyLocationInfoGroup getLatestVersionLocations() {
    return keyLocationVersions.size() == 0? null : keyLocationVersions.get(keyLocationVersions.size() - 1);
  }
  
  public List<OmKeyLocationInfoGroup> getKeyLocationVersions() {
    return keyLocationVersions;
  }
  
  public void updateModifcationTime() {
    this.modificationTime = Time.monotonicNow();
  }
  
  public void updateLocationInfoList(List<OmKeyLocationInfo> locationInfoList, boolean isMpu) {
    long latestVersion = getLatestVersionLocations().getVersion();
    OmKeyLocationInfoGroup keyLocationInfoGroup = getLatestVersionLocations();
    keyLocationInfoGroup.setMultipartKey(isMpu);
    keyLocationInfoGroup.removeBlocks(latestVersion);
    locationInfoList.forEach(omKeyLocationInfo -> omKeyLocationInfo .setCreateVersion(latestVersion));
    keyLocationInfoGroup.addAll(latestVersion, locationInfoList);
  }
  
  public synchronized void appendNewBlocks( List<OmKeyLocationInfo> newLocationList, boolean updateTime) throws IOException {
    if (keyLocationVersions.size() == 0) {
      throw new IOException("Appending new block, but no version exist");
    }
    
    OmKeyLocationInfoGroup currentLatestVersion = keyLocationVersions.get(keyLocationVersions.size() - 1);
    currentLatestVersion.appendNewBlocks(newLocationList);
    if (updateTime) {
      setModificationTime(Time.now());
    }
    
  }
  
  public synchronized long addNewVersion( List<OmKeyLocationInfo> newLocationList, boolean updateTime) throws IOException {
    long latestVersionNum;
    if (keyLocationVersions.size() == 0) {
      keyLocationVersions.add(new OmKeyLocationInfoGroup(0, newLocationList));
      latestVersionNum = 0;
    }
     else {
      OmKeyLocationInfoGroup currentLatestVersion = keyLocationVersions.get(keyLocationVersions.size() - 1);
      OmKeyLocationInfoGroup newVersion = currentLatestVersion.generateNextVersion(newLocationList);
      keyLocationVersions.add(newVersion);
      latestVersionNum = newVersion.getVersion();
    }
    
    if (updateTime) {
      setModificationTime(Time.now());
    }
    
    return latestVersionNum;
  }
  
  public long getCreationTime() {
    return creationTime;
  }
  
  public long getModificationTime() {
    return modificationTime;
  }
  
  public void setModificationTime(long modificationTime) {
    this.modificationTime = modificationTime;
  }
  
  public FileEncryptionInfo getFileEncryptionInfo() {
    return encInfo;
  }
  
  public List<OzoneAcl> getAcls() {
    return acls;
  }
  
  public boolean addAcl(OzoneAcl acl) {
    return OzoneAclUtil.addAcl(acls, acl);
  }
  
  public boolean removeAcl(OzoneAcl acl) {
    return OzoneAclUtil.removeAcl(acls, acl);
  }
  
  public boolean setAcls(List<OzoneAcl> newAcls) {
    return OzoneAclUtil.setAcl(acls, newAcls);
  }
  
  public static class Builder {
    private String volumeName;
    private String bucketName;
    private String keyName;
    private long dataSize;
    private List<OmKeyLocationInfoGroup> omKeyLocationInfoGroups = new ArrayList<>();
    private long creationTime;
    private long modificationTime;
    private HddsProtos.ReplicationType type;
    private HddsProtos.ReplicationFactor factor;
    private Map<String, String> metadata;
    private FileEncryptionInfo encInfo;
    private List<OzoneAcl> acls;
    private long objectID;
    private long updateID;
    public Builder() {
      this.metadata = new HashMap<>();
      omKeyLocationInfoGroups = new ArrayList<>();
      acls = new ArrayList<>();
    }
    
    public Builder setVolumeName(String volume) {
      this.volumeName = volume;
      return this;
    }
    
    public Builder setBucketName(String bucket) {
      this.bucketName = bucket;
      return this;
    }
    
    public Builder setKeyName(String key) {
      this.keyName = key;
      return this;
    }
    
    public Builder setOmKeyLocationInfos( List<OmKeyLocationInfoGroup> omKeyLocationInfoList) {
      if (omKeyLocationInfoList != null) {
        this.omKeyLocationInfoGroups.addAll(omKeyLocationInfoList);
      }
      
      return this;
    }
    
    public Builder addOmKeyLocationInfoGroup(OmKeyLocationInfoGroup omKeyLocationInfoGroup) {
      if (omKeyLocationInfoGroup != null) {
        this.omKeyLocationInfoGroups.add(omKeyLocationInfoGroup);
      }
      
      return this;
    }
    
    public Builder setDataSize(long size) {
      this.dataSize = size;
      return this;
    }
    
    public Builder setCreationTime(long crTime) {
      this.creationTime = crTime;
      return this;
    }
    
    public Builder setModificationTime(long mTime) {
      this.modificationTime = mTime;
      return this;
    }
    
    public Builder setReplicationFactor(HddsProtos.ReplicationFactor replFact) {
      this.factor = replFact;
      return this;
    }
    
    public Builder setReplicationType(HddsProtos.ReplicationType replType) {
      this.type = replType;
      return this;
    }
    
    public Builder addMetadata(String key, String value) {
      metadata.put(key, value);
      return this;
    }
    
    public Builder addAllMetadata(Map<String, String> newMetadata) {
      metadata.putAll(newMetadata);
      return this;
    }
    
    public Builder setFileEncryptionInfo(FileEncryptionInfo feInfo) {
      this.encInfo = feInfo;
      return this;
    }
    
    public Builder setAcls(List<OzoneAcl> listOfAcls) {
      if (listOfAcls != null) {
        this.acls.addAll(listOfAcls);
      }
      
      return this;
    }
    
    public Builder addAcl(OzoneAcl ozoneAcl) {
      if (ozoneAcl != null) {
        this.acls.add(ozoneAcl);
      }
      
      return this;
    }
    
    public Builder setObjectID(long obId) {
      this.objectID = obId;
      return this;
    }
    
    public Builder setUpdateID(long id) {
      this.updateID = id;
      return this;
    }
    
    public OmKeyInfo build() {
      return new OmKeyInfo( volumeName, bucketName, keyName, omKeyLocationInfoGroups, dataSize, creationTime, modificationTime, type, factor, metadata, encInfo, acls, objectID, updateID);
    }
    
  }
  
  public KeyInfo getProtobuf(int clientVersion) {
    return getProtobuf(false, clientVersion);
  }
  
  public KeyInfo getProtobuf(boolean ignorePipeline, int clientVersion) {
    long latestVersion = keyLocationVersions.size() == 0 ? -1 : keyLocationVersions.get(keyLocationVersions.size() - 1).getVersion();
    List<KeyLocationList> keyLocations = new ArrayList<>();
    for (OmKeyLocationInfoGroup locationInfoGroup : keyLocationVersions) {
      keyLocations.add(locationInfoGroup.getProtobuf( ignorePipeline, clientVersion));
    }
    
    KeyInfo.Builder kb = KeyInfo.newBuilder() .setVolumeName(volumeName) .setBucketName(bucketName) .setKeyName(keyName) .setDataSize(dataSize) .setFactor(factor) .setType(type) .setLatestVersion(latestVersion) .addAllKeyLocationList(keyLocations) .setCreationTime(creationTime) .setModificationTime(modificationTime) .addAllMetadata(KeyValueUtil.toProtobuf(metadata)) .addAllAcls(OzoneAclUtil.toProtobuf(acls)) .setObjectID(objectID) .setUpdateID(updateID);
    if (encInfo != null) {
      kb.setFileEncryptionInfo(OMPBHelper.convert(encInfo));
    }
    
    return kb.build();
  }
  
  public static OmKeyInfo getFromProtobuf(KeyInfo keyInfo) {
    if (keyInfo == null) {
      return null;
    }
    
    List<OmKeyLocationInfoGroup> omKeyLocationInfos = new ArrayList<>();
    for (KeyLocationList keyLocationList : keyInfo.getKeyLocationListList()) {
      omKeyLocationInfos.add( OmKeyLocationInfoGroup.getFromProtobuf(keyLocationList));
    }
    
    Builder builder = new Builder() .setVolumeName(keyInfo.getVolumeName()) .setBucketName(keyInfo.getBucketName()) .setKeyName(keyInfo.getKeyName()) .setOmKeyLocationInfos(omKeyLocationInfos) .setDataSize(keyInfo.getDataSize()) .setCreationTime(keyInfo.getCreationTime()) .setModificationTime(keyInfo.getModificationTime()) .setReplicationType(keyInfo.getType()) .setReplicationFactor(keyInfo.getFactor()) .addAllMetadata(KeyValueUtil.getFromProtobuf(keyInfo.getMetadataList())) .setFileEncryptionInfo(keyInfo.hasFileEncryptionInfo() ? OMPBHelper.convert(keyInfo.getFileEncryptionInfo()) : null) .setAcls(OzoneAclUtil.fromProtobuf(keyInfo.getAclsList()));
    if (keyInfo.hasObjectID()) {
      builder.setObjectID(keyInfo.getObjectID());
    }
    
    if (keyInfo.hasUpdateID()) {
      builder.setUpdateID(keyInfo.getUpdateID());
    }
    
    return builder.build();
  }
  
  public String getObjectInfo() {
    return "OMKeyInfo{" + "volume='" + volumeName + '\'' + ", bucket='" + bucketName + '\'' + ", key='" + keyName + '\'' + ", dataSize='" + dataSize + '\'' + ", creationTime='" + creationTime + '\'' + ", type='" + type + '\'' + ", factor='" + factor + '\'' + '}';
  }
  
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    
    OmKeyInfo omKeyInfo = (OmKeyInfo) o;
    return dataSize == omKeyInfo.dataSize && creationTime == omKeyInfo.creationTime && modificationTime == omKeyInfo.modificationTime && volumeName.equals(omKeyInfo.volumeName) && bucketName.equals(omKeyInfo.bucketName) && keyName.equals(omKeyInfo.keyName) && Objects .equals(keyLocationVersions, omKeyInfo.keyLocationVersions) && type == omKeyInfo.type && factor == omKeyInfo.factor && Objects.equals(metadata, omKeyInfo.metadata) && Objects.equals(acls, omKeyInfo.acls) && objectID == omKeyInfo.objectID && updateID == omKeyInfo.updateID;
  }
  
  public int hashCode() {
    return Objects.hash(volumeName, bucketName, keyName);
  }
  
  public OmKeyInfo copyObject() {
    OmKeyInfo.Builder builder = new OmKeyInfo.Builder() .setVolumeName(volumeName) .setBucketName(bucketName) .setKeyName(keyName) .setCreationTime(creationTime) .setModificationTime(modificationTime) .setDataSize(dataSize) .setReplicationType(type) .setReplicationFactor(factor) .setFileEncryptionInfo(encInfo) .setObjectID(objectID).setUpdateID(updateID);
    keyLocationVersions.forEach(keyLocationVersion -> builder.addOmKeyLocationInfoGroup( new OmKeyLocationInfoGroup(keyLocationVersion.getVersion(), keyLocationVersion.getLocationList())));
    acls.forEach(acl -> builder.addAcl(new OzoneAcl(acl.getType(), acl.getName(), (BitSet) acl.getAclBitSet().clone(), acl.getAclScope())));
    if (metadata != null) {
      metadata.forEach((k, v) -> builder.addMetadata(k, v));
    }
    
    return builder.build();
  }
  
  public void clearFileEncryptionInfo() {
    this.encInfo = null;
  }
  
}


