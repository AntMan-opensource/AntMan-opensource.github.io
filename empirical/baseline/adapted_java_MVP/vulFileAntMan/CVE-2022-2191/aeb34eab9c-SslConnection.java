package org.eclipse.jetty.io.ssl;
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.ToIntFunction;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLEngineResult.HandshakeStatus;
import javax.net.ssl.SSLEngineResult.Status;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLSession;
import org.eclipse.jetty.io.AbstractConnection;
import org.eclipse.jetty.io.AbstractEndPoint;
import org.eclipse.jetty.io.ByteBufferPool;
import org.eclipse.jetty.io.Connection;
import org.eclipse.jetty.io.EndPoint;
import org.eclipse.jetty.io.RetainableByteBuffer;
import org.eclipse.jetty.io.RetainableByteBufferPool;
import org.eclipse.jetty.io.WriteFlusher;
import org.eclipse.jetty.util.BufferUtil;
import org.eclipse.jetty.util.Callback;
import org.eclipse.jetty.util.StringUtil;
import org.eclipse.jetty.util.thread.AutoLock;
import org.eclipse.jetty.util.thread.Invocable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SslConnection extends AbstractConnection implements Connection.UpgradeTo {
    private static final Logger LOG = LoggerFactory.getLogger(SslConnection.class);
    private static final String TLS_1_3 = "TLSv1.3";
    private enum HandshakeState {
        INITIAL, HANDSHAKE, SUCCEEDED, FAILED }
    private enum FillState {
        IDLE,  INTERESTED,  WAIT_FOR_FLUSH  }
    private enum FlushState {
        IDLE,  WRITING,  WAIT_FOR_FILL  }
    private final AutoLock _lock = new AutoLock();
    private final AtomicReference<HandshakeState> _handshake = new AtomicReference<>(HandshakeState.INITIAL);
    private final List<SslHandshakeListener> handshakeListeners = new ArrayList<>();
    private final AtomicLong _bytesIn = new AtomicLong();
    private final AtomicLong _bytesOut = new AtomicLong();
    private final ByteBufferPool _bufferPool;
    private final RetainableByteBufferPool _retainableByteBufferPool;
    private final SSLEngine _sslEngine;
    private final DecryptedEndPoint _decryptedEndPoint;
    private ByteBuffer _decryptedInput;
    private RetainableByteBuffer _encryptedInput;
    private ByteBuffer _encryptedOutput;
    private final boolean _encryptedDirectBuffers;
    private final boolean _decryptedDirectBuffers;
    private boolean _renegotiationAllowed;
    private int _renegotiationLimit = -1;
    private boolean _closedOutbound;
    private boolean _requireCloseMessage;
    private FlushState _flushState = FlushState.IDLE;
    private FillState _fillState = FillState.IDLE;
    private boolean _underflown;
    private final Runnable _runFillable = new RunnableTask("runFillable") {
        public void run() {
            _decryptedEndPoint.getFillInterest().fillable();
        }
        
        public InvocationType getInvocationType() {
            return _decryptedEndPoint.getFillInterest().getCallbackInvocationType();
        }
        
    };
    private final Callback _sslReadCallback = new Callback() {
        public void succeeded() {
            onFillable();
        }
        
        public void failed(final Throwable x) {
            onFillInterestedFailed(x);
        }
        
        public InvocationType getInvocationType() {
            return getDecryptedEndPoint().getFillInterest().getCallbackInvocationType();
        }
        
        public String toString() {
            return String.format("SSLC.NBReadCB@%x{%s}", SslConnection.this.hashCode(), SslConnection.this);
        }
        
    };
    public SslConnection(ByteBufferPool byteBufferPool, Executor executor, EndPoint endPoint, SSLEngine sslEngine) {
        this(byteBufferPool, executor, endPoint, sslEngine, false, false);
    }
    
    public SslConnection(ByteBufferPool byteBufferPool, Executor executor, EndPoint endPoint, SSLEngine sslEngine, boolean useDirectBuffersForEncryption, boolean useDirectBuffersForDecryption) {
        this(RetainableByteBufferPool.findOrAdapt(null, byteBufferPool), byteBufferPool, executor, endPoint, sslEngine, useDirectBuffersForEncryption, useDirectBuffersForDecryption);
    }
    
    public SslConnection(RetainableByteBufferPool retainableByteBufferPool, ByteBufferPool byteBufferPool, Executor executor, EndPoint endPoint, SSLEngine sslEngine, boolean useDirectBuffersForEncryption, boolean useDirectBuffersForDecryption) {
        super(endPoint, executor);
        this._bufferPool = byteBufferPool;
        this._retainableByteBufferPool = retainableByteBufferPool;
        this._sslEngine = sslEngine;
        this._decryptedEndPoint = newDecryptedEndPoint();
        this._encryptedDirectBuffers = useDirectBuffersForEncryption;
        this._decryptedDirectBuffers = useDirectBuffersForDecryption;
    }
    
    public long getBytesIn() {
        return _bytesIn.get();
    }
    
    public long getBytesOut() {
        return _bytesOut.get();
    }
    
    public void addHandshakeListener(SslHandshakeListener listener) {
        handshakeListeners.add(listener);
    }
    
    public boolean removeHandshakeListener(SslHandshakeListener listener) {
        return handshakeListeners.remove(listener);
    }
    
    protected DecryptedEndPoint newDecryptedEndPoint() {
        return new DecryptedEndPoint();
    }
    
    public SSLEngine getSSLEngine() {
        return _sslEngine;
    }
    
    public DecryptedEndPoint getDecryptedEndPoint() {
        return _decryptedEndPoint;
    }
    
    public boolean isRenegotiationAllowed() {
        return _renegotiationAllowed;
    }
    
    public void setRenegotiationAllowed(boolean renegotiationAllowed) {
        _renegotiationAllowed = renegotiationAllowed;
    }
    
    public int getRenegotiationLimit() {
        return _renegotiationLimit;
    }
    
    public void setRenegotiationLimit(int renegotiationLimit) {
        _renegotiationLimit = renegotiationLimit;
    }
    
    public boolean isRequireCloseMessage() {
        return _requireCloseMessage;
    }
    
    public void setRequireCloseMessage(boolean requireCloseMessage) {
        _requireCloseMessage = requireCloseMessage;
    }
    
    private boolean isHandshakeInitial() {
        return _handshake.get() == HandshakeState.INITIAL;
    }
    
    private boolean isHandshakeSucceeded() {
        return _handshake.get() == HandshakeState.SUCCEEDED;
    }
    
    private boolean isHandshakeComplete() {
        HandshakeState state = _handshake.get();
        return state == HandshakeState.SUCCEEDED || state == HandshakeState.FAILED;
    }
    
    private int getApplicationBufferSize() {
        return getBufferSize(SSLSession::getApplicationBufferSize);
    }
    
    private int getPacketBufferSize() {
        return getBufferSize(SSLSession::getPacketBufferSize);
    }
    
    private int getBufferSize(ToIntFunction<SSLSession> bufferSizeFn) {
        SSLSession hsSession = _sslEngine.getHandshakeSession();
        SSLSession session = _sslEngine.getSession();
        int size = bufferSizeFn.applyAsInt(session);
        if (hsSession == null || hsSession == session){
            return size;
}
        int hsSize = bufferSizeFn.applyAsInt(hsSession);
        return Math.max(hsSize, size);
    }
    
    private void acquireEncryptedInput() {
        if (_encryptedInput == null){
            _encryptedInput = _retainableByteBufferPool.acquire(getPacketBufferSize(), _encryptedDirectBuffers);
}
    }
    
    private void acquireEncryptedOutput() {
        if (_encryptedOutput == null){
            _encryptedOutput = _bufferPool.acquire(getPacketBufferSize(), _encryptedDirectBuffers);
}
    }
    
    public void onUpgradeTo(ByteBuffer buffer) {
        acquireEncryptedInput();
        BufferUtil.append(_encryptedInput.getBuffer(), buffer);
    }
    
    public void onOpen() {
        super.onOpen();
        getDecryptedEndPoint().getConnection().onOpen();
    }
    
    public void onClose(Throwable cause) {
        _decryptedEndPoint.getConnection().onClose(cause);
        super.onClose(cause);
    }
    
    public void close() {
        getDecryptedEndPoint().getConnection().close();
    }
    
    public boolean onIdleExpired() {
        return getDecryptedEndPoint().getConnection().onIdleExpired();
    }
    
    public void onFillable() {
        if (LOG.isDebugEnabled()){
            LOG.debug(">c.onFillable {}", SslConnection.this);
}
        if (_decryptedEndPoint.isInputShutdown()){
            _decryptedEndPoint.close();
}
        _decryptedEndPoint.onFillable();
        if (LOG.isDebugEnabled()){
            LOG.debug("<c.onFillable {}", SslConnection.this);
}
    }
    
    public void onFillInterestedFailed(Throwable cause) {
        _decryptedEndPoint.onFillableFail(cause == null ? new IOException() : cause);
    }
    
    protected SSLEngineResult wrap(SSLEngine sslEngine, ByteBuffer[] input, ByteBuffer output) throws SSLException {
        return sslEngine.wrap(input, output);
    }
    
    protected SSLEngineResult unwrap(SSLEngine sslEngine, ByteBuffer input, ByteBuffer output) throws SSLException {
        return sslEngine.unwrap(input, output);
    }
    
    public String toConnectionString() {
        ByteBuffer b = _encryptedInput == null ? null : _encryptedInput.getBuffer();
        int ei = b == null ? -1 : b.remaining();
        b = _encryptedOutput;
        int eo = b == null ? -1 : b.remaining();
        b = _decryptedInput;
        int di = b == null ? -1 : b.remaining();
        Connection connection = _decryptedEndPoint.getConnection();
        return String.format("%s@%x{%s,eio=%d/%d,di=%d,fill=%s,flush=%s}~>%s=>%s", getClass().getSimpleName(), hashCode(), _sslEngine.getHandshakeStatus(), ei, eo, di, _fillState, _flushState, _decryptedEndPoint.toEndPointString(), connection instanceof AbstractConnection ? ((AbstractConnection)connection).toConnectionString() : connection);
    }
    
    private void releaseEncryptedInputBuffer() {
        if (_encryptedInput != null && !_encryptedInput.hasRemaining()){
            _encryptedInput.release();
            _encryptedInput = null;
        }
        
    }
    
    protected void releaseDecryptedInputBuffer() {
        if (_decryptedInput != null && !_decryptedInput.hasRemaining()){
            _bufferPool.release(_decryptedInput);
            _decryptedInput = null;
        }
        
    }
    
    private void releaseEncryptedOutputBuffer() {
        if (!_lock.isHeldByCurrentThread()){
            throw new IllegalStateException();
}
        if (_encryptedOutput != null && !_encryptedOutput.hasRemaining()){
            _bufferPool.release(_encryptedOutput);
            _encryptedOutput = null;
        }
        
    }
    
    protected int networkFill(ByteBuffer input) throws IOException {
        return getEndPoint().fill(input);
    }
    
    protected boolean networkFlush(ByteBuffer output) throws IOException {
        return getEndPoint().flush(output);
    }
    
    public class DecryptedEndPoint extends AbstractEndPoint implements EndPoint.Wrapper {
        private final Callback _incompleteWriteCallback = new IncompleteWriteCallback();
        private Throwable _failure;
        public DecryptedEndPoint() {
            super(null);
            super.setIdleTimeout(-1);
        }
        
        public EndPoint unwrap() {
            return getEndPoint();
        }
        
        public long getIdleTimeout() {
            return getEndPoint().getIdleTimeout();
        }
        
        public void setIdleTimeout(long idleTimeout) {
            getEndPoint().setIdleTimeout(idleTimeout);
        }
        
        public boolean isOpen() {
            return getEndPoint().isOpen();
        }
        
        public SocketAddress getLocalSocketAddress() {
            return getEndPoint().getLocalSocketAddress();
        }
        
        public SocketAddress getRemoteSocketAddress() {
            return getEndPoint().getRemoteSocketAddress();
        }
        
        public WriteFlusher getWriteFlusher() {
            return super.getWriteFlusher();
        }
        
        protected void onFillable() {
            try {
                boolean waitingForFill;
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug("onFillable {}", SslConnection.this);
}
                    _fillState = FillState.IDLE;
                    waitingForFill = _flushState == FlushState.WAIT_FOR_FILL;
                }
                
                getFillInterest().fillable();
                if (waitingForFill){
                    try (AutoLock l = _lock.lock()) {
                        waitingForFill = _flushState == FlushState.WAIT_FOR_FILL;
                    }
                    
                    if (waitingForFill){
                        fill(BufferUtil.EMPTY_BUFFER);
}
                }
                
            }
            
            catch (Throwable e) {
                close(e);
            }
            
        }
        
        protected void onFillableFail(Throwable failure) {
            boolean fail = false;
            try (AutoLock l = _lock.lock()) {
                if (LOG.isDebugEnabled()){
                    LOG.debug("onFillableFail {}", SslConnection.this, failure);
}
                _fillState = FillState.IDLE;
                if (_flushState == FlushState.WAIT_FOR_FILL){
                    _flushState = FlushState.IDLE;
                    fail = true;
                }
                
            }
            
            getFillInterest().onFail(failure);
            if (fail){
                if (!getWriteFlusher().onFail(failure)){
                    close(failure);
}
            }
            
        }
        
        public void setConnection(Connection connection) {
            if (connection instanceof AbstractConnection){
                AbstractConnection c = (AbstractConnection)connection;
                int appBufferSize = getApplicationBufferSize();
                if (c.getInputBufferSize() < appBufferSize){
                    c.setInputBufferSize(appBufferSize);
}
            }
            
            super.setConnection(connection);
        }
        
        public SslConnection getSslConnection() {
            return SslConnection.this;
        }
        
        public int fill(ByteBuffer buffer) throws IOException {
            try {
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug(">fill {}", SslConnection.this);
}
                    int filled = -2;
                    try {
                        if (_fillState != FillState.IDLE){
                            return filled = 0;
}
                        if (BufferUtil.hasContent(_decryptedInput)){
                            return filled = BufferUtil.append(buffer, _decryptedInput);
}
                        while (true){
                            HandshakeStatus status = _sslEngine.getHandshakeStatus();
                            if (LOG.isDebugEnabled()){
                                LOG.debug("fill {}", status);
}
                            switch (status){
                                case NEED_UNWRAP:
                                case NOT_HANDSHAKING:
                                    break;
                                case NEED_TASK:
                                    _sslEngine.getDelegatedTask().run();
                                    continue;
                                case NEED_WRAP:
                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER)){
                                        Throwable failure = _failure;
                                        if (failure != null){
                                            rethrow(failure);
}
                                        if (_sslEngine.isInboundDone()){
                                            return filled = -1;
}
                                        continue;
                                    }
                                    
                                    return filled = 0;
                                default: throw new IllegalStateException("Unexpected HandshakeStatus " + status);
                            }
                            
                            acquireEncryptedInput();
                            ByteBuffer appIn;
                            int appBufferSize = getApplicationBufferSize();
                            if (_decryptedInput == null){
                                if (BufferUtil.space(buffer) > appBufferSize){
                                    appIn = buffer;
}
                                else{
                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);
}
                            }
                            
                            else{
                                appIn = _decryptedInput;
                            }
                            
                            int netFilled = networkFill(_encryptedInput.getBuffer());
                            if (netFilled > 0){
                                _bytesIn.addAndGet(netFilled);
}
                            if (LOG.isDebugEnabled()){
                                LOG.debug("net filled={}", netFilled);
}
                            if (netFilled < 0 && isHandshakeInitial() && (_encryptedInput == null || _encryptedInput.isEmpty())){
                                closeInbound();
}
                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone()){
                                throw new SSLHandshakeException("Closed during handshake");
}
                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE)){
                                if (LOG.isDebugEnabled()){
                                    LOG.debug("fill starting handshake {}", SslConnection.this);
}
                            }
                            
                            int pos = BufferUtil.flipToFill(appIn);
                            SSLEngineResult unwrapResult;
                            try {
                                _underflown = false;
                                unwrapResult = SslConnection.this.unwrap(_sslEngine, _encryptedInput.getBuffer(), appIn);
                            }
                            
                            finally {
                                BufferUtil.flipToFlush(appIn, pos);
                            }
                            
                            if (LOG.isDebugEnabled()){
                                LOG.debug("unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}", netFilled, StringUtil.replace(unwrapResult.toString(), '\n', ' '), _encryptedInput, BufferUtil.toDetailString(appIn), BufferUtil.toDetailString(buffer));
}
                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();
                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0){
                                unwrap = Status.BUFFER_UNDERFLOW;
}
                            switch (unwrap){
                                case CLOSED:
                                    Throwable failure = _failure;
                                    if (failure != null){
                                        rethrow(failure);
}
                                    return filled = -1;
                                case BUFFER_UNDERFLOW:
                                    if (BufferUtil.compact(_encryptedInput.getBuffer())){
                                        continue;
}
                                    if (BufferUtil.space(_encryptedInput.getBuffer()) == 0){
                                        BufferUtil.clear(_encryptedInput.getBuffer());
                                        throw new SSLHandshakeException("Encrypted buffer max length exceeded");
                                    }
                                    
                                    if (netFilled > 0){
                                        continue; 
}
                                    _underflown = true;
                                    if (netFilled < 0 && _sslEngine.getUseClientMode()){
                                        Throwable closeFailure = closeInbound();
                                        if (_flushState == FlushState.WAIT_FOR_FILL){
                                            Throwable handshakeFailure = new SSLHandshakeException("Abruptly closed by peer");
                                            if (closeFailure != null){
                                                handshakeFailure.addSuppressed(closeFailure);
}
                                            throw handshakeFailure;
                                        }
                                        
                                        return filled = -1;
                                    }
                                    
                                    return filled = netFilled;
                                case BUFFER_OVERFLOW:
                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize()){
                                        releaseDecryptedInputBuffer();
                                        continue;
                                    }
                                    
                                    throw new IllegalStateException("Unexpected unwrap result " + unwrap);
                                case OK:
                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED){
                                        handshakeSucceeded();
}
                                    if (isRenegotiating() && !allowRenegotiate()){
                                        return filled = -1;
}
                                    if (unwrapResult.bytesProduced() > 0){
                                        if (appIn == buffer){
                                            return filled = unwrapResult.bytesProduced();
}
                                        return filled = BufferUtil.append(buffer, _decryptedInput);
                                    }
                                    
                                    break;
                                default: throw new IllegalStateException("Unexpected unwrap result " + unwrap);
                            }
                            
                        }
                        
                    }
                    
                    catch (Throwable x) {
                        Throwable f = handleException(x, "fill");
                        Throwable failure = handshakeFailed(f);
                        if (_flushState == FlushState.WAIT_FOR_FILL){
                            _flushState = FlushState.IDLE;
                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));
                        }
                        
                        throw failure;
                    }
                    
                    finally {
                        releaseEncryptedInputBuffer();
                        releaseDecryptedInputBuffer();
                        if (_flushState == FlushState.WAIT_FOR_FILL){
                            _flushState = FlushState.IDLE;
                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());
                        }
                        
                        if (LOG.isDebugEnabled()){
                            LOG.debug("<fill f={} uf={} {}", filled, _underflown, SslConnection.this);
}
                    }
                    
                }
                
            }
            
            catch (Throwable x) {
                close(x);
                rethrow(x);
                throw new AssertionError();
            }
            
        }
        
        protected void needsFillInterest() {
            try {
                boolean fillable;
                ByteBuffer write = null;
                boolean interest = false;
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug(">needFillInterest s={}/{} uf={} ei={} di={} {}", _flushState, _fillState, _underflown, _encryptedInput, BufferUtil.toDetailString(_decryptedInput), SslConnection.this);
}
                    if (_fillState != FillState.IDLE){
                        return;
}
                    fillable = BufferUtil.hasContent(_decryptedInput) || (_encryptedInput != null && _encryptedInput.hasRemaining() && !_underflown);
                    HandshakeStatus status = _sslEngine.getHandshakeStatus();
                    switch (status){
                        case NEED_TASK:
                            fillable = true;
                            break;
                        case NEED_UNWRAP:
                        case NOT_HANDSHAKING:
                            if (!fillable){
                                interest = true;
                                _fillState = FillState.INTERESTED;
                                if (_flushState == FlushState.IDLE && BufferUtil.hasContent(_encryptedOutput)){
                                    _flushState = FlushState.WRITING;
                                    write = _encryptedOutput;
                                }
                                
                            }
                            
                            break;
                        case NEED_WRAP:
                            if (!fillable){
                                _fillState = FillState.WAIT_FOR_FLUSH;
                                if (_flushState == FlushState.IDLE){
                                    _flushState = FlushState.WRITING;
                                    write = BufferUtil.hasContent(_encryptedOutput) ? _encryptedOutput : BufferUtil.EMPTY_BUFFER;
                                }
                                
                            }
                            
                            break;
                        default: throw new IllegalStateException("Unexpected HandshakeStatus " + status);
                    }
                    
                    if (LOG.isDebugEnabled()){
                        LOG.debug("<needFillInterest s={}/{} f={} i={} w={}", _flushState, _fillState, fillable, interest, BufferUtil.toDetailString(write));
}
                }
                
                if (write != null){
                    getEndPoint().write(_incompleteWriteCallback, write);
}
                else if (fillable){
                    getExecutor().execute(_runFillable);
}
                else if (interest){
                    ensureFillInterested();
}
            }
            
            catch (Throwable x) {
                if (LOG.isDebugEnabled()){
                    LOG.debug(SslConnection.this.toString(), x);
}
                close(x);
                throw x;
            }
            
        }
        
        private void handshakeSucceeded() throws SSLException {
            if (_handshake.compareAndSet(HandshakeState.HANDSHAKE, HandshakeState.SUCCEEDED)){
                if (LOG.isDebugEnabled()){
                    LOG.debug("handshake succeeded {} {} {}/{}", SslConnection.this, _sslEngine.getUseClientMode() ? "client" : "resumed server", _sslEngine.getSession().getProtocol(), _sslEngine.getSession().getCipherSuite());
}
                notifyHandshakeSucceeded(_sslEngine);
            }
            
            else if (isHandshakeSucceeded()){
                if (_renegotiationLimit > 0){
                    _renegotiationLimit--;
}
            }
            
        }
        
        private Throwable handshakeFailed(Throwable failure) {
            if (_handshake.compareAndSet(HandshakeState.HANDSHAKE, HandshakeState.FAILED)){
                if (LOG.isDebugEnabled()){
                    LOG.debug("handshake failed {} {}", SslConnection.this, failure);
}
                if (!(failure instanceof SSLHandshakeException)){
                    failure = new SSLHandshakeException(failure.getMessage()).initCause(failure);
}
                notifyHandshakeFailed(_sslEngine, failure);
            }
            
            return failure;
        }
        
        private void terminateInput() {
            try {
                _sslEngine.closeInbound();
            }
            
            catch (Throwable x) {
                LOG.trace("IGNORED", x);
            }
            
        }
        
        private Throwable closeInbound() throws SSLException {
            HandshakeStatus handshakeStatus = _sslEngine.getHandshakeStatus();
            try {
                _sslEngine.closeInbound();
                return null;
            }
            
            catch (SSLException x) {
                if (handshakeStatus == HandshakeStatus.NOT_HANDSHAKING && isRequireCloseMessage()){
                    throw x;
}
                LOG.trace("IGNORED", x);
                return x;
            }
            
            catch (Throwable x) {
                LOG.trace("IGNORED", x);
                return x;
            }
            
        }
        
        public boolean flush(ByteBuffer... appOuts) throws IOException {
            try {
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug(">flush {}", SslConnection.this);
                        int i = 0;
                        for (ByteBuffer b : appOuts){
                            LOG.debug("flush b[{}]={}", i++, BufferUtil.toDetailString(b));
                        }
                        
                    }
                    
                    if (_encryptedOutput != null){
                        int remaining = _encryptedOutput.remaining();
                        if (remaining > 0){
                            boolean flushed = networkFlush(_encryptedOutput);
                            int written = remaining - _encryptedOutput.remaining();
                            if (written > 0){
                                _bytesOut.addAndGet(written);
}
                            if (!flushed){
                                return false;
}
                        }
                        
                    }
                    
                    boolean isEmpty = BufferUtil.isEmpty(appOuts);
                    Boolean result = null;
                    try {
                        if (_flushState != FlushState.IDLE){
                            return result = false;
}
                        while (true){
                            HandshakeStatus status = _sslEngine.getHandshakeStatus();
                            if (LOG.isDebugEnabled()){
                                LOG.debug("flush {}", status);
}
                            switch (status){
                                case NEED_WRAP:
                                case NOT_HANDSHAKING:
                                    break;
                                case NEED_TASK:
                                    _sslEngine.getDelegatedTask().run();
                                    continue;
                                case NEED_UNWRAP:
                                    if (isHandshakeInitial() && isOutboundDone()){
                                        break;
}
                                    if (_fillState == FillState.IDLE){
                                        int filled = fill(BufferUtil.EMPTY_BUFFER);
                                        if (_sslEngine.getHandshakeStatus() != status){
                                            continue;
}
                                        if (filled < 0){
                                            throw new IOException("Broken pipe");
}
                                    }
                                    
                                    return result = isEmpty;
                                default: throw new IllegalStateException("Unexpected HandshakeStatus " + status);
                            }
                            
                            int packetBufferSize = getPacketBufferSize();
                            acquireEncryptedOutput();
                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE)){
                                if (LOG.isDebugEnabled()){
                                    LOG.debug("flush starting handshake {}", SslConnection.this);
}
                            }
                            
                            BufferUtil.compact(_encryptedOutput);
                            int pos = BufferUtil.flipToFill(_encryptedOutput);
                            SSLEngineResult wrapResult;
                            try {
                                wrapResult = wrap(_sslEngine, appOuts, _encryptedOutput);
                            }
                            
                            finally {
                                BufferUtil.flipToFlush(_encryptedOutput, pos);
                            }
                            
                            if (LOG.isDebugEnabled()){
                                LOG.debug("wrap {} {} ioDone={}/{}", StringUtil.replace(wrapResult.toString(), '\n', ' '), BufferUtil.toSummaryString(_encryptedOutput), _sslEngine.isInboundDone(), _sslEngine.isOutboundDone());
}
                            isEmpty = BufferUtil.isEmpty(appOuts);
                            boolean flushed = true;
                            if (_encryptedOutput != null){
                                int remaining = _encryptedOutput.remaining();
                                if (remaining > 0){
                                    flushed = networkFlush(_encryptedOutput);
                                    int written = remaining - _encryptedOutput.remaining();
                                    if (written > 0){
                                        _bytesOut.addAndGet(written);
}
                                }
                                
                            }
                            
                            if (LOG.isDebugEnabled()){
                                LOG.debug("net flushed={}, ac={}", flushed, isEmpty);
}
                            Status wrap = wrapResult.getStatus();
                            switch (wrap){
                                case CLOSED:{
                                    if (!flushed){
                                        return result = false;
}
                                    getEndPoint().shutdownOutput();
                                    if (isEmpty){
                                        return result = true;
}
                                    throw new IOException("Broken pipe");
                                }
                                
                                case BUFFER_OVERFLOW:
                                    if (!flushed){
                                        return result = false;
}
                                    if (packetBufferSize < getPacketBufferSize()){
                                        releaseEncryptedOutputBuffer();
                                        continue;
                                    }
                                    
                                    throw new IllegalStateException("Unexpected wrap result " + wrap);
                                case OK:
                                    if (wrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED){
                                        handshakeSucceeded();
}
                                    if (isRenegotiating() && !allowRenegotiate()){
                                        getEndPoint().shutdownOutput();
                                        if (isEmpty && BufferUtil.isEmpty(_encryptedOutput)){
                                            return result = true;
}
                                        throw new IOException("Broken pipe");
                                    }
                                    
                                    if (!flushed){
                                        return result = false;
}
                                    if (isEmpty){
                                        if (wrapResult.getHandshakeStatus() != HandshakeStatus.NEED_WRAP || wrapResult.bytesProduced() == 0){
                                            return result = true;
}
                                    }
                                    
                                    break;
                                default: throw new IllegalStateException("Unexpected wrap result " + wrap);
                            }
                            
                            if (getEndPoint().isOutputShutdown()){
                                return false;
}
                        }
                        
                    }
                    
                    catch (Throwable x) {
                        Throwable failure = handleException(x, "flush");
                        throw handshakeFailed(failure);
                    }
                    
                    finally {
                        releaseEncryptedOutputBuffer();
                        if (LOG.isDebugEnabled()){
                            LOG.debug("<flush {} {}", result, SslConnection.this);
}
                    }
                    
                }
                
            }
            
            catch (Throwable x) {
                close(x);
                rethrow(x);
                throw new AssertionError();
            }
            
        }
        
        protected void onIncompleteFlush() {
            try {
                boolean fillInterest = false;
                ByteBuffer write = null;
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug(">onIncompleteFlush {} {}", SslConnection.this, BufferUtil.toDetailString(_encryptedOutput));
}
                    if (_flushState != FlushState.IDLE){
                        return;
}
                    while (true){
                        HandshakeStatus status = _sslEngine.getHandshakeStatus();
                        switch (status){
                            case NEED_TASK:
                            case NEED_WRAP:
                            case NOT_HANDSHAKING:
                                write = BufferUtil.hasContent(_encryptedOutput) ? _encryptedOutput : BufferUtil.EMPTY_BUFFER;
                                _flushState = FlushState.WRITING;
                                break;
                            case NEED_UNWRAP:
                                if (BufferUtil.hasContent(_encryptedOutput)){
                                    write = _encryptedOutput;
                                    _flushState = FlushState.WRITING;
                                    break;
                                }
                                
                                if (_fillState != FillState.IDLE){
                                    _flushState = FlushState.WAIT_FOR_FILL;
                                    break;
                                }
                                
                                try {
                                    int filled = fill(BufferUtil.EMPTY_BUFFER);
                                    if (_sslEngine.getHandshakeStatus() != status){
                                        continue;
}
                                    if (filled < 0){
                                        throw new IOException("Broken pipe");
}
                                }
                                
                                catch (IOException e) {
                                    LOG.debug("Incomplete flush?", e);
                                    close(e);
                                    write = BufferUtil.EMPTY_BUFFER;
                                    _flushState = FlushState.WRITING;
                                    break;
                                }
                                
                                fillInterest = true;
                                _fillState = FillState.INTERESTED;
                                _flushState = FlushState.WAIT_FOR_FILL;
                                break;
                            default: throw new IllegalStateException("Unexpected HandshakeStatus " + status);
                        }
                        
                        break;
                    }
                    
                    if (LOG.isDebugEnabled()){
                        LOG.debug("<onIncompleteFlush s={}/{} fi={} w={}", _flushState, _fillState, fillInterest, BufferUtil.toDetailString(write));
}
                }
                
                if (write != null){
                    getEndPoint().write(_incompleteWriteCallback, write);
}
                else if (fillInterest){
                    ensureFillInterested();
}
            }
            
            catch (Throwable x) {
                if (LOG.isDebugEnabled()){
                    LOG.debug(SslConnection.this.toString(), x);
}
                close(x);
                throw x;
            }
            
        }
        
        public void doShutdownOutput() {
            EndPoint endPoint = getEndPoint();
            try {
                boolean close;
                boolean flush = false;
                try (AutoLock l = _lock.lock()) {
                    boolean ishut = endPoint.isInputShutdown();
                    boolean oshut = endPoint.isOutputShutdown();
                    if (LOG.isDebugEnabled()){
                        LOG.debug("shutdownOutput: {} oshut={}, ishut={}", SslConnection.this, oshut, ishut);
}
                    closeOutbound();
                    if (!_closedOutbound){
                        _closedOutbound = true;
                        flush = !oshut;
                    }
                    
                    close = ishut;
                }
                
                if (flush){
                    if (!flush(BufferUtil.EMPTY_BUFFER) && !close){
                        ByteBuffer write = null;
                        try (AutoLock l = _lock.lock()) {
                            if (BufferUtil.hasContent(_encryptedOutput)){
                                write = _encryptedOutput;
                                _flushState = FlushState.WRITING;
                            }
                            
                        }
                        
                        if (write != null){
                            endPoint.write(Callback.from(() -> {
                                try (AutoLock l = _lock.lock()) {
                                    _flushState = FlushState.IDLE;
                                    releaseEncryptedOutputBuffer();
                                }
                                
                            }, t -> endPoint.close()), write);
                        }
                        
                    }
                    
                }
                
                if (close){
                    endPoint.close();
}
                else{
                    ensureFillInterested();
}
            }
            
            catch (Throwable x) {
                LOG.trace("IGNORED", x);
                endPoint.close();
            }
            
        }
        
        private void closeOutbound() {
            try {
                _sslEngine.closeOutbound();
            }
            
            catch (Throwable x) {
                if (LOG.isDebugEnabled()){
                    LOG.debug("Unable to close outbound", x);
}
            }
            
        }
        
        private void ensureFillInterested() {
            if (LOG.isDebugEnabled()){
                LOG.debug("ensureFillInterested {}", SslConnection.this);
}
            SslConnection.this.tryFillInterested(_sslReadCallback);
        }
        
        public boolean isOutputShutdown() {
            return isOutboundDone() || getEndPoint().isOutputShutdown();
        }
        
        private boolean isOutboundDone() {
            try {
                return _sslEngine.isOutboundDone();
            }
            
            catch (Throwable x) {
                LOG.trace("IGNORED", x);
                return true;
            }
            
        }
        
        public void doClose() {
            doShutdownOutput();
            getEndPoint().close();
            super.doClose();
        }
        
        public Object getTransport() {
            return getEndPoint();
        }
        
        public boolean isInputShutdown() {
            return BufferUtil.isEmpty(_decryptedInput) && (getEndPoint().isInputShutdown() || isInboundDone());
        }
        
        private boolean isInboundDone() {
            try {
                return _sslEngine.isInboundDone();
            }
            
            catch (Throwable x) {
                LOG.trace("IGNORED", x);
                return true;
            }
            
        }
        
        private void notifyHandshakeSucceeded(SSLEngine sslEngine) throws SSLException {
            SslHandshakeListener.Event event = null;
            for (SslHandshakeListener listener : handshakeListeners){
                if (event == null){
                    event = new SslHandshakeListener.Event(sslEngine);
}
                try {
                    listener.handshakeSucceeded(event);
                }
                
                catch (SSLException x) {
                    throw x;
                }
                
                catch (Throwable x) {
                    LOG.info("Exception while notifying listener {}", listener, x);
                }
                
            }
            
        }
        
        private void notifyHandshakeFailed(SSLEngine sslEngine, Throwable failure) {
            SslHandshakeListener.Event event = null;
            for (SslHandshakeListener listener : handshakeListeners){
                if (event == null){
                    event = new SslHandshakeListener.Event(sslEngine);
}
                try {
                    listener.handshakeFailed(event, failure);
                }
                
                catch (Throwable x) {
                    LOG.info("Exception while notifying listener {}", listener, x);
                }
                
            }
            
        }
        
        private boolean isRenegotiating() {
            if (!isHandshakeComplete()){
                return false;
}
            if (isTLS13()){
                return false;
}
            return _sslEngine.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING;
        }
        
        private boolean allowRenegotiate() {
            if (!isRenegotiationAllowed()){
                if (LOG.isDebugEnabled()){
                    LOG.debug("Renegotiation denied {}", SslConnection.this);
}
                terminateInput();
                return false;
            }
            
            if (getRenegotiationLimit() == 0){
                if (LOG.isDebugEnabled()){
                    LOG.debug("Renegotiation limit exceeded {}", SslConnection.this);
}
                terminateInput();
                return false;
            }
            
            return true;
        }
        
        private boolean isTLS13() {
            String protocol = _sslEngine.getSession().getProtocol();
            return TLS_1_3.equals(protocol);
        }
        
        private Throwable handleException(Throwable x, String context) {
            try (AutoLock l = _lock.lock()) {
                if (_failure == null){
                    _failure = x;
                    if (LOG.isDebugEnabled()){
                        LOG.debug("{} stored {} exception", this, context, x);
}
                }
                
                else if (x != _failure){
                    _failure.addSuppressed(x);
                    if (LOG.isDebugEnabled()){
                        LOG.debug("{} suppressed {} exception", this, context, x);
}
                }
                
                return _failure;
            }
            
        }
        
        private void rethrow(Throwable x) throws IOException {
            if (x instanceof RuntimeException){
                throw (RuntimeException)x;
}
            if (x instanceof Error){
                throw (Error)x;
}
            if (x instanceof IOException){
                throw (IOException)x;
}
            throw new IOException(x);
        }
        
        public String toString() {
            return String.format("%s@%x[%s]", getClass().getSimpleName(), hashCode(), toEndPointString());
        }
        
        private final class IncompleteWriteCallback implements Callback, Invocable {
            public void succeeded() {
                boolean fillable;
                boolean interested;
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug("IncompleteWriteCB succeeded {}", SslConnection.this);
}
                    releaseEncryptedOutputBuffer();
                    _flushState = FlushState.IDLE;
                    interested = _fillState == FillState.INTERESTED;
                    fillable = _fillState == FillState.WAIT_FOR_FLUSH;
                    if (fillable){
                        _fillState = FillState.IDLE;
}
                }
                
                if (interested){
                    ensureFillInterested();
}
                else if (fillable){
                    _decryptedEndPoint.getFillInterest().fillable();
}
                _decryptedEndPoint.getWriteFlusher().completeWrite();
            }
            
            public void failed(final Throwable x) {
                boolean failFillInterest;
                try (AutoLock l = _lock.lock()) {
                    if (LOG.isDebugEnabled()){
                        LOG.debug("IncompleteWriteCB failed {}", SslConnection.this, x);
}
                    BufferUtil.clear(_encryptedOutput);
                    releaseEncryptedOutputBuffer();
                    _flushState = FlushState.IDLE;
                    failFillInterest = _fillState == FillState.WAIT_FOR_FLUSH || _fillState == FillState.INTERESTED;
                    if (failFillInterest){
                        _fillState = FillState.IDLE;
}
                }
                
                getExecutor().execute(() -> {
                    if (failFillInterest){
                        _decryptedEndPoint.getFillInterest().onFail(x);
}
                    _decryptedEndPoint.getWriteFlusher().onFail(x);
                }
                
);
            }
            
            public InvocationType getInvocationType() {
                return _decryptedEndPoint.getWriteFlusher().getCallbackInvocationType();
            }
            
            public String toString() {
                return String.format("SSL@%h.DEP.writeCallback", SslConnection.this);
            }
            
        }
        
    }
    
    private abstract class RunnableTask implements Invocable.Task {
        private final String _operation;
        protected RunnableTask(String op) {
            _operation = op;
        }
        
        public String toString() {
            return String.format("SSL:%s:%s:%s", SslConnection.this, _operation, getInvocationType());
        }
        
    }
    
}


