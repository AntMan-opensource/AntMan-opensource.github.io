package org.apache.commons.compress.archivers.tar;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.utils.BoundedArchiveInputStream;
import org.apache.commons.compress.utils.BoundedSeekableByteChannelInputStream;
import org.apache.commons.compress.utils.SeekableInMemoryByteChannel;
public class TarFile implements Closeable {
    private static final int SMALL_BUFFER_SIZE = 256;
    private final byte[] smallBuf = new byte[SMALL_BUFFER_SIZE];
    private final SeekableByteChannel archive;
    private final ZipEncoding zipEncoding;
    private final LinkedList<TarArchiveEntry> entries = new LinkedList<>();
    private final int blockSize;
    private final boolean lenient;
    private final int recordSize;
    private final ByteBuffer recordBuffer;
    private final List<TarArchiveStructSparse> globalSparseHeaders = new ArrayList<>();
    private boolean hasHitEOF;
    private TarArchiveEntry currEntry;
    private Map<String, String> globalPaxHeaders = new HashMap<>();
    private final Map<String, List<InputStream>> sparseInputStreams = new HashMap<>();
    public TarFile(final byte[] content) throws IOException {
        this(new SeekableInMemoryByteChannel(content));
    }
    
    public TarFile(final byte[] content, final String encoding) throws IOException {
        this(new SeekableInMemoryByteChannel(content), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding, false);
    }
    
    public TarFile(final byte[] content, final boolean lenient) throws IOException {
        this(new SeekableInMemoryByteChannel(content), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, lenient);
    }
    
    public TarFile(final File archive) throws IOException {
        this(archive.toPath());
    }
    
    public TarFile(final File archive, final String encoding) throws IOException {
        this(archive.toPath(), encoding);
    }
    
    public TarFile(final File archive, final boolean lenient) throws IOException {
        this(archive.toPath(), lenient);
    }
    
    public TarFile(final Path archivePath) throws IOException {
        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, false);
    }
    
    public TarFile(final Path archivePath, final String encoding) throws IOException {
        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding, false);
    }
    
    public TarFile(final Path archivePath, final boolean lenient) throws IOException {
        this(Files.newByteChannel(archivePath), TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, lenient);
    }
    
    public TarFile(final SeekableByteChannel content) throws IOException {
        this(content, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, false);
    }
    
    public TarFile(final SeekableByteChannel archive, final int blockSize, final int recordSize, final String encoding, final boolean lenient) throws IOException {
        this.archive = archive;
        this.hasHitEOF = false;
        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
        this.recordSize = recordSize;
        this.recordBuffer = ByteBuffer.allocate(this.recordSize);
        this.blockSize = blockSize;
        this.lenient = lenient;
        TarArchiveEntry entry;
        while ((entry = getNextTarEntry()) != null) {
            entries.add(entry);
        }
        
    }
    
    private TarArchiveEntry getNextTarEntry() throws IOException {
        if (isAtEOF()) {
            return null;
        }
        
        if (currEntry != null) {
            repositionForwardTo(currEntry.getDataOffset() + currEntry.getSize());
            throwExceptionIfPositionIsNotInArchive();
            skipRecordPadding();
        }
        
        final ByteBuffer headerBuf = getRecord();
        if (null == headerBuf) {
            currEntry = null;
            return null;
        }
        
        try {
            currEntry = new TarArchiveEntry(headerBuf.array(), zipEncoding, lenient, archive.position());
        }
         catch (final IllegalArgumentException e) {
            throw new IOException("Error detected parsing the header", e);
        }
        
        if (currEntry.isGNULongLinkEntry()) {
            final byte[] longLinkData = getLongNameData();
            if (longLinkData == null) {
                return null;
            }
            
            currEntry.setLinkName(zipEncoding.decode(longLinkData));
        }
        
        if (currEntry.isGNULongNameEntry()) {
            final byte[] longNameData = getLongNameData();
            if (longNameData == null) {
                return null;
            }
            
            final String name = zipEncoding.decode(longNameData);
            currEntry.setName(name);
            if (currEntry.isDirectory() && !name.endsWith("/")) {
                currEntry.setName(name + "/");
            }
            
        }
        
        if (currEntry.isGlobalPaxHeader()) { 
            readGlobalPaxHeaders();
        }
        
        try {
            if (currEntry.isPaxHeader()) { 
                paxHeaders();
            }
             else if (!globalPaxHeaders.isEmpty()) {
                applyPaxHeadersToCurrentEntry(globalPaxHeaders, globalSparseHeaders);
            }
            
        }
         catch (NumberFormatException e) {
            throw new IOException("Error detected parsing the pax header", e);
        }
        
        if (currEntry.isOldGNUSparse()) { 
            readOldGNUSparse();
        }
        
        return currEntry;
    }
    
    private void readOldGNUSparse() throws IOException {
        if (currEntry.isExtended()) {
            TarArchiveSparseEntry entry;
            do {
                final ByteBuffer headerBuf = getRecord();
                if (headerBuf == null) {
                    throw new IOException("premature end of tar archive. Didn't find extended_header after header with extended flag.");
                }
                
                entry = new TarArchiveSparseEntry(headerBuf.array());
                currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());
                currEntry.setDataOffset(currEntry.getDataOffset() + recordSize);
            }
             while (entry.isExtended());
        }
        
        buildSparseInputStreams();
    }
    
    private void buildSparseInputStreams() throws IOException {
        final List<InputStream> streams = new ArrayList<>();
        final List<TarArchiveStructSparse> sparseHeaders = currEntry.getOrderedSparseHeaders();
        final InputStream zeroInputStream = new TarArchiveSparseZeroInputStream(); 
        long offset = 0;
        long numberOfZeroBytesInSparseEntry = 0;
        for (TarArchiveStructSparse sparseHeader : sparseHeaders) {
            final long zeroBlockSize = sparseHeader.getOffset() - offset;
            if (zeroBlockSize < 0) {
                throw new IOException("Corrupted struct sparse detected");
            }
            
            if (zeroBlockSize > 0) {
                streams.add(new BoundedInputStream(zeroInputStream, zeroBlockSize));
                numberOfZeroBytesInSparseEntry += zeroBlockSize;
            }
            
            if (sparseHeader.getNumbytes() > 0) {
                final long start = currEntry.getDataOffset() + sparseHeader.getOffset() - numberOfZeroBytesInSparseEntry;
                if (start + sparseHeader.getNumbytes() < start) {
                    throw new IOException("Unreadable TAR archive, sparse block offset or length too big");
                }
                
                streams.add(new BoundedSeekableByteChannelInputStream(start, sparseHeader.getNumbytes(), archive));
            }
            
            offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();
        }
        
        sparseInputStreams.put(currEntry.getName(), streams);
    }
    
    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {
        currEntry.updateEntryFromPaxHeaders(headers);
        currEntry.setSparseHeaders(sparseHeaders);
    }
    
    private void paxHeaders() throws IOException {
        List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();
        final Map<String, String> headers;
        try (final InputStream input = getInputStream(currEntry)) {
            headers = TarUtils.parsePaxHeaders(input, sparseHeaders, globalPaxHeaders);
        }
        
        if (headers.containsKey("GNU.sparse.map")) {
            sparseHeaders = new ArrayList<>(TarUtils.parseFromPAX01SparseHeaders(headers.get("GNU.sparse.map")));
        }
        
        getNextTarEntry(); 
        if (currEntry == null) {
            throw new IOException("premature end of tar archive. Didn't find any entry after PAX header.");
        }
        
        applyPaxHeadersToCurrentEntry(headers, sparseHeaders);
        if (currEntry.isPaxGNU1XSparse()) {
            try (final InputStream input = getInputStream(currEntry)) {
                sparseHeaders = TarUtils.parsePAX1XSparseHeaders(input, recordSize);
            }
            
            currEntry.setSparseHeaders(sparseHeaders);
            currEntry.setDataOffset(currEntry.getDataOffset() + recordSize);
        }
        
        buildSparseInputStreams();
    }
    
    private void readGlobalPaxHeaders() throws IOException {
        try (InputStream input = getInputStream(currEntry)) {
            globalPaxHeaders = TarUtils.parsePaxHeaders(input, globalSparseHeaders, globalPaxHeaders);
        }
        
        getNextTarEntry(); 
        if (currEntry == null) {
            throw new IOException("Error detected parsing the pax header");
        }
        
    }
    
    private byte[] getLongNameData() throws IOException {
        final ByteArrayOutputStream longName = new ByteArrayOutputStream();
        int length;
        try (final InputStream in = getInputStream(currEntry)) {
            while ((length = in.read(smallBuf)) >= 0) {
                longName.write(smallBuf, 0, length);
            }
            
        }
        
        getNextTarEntry();
        if (currEntry == null) {
            return null;
        }
        
        byte[] longNameData = longName.toByteArray();
        length = longNameData.length;
        while (length > 0 && longNameData[length - 1] == 0) { --length;
        }
        
        if (length != longNameData.length) {
            final byte[] l = new byte[length];
            System.arraycopy(longNameData, 0, l, 0, length);
            longNameData = l;
        }
        
        return longNameData;
    }
    
    private void skipRecordPadding() throws IOException {
        if (!isDirectory() && currEntry.getSize() > 0 && currEntry.getSize() % recordSize != 0) {
            final long numRecords = (currEntry.getSize() / recordSize) + 1;
            final long padding = (numRecords * recordSize) - currEntry.getSize();
            repositionForwardBy(padding);
            throwExceptionIfPositionIsNotInArchive();
        }
        
    }
    
    private void repositionForwardTo(final long newPosition) throws IOException {
        final long currPosition = archive.position();
        if (newPosition < currPosition) {
            throw new IOException("trying to move backwards inside of the archive");
        }
        
        archive.position(newPosition);
    }
    
    private void repositionForwardBy(final long offset) throws IOException {
        repositionForwardTo(archive.position() + offset);
    }
    
    private void throwExceptionIfPositionIsNotInArchive() throws IOException {
        if (archive.size() < archive.position()) {
            throw new IOException("Truncated TAR archive");
        }
        
    }
    
    private ByteBuffer getRecord() throws IOException {
        ByteBuffer headerBuf = readRecord();
        setAtEOF(isEOFRecord(headerBuf));
        if (isAtEOF() && headerBuf != null) {
            tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; }
        return headerBuf;
    }
    
    private void tryToConsumeSecondEOFRecord() throws IOException {
        boolean shouldReset = true;
        try {
            shouldReset = !isEOFRecord(readRecord());
        }
         finally {
            if (shouldReset) {
                archive.position(archive.position() - recordSize);
            }
            
        }
        
    }
    
    private void consumeRemainderOfLastBlock() throws IOException {
        final long bytesReadOfLastBlock = archive.position() % blockSize;
        if (bytesReadOfLastBlock > 0) {
            repositionForwardBy(blockSize - bytesReadOfLastBlock);
        }
        
    }
    
    private ByteBuffer readRecord() throws IOException {
        recordBuffer.rewind();
        final int readNow = archive.read(recordBuffer);
        if (readNow != recordSize) {
            return null;
        }
        
        return recordBuffer;
    }
    
    public List<TarArchiveEntry> getEntries() {
        return new ArrayList<>(entries);
    }
    
    private boolean isEOFRecord(final ByteBuffer headerBuf) {
        return headerBuf == null || ArchiveUtils.isArrayZero(headerBuf.array(), recordSize);
    }
    
    protected final boolean isAtEOF() {
        return hasHitEOF;
    }
    
    protected final void setAtEOF(final boolean b) {
        hasHitEOF = b;
    }
    
    private boolean isDirectory() {
        return currEntry != null && currEntry.isDirectory();
    }
    
    public InputStream getInputStream(final TarArchiveEntry entry) throws IOException {
        try {
            return new BoundedTarEntryInputStream(entry, archive);
        }
         catch (RuntimeException ex) {
            throw new IOException("Corrupted TAR archive. Can't read entry", ex);
        }
        
    }
    
    public void close() throws IOException {
        archive.close();
    }
    
    private final class BoundedTarEntryInputStream extends BoundedArchiveInputStream {
        private final SeekableByteChannel channel;
        private final TarArchiveEntry entry;
        private long entryOffset;
        private int currentSparseInputStreamIndex;
        BoundedTarEntryInputStream(final TarArchiveEntry entry, final SeekableByteChannel channel) {
            super(entry.getDataOffset(), entry.getRealSize());
            this.entry = entry;
            this.channel = channel;
        }
        
        protected int read(final long pos, final ByteBuffer buf) throws IOException {
            if (entryOffset >= entry.getRealSize()) {
                return -1;
            }
            
            final int totalRead;
            if (entry.isSparse()) {
                totalRead = readSparse(entryOffset, buf, buf.limit());
            }
             else {
                totalRead = readArchive(pos, buf);
            }
            
            if (totalRead == -1) {
                if (buf.array().length > 0) {
                    throw new IOException("Truncated TAR archive");
                }
                
                setAtEOF(true);
            }
             else {
                entryOffset += totalRead;
                buf.flip();
            }
            
            return totalRead;
        }
        
        private int readSparse(final long pos, final ByteBuffer buf, final int numToRead) throws IOException {
            final List<InputStream> entrySparseInputStreams = sparseInputStreams.get(entry.getName());
            if (entrySparseInputStreams == null || entrySparseInputStreams.isEmpty()) {
                return readArchive(entry.getDataOffset() + pos, buf);
            }
            
            if (currentSparseInputStreamIndex >= entrySparseInputStreams.size()) {
                return -1;
            }
            
            final InputStream currentInputStream = entrySparseInputStreams.get(currentSparseInputStreamIndex);
            final byte[] bufArray = new byte[numToRead];
            final int readLen = currentInputStream.read(bufArray);
            if (readLen != -1) {
                buf.put(bufArray, 0, readLen);
            }
            
            if (currentSparseInputStreamIndex == entrySparseInputStreams.size() - 1) {
                return readLen;
            }
            
            if (readLen == -1) {
                currentSparseInputStreamIndex++;
                return readSparse(pos, buf, numToRead);
            }
            
            if (readLen < numToRead) {
                currentSparseInputStreamIndex++;
                final int readLenOfNext = readSparse(pos + readLen, buf, numToRead - readLen);
                if (readLenOfNext == -1) {
                    return readLen;
                }
                
                return readLen + readLenOfNext;
            }
            
            return readLen;
        }
        
        private int readArchive(final long pos, final ByteBuffer buf) throws IOException {
            channel.position(pos);
            return channel.read(buf);
        }
        
    }
    
}


