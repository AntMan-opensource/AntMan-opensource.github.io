package org.apache.commons.compress.archivers.tar;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.zip.ZipEncoding;
import org.apache.commons.compress.archivers.zip.ZipEncodingHelper;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.BoundedInputStream;
import org.apache.commons.compress.utils.IOUtils;
public class TarArchiveInputStream extends ArchiveInputStream {
    private static final int SMALL_BUFFER_SIZE = 256;
    private final byte[] smallBuf = new byte[SMALL_BUFFER_SIZE];
    private final int recordSize;
    private final byte[] recordBuffer;
    private final int blockSize;
    private boolean hasHitEOF;
    private long entrySize;
    private long entryOffset;
    private final InputStream inputStream;
    private List<InputStream> sparseInputStreams;
    private int currentSparseInputStreamIndex;
    private TarArchiveEntry currEntry;
    private final ZipEncoding zipEncoding;
    final String encoding;
    private Map<String, String> globalPaxHeaders = new HashMap<>();
    private final List<TarArchiveStructSparse> globalSparseHeaders = new ArrayList<>();
    private final boolean lenient;
    public TarArchiveInputStream(final InputStream is) {
        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);
    }
    
    public TarArchiveInputStream(final InputStream is, final boolean lenient) {
        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, null, lenient);
    }
    
    public TarArchiveInputStream(final InputStream is, final String encoding) {
        this(is, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE, encoding);
    }
    
    public TarArchiveInputStream(final InputStream is, final int blockSize) {
        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE);
    }
    
    public TarArchiveInputStream(final InputStream is, final int blockSize, final String encoding) {
        this(is, blockSize, TarConstants.DEFAULT_RCDSIZE, encoding);
    }
    
    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize) {
        this(is, blockSize, recordSize, null);
    }
    
    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding) {
        this(is, blockSize, recordSize, encoding, false);
    }
    
    public TarArchiveInputStream(final InputStream is, final int blockSize, final int recordSize, final String encoding, final boolean lenient) {
        this.inputStream = is;
        this.hasHitEOF = false;
        this.encoding = encoding;
        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
        this.recordSize = recordSize;
        this.recordBuffer = new byte[recordSize];
        this.blockSize = blockSize;
        this.lenient = lenient;
    }
    
    public void close() throws IOException {
        if(sparseInputStreams != null) {
            for (final InputStream inputStream : sparseInputStreams) {
                inputStream.close();
            }
            
        }
        
        inputStream.close();
    }
    
    public int getRecordSize() {
        return recordSize;
    }
    
    public int available() throws IOException {
        if (isDirectory()) {
            return 0;
        }
        
        if (currEntry.getRealSize() - entryOffset > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        
        return (int) (currEntry.getRealSize() - entryOffset);
    }
    
    public long skip(final long n) throws IOException {
        if (n <= 0 || isDirectory()) {
            return 0;
        }
        
        final long availableOfInputStream = inputStream.available();
        final long available = currEntry.getRealSize() - entryOffset;
        final long numToSkip = Math.min(n, available);
        long skipped;
        if (!currEntry.isSparse()) {
            skipped = IOUtils.skip(inputStream, numToSkip);
            skipped = getActuallySkipped(availableOfInputStream, skipped, numToSkip);
        }
         else {
            skipped = skipSparse(numToSkip);
        }
        
        count(skipped);
        entryOffset += skipped;
        return skipped;
    }
    
    private long skipSparse(final long n) throws IOException {
        if (sparseInputStreams == null || sparseInputStreams.isEmpty()) {
            return inputStream.skip(n);
        }
        
        long bytesSkipped = 0;
        while (bytesSkipped < n && currentSparseInputStreamIndex < sparseInputStreams.size()) {
            final InputStream  currentInputStream = sparseInputStreams.get(currentSparseInputStreamIndex);
            bytesSkipped += currentInputStream.skip(n - bytesSkipped);
            if (bytesSkipped < n) {
                currentSparseInputStreamIndex++;
            }
            
        }
        
        return bytesSkipped;
    }
    
    public boolean markSupported() {
        return false;
    }
    
    public synchronized void mark(final int markLimit) {
    }
    
    public synchronized void reset() {
    }
    
    public TarArchiveEntry getNextTarEntry() throws IOException {
        if (isAtEOF()) {
            return null;
        }
        
        if (currEntry != null) {
            IOUtils.skip(this, Long.MAX_VALUE);
            skipRecordPadding();
        }
        
        final byte[] headerBuf = getRecord();
        if (headerBuf == null) {
            currEntry = null;
            return null;
        }
        
        try {
            currEntry = new TarArchiveEntry(headerBuf, zipEncoding, lenient);
        }
         catch (final IllegalArgumentException e) {
            throw new IOException("Error detected parsing the header", e);
        }
        
        entryOffset = 0;
        entrySize = currEntry.getSize();
        if (currEntry.isGNULongLinkEntry()) {
            final byte[] longLinkData = getLongNameData();
            if (longLinkData == null) {
                return null;
            }
            
            currEntry.setLinkName(zipEncoding.decode(longLinkData));
        }
        
        if (currEntry.isGNULongNameEntry()) {
            final byte[] longNameData = getLongNameData();
            if (longNameData == null) {
                return null;
            }
            
            final String name = zipEncoding.decode(longNameData);
            currEntry.setName(name);
            if (currEntry.isDirectory() && !name.endsWith("/")) {
                currEntry.setName(name + "/");
            }
            
        }
        
        if (currEntry.isGlobalPaxHeader()){ 
            readGlobalPaxHeaders();
        }
        
        try {
            if (currEntry.isPaxHeader()){ 
                paxHeaders();
            }
             else if (!globalPaxHeaders.isEmpty()) {
                applyPaxHeadersToCurrentEntry(globalPaxHeaders, globalSparseHeaders);
            }
            
        }
         catch (final NumberFormatException e) {
            throw new IOException("Error detected parsing the pax header", e);
        }
        
        if (currEntry.isOldGNUSparse()){ 
            readOldGNUSparse();
        }
        
        entrySize = currEntry.getSize();
        return currEntry;
    }
    
    private void skipRecordPadding() throws IOException {
        if (!isDirectory() && this.entrySize > 0 && this.entrySize % this.recordSize != 0) {
            final long available = inputStream.available();
            final long numRecords = (this.entrySize / this.recordSize) + 1;
            final long padding = (numRecords * this.recordSize) - this.entrySize;
            long skipped = IOUtils.skip(inputStream, padding);
            skipped = getActuallySkipped(available, skipped, padding);
            count(skipped);
        }
        
    }
    
    private long getActuallySkipped(final long available, final long skipped, final long expected) throws IOException {
        long actuallySkipped = skipped;
        if (inputStream instanceof FileInputStream) {
            actuallySkipped = Math.min(skipped, available);
        }
        
        if (actuallySkipped != expected) {
            throw new IOException("Truncated TAR archive");
        }
        
        return actuallySkipped;
    }
    
    protected byte[] getLongNameData() throws IOException {
        final ByteArrayOutputStream longName = new ByteArrayOutputStream();
        int length = 0;
        while ((length = read(smallBuf)) >= 0) {
            longName.write(smallBuf, 0, length);
        }
        
        getNextEntry();
        if (currEntry == null) {
            return null;
        }
        
        byte[] longNameData = longName.toByteArray();
        length = longNameData.length;
        while (length > 0 && longNameData[length - 1] == 0) { --length;
        }
        
        if (length != longNameData.length) {
            final byte[] l = new byte[length];
            System.arraycopy(longNameData, 0, l, 0, length);
            longNameData = l;
        }
        
        return longNameData;
    }
    
    private byte[] getRecord() throws IOException {
        byte[] headerBuf = readRecord();
        setAtEOF(isEOFRecord(headerBuf));
        if (isAtEOF() && headerBuf != null) {
            tryToConsumeSecondEOFRecord(); consumeRemainderOfLastBlock(); headerBuf = null; }
        return headerBuf;
    }
    
    protected boolean isEOFRecord(final byte[] record) {
        return record == null || ArchiveUtils.isArrayZero(record, recordSize);
    }
    
    protected byte[] readRecord() throws IOException {
        final int readNow = IOUtils.readFully(inputStream, recordBuffer);
        count(readNow);
        if (readNow != recordSize) {
            return null;
        }
        
        return recordBuffer;
    }
    
    private void readGlobalPaxHeaders() throws IOException {
        globalPaxHeaders = TarUtils.parsePaxHeaders(this, globalSparseHeaders, globalPaxHeaders);
        getNextEntry(); 
        if (currEntry == null) {
            throw new IOException("Error detected parsing the pax header");
        }
        
    }
    
    private void paxHeaders() throws IOException {
        List<TarArchiveStructSparse> sparseHeaders = new ArrayList<>();
        final Map<String, String> headers = TarUtils.parsePaxHeaders(this, sparseHeaders, globalPaxHeaders);
        if (headers.containsKey("GNU.sparse.map")) {
            sparseHeaders = new ArrayList<>(TarUtils.parseFromPAX01SparseHeaders(headers.get("GNU.sparse.map")));
        }
        
        getNextEntry(); 
        if (currEntry == null) {
            throw new IOException("premature end of tar archive. Didn't find any entry after PAX header.");
        }
        
        applyPaxHeadersToCurrentEntry(headers, sparseHeaders);
        if (currEntry.isPaxGNU1XSparse()) {
            sparseHeaders = TarUtils.parsePAX1XSparseHeaders(inputStream, recordSize);
            currEntry.setSparseHeaders(sparseHeaders);
        }
        
        buildSparseInputStreams();
    }
    
    private void applyPaxHeadersToCurrentEntry(final Map<String, String> headers, final List<TarArchiveStructSparse> sparseHeaders) throws IOException {
        currEntry.updateEntryFromPaxHeaders(headers);
        currEntry.setSparseHeaders(sparseHeaders);
    }
    
    private void readOldGNUSparse() throws IOException {
        if (currEntry.isExtended()) {
            TarArchiveSparseEntry entry;
            do {
                final byte[] headerBuf = getRecord();
                if (headerBuf == null) {
                    throw new IOException("premature end of tar archive. Didn't find extended_header after header with extended flag.");
                }
                
                entry = new TarArchiveSparseEntry(headerBuf);
                currEntry.getSparseHeaders().addAll(entry.getSparseHeaders());
            }
             while (entry.isExtended());
        }
        
        buildSparseInputStreams();
    }
    
    private boolean isDirectory() {
        return currEntry != null && currEntry.isDirectory();
    }
    
    public ArchiveEntry getNextEntry() throws IOException {
        return getNextTarEntry();
    }
    
    private void tryToConsumeSecondEOFRecord() throws IOException {
        boolean shouldReset = true;
        final boolean marked = inputStream.markSupported();
        if (marked) {
            inputStream.mark(recordSize);
        }
        
        try {
            shouldReset = !isEOFRecord(readRecord());
        }
         finally {
            if (shouldReset && marked) {
                pushedBackBytes(recordSize);
            	inputStream.reset();
            }
            
        }
        
    }
    
    public int read(final byte[] buf, final int offset, int numToRead) throws IOException {
        if (numToRead == 0) {
            return 0;
        }
        
    	int totalRead = 0;
        if (isAtEOF() || isDirectory()) {
            return -1;
        }
        
        if (currEntry == null) {
            throw new IllegalStateException("No current tar entry");
        }
        
        if (entryOffset >= currEntry.getRealSize()) {
            return -1;
        }
        
        numToRead = Math.min(numToRead, available());
        if (currEntry.isSparse()) {
            totalRead = readSparse(buf, offset, numToRead);
        }
         else {
            totalRead = inputStream.read(buf, offset, numToRead);
        }
        
        if (totalRead == -1) {
            if (numToRead > 0) {
                throw new IOException("Truncated TAR archive");
            }
            
            setAtEOF(true);
        }
         else {
            count(totalRead);
            entryOffset += totalRead;
        }
        
        return totalRead;
    }
    
    private int readSparse(final byte[] buf, final int offset, final int numToRead) throws IOException {
        if (sparseInputStreams == null || sparseInputStreams.isEmpty()) {
            return inputStream.read(buf, offset, numToRead);
        }
        
        if (currentSparseInputStreamIndex >= sparseInputStreams.size()) {
            return -1;
        }
        
        final InputStream currentInputStream = sparseInputStreams.get(currentSparseInputStreamIndex);
        final int readLen = currentInputStream.read(buf, offset, numToRead);
        if (currentSparseInputStreamIndex == sparseInputStreams.size() - 1) {
            return readLen;
        }
        
        if (readLen == -1) {
            currentSparseInputStreamIndex++;
            return readSparse(buf, offset, numToRead);
        }
        
        if (readLen < numToRead) {
            currentSparseInputStreamIndex++;
            final int readLenOfNext = readSparse(buf, offset + readLen, numToRead - readLen);
            if (readLenOfNext == -1) {
                return readLen;
            }
            
            return readLen + readLenOfNext;
        }
        
        return readLen;
    }
    
    public boolean canReadEntryData(final ArchiveEntry ae) {
        return ae instanceof TarArchiveEntry;
    }
    
    public TarArchiveEntry getCurrentEntry() {
        return currEntry;
    }
    
    protected final void setCurrentEntry(final TarArchiveEntry e) {
        currEntry = e;
    }
    
    protected final boolean isAtEOF() {
        return hasHitEOF;
    }
    
    protected final void setAtEOF(final boolean b) {
        hasHitEOF = b;
    }
    
    private void consumeRemainderOfLastBlock() throws IOException {
        final long bytesReadOfLastBlock = getBytesRead() % blockSize;
        if (bytesReadOfLastBlock > 0) {
            final long skipped = IOUtils.skip(inputStream, blockSize - bytesReadOfLastBlock);
            count(skipped);
        }
        
    }
    
    public static boolean matches(final byte[] signature, final int length) {
        if (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {
            return false;
        }
        
        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) ){
            return true;
        }
        
        if (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ( ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) || ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN) ) ){
            return true;
        }
        
        return ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT, signature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN) && ArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT, signature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN);
    }
    
    private void buildSparseInputStreams() throws IOException {
        currentSparseInputStreamIndex = -1;
        sparseInputStreams = new ArrayList<>();
        final List<TarArchiveStructSparse> sparseHeaders = currEntry.getOrderedSparseHeaders();
        final InputStream zeroInputStream = new TarArchiveSparseZeroInputStream(); 
        long offset = 0;
        for (final TarArchiveStructSparse sparseHeader : sparseHeaders) {
            final long zeroBlockSize = sparseHeader.getOffset() - offset;
            if (zeroBlockSize < 0) {
                throw new IOException("Corrupted struct sparse detected");
            }
            
            if (zeroBlockSize > 0) {
                sparseInputStreams.add(new BoundedInputStream(zeroInputStream, sparseHeader.getOffset() - offset));
            }
            
            if (sparseHeader.getNumbytes() > 0) {
                sparseInputStreams.add(new BoundedInputStream(inputStream, sparseHeader.getNumbytes()));
            }
            
            offset = sparseHeader.getOffset() + sparseHeader.getNumbytes();
        }
        
        if (!sparseInputStreams.isEmpty()) {
            currentSparseInputStreamIndex = 0;
        }
        
    }
    
}


