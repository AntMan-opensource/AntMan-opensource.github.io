package org.springframework.web.reactive.result.method;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;
import org.springframework.aop.support.AopUtils;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.MethodIntrospector;
import org.springframework.http.server.RequestPath;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsUtils;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.reactive.HandlerMapping;
import org.springframework.web.reactive.handler.AbstractHandlerMapping;
import org.springframework.web.server.ServerWebExchange;
public abstract class AbstractHandlerMethodMapping<T> extends AbstractHandlerMapping implements InitializingBean {
	 private static final String SCOPED_TARGET_NAME_PREFIX = "scopedTarget.";
	 private static final HandlerMethod PREFLIGHT_AMBIGUOUS_MATCH = new HandlerMethod(new PreFlightAmbiguousMatchHandler(), ClassUtils.getMethod(PreFlightAmbiguousMatchHandler.class, "handle"));
	private static final CorsConfiguration ALLOW_CORS_CONFIG = new CorsConfiguration();
	static {
		ALLOW_CORS_CONFIG.addAllowedOrigin("*");
		ALLOW_CORS_CONFIG.addAllowedMethod("*");
		ALLOW_CORS_CONFIG.addAllowedHeader("*");
		ALLOW_CORS_CONFIG.setAllowCredentials(true);
	}
	
	private final MappingRegistry mappingRegistry = new MappingRegistry();
	 public Map<T, HandlerMethod> getHandlerMethods() {
		this.mappingRegistry.acquireReadLock();
		try {
			return Collections.unmodifiableMap(this.mappingRegistry.getMappings());
		}
		
		finally {
			this.mappingRegistry.releaseReadLock();
		}
		
	}
	
	 MappingRegistry getMappingRegistry() {
		return this.mappingRegistry;
	}
	
	 public void registerMapping(T mapping, Object handler, Method method) {
		if (logger.isTraceEnabled()) {
			logger.trace("Register \"" + mapping + "\" to " + method.toGenericString());
		}
		
		this.mappingRegistry.register(mapping, handler, method);
	}
	
	 public void unregisterMapping(T mapping) {
		if (logger.isTraceEnabled()) {
			logger.trace("Unregister mapping \"" + mapping);
		}
		
		this.mappingRegistry.unregister(mapping);
	}
	
	public void afterPropertiesSet() {
		initHandlerMethods();
		 int total = this.getHandlerMethods().size();
		if ((logger.isTraceEnabled() && total == 0) || (logger.isDebugEnabled() && total > 0) ) {
			logger.debug(total + " mappings in " + formatMappingName());
		}
		
	}
	
	 protected void initHandlerMethods() {
		String[] beanNames = obtainApplicationContext().getBeanNamesForType(Object.class);
		for (String beanName : beanNames) {
			if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
				Class<?> beanType = null;
				try {
					beanType = obtainApplicationContext().getType(beanName);
				}
				
				catch (Throwable ex) {
					 if (logger.isTraceEnabled()) {
						logger.trace("Could not resolve type for bean '" + beanName + "'", ex);
					}
					
				}
				
				if (beanType != null && isHandler(beanType)) {
					detectHandlerMethods(beanName);
				}
				
			}
			
		}
		
		handlerMethodsInitialized(getHandlerMethods());
	}
	
	 protected void detectHandlerMethods(final Object handler) {
		Class<?> handlerType = (handler instanceof String ? obtainApplicationContext().getType((String) handler) : handler.getClass());
		if (handlerType != null) {
			final Class<?> userType = ClassUtils.getUserClass(handlerType);
			Map<Method, T> methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup<T>) method -> getMappingForMethod(method, userType));
			if (logger.isTraceEnabled()) {
				logger.trace(formatMappings(userType, methods));
			}
			
			methods.forEach((method, mapping) -> {
				Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);
				registerHandlerMethod(handler, invocableMethod, mapping);
			}
			
);
		}
		
	}
	
	private String formatMappings(Class<?> userType, Map<Method, T> methods) {
		String formattedType = Arrays.stream(ClassUtils.getPackageName(userType).split("\\.")) .map(p -> p.substring(0, 1)) .collect(Collectors.joining(".", "", "." + userType.getSimpleName()));
		Function<Method, String> methodFormatter = method -> Arrays.stream(method.getParameterTypes()) .map(Class::getSimpleName) .collect(Collectors.joining(",", "(", ")"));
		return methods.entrySet().stream() .map(e -> {
					Method method = e.getKey();
					return e.getValue() + ": " + method.getName() + methodFormatter.apply(method);
				}
) .collect(Collectors.joining("\n\t", "\n\t" + formattedType + ":" + "\n\t", ""));
	}
	
	 protected void registerHandlerMethod(Object handler, Method method, T mapping) {
		this.mappingRegistry.register(mapping, handler, method);
	}
	
	 protected HandlerMethod createHandlerMethod(Object handler, Method method) {
		if (handler instanceof String) {
			return new HandlerMethod((String) handler, obtainApplicationContext().getAutowireCapableBeanFactory(), method);
		}
		
		return new HandlerMethod(handler, method);
	}
	
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method, T mapping) {
		return null;
	}
	
	 protected void handlerMethodsInitialized(Map<T, HandlerMethod> handlerMethods) {
	}
	
	public Mono<HandlerMethod> getHandlerInternal(ServerWebExchange exchange) {
		this.mappingRegistry.acquireReadLock();
		try {
			HandlerMethod handlerMethod;
			try {
				handlerMethod = lookupHandlerMethod(exchange);
			}
			
			catch (Exception ex) {
				return Mono.error(ex);
			}
			
			if (handlerMethod != null) {
				handlerMethod = handlerMethod.createWithResolvedBean();
			}
			
			return Mono.justOrEmpty(handlerMethod);
		}
		
		finally {
			this.mappingRegistry.releaseReadLock();
		}
		
	}
	
	protected HandlerMethod lookupHandlerMethod(ServerWebExchange exchange) throws Exception {
		List<Match> matches = new ArrayList<>();
		addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, exchange);
		if (!matches.isEmpty()) {
			Comparator<Match> comparator = new MatchComparator(getMappingComparator(exchange));
			matches.sort(comparator);
			Match bestMatch = matches.get(0);
			if (matches.size() > 1) {
				if (logger.isTraceEnabled()) {
					logger.trace(exchange.getLogPrefix() + matches.size() + " matching mappings: " + matches);
				}
				
				if (CorsUtils.isPreFlightRequest(exchange.getRequest())) {
					return PREFLIGHT_AMBIGUOUS_MATCH;
				}
				
				Match secondBestMatch = matches.get(1);
				if (comparator.compare(bestMatch, secondBestMatch) == 0) {
					Method m1 = bestMatch.handlerMethod.getMethod();
					Method m2 = secondBestMatch.handlerMethod.getMethod();
					RequestPath path = exchange.getRequest().getPath();
					throw new IllegalStateException( "Ambiguous handler methods mapped for '" + path + "': {" + m1 + ", " + m2 + "}");
				}
				
			}
			
			handleMatch(bestMatch.mapping, bestMatch.handlerMethod, exchange);
			return bestMatch.handlerMethod;
		}
		
		else {
			return handleNoMatch(this.mappingRegistry.getMappings().keySet(), exchange);
		}
		
	}
	
	private void addMatchingMappings(Collection<T> mappings, List<Match> matches, ServerWebExchange exchange) {
		for (T mapping : mappings) {
			T match = getMatchingMapping(mapping, exchange);
			if (match != null) {
				matches.add(new Match(match, this.mappingRegistry.getMappings().get(mapping)));
			}
			
		}
		
	}
	
	 protected void handleMatch(T mapping, HandlerMethod handlerMethod, ServerWebExchange exchange) {
	}
	
	protected HandlerMethod handleNoMatch(Set<T> mappings, ServerWebExchange exchange) throws Exception {
		return null;
	}
	
	protected boolean hasCorsConfigurationSource(Object handler) {
		return super.hasCorsConfigurationSource(handler) || (handler instanceof HandlerMethod && this.mappingRegistry.getCorsConfiguration((HandlerMethod) handler) != null) || handler.equals(PREFLIGHT_AMBIGUOUS_MATCH);
	}
	
	protected CorsConfiguration getCorsConfiguration(Object handler, ServerWebExchange exchange) {
		CorsConfiguration corsConfig = super.getCorsConfiguration(handler, exchange);
		if (handler instanceof HandlerMethod) {
			HandlerMethod handlerMethod = (HandlerMethod) handler;
			if (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) {
				return ALLOW_CORS_CONFIG;
			}
			
			CorsConfiguration methodConfig = this.mappingRegistry.getCorsConfiguration(handlerMethod);
			corsConfig = (corsConfig != null ? corsConfig.combine(methodConfig) : methodConfig);
		}
		
		return corsConfig;
	}
	
	 protected abstract boolean isHandler(Class<?> beanType);
	protected abstract T getMappingForMethod(Method method, Class<?> handlerType);
	protected abstract T getMatchingMapping(T mapping, ServerWebExchange exchange);
	 protected abstract Comparator<T> getMappingComparator(ServerWebExchange exchange);
	 class MappingRegistry {
		private final Map<T, MappingRegistration<T>> registry = new HashMap<>();
		private final Map<T, HandlerMethod> mappingLookup = new LinkedHashMap<>();
		private final Map<HandlerMethod, CorsConfiguration> corsLookup = new ConcurrentHashMap<>();
		private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
		 public Map<T, HandlerMethod> getMappings() {
			return this.mappingLookup;
		}
		
		public CorsConfiguration getCorsConfiguration(HandlerMethod handlerMethod) {
			HandlerMethod original = handlerMethod.getResolvedFromHandlerMethod();
			return this.corsLookup.get(original != null ? original : handlerMethod);
		}
		
		 public void acquireReadLock() {
			this.readWriteLock.readLock().lock();
		}
		
		 public void releaseReadLock() {
			this.readWriteLock.readLock().unlock();
		}
		
		public void register(T mapping, Object handler, Method method) {
			this.readWriteLock.writeLock().lock();
			try {
				HandlerMethod handlerMethod = createHandlerMethod(handler, method);
				validateMethodMapping(handlerMethod, mapping);
				this.mappingLookup.put(mapping, handlerMethod);
				CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);
				if (corsConfig != null) {
					this.corsLookup.put(handlerMethod, corsConfig);
				}
				
				this.registry.put(mapping, new MappingRegistration<>(mapping, handlerMethod));
			}
			
			finally {
				this.readWriteLock.writeLock().unlock();
			}
			
		}
		
		private void validateMethodMapping(HandlerMethod handlerMethod, T mapping) {
			 HandlerMethod existingHandlerMethod = this.mappingLookup.get(mapping);
			if (existingHandlerMethod != null && !existingHandlerMethod.equals(handlerMethod)) {
				throw new IllegalStateException( "Ambiguous mapping. Cannot map '" + handlerMethod.getBean() + "' method \n" + handlerMethod + "\nto " + mapping + ": There is already '" + existingHandlerMethod.getBean() + "' bean method\n" + existingHandlerMethod + " mapped.");
			}
			
		}
		
		public void unregister(T mapping) {
			this.readWriteLock.writeLock().lock();
			try {
				MappingRegistration<T> definition = this.registry.remove(mapping);
				if (definition == null) {
					return;
				}
				
				this.mappingLookup.remove(definition.getMapping());
				this.corsLookup.remove(definition.getHandlerMethod());
			}
			
			finally {
				this.readWriteLock.writeLock().unlock();
			}
			
		}
		
	}
	
	private static class MappingRegistration<T> {
		private final T mapping;
		private final HandlerMethod handlerMethod;
		public MappingRegistration(T mapping, HandlerMethod handlerMethod) {
			Assert.notNull(mapping, "Mapping must not be null");
			Assert.notNull(handlerMethod, "HandlerMethod must not be null");
			this.mapping = mapping;
			this.handlerMethod = handlerMethod;
		}
		
		public T getMapping() {
			return this.mapping;
		}
		
		public HandlerMethod getHandlerMethod() {
			return this.handlerMethod;
		}
		
	}
	
	 private class Match {
		private final T mapping;
		private final HandlerMethod handlerMethod;
		public Match(T mapping, HandlerMethod handlerMethod) {
			this.mapping = mapping;
			this.handlerMethod = handlerMethod;
		}
		
		public String toString() {
			return this.mapping.toString();
		}
		
	}
	
	private class MatchComparator implements Comparator<Match> {
		private final Comparator<T> comparator;
		public MatchComparator(Comparator<T> comparator) {
			this.comparator = comparator;
		}
		
		public int compare(Match match1, Match match2) {
			return this.comparator.compare(match1.mapping, match2.mapping);
		}
		
	}
	
	private static class PreFlightAmbiguousMatchHandler {
		public void handle() {
			throw new UnsupportedOperationException("Not implemented");
		}
		
	}
	
}


