package io.grpc.xds;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Stopwatch;
import com.google.common.base.Supplier;
import com.google.protobuf.Any;
import com.google.rpc.Code;
import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;
import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;
import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;
import io.grpc.Channel;
import io.grpc.Context;
import io.grpc.InternalLogId;
import io.grpc.ManagedChannel;
import io.grpc.Status;
import io.grpc.SynchronizationContext;
import io.grpc.SynchronizationContext.ScheduledHandle;
import io.grpc.internal.BackoffPolicy;
import io.grpc.stub.ClientCallStreamObserver;
import io.grpc.stub.ClientResponseObserver;
import io.grpc.stub.StreamObserver;
import io.grpc.xds.Bootstrapper.ServerInfo;
import io.grpc.xds.EnvoyProtoData.Node;
import io.grpc.xds.XdsClient.ResourceStore;
import io.grpc.xds.XdsClient.XdsResponseHandler;
import io.grpc.xds.XdsClientImpl.XdsChannelFactory;
import io.grpc.xds.XdsLogger.XdsLogLevel;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
final class AbstractXdsClient {
  private final SynchronizationContext syncContext;
  private final InternalLogId logId;
  private final XdsLogger logger;
  private final ServerInfo serverInfo;
  private final ManagedChannel channel;
  private final XdsResponseHandler xdsResponseHandler;
  private final ResourceStore resourceStore;
  private final Context context;
  private final ScheduledExecutorService timeService;
  private final BackoffPolicy.Provider backoffPolicyProvider;
  private final Stopwatch stopwatch;
  private final Node bootstrapNode;
  private final XdsClient.TimerLaunch timerLaunch;
  private final Map<XdsResourceType<?>, String> versions = new HashMap<>();
  private boolean shutdown;
  private AbstractAdsStream adsStream;
  private BackoffPolicy retryBackoffPolicy;
  private ScheduledHandle rpcRetryTimer;
  AbstractXdsClient( XdsChannelFactory xdsChannelFactory, ServerInfo serverInfo, Node bootstrapNode, XdsResponseHandler xdsResponseHandler, ResourceStore resourceStore, Context context, ScheduledExecutorService timeService, SynchronizationContext syncContext, BackoffPolicy.Provider backoffPolicyProvider, Supplier<Stopwatch> stopwatchSupplier, XdsClient.TimerLaunch timerLaunch) {
    this.serverInfo = checkNotNull(serverInfo, "serverInfo");
    this.channel = checkNotNull(xdsChannelFactory, "xdsChannelFactory").create(serverInfo);
    this.xdsResponseHandler = checkNotNull(xdsResponseHandler, "xdsResponseHandler");
    this.resourceStore = checkNotNull(resourceStore, "resourcesSubscriber");
    this.bootstrapNode = checkNotNull(bootstrapNode, "bootstrapNode");
    this.context = checkNotNull(context, "context");
    this.timeService = checkNotNull(timeService, "timeService");
    this.syncContext = checkNotNull(syncContext, "syncContext");
    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, "backoffPolicyProvider");
    this.timerLaunch  = checkNotNull(timerLaunch, "timerLaunch");
    stopwatch = checkNotNull(stopwatchSupplier, "stopwatchSupplier").get();
    logId = InternalLogId.allocate("xds-client", serverInfo.target());
    logger = XdsLogger.withLogId(logId);
    logger.log(XdsLogLevel.INFO, "Created");
  }
  
  Channel channel() {
    return channel;
  }
  
  void shutdown() {
    syncContext.execute(new Runnable() {
      public void run() {
        shutdown = true;
        logger.log(XdsLogLevel.INFO, "Shutting down");
        if (adsStream != null) {
          adsStream.close(Status.CANCELLED.withDescription("shutdown").asException());
        }
        
        if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {
          rpcRetryTimer.cancel();
        }
        
        channel.shutdown();
      }
      
    }
    
);
  }
  
  public String toString() {
    return logId.toString();
  }
  
  void adjustResourceSubscription(XdsResourceType<?> resourceType) {
    if (isInBackoff()) {
      return;
    }
    
    if (adsStream == null) {
      startRpcStream();
    }
    
    Collection<String> resources = resourceStore.getSubscribedResources(serverInfo, resourceType);
    if (resources != null) {
      adsStream.sendDiscoveryRequest(resourceType, resources);
    }
    
  }
  
  void ackResponse(XdsResourceType<?> type, String versionInfo, String nonce) {
    versions.put(type, versionInfo);
    logger.log(XdsLogLevel.INFO, "Sending ACK for {0} update, nonce: {1}, current version: {2}", type.typeName(), nonce, versionInfo);
    Collection<String> resources = resourceStore.getSubscribedResources(serverInfo, type);
    if (resources == null) {
      resources = Collections.emptyList();
    }
    
    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);
  }
  
  void nackResponse(XdsResourceType<?> type, String nonce, String errorDetail) {
    String versionInfo = versions.getOrDefault(type, "");
    logger.log(XdsLogLevel.INFO, "Sending NACK for {0} update, nonce: {1}, current version: {2}", type.typeName(), nonce, versionInfo);
    Collection<String> resources = resourceStore.getSubscribedResources(serverInfo, type);
    if (resources == null) {
      resources = Collections.emptyList();
    }
    
    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);
  }
  
  boolean isInBackoff() {
    return rpcRetryTimer != null && rpcRetryTimer.isPending();
  }
  
  boolean isReady() {
    return adsStream != null && adsStream.isReady();
  }
  
  void readyHandler() {
    if (!isReady()) {
      return;
    }
    
    timerLaunch.startSubscriberTimersIfNeeded(serverInfo);
  }
  
  private void startRpcStream() {
    checkState(adsStream == null, "Previous adsStream has not been cleared yet");
    adsStream = new AdsStreamV3();
    Context prevContext = context.attach();
    try {
      adsStream.start();
    }
     finally {
      context.detach(prevContext);
    }
    
    logger.log(XdsLogLevel.INFO, "ADS stream started");
    stopwatch.reset().start();
  }
  
  @VisibleForTesting
  final class RpcRetryTask implements Runnable {
    public void run() {
      if (shutdown) {
        return;
      }
      
      startRpcStream();
      Set<XdsResourceType<?>> subscribedResourceTypes = new HashSet<>(resourceStore.getSubscribedResourceTypesWithTypeUrl().values());
      for (XdsResourceType<?> type : subscribedResourceTypes) {
        Collection<String> resources = resourceStore.getSubscribedResources(serverInfo, type);
        if (resources != null) {
          adsStream.sendDiscoveryRequest(type, resources);
        }
        
      }
      
      xdsResponseHandler.handleStreamRestarted(serverInfo);
    }
    
  }
  
  @Nullable
  XdsResourceType<?> fromTypeUrl(String typeUrl) {
    return resourceStore.getSubscribedResourceTypesWithTypeUrl().get(typeUrl);
  }
  
  private abstract class AbstractAdsStream {
    private boolean responseReceived;
    private boolean closed;
    private final Map<XdsResourceType<?>, String> respNonces = new HashMap<>();
    abstract void start();
    abstract void sendError(Exception error);
    abstract boolean isReady();
    abstract void sendDiscoveryRequest(XdsResourceType<?> type, String version, Collection<String> resources, String nonce, @Nullable String errorDetail);
    final void sendDiscoveryRequest(XdsResourceType<?> type, Collection<String> resources) {
      logger.log(XdsLogLevel.INFO, "Sending {0} request for resources: {1}", type, resources);
      sendDiscoveryRequest(type, versions.getOrDefault(type, ""), resources, respNonces.getOrDefault(type, ""), null);
    }
    
    final void handleRpcResponse(XdsResourceType<?> type, String versionInfo, List<Any> resources, String nonce) {
      checkNotNull(type, "type");
      if (closed) {
        return;
      }
      
      responseReceived = true;
      respNonces.put(type, nonce);
      xdsResponseHandler.handleResourceResponse(type, serverInfo, versionInfo, resources, nonce);
    }
    
    final void handleRpcError(Throwable t) {
      handleRpcStreamClosed(Status.fromThrowable(t));
    }
    
    final void handleRpcCompleted() {
      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription("Closed by server"));
    }
    
    private void handleRpcStreamClosed(Status error) {
      checkArgument(!error.isOk(), "unexpected OK status");
      if (closed) {
        return;
      }
      
      logger.log( XdsLogLevel.ERROR, "ADS stream closed with status {0}: {1}. Cause: {2}", error.getCode(), error.getDescription(), error.getCause());
      closed = true;
      xdsResponseHandler.handleStreamClosed(error);
      cleanUp();
      if (responseReceived || retryBackoffPolicy == null) {
        retryBackoffPolicy = backoffPolicyProvider.get();
      }
      
      long delayNanos = Math.max( 0, retryBackoffPolicy.nextBackoffNanos() - stopwatch.elapsed(TimeUnit.NANOSECONDS));
      logger.log(XdsLogLevel.INFO, "Retry ADS stream in {0} ns", delayNanos);
      rpcRetryTimer = syncContext.schedule( new RpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS, timeService);
    }
    
    private void close(Exception error) {
      if (closed) {
        return;
      }
      
      closed = true;
      cleanUp();
      sendError(error);
    }
    
    private void cleanUp() {
      if (adsStream == this) {
        adsStream = null;
      }
      
    }
    
  }
  
  private final class AdsStreamV3 extends AbstractAdsStream {
    private StreamObserver<DiscoveryRequest> requestWriter;
    public boolean isReady() {
      return requestWriter != null && ((ClientCallStreamObserver<?>) requestWriter).isReady();
    }
    
    @Override
    void start() {
      AggregatedDiscoveryServiceGrpc.AggregatedDiscoveryServiceStub stub = AggregatedDiscoveryServiceGrpc.newStub(channel);
      StreamObserver<DiscoveryResponse> responseReader = new ClientResponseObserver<DiscoveryRequest,DiscoveryResponse>() { 

        public void beforeStart(ClientCallStreamObserver<DiscoveryRequest> requestStream) {
          requestStream.setOnReadyHandler(AbstractXdsClient.this::readyHandler);
        }
        
        public void onNext(final DiscoveryResponse response) {
          syncContext.execute(new Runnable() {
            public void run() {
              XdsResourceType<?> type = fromTypeUrl(response.getTypeUrl());
              if (logger.isLoggable(XdsLogLevel.DEBUG)) {
                logger.log( XdsLogLevel.DEBUG, "Received {0} response:\n{1}", type, MessagePrinter.print(response));
              }
              
              if (type == null) {
                logger.log( XdsLogLevel.WARNING, "Ignore an unknown type of DiscoveryResponse: {0}", response.getTypeUrl());
                return;
              }
              
              handleRpcResponse(type, response.getVersionInfo(), response.getResourcesList(), response.getNonce());
            }
            
          }
          
);
        }
        
        public void onError(final Throwable t) {
          syncContext.execute(new Runnable() {
            public void run() {
              handleRpcError(t);
            }
            
          }
          
);
        }
        
        public void onCompleted() {
          syncContext.execute(new Runnable() {
            public void run() {
              handleRpcCompleted();
            }
            
          }
          
);
        }
        
      };
      requestWriter = stub.withWaitForReady().streamAggregatedResources(responseReader);
    }
    
    @Override
    void sendDiscoveryRequest(XdsResourceType<?> type, String versionInfo, Collection<String> resources, String nonce, @Nullable String errorDetail) {
      checkState(requestWriter != null, "ADS stream has not been started");
      DiscoveryRequest.Builder builder = DiscoveryRequest.newBuilder() .setVersionInfo(versionInfo) .setNode(bootstrapNode.toEnvoyProtoNode()) .addAllResourceNames(resources) .setTypeUrl(type.typeUrl()) .setResponseNonce(nonce);
      if (errorDetail != null) {
        com.google.rpc.Status error = com.google.rpc.Status.newBuilder() .setCode(Code.INVALID_ARGUMENT_VALUE)   .setMessage(errorDetail) .build();
        builder.setErrorDetail(error);
      }
      
      DiscoveryRequest request = builder.build();
      requestWriter.onNext(request);
      if (logger.isLoggable(XdsLogLevel.DEBUG)) {
        logger.log(XdsLogLevel.DEBUG, "Sent DiscoveryRequest\n{0}", MessagePrinter.print(request));
      }
      
    }
    
    @Override
    void sendError(Exception error) {
      requestWriter.onError(error);
    }
    
  }
  
}


