package org.xwiki.rendering.async.internal.block;
import java.util.Collections;
import java.util.List;
import javax.inject.Inject;
import org.xwiki.component.annotation.Component;
import org.xwiki.component.descriptor.ComponentRole;
import org.xwiki.model.reference.EntityReference;
import org.xwiki.rendering.RenderingException;
import org.xwiki.rendering.async.AsyncContext;
import org.xwiki.rendering.block.Block;
import org.xwiki.rendering.block.CompositeBlock;
import org.xwiki.rendering.block.MetaDataBlock;
import org.xwiki.rendering.block.XDOM;
import org.xwiki.rendering.syntax.Syntax;
import org.xwiki.rendering.transformation.TransformationContext;
import org.xwiki.rendering.util.ErrorBlockGenerator;
import org.xwiki.rendering.util.ParserUtils;
@Component(roles = DefaultBlockAsyncRenderer.class)
public class DefaultBlockAsyncRenderer extends AbstractBlockAsyncRenderer {
    private static final String TM_FAILEDASYNC = "rendering.async.error.failed";
    private static final ParserUtils PARSERUTILS = new ParserUtils();
    private AsyncContext asyncContext;
    private ErrorBlockGenerator errorBlockGenerator;
    private BlockAsyncRendererConfiguration configuration;
    public void initialize(BlockAsyncRendererConfiguration configuration) {
        this.configuration = configuration;
    }
    
    public List<String> getId() {
        return this.configuration.getId();
    }
    
    public boolean isAsyncAllowed() {
        return this.configuration.isAsyncAllowed();
    }
    
    public boolean isCacheAllowed() {
        return this.configuration.isCacheAllowed();
    }
    
    public boolean isInline() {
        return this.configuration.isInline();
    }
    
    public Syntax getTargetSyntax() {
        return this.configuration.getTargetSyntax();
    }
    
    public Block execute(boolean async, boolean cached) throws RenderingException {
        Block resultBlock;
        try {
            for (EntityReference reference : this.configuration.getReferences()) {
                this.asyncContext.useEntity(reference);
            }
            
            for (ComponentRole<?> role : this.configuration.getRoles()) {
                this.asyncContext.useComponent(role.getRoleType(), role.getRoleHint());
            }
            
            Block block = this.configuration.getBlock();
            if (this.configuration.isInline()) {
                block = PARSERUTILS.convertToInline(block, true);
            }
            
            XDOM xdom = this.configuration.getXDOM();
            if (xdom == null) {
                Block rootBlock = block.getRoot();
                if (rootBlock instanceof XDOM) {
                    xdom = (XDOM) rootBlock;
                }
                 else {
                    xdom = new XDOM(Collections.singletonList(rootBlock));
                }
                
            }
            
            resultBlock = tranform(xdom, block);
        }
         catch (Exception e) {
            resultBlock = new CompositeBlock(this.errorBlockGenerator.generateErrorBlocks(this.configuration.isInline(), TM_FAILEDASYNC, "Failed to execute asynchronous content", null, e));
        }
        
        return resultBlock;
    }
    
    private Block tranform(XDOM xdom, Block block) throws RenderingException {
        TransformationContext transformationContext = new TransformationContext(xdom, this.configuration.getDefaultSyntax(), false);
        transformationContext.setTargetSyntax(this.configuration.getTargetSyntax());
        transformationContext.setId(this.configuration.getTransformationId());
        transform(block, transformationContext);
        if (block instanceof XDOM) {
            return new MetaDataBlock(block.getChildren(), ((XDOM) block).getMetaData());
        }
        
        return block;
    }
    
}


