package org.apache.solr.core;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Constructor;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import org.apache.lucene.analysis.CharFilterFactory;
import org.apache.lucene.util.ResourceLoader;
import org.apache.lucene.util.ResourceLoaderAware;
import org.apache.lucene.analysis.TokenFilterFactory;
import org.apache.lucene.analysis.TokenizerFactory;
import org.apache.lucene.analysis.WordlistLoader;
import org.apache.lucene.codecs.Codec;
import org.apache.lucene.codecs.DocValuesFormat;
import org.apache.lucene.codecs.PostingsFormat;
import org.apache.lucene.util.IOUtils;
import org.apache.solr.common.SolrException;
import org.apache.solr.common.cloud.SolrClassLoader;
import org.apache.solr.handler.component.SearchComponent;
import org.apache.solr.handler.component.ShardHandlerFactory;
import org.apache.solr.logging.DeprecationLog;
import org.apache.solr.pkg.PackageListeningClassLoader;
import org.apache.solr.pkg.PackageLoader;
import org.apache.solr.request.SolrRequestHandler;
import org.apache.solr.response.QueryResponseWriter;
import org.apache.solr.rest.RestManager;
import org.apache.solr.schema.FieldType;
import org.apache.solr.schema.ManagedIndexSchemaFactory;
import org.apache.solr.schema.SimilarityFactory;
import org.apache.solr.search.QParserPlugin;
import org.apache.solr.update.processor.UpdateRequestProcessorFactory;
import org.apache.solr.util.plugin.SolrCoreAware;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class SolrResourceLoader implements ResourceLoader, Closeable, SolrClassLoader, SolrCoreAware  {
  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
  private static final String base = "org.apache.solr";
  private static final String[] packages = {
      "", "analysis.", "schema.", "handler.", "handler.tagger.", "search.", "update.", "core.", "response.", "request.", "update.processor.", "util.", "spelling.", "handler.component.", "spelling.suggest.", "spelling.suggest.fst.", "rest.schema.analysis.", "security.", "handler.admin." };
  private static final Charset UTF_8 = StandardCharsets.UTF_8;
  public static final String SOLR_ALLOW_UNSAFE_RESOURCELOADING_PARAM = "solr.allow.unsafe.resourceloading";
  private boolean allowUnsafeResourceloading;
  private String name = "";
  protected URLClassLoader classLoader;
  private final Path instanceDir;
  private String coreName;
  private UUID coreId;
  private SolrConfig config;
  private CoreContainer coreContainer;
  private PackageListeningClassLoader schemaLoader ;
  private PackageListeningClassLoader coreReloadingClassLoader ;
  private final List<SolrCoreAware> waitingForCore = Collections.synchronizedList(new ArrayList<SolrCoreAware>());
  private final List<SolrInfoBean> infoMBeans = Collections.synchronizedList(new ArrayList<SolrInfoBean>());
  private final List<ResourceLoaderAware> waitingForResources = Collections.synchronizedList(new ArrayList<ResourceLoaderAware>());
  private volatile boolean live;
  private RestManager.Registry managedResourceRegistry;
  private boolean needToReloadLuceneSPI = false; 
  public synchronized RestManager.Registry getManagedResourceRegistry() {
    if (managedResourceRegistry == null) {
      managedResourceRegistry = new RestManager.Registry();
    }
    
    return managedResourceRegistry;
  }
  
  public SolrClassLoader getSchemaLoader() {
    if (schemaLoader == null) {
      schemaLoader = createSchemaLoader();
    }
    
    return schemaLoader;
  }
  
  public SolrResourceLoader(String name, List<Path> classpath, Path instanceDir, ClassLoader parent) {
    this(instanceDir, parent);
    this.name = name;
    final List<URL> libUrls = new ArrayList<>(classpath.size());
    try {
      for (Path path : classpath) {
        libUrls.add(path.toUri().normalize().toURL());
      }
      
    }
     catch (MalformedURLException e) { 
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
    }
    
    addToClassLoader(libUrls);
  }
  
  public SolrResourceLoader(Path instanceDir) {
    this(instanceDir, null);
  }
  
  public SolrResourceLoader(Path instanceDir, ClassLoader parent) {
     allowUnsafeResourceloading = Boolean.getBoolean(SOLR_ALLOW_UNSAFE_RESOURCELOADING_PARAM);
     if (instanceDir == null) {
      throw new NullPointerException("SolrResourceLoader instanceDir must be non-null");
    }
    
    this.instanceDir = instanceDir;
    log.debug("new SolrResourceLoader for directory: '{}'", this.instanceDir);
    if (parent == null) {
      parent = getClass().getClassLoader();
    }
    
    this.classLoader = URLClassLoader.newInstance(new URL[0], parent);
  }
  
  synchronized void addToClassLoader(List<URL> urls) {
    URLClassLoader newLoader = addURLsToClassLoader(classLoader, urls);
    if (newLoader == classLoader) {
      return; 
    }
    
    this.classLoader = newLoader;
    this.needToReloadLuceneSPI = true;
    if (log.isInfoEnabled()) {
      log.info("Added {} libs to classloader, from paths: {}", urls.size(), urls.stream() .map(u -> u.getPath().substring(0, u.getPath().lastIndexOf("/"))) .sorted() .distinct() .collect(Collectors.toList()));
    }
    
  }
  
  synchronized void reloadLuceneSPI() {
    if (!needToReloadLuceneSPI) {
      return;
    }
    
    needToReloadLuceneSPI = false; 
    log.debug("Reloading Lucene SPI");
    PostingsFormat.reloadPostingsFormats(this.classLoader);
    DocValuesFormat.reloadDocValuesFormats(this.classLoader);
    Codec.reloadCodecs(this.classLoader);
    CharFilterFactory.reloadCharFilters(this.classLoader);
    TokenFilterFactory.reloadTokenFilters(this.classLoader);
    TokenizerFactory.reloadTokenizers(this.classLoader);
  }
  
  private static URLClassLoader addURLsToClassLoader(final URLClassLoader oldLoader, List<URL> urls) {
    if (urls.size() == 0) {
      return oldLoader;
    }
    
    List<URL> allURLs = new ArrayList<>();
    allURLs.addAll(Arrays.asList(oldLoader.getURLs()));
    allURLs.addAll(urls);
    for (URL url : urls) {
      if (log.isDebugEnabled()) {
        log.debug("Adding '{}' to classloader", url);
      }
      
    }
    
    ClassLoader oldParent = oldLoader.getParent();
    IOUtils.closeWhileHandlingException(oldLoader);
    return URLClassLoader.newInstance(allURLs.toArray(new URL[allURLs.size()]), oldParent);
  }
  
  public static List<URL> getURLs(Path libDir, DirectoryStream.Filter<Path> filter) throws IOException {
    List<URL> urls = new ArrayList<>();
    try (DirectoryStream<Path> directory = Files.newDirectoryStream(libDir, filter)) {
      for (Path element : directory) {
        urls.add(element.toUri().normalize().toURL());
      }
      
    }
    
    return urls;
  }
  
  public static List<URL> getURLs(Path libDir) throws IOException {
    return getURLs(libDir, new DirectoryStream.Filter<Path>() {
      public boolean accept(Path entry) throws IOException {
        return true;
      }
      
    }
    
);
  }
  
  public static List<URL> getFilteredURLs(Path libDir, String regex) throws IOException {
    final PathMatcher matcher = libDir.getFileSystem().getPathMatcher("regex:" + regex);
    return getURLs(libDir, new DirectoryStream.Filter<Path>() {
      public boolean accept(Path entry) throws IOException {
        return matcher.matches(entry.getFileName());
      }
      
    }
    
);
  }
  
  public Path getConfigPath() {
    return instanceDir.resolve("conf");
  }
  
  @Deprecated
(since="9.0.0")
  public String getConfigDir() {
    return getConfigPath().toString();
  }
  
  public ClassLoader getClassLoader() {
    return classLoader;
  }
  
  public InputStream openResource(String resource) throws IOException {
    if (resource.trim().startsWith("\\\\")) { 
      throw new SolrResourceNotFoundException("Resource '" + resource + "' could not be loaded.");
    }
    
    Path instanceDir = getInstancePath().normalize();
    Path inInstanceDir = getInstancePath().resolve(resource).normalize();
    Path inConfigDir = instanceDir.resolve("conf").resolve(resource).normalize();
    if (inInstanceDir.startsWith(instanceDir) || allowUnsafeResourceloading) {
      if (Files.exists(inConfigDir) && Files.isReadable(inConfigDir)) {
        return Files.newInputStream(inConfigDir);
      }
      
      if (Files.exists(inInstanceDir) && Files.isReadable(inInstanceDir)) {
        return Files.newInputStream(inInstanceDir);
      }
      
    }
    
    InputStream is = classLoader.getResourceAsStream(resource.replace(File.separatorChar, '/'));
    if (is == null && System.getProperty("jetty.testMode") != null) {
      is = classLoader.getResourceAsStream(("conf/" + resource).replace(File.separatorChar, '/'));
    }
    
    if (is == null) {
      throw new SolrResourceNotFoundException("Can't find resource '" + resource + "' in classpath or '" + instanceDir + "'");
    }
    
    return is;
  }
  
  public String resourceLocation(String resource) {
    if (resource.trim().startsWith("\\\\")) {
      return null;
    }
    
    Path inInstanceDir = instanceDir.resolve(resource).normalize();
    Path inConfigDir = instanceDir.resolve("conf").resolve(resource).normalize();
    boolean isRelativeToInstanceDir = inInstanceDir.startsWith(instanceDir.normalize());
    if (isRelativeToInstanceDir || allowUnsafeResourceloading) {
      if (Files.exists(inConfigDir) && Files.isReadable(inConfigDir)){
        return inConfigDir.normalize().toString();
}
      if (Files.exists(inInstanceDir) && Files.isReadable(inInstanceDir)){
        return inInstanceDir.normalize().toString();
}
    }
    
    try (InputStream is = classLoader.getResourceAsStream(resource.replace(File.separatorChar, '/'))) {
      if (is != null){
        return "classpath:" + resource;
}
    }
     catch (IOException e) {
    }
    
    return allowUnsafeResourceloading ? resource : null;
  }
  
  public List<String> getLines(String resource) throws IOException {
    return getLines(resource, UTF_8);
  }
  
  public List<String> getLines(String resource, String encoding) throws IOException {
    return getLines(resource, Charset.forName(encoding));
  }
  
  public List<String> getLines(String resource, Charset charset) throws IOException {
    try {
      return WordlistLoader.getLines(openResource(resource), charset);
    }
     catch (CharacterCodingException ex) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error loading resource (wrong encoding?): " + resource, ex);
    }
    
  }
  
  private static final Map<String, String> classNameCache = new ConcurrentHashMap<>();
  @VisibleForTesting
  static void clearCache() {
    classNameCache.clear();
  }
  
  private static final Pattern legacyAnalysisPattern = Pattern.compile("((\\Q" + base + ".analysis.\\E)|(\\Qsolr.\\E))([\\p{L}_$][\\p{L}\\p{N}_$]+?)(TokenFilter|Filter|Tokenizer|CharFilter)Factory");
  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType) {
    return findClass(cname, expectedType, empty);
  }
  
  public <T> Class<? extends T> findClass(String cname, Class<T> expectedType, String... subpackages) {
    if (subpackages == null || subpackages.length == 0 || subpackages == packages) {
      subpackages = packages;
      String c = classNameCache.get(cname);
      if (c != null) {
        try {
          return Class.forName(c, true, classLoader).asSubclass(expectedType);
        }
         catch (ClassNotFoundException | ClassCastException e) {
          log.warn("{} Unable to load cached class, attempting lookup. name={} shortname={} reason={}", name , c, cname, e);
          classNameCache.remove(cname);
        }
        
      }
      
    }
    
    Class<? extends T> clazz = null;
    clazz = getPackageClass(cname, expectedType);
    if(clazz != null) return clazz;
    try {
      final Matcher m = legacyAnalysisPattern.matcher(cname);
      if (m.matches()) {
        final String name = m.group(4);
        log.trace("Trying to load class from analysis SPI using name='{}'", name);
        try {
          if (CharFilterFactory.class.isAssignableFrom(expectedType)) {
            return clazz = CharFilterFactory.lookupClass(name).asSubclass(expectedType);
          }
           else if (TokenizerFactory.class.isAssignableFrom(expectedType)) {
            return clazz = TokenizerFactory.lookupClass(name).asSubclass(expectedType);
          }
           else if (TokenFilterFactory.class.isAssignableFrom(expectedType)) {
            return clazz = TokenFilterFactory.lookupClass(name).asSubclass(expectedType);
          }
           else {
            log.warn("'{}' looks like an analysis factory, but caller requested different class type: {}", cname, expectedType.getName());
          }
          
        }
         catch (IllegalArgumentException ex) {
        }
        
      }
      
      try {
        return clazz = Class.forName(cname, true, classLoader).asSubclass(expectedType);
      }
       catch (ClassNotFoundException e) {
        String newName = cname;
        if (newName.startsWith("solr")) {
          newName = cname.substring("solr".length() + 1);
        }
        
        for (String subpackage : subpackages) {
          try {
            String name = base + '.' + subpackage + newName;
            log.trace("Trying class name {}", name);
            return clazz = Class.forName(name, true, classLoader).asSubclass(expectedType);
          }
           catch (ClassNotFoundException e1) {
          }
          
        }
        
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, name +" Error loading class '" + cname + "'", e);
      }
      
    }
     finally {
      if (clazz != null) {
        if (clazz.getClassLoader() == SolrResourceLoader.class.getClassLoader() && !cname.equals(clazz.getName()) && (subpackages.length == 0 || subpackages == packages)) {
          classNameCache.put(cname, clazz.getName());
        }
        
        if (clazz.isAnnotationPresent(Deprecated.class)) {
          DeprecationLog.log(cname, "Solr loaded a deprecated plugin/analysis class [" + cname + "]. Please consult documentation how to replace it accordingly.");
        }
        
      }
      
    }
    
  }
  
  private <T> Class<? extends T> getPackageClass(String cname, Class<T> expectedType) {
    PluginInfo.ClassName cName = PluginInfo.parseClassName(cname);
    if (cName.pkg == null) return null;
    ResourceLoaderAware aware = CURRENT_AWARE.get();
    if (aware != null) {
      Class<?> type = assertAwareCompatibility(ResourceLoaderAware.class, aware);
      if (schemaResourceLoaderComponents.contains(type)) {
        return getSchemaLoader().findClass(cname, expectedType);
      }
      
    }
    
    return null;
  }
  
  static final String[] empty = new String[0];
  public <T> T newInstance(String name, Class<T> expectedType) {
    return newInstance(name, expectedType, empty);
  }
  
  private static final Class<?>[] NO_CLASSES = new Class<?>[0];
  private static final Object[] NO_OBJECTS = new Object[0];
  public <T> T newInstance(String cname, Class<T> expectedType, String... subpackages) {
    return newInstance(cname, expectedType, subpackages, NO_CLASSES, NO_OBJECTS);
  }
  
  public <T> T newInstance(String cName, Class<T> expectedType, String[] subPackages, Class<?>[] params, Object[] args) {
    Class<? extends T> clazz = findClass(cName, expectedType, subPackages);
    if (clazz == null) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Can not find class: " + cName + " in " + classLoader);
    }
    
    T obj = null;
    try {
      Constructor<? extends T> constructor = null;
      try {
        constructor = clazz.getConstructor(params);
        obj = constructor.newInstance(args);
      }
       catch (NoSuchMethodException e) {
        try {
          constructor = clazz.getConstructor();
          obj = constructor.newInstance();
        }
         catch (NoSuchMethodException e1) {
          throw e;
        }
        
      }
      
    }
     catch (Error err) {
      log.error("Loading Class {} ({}) triggered serious java error: {}", cName, clazz.getName(), err.getClass().getName(), err);
      throw err;
    }
     catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error instantiating class: '" + clazz.getName() + "'", e);
    }
    
    addToCoreAware(obj);
    addToResourceLoaderAware(obj);
    addToInfoBeans(obj);
    return obj;
  }
  
  public <T> void addToInfoBeans(T obj) {
    if(!live) {
      if (obj instanceof SolrInfoBean) {
        infoMBeans.add((SolrInfoBean) obj);
      }
      
    }
    
  }
  
  public <T> boolean addToResourceLoaderAware(T obj) {
    if (!live) {
      if (obj instanceof ResourceLoaderAware) {
        assertAwareCompatibility(ResourceLoaderAware.class, obj);
        waitingForResources.add((ResourceLoaderAware) obj);
      }
      
      return true;
    }
     else {
      return false;
    }
    
  }
  
  public <T> boolean addToCoreAware(T obj) {
    if (!live) {
      if (obj instanceof SolrCoreAware) {
        assertAwareCompatibility(SolrCoreAware.class, obj);
        waitingForCore.add((SolrCoreAware) obj);
      }
      
      return true;
    }
     else {
      return false;
    }
    
  }
  
  void initCore(SolrCore core) {
    this.coreName = core.getName();
    this.config = core.getSolrConfig();
    this.coreId = core.uniqueId;
    this.coreContainer = core.getCoreContainer();
    SolrCore.Provider coreProvider = core.coreProvider;
    this.coreReloadingClassLoader = new PackageListeningClassLoader(core.getCoreContainer(), this, s -> config.maxPackageVersion(s), null){
      protected void doReloadAction(Ctx ctx) {
        log.info("Core reloading classloader issued reload for: {}/{} ", coreName, coreId);
        coreProvider.reload();
      }
      
    };
    core.getPackageListeners().addListener(coreReloadingClassLoader, true);
  }
  
  public void inform(SolrCore core) {
    if(getSchemaLoader() != null) core.getPackageListeners().addListener(schemaLoader);
    SolrCoreAware[] arr;
    while (waitingForCore.size() > 0) {
      synchronized (waitingForCore) {
        arr = waitingForCore.toArray(new SolrCoreAware[waitingForCore.size()]);
        waitingForCore.clear();
      }
      
      for (SolrCoreAware aware : arr) {
        aware.inform(core);
      }
      
    }
    
    live = true;
  }
  
  public void inform(ResourceLoader loader) throws IOException {
    ResourceLoaderAware[] arr;
    while (waitingForResources.size() > 0) {
      synchronized (waitingForResources) {
        arr = waitingForResources.toArray(new ResourceLoaderAware[waitingForResources.size()]);
        waitingForResources.clear();
      }
      
      for (ResourceLoaderAware aware : arr) {
        informAware(loader, aware);
      }
      
    }
    
  }
  
  public static void informAware(ResourceLoader loader, ResourceLoaderAware aware) throws IOException {
    CURRENT_AWARE.set(aware);
    try{
      aware.inform(loader);
    }
     finally {
      CURRENT_AWARE.remove();
    }
    
  }
  
  public void inform(Map<String, SolrInfoBean> infoRegistry) {
    SolrInfoBean[] arr;
    synchronized (infoMBeans) {
      arr = infoMBeans.toArray(new SolrInfoBean[infoMBeans.size()]);
      waitingForResources.clear();
    }
    
    for (SolrInfoBean bean : arr) {
      if (!infoRegistry.containsValue(bean)) {
        try {
          infoRegistry.put(bean.getName(), bean);
        }
         catch (Exception e) {
          log.warn("could not register MBean '{}'.", bean.getName(), e);
        }
        
      }
      
    }
    
  }
  
  public Path getInstancePath() {
    return instanceDir;
  }
  
  private static final Map<Class<?>, Class<?>[]> awareCompatibility;
  static {
    awareCompatibility = new HashMap<>();
    awareCompatibility.put( SolrCoreAware.class, new Class<?>[]{              CodecFactory.class, DirectoryFactory.class, ManagedIndexSchemaFactory.class, QueryResponseWriter.class, SearchComponent.class, ShardHandlerFactory.class, SimilarityFactory.class, SolrRequestHandler.class, UpdateRequestProcessorFactory.class } );
    awareCompatibility.put( ResourceLoaderAware.class, new Class<?>[]{              CharFilterFactory.class, TokenFilterFactory.class, TokenizerFactory.class, QParserPlugin.class, FieldType.class } );
  }
  
  private static final Set<Class<?>> schemaResourceLoaderComponents = ImmutableSet.of( CharFilterFactory.class, TokenFilterFactory.class, TokenizerFactory.class, FieldType.class);
  public static Class<?> assertAwareCompatibility(Class<?> aware, Object obj) {
    Class<?>[] valid = awareCompatibility.get(aware);
    if (valid == null) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown Aware interface: " + aware);
    }
    
    for (Class<?> v : valid) {
      if (v.isInstance(obj)) {
        return v;
      }
      
    }
    
    StringBuilder builder = new StringBuilder();
    builder.append("Invalid 'Aware' object: ").append(obj);
    builder.append(" -- ").append(aware.getName());
    builder.append(" must be an instance of: ");
    for (Class<?> v : valid) {
      builder.append("[").append(v.getName()).append("] ");
    }
    
    throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, builder.toString());
  }
  
  public CoreContainer getCoreContainer(){
    return coreContainer;
  }
  
  public SolrConfig getSolrConfig() {
    return config;
  }
  
  public void close() throws IOException {
    IOUtils.close(classLoader);
  }
  
  public List<SolrInfoBean> getInfoMBeans() {
    return Collections.unmodifiableList(infoMBeans);
  }
  
  public  <T> Class<? extends T> findClass( PluginInfo info, Class<T>  type, boolean registerCoreReloadListener) {
    if(info.cName.pkg == null) return findClass(info.className, type);
    return _classLookup(info, (Function<PackageLoader.Package.Version, Class<? extends T>>) ver -> ver.getLoader().findClass(info.cName.className, type), registerCoreReloadListener);
  }
  
  private  <T> T _classLookup(PluginInfo info, Function<PackageLoader.Package.Version, T> fun, boolean registerCoreReloadListener ) {
    PluginInfo.ClassName cName = info.cName;
    if (registerCoreReloadListener) {
      if (coreReloadingClassLoader == null) {
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Core not set");
      }
      
      return fun.apply(coreReloadingClassLoader.findPackageVersion(cName, true));
    }
     else {
      return fun.apply(coreReloadingClassLoader.findPackageVersion(cName, false));
    }
    
  }
  
  public <T> T newInstance(PluginInfo info, Class<T> type, boolean registerCoreReloadListener) {
    if(info.cName.pkg == null) {
      return newInstance(info.cName.className == null? type.getName(): info.cName.className , type);
    }
    
    return _classLookup( info, version -> version.getLoader().newInstance(info.cName.className, type), registerCoreReloadListener);
  }
  
  private PackageListeningClassLoader createSchemaLoader() {
    CoreContainer cc = getCoreContainer();
    if (cc == null) {
      return null;
    }
    
    return new PackageListeningClassLoader(cc, this, pkg -> {
      if (getSolrConfig() == null) return null;
      return getSolrConfig().maxPackageVersion(pkg);
    }, () -> {
      if(getCoreContainer() == null || config == null || coreName == null || coreId==null) return;
      try (SolrCore c = getCoreContainer().getCore(coreName, coreId)) {
        if (c != null) {
          c.fetchLatestSchema();
        }
        
      }
      
    }
    
);
  }
  
  public static void persistConfLocally(SolrResourceLoader loader, String resourceName, byte[] content) {
    Path confFile = loader.getConfigPath().resolve(resourceName);
    try {
      Files.createDirectories(confFile.getParent());
      Files.write(confFile, content);
      log.info("Written conf file {}", resourceName);
    }
     catch (IOException e) {
      final String msg = "Error persisting conf file " + resourceName;
      log.error(msg, e);
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg, e);
    }
     finally {
      try {
        IOUtils.fsync(confFile, false);
      }
       catch (IOException e) {
        final String msg = "Error syncing conf file " + resourceName;
        log.error(msg, e);
      }
      
    }
    
  }
  
  private static final ThreadLocal<ResourceLoaderAware> CURRENT_AWARE = new ThreadLocal<>();
}


