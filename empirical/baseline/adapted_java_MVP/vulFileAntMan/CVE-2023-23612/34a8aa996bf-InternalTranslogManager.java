package org.opensearch.index.translog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.message.ParameterizedMessage;
import org.apache.lucene.store.AlreadyClosedException;
import org.opensearch.common.util.concurrent.ReleasableLock;
import org.opensearch.core.internal.io.IOUtils;
import org.opensearch.index.engine.LifecycleAware;
import org.opensearch.index.seqno.LocalCheckpointTracker;
import org.opensearch.index.shard.ShardId;
import org.opensearch.index.translog.listener.TranslogEventListener;
import java.io.Closeable;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.LongConsumer;
import java.util.function.LongSupplier;
import java.util.function.Supplier;
import java.util.stream.Stream;
public class InternalTranslogManager implements TranslogManager, Closeable {
    private final ReleasableLock readLock;
    private final LifecycleAware engineLifeCycleAware;
    private final ShardId shardId;
    private final Translog translog;
    private final AtomicBoolean pendingTranslogRecovery = new AtomicBoolean(false);
    private final TranslogEventListener translogEventListener;
    private final Supplier<LocalCheckpointTracker> localCheckpointTrackerSupplier;
    private static final Logger logger = LogManager.getLogger(InternalTranslogManager.class);
    public AtomicBoolean getPendingTranslogRecovery() {
        return pendingTranslogRecovery;
    }
    
    public InternalTranslogManager( TranslogConfig translogConfig, LongSupplier primaryTermSupplier, LongSupplier globalCheckpointSupplier, TranslogDeletionPolicy translogDeletionPolicy, ShardId shardId, ReleasableLock readLock, Supplier<LocalCheckpointTracker> localCheckpointTrackerSupplier, String translogUUID, TranslogEventListener translogEventListener, LifecycleAware engineLifeCycleAware, TranslogFactory translogFactory ) throws IOException {
        this.shardId = shardId;
        this.readLock = readLock;
        this.engineLifeCycleAware = engineLifeCycleAware;
        this.translogEventListener = translogEventListener;
        this.localCheckpointTrackerSupplier = localCheckpointTrackerSupplier;
        Translog translog = openTranslog(translogConfig, primaryTermSupplier, translogDeletionPolicy, globalCheckpointSupplier, seqNo -> {
            final LocalCheckpointTracker tracker = localCheckpointTrackerSupplier.get();
            assert tracker != null || getTranslog(true).isOpen() == false;
            if (tracker != null) {
                tracker.markSeqNoAsPersisted(seqNo);
            }
            
        }, translogUUID, translogFactory);
        assert translog.getGeneration() != null;
        this.translog = translog;
        assert pendingTranslogRecovery.get() == false : "translog recovery can't be pending before we set it";
        pendingTranslogRecovery.set(true);
    }
    
    public void rollTranslogGeneration() throws TranslogException {
        try (ReleasableLock ignored = readLock.acquire()) {
            engineLifeCycleAware.ensureOpen();
            translog.rollGeneration();
            translog.trimUnreferencedReaders();
        }
         catch (AlreadyClosedException e) {
            translogEventListener.onFailure("translog roll generation failed", e);
            throw e;
        }
         catch (Exception e) {
            try {
                translogEventListener.onFailure("translog roll generation failed", e);
            }
             catch (Exception inner) {
                e.addSuppressed(inner);
            }
            
            throw new TranslogException(shardId, "failed to roll translog", e);
        }
        
    }
    
    public int recoverFromTranslog(TranslogRecoveryRunner translogRecoveryRunner, long localCheckpoint, long recoverUpToSeqNo) throws IOException {
        int opsRecovered = 0;
        translogEventListener.onBeginTranslogRecovery();
        try (ReleasableLock ignored = readLock.acquire()) {
            engineLifeCycleAware.ensureOpen();
            if (pendingTranslogRecovery.get() == false) {
                throw new IllegalStateException("Engine has already been recovered");
            }
            
            try {
                opsRecovered = recoverFromTranslogInternal(translogRecoveryRunner, localCheckpoint, recoverUpToSeqNo);
            }
             catch (Exception e) {
                try {
                    pendingTranslogRecovery.set(true); 
                    translogEventListener.onFailure("failed to recover from translog", e);
                }
                 catch (Exception inner) {
                    e.addSuppressed(inner);
                }
                
                throw e;
            }
            
        }
        
        return opsRecovered;
    }
    
    private int recoverFromTranslogInternal(TranslogRecoveryRunner translogRecoveryRunner, long localCheckpoint, long recoverUpToSeqNo) {
        final int opsRecovered;
        if (localCheckpoint < recoverUpToSeqNo) {
            try (Translog.Snapshot snapshot = translog.newSnapshot(localCheckpoint + 1, recoverUpToSeqNo)) {
                opsRecovered = translogRecoveryRunner.run(snapshot);
            }
             catch (Exception e) {
                throw new TranslogException(shardId, "failed to recover from translog", e);
            }
            
        }
         else {
            opsRecovered = 0;
        }
        
        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";
        pendingTranslogRecovery.set(false); 
        logger.trace( () -> new ParameterizedMessage( "flushing post recovery from translog: ops recovered [{}], current translog generation [{}]", opsRecovered, translog.currentFileGeneration() ) );
        translogEventListener.onAfterTranslogRecovery();
        return opsRecovered;
    }
    
    public boolean isTranslogSyncNeeded() {
        return getTranslog(true).syncNeeded();
    }
    
    public boolean ensureTranslogSynced(Stream<Translog.Location> locations) throws IOException {
        final boolean synced = translog.ensureSynced(locations);
        if (synced) {
            translogEventListener.onAfterTranslogSync();
        }
        
        return synced;
    }
    
    public void syncTranslog() throws IOException {
        translog.sync();
        translogEventListener.onAfterTranslogSync();
    }
    
    public TranslogStats getTranslogStats() {
        return getTranslog(true).stats();
    }
    
    public Translog.Location getTranslogLastWriteLocation() {
        return getTranslog(true).getLastWriteLocation();
    }
    
    public void trimUnreferencedTranslogFiles() throws TranslogException {
        try (ReleasableLock ignored = readLock.acquire()) {
            engineLifeCycleAware.ensureOpen();
            translog.trimUnreferencedReaders();
        }
         catch (AlreadyClosedException e) {
            translogEventListener.onFailure("translog trimming unreferenced translog failed", e);
            throw e;
        }
         catch (Exception e) {
            try {
                translogEventListener.onFailure("translog trimming unreferenced translog failed", e);
            }
             catch (Exception inner) {
                e.addSuppressed(inner);
            }
            
            throw new TranslogException(shardId, "failed to trim unreferenced translog translog", e);
        }
        
    }
    
    public boolean shouldRollTranslogGeneration() {
        return getTranslog(true).shouldRollGeneration();
    }
    
    public void trimOperationsFromTranslog(long belowTerm, long aboveSeqNo) throws TranslogException {
        try (ReleasableLock ignored = readLock.acquire()) {
            engineLifeCycleAware.ensureOpen();
            translog.trimOperations(belowTerm, aboveSeqNo);
        }
         catch (AlreadyClosedException e) {
            translogEventListener.onFailure("translog operations trimming failed", e);
            throw e;
        }
         catch (Exception e) {
            try {
                translogEventListener.onFailure("translog operations trimming failed", e);
            }
             catch (Exception inner) {
                e.addSuppressed(inner);
            }
            
            throw new TranslogException(shardId, "failed to trim translog operations", e);
        }
        
    }
    
    public int restoreLocalHistoryFromTranslog(long processedCheckpoint, TranslogRecoveryRunner translogRecoveryRunner) throws IOException {
        try (ReleasableLock ignored = readLock.acquire()) {
            engineLifeCycleAware.ensureOpen();
            try (Translog.Snapshot snapshot = getTranslog(true).newSnapshot(processedCheckpoint + 1, Long.MAX_VALUE)) {
                return translogRecoveryRunner.run(snapshot);
            }
            
        }
        
    }
    
    public void ensureCanFlush() {
        if (pendingTranslogRecovery.get()) {
            throw new IllegalStateException(shardId.toString() + " flushes are disabled - pending translog recovery");
        }
        
    }
    
    public Translog.Operation readOperation(Translog.Location location) throws IOException {
        return translog.readOperation(location);
    }
    
    public Translog.Location add(Translog.Operation operation) throws IOException {
        return translog.add(operation);
    }
    
    public void skipTranslogRecovery() {
        assert pendingTranslogRecovery.get() : "translogRecovery is not pending but should be";
        pendingTranslogRecovery.set(false); 
    }
    
    public Translog getTranslog() {
        return translog;
    }
    
    private Translog getTranslog(boolean ensureOpen) {
        if (ensureOpen) {
            this.engineLifeCycleAware.ensureOpen();
        }
        
        return translog;
    }
    
    protected Translog openTranslog( TranslogConfig translogConfig, LongSupplier primaryTermSupplier, TranslogDeletionPolicy translogDeletionPolicy, LongSupplier globalCheckpointSupplier, LongConsumer persistedSequenceNumberConsumer, String translogUUID, TranslogFactory translogFactory ) throws IOException {
        return translogFactory.newTranslog( translogConfig, translogUUID, translogDeletionPolicy, globalCheckpointSupplier, primaryTermSupplier, persistedSequenceNumberConsumer );
    }
    
    public long getLastSyncedGlobalCheckpoint() {
        return translog.getLastSyncedGlobalCheckpoint();
    }
    
    public long getMaxSeqNo() {
        return translog.getMaxSeqNo();
    }
    
    public void trimUnreferencedReaders() throws IOException {
        translog.trimUnreferencedReaders();
    }
    
    public TranslogDeletionPolicy getDeletionPolicy() {
        return translog.getDeletionPolicy();
    }
    
    public Exception getTragicExceptionIfClosed() {
        return translog.isOpen() == false ? translog.getTragicException() : null;
    }
    
    public String getTranslogUUID() {
        return translog.getTranslogUUID();
    }
    
    public boolean shouldPeriodicallyFlush(long localCheckpointOfLastCommit, long flushThreshold) {
        final long translogGenerationOfLastCommit = translog.getMinGenerationForSeqNo( localCheckpointOfLastCommit + 1 ).translogFileGeneration;
        if (translog.sizeInBytesByMinGen(translogGenerationOfLastCommit) < flushThreshold) {
            return false;
        }
        
        final long translogGenerationOfNewCommit = translog.getMinGenerationForSeqNo( localCheckpointTrackerSupplier.get().getProcessedCheckpoint() + 1 ).translogFileGeneration;
        return translogGenerationOfLastCommit < translogGenerationOfNewCommit || localCheckpointTrackerSupplier.get().getProcessedCheckpoint() == localCheckpointTrackerSupplier.get().getMaxSeqNo();
    }
    
    public void close() throws IOException {
        IOUtils.closeWhileHandlingException(translog);
    }
    
}


