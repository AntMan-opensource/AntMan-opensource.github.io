package org.opensearch.index.translog;
import org.opensearch.common.util.concurrent.ReleasableLock;
import org.opensearch.index.shard.ShardId;
import java.io.IOException;
import java.util.stream.Stream;
public class NoOpTranslogManager implements TranslogManager {
    private final Translog.Snapshot emptyTranslogSnapshot;
    private final ReleasableLock readLock;
    private final Runnable ensureOpen;
    private final ShardId shardId;
    private final TranslogStats translogStats;
    public NoOpTranslogManager( ShardId shardId, ReleasableLock readLock, Runnable ensureOpen, TranslogStats translogStats, Translog.Snapshot emptyTranslogSnapshot ) throws IOException {
        this.emptyTranslogSnapshot = emptyTranslogSnapshot;
        this.readLock = readLock;
        this.shardId = shardId;
        this.ensureOpen = ensureOpen;
        this.translogStats = translogStats;
    }
    
    public void rollTranslogGeneration() throws TranslogException {}
    public int recoverFromTranslog(TranslogRecoveryRunner translogRecoveryRunner, long localCheckpoint, long recoverUpToSeqNo) throws IOException {
        try (ReleasableLock ignored = readLock.acquire()) {
            ensureOpen.run();
            try (Translog.Snapshot snapshot = emptyTranslogSnapshot) {
                translogRecoveryRunner.run(snapshot);
            }
             catch (final Exception e) {
                throw new TranslogException(shardId, "failed to recover from empty translog snapshot", e);
            }
            
        }
        
        return emptyTranslogSnapshot.totalOperations();
    }
    
    public boolean isTranslogSyncNeeded() {
        return false;
    }
    
    public boolean ensureTranslogSynced(Stream<Translog.Location> locations) {
        return false;
    }
    
    public void syncTranslog() throws IOException {}
    public TranslogStats getTranslogStats() {
        return translogStats;
    }
    
    public Translog.Location getTranslogLastWriteLocation() {
        return new Translog.Location(0, 0, 0);
    }
    
    public void trimUnreferencedTranslogFiles() throws TranslogException {}
    public boolean shouldRollTranslogGeneration() {
        return false;
    }
    
    public void trimOperationsFromTranslog(long belowTerm, long aboveSeqNo) throws TranslogException {}
    public void ensureCanFlush() {}
    public int restoreLocalHistoryFromTranslog(long processedCheckpoint, TranslogRecoveryRunner translogRecoveryRunner) throws IOException {
        return 0;
    }
    
    public void skipTranslogRecovery() {}
    public Translog.Operation readOperation(Translog.Location location) throws IOException {
        return null;
    }
    
    public Translog.Location add(Translog.Operation operation) throws IOException {
        return new Translog.Location(0, 0, 0);
    }
    
}


