package org.opensearch.index.engine;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexCommit;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.SegmentReader;
import org.apache.lucene.store.Directory;
import org.opensearch.common.lucene.Lucene;
import org.opensearch.common.util.concurrent.ReleasableLock;
import org.opensearch.index.seqno.SequenceNumbers;
import org.opensearch.index.shard.DocsStats;
import org.opensearch.index.store.Store;
import org.opensearch.index.translog.DefaultTranslogDeletionPolicy;
import org.opensearch.index.translog.LocalTranslog;
import org.opensearch.index.translog.NoOpTranslogManager;
import org.opensearch.index.translog.Translog;
import org.opensearch.index.translog.TranslogConfig;
import org.opensearch.index.translog.TranslogDeletionPolicy;
import org.opensearch.index.translog.TranslogException;
import org.opensearch.index.translog.TranslogManager;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
public final class NoOpEngine extends ReadOnlyEngine {
    private final SegmentsStats segmentsStats;
    private final DocsStats docsStats;
    public NoOpEngine(EngineConfig config) {
        super(config, null, null, true, Function.identity(), true);
        this.segmentsStats = new SegmentsStats();
        Directory directory = store.directory();
        try (DirectoryReader reader = openDirectory(directory, config.getIndexSettings().isSoftDeleteEnabled())) {
            for (LeafReaderContext ctx : reader.getContext().leaves()) {
                SegmentReader segmentReader = Lucene.segmentReader(ctx.reader());
                fillSegmentStats(segmentReader, true, segmentsStats);
            }
            
            this.docsStats = docsStats(reader);
        }
         catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        
    }
    
    protected DirectoryReader open(final IndexCommit commit) throws IOException {
        final Directory directory = commit.getDirectory();
        final List<IndexCommit> indexCommits = DirectoryReader.listCommits(directory);
        final IndexCommit indexCommit = indexCommits.get(indexCommits.size() - 1);
        return new DirectoryReader(directory, new LeafReader[0], null) {
            protected DirectoryReader doOpenIfChanged() {
                return null;
            }
            
            protected DirectoryReader doOpenIfChanged(IndexCommit commit) {
                return null;
            }
            
            protected DirectoryReader doOpenIfChanged(IndexWriter writer, boolean applyAllDeletes) {
                return null;
            }
            
            public long getVersion() {
                return 0;
            }
            
            public boolean isCurrent() {
                return true;
            }
            
            public IndexCommit getIndexCommit() {
                return indexCommit;
            }
            
            protected void doClose() {}
            public CacheHelper getReaderCacheHelper() {
                return null;
            }
            
        };
    }
    
    public SegmentsStats segmentsStats(boolean includeSegmentFileSizes, boolean includeUnloadedSegments) {
        if (includeUnloadedSegments) {
            final SegmentsStats stats = new SegmentsStats();
            stats.add(this.segmentsStats);
            if (includeSegmentFileSizes == false) {
                stats.clearFileSizes();
            }
            
            return stats;
        }
         else {
            return super.segmentsStats(includeSegmentFileSizes, includeUnloadedSegments);
        }
        
    }
    
    public DocsStats docStats() {
        return docsStats;
    }
    
    public TranslogManager translogManager() {
        try {
            return new NoOpTranslogManager(shardId, readLock, this::ensureOpen, this.translogStats, new Translog.Snapshot() {
                public void close() {}
                public int totalOperations() {
                    return 0;
                }
                
                public Translog.Operation next() {
                    return null;
                }
                
            }
            ) {
                public void trimUnreferencedTranslogFiles() throws TranslogException {
                    final Store store = engineConfig.getStore();
                    store.incRef();
                    try (ReleasableLock ignored = readLock.acquire()) {
                        ensureOpen();
                        final List<IndexCommit> commits = DirectoryReader.listCommits(store.directory());
                        if (commits.size() == 1 && translogStats.getTranslogSizeInBytes() > translogStats.getUncommittedSizeInBytes()) {
                            final Map<String, String> commitUserData = getLastCommittedSegmentInfos().getUserData();
                            final String translogUuid = commitUserData.get(Translog.TRANSLOG_UUID_KEY);
                            if (translogUuid == null) {
                                throw new IllegalStateException("commit doesn't contain translog unique id");
                            }
                            
                            final TranslogConfig translogConfig = engineConfig.getTranslogConfig();
                            final long localCheckpoint = Long.parseLong(commitUserData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
                            final TranslogDeletionPolicy translogDeletionPolicy = new DefaultTranslogDeletionPolicy(-1, -1, 0);
                            translogDeletionPolicy.setLocalCheckpointOfSafeCommit(localCheckpoint);
                            try ( Translog translog = engineConfig.getTranslogFactory() .newTranslog( translogConfig, translogUuid, translogDeletionPolicy, engineConfig.getGlobalCheckpointSupplier(), engineConfig.getPrimaryTermSupplier(), seqNo -> {} ) ) {
                                translog.trimUnreferencedReaders();
                                translogStats = translog.stats();
                                assert translog.currentFileGeneration() == translog.getMinFileGeneration() : "translog was not trimmed " + " current gen " + translog.currentFileGeneration() + " != min gen " + translog.getMinFileGeneration();
                            }
                            
                        }
                        
                    }
                     catch (final Exception e) {
                        try {
                            failEngine("translog trimming failed", e);
                        }
                         catch (Exception inner) {
                            e.addSuppressed(inner);
                        }
                        
                        throw new EngineException(shardId, "failed to trim translog", e);
                    }
                     finally {
                        store.decRef();
                    }
                    
                }
                
            };
        }
         catch (IOException ex) {
            throw new RuntimeException(ex);
        }
        
    }
    
    public void trimUnreferencedTranslogFiles() {
        final Store store = this.engineConfig.getStore();
        store.incRef();
        try (ReleasableLock lock = readLock.acquire()) {
            ensureOpen();
            final List<IndexCommit> commits = DirectoryReader.listCommits(store.directory());
            if (commits.size() == 1 && translogStats.getTranslogSizeInBytes() > translogStats.getUncommittedSizeInBytes()) {
                final Map<String, String> commitUserData = getLastCommittedSegmentInfos().getUserData();
                final String translogUuid = commitUserData.get(Translog.TRANSLOG_UUID_KEY);
                if (translogUuid == null) {
                    throw new IllegalStateException("commit doesn't contain translog unique id");
                }
                
                final TranslogConfig translogConfig = engineConfig.getTranslogConfig();
                final long localCheckpoint = Long.parseLong(commitUserData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY));
                final TranslogDeletionPolicy translogDeletionPolicy = new DefaultTranslogDeletionPolicy(-1, -1, 0);
                translogDeletionPolicy.setLocalCheckpointOfSafeCommit(localCheckpoint);
                try ( Translog translog = new LocalTranslog( translogConfig, translogUuid, translogDeletionPolicy, engineConfig.getGlobalCheckpointSupplier(), engineConfig.getPrimaryTermSupplier(), seqNo -> {} ) ) {
                    translog.trimUnreferencedReaders();
                    this.translogStats = translog.stats();
                    assert translog.currentFileGeneration() == translog.getMinFileGeneration() : "translog was not trimmed " + " current gen " + translog.currentFileGeneration() + " != min gen " + translog.getMinFileGeneration();
                }
                
            }
            
        }
         catch (final Exception e) {
            try {
                failEngine("translog trimming failed", e);
            }
             catch (Exception inner) {
                e.addSuppressed(inner);
            }
            
            throw new EngineException(shardId, "failed to trim translog", e);
        }
         finally {
            store.decRef();
        }
        
    }
    
}


