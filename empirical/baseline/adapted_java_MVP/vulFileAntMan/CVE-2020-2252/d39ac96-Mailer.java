package hudson.tasks;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import static hudson.Util.fixEmptyAndTrim;
import hudson.BulkChange;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.Functions;
import hudson.Launcher;
import hudson.RestrictedSince;
import hudson.Util;
import hudson.model.*;
import jenkins.plugins.mailer.tasks.i18n.Messages;
import hudson.util.FormValidation;
import hudson.util.Secret;
import hudson.util.XStream2;
import jenkins.model.JenkinsLocationConfiguration;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.DataBoundConstructor;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Date;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.mail.Address;
import javax.mail.Authenticator;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import javax.servlet.ServletException;
import org.apache.tools.ant.types.selectors.SelectorUtils;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.export.Exported;
import jenkins.model.Jenkins;
import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONObject;
import org.kohsuke.accmod.restrictions.DoNotUse;
import org.kohsuke.stapler.interceptor.RequirePOST;
public class Mailer extends Notifier implements SimpleBuildStep {
    protected static final Logger LOGGER = Logger.getLogger(Mailer.class.getName());
    public String recipients;
    public boolean dontNotifyEveryUnstableBuild;
    public boolean isNotifyEveryUnstableBuild() {
        return !dontNotifyEveryUnstableBuild;
    }
    
    public boolean sendToIndividuals;
    public Mailer() {}
    public Mailer(String recipients, boolean notifyEveryUnstableBuild, boolean sendToIndividuals) {
        this.recipients = recipients;
        this.dontNotifyEveryUnstableBuild = !notifyEveryUnstableBuild;
        this.sendToIndividuals = sendToIndividuals;
    }
    
    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "build cannnot be null and the workspace is not used in case it was null")
    public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {
        perform(build, build.getWorkspace(), launcher, listener);
        return true;
    }
    
    public void perform(Run<?,?> build, FilePath workspace, Launcher launcher, TaskListener listener) throws IOException, InterruptedException {
        if(debug) listener.getLogger().println("Running mailer");
        EnvVars env = build.getEnvironment(listener);
        String recip = env.expand(recipients);
        new MailSender(recip, dontNotifyEveryUnstableBuild, sendToIndividuals, descriptor().getCharset()) {             

            public boolean artifactMatches(String path, AbstractBuild<?,?> build) {
                ArtifactArchiver aa = build.getProject().getPublishersList().get(ArtifactArchiver.class);
                if (aa == null) {
                    LOGGER.finer("No ArtifactArchiver found");
                    return false;
                }
                
                String artifacts = aa.getArtifacts();
                for (String include : artifacts.split("[, ]+")) {
                    String pattern = include.replace(File.separatorChar, '/');
                    if (pattern.endsWith("/")) {
                        pattern += "**";
                    }
                    
                    if (SelectorUtils.matchPath(pattern, path)) {
                        LOGGER.log(Level.FINER, "DescriptorImpl.artifactMatches true for {0} against {1}", new Object[] {path, pattern});
                        return true;
                    }
                    
                }
                
                LOGGER.log(Level.FINER, "DescriptorImpl.artifactMatches for {0} matched none of {1}", new Object[] {path, artifacts});
                return false;
            }
            
        }
        .run(build,listener);
    }
    
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }
    
    private static Pattern ADDRESS_PATTERN = Pattern.compile("\\s*([^<]*)<([^>]+)>\\s*");
    @SuppressFBWarnings(value = "NM_METHOD_NAMING_CONVENTION", justification = "It's deprecated and required for API compatibility")
    public static InternetAddress StringToAddress(String strAddress, String charset) throws AddressException, UnsupportedEncodingException {
        return stringToAddress(strAddress, charset);
    }
    
    public static @Nonnull InternetAddress stringToAddress(@Nonnull String strAddress,  @Nonnull String charset) throws AddressException, UnsupportedEncodingException {
        Matcher m = ADDRESS_PATTERN.matcher(strAddress);
        if(!m.matches()) {
            return new InternetAddress(strAddress);
        }
        
        String personal = m.group(1);
        String address = m.group(2);
        return new InternetAddress(address, personal, charset);
    }
    
    @SuppressFBWarnings(value = "MS_PKGPROTECT", justification = "Deprecated API field")
    public static DescriptorImpl DESCRIPTOR;
    public static DescriptorImpl descriptor() {
        final Jenkins jenkins = Jenkins.getInstance();
        if (jenkins == null) {
            throw new IllegalStateException("Jenkins instance is not ready");
        }
        
        return jenkins.getDescriptorByType(Mailer.DescriptorImpl.class);
    }
    
    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {
        private String defaultSuffix;
        private String hudsonUrl;
        private transient String smtpAuthUsername;
        private transient Secret smtpAuthPassword;
        private SMTPAuthentication authentication;
        private String adminAddress;
        private String replyToAddress;
        private String smtpHost;
        private boolean useSsl;
        private boolean useTls;
        private String smtpPort;
        private String charset;
        private static transient AtomicInteger testEmailCount = new AtomicInteger(0);
        @SuppressFBWarnings(value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",  justification = "Writing to a deprecated field")
        public DescriptorImpl() {
            load();
            DESCRIPTOR = this;
        }
        
        public String getDisplayName() {
            return Messages.Mailer_DisplayName();
        }
        
        public String getDefaultSuffix() {
            return defaultSuffix;
        }
        
        public String getReplyToAddress() {
            return replyToAddress;
        }
        
        public void setReplyToAddress(String address) {
            this.replyToAddress = Util.fixEmpty(address);
            save();
        }
        
        public Session createSession() {
            return createSession(smtpHost,smtpPort,useSsl,useTls,getSmtpAuthUserName(),getSmtpAuthPasswordSecret());
        }
        
        private static Session createSession(String smtpHost, String smtpPort, boolean useSsl, boolean useTls, String smtpAuthUserName, Secret smtpAuthPassword) {
            final String SMTP_PORT_PROPERTY = "mail.smtp.port";
            final String SMTP_SOCKETFACTORY_PORT_PROPERTY = "mail.smtp.socketFactory.port";
            smtpPort = fixEmptyAndTrim(smtpPort);
            smtpAuthUserName = fixEmptyAndTrim(smtpAuthUserName);
            Properties props = new Properties(System.getProperties());
            if(fixEmptyAndTrim(smtpHost)!=null) props.put("mail.smtp.host",smtpHost);
            if (smtpPort!=null) {
                props.put(SMTP_PORT_PROPERTY, smtpPort);
            }
            
            if (useSsl) {
            	 if (props.getProperty(SMTP_SOCKETFACTORY_PORT_PROPERTY) == null) {
                    String port = smtpPort==null?"465":smtpPort;
                    props.put(SMTP_PORT_PROPERTY, port);
                    props.put(SMTP_SOCKETFACTORY_PORT_PROPERTY, port);
            	}
            	
            	if (props.getProperty("mail.smtp.socketFactory.class") == null) {
            		 props.put("mail.smtp.socketFactory.class","javax.net.ssl.SSLSocketFactory");
            	}
            	
				props.put("mail.smtp.socketFactory.fallback", "false");
			}
			
			if(useTls){
                if (props.getProperty(SMTP_SOCKETFACTORY_PORT_PROPERTY) == null) {
                    String port = smtpPort==null?"587":smtpPort;
                    props.put(SMTP_PORT_PROPERTY, port);
                    props.put(SMTP_SOCKETFACTORY_PORT_PROPERTY, port);
                }
                
                props.put("mail.smtp.starttls.enable", "true");
                props.put("mail.smtp.starttls.required", "true");
            }
            
            if(smtpAuthUserName!=null) props.put("mail.smtp.auth","true");
            props.put("mail.smtp.timeout","60000");
            props.put("mail.smtp.connectiontimeout","60000");
            return Session.getInstance(props,getAuthenticator(smtpAuthUserName,Secret.toString(smtpAuthPassword)));
        }
        
        private static Authenticator getAuthenticator(final String smtpAuthUserName, final String smtpAuthPassword) {
            if(smtpAuthUserName==null)    return null;
            return new Authenticator() {
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(smtpAuthUserName,smtpAuthPassword);
                }
                
            };
        }
        
        public boolean configure(StaplerRequest req, JSONObject json) throws FormException {
            BulkChange b = new BulkChange(this);
            SMTPAuthentication current = this.authentication;
            try {
                this.authentication = null;
                req.bindJSON(this, json);
                b.commit();
            }
             catch (IOException e) {
                this.authentication = current;
                b.abort();
                throw new FormException("Failed to apply configuration", e, null);
            }
            
            return true;
        }
        
        private String nullify(String v) {
            if(v!=null && v.length()==0)    v=null;
            return v;
        }
        
        public String getSmtpHost() {
            return smtpHost;
        }
        
        public String getSmtpServer() {
            return smtpHost;
        }
        
        @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "False positive. See https://sourceforge.net/p/findbugs/bugs/1411/")
        private JenkinsLocationConfiguration getJenkinsLocationConfiguration() {
            final JenkinsLocationConfiguration jlc = JenkinsLocationConfiguration.get();
            if (jlc == null) {
                throw new IllegalStateException("JenkinsLocationConfiguration not available");
            }
            
            return jlc;
        }
        
        public String getAdminAddress() {
            return getJenkinsLocationConfiguration().getAdminAddress();
        }
        
        public String getUrl() {
            return getJenkinsLocationConfiguration().getUrl();
        }
        
        public String getSmtpAuthUserName() {
            if (authentication == null) return null;
            return authentication.getUsername();
        }
        
        public String getSmtpAuthPassword() {
            if (authentication == null) return null;
            return Secret.toString(authentication.getPassword());
        }
        
        public Secret getSmtpAuthPasswordSecret() {
            if (authentication == null) return null;
            return authentication.getPassword();
        }
        
        public boolean getUseSsl() {
        	return useSsl;
        }
        
        public boolean getUseTls() {
            return useTls;
        }
        
        public String getSmtpPort() {
        	return smtpPort;
        }
        
        public String getCharset() {
        	String c = charset;
        	if (c == null || c.length() == 0)	c = "UTF-8";
        	return c;
        }
        
        public void setDefaultSuffix(String defaultSuffix) {
            this.defaultSuffix = defaultSuffix;
            save();
        }
        
        public void setHudsonUrl(String hudsonUrl) {
            getJenkinsLocationConfiguration().setUrl(hudsonUrl);
        }
        
        public void setAdminAddress(String adminAddress) {
            getJenkinsLocationConfiguration().setAdminAddress(adminAddress);
        }
        
        public void setSmtpHost(String smtpHost) {
            this.smtpHost = nullify(smtpHost);
            save();
        }
        
        public void setUseSsl(boolean useSsl) {
            this.useSsl = useSsl;
            save();
        }
        
        public void setUseTls(boolean useTls) {
            this.useTls = useTls;
            save();
        }
        
        public void setSmtpPort(String smtpPort) {
            this.smtpPort = smtpPort;
            save();
        }
        
        public void setCharset(String charset) {
            if (charset == null || charset.length() == 0) {
                charset = "UTF-8";
            }
            
            this.charset = charset;
            save();
        }
        
        public void setAuthentication(@CheckForNull SMTPAuthentication authentication) {
            this.authentication = authentication;
            save();
        }
        
        public SMTPAuthentication getAuthentication() {
            return authentication;
        }
        
        public void setSmtpAuth(String userName, String password) {
            if (userName == null && password == null) {
                this.authentication = null;
            }
             else {
                this.authentication = new SMTPAuthentication(userName, Secret.fromString(password));
            }
            
        }
        
        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {
            Mailer m = (Mailer)super.newInstance(req, formData);
            if(hudsonUrl==null) {
                hudsonUrl = Functions.inferHudsonURL(req);
                save();
            }
            
            return m;
        }
        
        private Object readResolve() {
            if (smtpAuthPassword != null) {
                authentication = new SMTPAuthentication(smtpAuthUsername, smtpAuthPassword);
            }
            
            return this;
        }
        
        public FormValidation doAddressCheck(@QueryParameter String value) {
            try {
                new InternetAddress(value);
                return FormValidation.ok();
            }
             catch (AddressException e) {
                return FormValidation.error(e.getMessage());
            }
            
        }
        
        public FormValidation doCheckSmtpServer(@QueryParameter String value) {
            try {
                if (fixEmptyAndTrim(value)!=null){
                    InetAddress.getByName(value);
}
                return FormValidation.ok();
            }
             catch (UnknownHostException e) {
                return FormValidation.error(Messages.Mailer_Unknown_Host_Name()+value);
            }
            
        }
        
        public FormValidation doCheckDefaultSuffix(@QueryParameter String value) {
            if (value.matches("@[A-Za-z0-9.\\-]+") || fixEmptyAndTrim(value)==null){
                return FormValidation.ok();
}
            else{
                return FormValidation.error(Messages.Mailer_Suffix_Error());
}
        }
        
        public FormValidation doSendTestMail( @QueryParameter String smtpHost, @QueryParameter String adminAddress, @QueryParameter boolean authentication, @QueryParameter String username, @QueryParameter Secret password, @QueryParameter boolean useSsl, @QueryParameter boolean useTls, @QueryParameter String smtpPort, @QueryParameter String charset, @QueryParameter String sendTestMailTo) throws IOException {
            try {
                final Jenkins jenkins = Jenkins.getInstance();
                if (jenkins == null) {
                    throw new IOException("Jenkins instance is not ready");
                }
                
                jenkins.checkPermission(Jenkins.ADMINISTER);
                if (!authentication) {
                    username = null;
                    password = null;
                }
                
                MimeMessage msg = new MimeMessage(createSession(smtpHost, smtpPort, useSsl, useTls, username, password));
                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);
                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);
                msg.setFrom(stringToAddress(adminAddress, charset));
                if (StringUtils.isNotBlank(replyToAddress)) {
                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});
                }
                
                msg.setSentDate(new Date());
                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));
                Transport.send(msg);                
                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());
            }
             catch (MessagingException e) {
                return FormValidation.errorWithMarkup("<p>"+Messages.Mailer_FailedToSendEmail()+"</p><pre>"+Util.escape(Functions.printThrowable(e))+"</pre>");
            }
            
        }
        
        public boolean isApplicable(Class<? extends AbstractProject> jobType) {
            return true;
        }
        
    }
    
    public static class UserProperty extends hudson.model.UserProperty {
        private final String emailAddress;
        public UserProperty(String emailAddress) {
            this.emailAddress = emailAddress;
        }
        
        public String getAddress() {
            if(hasExplicitlyConfiguredAddress()) {
                return emailAddress;
	        }
	        
            return MailAddressResolver.resolve(user);
        }
        
        public String getConfiguredAddress() {
            if(hasExplicitlyConfiguredAddress()) {
                return emailAddress;
            }
            
            return MailAddressResolver.resolveFast(user);
        }
        
        public String getEmailAddress() {
            return Util.fixEmptyAndTrim(emailAddress);
        }
        
        public String getExplicitlyConfiguredAddress() {
            return Util.fixEmptyAndTrim(emailAddress);
        }
        
        public boolean hasExplicitlyConfiguredAddress() {
            return Util.fixEmptyAndTrim(emailAddress)!=null;
        }
        
        public static final class DescriptorImpl extends UserPropertyDescriptor {
            public String getDisplayName() {
                return Messages.Mailer_UserProperty_DisplayName();
            }
            
            public UserProperty newInstance(User user) {
                return new UserProperty(null);
            }
            
            public UserProperty newInstance(@CheckForNull StaplerRequest req, JSONObject formData) throws FormException {
                return new UserProperty(req != null ? req.getParameter("email.address") : null);
            }
            
        }
        
    }
    
    @SuppressFBWarnings(value = "MS_SHOULD_BE_FINAL",  justification = "It may used for debugging purposes. We have to keep it for the sake of the binary copatibility")
    public static boolean debug = false;
}


