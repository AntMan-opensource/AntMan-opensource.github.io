package com.compuware.ispw.git;
import java.io.PrintStream;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.plugins.workflow.job.WorkflowRun;
import org.jenkinsci.plugins.workflow.steps.AbstractStepDescriptorImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractStepImpl;
import org.jenkinsci.plugins.workflow.steps.AbstractSynchronousNonBlockingStepExecution;
import org.jenkinsci.plugins.workflow.steps.StepContextParameter;
import org.kohsuke.stapler.AncestorInPath;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import com.compuware.ispw.restapi.Constants;
import com.compuware.ispw.restapi.util.RestApiUtils;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.init.InitMilestone;
import hudson.init.Initializer;
import hudson.model.Cause;
import hudson.model.Item;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.scm.ChangeLogSet;
import hudson.scm.EditType;
import hudson.scm.ChangeLogSet.AffectedFile;
import hudson.scm.ChangeLogSet.Entry;
import hudson.util.ListBoxModel;
import jenkins.branch.BranchIndexingCause;
import jenkins.model.Jenkins;
public class GitToIspwPublishStep extends AbstractStepImpl implements IGitToIspwPublish {
	 private String gitRepoUrl = DescriptorImpl.gitRepoUrl;
	private String gitCredentialsId = DescriptorImpl.gitCredentialsId;
	 private String connectionId = DescriptorImpl.connectionId;
	private String credentialsId = DescriptorImpl.credentialsId;
	private String runtimeConfig = DescriptorImpl.runtimeConfig;
	private String stream = DescriptorImpl.stream;
	private String app = DescriptorImpl.app;
	private String ispwConfigPath = DescriptorImpl.ispwConfigPath;
	 private String branchMapping = DescriptorImpl.branchMapping;
	public GitToIspwPublishStep() {
	}
	
	public static final class Execution extends AbstractSynchronousNonBlockingStepExecution<Integer> {
		private static final long serialVersionUID = 1L;
		private transient GitToIspwPublishStep step;
		private transient Run<?, ?> run;
		private transient TaskListener listener;
		protected Integer run() throws Exception {
			boolean firstBuild = false;
			WorkflowRun workflowRun = null;
			WorkflowRun previousRun = null;
			PrintStream logger = listener.getLogger();
			EnvVars envVars = getContext().get(hudson.EnvVars.class);
			GitToIspwUtils.trimEnvironmentVariables(envVars);
			            FilePath workspace = getContext().get(FilePath.class);
			List<? extends ChangeLogSet<? extends Entry>> changeSets = GitToIspwUtils.getChangeSets(run, logger);
			String branchName = envVars.get("BRANCH_NAME", StringUtils.EMPTY); 
			boolean calculatLog = false;
			if (run instanceof WorkflowRun){
				workflowRun = (WorkflowRun) run;
				previousRun = workflowRun.getPreviousBuild();
			}
			
			if (run instanceof WorkflowRun && (changeSets == null || changeSets.isEmpty())){
				 if (previousRun != null ){
					if (GitToIspwUtils.isReCalculateChangesRequired(workflowRun, listener)){
						if (RestApiUtils.isIspwDebugMode()){
							logger.println( "GitToIspwPublishStep: Calculate the changelog when re-running the last build."); 
						}
						
						calculatLog = true;
					}
					
				}
				
			}
			
			 FilePath buildParmPath = GitToIspwUtils.getFilePathInVirtualWorkspace(envVars, Constants.BUILD_PARAM_FILE_NAME);
        	 if (buildParmPath.exists()) {
        		logger.println("Remove the old build parm files." + buildParmPath.getName()); 
        		buildParmPath.delete();
        	}
        	
			 if ((changeSets != null || calculatLog) && !branchName.isEmpty()){
				HashSet<String> changedPathSet = new HashSet<String>();
				String paths = null;
				 logger.println("Branch name: " + branchName);
				Iterator<? extends ChangeLogSet<? extends Entry>> itrChangeSets = changeSets.iterator();
				if (calculatLog){
					if (RestApiUtils.isIspwDebugMode()){
						logger.println("GitToIspwPublishStep: Calculate the change log. "); 
					}
					
					itrChangeSets = GitToIspwUtils.calculateGitSCMChanges(run, workspace, listener, envVars).iterator();
				}
				
				 if (!itrChangeSets.hasNext()){
					if (previousRun == null){
						List<Cause> causes = run.getCauses();
						for (int i = 0; i < causes.size(); i++) {
							 if (causes.get(i) instanceof BranchIndexingCause){
								firstBuild = true;
								break;
							}
							
						}
						
					}
					
					if (!firstBuild){
						logger.println("No changed files were detected.");
						return 0; 
					}
					
				}
				
				 while (itrChangeSets.hasNext()){
					ChangeLogSet<? extends Entry> changeLogSets = itrChangeSets.next();
					Iterator<? extends Entry> itrChangeSet = changeLogSets.iterator();
					while (itrChangeSet.hasNext()){
						Entry changeLogSet = itrChangeSet.next();
						logger.println("Commit ID = " + changeLogSet.getCommitId());
						 Collection<? extends AffectedFile> affectedFiles = changeLogSet.getAffectedFiles();
						for (AffectedFile affectedFile : affectedFiles){
							String affectedPath = affectedFile.getPath();
							if (affectedFile.getEditType() == EditType.DELETE){
								affectedPath = "|" + changeLogSet.getCommitId() + "|" + affectedPath;
							}
							
							changedPathSet.add(affectedPath);
							 if (RestApiUtils.isIspwDebugMode()){
								logger.println("GitToIspwPublishStep: add a file path - " + affectedPath); 
							}
							
						}
						
					}
					
					logger.println("ChangedPathSet = " + changedPathSet);
					 if (!changedPathSet.isEmpty()){
						Set<String> pathSet = changedPathSet;
						paths = StringUtils.join(pathSet, ":");
					}
					
					else{
						logger.println("No changed files were detected.");
						return 0; 
					}
					
					if (!firstBuild){
						 envVars.put(GitToIspwConstants.VAR_TO_HASH, paths);
						envVars.put(GitToIspwConstants.VAR_FROM_HASH, GitToIspwConstants.VAR_FROM_HASH_TYPE_CHANGESET);
						envVars.put(GitToIspwConstants.VAR_REF, branchName);
					}
					
				}
				
			}
			
			 if (firstBuild){
				 envVars.put(GitToIspwConstants.VAR_TO_HASH, "-2");
				envVars.put(GitToIspwConstants.VAR_FROM_HASH, "-2");
				envVars.put(GitToIspwConstants.VAR_REF, branchName);
			}
			
	 Map<String, RefMap> map = GitToIspwUtils.parse(step.branchMapping);
			if (RestApiUtils.isIspwDebugMode()){
				logger.println("map=" + map);
			}
			
			 String refId = envVars.get(GitToIspwConstants.VAR_REF_ID, null);
			 BranchPatternMatcher matcher = new BranchPatternMatcher(map, logger);
			String matchTo = null;
			RefMap refMap = null;
			if (StringUtils.isBlank(refId)){
				logger.println("Using branch name for branch pattern match: " + branchName);
				matchTo = StringUtils.trimToNull(branchName);
			}
			
			else{
				logger.println("Using refid for branch pattern match: " + refId);
				matchTo = StringUtils.trimToNull(refId);
			}
			
			RestApiUtils.assertNotNull(logger, matchTo, "Cannot match on the branch name or refId in the branch mapping. Both are null or empty.");
			 refMap = matcher.match(matchTo);
			RestApiUtils.assertNotNull(logger, refMap, "Cannot find a branch pattern that matches the branch %s.  Please adjust your branch mapping.", matchTo);
			 Launcher launcher = getContext().get(Launcher.class);
			if(GitToIspwUtils.callCli(launcher, run, logger, envVars, refMap, step)) {
				return 0;
			}
			
			else{
				throw new AbortException("An error occurred while synchronizing source to ISPW");
			}
			
		}
		
	}
	
	public static final class DescriptorImpl extends AbstractStepDescriptorImpl {
		 public static final String gitRepoUrl = StringUtils.EMPTY;
		public static final String gitCredentialsId = StringUtils.EMPTY;
		 public static final String connectionId = StringUtils.EMPTY;
		public static final String credentialsId = StringUtils.EMPTY;
		public static final String runtimeConfig = StringUtils.EMPTY;
		public static final String stream = StringUtils.EMPTY;
		public static final String app = StringUtils.EMPTY;
		public static final String ispwConfigPath = StringUtils.EMPTY;
		 public static final String branchMapping = GitToIspwConstants.BRANCH_MAPPING_DEFAULT;
		public static final String containerDesc = StringUtils.EMPTY;
		public static final String containerPref = StringUtils.EMPTY;
		public DescriptorImpl() {
			super(Execution.class);
		}
		
		public String getDisplayName() {
			return "Git to ISPW Integration";
		}
		
		public String getFunctionName() {
			return "gitToIspwIntegration";
		}
		
		 public ListBoxModel doFillGitCredentialsIdItems(@AncestorInPath Jenkins context, @QueryParameter String gitCredentialsId, @AncestorInPath Item project) {
			return GitToIspwUtils.buildStandardCredentialsIdItems(context, gitCredentialsId, project);
		}
		
		 public ListBoxModel doFillConnectionIdItems(@AncestorInPath Jenkins context, @QueryParameter String connectionId, @AncestorInPath Item project) {
			return RestApiUtils.buildConnectionIdItems(context, connectionId, project);
		}
		
		public ListBoxModel doFillCredentialsIdItems(@AncestorInPath Jenkins context, @QueryParameter String credentialsId, @AncestorInPath Item project) {
			return GitToIspwUtils.buildStandardCredentialsIdItems(context, credentialsId, project);
		}
		
	}
	
	@Initializer(before = InitMilestone.PLUGINS_STARTED)
	public static void xStreamCompatibility() {
	}
	
	 public String getGitRepoUrl() {
		return gitRepoUrl;
	}
	
	public void setGitRepoUrl(String gitRepoUrl) {
		this.gitRepoUrl = gitRepoUrl;
	}
	
	 public String getGitCredentialsId() {
		return gitCredentialsId;
	}
	
	public void setGitCredentialsId(String gitCredentialsId) {
		this.gitCredentialsId = gitCredentialsId;
	}
	
	 public String getConnectionId() {
		return connectionId;
	}
	
	public void setConnectionId(String connectionId) {
		this.connectionId = connectionId;
	}
	
	 public String getCredentialsId() {
		return credentialsId;
	}
	
	public void setCredentialsId(String credentialsId) {
		this.credentialsId = credentialsId;
	}
	
	 public String getRuntimeConfig() {
		return runtimeConfig;
	}
	
	public void setRuntimeConfig(String runtimeConfig) {
		this.runtimeConfig = runtimeConfig;
	}
	
	 public String getStream() {
		return stream;
	}
	
	public void setStream(String stream) {
		this.stream = stream;
	}
	
	 public String getApp() {
		return app;
	}
	
	public void setApp(String app) {
		this.app = app;
	}
	
	 public String getBranchMapping() {
		return branchMapping;
	}
	
	public void setBranchMapping(String branchMapping) {
		this.branchMapping = branchMapping;
	}
	
	 public String getIspwConfigPath() {
		return ispwConfigPath;
	}
	
	public void setIspwConfigPath(String ispwConfigPath) {
		this.ispwConfigPath = ispwConfigPath;
	}
	
}


