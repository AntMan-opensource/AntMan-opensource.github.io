package org.keycloak.services.resources.admin;
import org.jboss.logging.Logger;
import org.jboss.resteasy.annotations.cache.NoCache;
import org.jboss.resteasy.spi.ResteasyProviderFactory;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.authentication.actiontoken.execactions.ExecuteActionsActionToken;
import org.keycloak.common.ClientConnection;
import org.keycloak.common.Profile;
import org.keycloak.common.util.Time;
import org.keycloak.credential.CredentialModel;
import org.keycloak.email.EmailException;
import org.keycloak.email.EmailTemplateProvider;
import org.keycloak.events.Details;
import org.keycloak.events.EventBuilder;
import org.keycloak.events.EventType;
import org.keycloak.events.admin.OperationType;
import org.keycloak.events.admin.ResourceType;
import org.keycloak.models.AuthenticatedClientSessionModel;
import org.keycloak.models.ClientModel;
import org.keycloak.models.Constants;
import org.keycloak.models.FederatedIdentityModel;
import org.keycloak.models.GroupModel;
import org.keycloak.models.IdentityProviderModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.ModelDuplicateException;
import org.keycloak.models.ModelException;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserConsentModel;
import org.keycloak.models.UserCredentialModel;
import org.keycloak.models.UserLoginFailureModel;
import org.keycloak.models.UserManager;
import org.keycloak.models.UserModel;
import org.keycloak.models.UserSessionModel;
import org.keycloak.models.utils.ModelToRepresentation;
import org.keycloak.models.utils.RepresentationToModel;
import org.keycloak.protocol.oidc.OIDCLoginProtocol;
import org.keycloak.protocol.oidc.utils.RedirectUtils;
import org.keycloak.provider.ProviderFactory;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.FederatedIdentityRepresentation;
import org.keycloak.representations.idm.GroupRepresentation;
import org.keycloak.representations.idm.UserConsentRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.keycloak.representations.idm.UserSessionRepresentation;
import org.keycloak.services.ErrorResponse;
import org.keycloak.services.ErrorResponseException;
import org.keycloak.services.ForbiddenException;
import org.keycloak.services.ServicesLogger;
import org.keycloak.services.managers.AuthenticationManager;
import org.keycloak.services.managers.BruteForceProtector;
import org.keycloak.services.managers.UserConsentManager;
import org.keycloak.services.managers.UserSessionManager;
import org.keycloak.services.resources.LoginActionsService;
import org.keycloak.services.resources.account.AccountFormService;
import org.keycloak.services.resources.admin.permissions.AdminPermissionEvaluator;
import org.keycloak.services.validation.Validation;
import org.keycloak.storage.ReadOnlyException;
import org.keycloak.userprofile.utils.UserUpdateHelper;
import org.keycloak.userprofile.validation.AttributeValidationResult;
import org.keycloak.userprofile.validation.UserProfileValidationResult;
import org.keycloak.userprofile.validation.ValidationResult;
import org.keycloak.utils.ProfileHelper;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.GET;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.core.UriBuilder;
import java.net.URI;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static org.keycloak.models.ImpersonationSessionNote.IMPERSONATOR_ID;
import static org.keycloak.models.ImpersonationSessionNote.IMPERSONATOR_USERNAME;
import static org.keycloak.userprofile.profile.UserProfileContextFactory.forUserResource;
public class UserResource {
    private static final Logger logger = Logger.getLogger(UserResource.class);
    protected RealmModel realm;
    private AdminPermissionEvaluator auth;
    private AdminEventBuilder adminEvent;
    private UserModel user;
    protected ClientConnection clientConnection;
    protected KeycloakSession session;
    protected HttpHeaders headers;
    public UserResource(RealmModel realm, UserModel user, AdminPermissionEvaluator auth, AdminEventBuilder adminEvent) {
        this.auth = auth;
        this.realm = realm;
        this.user = user;
        this.adminEvent = adminEvent.resource(ResourceType.USER);
    }
    
    public Response updateUser(final UserRepresentation rep) {
        auth.users().requireManage(user);
        try {
            if (rep.isEnabled() != null && rep.isEnabled()) {
                UserLoginFailureModel failureModel = session.loginFailures().getUserLoginFailure(realm, user.getId());
                if (failureModel != null) {
                    failureModel.clearFailures();
                }
                
            }
            
            Response response = validateUserProfile(user, rep, session);
            if (response != null) {
                return response;
            }
            
            updateUserFromRep(user, rep, session, true);
            RepresentationToModel.createCredentials(rep, session, realm, user, true);
            adminEvent.operation(OperationType.UPDATE).resourcePath(session.getContext().getUri()).representation(rep).success();
            if (session.getTransactionManager().isActive()) {
                session.getTransactionManager().commit();
            }
            
            return Response.noContent().build();
        }
         catch (ModelDuplicateException e) {
            return ErrorResponse.exists("User exists with same username or email");
        }
         catch (ReadOnlyException re) {
            return ErrorResponse.exists("User is read only!");
        }
         catch (ModelException me) {
            logger.warn("Could not update user!", me);
            return ErrorResponse.error("Could not update user!", Status.BAD_REQUEST);
        }
         catch (ForbiddenException fe) {
            throw fe;
        }
         catch (Exception me) { 
            logger.warn("Could not update user!", me);
            return ErrorResponse.error("Could not update user!", Status.BAD_REQUEST);
        }
        
    }
    
    public static Response validateUserProfile(UserModel user, UserRepresentation rep, KeycloakSession session) {
        UserProfileValidationResult result = forUserResource(user, rep, session).validate();
        if (!result.getErrors().isEmpty()) {
            for (AttributeValidationResult attrValidation : result.getErrors()) {
                StringBuilder s = new StringBuilder("Failed to update attribute " + attrValidation.getField() + ": ");
                for (ValidationResult valResult : attrValidation.getFailedValidations()) {
                    s.append(valResult.getErrorType() + ", ");
                }
                
                logger.warn(s);
            }
            
            return ErrorResponse.error("Could not update user! See server log for more details", Response.Status.BAD_REQUEST);
        }
         else {
            return null;
        }
        
    }
    
    public static void updateUserFromRep(UserModel user, UserRepresentation rep, KeycloakSession session, boolean isUpdateExistingUser) {
        boolean removeMissingRequiredActions = isUpdateExistingUser;
        UserUpdateHelper.updateUserResource(session, user, rep, rep.getAttributes() != null);
        if (rep.isEnabled() != null) user.setEnabled(rep.isEnabled());
        if (rep.isEmailVerified() != null) user.setEmailVerified(rep.isEmailVerified());
        if (rep.getFederationLink() != null) user.setFederationLink(rep.getFederationLink());
        List<String> reqActions = rep.getRequiredActions();
        if (reqActions != null) {
            session.getKeycloakSessionFactory() .getProviderFactoriesStream(RequiredActionProvider.class) .map(ProviderFactory::getId) .distinct() .forEach(action -> {
                        if (reqActions.contains(action)) {
                            user.addRequiredAction(action);
                        }
                         else if (removeMissingRequiredActions) {
                            user.removeRequiredAction(action);
                        }
                        
                    }
                    
);
        }
        
        List<CredentialRepresentation> credentials = rep.getCredentials();
        if (credentials != null) {
            for (CredentialRepresentation credential : credentials) {
                if (CredentialRepresentation.PASSWORD.equals(credential.getType()) && credential.isTemporary() != null && credential.isTemporary()) {
                    user.addRequiredAction(UserModel.RequiredAction.UPDATE_PASSWORD);
                }
                
            }
            
        }
        
    }
    
    public UserRepresentation getUser() {
        auth.users().requireView(user);
        UserRepresentation rep = ModelToRepresentation.toRepresentation(session, realm, user);
        if (realm.isIdentityFederationEnabled()) {
            List<FederatedIdentityRepresentation> reps = getFederatedIdentities(user).collect(Collectors.toList());
            rep.setFederatedIdentities(reps);
        }
        
        if (session.getProvider(BruteForceProtector.class).isTemporarilyDisabled(session, realm, user)) {
            rep.setEnabled(false);
        }
        
        rep.setAccess(auth.users().getAccess(user));
        return rep;
    }
    
    public Map<String, Object> impersonate() {
        ProfileHelper.requireFeature(Profile.Feature.IMPERSONATION);
        auth.users().requireImpersonate(user);
        RealmModel authenticatedRealm = auth.adminAuth().getRealm();
        boolean sameRealm = false;
        if (authenticatedRealm.getId().equals(realm.getId())) {
            sameRealm = true;
            UserSessionModel userSession = session.sessions().getUserSession(authenticatedRealm, auth.adminAuth().getToken().getSessionState());
            AuthenticationManager.expireIdentityCookie(realm, session.getContext().getUri(), clientConnection);
            AuthenticationManager.expireRememberMeCookie(realm, session.getContext().getUri(), clientConnection);
            AuthenticationManager.backchannelLogout(session, authenticatedRealm, userSession, session.getContext().getUri(), clientConnection, headers, true);
        }
        
        EventBuilder event = new EventBuilder(realm, session, clientConnection);
        UserSessionModel userSession = session.sessions().createUserSession(realm, user, user.getUsername(), clientConnection.getRemoteAddr(), "impersonate", false, null, null);
        UserModel adminUser = auth.adminAuth().getUser();
        String impersonatorId = adminUser.getId();
        String impersonator = adminUser.getUsername();
        userSession.setNote(IMPERSONATOR_ID.toString(), impersonatorId);
        userSession.setNote(IMPERSONATOR_USERNAME.toString(), impersonator);
        AuthenticationManager.createLoginCookie(session, realm, userSession.getUser(), userSession, session.getContext().getUri(), clientConnection);
        URI redirect = AccountFormService.accountServiceBaseUrl(session.getContext().getUri()).build(realm.getName());
        Map<String, Object> result = new HashMap<>();
        result.put("sameRealm", sameRealm);
        result.put("redirect", redirect.toString());
        event.event(EventType.IMPERSONATE) .session(userSession) .user(user) .detail(Details.IMPERSONATOR_REALM, authenticatedRealm.getName()) .detail(Details.IMPERSONATOR, impersonator).success();
        return result;
    }
    
    public Stream<UserSessionRepresentation> getSessions() {
        auth.users().requireView(user);
        return session.sessions().getUserSessionsStream(realm, user).map(ModelToRepresentation::toRepresentation);
    }
    
    public Stream<UserSessionRepresentation> getOfflineSessions(final @PathParam("clientUuid") String clientUuid) {
        auth.users().requireView(user);
        ClientModel client = realm.getClientById(clientUuid);
        if (client == null) {
            throw new NotFoundException("Client not found");
        }
        
        return new UserSessionManager(session).findOfflineSessionsStream(realm, user) .map(session -> toUserSessionRepresentation(session, clientUuid)) .filter(Objects::nonNull);
    }
    
    public Stream<FederatedIdentityRepresentation> getFederatedIdentity() {
        auth.users().requireView(user);
        return getFederatedIdentities(user);
    }
    
    private Stream<FederatedIdentityRepresentation> getFederatedIdentities(UserModel user) {
        Set<String> idps = realm.getIdentityProvidersStream().map(IdentityProviderModel::getAlias).collect(Collectors.toSet());
        return session.users().getFederatedIdentitiesStream(realm, user) .filter(identity -> idps.contains(identity.getIdentityProvider())) .map(ModelToRepresentation::toRepresentation);
    }
    
    public Response addFederatedIdentity(final @PathParam("provider") String provider, FederatedIdentityRepresentation rep) {
        auth.users().requireManage(user);
        if (session.users().getFederatedIdentity(realm, user, provider) != null) {
            return ErrorResponse.exists("User is already linked with provider");
        }
        
        FederatedIdentityModel socialLink = new FederatedIdentityModel(provider, rep.getUserId(), rep.getUserName());
        session.users().addFederatedIdentity(realm, user, socialLink);
        adminEvent.operation(OperationType.CREATE).resourcePath(session.getContext().getUri()).representation(rep).success();
        return Response.noContent().build();
    }
    
    public void removeFederatedIdentity(final @PathParam("provider") String provider) {
        auth.users().requireManage(user);
        if (!session.users().removeFederatedIdentity(realm, user, provider)) {
            throw new NotFoundException("Link not found");
        }
        
        adminEvent.operation(OperationType.DELETE).resourcePath(session.getContext().getUri()).success();
    }
    
    public Stream<Map<String, Object>> getConsents() {
        auth.users().requireView(user);
        Set<ClientModel> offlineClients = new UserSessionManager(session).findClientsWithOfflineToken(realm, user);
        return realm.getClientsStream() .map(client -> toConsent(client, offlineClients)) .filter(Objects::nonNull);
    }
    
    private Map<String, Object> toConsent(ClientModel client, Set<ClientModel> offlineClients) {
        UserConsentModel consent = session.users().getConsentByClient(realm, user.getId(), client.getId());
        boolean hasOfflineToken = offlineClients.contains(client);
        if (consent == null && !hasOfflineToken) {
            return null;
        }
        
        UserConsentRepresentation rep = (consent == null) ? null : ModelToRepresentation.toRepresentation(consent);
        Map<String, Object> currentRep = new HashMap<>();
        currentRep.put("clientId", client.getClientId());
        currentRep.put("grantedClientScopes", (rep == null ? Collections.emptyList() : rep.getGrantedClientScopes()));
        currentRep.put("createdDate", (rep == null ? null : rep.getCreatedDate()));
        currentRep.put("lastUpdatedDate", (rep == null ? null : rep.getLastUpdatedDate()));
        List<Map<String, String>> additionalGrants = new LinkedList<>();
        if (hasOfflineToken) {
            Map<String, String> offlineTokens = new HashMap<>();
            offlineTokens.put("client", client.getId());
            offlineTokens.put("key", "Offline Token");
            additionalGrants.add(offlineTokens);
        }
        
        currentRep.put("additionalGrants", additionalGrants);
        return currentRep;
    }
    
    public void revokeConsent(final @PathParam("client") String clientId) {
        auth.users().requireManage(user);
        ClientModel client = realm.getClientByClientId(clientId);
        if (client == null) {
            throw new NotFoundException("Client not found");
        }
        
        boolean revokedConsent = UserConsentManager.revokeConsentToClient(session, client, user);
        if (!revokedConsent) {
            throw new NotFoundException("Consent nor offline token not found");
        }
        
        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
    }
    
    public void logout() {
        auth.users().requireManage(user);
        session.users().setNotBeforeForUser(realm, user, Time.currentTime());
        session.sessions().getUserSessionsStream(realm, user) .collect(Collectors.toList())  .forEach(userSession -> AuthenticationManager.backchannelLogout(session, realm, userSession, session.getContext().getUri(), clientConnection, headers, true));
        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
    }
    
    public Response deleteUser() {
        auth.users().requireManage(user);
        boolean removed = new UserManager(session).removeUser(realm, user);
        if (removed) {
            adminEvent.operation(OperationType.DELETE).resourcePath(session.getContext().getUri()).success();
            return Response.noContent().build();
        }
         else {
            return ErrorResponse.error("User couldn't be deleted", Status.BAD_REQUEST);
        }
        
    }
    
    public RoleMapperResource getRoleMappings() {
        AdminPermissionEvaluator.RequirePermissionCheck manageCheck = () -> auth.users().requireMapRoles(user);
        AdminPermissionEvaluator.RequirePermissionCheck viewCheck = () -> auth.users().requireView(user);
        RoleMapperResource resource =  new RoleMapperResource(realm, auth, user, adminEvent, manageCheck, viewCheck);
        ResteasyProviderFactory.getInstance().injectProperties(resource);
        return resource;
    }
    
    public void disableCredentialType(List<String> credentialTypes) {
        auth.users().requireManage(user);
        if (credentialTypes == null) return;
        for (String type : credentialTypes) {
            session.userCredentialManager().disableCredentialType(realm, user, type);
        }
        
    }
    
    public void resetPassword(CredentialRepresentation cred) {
        auth.users().requireManage(user);
        if (cred == null || cred.getValue() == null) {
            throw new BadRequestException("No password provided");
        }
        
        if (Validation.isBlank(cred.getValue())) {
            throw new BadRequestException("Empty password not allowed");
        }
        
        try {
            session.userCredentialManager().updateCredential(realm, user, UserCredentialModel.password(cred.getValue(), false));
        }
         catch (IllegalStateException ise) {
            throw new BadRequestException("Resetting to N old passwords is not allowed.");
        }
         catch (ReadOnlyException mre) {
            throw new BadRequestException("Can't reset password as account is read only");
        }
         catch (ModelException e) {
            logger.warn("Could not update user password.", e);
            Properties messages = AdminRoot.getMessages(session, realm, auth.adminAuth().getToken().getLocale());
            throw new ErrorResponseException(e.getMessage(), MessageFormat.format(messages.getProperty(e.getMessage(), e.getMessage()), e.getParameters()), Status.BAD_REQUEST);
        }
        
        if (cred.isTemporary() != null && cred.isTemporary()) {
            user.addRequiredAction(UserModel.RequiredAction.UPDATE_PASSWORD);
        }
         else {
            user.removeRequiredAction(UserModel.RequiredAction.UPDATE_PASSWORD);
        }
        
        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
    }
    
    public Stream<CredentialRepresentation> credentials(){
        auth.users().requireManage(user);
        return session.userCredentialManager().getStoredCredentialsStream(realm, user) .peek(model -> model.setSecretData(null)) .map(ModelToRepresentation::toRepresentation);
    }
    
    public Stream<String> getConfiguredUserStorageCredentialTypes() {
        auth.users().requireManage(user);
        return session.userCredentialManager().getConfiguredUserStorageCredentialTypesStream(realm, user);
    }
    
    public void removeCredential(final @PathParam("credentialId") String credentialId) {
        auth.users().requireManage(user);
        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
        if (credential == null) {
            if (auth.users().canQuery()) throw new NotFoundException("Credential not found");
            else throw new ForbiddenException();
        }
        
        session.userCredentialManager().removeStoredCredential(realm, user, credentialId);
        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
    }
    
    public void setCredentialUserLabel(final @PathParam("credentialId") String credentialId, String userLabel) {
        auth.users().requireManage(user);
        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
        if (credential == null) {
            if (auth.users().canQuery()) throw new NotFoundException("Credential not found");
            else throw new ForbiddenException();
        }
        
        session.userCredentialManager().updateCredentialLabel(realm, user, credentialId, userLabel);
    }
    
    public void moveCredentialToFirst(final @PathParam("credentialId") String credentialId){
        moveCredentialAfter(credentialId, null);
    }
    
    public void moveCredentialAfter(final @PathParam("credentialId") String credentialId, final @PathParam("newPreviousCredentialId") String newPreviousCredentialId){
        auth.users().requireManage(user);
        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
        if (credential == null) {
            if (auth.users().canQuery()) throw new NotFoundException("Credential not found");
            else throw new ForbiddenException();
        }
        
        session.userCredentialManager().moveCredentialTo(realm, user, credentialId, newPreviousCredentialId);
    }
    
    public Response resetPasswordEmail(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String redirectUri, @QueryParam(OIDCLoginProtocol.CLIENT_ID_PARAM) String clientId) {
        List<String> actions = new LinkedList<>();
        actions.add(UserModel.RequiredAction.UPDATE_PASSWORD.name());
        return executeActionsEmail(redirectUri, clientId, null, actions);
    }
    
    public Response executeActionsEmail(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String redirectUri, @QueryParam(OIDCLoginProtocol.CLIENT_ID_PARAM) String clientId, @QueryParam("lifespan") Integer lifespan, List<String> actions) {
        auth.users().requireManage(user);
        if (user.getEmail() == null) {
            return ErrorResponse.error("User email missing", Status.BAD_REQUEST);
        }
        
        if (!user.isEnabled()) {
            throw new WebApplicationException( ErrorResponse.error("User is disabled", Status.BAD_REQUEST));
        }
        
        if (redirectUri != null && clientId == null) {
            throw new WebApplicationException( ErrorResponse.error("Client id missing", Status.BAD_REQUEST));
        }
        
        if (clientId == null) {
            clientId = Constants.ACCOUNT_MANAGEMENT_CLIENT_ID;
        }
        
        ClientModel client = realm.getClientByClientId(clientId);
        if (client == null) {
            logger.debugf("Client %s doesn't exist", clientId);
            throw new WebApplicationException( ErrorResponse.error("Client doesn't exist", Status.BAD_REQUEST));
        }
        
        if (!client.isEnabled()) {
            logger.debugf("Client %s is not enabled", clientId);
            throw new WebApplicationException( ErrorResponse.error("Client is not enabled", Status.BAD_REQUEST));
        }
        
        String redirect;
        if (redirectUri != null) {
            redirect = RedirectUtils.verifyRedirectUri(session, redirectUri, client);
            if (redirect == null) {
                throw new WebApplicationException( ErrorResponse.error("Invalid redirect uri.", Status.BAD_REQUEST));
            }
            
        }
        
        if (lifespan == null) {
            lifespan = realm.getActionTokenGeneratedByAdminLifespan();
        }
        
        int expiration = Time.currentTime() + lifespan;
        ExecuteActionsActionToken token = new ExecuteActionsActionToken(user.getId(), expiration, actions, redirectUri, clientId);
        try {
            UriBuilder builder = LoginActionsService.actionTokenProcessor(session.getContext().getUri());
            builder.queryParam("key", token.serialize(session, realm, session.getContext().getUri()));
            String link = builder.build(realm.getName()).toString();
            this.session.getProvider(EmailTemplateProvider.class) .setAttribute(Constants.TEMPLATE_ATTR_REQUIRED_ACTIONS, token.getRequiredActions()) .setRealm(realm) .setUser(user) .sendExecuteActions(link, TimeUnit.SECONDS.toMinutes(lifespan));
            adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
            return Response.noContent().build();
        }
         catch (EmailException e) {
            ServicesLogger.LOGGER.failedToSendActionsEmail(e);
            return ErrorResponse.error("Failed to send execute actions email", Status.INTERNAL_SERVER_ERROR);
        }
        
    }
    
    public Response sendVerifyEmail(@QueryParam(OIDCLoginProtocol.REDIRECT_URI_PARAM) String redirectUri, @QueryParam(OIDCLoginProtocol.CLIENT_ID_PARAM) String clientId) {
        List<String> actions = new LinkedList<>();
        actions.add(UserModel.RequiredAction.VERIFY_EMAIL.name());
        return executeActionsEmail(redirectUri, clientId, null, actions);
    }
    
    public Stream<GroupRepresentation> groupMembership(@QueryParam("search") String search, @QueryParam("first") Integer firstResult, @QueryParam("max") Integer maxResults, @QueryParam("briefRepresentation") @DefaultValue("true") boolean briefRepresentation) {
        auth.users().requireView(user);
        if (Objects.nonNull(search) && Objects.nonNull(firstResult) && Objects.nonNull(maxResults)) {
            return ModelToRepresentation.searchForGroupByName(user, !briefRepresentation, search.trim(), firstResult, maxResults);
        }
         else if(Objects.nonNull(firstResult) && Objects.nonNull(maxResults)) {
            return ModelToRepresentation.toGroupHierarchy(user, !briefRepresentation, firstResult, maxResults);
        }
         else {
            return ModelToRepresentation.toGroupHierarchy(user, !briefRepresentation);
        }
        
    }
    
    public Map<String, Long> getGroupMembershipCount(@QueryParam("search") String search) {
        auth.users().requireView(user);
        Long results;
        if (Objects.nonNull(search)) {
            results = user.getGroupsCountByNameContaining(search);
        }
         else {
            results = user.getGroupsCount();
        }
        
        Map<String, Long> map = new HashMap<>();
        map.put("count", results);
        return map;
    }
    
    public void removeMembership(@PathParam("groupId") String groupId) {
        auth.users().requireManageGroupMembership(user);
        GroupModel group = session.groups().getGroupById(realm, groupId);
        if (group == null) {
            throw new NotFoundException("Group not found");
        }
        
        auth.groups().requireManageMembership(group);
        try {
            if (user.isMemberOf(group)){
                user.leaveGroup(group);
                adminEvent.operation(OperationType.DELETE).resource(ResourceType.GROUP_MEMBERSHIP).representation(ModelToRepresentation.toRepresentation(group, true)).resourcePath(session.getContext().getUri()).success();
            }
            
        }
         catch (ModelException me) {
            Properties messages = AdminRoot.getMessages(session, realm, auth.adminAuth().getToken().getLocale());
            throw new ErrorResponseException(me.getMessage(), MessageFormat.format(messages.getProperty(me.getMessage(), me.getMessage()), me.getParameters()), Status.BAD_REQUEST);
        }
        
    }
    
    public void joinGroup(@PathParam("groupId") String groupId) {
        auth.users().requireManageGroupMembership(user);
        GroupModel group = session.groups().getGroupById(realm, groupId);
        if (group == null) {
            throw new NotFoundException("Group not found");
        }
        
        auth.groups().requireManageMembership(group);
        if (!user.isMemberOf(group)){
            user.joinGroup(group);
            adminEvent.operation(OperationType.CREATE).resource(ResourceType.GROUP_MEMBERSHIP).representation(ModelToRepresentation.toRepresentation(group, true)).resourcePath(session.getContext().getUri()).success();
        }
        
    }
    
    private UserSessionRepresentation toUserSessionRepresentation(final UserSessionModel userSession, final String clientUuid) {
        UserSessionRepresentation rep = ModelToRepresentation.toRepresentation(userSession);
        AuthenticatedClientSessionModel clientSession = userSession.getAuthenticatedClientSessionByClient(clientUuid);
        if (clientSession == null) {
            return null;
        }
        
        rep.setLastAccess(clientSession.getTimestamp());
        return rep;
    }
    
}


