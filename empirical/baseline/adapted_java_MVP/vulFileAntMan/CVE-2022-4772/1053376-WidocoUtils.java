package widoco;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.io.FileDocumentSource;
import org.semanticweb.owlapi.model.*;
public class WidocoUtils {
	private static final Logger logger = LoggerFactory.getLogger(WidocoUtils.class);
	 public static void loadModelToDocument(Configuration c) throws Exception {
		if (!c.isFromFile()) {
			String newOntologyPath = c.getTmpFile().getAbsolutePath() + File.separator + "Ontology";
			downloadOntology(c.getOntologyURI(), newOntologyPath);
			c.setFromFile(true);
			c.setOntologyPath(newOntologyPath);
		}
		
		logger.info("Load ontology " + c.getOntologyPath());
		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		OWLOntologyIRIMapper jenaCatalogMapper = new CatalogIRIMapper();
		manager.getIRIMappers().add(jenaCatalogMapper);
		((CatalogIRIMapper) jenaCatalogMapper).printMap();
		OWLOntologyLoaderConfiguration loadingConfig = new OWLOntologyLoaderConfiguration();
		loadingConfig = loadingConfig.setMissingImportHandlingStrategy(MissingImportHandlingStrategy.SILENT);
		OWLOntology ontology = manager .loadOntologyFromOntologyDocument(new FileDocumentSource(new File(c.getOntologyPath())), loadingConfig);
		c.getMainOntology().setMainOntology(ontology);
		c.getMainOntology().setMainOntologyManager(manager);
		c.getMainOntology().getOWLAPIModel().setOWLOntologyManager(manager);
	}
	
	 public static void downloadOntology(String uri, String downloadPath) {
		for (String serialization : Constants.POSSIBLE_VOCAB_SERIALIZATIONS) {
			logger.info("Attempting to download vocabulary in " + serialization);
			try {
				URL url = new URL(uri);
				HttpURLConnection connection = (HttpURLConnection) url.openConnection();
				connection.setRequestMethod("GET");
				connection.setInstanceFollowRedirects(true);
				connection.setRequestProperty("Accept", serialization);
				int status = connection.getResponseCode();
				boolean redirect = false;
				if (status != HttpURLConnection.HTTP_OK) {
					if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER){
						redirect = true;
}
				}
				
				 while (redirect) {
					String newUrl = connection.getHeaderField("Location");
					connection = (HttpURLConnection) new URL(newUrl).openConnection();
					connection.setRequestProperty("Accept", serialization);
					status = connection.getResponseCode();
					if (status != HttpURLConnection.HTTP_MOVED_TEMP && status != HttpURLConnection.HTTP_MOVED_PERM && status != HttpURLConnection.HTTP_SEE_OTHER){
						redirect = false;
}
				}
				
				InputStream in = (InputStream) connection.getInputStream();
				Files.copy(in, Paths.get(downloadPath), StandardCopyOption.REPLACE_EXISTING);
				in.close();
				break; 
						 }
						  catch (Exception e) {
				final String message = "Failed to download vocabulary in RDF format [" + serialization +"]: ";
				logger.error(message + e.toString());
				throw new RuntimeException(message, e);
			}
			
		}
		
	}
	
	 public static void writeModel(OWLOntologyManager m, OWLOntology o, OWLDocumentFormat f, String outPath) {
		OutputStream out = null;
		try {
			out = new FileOutputStream(outPath);
			m.saveOntology(o, f, out);
			out.close();
		}
		 catch (Exception ex) {
			logger.error("Error while writing the model to file " + ex.getMessage());
			if (out != null) {
				try {
					out.close();
				}
				 catch (Exception e) {
				}
				
			}
			
		}
		
	}
	
	 public static void copyResourceFolder(String[] resources, String savePath) throws IOException {
		for (String resource : resources) {
			String aux = resource.substring(resource.lastIndexOf("/") + 1, resource.length());
			File b = new File(savePath + File.separator + aux);
			b.createNewFile();
			copyLocalResource(resource, b);
		}
		
	}
	
	 public static void copyLocalResource(String resourceName, File dest) {
		try {
			copy(CreateResources.class.getResourceAsStream(resourceName), dest);
		}
		 catch (Exception e) {
			logger.error("Exception while copying " + resourceName + " - " + e.getMessage());
		}
		
	}
	
	 public static void copyExternalResource(String path, File dest) {
		try {
			InputStream is = new FileInputStream(path);
			copy(is, dest);
		}
		 catch (Exception e) {
			logger.error("Exception while copying " + path + e.getMessage());
		}
		
	}
	
        public static String readExternalResource(String path) {
            String content = "";
            try{
                content = new String ( Files.readAllBytes( Paths.get(path) ) );
            }
            catch (IOException e){
                logger.error("Exception while copying " + path + e.getMessage());
            }
            
            return content;
	}
	
	 public static void unZipIt(String resourceName, String outputFolder) {
		byte[] buffer = new byte[1024];
		try {
			ZipInputStream zis = new ZipInputStream(CreateResources.class.getResourceAsStream(resourceName));
			ZipEntry ze = zis.getNextEntry();
			while (ze != null) {
				String fileName = ze.getName();
				File newFile = new File(outputFolder + File.separator + fileName);
				 if (ze.isDirectory()) {
					String temp = newFile.getAbsolutePath();
					new File(temp).mkdirs();
				}
				 else {
					String directory = newFile.getParent();
					if (directory != null) {
						File d = new File(directory);
						if (!d.exists()) {
							d.mkdirs();
						}
						
					}
					
					FileOutputStream fos = new FileOutputStream(newFile);
					int len;
					while ((len = zis.read(buffer)) > 0) {
						fos.write(buffer, 0, len);
					}
					
					fos.close();
				}
				
				ze = zis.getNextEntry();
			}
			
			zis.closeEntry();
			zis.close();
		}
		 catch (IOException ex) {
			logger.error("Error while extracting the reosurces: " + ex.getMessage());
		}
		
	}
	
	public static void copy(InputStream is, File dest) throws Exception {
		OutputStream os = null;
		try {
			os = new FileOutputStream(dest);
			byte[] buffer = new byte[1024];
			int length;
			while ((length = is.read(buffer)) > 0) {
				os.write(buffer, 0, length);
			}
			
		}
		 catch (Exception e) {
			logger.error("Exception while copying resource. " + e.getMessage());
			throw e;
		}
		 finally {
			if (is != null){
				is.close();
}
			if (os != null){
				os.close();
}
		}
		
	}
	
	public static String getValueAsLiteralOrURI(OWLAnnotationValue v) {
		try {
			return v.asIRI().get().getIRIString();
		}
		 catch (Exception e) {
			 return v.asLiteral().get().getLiteral();
		}
		
	}
	
}


