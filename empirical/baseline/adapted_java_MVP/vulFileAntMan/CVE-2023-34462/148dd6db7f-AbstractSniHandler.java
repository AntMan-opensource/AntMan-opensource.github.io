package io.netty.handler.ssl;
import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.ScheduledFuture;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
public abstract class AbstractSniHandler<T> extends SslClientHelloHandler<T> {
    private static String extractSniHostname(ByteBuf in) {
        int offset = in.readerIndex();
        int endOffset = in.writerIndex();
        offset += 34;
        if (endOffset - offset >= 6) {
            final int sessionIdLength = in.getUnsignedByte(offset);
            offset += sessionIdLength + 1;
            final int cipherSuitesLength = in.getUnsignedShort(offset);
            offset += cipherSuitesLength + 2;
            final int compressionMethodLength = in.getUnsignedByte(offset);
            offset += compressionMethodLength + 1;
            final int extensionsLength = in.getUnsignedShort(offset);
            offset += 2;
            final int extensionsLimit = offset + extensionsLength;
            if (extensionsLimit <= endOffset) {
                while (extensionsLimit - offset >= 4) {
                    final int extensionType = in.getUnsignedShort(offset);
                    offset += 2;
                    final int extensionLength = in.getUnsignedShort(offset);
                    offset += 2;
                    if (extensionsLimit - offset < extensionLength) {
                        break;
                    }
                    
                    if (extensionType == 0) {
                        offset += 2;
                        if (extensionsLimit - offset < 3) {
                            break;
                        }
                        
                        final int serverNameType = in.getUnsignedByte(offset);
                        offset++;
                        if (serverNameType == 0) {
                            final int serverNameLength = in.getUnsignedShort(offset);
                            offset += 2;
                            if (extensionsLimit - offset < serverNameLength) {
                                break;
                            }
                            
                            final String hostname = in.toString(offset, serverNameLength, CharsetUtil.US_ASCII);
                            return hostname.toLowerCase(Locale.US);
                        }
                         else {
                            break;
                        }
                        
                    }
                    
                    offset += extensionLength;
                }
                
            }
            
        }
        
        return null;
    }
    
    protected final long handshakeTimeoutMillis;
    private ScheduledFuture<?> timeoutFuture;
    private String hostname;
    protected AbstractSniHandler(long handshakeTimeoutMillis) {
        this.handshakeTimeoutMillis = checkPositiveOrZero(handshakeTimeoutMillis, "handshakeTimeoutMillis");
    }
    
    public AbstractSniHandler() {
        this(0L);
    }
    
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        if (ctx.channel().isActive()) {
            checkStartTimeout(ctx);
        }
        
    }
    
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        ctx.fireChannelActive();
        checkStartTimeout(ctx);
    }
    
    private void checkStartTimeout(final ChannelHandlerContext ctx) {
        if (handshakeTimeoutMillis <= 0 || timeoutFuture != null) {
            return;
        }
        
        timeoutFuture = ctx.executor().schedule(new Runnable() {
            public void run() {
                if (ctx.channel().isActive()) {
                    SslHandshakeTimeoutException exception = new SslHandshakeTimeoutException( "handshake timed out after " + handshakeTimeoutMillis + "ms");
                    ctx.fireUserEventTriggered(new SniCompletionEvent(exception));
                    ctx.close();
                }
                
            }
            
        }, handshakeTimeoutMillis, TimeUnit.MILLISECONDS);
    }
    
    protected Future<T> lookup(ChannelHandlerContext ctx, ByteBuf clientHello) throws Exception {
        hostname = clientHello == null ? null : extractSniHostname(clientHello);
        return lookup(ctx, hostname);
    }
    
    protected void onLookupComplete(ChannelHandlerContext ctx, Future<T> future) throws Exception {
        if (timeoutFuture != null) {
            timeoutFuture.cancel(false);
        }
        
        try {
            onLookupComplete(ctx, hostname, future);
        }
         finally {
            fireSniCompletionEvent(ctx, hostname, future);
        }
        
    }
    
    protected abstract Future<T> lookup(ChannelHandlerContext ctx, String hostname) throws Exception;
    protected abstract void onLookupComplete(ChannelHandlerContext ctx, String hostname, Future<T> future) throws Exception;
    private static void fireSniCompletionEvent(ChannelHandlerContext ctx, String hostname, Future<?> future) {
        Throwable cause = future.cause();
        if (cause == null) {
            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname));
        }
         else {
            ctx.fireUserEventTriggered(new SniCompletionEvent(hostname, cause));
        }
        
    }
    
}


