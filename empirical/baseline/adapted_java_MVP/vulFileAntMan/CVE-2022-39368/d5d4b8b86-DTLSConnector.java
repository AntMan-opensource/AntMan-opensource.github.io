package org.eclipse.californium.scandium;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
import java.net.PortUnreachableException;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.eclipse.californium.elements.Connector;
import org.eclipse.californium.elements.DtlsEndpointContext;
import org.eclipse.californium.elements.EndpointContext;
import org.eclipse.californium.elements.EndpointContextMatcher;
import org.eclipse.californium.elements.exception.EndpointMismatchException;
import org.eclipse.californium.elements.exception.EndpointUnconnectedException;
import org.eclipse.californium.elements.exception.MulticastNotSupportedException;
import org.eclipse.californium.elements.RawData;
import org.eclipse.californium.elements.RawDataChannel;
import org.eclipse.californium.elements.util.ClockUtil;
import org.eclipse.californium.elements.util.DaemonThreadFactory;
import org.eclipse.californium.elements.util.DatagramReader;
import org.eclipse.californium.elements.util.ExecutorsUtil;
import org.eclipse.californium.elements.util.LeastRecentlyUsedCache;
import org.eclipse.californium.elements.util.NamedThreadFactory;
import org.eclipse.californium.elements.util.NetworkInterfacesUtil;
import org.eclipse.californium.elements.util.NoPublicAPI;
import org.eclipse.californium.elements.util.SerialExecutor;
import org.eclipse.californium.elements.util.StringUtil;
import org.eclipse.californium.scandium.config.DtlsConnectorConfig;
import org.eclipse.californium.scandium.dtls.AlertMessage;
import org.eclipse.californium.scandium.dtls.AlertMessage.AlertDescription;
import org.eclipse.californium.scandium.dtls.AlertMessage.AlertLevel;
import org.eclipse.californium.scandium.dtls.ApplicationMessage;
import org.eclipse.californium.scandium.dtls.AvailableConnections;
import org.eclipse.californium.scandium.dtls.ClientHandshaker;
import org.eclipse.californium.scandium.dtls.ClientHello;
import org.eclipse.californium.scandium.dtls.Connection;
import org.eclipse.californium.scandium.dtls.ConnectionEvictedException;
import org.eclipse.californium.scandium.dtls.ConnectionId;
import org.eclipse.californium.scandium.dtls.ConnectionIdGenerator;
import org.eclipse.californium.scandium.dtls.HandshakeResult;
import org.eclipse.californium.scandium.dtls.HandshakeResultHandler;
import org.eclipse.californium.scandium.dtls.ContentType;
import org.eclipse.californium.scandium.dtls.DTLSMessage;
import org.eclipse.californium.scandium.dtls.DTLSSession;
import org.eclipse.californium.scandium.dtls.DtlsException;
import org.eclipse.californium.scandium.dtls.DtlsHandshakeException;
import org.eclipse.californium.scandium.dtls.FragmentedHandshakeMessage;
import org.eclipse.californium.scandium.dtls.HandshakeException;
import org.eclipse.californium.scandium.dtls.HandshakeMessage;
import org.eclipse.californium.scandium.dtls.Handshaker;
import org.eclipse.californium.scandium.dtls.HelloVerifyRequest;
import org.eclipse.californium.scandium.dtls.InMemoryConnectionStore;
import org.eclipse.californium.scandium.dtls.PskSecretResult;
import org.eclipse.californium.scandium.dtls.MaxFragmentLengthExtension;
import org.eclipse.californium.scandium.dtls.ProtocolVersion;
import org.eclipse.californium.scandium.dtls.Record;
import org.eclipse.californium.scandium.dtls.RecordLayer;
import org.eclipse.californium.scandium.dtls.ResumingClientHandshaker;
import org.eclipse.californium.scandium.dtls.ResumingServerHandshaker;
import org.eclipse.californium.scandium.dtls.ResumptionSupportingConnectionStore;
import org.eclipse.californium.scandium.dtls.ServerHandshaker;
import org.eclipse.californium.scandium.dtls.ServerNameExtension;
import org.eclipse.californium.scandium.dtls.SessionAdapter;
import org.eclipse.californium.scandium.dtls.SessionCache;
import org.eclipse.californium.scandium.dtls.SessionId;
import org.eclipse.californium.scandium.dtls.SessionListener;
import org.eclipse.californium.scandium.dtls.SessionTicket;
import org.eclipse.californium.scandium.dtls.cipher.CipherSuite;
import org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore;
import org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier;
import org.eclipse.californium.scandium.util.SecretUtil;
import org.eclipse.californium.scandium.util.ServerNames;
public class DTLSConnector implements Connector, RecordLayer {
	 public static final String KEY_TLS_SERVER_HOST_NAME = "TLS_SERVER_HOST_NAME";
	private static final Logger LOGGER = LoggerFactory.getLogger(DTLSConnector.class);
	private static final Logger DROP_LOGGER = LoggerFactory.getLogger(LOGGER.getName() + ".drops");
	private static final int MAX_PLAINTEXT_FRAGMENT_LENGTH = 16384; 
	private static final int MAX_CIPHERTEXT_EXPANSION = CipherSuite.getOverallMaxCiphertextExpansion();
	private static final int MAX_DATAGRAM_BUFFER_SIZE = MAX_PLAINTEXT_FRAGMENT_LENGTH + DTLSSession.DTLS_HEADER_LENGTH + MAX_CIPHERTEXT_EXPANSION;
	 private static final int TLS12_CID_PADDING = 0;
	private static final long CLIENT_HELLO_TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(60);
	 private static final boolean MDC_SUPPORT;
	static {
		boolean mdc = false;
		try {
			MDC.clear();
			mdc = true;
		}
		 catch (Throwable ex) {
		}
		
		MDC_SUPPORT = mdc;
	}
	
	  protected final DtlsConnectorConfig config;
	private final ResumptionSupportingConnectionStore connectionStore;
	 private final Long autoResumptionTimeoutMillis;
	private final int thresholdHandshakesWithoutVerifiedPeer;
	private final AtomicInteger pendingHandshakesWithoutVerifiedPeer = new AtomicInteger();
	protected final DtlsHealth health;
	private final boolean serverOnly;
	private final String defaultHandshakeMode;
	 private final int useExtendedWindowFilter;
	 private final boolean useFilter;
	 private final boolean useCidUpdateAddressOnNewerRecordFilter;
	 private final AtomicInteger pendingOutboundMessagesCountdown = new AtomicInteger();
	private final List<Thread> receiverThreads = new LinkedList<Thread>();
	 protected final ConnectionIdGenerator connectionIdGenerator;
	 private final ProtocolVersion protocolVersionForHelloVerifyRequests;
	private ScheduledFuture<?> statusLogger;
	private InetSocketAddress lastBindAddress;
	 private Integer maximumTransmissionUnit;
	 private int ipv4Mtu = DEFAULT_IPV4_MTU;
	 private int ipv6Mtu = DEFAULT_IPV6_MTU;
	protected int inboundDatagramBufferSize = MAX_DATAGRAM_BUFFER_SIZE;
	private CookieGenerator cookieGenerator = new CookieGenerator();
	private Object alertHandlerLock= new Object();
	private volatile DatagramSocket socket;
	 protected ScheduledExecutorService timer;
	 private AtomicBoolean running = new AtomicBoolean(false);
	 private volatile EndpointContextMatcher endpointContextMatcher;
	private volatile RawDataChannel messageHandler;
	private AlertHandler alertHandler;
	private SessionListener sessionListener;
	private ConnectionExecutionListener connectionExecutionListener;
	private ExecutorService executorService;
	private boolean hasInternalExecutor;
	 public DTLSConnector(DtlsConnectorConfig configuration) {
		this(configuration, (SessionCache) null);
	}
	
	 public DTLSConnector(final DtlsConnectorConfig configuration, final SessionCache sessionCache) {
		this(configuration, createConnectionStore(configuration, sessionCache));
	}
	
	 protected static ResumptionSupportingConnectionStore createConnectionStore(DtlsConnectorConfig configuration, SessionCache sessionCache) {
		return new InMemoryConnectionStore(configuration.getMaxConnections(), configuration.getStaleConnectionThreshold(), sessionCache).setTag(configuration.getLoggingTag());
	}
	
	 protected DTLSConnector(final DtlsConnectorConfig configuration, final ResumptionSupportingConnectionStore connectionStore) {
		if (configuration == null) {
			throw new NullPointerException("Configuration must not be null");
		}
		 else if (connectionStore == null) {
			throw new NullPointerException("Connection store must not be null");
		}
		 else {
			this.config = configuration;
			this.connectionIdGenerator = config.getConnectionIdGenerator();
			this.protocolVersionForHelloVerifyRequests = config.getProtocolVersionForHelloVerifyRequests();
			this.pendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());
			this.autoResumptionTimeoutMillis = config.getAutoResumptionTimeoutMillis();
			this.serverOnly = config.isServerOnly();
			this.defaultHandshakeMode = config.getDefaultHandshakeMode();
			this.useExtendedWindowFilter = config.useExtendedWindowFilter();
			this.useFilter = config.useAntiReplayFilter() || useExtendedWindowFilter != 0;
			this.useCidUpdateAddressOnNewerRecordFilter = config.useCidUpdateAddressOnNewerRecordFilter();
			this.connectionStore = connectionStore;
			this.connectionStore.attach(connectionIdGenerator);
			this.connectionStore.setConnectionListener(config.getConnectionListener());
			ConnectionListener listener = config.getConnectionListener();
			if (listener instanceof ConnectionExecutionListener) {
				this.connectionExecutionListener = (ConnectionExecutionListener) listener;
			}
			
			HandshakeResultHandler handler = new HandshakeResultHandler() { 

				public void apply(PskSecretResult secretResult) {
					processAsynchronousHandshakeResult(secretResult);
				}
				
				public void apply(HandshakeResult connectionResult) {
					processAsynchronousHandshakeResult(connectionResult);
				}
				
			};
			AdvancedPskStore advancedPskStore = config.getAdvancedPskStore();
			if (advancedPskStore != null) {
				advancedPskStore.setResultHandler(handler);
			}
			
			NewAdvancedCertificateVerifier certificateVerifier = config.getAdvancedCertificateVerifier();
			if (certificateVerifier != null) {
				certificateVerifier.setResultHandler(handler);
			}
			
			DtlsHealth healthHandler = config.getHealthHandler();
			Integer healthStatusInterval = config.getHealthStatusInterval();
			 if (healthHandler == null && healthStatusInterval != null && healthStatusInterval > 0) {
				healthHandler = createDefaultHealthHandler(config);
				if (!healthHandler.isEnabled()) {
					healthHandler = null;
				}
				
			}
			
			this.health = healthHandler;
			this.sessionListener = new SessionAdapter() { 

				public void sessionEstablished(Handshaker handshaker, DTLSSession establishedSession) throws HandshakeException {
					DTLSConnector.this.sessionEstablished(handshaker, establishedSession);
				}
				
				public void handshakeCompleted(final Handshaker handshaker) {
					if (health != null) {
						health.endHandshake(true);
					}
					
					final Connection connection = handshaker.getConnection();
					ScheduledExecutorService timer = DTLSConnector.this.timer;
					if (timer != null) {
						try {
							timer.schedule(new Runnable() {
								public void run() {
									connection.startByClientHello(null);
								}
								
							}, CLIENT_HELLO_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
							return;
						}
						 catch (RejectedExecutionException ex) {
							LOGGER.debug("stopping.");
						}
						
					}
					
					 connection.startByClientHello(null);
				}
				
				public void handshakeFailed(Handshaker handshaker, Throwable error) {
					if (health != null) {
						health.endHandshake(false);
					}
					
					List<RawData> listOut = handshaker.takeDeferredApplicationData();
					if (!listOut.isEmpty()) {
						LOGGER.debug("Handshake with [{}] failed, report error to deferred {} messages", handshaker.getPeerAddress(), listOut.size());
						for (RawData message : listOut) {
							message.onError(error);
						}
						
					}
					
					Connection connection = handshaker.getConnection();
					if (handshaker.isRemovingConnection()) {
						connectionStore.remove(connection, false);
					}
					 else if (handshaker.isProbing()) {
						LOGGER.debug("Handshake with [{}] failed within probe!", handshaker.getPeerAddress());
					}
					 else if (connection.getEstablishedSession() == handshaker.getSession()) {
						if (error instanceof HandshakeException) {
							AlertMessage alert = ((HandshakeException)error).getAlert();
							if (alert != null && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {
								LOGGER.debug("Handshake with [{}] closed after session was established!", handshaker.getPeerAddress());
							}
							 else {
								LOGGER.warn("Handshake with [{}] failed after session was established! {}", handshaker.getPeerAddress(), alert);
							}
							
						}
						 else {
							 if (error instanceof ConnectionEvictedException) {
								LOGGER.debug("Handshake with [{}] never get APPLICATION_DATA", handshaker.getPeerAddress(), error);
							}
							 else {
								LOGGER.warn("Handshake with [{}] failed after session was established!", handshaker.getPeerAddress(), error);
							}
							
						}
						
					}
					 else if (connection.hasEstablishedSession()) {
						LOGGER.warn("Handshake with [{}] failed, but has an established session!", handshaker.getPeerAddress());
					}
					 else {
						LOGGER.warn("Handshake with [{}] failed, connection preserved!", handshaker.getPeerAddress());
					}
					
				}
				
			};
			int maxConnections = config.getMaxConnections();
			 long thresholdInPercent = config.getVerifyPeersOnResumptionThreshold();
			long threshold = (((long) maxConnections * thresholdInPercent) + 50L) / 100L;
			if (threshold == 0 && thresholdInPercent > 0) {
				threshold = 1;
			}
			
			this.thresholdHandshakesWithoutVerifiedPeer = (int) threshold;
		}
		
	}
	
	 protected DtlsHealth createDefaultHealthHandler(DtlsConnectorConfig configuration) {
		return new DtlsHealthLogger(configuration.getLoggingTag());
	}
	
	private final void sessionEstablished(Handshaker handshaker, final DTLSSession establishedSession) throws HandshakeException {
		try {
			final Connection connection = handshaker.getConnection();
			connectionStore.putEstablishedSession(establishedSession, connection);
			final SerialExecutor serialExecutor = connection.getExecutor();
			List<RawData> listOut = handshaker.takeDeferredApplicationData();
			if (!listOut.isEmpty()) {
				LOGGER.trace("Session with [{}] established, now process deferred {} messages", establishedSession.getPeer(), listOut.size());
				for (RawData message : listOut) {
					final RawData rawData = message;
					serialExecutor.execute(new Runnable() {
						public void run() {
							sendMessage(rawData, connection, establishedSession);
						}
						
					}
					
);
				}
				
			}
			
			List<Record> listIn = handshaker.takeDeferredRecords();
			if (!listIn.isEmpty()) {
				LOGGER.trace("Session with [{}] established, now process deferred {} messages", establishedSession.getPeer(), listIn.size());
				for (Record message : listIn) {
					final Record record = message;
					serialExecutor.execute(new Runnable() {
						public void run() {
							processRecord(record, connection);
						}
						
					}
					
);
				}
				
			}
			
		}
		 catch (RejectedExecutionException ex) {
			LOGGER.debug("stopping.");
		}
		
	}
	
	 protected void onInitializeHandshaker(final Handshaker handshaker) {
	}
	
	 private final void initializeHandshaker(final Handshaker handshaker) {
		if (sessionListener != null) {
			handshaker.addSessionListener(sessionListener);
			if (health != null) {
				health.startHandshake();
			}
			
		}
		
		onInitializeHandshaker(handshaker);
	}
	
	 public final synchronized void setExecutor(ExecutorService executor) {
		if (this.executorService != executor) {
			if (running.get()) {
				throw new IllegalStateException("cannot set new executor while connector is running");
			}
			 else {
				this.executorService = executor;
			}
			
		}
		
	}
	
	 public final void close(InetSocketAddress peerAddress) {
		final Connection connection = getConnection(peerAddress, null, false);
		if (connection != null && connection.hasEstablishedSession()) {
			SerialExecutor serialExecutor = connection.getExecutor();
			serialExecutor.execute(new Runnable() {
				public void run() {
					DTLSSession session = connection.getEstablishedSession();
					if (session != null) {
						terminateConnection(connection, new AlertMessage(AlertLevel.WARNING, AlertDescription.CLOSE_NOTIFY, connection.getPeerAddress()), session);
					}
					
				}
				
			}
			
);
		}
		
	}
	
	public final synchronized void start() throws IOException {
		start(config.getAddress());
	}
	
	 final synchronized void restart() throws IOException {
		if (lastBindAddress != null) {
			start(lastBindAddress);
		}
		 else {
			throw new IllegalStateException("Connector has never been started before");
		}
		
	}
	
	private synchronized ExecutorService getExecutorService() {
		return executorService;
	}
	
	 protected void start(InetSocketAddress bindAddress) throws IOException {
		if (running.get()) {
			return;
		}
		
		init(bindAddress, new DatagramSocket(null), config.getMaxTransmissionUnit());
	}
	
	 protected void init(InetSocketAddress bindAddress, DatagramSocket socket, Integer mtu) throws IOException {
		this.socket = socket;
		pendingOutboundMessagesCountdown.set(config.getOutboundMessageBufferSize());
		if (bindAddress.getPort() != 0 && config.isAddressReuseEnabled()) {
			 LOGGER.info("Enable address reuse for socket!");
			socket.setReuseAddress(true);
			if (!socket.getReuseAddress()) {
				LOGGER.warn("Enable address reuse for socket failed!");
			}
			
		}
		
		Integer size = config.getSocketReceiveBufferSize();
		try {
			if (size != null && size != 0) {
				socket.setReceiveBufferSize(size);
			}
			
			size = config.getSocketSendBufferSize();
			if (size != null && size != 0) {
				socket.setSendBufferSize(size);
			}
			
		}
		 catch (IllegalArgumentException ex) {
			LOGGER.error("failed to apply {}", size, ex);
		}
		
		 int recvBuffer = socket.getReceiveBufferSize();
		int sendBuffer = socket.getSendBufferSize();
		if (!socket.isBound()) {
			socket.bind(bindAddress);
		}
		
		if (lastBindAddress != null && (!socket.getLocalAddress().equals(lastBindAddress.getAddress()) || socket.getLocalPort() != lastBindAddress.getPort())){
			if (connectionStore instanceof ResumptionSupportingConnectionStore) {
				((ResumptionSupportingConnectionStore) connectionStore).markAllAsResumptionRequired();
			}
			 else {
				connectionStore.clear();
			}
			
		}
		
		if (config.getMaxFragmentLengthCode() != null) {
			MaxFragmentLengthExtension.Length lengthCode = MaxFragmentLengthExtension.Length.fromCode( config.getMaxFragmentLengthCode());
			 inboundDatagramBufferSize = lengthCode.length() + MAX_CIPHERTEXT_EXPANSION + DTLSSession.DTLS_HEADER_LENGTH; 
		}
		
		if (config.getMaxTransmissionUnit() != null) {
			this.maximumTransmissionUnit = config.getMaxTransmissionUnit();
			LOGGER.info("Configured MTU [{}]", this.maximumTransmissionUnit);
		}
		 else if (mtu != null) {
			this.maximumTransmissionUnit = mtu;
			LOGGER.info("Forced MTU [{}]", this.maximumTransmissionUnit);
		}
		 else {
			InetAddress localInterfaceAddress = bindAddress.getAddress();
			if (localInterfaceAddress.isAnyLocalAddress()) {
				ipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();
				ipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();
				LOGGER.info("multiple network interfaces, using smallest MTU [IPv4 {}, IPv6 {}]", ipv4Mtu, ipv6Mtu);
			}
			 else {
				NetworkInterface ni = NetworkInterface.getByInetAddress(localInterfaceAddress);
				boolean ipv6 = localInterfaceAddress instanceof Inet6Address;
				if (ni != null && ni.getMTU() > 0) {
					if (ipv6) {
						ipv6Mtu = ni.getMTU();
					}
					 else {
						ipv4Mtu = ni.getMTU();
					}
					
				}
				 else if (ipv6) {
					ipv6Mtu = NetworkInterfacesUtil.getIPv6Mtu();
					LOGGER.info("Cannot determine MTU of network interface, using minimum MTU [{}] of IPv6 instead", ipv6Mtu);
				}
				 else {
					ipv4Mtu = NetworkInterfacesUtil.getIPv4Mtu();
					LOGGER.info("Cannot determine MTU of network interface, using minimum MTU [{}] of IPv4 instead", ipv4Mtu);
				}
				
			}
			
			if (inboundDatagramBufferSize > config.getMaxTransmissionUnitLimit()) {
				if (ipv4Mtu > config.getMaxTransmissionUnitLimit()) {
					ipv4Mtu = config.getMaxTransmissionUnitLimit();
					LOGGER.info("Limit MTU IPv4[{}]", ipv4Mtu);
				}
				
				if (ipv6Mtu > config.getMaxTransmissionUnitLimit()) {
					ipv6Mtu = config.getMaxTransmissionUnitLimit();
					LOGGER.info("Limit MTU IPv6[{}]", ipv6Mtu);
				}
				
			}
			 else {
				if (ipv4Mtu > inboundDatagramBufferSize) {
					ipv4Mtu = inboundDatagramBufferSize;
					LOGGER.info("Buffersize MTU IPv4[{}]", ipv4Mtu);
				}
				
				if (ipv6Mtu > inboundDatagramBufferSize) {
					ipv6Mtu = inboundDatagramBufferSize;
					LOGGER.info("Buffersize MTU IPv6[{}]", ipv6Mtu);
				}
				
			}
			
		}
		
		lastBindAddress = new InetSocketAddress(socket.getLocalAddress(), socket.getLocalPort());
		if (executorService instanceof ScheduledExecutorService) {
			timer = (ScheduledExecutorService) executorService;
		}
		 else {
			timer = ExecutorsUtil.newSingleThreadScheduledExecutor(new DaemonThreadFactory( "DTLS-Timer-" + lastBindAddress + "#", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); 
		}
		
		if (executorService == null) {
			int threadCount = config.getConnectionThreadCount();
			if (threadCount > 1) {
				executorService = ExecutorsUtil.newFixedThreadPool(threadCount - 1, new DaemonThreadFactory( "DTLS-Worker-" + lastBindAddress + "#", NamedThreadFactory.SCANDIUM_THREAD_GROUP)); 
			}
			 else {
				executorService = timer;
			}
			
			this.hasInternalExecutor = true;
		}
		
		running.set(true);
		int receiverThreadCount = config.getReceiverThreadCount();
		for (int i = 0; i < receiverThreadCount; i++) {
			Worker receiver = new Worker("DTLS-Receiver-" + i + "-" + lastBindAddress) { 

				private final byte[] receiverBuffer = new byte[inboundDatagramBufferSize];
				private final DatagramPacket packet = new DatagramPacket(receiverBuffer, inboundDatagramBufferSize);
				public void doWork() throws Exception {
					if (MDC_SUPPORT) {
						MDC.clear();
					}
					
					packet.setData(receiverBuffer);
					receiveNextDatagramFromNetwork(packet);
				}
				
			};
			receiver.setDaemon(true);
			receiver.start();
			receiverThreads.add(receiver);
		}
		
		String mtuDescription = maximumTransmissionUnit != null ? maximumTransmissionUnit.toString() : "IPv4 " + ipv4Mtu + " / IPv6 " + ipv6Mtu;
		LOGGER.info("DTLSConnector listening on {}, recv buf = {}, send buf = {}, recv packet size = {}, MTU = {}", lastBindAddress, recvBuffer, sendBuffer, inboundDatagramBufferSize, mtuDescription);
		 if (health != null && health.isEnabled()) {
			final Integer healthStatusInterval = config.getHealthStatusInterval();
			if (healthStatusInterval != null) {
				statusLogger = timer.scheduleAtFixedRate(new Runnable() {
					public void run() {
						health.dump(config.getLoggingTag(), config.getMaxConnections(), connectionStore.remainingCapacity(), pendingHandshakesWithoutVerifiedPeer.get());
					}
					
				}, healthStatusInterval, healthStatusInterval, TimeUnit.SECONDS);
			}
			
		}
		
	}
	
	 public final synchronized void forceResumeSessionFor(InetSocketAddress peer) {
		Connection peerConnection = connectionStore.get(peer);
		if (peerConnection != null && peerConnection.hasEstablishedSession()) {
			peerConnection.setResumptionRequired(true);
		}
		
	}
	
	 public final synchronized void forceResumeAllSessions() {
		connectionStore.markAllAsResumptionRequired();
	}
	
	 public final synchronized void clearConnectionState() {
		connectionStore.clear();
	}
	
	private final DatagramSocket getSocket() {
		return socket;
	}
	
	public void stop() {
		ExecutorService shutdownTimer = null;
		ExecutorService shutdown = null;
		List<Runnable> pending = new ArrayList<>();
		synchronized (this) {
			if (running.compareAndSet(true, false)) {
				if (statusLogger != null) {
					statusLogger.cancel(false);
					statusLogger = null;
				}
				
				LOGGER.info("Stopping DTLS connector on [{}]", lastBindAddress);
				for (Thread t : receiverThreads) {
					t.interrupt();
				}
				
				if (socket != null) {
					socket.close();
					socket = null;
				}
				
				maximumTransmissionUnit = null;
				ipv4Mtu = DEFAULT_IPV4_MTU;
				ipv6Mtu = DEFAULT_IPV6_MTU;
				connectionStore.stop(pending);
				if (executorService != timer) {
					pending.addAll(timer.shutdownNow());
					shutdownTimer = timer;
					timer = null;
				}
				
				if (hasInternalExecutor) {
					pending.addAll(executorService.shutdownNow());
					shutdown = executorService;
					executorService = null;
					hasInternalExecutor = false;
				}
				
				for (Thread t : receiverThreads) {
					t.interrupt();
					try {
						t.join(500);
					}
					 catch (InterruptedException e) {
					}
					
				}
				
				receiverThreads.clear();
			}
			
		}
		
		if (shutdownTimer != null) {
			try {
				if (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {
					LOGGER.warn("Shutdown DTLS connector on [{}] timer not terminated in time!", lastBindAddress);
				}
				
			}
			 catch (InterruptedException e) {
			}
			
		}
		
		if (shutdown != null) {
			try {
				if (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {
					LOGGER.warn("Shutdown DTLS connector on [{}] executor not terminated in time!", lastBindAddress);
				}
				
			}
			 catch (InterruptedException e) {
			}
			
		}
		
		for (Runnable job : pending) {
			try {
				job.run();
			}
			 catch (Exception e) {
				LOGGER.warn("Shutdown DTLS connector:", e);
			}
			
		}
		
	}
	
	public synchronized void destroy() {
		stop();
		connectionStore.clear();
		messageHandler = null;
	}
	
	 public Future<Void> startDropConnectionsForPrincipal(final Principal principal) {
		if (principal == null) {
			throw new NullPointerException("principal must not be null!");
		}
		
		LeastRecentlyUsedCache.Predicate<Principal> handler = new LeastRecentlyUsedCache.Predicate<Principal>() { 

			public boolean accept(Principal connectionPrincipal) {
				return principal.equals(connectionPrincipal);
			}
			
		};
		return startTerminateConnectionsForPrincipal(handler);
	}
	
	 public Future<Void> startTerminateConnectionsForPrincipal( LeastRecentlyUsedCache.Predicate<Principal> principalHandler) {
		return startTerminateConnectionsForPrincipal(principalHandler, true);
	}
	
	 public Future<Void> startTerminateConnectionsForPrincipal( final LeastRecentlyUsedCache.Predicate<Principal> principalHandler, final boolean removeFromSessionCache) {
		if (principalHandler == null) {
			throw new NullPointerException("principal handler must not be null!");
		}
		
		LeastRecentlyUsedCache.Predicate<Connection> connectionHandler = new LeastRecentlyUsedCache.Predicate<Connection>() { 

			public boolean accept(Connection connection) {
				Principal peer = null;
				SessionTicket ticket = connection.getSessionTicket();
				if (ticket != null) {
					peer = ticket.getClientIdentity();
				}
				 else {
					DTLSSession session = connection.getSession();
					if (session != null) {
						peer = session.getPeerIdentity();
					}
					
				}
				
				if (peer != null && principalHandler.accept(peer)) {
					connectionStore.remove(connection, removeFromSessionCache);
				}
				
				return false;
			}
			
		};
		return startForEach(connectionHandler);
	}
	
	 public Future<Void> startForEach(LeastRecentlyUsedCache.Predicate<Connection> handler) {
		if (handler == null) {
			throw new NullPointerException("handler must not be null!");
		}
		
		ForEachFuture result = new ForEachFuture();
		nextForEach(connectionStore.iterator(), handler, result);
		return result;
	}
	
	 private void nextForEach(final Iterator<Connection> iterator, final LeastRecentlyUsedCache.Predicate<Connection> handler, final ForEachFuture result) {
		if (!result.isStopped() && iterator.hasNext()) {
			final Connection next = iterator.next();
			try {
				next.getExecutor().execute(new Runnable() {
					public void run() {
						boolean done = true;
						try {
							if (!result.isStopped() && !handler.accept(next)) {
								done = false;
								nextForEach(iterator, handler, result);
							}
							
						}
						 catch (Exception exception) {
							result.failed(exception);
						}
						 finally {
							if (done) {
								result.done();
							}
							
						}
						
					}
					
				}
				
);
				return;
			}
			 catch (RejectedExecutionException ex) {
				if (!handler.accept(next)) {
					while (iterator.hasNext()) {
						if (handler.accept(iterator.next())) {
							break;
						}
						
						if (result.isStopped()) {
							break;
						}
						
					}
					
				}
				
			}
			
		}
		
		result.done();
	}
	
	 private final Connection getConnection(InetSocketAddress peerAddress, ConnectionId cid, boolean create) {
		ExecutorService executor = getExecutorService();
		synchronized (connectionStore) {
			Connection connection;
			if (cid != null) {
				connection = connectionStore.get(cid);
			}
			 else {
				connection = connectionStore.get(peerAddress);
				if (connection == null && create) {
					LOGGER.trace("create new connection for {}", peerAddress);
					Connection newConnection = new Connection(peerAddress, new SerialExecutor(executor));
					newConnection.setExecutionListener(connectionExecutionListener);
					if (running.get()) {
						 if (!connectionStore.put(newConnection)) {
							return null;
						}
						
					}
					
					return newConnection;
				}
				
			}
			
			if (connection == null) {
				LOGGER.trace("no connection available for {},{}", peerAddress, cid);
			}
			 else if (!connection.isExecuting() && running.get()) {
				LOGGER.trace("revive connection for {},{}", peerAddress, cid);
				connection.setExecutor(new SerialExecutor(executor));
			}
			 else {
				LOGGER.trace("connection available for {},{}", peerAddress, cid);
			}
			
			return connection;
		}
		
	}
	
	 protected void receiveNextDatagramFromNetwork(DatagramPacket packet) throws IOException {
		DatagramSocket currentSocket = getSocket();
		if (currentSocket == null) {
			 return;
		}
		
		currentSocket.receive(packet);
		if (packet.getLength() == 0) {
			 return;
		}
		
		 processDatagram(packet);
	}
	
	protected void processDatagram(DatagramPacket packet) {
		processDatagram(packet, null);
	}
	
	 protected void processDatagram(DatagramPacket packet, InetSocketAddress router) {
		InetSocketAddress peerAddress = (InetSocketAddress) packet.getSocketAddress();
		if (MDC_SUPPORT) {
			MDC.put("PEER", StringUtil.toString(peerAddress));
		}
		
		if (health != null) {
			health.receivingRecord(false);
		}
		
		long timestamp = ClockUtil.nanoRealtime();
		if (peerAddress.getPort() == 0) {
			 DROP_LOGGER.trace("Discarding record with {} bytes from [{}] without source-port", packet.getLength(), peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			
			return;
		}
		
		DatagramReader reader = new DatagramReader(packet.getData(), packet.getOffset(), packet.getLength());
		List<Record> records = Record.fromReader(reader, peerAddress, router, connectionIdGenerator, timestamp);
		LOGGER.trace("Received {} DTLS records from {} using a {} byte datagram buffer", records.size(), peerAddress, inboundDatagramBufferSize);
		if (records.isEmpty()) {
			DROP_LOGGER.trace("Discarding {} malicious record with {} bytes from [{}]", packet.getLength(), peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			
			return;
		}
		
		if (!running.get()) {
			DROP_LOGGER.trace("Discarding {} records, startting with {} from [{}] on shutdown", records.size(), records.get(0).getType(), peerAddress);
			LOGGER.debug("Execution shutdown while processing incoming records from peer: {}", peerAddress);
			if (health != null) {
				health.receivingRecord(true);
			}
			
			return;
		}
		
		final Record firstRecord = records.get(0);
		if (records.size() == 1 && firstRecord.isNewClientHello()) {
			getExecutorService().execute(new Runnable() {
				public void run() {
					if (MDC_SUPPORT) {
						MDC.put("PEER", StringUtil.toString(firstRecord.getPeerAddress()));
					}
					
					processNewClientHello(firstRecord);
					if (MDC_SUPPORT) {
						MDC.clear();
					}
					
				}
				
			}
			
);
			return;
		}
		
		final ConnectionId connectionId = firstRecord.getConnectionId();
		final Connection connection = getConnection(peerAddress, connectionId, false);
		if (connection == null) {
			if (health != null) {
				health.receivingRecord(true);
			}
			
			if (connectionId == null) {
				DROP_LOGGER.trace("Discarding {} records from [{}] received without existing connection", records.size(), peerAddress);
			}
			 else {
				DROP_LOGGER.trace("Discarding {} records from [{},{}] received without existing connection", records.size(), peerAddress, connectionId);
			}
			
			return;
		}
		
		SerialExecutor serialExecutor = connection.getExecutor();
		for (final Record record : records) {
			try {
				serialExecutor.execute(new Runnable() {
					public void run() {
						if (running.get()) {
							processRecord(record, connection);
						}
						
					}
					
				}
				
);
			}
			 catch (RejectedExecutionException e) {
				 LOGGER.debug("Execution rejected while processing record [type: {}, peer: {}]", record.getType(), peerAddress, e);
				break;
			}
			 catch (RuntimeException e) {
				LOGGER.warn("Unexpected error occurred while processing record [type: {}, peer: {}]", record.getType(), peerAddress, e);
				terminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);
				break;
			}
			
		}
		
	}
	
	public void processRecord(Record record, Connection connection) {
		try {
			 if (record.getConnectionId() == null && !connection.equalsPeerAddress(record.getPeerAddress())) {
				long delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - record.getReceiveNanos());
				DROP_LOGGER.debug("Drop received record {}, connection changed address {} => {}! (shift {}ms)", record.getType(), record.getPeerAddress(), connection.getPeerAddress(), delay);
				if (health != null) {
					health.receivingRecord(true);
				}
				
				return;
			}
			
			int epoch = record.getEpoch();
			LOGGER.trace("Received DTLS record of type [{}], length: {}, [epoche:{},rseqn:{}]",  record.getType(), record.getFragmentLength(), epoch, record.getSequenceNumber());
			Handshaker handshaker = connection.getOngoingHandshake();
			if (handshaker != null && handshaker.isExpired()) {
				 handshaker.handshakeFailed(new Exception("handshake already expired!"));
				if (connectionStore.get(connection.getConnectionId()) != connection) {
					 DROP_LOGGER.debug("Discarding {} record [epoch {}, rseqn {}] received from peer [{}], handshake expired!", record.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());
					if (health != null) {
						health.receivingRecord(true);
					}
					
					return;
				}
				
				handshaker = null;
			}
			
			DTLSSession session = connection.getSession(epoch);
			if (session == null) {
				if (handshaker != null && handshaker.getSession().getReadEpoch() == 0 && epoch == 1) {
					 handshaker.addRecordsForDeferredProcessing(record);
				}
				 else {
					DROP_LOGGER.debug("Discarding {} record [epoch {}, rseqn {}] received from peer [{}] without an active session", record.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());
					if (health != null) {
						health.receivingRecord(true);
					}
					
				}
				
				return;
			}
			
			 boolean closed = connection.isClosed();
			boolean discard = (useFilter || closed) && (session != null) && !session.isRecordProcessable(epoch, record.getSequenceNumber(), useExtendedWindowFilter);
			 discard |= (closed && session == null);
			if (discard) {
				if (closed) {
					DROP_LOGGER.debug("Discarding {} record [epoch {}, rseqn {}] received from closed peer [{}]", record.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());
				}
				 else {
					DROP_LOGGER.debug("Discarding duplicate {} record [epoch {}, rseqn {}] received from peer [{}]", record.getType(), epoch, record.getSequenceNumber(), record.getPeerAddress());
				}
				
				if (health != null) {
					health.receivingRecord(true);
				}
				
				return;
			}
			
			if (record.getType() == ContentType.TLS12_CID) {
				 if (epoch == 0) {
					DROP_LOGGER.debug("Discarding TLS_CID record received from peer [{}] during handshake", record.getPeerAddress());
					if (health != null) {
						health.receivingRecord(true);
					}
					
					return;
				}
				
			}
			 else if (epoch > 0 && connection.expectCid()) {
				DROP_LOGGER.debug("Discarding record received from peer [{}], CID required!", record.getPeerAddress());
				if (health != null) {
					health.receivingRecord(true);
				}
				
				return;
			}
			
			if (!record.isDecoded() || record.getType() != ContentType.APPLICATION_DATA) {
				 record.applySession(session);
			}
			
			if (handshaker != null && handshaker.isProbing()) {
				 if (connection.hasEstablishedSession()) {
					connectionStore.removeFromEstablishedSessions(connection.getEstablishedSession(), connection);
				}
				
				connection.resetSession();
				handshaker.resetProbing();
				LOGGER.trace("handshake probe successful {}", connection.getPeerAddress());
			}
			
			switch (record.getType()) {
			case APPLICATION_DATA:
				processApplicationDataRecord(record, connection);
				break;
			case ALERT:
				processAlertRecord(record, connection, session);
				break;
			case CHANGE_CIPHER_SPEC:
				processChangeCipherSpecRecord(record, connection);
				break;
			case HANDSHAKE:
				processHandshakeRecord(record, connection);
				break;
			default: DROP_LOGGER.debug("Discarding record of unsupported type [{}] from peer [{}]", record.getType(), record.getPeerAddress());
			}
			
		}
		 catch (RuntimeException e) {
			if (health != null) {
				health.receivingRecord(true);
			}
			
			LOGGER.warn("Unexpected error occurred while processing record from peer [{}]", record.getPeerAddress(), e);
			terminateConnection(connection, e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);
		}
		 catch (GeneralSecurityException e) {
			DROP_LOGGER.debug("Discarding {} received from peer [{}] caused by {}", record.getType(), record.getPeerAddress(), e.getMessage());
			if (health != null) {
				health.receivingRecord(true);
			}
			
			LOGGER.debug("error occurred while processing record from peer [{}]", record.getPeerAddress(), e);
		}
		 catch (HandshakeException e) {
			LOGGER.debug("error occurred while processing record from peer [{}]", record.getPeerAddress(), e);
		}
		
	}
	
	 private void terminateOngoingHandshake(final Connection connection, final HandshakeException cause) {
		Handshaker handshaker = connection.getOngoingHandshake();
		if (handshaker != null) {
			if (LOGGER.isTraceEnabled()) {
				LOGGER.trace("Aborting handshake with peer [{}]:", connection.getPeerAddress(), cause);
			}
			 else if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("Aborting handshake with peer [{}]: {}", connection.getPeerAddress(), cause.getMessage());
			}
			
			handshaker.setFailureCause(cause);
			AlertMessage causingAlert = cause.getAlert();
			DTLSSession session = handshaker.getSession();
			if (!connection.hasEstablishedSession()) {
				terminateConnection(connection, causingAlert, session);
			}
			 else {
				 if (connection.getEstablishedSession() == handshaker.getSession()) {
					if (causingAlert.getDescription() == AlertDescription.CLOSE_NOTIFY) {
						LOGGER.debug("Handshake with [{}] closed after session was established!", handshaker.getPeerAddress());
					}
					 else {
						LOGGER.warn("Handshake with [{}] failed after session was established! {}", handshaker.getPeerAddress(), causingAlert);
					}
					
				}
				 else {
					LOGGER.warn("Handshake with [{}] failed, but has an established session!", handshaker.getPeerAddress());
				}
				
				send(causingAlert, session);
			}
			
			handshaker.handshakeFailed(cause);
		}
		
	}
	
	private void terminateConnection(Connection connection, Throwable cause, AlertLevel level, AlertDescription description) {
		if (connection.hasEstablishedSession()) {
			terminateConnection( connection, new AlertMessage(level, description, connection.getPeerAddress()), connection.getEstablishedSession());
		}
		 else if (connection.hasOngoingHandshake()) {
			terminateConnection( connection, new AlertMessage(level, description, connection.getPeerAddress()), connection.getOngoingHandshake().getSession());
		}
		
	}
	
	 private void terminateConnection(Connection connection, AlertMessage alert, DTLSSession session) {
		if (alert == null) {
			LOGGER.trace("Terminating connection with peer [{}]", connection.getPeerAddress());
		}
		 else {
			if (session == null) {
				throw new IllegalArgumentException("Session must not be null, if alert message is to be sent");
			}
			
			LOGGER.trace("Terminating connection with peer [{}], reason [{}]", connection.getPeerAddress(), alert.getDescription());
			send(alert, session);
		}
		
		if (alert != null && alert.getLevel() == AlertLevel.WARNING && alert.getDescription() == AlertDescription.CLOSE_NOTIFY) {
			 connection.setResumptionRequired(true);
		}
		 else {
			 connectionStore.remove(connection);
		}
		
	}
	
	 private void processApplicationDataRecord(final Record record, final Connection connection) {
		final Handshaker ongoingHandshake = connection.getOngoingHandshake();
		final DTLSSession session = connection.getEstablishedSession();
		if (session != null && !connection.isResumptionRequired()) {
			 ApplicationMessage message = (ApplicationMessage) record.getFragment();
			updateConnectionAddress(record, connection, session);
			final RawDataChannel channel = messageHandler;
			 if (channel != null) {
				 InetSocketAddress peer = session.getPeer();
				if (peer == null) {
					 session.setPeer(record.getPeerAddress());
				}
				
				 DtlsEndpointContext context = session.getConnectionReadContext();
				if (peer == null) {
					 session.setPeer(null);
					LOGGER.debug("Received APPLICATION_DATA from deprecated {}", record.getPeerAddress());
				}
				
				LOGGER.trace("Received APPLICATION_DATA for {}", context);
				RawData receivedApplicationMessage = RawData.inbound(message.getData(), context, false, record.getReceiveNanos());
				channel.receiveData(receivedApplicationMessage);
			}
			
		}
		 else if (ongoingHandshake != null) {
			 ongoingHandshake.addRecordsForDeferredProcessing(record);
		}
		 else {
			DROP_LOGGER.debug("Discarding APPLICATION_DATA record received from peer [{}]", record.getPeerAddress());
		}
		
	}
	
	 private void processAlertRecord(Record record, Connection connection, DTLSSession session) {
		AlertMessage alert = (AlertMessage) record.getFragment();
		Handshaker handshaker = connection.getOngoingHandshake();
		HandshakeException error = null;
		LOGGER.trace("Processing {} ALERT from [{}]: {}", alert.getLevel(), alert.getPeer(), alert.getDescription());
		if (AlertDescription.CLOSE_NOTIFY.equals(alert.getDescription())) {
			 if (connection.hasEstablishedSession()) {
				updateConnectionAddress(record, connection, session);
			}
			 else {
				error = new HandshakeException("Received 'close notify'", alert);
				if (handshaker != null) {
					handshaker.setFailureCause(error);
				}
				
			}
			
			if (!connection.isResumptionRequired()) {
				if (session.getPeer() != null) {
					send(new AlertMessage(AlertLevel.WARNING, AlertDescription.CLOSE_NOTIFY, alert.getPeer()), session);
				}
				
				if (connection.hasEstablishedSession()) {
					connection.close(record);
				}
				 else {
					connectionStore.remove(connection);
				}
				
			}
			
		}
		 else if (AlertLevel.FATAL.equals(alert.getLevel())) {
			 error = new HandshakeException("Received 'fatal alert/" + alert.getDescription() + "'", alert);
			if (handshaker != null) {
				handshaker.setFailureCause(error);
			}
			
			connectionStore.remove(connection);
		}
		 else {
			 }
			 
		handleAlertInternal(alert.getPeer(), alert, connection);
		if (null != error && null != handshaker) {
			handshaker.handshakeFailed(error);
		}
		
	}
	
	 private void updateConnectionAddress(Record record, Connection connection, DTLSSession session) {
		InetSocketAddress newAddress = null;
		if (session.markRecordAsRead(record.getEpoch(), record.getSequenceNumber()) || !useCidUpdateAddressOnNewerRecordFilter) {
			 connection.setRouter(record.getRouter());
			newAddress = record.getPeerAddress();
		}
		
		connection.refreshAutoResumptionTime();
		connectionStore.update(connection, newAddress);
		final Handshaker ongoingHandshake = connection.getOngoingHandshake();
		if (ongoingHandshake != null) {
			 ongoingHandshake.handshakeCompleted();
		}
		
	}
	
	 private void processChangeCipherSpecRecord(Record record, Connection connection) {
		Handshaker ongoingHandshaker = connection.getOngoingHandshake();
		if (ongoingHandshaker != null) {
			 try {
				ongoingHandshaker.processMessage(record);
			}
			 catch (HandshakeException e) {
				handleExceptionDuringHandshake(e, connection, record);
			}
			
		}
		 else {
			 DROP_LOGGER.debug("Received CHANGE_CIPHER_SPEC record from peer [{}] with no handshake going on", record.getPeerAddress());
		}
		
	}
	
	 private void processHandshakeRecord(final Record record, final Connection connection) {
		LOGGER.trace("Received {} record from peer [{}]", record.getType(), record.getPeerAddress());
		try {
			if (record.isNewClientHello()) {
				throw new IllegalArgumentException("new CLIENT_HELLO must be processed by processClientHello!");
			}
			
			HandshakeMessage handshakeMessage = (HandshakeMessage) record.getFragment();
			switch (handshakeMessage.getMessageType()) {
			case CLIENT_HELLO:
				 DROP_LOGGER.debug("Reject re-negotiation from peer {}", record.getPeerAddress());
				DTLSSession session = connection.getEstablishedSession();
				send(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, record.getPeerAddress()), session);
				break;
			case HELLO_REQUEST:
				processHelloRequest(connection);
				break;
			default: Handshaker handshaker = connection.getOngoingHandshake();
				if (handshaker != null) {
					handshaker.processMessage(record);
				}
				 else {
					DROP_LOGGER.debug( "Discarding HANDSHAKE message [epoch={}] from peer [{}], no ongoing handshake!", record.getEpoch(), record.getPeerAddress());
				}
				
				break;
			}
			
		}
		 catch (HandshakeException e) {
			handleExceptionDuringHandshake(e, connection, record);
		}
		
	}
	
	 private void processHelloRequest(final Connection connection) throws HandshakeException {
		if (connection.hasOngoingHandshake()) {
			 DROP_LOGGER.debug("Ignoring HELLO_REQUEST received from [{}] while already in an ongoing handshake with peer", connection.getPeerAddress());
		}
		 else {
			 DTLSSession session = connection.getEstablishedSession();
			send(new AlertMessage(AlertLevel.WARNING, AlertDescription.NO_RENEGOTIATION, connection.getPeerAddress()), session);
		}
		
	}
	
	 private void processNewClientHello(final Record record) {
		InetSocketAddress peerAddress = record.getPeerAddress();
		if (LOGGER.isTraceEnabled()) {
			StringBuilder msg = new StringBuilder("Processing new CLIENT_HELLO from peer [") .append(peerAddress).append("]").append(":").append(StringUtil.lineSeparator()).append(record);
			LOGGER.trace(msg.toString());
		}
		
		try {
			 record.applySession(null);
			DTLSMessage message = record.getFragment();
			if (message instanceof FragmentedHandshakeMessage) {
				LOGGER.debug("Received unsupported fragmented CLIENT_HELLO from peer [{}].", peerAddress);
				discardRecord(record, new DtlsException("Fragmented CLIENT_HELLO is not supported!", peerAddress));
				return;
			}
			
			final ClientHello clientHello = (ClientHello) message;
			 final AvailableConnections connections = new AvailableConnections();
			if (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {
				boolean verify = false;
				ExecutorService executorService = getExecutorService();
				Connection connection;
				synchronized (connectionStore) {
					connection = connectionStore.get(peerAddress);
					if (connection != null && !connection.isStartedByClientHello(clientHello)) {
						Connection sessionConnection = connections.getConnectionBySessionId();
						if (sessionConnection != null && sessionConnection != connection) {
							 verify = true;
						}
						 else {
							if (sessionConnection != null && sessionConnection == connection) {
								connections.setRemoveConnectionBySessionId(true);
							}
							
							final Handshaker handshaker = connection.getOngoingHandshake();
							if (handshaker != null) {
								DTLSSession establishedSession = connection.getEstablishedSession();
								if (establishedSession == null || handshaker.getSession() != establishedSession) {
									final DtlsException cause = new DtlsException( "Received new CLIENT_HELLO from " + StringUtil.toDisplayString(peerAddress), peerAddress);
									handshaker.setFailureCause(cause);
									connection.getExecutor().execute(new Runnable() {
										public void run() {
											if (running.get()) {
												handshaker.handshakeFailed(cause);
											}
											
										}
										
									}
									
);
								}
								
							}
							
							connection = null;
						}
						
					}
					
					if (connection == null) {
						connection = new Connection(peerAddress, new SerialExecutor(executorService));
						connection.setExecutionListener(connectionExecutionListener);
						connection.startByClientHello(clientHello);
						if (!connectionStore.put(connection)) {
							return;
						}
						
					}
					
				}
				
				if (verify) {
					sendHelloVerify(clientHello, record, null);
				}
				 else {
					connections.setConnectionByAddress(connection);
					try {
						connection.getExecutor().execute(new Runnable() {
							public void run() {
								if (running.get()) {
									processClientHello(clientHello, record, connections);
								}
								
							}
							
						}
						
);
					}
					 catch (RejectedExecutionException e) {
						 LOGGER.debug("Execution rejected while processing record [type: {}, peer: {}]", record.getType(), peerAddress, e);
					}
					 catch (RuntimeException e) {
						LOGGER.warn("Unexpected error occurred while processing record [type: {}, peer: {}]", record.getType(), peerAddress, e);
						terminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);
					}
					
				}
				
			}
			
		}
		 catch (HandshakeException e) {
			LOGGER.debug("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		}
		 catch (GeneralSecurityException e) {
			DROP_LOGGER.debug("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		}
		 catch (RuntimeException e) {
			LOGGER.warn("Processing new CLIENT_HELLO from peer [{}] failed!", record.getPeerAddress(), e);
		}
		
	}
	
	 private void processClientHello(ClientHello clientHello, Record record, AvailableConnections connections) {
		if (connections == null) {
			throw new NullPointerException("available connections must not be null!");
		}
		
		Connection connection = connections.getConnectionByAddress();
		if (connection == null) {
			throw new NullPointerException("connection by address must not be null!");
		}
		 else if (!connection.equalsPeerAddress(record.getPeerAddress())) {
			DROP_LOGGER.info("Drop received CLIENT_HELLO, changed address {} => {}!", record.getPeerAddress(), connection.getPeerAddress());
			return;
		}
		
		if (LOGGER.isTraceEnabled()) {
			StringBuilder msg = new StringBuilder("Processing CLIENT_HELLO from peer [").append(record.getPeerAddress()) .append("]").append(":").append(StringUtil.lineSeparator()).append(record);
			LOGGER.trace(msg.toString());
		}
		
		try {
			if (connection.hasEstablishedSession() || connection.getOngoingHandshake() != null) {
				DROP_LOGGER.debug("Discarding received duplicate CLIENT_HELLO message [epoch={}] from peer [{}]!", record.getEpoch(), record.getPeerAddress());
			}
			 else if (clientHello.hasSessionId()) {
				 resumeExistingSession(clientHello, record, connections);
			}
			 else {
				 startNewHandshake(clientHello, record, connection);
			}
			
		}
		 catch (HandshakeException e) {
			handleExceptionDuringHandshake(e, connection, record);
		}
		
	}
	
	 private boolean isClientInControlOfSourceIpAddress(ClientHello clientHello, Record record, AvailableConnections connections) {
		if (connections == null) {
			throw new NullPointerException("available connections must not be null!");
		}
		
		 try {
			byte[] expectedCookie = null;
			byte[] providedCookie = clientHello.getCookie();
			if (providedCookie.length > 0) {
				expectedCookie = cookieGenerator.generateCookie(clientHello);
				 if (MessageDigest.isEqual(expectedCookie, providedCookie)) {
					return true;
				}
				
				 byte[] pastCookie = cookieGenerator.generatePastCookie(clientHello);
				if (pastCookie != null && MessageDigest.isEqual(pastCookie, providedCookie)) {
					return true;
				}
				
				if (LOGGER.isDebugEnabled()) {
					LOGGER.debug("provided cookie must {} match {}. Send verify request to {}", StringUtil.byteArray2HexString(providedCookie, StringUtil.NO_SEPARATOR, 6), StringUtil.byteArray2HexString(expectedCookie, StringUtil.NO_SEPARATOR, 6), record.getPeerAddress());
				}
				
				 }
				  else {
				 if (0 < thresholdHandshakesWithoutVerifiedPeer) {
					int pending = pendingHandshakesWithoutVerifiedPeer.get();
					LOGGER.trace("pending fast resumptions [{}], threshold [{}]", pending, thresholdHandshakesWithoutVerifiedPeer);
					if (pending < thresholdHandshakesWithoutVerifiedPeer) {
						 Connection sessionConnection = connectionStore.find(clientHello.getSessionId());
						connections.setConnectionBySessionId(sessionConnection);
						if (sessionConnection != null) {
							 SessionTicket ticket;
							if (sessionConnection.hasEstablishedSession()) {
								ticket = sessionConnection.getEstablishedSession().getSessionTicket();
							}
							 else {
								ticket = sessionConnection.getSessionTicket();
							}
							
							if (verifySessionForResumption(clientHello, ticket)) {
								return true;
							}
							
						}
						
					}
					
				}
				
			}
			
			 sendHelloVerify(clientHello, record, expectedCookie);
			return false;
		}
		 catch (GeneralSecurityException e) {
			throw new DtlsHandshakeException("Cannot compute cookie for peer", AlertDescription.INTERNAL_ERROR, AlertLevel.FATAL, clientHello.getPeer(), e);
		}
		
	}
	
	 private void startNewHandshake(final ClientHello clientHello, final Record record, final Connection connection) throws HandshakeException {
		 DTLSSession newSession = new DTLSSession(record.getPeerAddress(), record.getSequenceNumber());
		 Handshaker handshaker = new ServerHandshaker(clientHello.getMessageSeq(), newSession, this, timer, connection, config);
		initializeHandshaker(handshaker);
		handshaker.processMessage(record);
	}
	
	 private void resumeExistingSession(ClientHello clientHello, Record record, final AvailableConnections connections) throws HandshakeException {
		InetSocketAddress peerAddress = record.getPeerAddress();
		LOGGER.trace("Client [{}] wants to resume session with ID [{}]", peerAddress, clientHello.getSessionId());
		if (connections == null) {
			throw new NullPointerException("available connections must not be null!");
		}
		
		Connection connection = connections.getConnectionByAddress();
		if (connection == null) {
			throw new NullPointerException("connection by address must not be null!");
		}
		 else if (!connection.equalsPeerAddress(peerAddress)) {
			throw new IllegalArgumentException("connection must have records address!");
		}
		
		SessionTicket ticket = null;
		if (!connections.isConnectionBySessionIdKnown()) {
			connections.setConnectionBySessionId(connectionStore.find(clientHello.getSessionId()));
		}
		
		Connection previousConnection = connections.getConnectionBySessionId();
		if (previousConnection != null && previousConnection.isActive()) {
			if (previousConnection.hasEstablishedSession()) {
				ticket = previousConnection.getEstablishedSession().getSessionTicket();
			}
			 else {
				ticket = previousConnection.getSessionTicket();
			}
			
			boolean ok = verifySessionForResumption(clientHello, ticket);
			if (!ok && ticket != null) {
				SecretUtil.destroy(ticket);
				ticket = null;
			}
			
		}
		
		if (ticket != null) {
			 final DTLSSession sessionToResume = new DTLSSession(clientHello.getSessionId(), peerAddress, ticket, record.getSequenceNumber());
			final Handshaker handshaker = new ResumingServerHandshaker(clientHello.getMessageSeq(), sessionToResume, this, timer, connection, config);
			initializeHandshaker(handshaker);
			SecretUtil.destroy(ticket);
			if (previousConnection.hasEstablishedSession()) {
				 if (connections.isRemoveConnectionBySessionId()) {
					 connectionStore.remove(previousConnection, false);
				}
				 else if (clientHello.getCookie().length == 0) {
					 pendingHandshakesWithoutVerifiedPeer.incrementAndGet();
					handshaker.addSessionListener(new SessionAdapter() {
						public void sessionEstablished(final Handshaker currentHandshaker, final DTLSSession establishedSession) throws HandshakeException {
							pendingHandshakesWithoutVerifiedPeer.decrementAndGet();
						}
						
						public void handshakeFailed(Handshaker handshaker, Throwable error) {
							pendingHandshakesWithoutVerifiedPeer.decrementAndGet();
						}
						
					}
					
);
				}
				
			}
			
			 handshaker.processMessage(record);
		}
		 else {
			LOGGER.trace( "Client [{}] tries to resume non-existing session [ID={}], performing full handshake instead ...", peerAddress, clientHello.getSessionId());
			startNewHandshake(clientHello, record, connection);
		}
		
	}
	
	 private boolean verifySessionForResumption(ClientHello clientHello, SessionTicket ticket) {
		boolean ok = true;
		if (ticket != null && config.isSniEnabled()) {
			ServerNames serverNames1 = ticket.getServerNames();
			ServerNames serverNames2 = null;
			ServerNameExtension extension = clientHello.getServerNameExtension();
			if (extension != null) {
				serverNames2 = extension.getServerNames();
			}
			
			if (serverNames1 != null) {
				ok = serverNames1.equals(serverNames2);
			}
			 else if (serverNames2 != null) {
				 ok = false;
			}
			
		}
		
		return ok;
	}
	
	private void sendHelloVerify(ClientHello clientHello, Record record, byte[] expectedCookie) throws GeneralSecurityException {
		 LOGGER.trace("Verifying client IP address [{}] using HELLO_VERIFY_REQUEST", record.getPeerAddress());
		if (expectedCookie == null) {
			expectedCookie = cookieGenerator.generateCookie(clientHello);
		}
		
		ProtocolVersion version = protocolVersionForHelloVerifyRequests;
		if (version == null) {
			 version = clientHello.getClientVersion();
			if (version.compareTo(ProtocolVersion.VERSION_DTLS_1_0) < 0) {
				version = ProtocolVersion.VERSION_DTLS_1_0;
			}
			 else if (version.compareTo(ProtocolVersion.VERSION_DTLS_1_2) > 0) {
				version = ProtocolVersion.VERSION_DTLS_1_2;
			}
			
		}
		
		 HelloVerifyRequest msg = new HelloVerifyRequest(version, expectedCookie, record.getPeerAddress());
		 msg.setMessageSeq(clientHello.getMessageSeq());
		 Record helloVerify = new Record(ContentType.HANDSHAKE, version, record.getSequenceNumber(), msg, record.getPeerAddress());
		try {
			sendRecord(helloVerify);
		}
		 catch (IOException e) {
			 }
			 
	}
	
	void send(AlertMessage alert, DTLSSession session) {
		if (alert == null) {
			throw new IllegalArgumentException("Alert must not be NULL");
		}
		 else if (session == null) {
			throw new IllegalArgumentException("Session must not be NULL");
		}
		 else {
			try {
				LOGGER.trace("send ALERT {} for peer {}.", alert, session.getPeer());
				Record record;
				boolean useCid = session.getWriteEpoch() > 0;
				if (useCid || alert.getProtocolVersion() == null) {
					record = new Record(ContentType.ALERT, session.getWriteEpoch(), session.getSequenceNumber(), alert, session, useCid, TLS12_CID_PADDING);
				}
				 else {
					record = new Record(ContentType.ALERT, alert.getProtocolVersion(), session.getSequenceNumber(), alert, session.getPeer());
				}
				
				sendRecord(record);
			}
			 catch (IOException e) {
				 }
				  catch (GeneralSecurityException e) {
				DROP_LOGGER.warn("Cannot create ALERT message for peer [{}]", session.getPeer(), e);
			}
			
		}
		
	}
	
	public void send(final RawData message) {
		if (message == null) {
			throw new NullPointerException("Message must not be null");
		}
		
		if (health != null) {
			health.sendingRecord(false);
		}
		
		if (message.isMulticast()) {
			DROP_LOGGER.warn("DTLSConnector drops {} outgoing bytes to multicast {}:{}", message.getSize(), message.getAddress(), message.getPort());
			message.onError(new MulticastNotSupportedException("DTLS doesn't support multicast!"));
			if (health != null) {
				health.sendingRecord(true);
			}
			
			return;
		}
		
		if (message.getInetSocketAddress().getPort() == 0) {
			String destination = StringUtil.toString(message.getInetSocketAddress());
			DROP_LOGGER.warn("DTLSConnector drops {} outgoing bytes to [{}] without destination-port", message.getSize(), destination);
			message.onError(new IOException("CoAPs message to " + destination + " dropped, destination port 0!"));
			return;
		}
		
		final Connection connection;
		RuntimeException error = null;
		if (!running.get()) {
			connection = null;
			error = new IllegalStateException("connector must be started before sending messages is possible");
		}
		 else if (message.getSize() > MAX_PLAINTEXT_FRAGMENT_LENGTH) {
			connection = null;
			error = new IllegalArgumentException( "Message data must not exceed " + MAX_PLAINTEXT_FRAGMENT_LENGTH + " bytes");
		}
		 else {
			boolean create = !serverOnly;
			if (create) {
				create = !getEffectiveHandshakeMode(message).equals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);
			}
			
			connection = getConnection(message.getInetSocketAddress(), null, create);
			if (connection == null) {
				if (create) {
					error = new IllegalStateException("connection store is exhausted!");
				}
				 else {
					if (serverOnly) {
						message.onError(new EndpointUnconnectedException("server only, connection missing!"));
					}
					 else {
						message.onError(new EndpointUnconnectedException("connection missing!"));
					}
					
					DROP_LOGGER.debug("DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!", message.getSize(), message.getAddress(), message.getPort());
					if (health != null) {
						health.sendingRecord(true);
					}
					
					return;
				}
				
			}
			
		}
		
		if (error != null) {
			DROP_LOGGER.debug("DTLSConnector drops {} outgoing bytes to {}:{}, {}!", message.getSize(), message.getAddress(), message.getPort(), error.getMessage());
			message.onError(error);
			if (health != null) {
				health.sendingRecord(true);
			}
			
			throw error;
		}
		
		final long now =ClockUtil.nanoRealtime();
		if (pendingOutboundMessagesCountdown.decrementAndGet() >= 0) {
			try {
				SerialExecutor executor = connection.getExecutor();
				if (executor == null) {
					throw new NullPointerException("missing executor for connection! " + connection.getPeerAddress());
				}
				
				executor.execute(new Runnable() {
					public void run() {
						try {
							if (running.get()) {
								sendMessage(now, message, connection);
							}
							 else {
								DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, connector not running!", message.getSize(), message.getAddress(), message.getPort());
								message.onError(new InterruptedIOException("Connector is not running."));
								if (health != null) {
									health.sendingRecord(true);
								}
								
							}
							
						}
						 catch (Exception e) {
							if (running.get()) {
								LOGGER.warn("Exception thrown by executor thread [{}]", Thread.currentThread().getName(), e);
							}
							
							DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, {}", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());
							if (health != null) {
								health.sendingRecord(true);
							}
							
							message.onError(e);
						}
						 finally {
							pendingOutboundMessagesCountdown.incrementAndGet();
						}
						
					}
					
				}
				
);
			}
			 catch (RejectedExecutionException e) {
				LOGGER.debug("Execution rejected while sending application record [peer: {}]", message.getInetSocketAddress(), e);
				DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, {}", message.getSize(), message.getAddress(), message.getPort(), e.getMessage());
				message.onError(new InterruptedIOException("Connector is not running."));
				if (health != null) {
					health.sendingRecord(true);
				}
				
			}
			
		}
		 else {
			pendingOutboundMessagesCountdown.incrementAndGet();
			DROP_LOGGER.warn("Outbound message overflow! Dropping outbound message to peer [{}]", message.getInetSocketAddress());
			message.onError(new IllegalStateException("Outbound message overflow!"));
			if (health != null) {
				health.sendingRecord(true);
			}
			
		}
		
	}
	
	 private void sendMessage(final long nanos, final RawData message, final Connection connection) throws HandshakeException {
		if (connection.getPeerAddress() == null) {
			long delay = TimeUnit.NANOSECONDS.toMillis(ClockUtil.nanoRealtime() - nanos);
			DROP_LOGGER.info("Drop outgoing record with {} bytes, connection lost address {}! (shift {}ms)", message.getSize(), message.getInetSocketAddress(), delay);
			message.onError(new EndpointUnconnectedException("connection not longer assigned to address!"));
			if (health != null) {
				health.sendingRecord(true);
			}
			
			return;
		}
		
		LOGGER.trace("Sending application layer message to [{}]", message.getEndpointContext());
		Handshaker handshaker = connection.getOngoingHandshake();
		if (handshaker != null && !handshaker.hasSessionEstablished()) {
			if (handshaker.isExpired()) {
				 handshaker.handshakeAborted(new Exception("handshake already expired!"));
			}
			 else if (handshaker.isProbing()) {
				if (checkOutboundEndpointContext(message, null)) {
					message.onConnecting();
					handshaker.addApplicationDataForDeferredProcessing(message);
				}
				
				return;
			}
			
		}
		
		if (connection.isActive() && !connection.isClosed()) {
			sendMessageWithSession(message, connection);
		}
		 else {
			sendMessageWithoutSession(message, connection);
		}
		
	}
	
	 private void sendMessageWithoutSession(final RawData message, final Connection connection) throws HandshakeException {
		if (!checkOutboundEndpointContext(message, null)) {
			return;
		}
		
		Handshaker handshaker = connection.getOngoingHandshake();
		if (handshaker == null) {
			if (serverOnly) {
				DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, server only, connection missing!", message.getSize(), message.getAddress(), message.getPort());
				message.onError(new EndpointUnconnectedException("server only, connection missing!"));
				if (health != null) {
					health.sendingRecord(true);
				}
				
				return;
			}
			
			boolean none = getEffectiveHandshakeMode(message).contentEquals(DtlsEndpointContext.HANDSHAKE_MODE_NONE);
			if (none) {
				DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, connection missing!", message.getSize(), message.getAddress(), message.getPort());
				message.onError(new EndpointUnconnectedException("connection missing!"));
				if (health != null) {
					health.sendingRecord(true);
				}
				
				return;
			}
			
			DTLSSession session = new DTLSSession(message.getInetSocketAddress());
			session.setHostName(message.getEndpointContext().getVirtualHost());
			 handshaker = new ClientHandshaker(session, this, timer, connection, config, false);
			initializeHandshaker(handshaker);
			message.onConnecting();
			handshaker.addApplicationDataForDeferredProcessing(message);
			handshaker.startHandshake(); 
		}
		 else {
			message.onConnecting();
			handshaker.addApplicationDataForDeferredProcessing(message);
		}
		
	}
	
	 private void sendMessageWithSession(final RawData message, final Connection connection) throws HandshakeException {
		DTLSSession session = connection.getEstablishedSession();
		boolean markedAsClosed = session != null && session.isMarkedAsClosed();
		String handshakeMode = getEffectiveHandshakeMode(message);
		boolean none = DtlsEndpointContext.HANDSHAKE_MODE_NONE.equals(handshakeMode);
		if (none) {
			if (markedAsClosed || connection.isResumptionRequired()) {
				DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, resumption required!", message.getSize(), message.getAddress(), message.getPort());
				message.onError(new EndpointUnconnectedException("resumption required!"));
				if (health != null) {
					health.sendingRecord(true);
				}
				
				return;
			}
			
		}
		 else {
			boolean probing = DtlsEndpointContext.HANDSHAKE_MODE_PROBE.equals(handshakeMode);
			boolean full = DtlsEndpointContext.HANDSHAKE_MODE_FORCE_FULL.equals(handshakeMode);
			boolean force = probing || full || DtlsEndpointContext.HANDSHAKE_MODE_FORCE.equals(handshakeMode);
			if (force || markedAsClosed || connection.isAutoResumptionRequired(getAutResumptionTimeout(message))) {
				 if (serverOnly) {
					DROP_LOGGER.trace("DTLSConnector drops {} outgoing bytes to {}:{}, server only, resumption requested failed!", message.getSize(), message.getAddress(), message.getPort());
					message.onError(new EndpointUnconnectedException("server only, resumption requested failed!"));
					if (health != null) {
						health.sendingRecord(true);
					}
					
					return;
				}
				
				message.onConnecting();
				Handshaker previousHandshaker = connection.getOngoingHandshake();
				SessionTicket ticket = null;
				SessionId sessionId = null;
				if (!full) {
					if (session != null) {
						sessionId = session.getSessionIdentifier();
					}
					 else {
						sessionId = connection.getSessionIdentity();
					}
					
					full = sessionId.isEmpty();
					if (!full) {
						if (session != null) {
							try {
								ticket = session.getSessionTicket();
							}
							 catch (IllegalStateException ex) {
								LOGGER.debug("Not possible to resume incomplete session!");
							}
							
						}
						 else {
							ticket = connection.getSessionTicket();
						}
						
					}
					
				}
				
				if (session != null) {
					if (!probing) {
						connectionStore.removeFromEstablishedSessions(session, connection);
					}
					
				}
				 else {
					probing = false;
				}
				
				if (probing) {
					 connection.setResumptionRequired(false);
				}
				 else {
					connection.resetSession();
				}
				
				Handshaker newHandshaker;
				if (ticket == null) {
					 DTLSSession newSession = new DTLSSession(message.getInetSocketAddress());
					newSession.setHostName(message.getEndpointContext().getVirtualHost());
					newHandshaker = new ClientHandshaker(newSession, this, timer, connection, config, probing);
				}
				 else {
					DTLSSession resumableSession = new DTLSSession(sessionId, message.getInetSocketAddress(), ticket, 0);
					SecretUtil.destroy(ticket);
					resumableSession.setHostName(message.getEndpointContext().getVirtualHost());
					newHandshaker = new ResumingClientHandshaker(resumableSession, this, timer, connection, config, probing);
				}
				
				initializeHandshaker(newHandshaker);
				if (previousHandshaker != null) {
					newHandshaker.takeDeferredApplicationData(previousHandshaker);
					 previousHandshaker.handshakeAborted(new Exception("handshake replaced!"));
				}
				
				newHandshaker.addApplicationDataForDeferredProcessing(message);
				newHandshaker.startHandshake();
				return;
			}
			
		}
		
		 sendMessage(message, connection, session);
	}
	
	private void sendMessage(final RawData message, final Connection connection, final DTLSSession session) {
		try {
			LOGGER.trace("send {}-{} using {}-{}", connection.getConnectionId(), connection.getPeerAddress(), session.getSessionIdentifier(), session.getPeer());
			final EndpointContext ctx = session.getConnectionWriteContext();
			if (!checkOutboundEndpointContext(message, ctx)) {
				return;
			}
			
			message.onContextEstablished(ctx);
			Record record = new Record( ContentType.APPLICATION_DATA, session.getWriteEpoch(), session.getSequenceNumber(), new ApplicationMessage(message.getBytes(), message.getInetSocketAddress()), session, true, TLS12_CID_PADDING);
			sendRecord(record);
			message.onSent();
			connection.refreshAutoResumptionTime();
		}
		 catch (IOException e) {
			message.onError(e);
		}
		 catch (GeneralSecurityException e) {
			DROP_LOGGER.warn("Cannot send APPLICATION record to peer [{}]", message.getInetSocketAddress(), e);
			message.onError(e);
		}
		
	}
	
	 private boolean checkOutboundEndpointContext(final RawData message, final EndpointContext connectionContext) {
		final EndpointContextMatcher endpointMatcher = getEndpointContextMatcher();
		if (null != endpointMatcher && !endpointMatcher.isToBeSent(message.getEndpointContext(), connectionContext)) {
			if (DROP_LOGGER.isInfoEnabled()) {
				DROP_LOGGER.info("DTLSConnector ({}) drops {} bytes outgoing, {} != {}", this, message.getSize(), endpointMatcher.toRelevantState(message.getEndpointContext()), endpointMatcher.toRelevantState(connectionContext));
			}
			
			message.onError(new EndpointMismatchException());
			if (health != null) {
				health.sendingRecord(true);
			}
			
			return false;
		}
		
		return true;
	}
	
	 public final DTLSSession getSessionByAddress(InetSocketAddress address) {
		if (address == null) {
			return null;
		}
		
		Connection connection = connectionStore.get(address);
		if (connection != null) {
			return connection.getEstablishedSession();
		}
		 else {
			return null;
		}
		
	}
	
	public void dropReceivedRecord(Record record) {
		DROP_LOGGER.debug("Discarding {} record [epoch {}, rseqn {}] dropped by handshaker for peer [{}]", record.getType(), record.getEpoch(), record.getSequenceNumber(), record.getPeerAddress());
		if (health != null) {
			health.receivingRecord(true);
		}
		
	}
	
	public int getMaxDatagramSize(boolean ipv6) {
		int headerSize = ipv6 ? IPV6_HEADER_LENGTH : IPV4_HEADER_LENGTH;
		int mtu = maximumTransmissionUnit != null ? maximumTransmissionUnit : (ipv6 ? ipv6Mtu : ipv4Mtu);
		int size = mtu - headerSize;
		if (size < 64) {
			throw new IllegalStateException( String.format("%s, datagram size %d, mtu %d", ipv6 ? "IPV6" : "IPv4", size, mtu));
		}
		
		return mtu - headerSize;
	}
	
	public void sendFlight(List<DatagramPacket> datagrams) throws IOException {
		 for (DatagramPacket datagramPacket : datagrams) {
			if (health != null) {
				health.sendingRecord(false);
			}
			
			sendNextDatagramOverNetwork(datagramPacket);
		}
		
	}
	
	protected void sendRecord(Record record) throws IOException {
		if (health != null && record.getType() != ContentType.APPLICATION_DATA) {
			health.sendingRecord(false);
		}
		
		byte[] recordBytes = record.toByteArray();
		DatagramPacket datagram = new DatagramPacket(recordBytes, recordBytes.length, record.getPeerAddress());
		sendNextDatagramOverNetwork(datagram);
	}
	
	protected void sendNextDatagramOverNetwork(final DatagramPacket datagramPacket) throws IOException {
		DatagramSocket socket = getSocket();
		if (socket != null && !socket.isClosed()) {
			if (datagramPacket.getPort() == 0) {
				String destination = StringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress());
				DROP_LOGGER.trace("Discarding record with {} bytes to [{}] without destination-port", datagramPacket.getLength(), destination);
				if (health != null) {
					health.sendingRecord(true);
				}
				
				throw new IOException("DTLS Record to " + destination + " dropped, destination port 0!");
			}
			
			try {
				socket.send(datagramPacket);
				return;
			}
			 catch (PortUnreachableException e) {
				if (!socket.isClosed()) {
					LOGGER.warn("Could not send record, destination {} unreachable!", StringUtil.toString((InetSocketAddress) datagramPacket.getSocketAddress()));
				}
				
			}
			 catch (IOException e) {
				if (!socket.isClosed()) {
					LOGGER.warn("Could not send record", e);
					throw e;
				}
				
			}
			
		}
		
		InetSocketAddress address = lastBindAddress;
		if (address == null) {
			address = config.getAddress();
		}
		
		DROP_LOGGER.debug("Socket [{}] is closed, discarding packet ...", address);
		throw new IOException("Socket closed.");
	}
	
	 private void processAsynchronousHandshakeResult(final HandshakeResult handshakeResult) {
		final Connection connection = connectionStore.get(handshakeResult.getConnectionId());
		if (connection != null && connection.hasOngoingHandshake()) {
			SerialExecutor serialExecutor = connection.getExecutor();
			try {
				serialExecutor.execute(new Runnable() {
					public void run() {
						if (running.get()) {
							Handshaker handshaker = connection.getOngoingHandshake();
							if (handshaker != null) {
								try {
									handshaker.processAsyncHandshakeResult(handshakeResult);
								}
								 catch (HandshakeException e) {
									handleExceptionDuringHandshake(e, connection, null);
								}
								 catch (IllegalStateException e) {
									LOGGER.warn("Exception while processing handshake result [{}]", connection, e);
								}
								
							}
							 else {
								LOGGER.debug("No ongoing handshake for result [{}]", connection);
							}
							
						}
						 else {
							LOGGER.debug("Execution stopped while processing handshake result [{}]", connection);
						}
						
					}
					
				}
				
);
			}
			 catch (RejectedExecutionException e) {
				 LOGGER.debug("Execution rejected while processing handshake result [{}]", connection, e);
			}
			 catch (RuntimeException e) {
				LOGGER.warn("Unexpected error occurred while processing handshake result [{}]", connection, e);
			}
			
		}
		 else {
			LOGGER.debug("No connection or ongoing handshake for handshake result [{}]", connection);
		}
		
	}
	
	 private Long getAutResumptionTimeout(RawData message) {
		Long timeout = autoResumptionTimeoutMillis;
		String contextTimeout = message.getEndpointContext().get(DtlsEndpointContext.KEY_RESUMPTION_TIMEOUT);
		if (contextTimeout != null) {
			if (contextTimeout.isEmpty()) {
				timeout = null;
			}
			 else {
				try {
					timeout = Long.valueOf(contextTimeout);
				}
				 catch (NumberFormatException e) {
				}
				
			}
			
		}
		
		return timeout;
	}
	
	public final int getMaximumTransmissionUnit() {
		return maximumTransmissionUnit;
	}
	
	 public final int getMaximumFragmentLength(InetSocketAddress peer) {
		Connection con = connectionStore.get(peer);
		if (con != null && con.hasEstablishedSession()) {
			return con.getEstablishedSession().getMaxFragmentLength();
		}
		 else {
			return getMaxDatagramSize(peer.getAddress() instanceof Inet6Address) - DTLSSession.DTLS_HEADER_LENGTH;
		}
		
	}
	
	public final InetSocketAddress getAddress() {
		DatagramSocket socket = getSocket();
		int localPort = socket == null ? -1 : socket.getLocalPort();
		if (localPort < 0) {
			return config.getAddress();
		}
		 else {
			return new InetSocketAddress(socket.getLocalAddress(), localPort);
		}
		
	}
	
	public final boolean isRunning() {
		return running.get();
	}
	
	 protected abstract class Worker extends Thread {
		 protected Worker(String name) {
			super(NamedThreadFactory.SCANDIUM_THREAD_GROUP, name);
		}
		
		public void run() {
			try {
				LOGGER.info("Starting worker thread [{}]", getName());
				while (running.get()) {
					try {
						doWork();
					}
					 catch (InterruptedIOException e) {
						if (running.get()) {
							LOGGER.info("Worker thread [{}] IO has been interrupted", getName());
						}
						 else {
							LOGGER.debug("Worker thread [{}] IO has been interrupted", getName());
						}
						
					}
					 catch (InterruptedException e) {
						if (running.get()) {
							LOGGER.info("Worker thread [{}] has been interrupted", getName());
						}
						 else {
							LOGGER.debug("Worker thread [{}] has been interrupted", getName());
						}
						
					}
					 catch (Exception e) {
						if (running.get()) {
							LOGGER.debug("Exception thrown by worker thread [{}]", getName(), e);
						}
						 else {
							LOGGER.trace("Exception thrown by worker thread [{}]", getName(), e);
						}
						
					}
					
				}
				
			}
			 finally {
				LOGGER.info("Worker thread [{}] has terminated", getName());
			}
			
		}
		
		 protected abstract void doWork() throws Exception;
	}
	
	 private static class ForEachFuture implements Future<Void> {
		private final Lock lock = new ReentrantLock();
		private final Condition waitDone = lock.newCondition();
		private volatile boolean cancel;
		private volatile boolean done;
		private volatile Exception exception;
		public boolean cancel(boolean mayInterruptIfRunning) {
			boolean cancelled = false;
			lock.lock();
			try {
				if (!done && !cancel) {
					cancelled = true;
					cancel = true;
				}
				
			}
			 finally {
				lock.unlock();
			}
			
			return cancelled;
		}
		
		public boolean isCancelled() {
			return cancel;
		}
		
		public boolean isDone() {
			return done;
		}
		
		public Void get() throws InterruptedException, ExecutionException {
			lock.lock();
			try {
				if (!done) {
					waitDone.await();
				}
				
				if (exception != null) {
					throw new ExecutionException(exception);
				}
				
			}
			 finally {
				lock.unlock();
			}
			
			return null;
		}
		
		public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
			lock.lock();
			try {
				if (!done) {
					waitDone.await(timeout, unit);
				}
				
				if (exception != null) {
					throw new ExecutionException(exception);
				}
				
			}
			 finally {
				lock.unlock();
			}
			
			return null;
		}
		
		 public void done() {
			lock.lock();
			try {
				done = true;
				waitDone.signalAll();
			}
			 finally {
				lock.unlock();
			}
			
		}
		
		public void failed(Exception exception) {
			lock.lock();
			try {
				this.exception = exception;
				done = true;
				waitDone.signalAll();
			}
			 finally {
				lock.unlock();
			}
			
		}
		
		public boolean isStopped() {
			return done || cancel;
		}
		
	}
	
	public void setRawDataReceiver(final RawDataChannel messageHandler) {
		if (isRunning()) {
			throw new IllegalStateException("message handler cannot be set on running connector");
		}
		
		this.messageHandler = messageHandler;
	}
	
	public void setEndpointContextMatcher(EndpointContextMatcher endpointContextMatcher) {
		this.endpointContextMatcher = endpointContextMatcher;
	}
	
	private EndpointContextMatcher getEndpointContextMatcher() {
		return endpointContextMatcher;
	}
	
	 private String getEffectiveHandshakeMode(RawData message) {
		String mode = message.getEndpointContext().get(DtlsEndpointContext.KEY_HANDSHAKE_MODE);
		if (mode == null) {
			mode = defaultHandshakeMode;
		}
		
		return mode;
	}
	
	 public final void setAlertHandler(AlertHandler handler) {
		synchronized (alertHandlerLock) {
			this.alertHandler = handler;
		}
		
	}
	
	 private void handleExceptionDuringHandshake(HandshakeException cause, Connection connection, Record record) {
		AlertMessage alert = cause.getAlert();
		 if (!AlertLevel.FATAL.equals(alert.getLevel())) {
			if (record != null) {
				discardRecord(record, cause);
			}
			
			handleAlertInternal(alert.getPeer(), alert, connection);
			return;
		}
		
		 if (AlertDescription.UNKNOWN_PSK_IDENTITY.equals(alert.getDescription())) {
			if (record != null) {
				discardRecord(record, cause);
			}
			
			handleAlertInternal(alert.getPeer(), alert, connection);
			return;
		}
		
		 terminateOngoingHandshake(connection, cause);
	}
	
	 private void handleAlertInternal(InetSocketAddress peer, AlertMessage alert, Connection connection) {
		if (connection.getRootCauseAlert() == null) {
			connection.setRootCause(alert);
			AlertHandler handler;
			synchronized (alertHandlerLock) {
				handler = alertHandler;
			}
			
			if (handler != null) {
				handler.onAlert(peer, alert);
			}
			
		}
		
	}
	
	private void discardRecord(final Record record, final Throwable cause) {
		if (health != null) {
			health.receivingRecord(true);
		}
		
		byte[] bytes = record.getFragmentBytes();
		if (DROP_LOGGER.isTraceEnabled()) {
			String hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 64);
			DROP_LOGGER.trace("Discarding received {} record (epoch {}, payload: {}) from peer [{}]: ", record.getType(), record.getEpoch(), hexString, record.getPeerAddress(), cause);
		}
		 else if (DROP_LOGGER.isDebugEnabled()) {
			String hexString = StringUtil.byteArray2HexString(bytes, StringUtil.NO_SEPARATOR, 16);
			DROP_LOGGER.debug("Discarding received {} record (epoch {}, payload: {}) from peer [{}]: {}", record.getType(), record.getEpoch(), hexString, record.getPeerAddress(), cause.getMessage());
		}
		
	}
	
	public String getProtocol() {
		return "DTLS";
	}
	
	public String toString() {
		return getProtocol() + "-" + StringUtil.toString(getAddress());
	}
	
	 }
	 

