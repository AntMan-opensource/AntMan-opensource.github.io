package htsjdk.samtools;
import htsjdk.samtools.util.CloseableIterator;
import htsjdk.samtools.util.CloserUtil;
import htsjdk.samtools.util.FileAppendStreamLRUCache;
import htsjdk.samtools.util.IOUtil;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
public class CoordinateSortedPairInfoMap<KEY, REC> implements Iterable<Map.Entry<KEY, REC>> {
    private final int INVALID_SEQUENCE_INDEX = -2;
    private final File workDir = IOUtil.createTempDir("CSPI.", null);
    private int sequenceIndexOfMapInRam = INVALID_SEQUENCE_INDEX;
    private Map<KEY, REC> mapInRam = null;
    private final FileAppendStreamLRUCache outputStreams;
    private final Codec<KEY, REC> elementCodec;
    private final Map<Integer, Integer> sizeOfMapOnDisk = new HashMap<Integer, Integer>();
    private boolean iterationInProgress = false;
    public CoordinateSortedPairInfoMap(final int maxOpenFiles, final Codec<KEY, REC> elementCodec) {
        this.elementCodec = elementCodec;
        workDir.deleteOnExit();
        outputStreams = new FileAppendStreamLRUCache(maxOpenFiles);
    }
    
    public REC remove(final int sequenceIndex, final KEY key) {
        if (iterationInProgress) throw new IllegalStateException("Cannot be called when iteration is in progress");
        ensureSequenceLoaded(sequenceIndex);
        return mapInRam.remove(key);
    }
    
    private void ensureSequenceLoaded(final int sequenceIndex) {
        try {
            if (sequenceIndexOfMapInRam == sequenceIndex) {
                return;
            }
            
            if (mapInRam != null) {
                final File spillFile = makeFileForSequence(sequenceIndexOfMapInRam);
                if (spillFile.exists()) throw new IllegalStateException(spillFile + " should not exist.");
                if (!mapInRam.isEmpty()) {
                    final OutputStream os = getOutputStreamForSequence(sequenceIndexOfMapInRam);
                    elementCodec.setOutputStream(os);
                    for (final Map.Entry<KEY, REC> entry : mapInRam.entrySet()) {
                        elementCodec.encode(entry.getKey(), entry.getValue());
                    }
                    
                    sizeOfMapOnDisk.put(sequenceIndexOfMapInRam, mapInRam.size());
                    mapInRam.clear();
                }
                
            }
             else {
                mapInRam = new HashMap<KEY, REC>();
            }
            
            sequenceIndexOfMapInRam = sequenceIndex;
            File mapOnDisk = makeFileForSequence(sequenceIndex);
            if (outputStreams.containsKey(mapOnDisk)) {
                outputStreams.remove(mapOnDisk).close();
            }
            
            final Integer numRecords = sizeOfMapOnDisk.remove(sequenceIndex);
            if (mapOnDisk.exists()) {
                if (numRecords == null){
                    throw new IllegalStateException("null numRecords for " + mapOnDisk);
}
                FileInputStream is = null;
                try {
                    is = new FileInputStream(mapOnDisk);
                    elementCodec.setInputStream(is);
                    for (int i = 0; i < numRecords; ++i) {
                        final Map.Entry<KEY, REC> keyAndRecord = elementCodec.decode();
                        if (mapInRam.containsKey(keyAndRecord.getKey())){
                            throw new SAMException("Value was put into PairInfoMap more than once.  " + sequenceIndex + ": " + keyAndRecord.getKey());
}
                        mapInRam.put(keyAndRecord.getKey(), keyAndRecord.getValue());
                    }
                    
                }
                 finally {
                    CloserUtil.close(is);
                }
                
                htsjdk.samtools.util.IOUtil.deleteFiles(mapOnDisk);
            }
             else if (numRecords != null && numRecords > 0) throw new IllegalStateException("Non-zero numRecords but " + mapOnDisk + " does not exist");
        }
         catch (IOException e) {
            throw new SAMException("Error loading new map from disk.", e);
        }
        
    }
    
    public void put(final int sequenceIndex, final KEY key, final REC record) {
        if (iterationInProgress) throw new IllegalStateException("Cannot be called when iteration is in progress");
        if (sequenceIndex == sequenceIndexOfMapInRam) {
            if (mapInRam.containsKey(key)){
                throw new IllegalArgumentException("Putting value into PairInfoMap that already existed. " + sequenceIndex + ": " + key);
}
            mapInRam.put(key, record);
        }
         else {
            final OutputStream os = getOutputStreamForSequence(sequenceIndex);
            elementCodec.setOutputStream(os);
            elementCodec.encode(key, record);
            Integer prevCount = sizeOfMapOnDisk.get(sequenceIndex);
            if (prevCount == null) prevCount = 0;
            sizeOfMapOnDisk.put(sequenceIndex,  prevCount + 1);
        }
        
    }
    
    private File makeFileForSequence(final int index) {
        final File file = new File(workDir, index + ".tmp");
        file.deleteOnExit();
        return file;
    }
    
    private OutputStream getOutputStreamForSequence(final int mateSequenceIndex) {
        return outputStreams.get(makeFileForSequence(mateSequenceIndex));
    }
    
    public int size() {
        int total = sizeInRam();
        for (final Integer mapSize : sizeOfMapOnDisk.values()) {
            if (mapSize != null) {
                total += mapSize;
            }
            
        }
        
        return total;
    }
    
    public int sizeInRam() {
        return mapInRam != null? mapInRam.size(): 0;
    }
    
    public CloseableIterator<Map.Entry<KEY, REC>> iterator() {
        if (iterationInProgress) throw new IllegalStateException("Cannot be called when iteration is in progress");
        iterationInProgress = true;
        return new MapIterator();
    }
    
    private class MapIterator implements CloseableIterator<Map.Entry<KEY, REC>> {
        private boolean closed = false;
        private Set<Integer> referenceIndices = new HashSet<Integer>(sizeOfMapOnDisk.keySet());
        private final Iterator<Integer> referenceIndexIterator;
        private Iterator<Map.Entry<KEY, REC>> currentReferenceIterator = null;
        private MapIterator() {
            if (sequenceIndexOfMapInRam != INVALID_SEQUENCE_INDEX){
                referenceIndices.add(sequenceIndexOfMapInRam);
}
            referenceIndexIterator = referenceIndices.iterator();
            advanceToNextNonEmptyReferenceIndex();
        }
        
        private void advanceToNextNonEmptyReferenceIndex() {
            while (referenceIndexIterator.hasNext()) {
                int nextReferenceIndex = referenceIndexIterator.next();
                ensureSequenceLoaded(nextReferenceIndex);
                if (!mapInRam.isEmpty()) {
                    createIteratorForMapInRam();
                    return;
                }
                
            }
            
            currentReferenceIterator = null;
        }
        
        private void createIteratorForMapInRam() {
            currentReferenceIterator = mapInRam.entrySet().iterator();
        }
        
        public void close() {
            closed = true;
            iterationInProgress = false;
        }
        
        public boolean hasNext() {
            if (closed) throw new IllegalStateException("Iterator has been closed");
            if (currentReferenceIterator != null && !currentReferenceIterator.hasNext()){
                throw new IllegalStateException("Should not happen");
}
            return currentReferenceIterator != null;
        }
        
        public Map.Entry<KEY, REC> next() {
            if (closed) throw new IllegalStateException("Iterator has been closed");
            if (!hasNext()) throw new NoSuchElementException();
            final Map.Entry<KEY, REC> ret = currentReferenceIterator.next();
            if (!currentReferenceIterator.hasNext()) advanceToNextNonEmptyReferenceIndex();
            return ret;
        }
        
        public void remove() {
            throw new UnsupportedOperationException();
        }
        
    }
    
    public interface Codec<KEY, REC> {
        void setOutputStream(OutputStream os);
        void setInputStream(InputStream is);
        void encode(KEY key, REC record);
        Map.Entry<KEY, REC> decode();
    }
    
}


