package org.openmetadata.service.security;
import static org.openmetadata.common.utils.CommonUtil.nullOrEmpty;
import static org.openmetadata.service.security.jwt.JWTTokenGenerator.TOKEN_TYPE;
import com.auth0.jwk.Jwk;
import com.auth0.jwk.JwkProvider;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.fasterxml.jackson.databind.node.TextNode;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import java.net.URL;
import java.security.interfaces.RSAPublicKey;
import java.util.Calendar;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.TreeMap;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.core.UriInfo;
import javax.ws.rs.ext.Provider;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.openmetadata.schema.api.security.AuthenticationConfiguration;
import org.openmetadata.schema.api.security.AuthorizerConfiguration;
import org.openmetadata.schema.auth.LogoutRequest;
import org.openmetadata.schema.auth.ServiceTokenType;
import org.openmetadata.schema.services.connections.metadata.AuthProvider;
import org.openmetadata.service.security.auth.BotTokenCache;
import org.openmetadata.service.security.auth.CatalogSecurityContext;
import org.openmetadata.service.security.auth.UserTokenCache;
import org.openmetadata.service.security.saml.JwtTokenCacheManager;
public class JwtFilter implements ContainerRequestFilter {
  public static final String AUTHORIZATION_HEADER = "Authorization";
  public static final String TOKEN_PREFIX = "Bearer";
  public static final String BOT_CLAIM = "isBot";
  private List<String> jwtPrincipalClaims;
  private JwkProvider jwkProvider;
  private String principalDomain;
  private boolean enforcePrincipalDomain;
  private AuthProvider providerType;
  public static final List<String> EXCLUDED_ENDPOINTS = List.of( "v1/system/config/jwks", "v1/system/config/authorizer", "v1/system/config/customLogoConfiguration", "v1/users/signup", "v1/system/version", "v1/users/registrationConfirmation", "v1/users/resendRegistrationToken", "v1/users/generatePasswordResetLink", "v1/users/password/reset", "v1/users/checkEmailInUse", "v1/users/login", "v1/users/refresh");
  private JwtFilter() {}
  public JwtFilter( AuthenticationConfiguration authenticationConfiguration, AuthorizerConfiguration authorizerConfiguration) {
    this.providerType = authenticationConfiguration.getProvider();
    this.jwtPrincipalClaims = authenticationConfiguration.getJwtPrincipalClaims();
    ImmutableList.Builder<URL> publicKeyUrlsBuilder = ImmutableList.builder();
    for (String publicKeyUrlStr : authenticationConfiguration.getPublicKeyUrls()) {
      publicKeyUrlsBuilder.add(new URL(publicKeyUrlStr));
    }
    
    this.jwkProvider = new MultiUrlJwkProvider(publicKeyUrlsBuilder.build());
    this.principalDomain = authorizerConfiguration.getPrincipalDomain();
    this.enforcePrincipalDomain = authorizerConfiguration.getEnforcePrincipalDomain();
  }
  
  @VisibleForTesting
  JwtFilter( JwkProvider jwkProvider, List<String> jwtPrincipalClaims, String principalDomain, boolean enforcePrincipalDomain) {
    this.jwkProvider = jwkProvider;
    this.jwtPrincipalClaims = jwtPrincipalClaims;
    this.principalDomain = principalDomain;
    this.enforcePrincipalDomain = enforcePrincipalDomain;
  }
  
  public void filter(ContainerRequestContext requestContext) {
    UriInfo uriInfo = requestContext.getUriInfo();
    if (EXCLUDED_ENDPOINTS.stream() .anyMatch(endpoint -> uriInfo.getPath().equalsIgnoreCase(endpoint))) {
      return;
    }
    
    MultivaluedMap<String, String> headers = requestContext.getHeaders();
    String tokenFromHeader = extractToken(headers);
    LOG.debug("Token from header:{}", tokenFromHeader);
    if (AuthProvider.BASIC.equals(providerType) || AuthProvider.SAML.equals(providerType)) {
      validateTokenIsNotUsedAfterLogout(tokenFromHeader);
    }
    
    DecodedJWT jwt = validateAndReturnDecodedJwtToken(tokenFromHeader);
    Map<String, Claim> claims = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    claims.putAll(jwt.getClaims());
    String userName = validateAndReturnUsername(claims);
    if (claims.containsKey(BOT_CLAIM) && Boolean.TRUE.equals(claims.get(BOT_CLAIM).asBoolean())) {
      validateBotToken(tokenFromHeader, userName);
    }
    
    if (claims.containsKey(TOKEN_TYPE) && ServiceTokenType.PERSONAL_ACCESS.equals( ServiceTokenType.fromValue(claims.get(TOKEN_TYPE).asString()))) {
      validatePersonalAccessToken(tokenFromHeader, userName);
    }
    
    CatalogPrincipal catalogPrincipal = new CatalogPrincipal(userName);
    String scheme = requestContext.getUriInfo().getRequestUri().getScheme();
    CatalogSecurityContext catalogSecurityContext = new CatalogSecurityContext(catalogPrincipal, scheme, SecurityContext.DIGEST_AUTH);
    LOG.debug("SecurityContext {}", catalogSecurityContext);
    requestContext.setSecurityContext(catalogSecurityContext);
  }
  
  public DecodedJWT validateAndReturnDecodedJwtToken(String token) {
    DecodedJWT jwt;
    try {
      jwt = JWT.decode(token);
    }
     catch (JWTDecodeException e) {
      throw new AuthenticationException("Invalid token", e);
    }
    
    if (jwt.getExpiresAt() != null && jwt.getExpiresAt().before(Calendar.getInstance(TimeZone.getTimeZone("UTC")).getTime())) {
      throw new AuthenticationException("Expired token!");
    }
    
    Jwk jwk = jwkProvider.get(jwt.getKeyId());
    Algorithm algorithm = Algorithm.RSA256((RSAPublicKey) jwk.getPublicKey(), null);
    try {
      algorithm.verify(jwt);
    }
     catch (RuntimeException runtimeException) {
      throw new AuthenticationException("Invalid token", runtimeException);
    }
    
    return jwt;
  }
  
  public String validateAndReturnUsername(Map<String, Claim> claims) {
    String jwtClaim = jwtPrincipalClaims.stream() .filter(claims::containsKey) .findFirst() .map(claims::get) .map(claim -> claim.as(TextNode.class).asText()) .orElseThrow( () -> new AuthenticationException( "Invalid JWT token, none of the following claims are present " + jwtPrincipalClaims));
    String userName;
    String domain;
    if (jwtClaim.contains("@")) {
      userName = jwtClaim.split("@")[0];
      domain = jwtClaim.split("@")[1];
    }
     else {
      userName = jwtClaim;
      domain = StringUtils.EMPTY;
    }
    
    if (enforcePrincipalDomain && !domain.equals(principalDomain)) {
      throw new AuthenticationException( String.format( "Not Authorized! Email does not match the principal domain %s", principalDomain));
    }
    
    return userName;
  }
  
  protected static String extractToken(MultivaluedMap<String, String> headers) {
    LOG.debug("Request Headers:{}", headers);
    String source = headers.getFirst(AUTHORIZATION_HEADER);
    if (nullOrEmpty(source)) {
      throw AuthenticationException.getTokenNotPresentException();
    }
    
    if (source.startsWith(TOKEN_PREFIX)) {
      return source.substring(TOKEN_PREFIX.length() + 1);
    }
    
    throw AuthenticationException.getTokenNotPresentException();
  }
  
  public static String extractToken(String tokenFromHeader) {
    LOG.debug("Request Token:{}", tokenFromHeader);
    if (nullOrEmpty(tokenFromHeader)) {
      throw AuthenticationException.getTokenNotPresentException();
    }
    
    if (tokenFromHeader.startsWith(TOKEN_PREFIX)) {
      return tokenFromHeader.substring(TOKEN_PREFIX.length() + 1);
    }
    
    throw AuthenticationException.getTokenNotPresentException();
  }
  
  private void validateBotToken(String tokenFromHeader, String userName) {
    if (tokenFromHeader.equals(BotTokenCache.getToken(userName))) {
      return;
    }
    
    throw AuthenticationException.getInvalidTokenException();
  }
  
  private void validatePersonalAccessToken(String tokenFromHeader, String userName) {
    if (UserTokenCache.getToken(userName).contains(tokenFromHeader)) {
      return;
    }
    
    throw AuthenticationException.getInvalidTokenException();
  }
  
  private void validateTokenIsNotUsedAfterLogout(String authToken) {
    LogoutRequest previouslyLoggedOutEvent = JwtTokenCacheManager.getInstance().getLogoutEventForToken(authToken);
    if (previouslyLoggedOutEvent != null) {
      throw new AuthenticationException("Expired token!");
    }
    
  }
  
}


