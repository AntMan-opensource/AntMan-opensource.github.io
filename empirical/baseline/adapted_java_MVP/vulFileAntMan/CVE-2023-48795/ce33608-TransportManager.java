package com.trilead.ssh2.transport;
import com.trilead.ssh2.ExtensionInfo;
import com.trilead.ssh2.packets.PacketExtInfo;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.security.SecureRandom;
import java.util.Vector;
import com.trilead.ssh2.ConnectionInfo;
import com.trilead.ssh2.ConnectionMonitor;
import com.trilead.ssh2.DHGexParameters;
import com.trilead.ssh2.ProxyData;
import com.trilead.ssh2.ServerHostKeyVerifier;
import com.trilead.ssh2.compression.ICompressor;
import com.trilead.ssh2.crypto.CryptoWishList;
import com.trilead.ssh2.crypto.cipher.BlockCipher;
import com.trilead.ssh2.crypto.digest.MAC;
import com.trilead.ssh2.log.Logger;
import com.trilead.ssh2.packets.PacketDisconnect;
import com.trilead.ssh2.packets.Packets;
import com.trilead.ssh2.packets.TypesReader;
public class TransportManager {
	private static final Logger log = Logger.getLogger(TransportManager.class);
	class HandlerEntry {
		MessageHandler mh;
		int low;
		int high;
	}
	
	private final Vector<byte[]> asynchronousQueue = new Vector<byte[]>();
	private Thread asynchronousThread = null;
	class AsynchronousWorker extends Thread {
		public void run() {
			while (true){
				byte[] msg;
				synchronized (asynchronousQueue) {
					if (asynchronousQueue.size() == 0){
						 try {
							asynchronousQueue.wait(2000);
						}
						
						catch (InterruptedException e) {
							 }
							 
						if (asynchronousQueue.size() == 0){
							asynchronousThread = null;
							return;
						}
						
					}
					
					msg = asynchronousQueue.remove(0);
				}
				
				 try {
					sendMessage(msg);
				}
				
				catch (IOException e) {
					return;
				}
				
			}
			
		}
		
	}
	
	String hostname;
	int port;
	Socket sock;
	Object connectionSemaphore = new Object();
	boolean flagKexOngoing = false;
	boolean connectionClosed = false;
	Throwable reasonClosedCause = null;
	TransportConnection tc;
	KexManager km;
	Vector<HandlerEntry> messageHandlers = new Vector<HandlerEntry>();
	Thread receiveThread;
	Vector connectionMonitors = new Vector();
	boolean monitorsWereInformed = false;
	private volatile ExtensionInfo extensionInfo = ExtensionInfo.noExtInfoSeen();
	public TransportManager(String host, int port) {
		this.hostname = host;
		this.port = port;
	}
	
	public int getPacketOverheadEstimate() {
		return tc.getPacketOverheadEstimate();
	}
	
	public ConnectionInfo getConnectionInfo(int kexNumber) throws IOException {
		return km.getOrWaitForConnectionInfo(kexNumber);
	}
	
	public ExtensionInfo getExtensionInfo() {
		return extensionInfo;
	}
	
	public Throwable getReasonClosedCause() {
		synchronized (connectionSemaphore) {
			return reasonClosedCause;
		}
		
	}
	
	public byte[] getSessionIdentifier() {
		return km.sessionId;
	}
	
	public void close(Throwable cause, boolean useDisconnectPacket) {
		if (!useDisconnectPacket){
			 try {
				if (sock != null){
					sock.close();
}
			}
			
			catch (IOException ignore) {
			}
			
			 }
			 
		synchronized (connectionSemaphore) {
			if (!connectionClosed){
				if (useDisconnectPacket){
					try {
						byte[] msg = new PacketDisconnect(Packets.SSH_DISCONNECT_BY_APPLICATION, cause.getMessage(), "") .getPayload();
						if (tc != null){
							tc.sendMessage(msg);
}
					}
					
					catch (IOException ignore) {
					}
					
					try {
						if (sock != null){
							sock.close();
}
					}
					
					catch (IOException ignore) {
					}
					
				}
				
				connectionClosed = true;
				reasonClosedCause = cause; 
			}
			
			connectionSemaphore.notifyAll();
		}
		
		 Vector monitors = null;
		synchronized (this) {
			 if (!monitorsWereInformed){
				monitorsWereInformed = true;
				monitors = (Vector) connectionMonitors.clone();
			}
			
		}
		
		if (monitors != null){
			for (int i = 0; i < monitors.size(); i++){
				try {
					ConnectionMonitor cmon = (ConnectionMonitor) monitors.elementAt(i);
					cmon.connectionLost(reasonClosedCause);
				}
				
				catch (Exception ignore) {
				}
				
			}
			
		}
		
	}
	
	private void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException {
		if (proxyData == null){
			sock = connectDirect(hostname, port, connectTimeout);
}
		else{
			sock = proxyData.openConnection(hostname, port, connectTimeout);
}
	}
	
	private static Socket connectDirect(String hostname, int port, int connectTimeout) throws IOException {
		Socket sock = new Socket();
		InetAddress addr = InetAddress.getByName(hostname);
		sock.connect(new InetSocketAddress(addr, port), connectTimeout);
		sock.setSoTimeout(0);
		return sock;
	}
	
	public void initialize(CryptoWishList cwl, ServerHostKeyVerifier verifier, DHGexParameters dhgex, int connectTimeout, SecureRandom rnd, ProxyData proxyData) throws IOException {
		 establishConnection(proxyData, connectTimeout);
		 ClientServerHello csh = new ClientServerHello(sock.getInputStream(), sock.getOutputStream());
		tc = new TransportConnection(sock.getInputStream(), sock.getOutputStream(), rnd);
		km = new KexManager(this, csh, cwl, hostname, port, verifier, rnd);
		km.initiateKEX(cwl, dhgex);
		receiveThread = new Thread(new Runnable() { 			public void run() { try { receiveLoop();
				}
				
				catch (IOException e) {
					close(e, false);
					if (log.isEnabled()){
						log.log(10, "Receive thread: error in receiveLoop: " + e.getMessage());
}
				}
				
				if (log.isEnabled()){
					log.log(50, "Receive thread: back from receiveLoop");
}
				 if (km != null){
					try {
						km.handleMessage(null, 0);
					}
					
					catch (IOException e) {
					}
					
				}
				
				for (int i = 0; i < messageHandlers.size(); i++){
					HandlerEntry he = messageHandlers.elementAt(i);
					try {
						he.mh.handleMessage(null, 0);
					}
					
					catch (Exception ignore) {
					}
					
				}
				
			}
			
		}
		
);
		receiveThread.setDaemon(true);
		receiveThread.start();
	}
	
	public void registerMessageHandler(MessageHandler mh, int low, int high) {
		HandlerEntry he = new HandlerEntry();
		he.mh = mh;
		he.low = low;
		he.high = high;
		synchronized (messageHandlers) {
			messageHandlers.addElement(he);
		}
		
	}
	
	public void removeMessageHandler(MessageHandler mh, int low, int high) {
		synchronized (messageHandlers) {
			for (int i = 0; i < messageHandlers.size(); i++){
				HandlerEntry he = messageHandlers.elementAt(i);
				if ((he.mh == mh) && (he.low == low) && (he.high == high)){
					messageHandlers.removeElementAt(i);
					break;
				}
				
			}
			
		}
		
	}
	
	public void sendKexMessage(byte[] msg) throws IOException {
		synchronized (connectionSemaphore) {
			if (connectionClosed){
				throw new IOException("Sorry, this connection is closed.", reasonClosedCause);
			}
			
			flagKexOngoing = true;
			try {
				tc.sendMessage(msg);
			}
			
			catch (IOException e) {
				close(e, false);
				throw e;
			}
			
		}
		
	}
	
	public void kexFinished() {
		synchronized (connectionSemaphore) {
			flagKexOngoing = false;
			connectionSemaphore.notifyAll();
		}
		
	}
	
	public void forceKeyExchange(CryptoWishList cwl, DHGexParameters dhgex) throws IOException {
		km.initiateKEX(cwl, dhgex);
	}
	
	public void changeRecvCipher(BlockCipher bc, MAC mac) {
		tc.changeRecvCipher(bc, mac);
	}
	
	public void changeSendCipher(BlockCipher bc, MAC mac) {
		tc.changeSendCipher(bc, mac);
	}
	
	 public void changeRecvCompression(ICompressor comp) {
		tc.changeRecvCompression(comp);
	}
	
	 public void changeSendCompression(ICompressor comp) {
		tc.changeSendCompression(comp);
	}
	
	 public void startCompression() {
		tc.startCompression();
	}
	
	public void sendAsynchronousMessage(byte[] msg) throws IOException {
		synchronized (asynchronousQueue) {
			asynchronousQueue.addElement(msg);
			 if (asynchronousQueue.size() > 100){
				throw new IOException("Error: the peer is not consuming our asynchronous replies.");
}
			 if (asynchronousThread == null){
				asynchronousThread = new AsynchronousWorker();
				asynchronousThread.setDaemon(true);
				asynchronousThread.start();
				 }
				 
		}
		
	}
	
	public void setConnectionMonitors(Vector monitors) {
		synchronized (this) {
			connectionMonitors = (Vector) monitors.clone();
		}
		
	}
	
	public void sendMessage(byte[] msg) throws IOException {
		if (Thread.currentThread() == receiveThread){
			throw new IOException("Assertion error: sendMessage may never be invoked by the receiver thread!");
}
		synchronized (connectionSemaphore) {
			while (true){
				if (connectionClosed){
					throw new IOException("Sorry, this connection is closed.", reasonClosedCause);
				}
				
				if (!flagKexOngoing){
					break;
}
				try {
					connectionSemaphore.wait();
				}
				
				catch (InterruptedException e) {
				}
				
			}
			
			try {
				tc.sendMessage(msg);
			}
			
			catch (IOException e) {
				close(e, false);
				throw e;
			}
			
		}
		
	}
	
	public void receiveLoop() throws IOException {
		byte[] msg = new byte[35004];
		while (true){
			int msglen = tc.receiveMessage(msg, 0, msg.length);
			int type = msg[0] & 0xff;
			if (type == Packets.SSH_MSG_IGNORE){
				continue;
}
			if (type == Packets.SSH_MSG_DEBUG){
				if (log.isEnabled()){
					TypesReader tr = new TypesReader(msg, 0, msglen);
					tr.readByte();
					tr.readBoolean();
					StringBuffer debugMessageBuffer = new StringBuffer();
					debugMessageBuffer.append(tr.readString("UTF-8"));
					for (int i = 0; i < debugMessageBuffer.length(); i++){
						char c = debugMessageBuffer.charAt(i);
						if ((c >= 32) && (c <= 126)){
							continue;
}
						debugMessageBuffer.setCharAt(i, '\uFFFD');
					}
					
					log.log(50, "DEBUG Message from remote: '" + debugMessageBuffer.toString() + "'");
				}
				
				continue;
			}
			
			if (type == Packets.SSH_MSG_UNIMPLEMENTED){
				throw new IOException("Peer sent UNIMPLEMENTED message, that should not happen.");
			}
			
			if (type == Packets.SSH_MSG_DISCONNECT){
				TypesReader tr = new TypesReader(msg, 0, msglen);
				tr.readByte();
				int reason_code = tr.readUINT32();
				StringBuffer reasonBuffer = new StringBuffer();
				reasonBuffer.append(tr.readString("UTF-8"));
				 if (reasonBuffer.length() > 255){
					reasonBuffer.setLength(255);
					reasonBuffer.setCharAt(254, '.');
					reasonBuffer.setCharAt(253, '.');
					reasonBuffer.setCharAt(252, '.');
				}
				
				 for (int i = 0; i < reasonBuffer.length(); i++){
					char c = reasonBuffer.charAt(i);
					if ((c >= 32) && (c <= 126)){
						continue;
}
					reasonBuffer.setCharAt(i, '\uFFFD');
				}
				
				throw new IOException("Peer sent DISCONNECT message (reason code " + reason_code + "): " + reasonBuffer.toString());
			}
			
			 if ((type == Packets.SSH_MSG_KEXINIT) || (type == Packets.SSH_MSG_NEWKEYS) || ((type >= 30) && (type <= 49))){
				km.handleMessage(msg, msglen);
				continue;
			}
			
			if (type == Packets.SSH_MSG_USERAUTH_SUCCESS) {
				tc.startCompression();
			}
			
			if (type == Packets.SSH_MSG_EXT_INFO) {
				 extensionInfo = ExtensionInfo.fromPacketExtInfo( new PacketExtInfo(msg, 0, msglen));
				continue;
			}
			
			MessageHandler mh = null;
			for (int i = 0; i < messageHandlers.size(); i++){
				HandlerEntry he = messageHandlers.elementAt(i);
				if ((he.low <= type) && (type <= he.high)){
					mh = he.mh;
					break;
				}
				
			}
			
			if (mh == null){
				throw new IOException("Unexpected SSH message (type " + type + ")");
}
			mh.handleMessage(msg, msglen);
		}
		
	}
	
}


