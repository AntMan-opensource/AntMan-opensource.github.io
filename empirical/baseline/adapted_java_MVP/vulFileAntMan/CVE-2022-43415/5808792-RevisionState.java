package hudson.plugins.repo;
import hudson.Util;
import hudson.scm.SCMRevisionState;
import java.io.PrintStream;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.Nullable;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
@SuppressWarnings("serial")
class RevisionState extends SCMRevisionState implements Serializable {
	private final String manifest;
	private final Map<String, ProjectState> projects = new TreeMap<String, ProjectState>();
	private final String url;
	private final String branch;
	private final String file;
	private static Logger debug = Logger.getLogger("hudson.plugins.repo.RevisionState");
	 RevisionState(final String manifest, final String manifestRevision, final String url, final String branch, final String file, @Nullable final PrintStream logger) {
		this.manifest = manifest;
		this.url = url;
		this.branch = branch;
		this.file = file;
		try {
			final InputSource xmlSource = new InputSource();
			xmlSource.setCharacterStream(new StringReader(manifest));
			final Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder() .parse(xmlSource);
			if (!doc.getDocumentElement().getNodeName().equals("manifest")) {
				if (logger != null) {
					logger.println("Error - malformed manifest");
				}
				
				return;
			}
			
			final NodeList projectNodes = doc.getElementsByTagName("project");
			final int numProjects = projectNodes.getLength();
			for (int i = 0; i < numProjects; i++) {
				final Element projectElement = (Element) projectNodes.item(i);
				String path = Util.fixEmptyAndTrim(projectElement .getAttribute("path"));
				final String serverPath = Util.fixEmptyAndTrim(projectElement .getAttribute("name"));
				final String revision = Util.fixEmptyAndTrim(projectElement .getAttribute("revision"));
				if (path == null) {
					 path = serverPath;
				}
				
				if (path != null && serverPath != null && revision != null) {
					projects.put(path, ProjectState.constructCachedInstance( path, serverPath, revision));
					if (logger != null) {
						logger.println("Added a project: " + path + " at revision: " + revision);
					}
					
				}
				
			}
			
            final String manifestP = ".repo/manifests.git";
            projects.put(manifestP, ProjectState.constructCachedInstance( manifestP, manifestP, manifestRevision));
            if (logger != null) {
                logger.println("Manifest at revision: " + manifestRevision);
            }
            
		}
		 catch (final Exception e) {
			if (logger != null) {
				logger.println(e);
			}
			
		}
		
	}
	
	public boolean equals(final Object obj) {
		if (obj instanceof RevisionState) {
			final RevisionState other = (RevisionState) obj;
			if (branch == null) {
				if (other.branch != null) {
					return false;
				}
				
				return projects.equals(other.projects);
			}
			
			return branch.equals(other.branch) && projects.equals(other.projects);
		}
		
		return super.equals(obj);
	}
	
	public int hashCode() {
		return (branch != null ? branch.hashCode() : 0) ^ (url != null ? url.hashCode() : 0) ^ (file != null ? file.hashCode() : 0) ^ (manifest != null ? manifest.hashCode() : 0) ^ projects.hashCode();
	}
	
	 public String getUrl() {
		return url;
	}
	
	 public String getBranch() {
		return branch;
	}
	
	 public String getFile() {
		return file;
	}
	
	 public String getManifest() {
		return manifest;
	}
	
	 public String getRevision(final String path) {
		ProjectState project = projects.get(path);
		return project == null ? null : project.getRevision();
	}
	
	 List<ProjectState> whatChanged(@Nullable final RevisionState previousState) {
		final List<ProjectState> changes = new ArrayList<ProjectState>();
		if (previousState == null) {
			 debug.log(Level.FINE, "Everything is new");
			return null;
		}
		
		 HashMap<String, ProjectState> previousStateCopy = new HashMap<String, ProjectState>(previousState.projects);
		for (final Map.Entry<String, ProjectState> entry : projects.entrySet()) {
			final ProjectState status = previousStateCopy.get(entry.getKey());
			if (status == null) {
				 final ProjectState newProject = entry.getValue();
				debug.log(Level.FINE, "New project: {0}", entry.getKey());
				changes.add(ProjectState.constructCachedInstance( newProject.getPath(), newProject.getServerPath(), null));
			}
			 else if (!status.equals(entry.getValue())) {
				changes.add(previousStateCopy.get(entry.getKey()));
			}
			
			previousStateCopy.remove(entry.getKey());
		}
		
		changes.addAll(previousStateCopy.values());
		return changes;
	}
	
}


