package org.apache.james.mailbox.maildir;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Properties;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.james.mailbox.MailboxPathLocker;
import org.apache.james.mailbox.MailboxPathLocker.LockAwareExecution;
import org.apache.james.mailbox.MailboxSession;
import org.apache.james.mailbox.MessageUid;
import org.apache.james.mailbox.ModSeq;
import org.apache.james.mailbox.exception.MailboxException;
import org.apache.james.mailbox.model.MailboxACL;
import org.apache.james.mailbox.model.MailboxACL.EntryKey;
import org.apache.james.mailbox.model.MailboxACL.Rfc4314Rights;
import org.apache.james.mailbox.model.MailboxPath;
import org.apache.james.mailbox.model.UidValidity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class MaildirFolder {
    private static final Logger LOGGER = LoggerFactory.getLogger(MaildirFolder.class);
    public static final String VALIDITY_FILE = "james-uidvalidity";
    public static final String UIDLIST_FILE = "james-uidlist";
    public static final String ACL_FILE = "james-acl";
    public static final String MAILBOX_ID_FILE = "james-mailboxId";
    public static final String CUR = "cur";
    public static final String NEW = "new";
    public static final String TMP = "tmp";
    private final File rootFolder;
    private final File curFolder;
    private final File newFolder;
    private final File tmpFolder;
    private final File uidFile;
    private final File aclFile;
    private final File mailboxIdFile;
    private Optional<MessageUid> lastUid;
    private int messageCount = 0;
    private Optional<UidValidity> uidValidity = Optional.empty();
    private MailboxACL acl;
    private boolean messageNameStrictParse = false;
    private final MailboxPathLocker locker;
    private final MailboxPath path;
    public MaildirFolder(String absPath, MailboxPath path, MailboxPathLocker locker) {
        this.rootFolder = new File(absPath);
        this.curFolder = new File(rootFolder, CUR);
        this.newFolder = new File(rootFolder, NEW);
        this.tmpFolder = new File(rootFolder, TMP);
        this.uidFile = new File(rootFolder, UIDLIST_FILE);
        this.aclFile = new File(rootFolder, ACL_FILE);
        this.mailboxIdFile = new File(rootFolder, MAILBOX_ID_FILE);
        this.locker = locker;
        this.path = path;
        this.lastUid = Optional.empty();
    }
    
    private MaildirMessageName newMaildirMessageName(MaildirFolder folder, String fullName) {
        MaildirMessageName mdn = new MaildirMessageName(folder, fullName);
        mdn.setMessageNameStrictParse(isMessageNameStrictParse());
        return mdn;
    }
    
    public boolean isMessageNameStrictParse() {
        return messageNameStrictParse;
    }
    
    public void setMessageNameStrictParse(boolean messageNameStrictParse) {
        this.messageNameStrictParse = messageNameStrictParse;
    }
    
    public File getRootFile() {
        return rootFolder;
    }
    
    public boolean exists() {
        return rootFolder.isDirectory() && curFolder.isDirectory() && newFolder.isDirectory() && tmpFolder.isDirectory();
    }
    
    private boolean isModified() {
        long uidListModified = uidFile.lastModified();
        long curModified = curFolder.lastModified();
        long newModified = newFolder.lastModified();
        if (curModified >= uidListModified || newModified >= uidListModified) {
            return true;
        }
        
        return false;
    }
    
    public File getCurFolder() {
        return curFolder;
    }
    
    public File getMailboxIdFile() {
        return mailboxIdFile;
    }
    
    public File getNewFolder() {
        return newFolder;
    }
    
    public File getTmpFolder() {
        return tmpFolder;
    }
    
    private MessageUid getNextUid() {
        MessageUid nextUid = lastUid.map(MessageUid::next).orElse(MessageUid.MIN_VALUE);
        lastUid = Optional.of(nextUid);
        return nextUid;
    }
    
    public Optional<MessageUid> getLastUid() throws MailboxException {
        if (!lastUid.isPresent()) {
            readLastUid();
        }
        
        return lastUid;
    }
    
    public ModSeq getHighestModSeq() throws IOException {
        long newModified = getNewFolder().lastModified();
        long curModified = getCurFolder().lastModified();
        if (newModified  == 0L && curModified == 0L) {
            throw new IOException("Unable to read highest modSeq");
        }
        
        return ModSeq.of(Math.max(newModified, curModified));
    }
    
    private void readLastUid() throws MailboxException {
        locker.executeWithLock(path, (LockAwareExecution<Void>) () -> {
            File uidList = uidFile;
            if (!uidList.exists()) {
                createUidFile();
            }
            
            try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                String line = reader.readLine();
                if (line != null) {
                    readUidListHeader(line);
                }
                
                return null;
            }
             catch (IOException e) {
                throw new MailboxException("Unable to read last uid", e);
            }
            
        }, MailboxPathLocker.LockType.Write);
    }
    
    public UidValidity getUidValidity() throws IOException {
        if (!uidValidity.isPresent()) {
            uidValidity = Optional.of(readUidValidity());
        }
        
        return uidValidity.get();
    }
    
    public void setUidValidity(UidValidity uidValidity) throws IOException {
        saveUidValidity(uidValidity);
        this.uidValidity = Optional.of(uidValidity);
    }
    
    private UidValidity readUidValidity() throws IOException {
        File validityFile = new File(rootFolder, VALIDITY_FILE);
        if (!validityFile.exists()) {
            return resetUidValidity();
        }
        
        try (FileInputStream fis = new FileInputStream(validityFile); InputStreamReader isr = new InputStreamReader(fis)) {
            char[] uidValidity = new char[20];
            int len = isr.read(uidValidity);
            long uidValidityValue = Long.parseLong(String.valueOf(uidValidity, 0, len).trim());
            return sanitizeUidValidity(uidValidityValue);
        }
        
    }
    
    private UidValidity sanitizeUidValidity(long uidValidityValue) throws IOException {
        if (!UidValidity.isValid(uidValidityValue)) {
            return resetUidValidity();
        }
        
        return UidValidity.of(uidValidityValue);
    }
    
    private void saveUidValidity(UidValidity uidValidity) throws IOException {
        File validityFile = new File(rootFolder, VALIDITY_FILE);
        if (!validityFile.createNewFile()) {
            throw new IOException("Could not create file " + validityFile);
        }
        
        try (FileOutputStream fos = new FileOutputStream(validityFile)) {
            fos.write(String.valueOf(uidValidity.asLong()).getBytes());
        }
        
    }
    
    public void setMailboxId(MaildirId mailboxId) throws IOException {
        saveMailboxId(mailboxId);
    }
    
    public MaildirId readMailboxId() throws IOException {
        if (!mailboxIdFile.exists()) {
            MaildirId maildirId = MaildirId.random();
            saveMailboxId(maildirId);
            return maildirId;
        }
        
        try (FileInputStream fileInputStream = new FileInputStream(mailboxIdFile)) {
            String serializedMaildirId = IOUtils.toString(fileInputStream, StandardCharsets.UTF_8);
            return MaildirId.fromString(serializedMaildirId);
        }
        
    }
    
    private void saveMailboxId(MaildirId id) throws IOException {
        if (!mailboxIdFile.createNewFile()) {
            throw new IOException("Could not create file " + mailboxIdFile);
        }
        
        try (FileOutputStream fos = new FileOutputStream(mailboxIdFile)) {
            fos.write(id.serialize().getBytes(StandardCharsets.UTF_8));
        }
        
    }
    
    private UidValidity resetUidValidity() throws IOException {
        UidValidity uidValidity = UidValidity.generate();
        setUidValidity(uidValidity);
        return uidValidity;
    }
    
    public MaildirMessageName getMessageNameByUid(final MessageUid uid) throws MailboxException {
        return locker.executeWithLock(path, () -> {
            File uidList = uidFile;
            try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                String uidString = String.valueOf(uid.asLong());
                String line = reader.readLine(); 
                int lineNumber = 1; 
                while ((line = reader.readLine()) != null) {
                    lineNumber++;
                    if (!line.equals("")) {
                        int gap = line.indexOf(" ");
                        if (gap == -1) {
                            LOGGER.info("Corrupted entry in uid-file {} line {}", uidList, lineNumber);
                            continue;
                        }
                        
                        if (line.substring(0, gap).equals(uidString)) {
                            return newMaildirMessageName(MaildirFolder.this, line.substring(gap + 1));
                        }
                        
                    }
                    
                }
                
                return null;
            }
             catch (IOException e) {
                throw new MailboxException("Unable to read messagename for uid " + uid, e);
            }
            
        }, MailboxPathLocker.LockType.Write);
    }
    
    public SortedMap<MessageUid, MaildirMessageName> getUidMap(final MessageUid from, final MessageUid to) throws MailboxException {
        return locker.executeWithLock(path, () -> {
            final SortedMap<MessageUid, MaildirMessageName> uidMap = new TreeMap<>();
            File uidList = uidFile;
            if (uidList.isFile()) {
                if (isModified()) {
                    try {
                        uidMap.putAll(truncateMap(updateUidFile(), from, to));
                    }
                     catch (MailboxException e) {
                        uidMap.putAll(truncateMap(createUidFile(), from, to));
                    }
                    
                }
                 else {
                    uidMap.putAll(readUidFile(from, to));
                }
                
            }
             else {
                uidMap.putAll(truncateMap(createUidFile(), from, to));
            }
            
            return uidMap;
        }, MailboxPathLocker.LockType.Write);
    }
    
    public SortedMap<MessageUid, MaildirMessageName> getUidMap(MailboxSession session, FilenameFilter filter, MessageUid from, MessageUid to) throws MailboxException {
        SortedMap<MessageUid, MaildirMessageName> allUids = getUidMap(from, to);
        SortedMap<MessageUid, MaildirMessageName> filteredUids = new TreeMap<>();
        for (Entry<MessageUid, MaildirMessageName> entry : allUids.entrySet()) {
            if (filter.accept(null, entry.getValue().getFullName())) {
                filteredUids.put(entry.getKey(), entry.getValue());
            }
            
        }
        
        return filteredUids;
    }
    
    public SortedMap<MessageUid, MaildirMessageName> getUidMap(FilenameFilter filter, int limit) throws MailboxException {
        MessageUid to = null;
        SortedMap<MessageUid, MaildirMessageName> allUids = getUidMap(MessageUid.MIN_VALUE, to);
        SortedMap<MessageUid, MaildirMessageName> filteredUids = new TreeMap<>();
        int theLimit = limit;
        if (limit < 1) {
            theLimit = allUids.size();
        }
        
        int counter = 0;
        for (Entry<MessageUid, MaildirMessageName> entry : allUids.entrySet()) {
            if (counter >= theLimit) {
                break;
            }
            
            if (filter.accept(null, entry.getValue().getFullName())) {
                filteredUids.put(entry.getKey(), entry.getValue());
                counter++;
            }
            
        }
        
        return filteredUids;
    }
    
    public SortedMap<MessageUid, MaildirMessageName> getRecentMessages() throws MailboxException {
        final String[] recentFiles = getNewFolder().list();
        final LinkedList<String> lines = new LinkedList<>();
        final int theLimit = recentFiles.length;
        return locker.executeWithLock(path, () -> {
            final SortedMap<MessageUid, MaildirMessageName> recentMessages = new TreeMap<>();
            File uidList = uidFile;
            try {
                if (!uidList.isFile()) {
                    if (!uidList.createNewFile()) {
                        throw new IOException("Could not create file " + uidList);
                    }
                    
                    String[] curFiles = curFolder.list();
                    String[] newFiles = newFolder.list();
                    messageCount = curFiles.length + newFiles.length;
                    String[] allFiles = ArrayUtils.addAll(curFiles, newFiles);
                    for (String file : allFiles) {
                        lines.add(String.valueOf(getNextUid().asLong()) + " " + file);
                    }
                    
                    try (PrintWriter pw = new PrintWriter(uidList)) {
                        pw.println(createUidListHeader());
                        for (String line : lines) {
                            pw.println(line);
                        }
                        
                    }
                    
                }
                 else {
                    try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                            reader.readLine();
                            String line;
                            while ((line = reader.readLine()) != null) {
                                lines.add(line);
                            }
                            
                        }
                        
                }
                
                int counter = 0;
                String line;
                while (counter < theLimit) {
                    try {
                        line = lines.removeLast();
                    }
                     catch (NoSuchElementException e) {
                        break; 
                    }
                    
                    if (!line.equals("")) {
                        int gap = line.indexOf(" ");
                        if (gap == -1) {
                            LOGGER.info("Corrupted entry in uid-file {} line {}", uidList, lines.size());
                            continue;
                        }
                        
                        MessageUid uid = MessageUid.of(Long.parseLong(line.substring(0, gap)));
                        String name = line.substring(gap + 1);
                        for (String recentFile : recentFiles) {
                            if (recentFile.equals(name)) {
                                recentMessages.put(uid, newMaildirMessageName(MaildirFolder.this, recentFile));
                                counter++;
                                break;
                            }
                            
                        }
                        
                    }
                    
                }
                
            }
             catch (IOException e) {
                throw new MailboxException("Unable to read recent messages", e);
            }
            
            return recentMessages;
        }, MailboxPathLocker.LockType.Write);
    }
    
    private Map<MessageUid, MaildirMessageName> createUidFile() throws MailboxException {
        final Map<MessageUid, MaildirMessageName> uidMap = new TreeMap<>();
        File uidList = uidFile;
        try {
            if (!uidList.createNewFile()) {
                throw new IOException("Could not create file " + uidList);
            }
            
            lastUid = Optional.empty();
            String[] curFiles = curFolder.list();
            String[] newFiles = newFolder.list();
            messageCount = curFiles.length + newFiles.length;
            String[] allFiles = (String[]) ArrayUtils.addAll(curFiles, newFiles);
            for (String file : allFiles) {
                uidMap.put(getNextUid(), newMaildirMessageName(MaildirFolder.this, file));
            }
            
            try (PrintWriter pw = new PrintWriter(uidList)) {
                pw.println(createUidListHeader());
                for (Entry<MessageUid, MaildirMessageName> entry : uidMap.entrySet()) {
                    pw.println(String.valueOf(entry.getKey().asLong()) + " " + entry.getValue().getFullName());
                }
                
            }
            
        }
         catch (IOException e) {
            throw new MailboxException("Unable to create uid file", e);
        }
        
        return uidMap;
    }
    
    private Map<MessageUid, MaildirMessageName> updateUidFile() throws MailboxException {
        final Map<MessageUid, MaildirMessageName> uidMap = new TreeMap<>();
        File uidList = uidFile;
        String[] curFiles = curFolder.list();
        String[] newFiles = newFolder.list();
        messageCount = curFiles.length + newFiles.length;
        HashMap<String, MessageUid> reverseUidMap = new HashMap<>(messageCount);
        try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
            String line = reader.readLine();
            if (line != null) {
                readUidListHeader(line);
            }
            
            int lineNumber = 1; 
            while ((line = reader.readLine()) != null) {
                lineNumber++;
                if (!line.equals("")) {
                    int gap = line.indexOf(" ");
                    if (gap == -1) {
                        throw new MailboxException("Corrupted entry in uid-file " + uidList + " line " + lineNumber);
                    }
                    
                    MessageUid uid = MessageUid.of(Long.parseLong(line.substring(0, gap)));
                    String name = line.substring(gap + 1);
                    reverseUidMap.put(stripMetaFromName(name), uid);
                }
                
            }
            
            String[] allFiles = (String[]) ArrayUtils.addAll(curFiles, newFiles);
            for (String file : allFiles) {
                MaildirMessageName messageName = newMaildirMessageName(MaildirFolder.this, file);
                MessageUid uid = reverseUidMap.get(messageName.getBaseName());
                if (uid == null) {
                    uid = getNextUid();
                }
                
                uidMap.put(uid, messageName);
            }
            
            try (PrintWriter pw = new PrintWriter(uidList)) {
                pw.println(createUidListHeader());
                for (Entry<MessageUid, MaildirMessageName> entry : uidMap.entrySet()) {
                    pw.println(String.valueOf(entry.getKey().asLong()) + " " + entry.getValue().getFullName());
                }
                
            }
            
        }
         catch (IOException e) {
            throw new MailboxException("Unable to update uid file", e);
        }
        
        return uidMap;
    }
    
    private Map<MessageUid, MaildirMessageName> readUidFile(MessageUid from, MessageUid to) throws MailboxException {
        final Map<MessageUid, MaildirMessageName> uidMap = new HashMap<>();
        File uidList = uidFile;
        try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
            String line = reader.readLine();
            if (line != null) {
                readUidListHeader(line);
            }
            
            int lineNumber = 1; 
            while ((line = reader.readLine()) != null) {
                lineNumber++;
                if (!line.equals("")) {
                    int gap = line.indexOf(" ");
                    if (gap == -1) {
                        LOGGER.info("Corrupted entry in uid-file {} line {}", uidList, lineNumber);
                        continue;
                    }
                    
                    MessageUid uid = MessageUid.of(Long.parseLong(line.substring(0, gap)));
                    if (uid.compareTo(from) >= 0) {
                        if (to != null && uid.compareTo(to) > 0) {
                            break;
                        }
                        
                        String name = line.substring(gap + 1);
                        uidMap.put(uid, newMaildirMessageName(MaildirFolder.this, name));
                    }
                    
                }
                
            }
            
        }
         catch (IOException e) {
            throw new MailboxException("Unable to read uid file", e);
        }
        
        messageCount = uidMap.size();
        return uidMap;
    }
    
    private SortedMap<MessageUid, MaildirMessageName> truncateMap(Map<MessageUid, MaildirMessageName> map, MessageUid from, MessageUid to) {
        TreeMap<MessageUid, MaildirMessageName> sortedMap;
        if (map instanceof TreeMap<?, ?>) {
            sortedMap = (TreeMap<MessageUid, MaildirMessageName>) map;
        }
         else {
            sortedMap = new TreeMap<>(map);
        }
        
        if (to != null) {
            return sortedMap.subMap(from, to.next());
        }
        
        return sortedMap.tailMap(from);
    }
    
    private void readUidListHeader(String line) throws IOException {
        if (line == null) {
            throw new IOException("Header entry in uid-file is null");
        }
        
        int gap1 = line.indexOf(" ");
        if (gap1 == -1) {
            throw new IOException("Corrupted header entry in uid-file");
        }
        
        int version = Integer.parseInt(line.substring(0, gap1));
        if (version != 1) {
            throw new IOException("Cannot read uidlists with versions other than 1.");
        }
        
        int gap2 = line.indexOf(" ", gap1 + 1);
        lastUid = Optional.of(MessageUid.of(Long.parseLong(line.substring(gap1 + 1, gap2))));
        messageCount = Integer.parseInt(line.substring(gap2 + 1));
    }
    
    private String createUidListHeader() {
        Long last = lastUid.map(MessageUid::asLong).orElse(0L);
        return "1 " + String.valueOf(last) + " " + String.valueOf(messageCount);
    }
    
    public static String stripMetaFromName(String fileName) {
        int end = fileName.indexOf(",S="); 
        if (end == -1) {
            end = fileName.indexOf(":2,"); 
        }
        
        if (end == -1) {
            return fileName; 
        }
        
        return fileName.substring(0, end);
    }
    
    public MessageUid appendMessage(final String name) throws MailboxException {
        return locker.executeWithLock(path, () -> {
            File uidList = uidFile;
            MessageUid uid = null;
            try {
                if (uidList.isFile()) {
                    try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                        String line = reader.readLine();
                        if (line != null) {
                            readUidListHeader(line);
                        }
                        
                        ArrayList<String> lines = new ArrayList<>();
                        while ((line = reader.readLine()) != null) {
                            lines.add(line);
                        }
                        
                        uid = getNextUid();
                        lines.add(String.valueOf(uid.asLong()) + " " + name);
                        messageCount++;
                        try (PrintWriter pw = new PrintWriter(uidList)) {
                            pw.println(createUidListHeader());
                            for (String entry : lines) {
                                pw.println(entry);
                            }
                            
                        }
                        
                    }
                    
                }
                 else {
                    if (!uidList.createNewFile()) {
                        throw new IOException("Could not create file " + uidList);
                    }
                    
                    String[] curFiles = curFolder.list();
                    String[] newFiles = newFolder.list();
                    messageCount = curFiles.length + newFiles.length;
                    ArrayList<String> lines = new ArrayList<>();
                    String[] allFiles = (String[]) ArrayUtils.addAll(curFiles, newFiles);
                    for (String file : allFiles) {
                        MessageUid theUid = getNextUid();
                        lines.add(String.valueOf(theUid.asLong()) + " " + file);
                        if (file.equals(name)) {
                            uid = theUid;
                        }
                        
                    }
                    
                    try (PrintWriter pw = new PrintWriter(uidList)) {
                        pw.println(createUidListHeader());
                        for (String line : lines) {
                            pw.println(line);
                        }
                        
                    }
                    
                }
                
            }
             catch (IOException e) {
                throw new MailboxException("Unable to append msg", e);
            }
            
            if (uid == null) {
                throw new MailboxException("Unable to append msg");
            }
             else {
               return uid;
            }
            
        }, MailboxPathLocker.LockType.Write);
    }
    
    public void update(final MessageUid uid, final String messageName) throws MailboxException {
        locker.executeWithLock(path, (LockAwareExecution<Void>) () -> {
            File uidList = uidFile;
            try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                String line = reader.readLine();
                readUidListHeader(line);
                ArrayList<String> lines = new ArrayList<>();
                while ((line = reader.readLine()) != null) {
                    if (uid.equals(MessageUid.of(Long.parseLong(line.substring(0, line.indexOf(" ")))))) {
                        line = String.valueOf(uid.asLong()) + " " + messageName;
                    }
                    
                    lines.add(line);
                }
                
                try (PrintWriter writer = new PrintWriter(uidList)) {
                    writer.println(createUidListHeader());
                    for (String entry : lines) {
                        writer.println(entry);
                    }
                    
                }
                
            }
             catch (IOException e) {
                throw new MailboxException("Unable to update msg with uid " + uid, e);
            }
            
            return null;
        }, MailboxPathLocker.LockType.Write);
    }
    
    public MaildirMessageName delete(final MessageUid uid) throws MailboxException {
        return locker.executeWithLock(path, () -> {
            File uidList = uidFile;
            MaildirMessageName deletedMessage = null;
            try (FileReader fileReader = new FileReader(uidList); BufferedReader reader = new BufferedReader(fileReader)) {
                readUidListHeader(reader.readLine());
                ArrayList<String> lines = new ArrayList<>();
                String line;
                int lineNumber = 0;
                while ((line = reader.readLine()) != null) {
                    lineNumber++;
                    int gap = line.indexOf(" ");
                    if (gap == -1) {
                        LOGGER.info("Corrupted entry in uid-file {} line {}", uidList, lineNumber);
                        continue;
                    }
                    
                    if (uid.equals(MessageUid.of(Long.parseLong(line.substring(0, line.indexOf(" ")))))) {
                        deletedMessage = newMaildirMessageName(MaildirFolder.this, line.substring(gap + 1));
                        messageCount--;
                    }
                     else {
                        lines.add(line);
                    }
                    
                }
                
                if (deletedMessage != null) {
                    FileUtils.forceDelete(deletedMessage.getFile());
                    try (PrintWriter writer = new PrintWriter(uidList)) {
                        writer.println(createUidListHeader());
                        for (String entry : lines) {
                            writer.println(entry);
                        }
                        
                    }
                    
                }
                
                return deletedMessage;
            }
             catch (IOException e) {
                throw new MailboxException("Unable to delete msg with uid " + uid, e);
            }
            
        }, MailboxPathLocker.LockType.Write);
    }
    
    public String toString() {
        return getRootFile().getAbsolutePath();
    }
    
    public MailboxACL getACL() throws MailboxException {
        if (acl == null) {
            acl = readACL();
        }
        
        return acl;
    }
    
    private MailboxACL readACL() throws MailboxException {
        return locker.executeWithLock(path, (LockAwareExecution<MailboxACL>) () -> {
            File f = aclFile;
            Properties props = new Properties();
            if (f.exists()) {
                try (FileInputStream in = new FileInputStream(f)) {
                    props.load(in);
                }
                 catch (IOException e) {
                    throw new MailboxException("Unable to read last ACL from " + f.getAbsolutePath(), e);
                }
                
            }
            
            return new MailboxACL(props);
        }, MailboxPathLocker.LockType.Write);
    }
    
    public void setACL(MailboxACL acl) throws MailboxException {
        MailboxACL old = this.acl;
        if (!Objects.equals(old, acl)) {
            saveACL(acl);
            this.acl = acl;
        }
        
    }
    
    private void saveACL(final MailboxACL acl) throws MailboxException {
        locker.executeWithLock(path, new LockAwareExecution<Void>() {             

            public Void execute() throws MailboxException {
                File f = aclFile;
                Properties props = new Properties();
                Map<EntryKey, Rfc4314Rights> entries = acl.getEntries();
                if (entries != null) {
                    for (Entry<EntryKey, Rfc4314Rights> en : entries.entrySet()) {
                        props.put(en.getKey().serialize(), en.getValue().serialize());
                    }
                    
                }
                
                if (f.exists()) {
                    try (FileOutputStream out = new FileOutputStream(f)) {
                        props.store(out, "written by " + getClass().getName());
                    }
                     catch (IOException e) {
                        throw new MailboxException("Unable to read last ACL from " + f.getAbsolutePath(), e);
                    }
                    
                }
                
                return null;
            }
            
        }, MailboxPathLocker.LockType.Write);
    }
    
}


