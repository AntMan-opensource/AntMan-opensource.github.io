package hudson.plugins.emailext;
import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.Extension;
import hudson.init.InitMilestone;
import hudson.init.Initializer;
import hudson.matrix.MatrixProject;
import hudson.model.AbstractProject;
import hudson.plugins.emailext.plugins.EmailTriggerDescriptor;
import hudson.plugins.emailext.plugins.trigger.FailureTrigger;
import hudson.security.Permission;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Publisher;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import hudson.util.ReflectionUtils;
import hudson.util.Secret;
import jenkins.model.Jenkins;
import jenkins.model.JenkinsLocationConfiguration;
import net.sf.json.JSONObject;
import org.apache.commons.lang.StringUtils;
import org.jenkinsci.Symbol;
import org.jenkinsci.plugins.scriptsecurity.scripts.ApprovalContext;
import org.jenkinsci.plugins.scriptsecurity.scripts.ClasspathEntry;
import org.jenkinsci.plugins.scriptsecurity.scripts.ScriptApproval;
import org.jenkinsci.plugins.scriptsecurity.scripts.languages.GroovyLanguage;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.StaplerRequest;
import javax.mail.Authenticator;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.servlet.ServletException;
import java.io.IOException;
import java.io.PrintStream;
import java.io.StringReader;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import static org.apache.commons.lang.StringUtils.isBlank;
public final class ExtendedEmailPublisherDescriptor extends BuildStepDescriptor<Publisher> {
    public static final Logger LOGGER = Logger.getLogger(ExtendedEmailPublisherDescriptor.class.getName());
    private String defaultSuffix;
    private transient String hudsonUrl;
    private MailAccount mailAccount = new MailAccount();
    private List<MailAccount> addAccounts = new ArrayList<>();
    private transient String adminAddress;
    private String charset;
    private String defaultContentType;
    private String defaultSubject;
    private String defaultBody;
    private String defaultPresendScript = "";
    private String defaultPostsendScript = "";
    private List<GroovyScriptPath> defaultClasspath = new ArrayList<>();
    private transient List<EmailTriggerDescriptor> defaultTriggers = new ArrayList<>();
    private List<String> defaultTriggerIds = new ArrayList<>();
    private String emergencyReroute;
    private long maxAttachmentSize = -1;
    private String recipientList = "";
    private String defaultReplyTo = "";
    private String allowedDomains = null;
    private String excludedCommitters = "";
    private boolean overrideGlobalSettings;
    private String listId;
    private boolean precedenceBulk;
    private boolean debugMode = false;
    private transient boolean enableSecurity = false;
    private boolean requireAdminForTemplateTesting = false;
    private boolean enableWatching;
    private boolean enableAllowUnregistered;
    private transient String smtpHost;
    private transient String smtpPort;
    private transient String smtpAuthUsername;
    private transient Secret smtpAuthPassword;
    private transient boolean useSsl = false;
    private Object readResolve(){
        if(smtpHost != null) mailAccount.setSmtpHost(smtpHost);
        if(smtpPort != null) mailAccount.setSmtpPort(smtpPort);
        if(smtpAuthUsername != null) mailAccount.setSmtpUsername(smtpAuthUsername);
        if(smtpAuthPassword != null) mailAccount.setSmtpPassword(smtpAuthPassword);
        if(useSsl) mailAccount.setUseSsl(useSsl);
        return this;
    }
    
    public ExtendedEmailPublisherDescriptor() {
        super(ExtendedEmailPublisher.class);
        load();
        if (defaultBody == null && defaultSubject == null && emergencyReroute == null) {
            defaultBody = ExtendedEmailPublisher.DEFAULT_BODY_TEXT;
            defaultSubject = ExtendedEmailPublisher.DEFAULT_SUBJECT_TEXT;
            emergencyReroute = ExtendedEmailPublisher.DEFAULT_EMERGENCY_REROUTE_TEXT;
        }
        
        if(mailAccount == null) {
            mailAccount = new MailAccount();
            mailAccount.setAddress(getAdminAddress());
        }
        
        mailAccount.setDefaultAccount(true);
    }
    
    @Initializer(after = InitMilestone.EXTENSIONS_AUGMENTED, before = InitMilestone.JOB_LOADED)
    public static void autoConfigure() {
        ExtendedEmailPublisherDescriptor descriptor = ExtendedEmailPublisher.descriptor();
        if (Jenkins.get().isUseSecurity() && (!StringUtils.isBlank(descriptor.getDefaultPostsendScript())) || !StringUtils.isBlank(descriptor.getDefaultPresendScript())) {
            descriptor.setDefaultPostsendScript(descriptor.getDefaultPostsendScript());
            descriptor.setDefaultPresendScript(descriptor.getDefaultPresendScript());
            try {
                descriptor.setDefaultClasspath(descriptor.getDefaultClasspath());
            }
             catch (FormException e) {
                List<GroovyScriptPath> newList = new ArrayList<>();
                for (GroovyScriptPath path : descriptor.getDefaultClasspath()) {
                    URL u = path.asURL();
                    if (u != null) {
                        try {
                            new ClasspathEntry(u.toString());
                            newList.add(path);
                        }
                         catch (MalformedURLException mfue) {
                            LOGGER.log(Level.WARNING, "The default classpath contained a malformed url, will be ignored.", mfue);
                        }
                        
                    }
                    
                }
                
                try {
                    descriptor.setDefaultClasspath(newList);
                }
                 catch (FormException e1) {
                    assert false : e1;
                }
                
            }
            
        }
        
    }
    
    public String getDisplayName() {
        return Messages.ExtendedEmailPublisherDescriptor_DisplayName();
    }
    
    public String getAdminAddress() {
        JenkinsLocationConfiguration config = JenkinsLocationConfiguration.get();
        if(config != null) {
            if(StringUtils.isBlank(mailAccount.getAddress())) {
                mailAccount.setAddress(config.getAdminAddress());
            }
            
        }
        
        return mailAccount.getAddress();
    }
    
    public String getDefaultSuffix() {
        return defaultSuffix;
    }
    
    public void setDefaultSuffix(String defaultSuffix) {
        this.defaultSuffix = defaultSuffix;
    }
    
    public Session createSession(String from) throws MessagingException {
        Properties props = new Properties(System.getProperties());
        MailAccount acc = mailAccount;
        if(StringUtils.isNotBlank(from)){
            InternetAddress fromAddress = new InternetAddress(from);
            for(MailAccount ma : addAccounts) {
                if(ma == null || !ma.isValid() || !ma.getAddress().equalsIgnoreCase(fromAddress.getAddress())) continue;
                acc = ma;
                break;
            }
            
        }
        
        if(!acc.isValid()) {
        }
        
        if (acc.getSmtpHost() != null) {
            props.put("mail.smtp.host", acc.getSmtpHost());
        }
        
        if (acc.getSmtpPort() != null) {
            props.put("mail.smtp.port", acc.getSmtpPort());
        }
        
        if (acc.isUseSsl()) {
            if (props.getProperty("mail.smtp.socketFactory.port") == null) {
                String port = acc.getSmtpPort() == null ? "465" : mailAccount.getSmtpPort();
                props.put("mail.smtp.port", port);
                props.put("mail.smtp.socketFactory.port", port);
            }
            
            if (props.getProperty("mail.smtp.socketFactory.class") == null) {
                props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
            }
            
            props.put("mail.smtp.socketFactory.fallback", "false");
        }
        
        if (!StringUtils.isBlank(acc.getSmtpUsername())) {
            props.put("mail.smtp.auth", "true");
        }
        
        props.put("mail.smtp.timeout", "60000");
        props.put("mail.smtp.connectiontimeout", "60000");
        try {
            String ap = acc.getAdvProperties();
            if (ap != null && !isBlank(ap.trim())) {
                props.load(new StringReader(ap));
            }
            
        }
         catch (IOException e) {
            LOGGER.log(Level.WARNING, "Parameters parse fail.", e);
        }
        
        return Session.getInstance(props, getAuthenticator(acc));
    }
    
    private Authenticator getAuthenticator(final MailAccount acc) {
        if (acc == null || StringUtils.isBlank(acc.getSmtpUsername())) {
            return null;
        }
        
        return new Authenticator() { 

            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(acc.getSmtpUsername(), Secret.toString(acc.getSmtpPassword()));
            }
            
        };
    }
    
    public String getHudsonUrl() {
        return Jenkins.get().getRootUrl();
    }
    
    public List<MailAccount> getAddAccounts() {
        return addAccounts;
    }
    
    public void setAddAccounts(List<MailAccount> addAccounts) {
        this.addAccounts = addAccounts;
    }
    
    public String getSmtpServer() {
        return mailAccount.getSmtpHost();
    }
    
    public void setSmtpServer(String smtpServer) {
        mailAccount.setSmtpHost(smtpServer);
    }
    
    public String getSmtpUsername() {
        return mailAccount.getSmtpUsername();
    }
    
    public void setSmtpUsername(String username) {
        mailAccount.setSmtpUsername(username);
    }
    
    public Secret getSmtpPassword() {
        return mailAccount.getSmtpPassword();
    }
    
    public void setSmtpPassword(String password) {
        mailAccount.setSmtpPassword(password);
    }
    
    public void setSmtpAuth(String userName, String password) {
        setSmtpUsername(userName);
        setSmtpPassword(password);
    }
    
    public boolean getUseSsl() {
        return mailAccount.isUseSsl();
    }
    
    public void setUseSsl(boolean useSsl) {
        mailAccount.setUseSsl(useSsl);
    }
    
    public String getSmtpPort() {
        return mailAccount.getSmtpPort();
    }
    
    public void setSmtpPort(String port) {
        mailAccount.setSmtpPort(nullify(port));
    }
    
    public String getAdvProperties() {
        return mailAccount.getAdvProperties();
    }
    
    public void setAdvProperties(String advProperties) {
        mailAccount.setAdvProperties(advProperties);
    }
    
    public String getCharset() {
        String c = charset;
        if (StringUtils.isBlank(c)) {
            c = "UTF-8";
        }
        
        return c;
    }
    
    public void setCharset(String charset) {
        this.charset = charset;
    }
    
    public String getDefaultContentType() {
        return defaultContentType;
    }
    
    public void setDefaultContentType(String contentType) {
        if (StringUtils.isBlank(contentType)) {
            this.defaultContentType = "text/plain";
        }
         else {
            this.defaultContentType = contentType;
        }
        
    }
    
    public String getDefaultSubject() {
        return defaultSubject;
    }
    
    public void setDefaultSubject(String subject) {
        if (subject == null) {
            this.defaultSubject = ExtendedEmailPublisher.DEFAULT_SUBJECT_TEXT;
        }
         else {
            this.defaultSubject = subject;
        }
        
    }
    
    public String getDefaultBody() {
        return defaultBody;
    }
    
    public void setDefaultBody(String body) {
        if (StringUtils.isBlank(body)) {
            this.defaultBody = ExtendedEmailPublisher.DEFAULT_BODY_TEXT;
        }
         else {
            this.defaultBody = body;
        }
        
    }
    
    public String getEmergencyReroute() {
        return emergencyReroute;
    }
    
    public void setEmergencyReroute(String emergencyReroute) {
        if (StringUtils.isBlank(emergencyReroute)) {
            this.emergencyReroute = ExtendedEmailPublisher.DEFAULT_EMERGENCY_REROUTE_TEXT;
        }
         else {
            this.emergencyReroute = emergencyReroute;
        }
        
    }
    
    public long getMaxAttachmentSize() {
        return maxAttachmentSize;
    }
    
    public void setMaxAttachmentSize(long bytes) {
        if (bytes < 0) {
            bytes = -1; 
        }
        
        this.maxAttachmentSize = bytes;
    }
    
    public MailAccount getMailAccount() {
        return mailAccount;
    }
    
    public void setMailAccount(MailAccount mailAccount) {
        this.mailAccount = mailAccount;
        this.mailAccount.setAddress(getAdminAddress());
        this.mailAccount.setDefaultAccount(true);
    }
    
    public long getMaxAttachmentSizeMb() {
        if(maxAttachmentSize < 0) {
            return -1;
        }
        
        return maxAttachmentSize / (1024 * 1024);
    }
    
    public void setMaxAttachmentSizeMb(long mb) {
        if(mb < 0) {
            setMaxAttachmentSize(mb);
        }
         else {
            setMaxAttachmentSize(mb * (1024 * 1024));
        }
        
    }
    
    public String getDefaultRecipients() {
        return recipientList;
    }
    
    public void setDefaultRecipients(String recipients) {
        this.recipientList = ((recipients == null) ? "" : recipients);
    }
    
    public String getAllowedDomains() {
        return allowedDomains;
    }
    
    public void setAllowedDomains(String allowed) {
        this.allowedDomains = ((allowed == null) ? "" : allowed);
    }
    
    public String getExcludedCommitters() {
        return excludedCommitters;
    }
    
    public void setExcludedCommitters(String excluded) {
        this.excludedCommitters = ((excluded == null) ? "" : excluded);
    }
    
    public boolean getOverrideGlobalSettings() {
        return overrideGlobalSettings;
    }
    
    public String getListId() {
        return listId;
    }
    
    public void setListId(String id) {
        this.listId = id;
    }
    
    public boolean getPrecedenceBulk() {
        return precedenceBulk;
    }
    
    public void setPrecedenceBulk(boolean bulk) {
        this.precedenceBulk = bulk;
    }
    
    public String getDefaultReplyTo() {
        return defaultReplyTo;
    }
    
    public void setDefaultReplyTo(String to) {
        this.defaultReplyTo = ((to == null) ? "" : to);
    }
    
    public boolean isSecurityEnabled() {
        return false;
    }
    
    public boolean isAdminRequiredForTemplateTesting() {
        return requireAdminForTemplateTesting;
    }
    
    public void setAdminRequiredForTemplateTesting(boolean requireAdmin) {
        this.requireAdminForTemplateTesting = requireAdmin;
    }
    
    public boolean isWatchingEnabled() {
        return enableWatching;
    }
    
    public boolean isAllowUnregisteredEnabled() {
        return enableAllowUnregistered;
    }
    
    public void setWatchingEnabled(boolean enabled) {
        this.enableWatching = enabled;
    }
    
    public void setAllowUnregisteredEnabled(boolean enabled) {
        this.enableAllowUnregistered = enabled;
    }
    
    public boolean isApplicable(Class<? extends AbstractProject> jobType) {
        return true;
    }
    
    public String getDefaultPresendScript() {
        return defaultPresendScript;
    }
    
    public void setDefaultPresendScript(String script) {
        script = StringUtils.trim(script);
        this.defaultPresendScript = ScriptApproval.get().configuring(((script == null) ? "" : script), GroovyLanguage.get(), ApprovalContext.create().withCurrentUser());
    }
    
    public String getDefaultPostsendScript() {
        return defaultPostsendScript;
    }
    
    public void setDefaultPostsendScript(String script) {
        script = StringUtils.trim(script);
        this.defaultPostsendScript = ScriptApproval.get().configuring(((script == null) ? "" : script), GroovyLanguage.get(), ApprovalContext.create().withCurrentUser());
    }
    
    public List<GroovyScriptPath> getDefaultClasspath() {
        return defaultClasspath;
    }
    
    public void setDefaultClasspath(List<GroovyScriptPath> defaultClasspath) throws FormException {
        if (Jenkins.get().isUseSecurity()) {
            ScriptApproval approval = ScriptApproval.get();
            ApprovalContext context = ApprovalContext.create().withCurrentUser();
            for (GroovyScriptPath path : defaultClasspath) {
                URL u = path.asURL();
                if (u != null) {
                    try {
                        approval.configuring(new ClasspathEntry(u.toString()), context);
                    }
                     catch (MalformedURLException e) {
                        throw new FormException(e, "defaultClasspath");
                    }
                    
                }
                
            }
            
        }
        
        this.defaultClasspath = defaultClasspath;
    }
    
    public List<String> getDefaultTriggerIds() {
        if (defaultTriggerIds.isEmpty()) {
            if (!defaultTriggers.isEmpty()) {
                defaultTriggerIds.clear();
                for (EmailTriggerDescriptor t : this.defaultTriggers) {
                    EmailTriggerDescriptor d = Jenkins.get().getDescriptorByType(t.getClass());
                    if (d != null && !defaultTriggerIds.contains(d.getId())) {
                        defaultTriggerIds.add(d.getId());
                    }
                    
                }
                
            }
             else {
                FailureTrigger.DescriptorImpl f = Jenkins.get().getDescriptorByType(FailureTrigger.DescriptorImpl.class);
                if (f != null) {
                    defaultTriggerIds.add(f.getId());
                }
                
            }
            
            save();
        }
        
        return defaultTriggerIds;
    }
    
    public void setDefaultTriggerIds(List<String> triggerIds) {
        defaultTriggerIds = triggerIds;
    }
    
    public ListBoxModel doFillDefaultContentTypeItems() {
        ListBoxModel items = new ListBoxModel();
        items.add(Messages.contentType_plainText(), "text/plain");
        items.add(Messages.contentType_html(), "text/html");
        return items;
    }
    
    public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
        req.bindJSON(this, formData);
        save();
        return super.configure(req, formData);
    }
    
    private String nullify(String v) {
        if (v != null && v.length() == 0) {
            v = null;
        }
        
        return v;
    }
    
    public String getHelpFile() {
        return "/plugin/email-ext/help/main.html";
    }
    
    public FormValidation doAddressCheck(@QueryParameter final String value) throws IOException, ServletException {
        try {
            new InternetAddress(value);
            return FormValidation.ok();
        }
         catch (AddressException e) {
            return FormValidation.error(e.getMessage());
        }
        
    }
    
    public FormValidation doRecipientListRecipientsCheck(@QueryParameter final String value) throws IOException, ServletException {
        return new EmailRecipientUtils().validateFormRecipientList(value);
    }
    
    public FormValidation doMaxAttachmentSizeCheck(@QueryParameter final String value) throws IOException, ServletException {
        try {
            String testValue = value.trim();
            if (testValue.length() > 0) {
                Long.parseLong(testValue);
            }
            
            return FormValidation.ok();
        }
         catch (Exception e) {
            return FormValidation.error(e.getMessage());
        }
        
    }
    
    public boolean isMatrixProject(Object project) {
        return project instanceof MatrixProject;
    }
    
    public boolean isDebugMode() {
        return debugMode;
    }
    
    public void setDebugMode(boolean debugMode) {
        this.debugMode = debugMode;
    }
    
    public void debug(PrintStream logger, String format, Object... args) {
        if (debugMode) {
            logger.format(format, args);
            logger.println();
        }
        
    }
    
    public Permission getRequiredGlobalConfigPagePermission() {
        return getJenkinsManageOrAdmin();
    }
    
    Permission getJenkinsManageOrAdmin() {
        Permission manage;
        try { 
            manage = (Permission) ReflectionUtils.getPublicProperty(Jenkins.get(), "MANAGE");
        }
         catch (IllegalArgumentException | InvocationTargetException | NoSuchMethodException | IllegalAccessException e) {
            manage = Jenkins.ADMINISTER;
        }
        
        return manage;
    }
    
}


