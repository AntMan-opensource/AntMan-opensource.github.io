package com.sonyericsson.jenkins.plugins.bfa.db;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import com.mongodb.MongoClientSettings;
import com.mongodb.MongoCredential;
import com.mongodb.MongoException;
import com.mongodb.ServerAddress;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoClient;
import static com.mongodb.client.model.Filters.not;
import static com.mongodb.client.model.Filters.exists;
import static com.mongodb.client.model.Filters.eq;
import static com.sonyericsson.jenkins.plugins.bfa.MetricsManager.addMetric;
import static com.sonyericsson.jenkins.plugins.bfa.MetricsManager.UNKNOWNCAUSE;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.result.UpdateResult;
import com.mongodb.connection.ClusterConnectionMode;
import com.sonyericsson.jenkins.plugins.bfa.Messages;
import com.sonyericsson.jenkins.plugins.bfa.model.FailureCause;
import com.sonyericsson.jenkins.plugins.bfa.model.indication.FoundIndication;
import com.sonyericsson.jenkins.plugins.bfa.statistics.FailureCauseStatistics;
import com.sonyericsson.jenkins.plugins.bfa.statistics.Statistics;
import com.sonyericsson.jenkins.plugins.bfa.utils.BfaUtils;
import hudson.Extension;
import hudson.Util;
import hudson.model.Descriptor;
import hudson.model.Run;
import hudson.util.FormValidation;
import hudson.util.Secret;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.SimpleTimeZone;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import jenkins.model.Jenkins;
import org.bson.BsonValue;
import org.bson.UuidRepresentation;
import org.bson.conversions.Bson;
import org.bson.types.ObjectId;
import org.jfree.data.time.Day;
import org.jfree.data.time.Hour;
import org.jfree.data.time.Month;
import org.jfree.data.time.TimePeriod;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import org.mongojack.JacksonMongoCollection;
import org.mongojack.internal.MongoJackModule;
public class MongoDBKnowledgeBase extends KnowledgeBase {
    private static final long serialVersionUID = 4984133048405390951L;
    public static final String COLLECTION_NAME = "failureCauses";
    public static final String STATISTICS_COLLECTION_NAME = "statistics";
    private static final int MONGO_DEFAULT_PORT = 27017;
    static final Bson NOT_REMOVED_QUERY_FILTER = not(exists("_removed"));
    private static final Logger logger = Logger.getLogger(MongoDBKnowledgeBase.class.getName());
    private static final int CONNECT_TIMEOUT = 5000;
    private static final int SERVER_SELECTION_TIMEOUT = 5000;
    private static final TypeFactory TYPE_FACTORY = TypeFactory.defaultInstance() .withClassLoader(MongoDBKnowledgeBase.class.getClassLoader());
    private static final ObjectMapper OBJECT_MAPPER = MongoJackModule .configure(new ObjectMapper()) .setTypeFactory(TYPE_FACTORY);
    private transient MongoClient mongo;
    private transient MongoDatabase db;
    private transient JacksonMongoCollection<FailureCause> jacksonCollection;
    private transient JacksonMongoCollection<DBObject> jacksonStatisticsCollection;
    private transient MongoDBKnowledgeBaseCache cache;
    private String host;
    private int port;
    private String dbName;
    private String userName;
    private Secret password;
    private boolean enableStatistics;
    private boolean successfulLogging;
    private boolean tls;
    private boolean retryWrites;
    public String getUserName() {
        return userName;
    }
    
    public Secret getPassword() {
        return password;
    }
    
    public String getHost() {
        return host;
    }
    
    public int getPort() {
        return port;
    }
    
    public String getDbName() {
        return dbName;
    }
    
    public boolean isTls() {
        return tls;
    }
    
    public void setTls(boolean tls) {
        this.tls = tls;
    }
    
    public void setRetryWrites(boolean retryWrites) {
        this.retryWrites = retryWrites;
    }
    
    public MongoDBKnowledgeBase(String host, int port, String dbName, String userName, Secret password, boolean enableStatistics, boolean successfulLogging) {
        this.host = host;
        this.port = port;
        this.dbName = dbName;
        this.userName = userName;
        this.password = password;
        this.enableStatistics = enableStatistics;
        this.successfulLogging = successfulLogging;
    }
    
    public synchronized void start() {
        initCache();
        cache.updateCache();
        for (FailureCause entry : getCauseNames()) {
            addMetric(entry);
        }
        
        addMetric(UNKNOWNCAUSE);
    }
    
    public synchronized void stop() {
        if (cache != null) {
            cache.stop();
            cache = null;
        }
        
        if (mongo != null) {
            mongo.close();
            mongo = null;
        }
        
    }
    
    private void initCache() {
        if (cache == null) {
            cache = new MongoDBKnowledgeBaseCache(getJacksonCollection());
            cache.start();
        }
        
    }
    
    public Collection<FailureCause> getCauses() {
        initCache();
        return cache.getCauses();
    }
    
    public Collection<FailureCause> getCauseNames() {
        List<FailureCause> list = new LinkedList<FailureCause>();
        DBObject keys = new BasicDBObject();
        keys.put("name", 1);
        final FindIterable<FailureCause> dbCauses = getJacksonCollection().find(NOT_REMOVED_QUERY_FILTER);
        final MongoCursor<FailureCause> iterator = dbCauses.iterator();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        
        return list;
    }
    
    public Collection<FailureCause> getShallowCauses() {
        List<FailureCause> list = new LinkedList<>();
        DBObject keys = new BasicDBObject();
        keys.put("name", 1);
        keys.put("description", 1);
        keys.put("categories", 1);
        keys.put("comment", 1);
        keys.put("modifications", 1);
        keys.put("lastOccurred", 1);
        BasicDBObject orderBy = new BasicDBObject("name", 1);
        final FindIterable<FailureCause> dbCauses = getJacksonCollection().find(NOT_REMOVED_QUERY_FILTER);
        dbCauses.sort(orderBy);
        final MongoCursor<FailureCause> iterator = dbCauses.iterator();
        while (iterator.hasNext()) {
            list.add(iterator.next());
        }
        
        return list;
    }
    
    public FailureCause getCause(String id) {
        FailureCause returnCase = null;
        try {
            returnCase = getJacksonCollection().findOneById(id);
        }
         catch (IllegalArgumentException e) {
         logger.fine("Could not find the id, returning null for id: " + id);
            return returnCase;
        }
        
        return returnCase;
    }
    
    public FailureCause addCause(FailureCause cause) {
        return addCause(cause, true);
    }
    
    public FailureCause removeCause(String id) {
        BasicDBObject removedInfo = new BasicDBObject("timestamp", new Date());
        removedInfo.put("by", Jenkins.getAuthentication().getName());
        BasicDBObject update = new BasicDBObject("$set", new BasicDBObject("_removed", removedInfo));
        getJacksonCollection().updateById(id, update);
        final FailureCause modifiedFailureCause = getJacksonCollection().findOneById(id);
        initCache();
        cache.updateCache();
        return modifiedFailureCause;
    }
    
    public FailureCause addCause(FailureCause cause, boolean doUpdate) {
        return saveCause(cause, doUpdate);
    }
    
    public FailureCause saveCause(FailureCause cause) {
        addMetric(cause);
        return saveCause(cause, true);
    }
    
    public FailureCause saveCause(FailureCause cause, boolean doUpdate) {
        UpdateResult result = getJacksonCollection().save(cause);
        if (doUpdate) {
            initCache();
            cache.updateCache();
        }
        
        final BsonValue upsertedId = result.getUpsertedId();
        final FailureCause modifiedFailureCause = getJacksonCollection().find(eq("_id", upsertedId)).first();
        return modifiedFailureCause;
    }
    
    public void convertFrom(KnowledgeBase oldKnowledgeBase) throws Exception {
        if (oldKnowledgeBase instanceof MongoDBKnowledgeBase) {
            convertFromAbstract(oldKnowledgeBase);
            convertRemoved((MongoDBKnowledgeBase)oldKnowledgeBase);
        }
         else {
            for (FailureCause cause : oldKnowledgeBase.getCauseNames()) {
                try {
                    if (getCause(cause.getId()) != null) {
                        saveCause(cause, false);
                    }
                     else {
                        cause.setId(null);
                        addCause(cause, false);
                    }
                    
                }
                 catch (MongoException e) {
                    cause.setId(null);
                    addCause(cause, false);
                }
                
            }
            
            initCache();
            cache.updateCache();
        }
        
    }
    
    public List<String> getCategories() {
        initCache();
        return cache.getCategories();
    }
    
    protected void convertRemoved(MongoDBKnowledgeBase oldKnowledgeBase) throws Exception {
        List<FailureCause> removed = oldKnowledgeBase.getRemovedCauses();
        for (FailureCause fc : removed) {
            getJacksonCollection().save(fc);
        }
        
    }
    
    protected List<FailureCause> getRemovedCauses() throws Exception {
        BasicDBObject query = new BasicDBObject("_removed", new BasicDBObject("$exists", true));
        FindIterable<FailureCause> causes = getJacksonCollection().find(query);
        List<FailureCause> removed = new LinkedList<FailureCause>();
        while (causes.iterator().hasNext()) {
            removed.add(causes.iterator().next());
        }
        
        return removed;
    }
    
    public boolean equals(KnowledgeBase oldKnowledgeBase) {
        if (getClass().isInstance(oldKnowledgeBase)) {
            MongoDBKnowledgeBase oldMongoDBKnowledgeBase = (MongoDBKnowledgeBase)oldKnowledgeBase;
            return equals(oldMongoDBKnowledgeBase.getHost(), host) && oldMongoDBKnowledgeBase.getPort() == port && equals(oldMongoDBKnowledgeBase.getDbName(), dbName) && equals(oldMongoDBKnowledgeBase.getUserName(), userName) && equals(oldMongoDBKnowledgeBase.getPassword(), password) && this.tls == oldMongoDBKnowledgeBase.tls && this.enableStatistics == oldMongoDBKnowledgeBase.enableStatistics && this.successfulLogging == oldMongoDBKnowledgeBase.successfulLogging;
        }
         else {
            return false;
        }
        
    }
    
    public boolean equals(Object other) {
        if (other instanceof KnowledgeBase) {
            return this.equals((KnowledgeBase)other);
        }
         else {
            return false;
        }
        
    }
    
    public static boolean equals(Object firstObject, Object secondObject) {
        if (firstObject == null) {
            if (secondObject == null) {
                return true;
            }
            
            return false;
        }
        
        if (secondObject == null) {
            return false;
        }
        
        return secondObject.equals(firstObject);
    }
    
    public int hashCode() {
        return getClass().getName().hashCode();
    }
    
    public boolean isEnableStatistics() {
        return enableStatistics;
    }
    
    public boolean isSuccessfulLogging() {
        return successfulLogging;
    }
    
    public void saveStatistics(Statistics stat) {
        DBObject object = new BasicDBObject();
        object.put("projectName", stat.getProjectName());
        object.put("buildNumber", stat.getBuildNumber());
        object.put("displayName", stat.getDisplayName());
        object.put("master", stat.getMaster());
        object.put("slaveHostName", stat.getSlaveHostName());
        object.put("startingTime", stat.getStartingTime());
        object.put("duration", stat.getDuration());
        object.put("timeZoneOffset", stat.getTimeZoneOffset());
        object.put("triggerCauses", stat.getTriggerCauses());
        DBObject cause = null;
        if (stat.getUpstreamCause() != null) {
            cause = new BasicDBObject();
            Statistics.UpstreamCause upstreamCause = stat.getUpstreamCause();
            cause.put("project", upstreamCause.getUpstreamProject());
            cause.put("build", upstreamCause.getUpstreamBuild());
        }
        
        object.put("upstreamCause", cause);
        object.put("result", stat.getResult());
        List<FailureCauseStatistics> failureCauseStatisticsList = stat.getFailureCauseStatisticsList();
        addFailureCausesToDBObject(object, failureCauseStatisticsList);
        getJacksonStatisticsCollection().insert(object);
       }
       
    public Date getLatestFailureForCause(String id) {
        try {
            BasicDBObject match = new BasicDBObject("failureCauses.failureCause.$id", new ObjectId(id));
            FindIterable<DBObject> output = getJacksonStatisticsCollection() .find(match) .sort(new BasicDBObject("startingTime", -1)) .limit(1);
            for (DBObject result : output) {
                Date startingTime = (Date)result.get("startingTime");
                if (startingTime != null) {
                    return startingTime;
                }
                
            }
            
        }
         catch (Exception e) {
            logger.log(Level.WARNING, "Failed getting latest failure of cause", e);
        }
        
        return null;
    }
    
    public Date getCreationDateForCause(String id) {
        Date creationDate;
        try {
            creationDate = new ObjectId(id).getDate();
        }
         catch (IllegalArgumentException e) {
            logger.log(Level.WARNING, "Could not retrieve original modification", e);
            creationDate = new Date(0);
        }
        
        return creationDate;
    }
    
    public void updateLastSeen(List<String> ids, Date seen) {
        BasicDBObject set = new BasicDBObject("$set", new BasicDBObject("lastOccurred", seen));
        for (String id : ids) {
            getJacksonCollection().updateById(id, set);
        }
        
    }
    
    private static void putNonNullStringValue(DBObject dbObject, String key, String value) {
        if (value != null) {
            dbObject.put(key, value);
        }
        
    }
    
    private static void putNonNullBasicDBObject(DBObject dbObject, String key, String operator, Object value) {
        if (value != null) {
            dbObject.put(key, new BasicDBObject(operator, value));
        }
        
    }
    
    private DBObject generateTimeGrouping(int intervalSize) {
        DBObject timeFields = new BasicDBObject();
        if (intervalSize == Calendar.HOUR_OF_DAY) {
            timeFields.put("hour", new BasicDBObject("$hour", "$startingTime"));
        }
        
        if (intervalSize == Calendar.HOUR_OF_DAY || intervalSize == Calendar.DATE) {
            timeFields.put("dayOfMonth", new BasicDBObject("$dayOfMonth", "$startingTime"));
        }
        
        timeFields.put("month", new BasicDBObject("$month", "$startingTime"));
        timeFields.put("year", new BasicDBObject("$year", "$startingTime"));
        return timeFields;
    }
    
    private TimePeriod generateTimePeriodFromResult(DBObject result, int intervalSize) {
        BasicDBObject groupedAttrs = (BasicDBObject)result.get("_id");
        int month = groupedAttrs.getInt("month");
        int year = groupedAttrs.getInt("year");
        Calendar c = Calendar.getInstance();
        c.set(Calendar.YEAR, year);
        c.set(Calendar.MONTH, month - 1);
        c.setTimeZone(new SimpleTimeZone(0, "UTC"));
        TimePeriod period;
        if (intervalSize == Calendar.HOUR_OF_DAY) {
            int dayOfMonth = groupedAttrs.getInt("dayOfMonth");
            c.set(Calendar.DAY_OF_MONTH, dayOfMonth);
            int hour = groupedAttrs.getInt("hour");
            c.set(Calendar.HOUR_OF_DAY, hour);
            period = new Hour(c.getTime());
        }
         else if (intervalSize == Calendar.DATE) {
            int dayOfMonth = groupedAttrs.getInt("dayOfMonth");
            c.set(Calendar.DAY_OF_MONTH, dayOfMonth);
            period = new Day(c.getTime());
        }
         else {
            period = new Month(c.getTime());
        }
        
        return period;
    }
    
    public void removeBuildfailurecause(Run build) {
        BasicDBObject searchObj = new BasicDBObject();
        searchObj.put("projectName", build.getParent().getFullName());
        searchObj.put("buildNumber", build.getNumber());
        searchObj.put("master", BfaUtils.getMasterName());
        getJacksonStatisticsCollection().getMongoCollection().deleteMany(searchObj);
    }
    
    private void addFailureCausesToDBObject(DBObject object, List<FailureCauseStatistics> failureCauseStatisticsList) {
        if (failureCauseStatisticsList != null && !failureCauseStatisticsList.isEmpty()) {
            List<DBObject> failureCauseStatisticsObjects = new LinkedList<DBObject>();
            for (FailureCauseStatistics failureCauseStatistics : failureCauseStatisticsList) {
                DBObject failureCauseStatisticsObject = new BasicDBObject();
                ObjectId id = new ObjectId(failureCauseStatistics.getId());
                DBRef failureCauseRef = new DBRef(dbName, COLLECTION_NAME, id);
                failureCauseStatisticsObject.put("failureCause", failureCauseRef);
                List<FoundIndication> foundIndicationList = failureCauseStatistics.getIndications();
                addIndicationsToDBObject(failureCauseStatisticsObject, foundIndicationList);
                failureCauseStatisticsObjects.add(failureCauseStatisticsObject);
            }
            
            object.put("failureCauses", failureCauseStatisticsObjects);
        }
        
    }
    
    private void addIndicationsToDBObject(DBObject object, List<FoundIndication> indications) {
        if (indications != null && !indications.isEmpty()) {
            List<DBObject> foundIndicationObjects = new LinkedList<DBObject>();
            for (FoundIndication foundIndication : indications) {
                DBObject foundIndicationObject = new BasicDBObject();
                foundIndicationObject.put("pattern", foundIndication.getPattern());
                foundIndicationObject.put("matchingFile", foundIndication.getMatchingFile());
                foundIndicationObject.put("matchingString", foundIndication.getMatchingString());
                foundIndicationObject.put("matchingLine", foundIndication.getMatchingLine());
                foundIndicationObjects.add(foundIndicationObject);
            }
            
            object.put("indications", foundIndicationObjects);
        }
        
    }
    
    public Descriptor<KnowledgeBase> getDescriptor() {
        return Jenkins.getInstance().getDescriptorByType(MongoDBKnowledgeBaseDescriptor.class);
    }
    
    MongoClient getMongoConnection() {
        if (mongo == null) {
            StringBuilder connectionStringBuilder = new StringBuilder(host);
            connectionStringBuilder.append(":").append(port);
            MongoClientSettings.Builder builder = MongoClientSettings.builder().applyToClusterSettings( builder1 -> {
                        List<ServerAddress> hostlist = new LinkedList<>();
                        for (String h: host.split(",")) {
                            hostlist.add(new ServerAddress(h, port));
                        }
                        
                        ClusterConnectionMode mode = hostlist.size() > 1 ? ClusterConnectionMode.MULTIPLE : ClusterConnectionMode.SINGLE;
                        builder1.hosts(hostlist). serverSelectionTimeout(SERVER_SELECTION_TIMEOUT, TimeUnit.MILLISECONDS). mode(mode);
                    }
).applyToConnectionPoolSettings(builder15 -> {
                    }
).applyToServerSettings(builder12 -> {
            }
).applyToSocketSettings(builder13 -> builder13.connectTimeout((CONNECT_TIMEOUT), TimeUnit.MILLISECONDS)). applyToSslSettings(builder14 -> builder14.enabled(tls)).retryWrites(retryWrites);
            if (password != null && Util.fixEmpty(password.getPlainText()) != null) {
                char[] pwd = password.getPlainText().toCharArray();
                MongoCredential credential = MongoCredential.createCredential(userName, dbName, pwd);
                builder.credential(credential);
            }
            
            mongo = MongoClients.create(builder.build());
        }
        
        return mongo;
    }
    
    private MongoDatabase getDb() {
        if (db == null) {
            db = getMongoConnection().getDatabase(dbName);
        }
        
        return db;
    }
    
    private synchronized JacksonMongoCollection<FailureCause> getJacksonCollection() {
        if (jacksonCollection == null) {
            jacksonCollection = JacksonMongoCollection.builder().withObjectMapper(OBJECT_MAPPER).build( getMongoConnection(), dbName, COLLECTION_NAME, FailureCause.class, UuidRepresentation.STANDARD);
        }
        
        return jacksonCollection;
    }
    
    private synchronized JacksonMongoCollection<DBObject> getJacksonStatisticsCollection() {
        if (jacksonStatisticsCollection == null) {
            jacksonStatisticsCollection = JacksonMongoCollection.builder().withObjectMapper(OBJECT_MAPPER).build( getMongoConnection(), dbName, STATISTICS_COLLECTION_NAME, DBObject.class, UuidRepresentation.STANDARD);
        }
        
        return jacksonStatisticsCollection;
    }
    
    public static class MongoDBKnowledgeBaseDescriptor extends KnowledgeBaseDescriptor {
        public String getDisplayName() {
            return Messages.MongoDBKnowledgeBase_DisplayName();
        }
        
        public int getDefaultPort() {
            return MONGO_DEFAULT_PORT;
        }
        
        public FormValidation doCheckHost(@QueryParameter("value") final String value) {
            if (Util.fixEmpty(value) == null) {
                return FormValidation.error("Please provide a host name!");
            }
             else {
                Matcher m = Pattern.compile("\\s").matcher(value);
                if (m.find()) {
                    return FormValidation.error("Host name contains white space!");
                }
                
                return FormValidation.ok();
            }
            
        }
        
        public FormValidation doCheckPort(@QueryParameter("value") String value) {
            try {
                Long.parseLong(value);
                return FormValidation.ok();
            }
             catch (NumberFormatException e) {
                return FormValidation.error("Please provide a port number!");
            }
            
        }
        
        public FormValidation doCheckDbName(@QueryParameter("value") String value) {
            if (value == null || value.isEmpty()) {
                return FormValidation.error("Please provide a database name!");
            }
             else {
                Matcher m = Pattern.compile("\\s").matcher(value);
                if (m.find()) {
                    return FormValidation.error("Database name contains white space!");
                }
                
                return FormValidation.ok();
            }
            
        }
        
        public FormValidation doTestConnection( @QueryParameter("host") final String host, @QueryParameter("port") final int port, @QueryParameter("dbName") final String dbName, @QueryParameter("userName") final String userName, @QueryParameter("password") final String password, @QueryParameter("tls") final boolean tls, @QueryParameter("retrywrites") final boolean retryWrites) {
            MongoDBKnowledgeBase base = new MongoDBKnowledgeBase(host, port, dbName, userName, Secret.fromString(password), false, false);
            base.setTls(tls);
            base.setRetryWrites(retryWrites);
            try {
                BasicDBObject ping = new BasicDBObject("ping", "1");
                base.getDb().runCommand(ping);
            }
             catch (Exception e) {
                return FormValidation.error(e, Messages.MongoDBKnowledgeBase_ConnectionError());
            }
             finally {
                base.stop();
            }
            
            return FormValidation.ok(Messages.MongoDBKnowledgeBase_ConnectionOK());
        }
        
    }
    
}


