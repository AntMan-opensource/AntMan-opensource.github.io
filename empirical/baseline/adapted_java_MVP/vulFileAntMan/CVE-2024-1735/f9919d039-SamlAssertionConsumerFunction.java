package com.linecorp.armeria.server.saml;
import static com.linecorp.armeria.server.saml.SamlHttpParameterNames.SAML_RESPONSE;
import static com.linecorp.armeria.server.saml.SamlMessageUtil.validateSignature;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import org.joda.time.DateTime;
import org.opensaml.messaging.context.MessageContext;
import org.opensaml.saml.common.messaging.context.SAMLBindingContext;
import org.opensaml.saml.saml2.core.Assertion;
import org.opensaml.saml.saml2.core.Audience;
import org.opensaml.saml.saml2.core.AuthnStatement;
import org.opensaml.saml.saml2.core.Conditions;
import org.opensaml.saml.saml2.core.EncryptedAssertion;
import org.opensaml.saml.saml2.core.Issuer;
import org.opensaml.saml.saml2.core.Response;
import org.opensaml.saml.saml2.core.Status;
import org.opensaml.saml.saml2.core.StatusCode;
import org.opensaml.saml.saml2.core.Subject;
import org.opensaml.saml.saml2.core.SubjectConfirmation;
import org.opensaml.saml.saml2.core.SubjectConfirmationData;
import org.opensaml.saml.saml2.encryption.Decrypter;
import org.opensaml.security.credential.Credential;
import org.opensaml.xmlsec.encryption.support.DecryptionException;
import org.opensaml.xmlsec.encryption.support.InlineEncryptedKeyResolver;
import org.opensaml.xmlsec.keyinfo.impl.StaticKeyInfoCredentialResolver;
import com.google.common.collect.ImmutableList;
import com.linecorp.armeria.common.AggregatedHttpRequest;
import com.linecorp.armeria.common.HttpResponse;
import com.linecorp.armeria.common.annotation.Nullable;
import com.linecorp.armeria.server.ServiceRequestContext;
final class SamlAssertionConsumerFunction implements SamlServiceFunction {
    private static final long MILLIS_IN_MINUTE = TimeUnit.MINUTES.toMillis(1);
    private final SamlAssertionConsumerConfig cfg;
    private final String entityId;
    private final Map<String, SamlIdentityProviderConfig> idpConfigs;
    private final SamlIdentityProviderConfig defaultIdpConfig;
    private final SamlRequestIdManager requestIdManager;
    private final SamlSingleSignOnHandler ssoHandler;
    SamlAssertionConsumerFunction(SamlAssertionConsumerConfig cfg, String entityId, Map<String, SamlIdentityProviderConfig> idpConfigs, @Nullable SamlIdentityProviderConfig defaultIdpConfig, SamlRequestIdManager requestIdManager, SamlSingleSignOnHandler ssoHandler) {
        this.cfg = cfg;
        this.entityId = entityId;
        this.idpConfigs = idpConfigs;
        this.defaultIdpConfig = defaultIdpConfig;
        this.requestIdManager = requestIdManager;
        this.ssoHandler = ssoHandler;
    }
    
    public HttpResponse serve(ServiceRequestContext ctx, AggregatedHttpRequest req, String defaultHostname, SamlPortConfig portConfig) {
        try {
            final MessageContext<Response> messageContext;
            if (cfg.endpoint().bindingProtocol() == SamlBindingProtocol.HTTP_REDIRECT) {
                messageContext = HttpRedirectBindingUtil.toSamlObject(req, SAML_RESPONSE, idpConfigs, defaultIdpConfig);
            }
             else {
                messageContext = HttpPostBindingUtil.toSamlObject(req, SAML_RESPONSE);
            }
            
            final String endpointUri = cfg.endpoint().toUriString(portConfig.scheme().uriText(), defaultHostname, portConfig.port());
            final Response response = messageContext.getMessage();
            final Assertion assertion = getValidatedAssertion(response, endpointUri);
            final String sessionIndex = assertion.getAuthnStatements().stream() .map(AuthnStatement::getSessionIndex) .filter(Objects::nonNull) .findFirst().orElse(null);
            final SAMLBindingContext bindingContext = messageContext.getSubcontext(SAMLBindingContext.class);
            final String relayState = bindingContext != null ? bindingContext.getRelayState() : null;
            return ssoHandler.loginSucceeded(ctx, req, messageContext, sessionIndex, relayState);
        }
         catch (SamlException e) {
            return ssoHandler.loginFailed(ctx, req, null, e);
        }
        
    }
    
    private SamlIdentityProviderConfig resolveIdpConfig(Issuer issuer) {
        final String value = issuer.getValue();
        if (value != null) {
            final SamlIdentityProviderConfig config = idpConfigs.get(value);
            if (config != null) {
                return config;
            }
            
        }
        
        throw new InvalidSamlRequestException("failed to find identity provider from configuration: " + issuer.getValue());
    }
    
    private Assertion getValidatedAssertion(Response response, String endpointUri) {
        final Status status = response.getStatus();
        final String statusCode = status.getStatusCode().getValue();
        if (!StatusCode.SUCCESS.equals(statusCode)) {
            throw new InvalidSamlRequestException("response status code: " + statusCode + " (expected: " + StatusCode.SUCCESS + ')');
        }
        
        final DateTime now = new DateTime();
        final DateTime issueInstant = response.getIssueInstant();
        if (issueInstant == null) {
            throw new InvalidSamlRequestException("failed to get IssueInstant attribute");
        }
        
        if (Math.abs(now.getMillis() - issueInstant.getMillis()) > MILLIS_IN_MINUTE) {
            throw new InvalidSamlRequestException("invalid IssueInstant: " + issueInstant + " (now: " + now + ')');
        }
        
        final List<Assertion> assertions;
        if (response.getEncryptedAssertions().isEmpty()) {
            assertions = response.getAssertions();
        }
         else {
            final SamlIdentityProviderConfig idp;
            final Issuer issuer = response.getIssuer();
            if (issuer != null) {
                idp = resolveIdpConfig(issuer);
            }
             else {
                if (defaultIdpConfig == null) {
                    throw new SamlException("failed to decrypt an assertion because there is no credential");
                }
                
                idp = defaultIdpConfig;
            }
            
            final ImmutableList.Builder<Assertion> builder = new ImmutableList.Builder<>();
            for (final EncryptedAssertion encryptedAssertion : response.getEncryptedAssertions()) {
                builder.add(decryptAssertion(encryptedAssertion, idp.encryptionCredential()));
            }
            
            builder.addAll(response.getAssertions());
            assertions = builder.build();
        }
        
        if (assertions.isEmpty()) {
            throw new InvalidSamlRequestException("failed to get Assertion elements from the response");
        }
        
        for (final Assertion assertion : assertions) {
            final Issuer issuer = assertion.getIssuer();
            if (issuer == null || issuer.getValue() == null) {
                throw new InvalidSamlRequestException("failed to get an Issuer element from the assertion");
            }
            
            final SamlIdentityProviderConfig idp = resolveIdpConfig(issuer);
            validateSignature(idp.signingCredential(), response);
            validateSignature(idp.signingCredential(), assertion);
            final List<AuthnStatement> authnStatements = assertion.getAuthnStatements();
            if (authnStatements.isEmpty()) {
                continue;
            }
            
            final Subject subject = assertion.getSubject();
            if (subject == null) {
                continue;
            }
            
            final List<SubjectConfirmation> subjectConfirmations = subject.getSubjectConfirmations();
            for (final SubjectConfirmation subjectConfirmation : subjectConfirmations) {
                if (!"urn:oasis:names:tc:SAML:2.0:cm:bearer".equals(subjectConfirmation.getMethod())) {
                    continue;
                }
                
                final SubjectConfirmationData data = subjectConfirmation.getSubjectConfirmationData();
                if (data == null) {
                    continue;
                }
                
                if (!endpointUri.equals(data.getRecipient())) {
                    throw new InvalidSamlRequestException( "recipient is not matched: " + data.getRecipient());
                }
                
                if (now.isAfter(data.getNotOnOrAfter())) {
                    throw new InvalidSamlRequestException( "response has been expired: " + data.getNotOnOrAfter());
                }
                
                if (!requestIdManager.validateId(data.getInResponseTo())) {
                    throw new InvalidSamlRequestException( "request ID is not valid: " + data.getInResponseTo());
                }
                
                final Conditions conditions = assertion.getConditions();
                if (conditions == null) {
                    throw new InvalidSamlRequestException("no condition found from the assertion");
                }
                
                final Optional<Audience> audience = conditions.getAudienceRestrictions().stream() .flatMap(r -> r.getAudiences().stream()) .filter(audience0 -> entityId .equals(audience0.getAudienceURI())) .findAny();
                if (!audience.isPresent()) {
                    throw new InvalidSamlRequestException("no audience found from the assertion");
                }
                
                return assertion;
            }
            
        }
        
        throw new InvalidSamlRequestException("no subject found from the assertions");
    }
    
    private static Assertion decryptAssertion(EncryptedAssertion encryptedAssertion, Credential decryptionCredential) {
        final StaticKeyInfoCredentialResolver keyInfoCredentialResolver = new StaticKeyInfoCredentialResolver(decryptionCredential);
        final Decrypter decrypter = new Decrypter(null, keyInfoCredentialResolver, new InlineEncryptedKeyResolver());
        decrypter.setRootInNewDocument(true);
        try {
            return decrypter.decrypt(encryptedAssertion);
        }
         catch (DecryptionException e) {
            throw new InvalidSamlRequestException("failed to decrypt an assertion", e);
        }
        
    }
    
}


