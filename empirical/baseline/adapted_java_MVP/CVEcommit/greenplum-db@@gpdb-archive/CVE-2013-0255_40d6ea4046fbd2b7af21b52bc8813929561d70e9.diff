commit 40d6ea4046fbd2b7af21b52bc8813929561d70e9
Author: Heikki Linnakangas <hlinnakangas@pivotal.io>
Date:   Wed Jun 15 15:17:21 2016 +0300

    Backport the "proper" fix for CVE-2013-0255.
    
    The PostgreSQL 8.3 merge included a band-aid fix for this, but since we
    haven't yet made a GPDB 5.0 release, and are therefore free to still modify
    the catalogs, let's apply the proper fix that went into PostgreSQL 9.3 at
    the time.
    
    commit 71627f3d1964ef9831ea7997d2f4ac5617c718cc
    Author: Tom Lane <tgl@sss.pgh.pa.us>
    Date:   Wed Feb 13 16:20:01 2013 -0500
    
        Fix CVE-2013-0255 properly.
    
        Revert commit ab0f7b6089fd215f6ce6081e2e222c38d643a526 (in HEAD only)
        in favor of the proper solution, which is to declare enum_recv() correctly
        in the system catalogs.  It should be declared to take type "internal"
        not "cstring".
    
        Also improve the type_sanity regression test, which should have caught
        this typo, so that it actually would.  Most of the relevant checks on
        the signature of type I/O functions should not have been restricted to
        basetypes/pseudotypes, as they should apply to any type's I/O functions.

diff --git a/src/backend/utils/adt/enum.c b/src/backend/utils/adt/enum.c
index 40cf15f097..7604440129 100644
--- a/src/backend/utils/adt/enum.c
+++ b/src/backend/utils/adt/enum.c
@@ -101,10 +101,6 @@ enum_recv(PG_FUNCTION_ARGS)
 	char	   *name;
 	int			nbytes;
 
-	/* guard against pre-9.3 misdeclaration of enum_recv */
-	if (get_fn_expr_argtype(fcinfo->flinfo, 0) == CSTRINGOID)
-		elog(ERROR, "invalid argument for enum_recv");
-
 	name = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes);
 
 	/* must check length to prevent Assert failure within SearchSysCache */
diff --git a/src/include/catalog/pg_proc.h b/src/include/catalog/pg_proc.h
index 6d112af727..dda00c3832 100644
--- a/src/include/catalog/pg_proc.h
+++ b/src/include/catalog/pg_proc.h
@@ -4282,7 +4282,7 @@ DATA(insert OID = 3530 (  enum_range	PGNSP PGUID 12 1 0 f f f f s 2 2277 "3500 3
 DESCR("range between the two given enum values, as an ordered array");
 DATA(insert OID = 3531 (  enum_range	PGNSP PGUID 12 1 0 f f f f s 1 2277 "3500" _null_ _null_ _null_ enum_range_all - _null_ _null_ ));
 DESCR("range of the given enum type, as an ordered array");
-DATA(insert OID = 3532 (  enum_recv		PGNSP PGUID 12 1 0 f f t f s 2 3500 "2275 26" _null_ _null_ _null_ enum_recv - _null_ _null_ ));
+DATA(insert OID = 3532 (  enum_recv		PGNSP PGUID 12 1 0 f f t f s 2 3500 "2281 26" _null_ _null_ _null_ enum_recv - _null_ _null_ ));
 DESCR("I/O");
 DATA(insert OID = 3533 (  enum_send		PGNSP PGUID 12 1 0 f f t f s 1 17	"3500" _null_ _null_ _null_ enum_send - _null_ _null_ ));
 DESCR("I/O");
diff --git a/src/test/regress/expected/type_sanity.out b/src/test/regress/expected/type_sanity.out
index df4a18234c..acfab84844 100755
--- a/src/test/regress/expected/type_sanity.out
+++ b/src/test/regress/expected/type_sanity.out
@@ -91,8 +91,10 @@ WHERE (p1.typinput = 0 OR p1.typoutput = 0);
 -- Check for bogus typinput routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typinput = p2.oid AND NOT
     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'cstring'::regtype) OR
+     (p2.pronargs = 2 AND p2.proargtypes[0] = 'cstring'::regtype AND
+      p2.proargtypes[1] = 'oid'::regtype) OR
      (p2.pronargs = 3 AND p2.proargtypes[0] = 'cstring'::regtype AND
       p2.proargtypes[1] = 'oid'::regtype AND
       p2.proargtypes[2] = 'int4'::regtype));
@@ -117,7 +119,7 @@ ORDER BY 1;
 -- Exception as of 8.1: int2vector and oidvector have their own I/O routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND
+WHERE p1.typinput = p2.oid AND
     (p1.typelem != 0 AND p1.typlen < 0) AND NOT
     (p2.oid = 'array_in'::regproc)
 ORDER BY 1;
@@ -155,7 +157,7 @@ ORDER BY 1;
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typoutput = p2.oid AND NOT
     (p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
  oid | typname | oid | proname 
 -----+---------+-----+---------
@@ -164,8 +166,10 @@ WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
 -- Check for bogus typreceive routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typreceive = p2.oid AND NOT
     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'internal'::regtype) OR
+     (p2.pronargs = 2 AND p2.proargtypes[0] = 'internal'::regtype AND
+      p2.proargtypes[1] = 'oid'::regtype) OR
      (p2.pronargs = 3 AND p2.proargtypes[0] = 'internal'::regtype AND
       p2.proargtypes[1] = 'oid'::regtype AND
       p2.proargtypes[2] = 'int4'::regtype));
@@ -190,7 +194,7 @@ ORDER BY 1;
 -- Exception as of 8.1: int2vector and oidvector have their own I/O routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND
+WHERE p1.typreceive = p2.oid AND
     (p1.typelem != 0 AND p1.typlen < 0) AND NOT
     (p2.oid = 'array_recv'::regproc)
 ORDER BY 1;
@@ -236,7 +240,7 @@ ORDER BY 1;
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typsend = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typsend = p2.oid AND NOT
     (p2.prorettype = 'bytea'::regtype AND NOT p2.proretset);
  oid | typname | oid | proname 
 -----+---------+-----+---------
diff --git a/src/test/regress/sql/type_sanity.sql b/src/test/regress/sql/type_sanity.sql
index 7202a2fb07..7a3cb511c4 100644
--- a/src/test/regress/sql/type_sanity.sql
+++ b/src/test/regress/sql/type_sanity.sql
@@ -77,8 +77,10 @@ WHERE (p1.typinput = 0 OR p1.typoutput = 0);
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typinput = p2.oid AND NOT
     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'cstring'::regtype) OR
+     (p2.pronargs = 2 AND p2.proargtypes[0] = 'cstring'::regtype AND
+      p2.proargtypes[1] = 'oid'::regtype) OR
      (p2.pronargs = 3 AND p2.proargtypes[0] = 'cstring'::regtype AND
       p2.proargtypes[1] = 'oid'::regtype AND
       p2.proargtypes[2] = 'int4'::regtype));
@@ -96,7 +98,7 @@ ORDER BY 1;
 -- Exception as of 8.1: int2vector and oidvector have their own I/O routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typinput = p2.oid AND p1.typtype in ('b', 'p') AND
+WHERE p1.typinput = p2.oid AND
     (p1.typelem != 0 AND p1.typlen < 0) AND NOT
     (p2.oid = 'array_in'::regproc)
 ORDER BY 1;
@@ -123,15 +125,17 @@ ORDER BY 1;
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typoutput = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typoutput = p2.oid AND NOT
     (p2.prorettype = 'cstring'::regtype AND NOT p2.proretset);
 
 -- Check for bogus typreceive routines
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typreceive = p2.oid AND NOT
     ((p2.pronargs = 1 AND p2.proargtypes[0] = 'internal'::regtype) OR
+     (p2.pronargs = 2 AND p2.proargtypes[0] = 'internal'::regtype AND
+      p2.proargtypes[1] = 'oid'::regtype) OR
      (p2.pronargs = 3 AND p2.proargtypes[0] = 'internal'::regtype AND
       p2.proargtypes[1] = 'oid'::regtype AND
       p2.proargtypes[2] = 'int4'::regtype));
@@ -149,7 +153,7 @@ ORDER BY 1;
 -- Exception as of 8.1: int2vector and oidvector have their own I/O routines
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typreceive = p2.oid AND p1.typtype in ('b', 'p') AND
+WHERE p1.typreceive = p2.oid AND
     (p1.typelem != 0 AND p1.typlen < 0) AND NOT
     (p2.oid = 'array_recv'::regproc)
 ORDER BY 1;
@@ -182,7 +186,7 @@ ORDER BY 1;
 
 SELECT p1.oid, p1.typname, p2.oid, p2.proname
 FROM pg_type AS p1, pg_proc AS p2
-WHERE p1.typsend = p2.oid AND p1.typtype in ('b', 'p') AND NOT
+WHERE p1.typsend = p2.oid AND NOT
     (p2.prorettype = 'bytea'::regtype AND NOT p2.proretset);
 
 -- Check for bogus typmodin routines
