commit 97138128b4fc02cf296a07acc5d7145557a27782
diff --git a/src/herder/QuorumIntersectionCheckerImpl.cpp b/src/herder/QuorumIntersectionCheckerImpl.cpp
index 6b124e777..67dc8cbce 100644
--- a/src/herder/QuorumIntersectionCheckerImpl.cpp
+++ b/src/herder/QuorumIntersectionCheckerImpl.cpp
@@ -58,7 +58,8 @@ QBitSet::getSuccessors(BitSet const& nodes, QGraph const& inner)
 
 // Slightly tweaked variant of Lachowski's next-node function.
 size_t
-MinQuorumEnumerator::pickSplitNode() const
+MinQuorumEnumerator::pickSplitNode(
+    stellar::stellar_default_random_engine& randEngine) const
 {
     std::vector<size_t>& inDegrees = mQic.mInDegrees;
     inDegrees.assign(mQic.mGraph.size(), 0);
@@ -83,7 +84,7 @@ MinQuorumEnumerator::pickSplitNode() const
                     // currDegree same as existing max: replace it
                     // only probabilistically.
                     maxCount++;
-                    if (rand_uniform<size_t>(0, maxCount) == 0)
+                    if (rand_uniform<size_t>(0, maxCount, randEngine) == 0)
                     {
                         // Not switching max element with max degree.
                         continue;
@@ -236,7 +237,7 @@ MinQuorumEnumerator::anyMinQuorumHasDisjointQuorum()
     }
 
     // Phase two: recurse into subproblems.
-    size_t split = pickSplitNode();
+    size_t split = pickSplitNode(mQic.mRand);
     if (mQic.mLogTrace)
     {
         CLOG_TRACE(SCP, "recursing into subproblems, split={}", split);
@@ -276,6 +277,8 @@ QuorumIntersectionCheckerImpl::QuorumIntersectionCheckerImpl(
     , mInterruptFlag(interruptFlag)
     , mCachedQuorums(MAX_CACHED_QUORUMS_SIZE)
 {
+    assertThreadIsMain();
+    mRand.seed(stellar::gRandomEngine());
     buildGraph(qmap);
     // Awkwardly, the graph size is zero when we initialize mTSC. Update it
     // here.
diff --git a/src/herder/QuorumIntersectionCheckerImpl.h b/src/herder/QuorumIntersectionCheckerImpl.h
index d0443ace3..0a91545ff 100644
--- a/src/herder/QuorumIntersectionCheckerImpl.h
+++ b/src/herder/QuorumIntersectionCheckerImpl.h
@@ -427,7 +427,8 @@ class MinQuorumEnumerator
     QuorumIntersectionCheckerImpl const& mQic;
 
     // Select the next node in mRemaining to split recursive cases between.
-    size_t pickSplitNode() const;
+    size_t
+    pickSplitNode(stellar::stellar_default_random_engine& randEngine) const;
 
     // Size limit for mCommitted beyond which we should stop scanning.
     size_t maxCommit() const;
@@ -527,6 +528,8 @@ class QuorumIntersectionCheckerImpl : public stellar::QuorumIntersectionChecker
 
     friend class MinQuorumEnumerator;
 
+    mutable stellar::stellar_default_random_engine mRand;
+
   public:
     QuorumIntersectionCheckerImpl(
         stellar::QuorumIntersectionChecker::QuorumSetMap const& qmap,
diff --git a/src/util/Math.h b/src/util/Math.h
index ef2926052..0f6b3eabe 100644
--- a/src/util/Math.h
+++ b/src/util/Math.h
@@ -27,11 +27,18 @@ typedef std::minstd_rand stellar_default_random_engine;
 
 extern stellar_default_random_engine gRandomEngine;
 
+template <typename T>
+T
+rand_uniform(T lo, T hi, stellar_default_random_engine& engine)
+{
+    return stellar::uniform_int_distribution<T>(lo, hi)(engine);
+}
+
 template <typename T>
 T
 rand_uniform(T lo, T hi)
 {
-    return stellar::uniform_int_distribution<T>(lo, hi)(gRandomEngine);
+    return rand_uniform<T>(lo, hi, gRandomEngine);
 }
 
 template <typename T>
diff --git a/src/work/BasicWork.cpp b/src/work/BasicWork.cpp
index 928468ada..f47cf7287 100644
--- a/src/work/BasicWork.cpp
+++ b/src/work/BasicWork.cpp
@@ -80,7 +80,7 @@ std::string
 BasicWork::getStatus() const
 {
     // Work is in `WAITING` state when retrying
-    auto state = mRetryTimer ? InternalState::RETRYING : mState;
+    auto state = mRetryTimer ? InternalState::RETRYING : mState.load();
 
     switch (state)
     {
diff --git a/src/work/BasicWork.h b/src/work/BasicWork.h
index 8b5388217..b1618616b 100644
--- a/src/work/BasicWork.h
+++ b/src/work/BasicWork.h
@@ -91,6 +91,12 @@ class Application;
  * _batches_
  *  - WorkSequence: BasicWork that allows sequential execution of children
  * works.
+ *
+ * BasicWork is _not_ thread-safe, and therefore should not be used by threads.
+ * The only acceptable use case if when we need to spawn an independent work in
+ * the background (read from a file, download a file, etc), and post back to the
+ * main thread at the end, so Work can finish. In this case, only const
+ * functions querying Work's state are thread-safe.
  */
 
 class BasicWork : public std::enable_shared_from_this<BasicWork>,
@@ -243,7 +249,7 @@ class BasicWork : public std::enable_shared_from_this<BasicWork>,
     std::unique_ptr<VirtualTimer> mRetryTimer;
     std::unique_ptr<VirtualTimer> mWaitingTimer;
 
-    InternalState mState{InternalState::PENDING};
+    std::atomic<InternalState> mState{InternalState::PENDING};
     size_t mRetries{0};
     size_t const mMaxRetries{RETRY_A_FEW};
 
