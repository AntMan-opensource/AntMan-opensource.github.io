commit 4e5c5d2ed71cc9c34559e5fbeeb7f390661e530c
Author: Wouter Verhelst <w@uter.be>
Date:   Sun Mar 6 09:06:48 2022 +0200

    Properly handle name lengths of (unsigned int)-1
    
    When a user sends a name length value of 0xffffffff, nbd-server will try
    to allocate one more byte for the \0 at the end, but that will result in
    an integer overflow and a malloc(0), with the resulting write being to a
    dangling pointer.
    
    Fix by constraining the string size to 4096 bytes, as recommended by the
    protocol standard.
    
    This issue exists in NBD_OPT_INFO/NBD_OPT_GO handling as well as in
    NBD_OPT_EXPORT_NAME handling.
    
    CVE-2022-26495
    
    Reported-By: 王多 <duo.wang@chaitin.com>
    Signed-Off-By: Wouter Verhelst <w@uter.be>

diff --git a/nbd-server.c b/nbd-server.c
index f7f9fb5..be41760 100644
--- a/nbd-server.c
+++ b/nbd-server.c
@@ -2177,6 +2177,9 @@ static CLIENT* handle_export_name(CLIENT* client, uint32_t opt, GArray* servers,
 
 	socket_read(client, &namelen, sizeof(namelen));
 	namelen = ntohl(namelen);
+	if(namelen > 4096) {
+		return NULL;
+	}
 	if(namelen > 0) {
 		name = malloc(namelen+1);
 		name[namelen]=0;
@@ -2362,6 +2365,10 @@ static bool handle_info(CLIENT* client, uint32_t opt, GArray* servers, uint32_t
 		send_reply(client, opt, NBD_REP_ERR_INVALID, -1, "An OPT_INFO request cannot be smaller than the length of the name + 6");
 		consume(client, len - sizeof(namelen), buf, sizeof(buf));
 	}
+	if(namelen > 4096) {
+		send_reply(client, opt, NBD_REP_ERR_INVALID, -1, "The name for this OPT_INFO request is too long");
+		consume(client, namelen, buf, sizeof(buf));
+	}
 	if(namelen > 0) {
 		name = malloc(namelen + 1);
 		name[namelen] = 0;
