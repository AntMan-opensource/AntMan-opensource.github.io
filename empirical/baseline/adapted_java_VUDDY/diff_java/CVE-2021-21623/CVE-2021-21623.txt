commit bbe358575155912b818ab3c6e8b9623f21ad3418
Author: Daniel Beck <daniel-beck@users.noreply.github.com>
Date:   Wed Mar 10 22:38:49 2021 +0100

    [SECURITY-2180]

diff --git a/src/main/java/hudson/security/ProjectMatrixAuthorizationStrategy.java b/src/main/java/hudson/security/ProjectMatrixAuthorizationStrategy.java
index f5be235..85819cc 100644
--- a/src/main/java/hudson/security/ProjectMatrixAuthorizationStrategy.java
+++ b/src/main/java/hudson/security/ProjectMatrixAuthorizationStrategy.java
@@ -64,6 +64,7 @@ public class ProjectMatrixAuthorizationStrategy extends GlobalMatrixAuthorizatio
     }
 
     @Restricted(NoExternalUse.class)
+    @Deprecated // Unused since SECURITY-2180 fix, TODO insert specific versions
     public static ACL inheritingACL(final ACL parent, final ACL child) {
         if (parent instanceof SidACL && child instanceof SidACL) {
             return ((SidACL) child).newInheritingACL((SidACL) parent);
diff --git a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritGlobalStrategy.java b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritGlobalStrategy.java
index 57507d7..7bb31ec 100644
--- a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritGlobalStrategy.java
+++ b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritGlobalStrategy.java
@@ -24,14 +24,16 @@
 package org.jenkinsci.plugins.matrixauth.inheritance;
 
 import hudson.Extension;
+import hudson.model.Item;
 import hudson.security.ACL;
-import hudson.security.AccessControlled;
-import hudson.security.ProjectMatrixAuthorizationStrategy;
-import jenkins.model.Jenkins;
+import hudson.security.Permission;
+import org.acegisecurity.Authentication;
 import org.jenkinsci.Symbol;
 import org.kohsuke.stapler.DataBoundConstructor;
 
+import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import java.util.Arrays;
 
 /**
  * Strategy that inherits only the global ACL -- parent, grandparent, etc. ACLs are not inherited.
@@ -42,10 +44,31 @@ public class InheritGlobalStrategy extends InheritanceStrategy {
     public InheritGlobalStrategy() {
 
     }
-    
+
     @Override
-    public ACL getEffectiveACL(ACL acl, AccessControlled subject) {
-        return ProjectMatrixAuthorizationStrategy.inheritingACL(Jenkins.get().getAuthorizationStrategy().getRootACL(), acl);
+    protected boolean hasPermission(@Nonnull Authentication a, @Nonnull Permission permission, ACL child, @CheckForNull ACL parent, ACL root) {
+        if (a.equals(ACL.SYSTEM)) {
+            return true;
+        }
+        if (isParentReadPermissionRequired() && parent != null && (Item.READ.equals(permission) || Item.DISCOVER.equals(permission))) {
+            /*
+             * We need special handling for Read/Discover permissions to prevent SECURITY-2180:
+             * Item/Read is expected to only be effective if it is granted on every ancestor, similar to how permissions
+             * granted while lacking Overall/Read are pointless.
+             * If and only if we check for Item/Read or Item/Discover, do not fall back to the permission granted globally.
+             * No need to check #isUltimatelyImpliedByAdminister like NonInheritingStrategy does, we know it to be true for these permissions.
+             *
+             * This is a nested element.
+             * We need to ensure that all of the following are true:
+             * - The permission is granted in the parent
+             * - The permission is granted globally or explicitly on this element (the child)
+             */
+            final boolean grantedViaChild = child.hasPermission(a, permission);
+            final boolean grantedGlobally = root.hasPermission(a, permission);
+            final boolean grantedInParent = parent.hasPermission(a, permission);
+            return (grantedViaChild || grantedGlobally) && grantedInParent;
+        }
+        return child.hasPermission(a, permission) || root.hasPermission(a, permission);
     }
 
     @Symbol("inheritingGlobal")
diff --git a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritParentStrategy.java b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritParentStrategy.java
index f9e5098..2ac2f5e 100644
--- a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritParentStrategy.java
+++ b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritParentStrategy.java
@@ -25,15 +25,16 @@ package org.jenkinsci.plugins.matrixauth.inheritance;
 
 import hudson.Extension;
 import hudson.model.AbstractItem;
-import hudson.model.ItemGroup;
+import hudson.model.Item;
 import hudson.security.ACL;
-import hudson.security.AccessControlled;
-import hudson.security.ProjectMatrixAuthorizationStrategy;
-import jenkins.model.Jenkins;
+import hudson.security.Permission;
+import org.acegisecurity.Authentication;
 import org.jenkinsci.Symbol;
 import org.kohsuke.stapler.DataBoundConstructor;
 
+import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import java.util.Arrays;
 
 /**
  * Strategy that inherits the ACL from the parent.
@@ -48,19 +49,28 @@ public class InheritParentStrategy extends InheritanceStrategy {
     }
 
     @Override
-    public ACL getEffectiveACL(ACL acl, AccessControlled subject) {
-        if (subject instanceof AbstractItem) {
-            AbstractItem item = (AbstractItem) subject;
-            ItemGroup<?> parent = item.getParent();
-            final ACL parentACL;
-            if (parent instanceof AbstractItem) {
-                parentACL = Jenkins.get().getAuthorizationStrategy().getACL((AbstractItem) parent);
-            } else {
-                parentACL = Jenkins.get().getAuthorizationStrategy().getRootACL();
-            }
-            return ProjectMatrixAuthorizationStrategy.inheritingACL(parentACL, acl);
+    protected boolean hasPermission(@Nonnull Authentication a, @Nonnull Permission permission, ACL child, @CheckForNull ACL parent, ACL root) {
+        if (a.equals(ACL.SYSTEM)) {
+            return true;
+        }
+        if (isParentReadPermissionRequired() && parent != null && (Item.READ.equals(permission) || Item.DISCOVER.equals(permission))) {
+            /*
+             * If we have an item parent, only grant Item/Read and Item/Discover if it's granted on the parent.
+             * In this case, it doesn't even matter whether it's explicitly granted on the child.
+             */
+            return parent.hasPermission(a, permission);
+        }
+        if (parent == null) {
+            /*
+             * Without an item parent (i.e. topmost level item) we need to check both grants on this item, as
+             * well as grants on the root (parent) ACL:
+             * - Explicitly granted here but possibly not globally (on root): That's OK
+             * - NOT explicitly granted here, but globally: That's also OK
+             */
+            return root.hasPermission(a, permission) || child.hasPermission(a, permission);
         } else {
-            throw new IllegalArgumentException("Expected subject to be AbstractItem, but got " + subject);
+            /* If we have an item parent, check both explicit grants here and inherited permissions from parent. */
+            return parent.hasPermission(a, permission) || child.hasPermission(a, permission);
         }
     }
 
diff --git a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritanceStrategy.java b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritanceStrategy.java
index f39fa25..e77f76e 100644
--- a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritanceStrategy.java
+++ b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/InheritanceStrategy.java
@@ -25,14 +25,52 @@ package org.jenkinsci.plugins.matrixauth.inheritance;
 
 import hudson.ExtensionPoint;
 import hudson.model.AbstractDescribableImpl;
+import hudson.model.AbstractItem;
+import hudson.model.ItemGroup;
 import hudson.security.ACL;
 import hudson.security.AccessControlled;
+import hudson.security.Permission;
+import jenkins.model.Jenkins;
+import org.acegisecurity.Authentication;
+import org.kohsuke.accmod.Restricted;
+import org.kohsuke.accmod.restrictions.NoExternalUse;
+
+import javax.annotation.CheckForNull;
+import javax.annotation.Nonnull;
 
 public abstract class InheritanceStrategy extends AbstractDescribableImpl<InheritanceStrategy> implements ExtensionPoint {
+    @Restricted(NoExternalUse.class)
+    /* package */ static boolean isParentReadPermissionRequired() {
+        // TODO Switch to SystemProperties in 2.236+
+        String propertyName = hudson.security.AuthorizationMatrixProperty.class.getName() + ".checkParentPermissions";
+        String value = System.getProperty(propertyName);
+        if (value == null) {
+            return true;
+        }
+        return Boolean.parseBoolean(value);
+    }
+
     @Override
     public InheritanceStrategyDescriptor getDescriptor() {
         return (InheritanceStrategyDescriptor) super.getDescriptor();
     }
 
-    public abstract ACL getEffectiveACL(ACL acl, AccessControlled subject);
+    @CheckForNull
+    private ACL getParentItemACL(AccessControlled accessControlled) {
+        ACL parentACL = null;
+        if (accessControlled instanceof AbstractItem) {
+            AbstractItem item = (AbstractItem) accessControlled;
+            ItemGroup<?> parent = item.getParent();
+            if (parent instanceof AbstractItem) {
+                parentACL = Jenkins.get().getAuthorizationStrategy().getACL((AbstractItem) parent);
+            }
+        }
+        return parentACL;
+    }
+
+    public ACL getEffectiveACL(final ACL acl, final AccessControlled subject) {
+        return ACL.lambda((a, p) -> hasPermission(a, p, acl, getParentItemACL(subject), Jenkins.get().getAuthorizationStrategy().getRootACL()));
+    }
+
+    protected abstract boolean hasPermission(@Nonnull Authentication a, @Nonnull Permission permission, ACL child, @CheckForNull ACL parent, ACL root);
 }
diff --git a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/NonInheritingStrategy.java b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/NonInheritingStrategy.java
index 8a3b430..72e3d69 100644
--- a/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/NonInheritingStrategy.java
+++ b/src/main/java/org/jenkinsci/plugins/matrixauth/inheritance/NonInheritingStrategy.java
@@ -24,15 +24,17 @@
 package org.jenkinsci.plugins.matrixauth.inheritance;
 
 import hudson.Extension;
+import hudson.model.Item;
 import hudson.security.ACL;
-import hudson.security.AccessControlled;
 import hudson.security.Permission;
 import jenkins.model.Jenkins;
 import org.acegisecurity.Authentication;
 import org.jenkinsci.Symbol;
 import org.kohsuke.stapler.DataBoundConstructor;
 
+import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import java.util.Arrays;
 
 /**
  * Strategy that disables inheritance except for the globally defined Administer permission.
@@ -45,30 +47,39 @@ public class NonInheritingStrategy extends InheritanceStrategy {
     }
 
     @Override
-    public ACL getEffectiveACL(ACL acl, AccessControlled subject) {
-        final ACL rootACL = Jenkins.get().getAuthorizationStrategy().getRootACL();
-        return new ACL() {
-            @Override
-            public boolean hasPermission(@Nonnull Authentication a, @Nonnull Permission permission) {
-                /*
-                    I see two possible approaches here:
-                    One would be to just grant every permission if the root ACL grants Administer.
-                    This could result in weird situations where disabling inheritance would grant permissions like the optional
-                    Run/Artifacts permission not implied by anything else.
-                    The chosen, second approach checks whether the given permission is ultimately (transitively) implied by
-                    Administer, and, if so, grants it if the user has Administer.
-                    As this is a tree, any permission implication rooted in Administer should then be granted to administrators.
-                     */
-                return isUltimatelyImpliedByAdminister(permission) && rootACL.hasPermission(a, Jenkins.ADMINISTER) || acl.hasPermission(a, permission);
-            }
+    protected boolean hasPermission(@Nonnull Authentication a, @Nonnull Permission permission, ACL child, @CheckForNull ACL parent, ACL root) {
+        if (a.equals(ACL.SYSTEM)) {
+            return true;
+        }
+        if (isUltimatelyImpliedByAdminister(permission) && root.hasPermission(a, Jenkins.ADMINISTER)) {
+            /*
+             * I see two possible approaches here:
+             * One would be to just grant every permission if the root ACL grants Administer.
+             * This could result in weird situations where disabling inheritance would grant permissions like the optional
+             * Run/Artifacts permission not implied by anything else.
+             * The chosen, second approach checks whether the given permission is ultimately (transitively) implied by
+             * Administer, and, if so, grants it if the user has Administer.
+             * As this is a tree, any permission implication rooted in Administer should then be granted to administrators.
+             */
+            return true;
+        }
+        if (isParentReadPermissionRequired() && parent != null && (Item.READ.equals(permission) || Item.DISCOVER.equals(permission))) {
+            /*
+             * We are not inheriting permissions from the parent, but we only grant Read permission if the parent
+             * also has Read permission.
+             */
+            return parent.hasPermission(a, permission) && child.hasPermission(a, permission);
+        } else {
+            /* Only grant permission if it is explicitly granted here. */
+            return child.hasPermission(a, permission);
+        }
+    }
 
-            private boolean isUltimatelyImpliedByAdminister(Permission permission) {
-                while (permission.impliedBy != null) {
-                    permission = permission.impliedBy;
-                }
-                return permission == Jenkins.ADMINISTER;
-            }
-        };
+    private static boolean isUltimatelyImpliedByAdminister(Permission permission) {
+        while (permission.impliedBy != null) {
+            permission = permission.impliedBy;
+        }
+        return permission == Jenkins.ADMINISTER;
     }
 
     @Symbol("nonInheriting")
diff --git a/src/test/java/org/jenkinsci/plugins/matrixauth/Security2180Test.java b/src/test/java/org/jenkinsci/plugins/matrixauth/Security2180Test.java
new file mode 100644
index 0000000..6a8184e
--- /dev/null
+++ b/src/test/java/org/jenkinsci/plugins/matrixauth/Security2180Test.java
@@ -0,0 +1,470 @@
+package org.jenkinsci.plugins.matrixauth;
+
+import com.cloudbees.hudson.plugins.folder.Folder;
+import com.gargoylesoftware.htmlunit.Page;
+import com.gargoylesoftware.htmlunit.html.HtmlPage;
+import hudson.model.Cause;
+import hudson.model.FreeStyleBuild;
+import hudson.model.FreeStyleProject;
+import hudson.model.Item;
+import hudson.model.TopLevelItem;
+import hudson.model.TopLevelItemDescriptor;
+import hudson.security.ACL;
+import hudson.security.AuthorizationMatrixProperty;
+import hudson.security.Permission;
+import hudson.security.ProjectMatrixAuthorizationStrategy;
+import jenkins.model.DirectlyModifiableTopLevelItemGroup;
+import jenkins.model.Jenkins;
+import org.jenkinsci.plugins.matrixauth.inheritance.InheritGlobalStrategy;
+import org.jenkinsci.plugins.matrixauth.inheritance.InheritParentStrategy;
+import org.jenkinsci.plugins.matrixauth.inheritance.InheritanceStrategy;
+import org.jenkinsci.plugins.matrixauth.inheritance.NonInheritingStrategy;
+import org.junit.Assert;
+import org.junit.Rule;
+import org.junit.Test;
+import org.jvnet.hudson.test.JenkinsRule;
+import org.jvnet.hudson.test.SleepBuilder;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.not;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class Security2180Test {
+    private static final String BUILD_CONTENT = "Started by user";
+    private static final String JOB_CONTENT = "Full project name: folder/job";
+    private static final Map<Permission, Set<String>> ANONYMOUS_CAN_ITEM_READ = Collections.singletonMap(Item.READ, Collections.singleton("anonymous"));
+
+    @Rule
+    public JenkinsRule j = new JenkinsRule();
+
+    /**
+     * Helper method that creates a nested folder structure: Each parameter but the last creates a folder, the last one
+     * creates a freestyle job. Every non-null argument will be added as that item's property.
+     * For example, to create just a job on the top level, pass a single argument, non-null if you want a job property.
+     * For nulls will create a nested folder structure like folder1/folder2/folder3/item4 and none of them will have properties.
+     * @param containers the {@link AuthorizationContainer}s to set for the corresponding nested folder or job.
+     * @return The job inside the innermost folder, if any
+     * @throws Exception when anything goes wrong
+     */
+    private FreeStyleProject prepareNestedProject(AuthorizationContainer ... containers) throws Exception {
+        int nestingLevel = containers.length;
+
+        DirectlyModifiableTopLevelItemGroup parent = j.jenkins;
+
+        TopLevelItem job = null;
+
+        for (int i = 0; i < nestingLevel; i++) {
+            final AuthorizationContainer container = containers[i];
+            if (i == nestingLevel - 1) {
+                // Create a job at the nested-most level
+                final TopLevelItem project = parent.createProject(TopLevelItemDescriptor.all().get(FreeStyleProject.DescriptorImpl.class), "item" + i, false);
+                final FreeStyleProject freestyleProject = (FreeStyleProject) project;
+                freestyleProject.getBuildersList().add(new SleepBuilder(100000));
+                if (container != null) {
+                    freestyleProject.addProperty((AuthorizationMatrixProperty) container);
+                }
+                freestyleProject.save();
+                job = project;
+            } else {
+                // Create folder
+                final TopLevelItem folder = parent.createProject(TopLevelItemDescriptor.all().get(Folder.DescriptorImpl.class), "folder" + i, false);
+                if (container != null) {
+                    ((Folder) folder).addProperty((com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty) container);
+                }
+                folder.save();
+                parent = (Folder) folder;
+            }
+        }
+
+        return (FreeStyleProject)job;
+    }
+
+    /**
+     * This triggers builds, so should only be called once. A single test may call this multiple times, each with a
+     * different job, but care needs to be taken to ensure there are enough executors to schedule a build.
+     */
+    // We can save a lot of time by only asserting permission checks, not full WebClient page content, but for now keep it in just in case.
+    private void assertJobVisibility(FreeStyleProject job, boolean visibleWithFix, boolean visibleWithEscapeHatch) throws Exception {
+        final String jobUrl = job.getUrl();
+        // TODO robustness: check queue contents / executor status before scheduling
+        job.scheduleBuild2(0, new Cause.UserIdCause("admin")).waitForStart(); // schedule one build now
+        job.scheduleBuild2(0, new Cause.UserIdCause("admin")); // schedule an additional queue item
+        Assert.assertEquals(1, Jenkins.get().getQueue().getItems().length); // expect there to be one queue item
+
+        final JenkinsRule.WebClient webClient = j.createWebClient().withThrowExceptionOnFailingStatusCode(false);
+
+        { // UI
+            final HtmlPage htmlPage = webClient.goTo("");
+            final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+            if (visibleWithFix) {
+                assertTrue(job.hasPermission(Jenkins.ANONYMOUS, Item.READ));
+                assertTrue(job.hasPermission(ACL.SYSTEM, Item.READ));
+                assertThat(contentAsString, containsString(jobUrl));
+            } else {
+                assertFalse(job.hasPermission(Jenkins.ANONYMOUS, Item.READ));
+                assertTrue(job.hasPermission(ACL.SYSTEM, Item.READ));
+                assertThat(contentAsString, not(containsString(jobUrl)));
+            }
+        }
+        // TODO check API?
+
+        final String propertyName = hudson.security.AuthorizationMatrixProperty.class.getName() + ".checkParentPermissions";
+        try {
+            System.setProperty(propertyName, "false");
+            { // UI
+                final HtmlPage htmlPage = webClient.goTo("");
+                final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+                if (visibleWithEscapeHatch) {
+                    assertTrue(job.hasPermission(Jenkins.ANONYMOUS, Item.READ));
+                    assertTrue(job.hasPermission(ACL.SYSTEM, Item.READ));
+                    assertThat(contentAsString, containsString(jobUrl));
+                } else {
+                    assertFalse(job.hasPermission(Jenkins.ANONYMOUS, Item.READ));
+                    assertTrue(job.hasPermission(ACL.SYSTEM, Item.READ));
+                    assertThat(contentAsString, not(containsString(jobUrl)));
+                }
+            }
+        } finally {
+            System.clearProperty(propertyName);
+        }
+    }
+
+    private void prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Permission... extraPermissions) {
+        j.jenkins.setSecurityRealm(j.createDummySecurityRealm());
+        final ProjectMatrixAuthorizationStrategy strategy = new ProjectMatrixAuthorizationStrategy();
+        strategy.add(Jenkins.READ, "anonymous");
+        strategy.add(Jenkins.ADMINISTER, "admin");
+        for (Permission permission : extraPermissions) {
+            strategy.add(permission, "anonymous");
+        }
+        j.jenkins.setAuthorizationStrategy(strategy);
+    }
+
+    private FreeStyleProject createFreeStyleProjectWithReadPermissionForAnonymousInFolder(Folder folder) throws java.io.IOException {
+        FreeStyleProject job = folder.createProject(FreeStyleProject.class, "job");
+        job.getBuildersList().add(new SleepBuilder(100000));
+        job.addProperty(new AuthorizationMatrixProperty(Collections.singletonMap(Item.READ, Collections.singleton("anonymous"))));
+        job.save();
+        return job;
+    }
+
+    private com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty createFolderProperty(Map<Permission, Set<String>> permissionSetMap) {
+        return createFolderProperty(permissionSetMap, new InheritParentStrategy());
+    }
+
+    private com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty createFolderProperty(Map<Permission, Set<String>> permissionSetMap, InheritanceStrategy inheritanceStrategy) {
+        com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty property = new com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty(permissionSetMap);
+        if (inheritanceStrategy != null) {
+            property.setInheritanceStrategy(inheritanceStrategy);
+        }
+        return property;
+    }
+
+    private AuthorizationMatrixProperty createJobProperty(Map<Permission, Set<String>> permissionSetMap) {
+        return createJobProperty(permissionSetMap, new InheritParentStrategy());
+    }
+
+    private AuthorizationMatrixProperty createJobProperty(Map<Permission, Set<String>> permissionSetMap, InheritanceStrategy inheritanceStrategy) {
+        AuthorizationMatrixProperty property = new AuthorizationMatrixProperty(permissionSetMap);
+        if (inheritanceStrategy != null) {
+            property.setInheritanceStrategy(inheritanceStrategy);
+        }
+        return property;
+    }
+
+
+    @Test
+    public void testQueuePath() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(null, new AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ));
+
+        job.scheduleBuild2(1000, new Cause.UserIdCause("admin"));
+        Assert.assertEquals(1, Jenkins.get().getQueue().getItems().length);
+
+        final JenkinsRule.WebClient webClient = j.createWebClient().withThrowExceptionOnFailingStatusCode(false);
+        final HtmlPage htmlPage = webClient.goTo("queue/items/0/task/");
+        final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+        assertThat(contentAsString, not(containsString(JOB_CONTENT))); // Fails while unfixed
+    }
+
+    @Test
+    public void testQueueContent() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(null, new AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ));
+
+        job.scheduleBuild2(1000, new Cause.UserIdCause("admin"));
+        Assert.assertEquals(1, Jenkins.get().getQueue().getItems().length);
+
+        final JenkinsRule.WebClient webClient = j.createWebClient();
+        final Page page = webClient.goTo("queue/api/xml/", "application/xml");
+        final String xml = page.getWebResponse().getContentAsString();
+        assertThat(xml, not(containsString(job.getUrl()))); // Fails while unfixed
+    }
+
+    @Test
+    public void testExecutorsPath() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(null, new AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ));
+
+        final FreeStyleBuild build = job.scheduleBuild2(0, new Cause.UserIdCause("admin")).waitForStart();
+        final int number = Objects.requireNonNull(build.getExecutor()).getNumber();
+
+        final JenkinsRule.WebClient webClient = j.createWebClient().withThrowExceptionOnFailingStatusCode(false);
+        final HtmlPage htmlPage = webClient.goTo("computer/(master)/executors/" + number + "/currentExecutable/");
+        final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+        assertThat(contentAsString, not(containsString(BUILD_CONTENT))); // Fails while unfixed
+    }
+
+    @Test
+    public void testExecutorsContent() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        Folder folder = j.jenkins.createProject(Folder.class, "folder");
+        FreeStyleProject job = createFreeStyleProjectWithReadPermissionForAnonymousInFolder(folder);
+
+        job.scheduleBuild2(0, new Cause.UserIdCause("admin")).waitForStart();
+
+        final JenkinsRule.WebClient webClient = j.createWebClient();
+        final Page page = webClient.goTo("computer/(master)/api/xml?depth=1", "application/xml");
+        final String xml = page.getWebResponse().getContentAsString();
+        assertThat(xml, not(containsString("job/folder/job/job"))); // Fails while unfixed
+    }
+
+    @Test
+    public void testWidgets() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ)
+        );
+
+        job.scheduleBuild2(0, new Cause.UserIdCause("admin")).waitForStart(); // schedule one build now
+        job.scheduleBuild2(0, new Cause.UserIdCause("admin")); // schedule an additional queue item
+        Assert.assertEquals(1, Jenkins.get().getQueue().getItems().length); // expect there to be one queue item
+
+        final JenkinsRule.WebClient webClient = j.createWebClient().withThrowExceptionOnFailingStatusCode(false);
+
+        final HtmlPage htmlPage = webClient.goTo("");
+        final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+        assertThat(contentAsString, not(containsString("job/folder/job/job"))); // Fails while unfixed
+    }
+
+    @Test
+    public void testTwoNestedFolderWithSecondGrantingAccess() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                new com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ),
+                new AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ));
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testThreeNestedFolderWithSecondGrantingAccess() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(
+                null, // folder does not allow Item/Read for anon
+                new com.cloudbees.hudson.plugins.folder.properties.AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ), // folder2 allows Item/Read for anon but should not matter
+                null, // folder3 inherits from parent
+                new AuthorizationMatrixProperty(ANONYMOUS_CAN_ITEM_READ));
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testGlobalItemReadBlockedByNonInheritingStrategyOnJob() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                createJobProperty(Collections.emptyMap(), new NonInheritingStrategy())
+        );
+        assertJobVisibility(job, false, false);
+    }
+
+    @Test
+    public void testGlobalItemReadBlockedByNonInheritingStrategyOnMiddleFolder() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                createFolderProperty(Collections.emptyMap(), new NonInheritingStrategy()),
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ),
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ)
+        );
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testInheritGlobalMiddleFolderInheritParentInnerFolder() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        // Global( Item/Read ) -> folder (no prop) -> folder2 (prop inherits global) -> folder3 (prop inherits parent, grants Read) -> job (grants Read)
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ),
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ));
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testNonInheritingOuterFolderBlocksInheritGlobalInnerFolder() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        // Global( Item/Read ) -> folder (do not inherit) -> folder2 (prop inherits global) -> folder3 (prop inherits parent, grants Read) -> job (grants Read)
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new NonInheritingStrategy()),
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ),
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ)
+        );
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testInheritGlobalInFolderInheritParentAndExplicitGrantInItem() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ, new InheritParentStrategy())
+        );
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testInheritGlobalInFolderInheritParentWithoutExplicitGrantInItem_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritParentStrategy())
+        );
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testExplicitNonInheritingThenInheritGlobalReadThenParent_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ, new NonInheritingStrategy()),
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritParentStrategy())
+        );
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testNonInheritingThenInheritGlobalReadThenParent_not_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new NonInheritingStrategy()),
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritParentStrategy())
+        );
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testExplicitNonInheritingThenInheritGlobalNonReadThenParent_not_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ, new NonInheritingStrategy()),
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritParentStrategy())
+        );
+        assertJobVisibility(job, false, false);
+    }
+
+    @Test
+    public void testExplicitNonInheritingThenInheritGlobalReadThenNonInheriting_not_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(ANONYMOUS_CAN_ITEM_READ, new NonInheritingStrategy()),
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new NonInheritingStrategy())
+        );
+        assertJobVisibility(job, false, false);
+    }
+
+    @Test
+    public void testInheritGlobalInFolderInheritParentWithoutExplicitGrantInItem2_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritParentStrategy())
+        );
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testInheritGlobalInFolderAndItem_visible() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous(Item.READ);
+        FreeStyleProject job = prepareNestedProject(
+                createFolderProperty(Collections.emptyMap(), new InheritGlobalStrategy()),
+                createJobProperty(Collections.emptyMap(), new InheritGlobalStrategy())
+        );
+        assertJobVisibility(job, true, true);
+    }
+
+    @Test
+    public void testNonInheritingItemWithExplicitGrantInsideNonGrantingFolder() throws Exception {
+        prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+
+        FreeStyleProject job = prepareNestedProject(
+                null,
+                createJobProperty(ANONYMOUS_CAN_ITEM_READ, new NonInheritingStrategy())
+        );
+        assertJobVisibility(job, false, true);
+    }
+
+    @Test
+    public void testEscapeHatch() throws Exception {
+        final String propertyName = hudson.security.AuthorizationMatrixProperty.class.getName() + ".checkParentPermissions";
+        try {
+            System.setProperty(propertyName, "false");
+
+            prepareJenkinsDefaultSetupWithOverallReadForAnonymous();
+            Folder folder = j.jenkins.createProject(Folder.class, "folder");
+            FreeStyleProject job = createFreeStyleProjectWithReadPermissionForAnonymousInFolder(folder);
+
+            job.scheduleBuild2(1000, new Cause.UserIdCause("admin"));
+            Assert.assertEquals(1, Jenkins.get().getQueue().getItems().length);
+
+            final JenkinsRule.WebClient webClient = j.createWebClient().withThrowExceptionOnFailingStatusCode(false);
+
+            { // queue related assertions
+                final HtmlPage htmlPage = webClient.goTo("queue/items/0/task/");
+                final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+                assertThat(contentAsString, containsString(JOB_CONTENT)); // Fails while unfixed
+
+                final Page page = webClient.goTo("queue/api/xml/", "application/xml");
+                final String xml = page.getWebResponse().getContentAsString();
+                assertThat(xml, containsString("job/folder/job/job")); // Fails while unfixed
+            }
+
+            final FreeStyleBuild build = job.scheduleBuild2(0, new Cause.UserIdCause("admin")).waitForStart();
+            final int number = Objects.requireNonNull(build.getExecutor()).getNumber();
+            Assert.assertEquals(0, Jenkins.get().getQueue().getItems().length); // collapsed queue items
+
+            { // executor related assertions
+                final HtmlPage htmlPage = webClient.goTo("computer/(master)/executors/" + number + "/currentExecutable/");
+                final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+                assertThat(contentAsString, containsString(BUILD_CONTENT)); // Fails while unfixed
+
+                final Page page = webClient.goTo("computer/(master)/api/xml?depth=1", "application/xml");
+                final String xml = page.getWebResponse().getContentAsString();
+                assertThat(xml, containsString("job/folder/job/job")); // Fails while unfixed
+            }
+
+            { // widget related assertions
+                final HtmlPage htmlPage = webClient.goTo("");
+                final String contentAsString = htmlPage.getWebResponse().getContentAsString();
+                assertThat(contentAsString, containsString("job/folder/job/job")); // Fails while unfixed
+            }
+
+        } finally {
+            System.clearProperty(propertyName);
+        }
+    }
+}
