commit 597b31afb473a40e8252de5b5def1876bab198d3
Author: Srikanth Reddy Lingala <srikanth.mailbox@gmail.com>
Date:   Sun Jan 15 11:19:55 2023 -0500

    #485 Check for MAC even when DataDescritor exists

diff --git a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
index 25d55cf..a58179f 100644
--- a/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
+++ b/src/main/java/net/lingala/zip4j/io/inputstream/AesCipherInputStream.java
@@ -4,9 +4,7 @@ import net.lingala.zip4j.crypto.AESDecrypter;
 import net.lingala.zip4j.exception.ZipException;
 import net.lingala.zip4j.model.AESExtraDataRecord;
 import net.lingala.zip4j.model.LocalFileHeader;
-import net.lingala.zip4j.model.enums.CompressionMethod;
 import net.lingala.zip4j.util.InternalZipConstants;
-import net.lingala.zip4j.util.Zip4jUtil;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -124,16 +122,6 @@ class AesCipherInputStream extends CipherInputStream<AESDecrypter> {
   }
 
   private void verifyContent(byte[] storedMac) throws IOException {
-    if (getLocalFileHeader().isDataDescriptorExists()
-        && CompressionMethod.DEFLATE.equals(Zip4jUtil.getCompressionMethod(getLocalFileHeader()))) {
-      // Skip content verification in case of Deflate compression and if data descriptor exists.
-      // In this case, we do not know the exact size of compressed data before hand and it is possible that we read
-      // and pass more than required data into inflater, thereby corrupting the aes mac bytes.
-      // See usage of PushBackInputStream in the project for how this push back of data is done
-      // Unfortunately, in this case we cannot perform a content verification and have to skip
-      return;
-    }
-
     byte[] calculatedMac = getDecrypter().getCalculatedAuthenticationBytes();
     byte[] first10BytesOfCalculatedMac = new byte[AES_AUTH_LENGTH];
     System.arraycopy(calculatedMac, 0, first10BytesOfCalculatedMac, 0, InternalZipConstants.AES_AUTH_LENGTH);
