commit 9e797b2f99617fdad0471eaa88c711ee7f44605f
Author: Bartosz Spyrko-Smietanko <bspyrkos@redhat.com>
Date:   Tue May 5 13:49:38 2020 +0100

    [UNDERTOW-1780][JBEAP-18537] Validating request headers in HTTP2 frames

diff --git a/core/src/main/java/io/undertow/server/Connectors.java b/core/src/main/java/io/undertow/server/Connectors.java
index 5c871c2b8..bc83aba15 100644
--- a/core/src/main/java/io/undertow/server/Connectors.java
+++ b/core/src/main/java/io/undertow/server/Connectors.java
@@ -52,6 +52,7 @@ import java.util.concurrent.RejectedExecutionException;
 public class Connectors {
 
     private static final boolean[] ALLOWED_TOKEN_CHARACTERS = new boolean[256];
+    private static final boolean[] ALLOWED_SCHEME_CHARACTERS = new boolean[256];
 
     static {
         for(int i = 0; i < ALLOWED_TOKEN_CHARACTERS.length; ++i) {
@@ -84,6 +85,25 @@ public class Connectors {
                 }
             }
         }
+
+        for(int i = 0; i < ALLOWED_SCHEME_CHARACTERS.length; ++i) {
+            if((i >='0' && i <= '9') ||
+                    (i >='a' && i <= 'z') ||
+                    (i >='A' && i <= 'Z')) {
+                ALLOWED_SCHEME_CHARACTERS[i] = true;
+            } else {
+                switch (i) {
+                    case '+':
+                    case '-':
+                    case '.': {
+                        ALLOWED_SCHEME_CHARACTERS[i] = true;
+                        break;
+                    }
+                    default:
+                        ALLOWED_SCHEME_CHARACTERS[i] = false;
+                }
+            }
+        }
     }
     /**
      * Flattens the exchange cookie map into the response header map. This should be called by a
@@ -547,6 +567,10 @@ public class Connectors {
         return ALLOWED_TOKEN_CHARACTERS[c];
     }
 
+    public static boolean isValidSchemeCharacter(byte c) {
+        return ALLOWED_SCHEME_CHARACTERS[c];
+    }
+
 
     /**
      * Verifies that the provided request headers are valid according to rfc7230. In particular:
diff --git a/core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java b/core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
index dc5d54452..7e7a4e64e 100644
--- a/core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
+++ b/core/src/main/java/io/undertow/server/protocol/http/HttpRequestParser.java
@@ -201,6 +201,10 @@ public abstract class HttpRequestParser {
         }
     }
 
+    public static boolean isTargetCharacterAllowed(char c) {
+        return ALLOWED_TARGET_CHARACTER[c];
+    }
+
     public HttpRequestParser(OptionMap options) {
         maxParameters = options.get(UndertowOptions.MAX_PARAMETERS, UndertowOptions.DEFAULT_MAX_PARAMETERS);
         maxHeaders = options.get(UndertowOptions.MAX_HEADERS, UndertowOptions.DEFAULT_MAX_HEADERS);
diff --git a/core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java b/core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
index 6986d4afc..1448a9f60 100644
--- a/core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
+++ b/core/src/main/java/io/undertow/server/protocol/http2/Http2ReceiveListener.java
@@ -18,6 +18,16 @@
 
 package io.undertow.server.protocol.http2;
 
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.function.Supplier;
+
+import static java.nio.charset.StandardCharsets.ISO_8859_1;
+
+import javax.net.ssl.SSLSession;
+
 import io.undertow.UndertowLogger;
 import io.undertow.UndertowOptions;
 import io.undertow.conduits.HeadStreamSinkConduit;
@@ -33,6 +43,7 @@ import io.undertow.server.HttpHandler;
 import io.undertow.server.HttpServerExchange;
 import io.undertow.server.protocol.http.HttpAttachments;
 import io.undertow.server.protocol.http.HttpContinue;
+import io.undertow.server.protocol.http.HttpRequestParser;
 import io.undertow.util.ConduitFactory;
 import io.undertow.util.HeaderMap;
 import io.undertow.util.HeaderValues;
@@ -48,14 +59,6 @@ import org.xnio.OptionMap;
 import org.xnio.channels.Channels;
 import org.xnio.conduits.StreamSinkConduit;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.charset.StandardCharsets;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.function.Supplier;
-
-import javax.net.ssl.SSLSession;
-
 import static io.undertow.protocols.http2.Http2Channel.AUTHORITY;
 import static io.undertow.protocols.http2.Http2Channel.METHOD;
 import static io.undertow.protocols.http2.Http2Channel.PATH;
@@ -152,6 +155,7 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
 
         final HttpServerExchange exchange = new HttpServerExchange(connection, dataChannel.getHeaders(), dataChannel.getResponseChannel().getHeaders(), maxEntitySize);
 
+
         dataChannel.setTrailersHandler(new Http2StreamSourceChannel.TrailersHandler() {
             @Override
             public void handleTrailers(HeaderMap headerMap) {
@@ -324,6 +328,38 @@ public class Http2ReceiveListener implements ChannelListener<Http2Channel> {
             }
         }
 
+        // verify content of request pseudo-headers. Each header should only have a single value.
+        if (headers.contains(PATH)) {
+            for (byte b: headers.get(PATH).getFirst().getBytes(ISO_8859_1)) {
+                if (!HttpRequestParser.isTargetCharacterAllowed((char)b)){
+                    return false;
+                }
+            }
+        }
+
+        if (headers.contains(SCHEME)) {
+            for (byte b: headers.get(SCHEME).getFirst().getBytes(ISO_8859_1)) {
+                if (!Connectors.isValidSchemeCharacter(b)){
+                    return false;
+                }
+            }
+        }
+
+        if (headers.contains(AUTHORITY)) {
+            for (byte b: headers.get(AUTHORITY).getFirst().getBytes(ISO_8859_1)) {
+                if (!HttpRequestParser.isTargetCharacterAllowed((char)b)){
+                    return false;
+                }
+            }
+        }
+
+        if (headers.contains(METHOD)) {
+            for (byte b: headers.get(METHOD).getFirst().getBytes(ISO_8859_1)) {
+                if (!Connectors.isValidTokenCharacter(b)){
+                    return false;
+                }
+            }
+        }
         return true;
     }
 }
