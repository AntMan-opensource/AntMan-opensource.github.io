commit 407cd6c826d4cea9123ea29c4ec458c1452b2901
Author: John Joyce <john@acryl.io>
Date:   Thu Sep 22 19:29:51 2022 -0700

    refactor(gms): Improving JWT parsing logic (#6025)

diff --git a/metadata-service/auth-impl/src/main/java/com/datahub/authentication/token/StatelessTokenService.java b/metadata-service/auth-impl/src/main/java/com/datahub/authentication/token/StatelessTokenService.java
index 3cc27673f85a..6ed22bfbe3ef 100644
--- a/metadata-service/auth-impl/src/main/java/com/datahub/authentication/token/StatelessTokenService.java
+++ b/metadata-service/auth-impl/src/main/java/com/datahub/authentication/token/StatelessTokenService.java
@@ -3,6 +3,7 @@ package com.datahub.authentication.token;
 import com.datahub.authentication.Actor;
 import com.datahub.authentication.ActorType;
 import io.jsonwebtoken.Claims;
+import io.jsonwebtoken.Jws;
 import io.jsonwebtoken.JwtBuilder;
 import io.jsonwebtoken.Jwts;
 import io.jsonwebtoken.SignatureAlgorithm;
@@ -128,11 +129,12 @@ public class StatelessTokenService {
     try {
       byte [] apiKeySecretBytes = this.signingKey.getBytes(StandardCharsets.UTF_8);
       final String base64Key = Base64.getEncoder().encodeToString(apiKeySecretBytes);
-      final Claims claims = (Claims) Jwts.parserBuilder()
+      final Jws<Claims> jws = Jwts.parserBuilder()
           .setSigningKey(base64Key)
           .build()
-          .parse(accessToken)
-          .getBody();
+          .parseClaimsJws(accessToken);
+      validateTokenAlgorithm(jws.getHeader().getAlgorithm());
+      final Claims claims = jws.getBody();
       final String tokenVersion = claims.get(TOKEN_VERSION_CLAIM_NAME, String.class);
       final String tokenType = claims.get(TOKEN_TYPE_CLAIM_NAME, String.class);
       final String actorId = claims.get(ACTOR_ID_CLAIM_NAME, String.class);
@@ -153,6 +155,14 @@ public class StatelessTokenService {
     throw new TokenException("Failed to validate DataHub token: Found malformed or missing 'actor' claim.");
   }
 
+  private void validateTokenAlgorithm(final String algorithm) throws TokenException {
+    try {
+      validateAlgorithm(algorithm);
+    } catch (UnsupportedOperationException e) {
+      throw new TokenException(String.format("Failed to validate signing algorithm for provided JWT! Found %s", algorithm));
+    }
+  }
+
   private SignatureAlgorithm validateAlgorithm(final String algorithm) {
     if (!SUPPORTED_ALGORITHMS.contains(algorithm)) {
       throw new UnsupportedOperationException(
diff --git a/metadata-service/auth-impl/src/test/java/com/datahub/authentication/token/StatelessTokenServiceTest.java b/metadata-service/auth-impl/src/test/java/com/datahub/authentication/token/StatelessTokenServiceTest.java
index 688ec5dc7e15..4268521a07c0 100644
--- a/metadata-service/auth-impl/src/test/java/com/datahub/authentication/token/StatelessTokenServiceTest.java
+++ b/metadata-service/auth-impl/src/test/java/com/datahub/authentication/token/StatelessTokenServiceTest.java
@@ -3,7 +3,16 @@ package com.datahub.authentication.token;
 import com.datahub.authentication.Actor;
 import com.datahub.authentication.ActorType;
 import com.datahub.authentication.authenticator.DataHubTokenAuthenticator;
+import io.jsonwebtoken.JwtBuilder;
+import io.jsonwebtoken.Jwts;
+import io.jsonwebtoken.SignatureAlgorithm;
+import java.nio.charset.StandardCharsets;
+import java.security.Key;
+import java.util.Date;
+import java.util.HashMap;
 import java.util.Map;
+import java.util.UUID;
+import javax.crypto.spec.SecretKeySpec;
 import org.testng.annotations.Test;
 
 import static com.datahub.authentication.token.TokenClaims.*;
@@ -117,4 +126,42 @@ public class StatelessTokenServiceTest {
     // Validation should fail.
     assertThrows(TokenException.class, () -> statelessTokenService.validateAccessToken(changedToken));
   }
+
+  @Test
+  public void testValidateAccessTokenFailsDueToNoneAlgorithm() {
+    // Token with none algorithm type.
+    String badToken =
+        "eyJhbGciOiJub25lIn0.eyJhY3RvclR5cGUiOiJVU0VSIiwiYWN0b3JJZCI6Il9fZGF0YWh1Yl9zeXN0ZW0iL"
+            + "CJ0eXBlIjoiU0VTU0lPTiIsInZlcnNpb24iOiIxIiwianRpIjoiN2VmOTkzYjQtMjBiOC00Y2Y5LTljNm"
+            + "YtMTE2NjNjZWVmOTQzIiwic3ViIjoiZGF0YWh1YiIsImlzcyI6ImRhdGFodWItbWV0YWRhdGEtc2VydmljZSJ9.";
+    StatelessTokenService statelessTokenService = new StatelessTokenService(TEST_SIGNING_KEY, "HS256");
+    // Validation should fail.
+    assertThrows(TokenException.class, () -> statelessTokenService.validateAccessToken(badToken));
+  }
+
+  @Test
+  public void testValidateAccessTokenFailsDueToUnsupportedSigningAlgorithm() throws Exception {
+    StatelessTokenService statelessTokenService = new StatelessTokenService(TEST_SIGNING_KEY, "HS256");
+
+    Map<String, Object> claims = new HashMap<>();
+    claims.put(TOKEN_VERSION_CLAIM_NAME, String.valueOf(TokenVersion.ONE.numericValue)); // Hardcode version 1 for now.
+    claims.put(TOKEN_TYPE_CLAIM_NAME, "SESSION");
+    claims.put(ACTOR_TYPE_CLAIM_NAME, "USER");
+    claims.put(ACTOR_ID_CLAIM_NAME, "__datahub_system");
+
+    final JwtBuilder builder = Jwts.builder()
+        .addClaims(claims)
+        .setId(UUID.randomUUID().toString())
+        .setIssuer("datahub-metadata-service")
+        .setSubject("datahub");
+     builder.setExpiration(new Date(System.currentTimeMillis() + 60));
+
+    final String testSigningKey = "TLHLdPSivAwIjXP4MT4TtlitsEGkOKjQGNnqsprisfghpU8g";
+    byte [] apiKeySecretBytes = testSigningKey.getBytes(StandardCharsets.UTF_8);
+    final Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS384.getJcaName());
+    final String badToken = builder.signWith(signingKey, SignatureAlgorithm.HS384).compact();
+
+    // Validation should fail.
+    assertThrows(TokenException.class, () -> statelessTokenService.validateAccessToken(badToken));
+  }
 }
