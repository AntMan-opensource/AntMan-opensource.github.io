commit d9c0e1fae3dbd10cf8dcad53abd5c9872e17eb9c
Author: Farah Juma <fjuma@redhat.com>
Date:   Tue Feb 13 15:42:11 2024 -0500

    [JBEAP-26556] CVE-2024-1233 Validate the jku header parameter during token validation to make sure it exactly matches a value from a configured list of allowed values

diff --git a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/_private/ElytronMessages.java b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/_private/ElytronMessages.java
index 3d23a845fe..229776e39a 100644
--- a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/_private/ElytronMessages.java
+++ b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/_private/ElytronMessages.java
@@ -98,5 +98,9 @@ public interface ElytronMessages extends BasicLogger {
     @LogMessage(level = WARN)
     @Message(id = 1181, value = "Not sending new request to jwks url \"%s\". Last request time was %d.")
     void avoidingFetchJwks(URL url, long timestamp);
+
+    @LogMessage(level = WARN)
+    @Message(id = 1182, value = "Allowed jku values haven't been configured for the JWT validator. Token validation will fail if the token contains a 'jku' header parameter.")
+    void allowedJkuValuesNotConfigured();
 }
 
diff --git a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwkManager.java b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwkManager.java
index cf4a8a80ef..71b889c065 100644
--- a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwkManager.java
+++ b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwkManager.java
@@ -41,6 +41,7 @@ import java.util.Base64;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Set;
 
 import static org.wildfly.security.auth.realm.token._private.ElytronMessages.log;
 
@@ -54,6 +55,7 @@ class JwkManager {
     private final Map<URL, CacheEntry> keys = new LinkedHashMap<>();
     private final SSLContext sslContext;
     private final HostnameVerifier hostnameVerifier;
+    private final Set<String> allowedJkuValues;
 
     private final long updateTimeout;
     private final int minTimeBetweenRequests;
@@ -61,13 +63,14 @@ class JwkManager {
     private final int connectionTimeout;
     private final int readTimeout;
 
-    JwkManager(SSLContext sslContext, HostnameVerifier hostnameVerifier, long updateTimeout, int connectionTimeout, int readTimeout, int minTimeBetweenRequests) {
+    JwkManager(SSLContext sslContext, HostnameVerifier hostnameVerifier, long updateTimeout, int connectionTimeout, int readTimeout, int minTimeBetweenRequests, Set<String> allowedJkuValues) {
         this.sslContext = sslContext;
         this.hostnameVerifier = hostnameVerifier;
         this.updateTimeout = updateTimeout;
         this.connectionTimeout = connectionTimeout;
         this.readTimeout = readTimeout;
         this.minTimeBetweenRequests = minTimeBetweenRequests;
+        this.allowedJkuValues = allowedJkuValues;
     }
 
     /**
diff --git a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwtValidator.java b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwtValidator.java
index adcea12fb4..d6cde8c6bb 100644
--- a/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwtValidator.java
+++ b/auth/realm/token/src/main/java/org/wildfly/security/auth/realm/token/validator/JwtValidator.java
@@ -77,6 +77,7 @@ public class JwtValidator implements TokenValidator {
 
     private final Set<String> issuers;
     private final Set<String> audiences;
+    private final Set<String> allowedJkuValues;
     private final JwkManager jwkManager;
     private final Map<String, PublicKey> namedKeys;
 
@@ -85,12 +86,14 @@ public class JwtValidator implements TokenValidator {
     JwtValidator(Builder configuration) {
         this.issuers = checkNotNullParam("issuers", configuration.issuers);
         this.audiences = checkNotNullParam("audience", configuration.audience);
+        this.allowedJkuValues = checkNotNullParam("allowedJkuValues", configuration.allowedJkuValues);
         this.defaultPublicKey = configuration.publicKey;
         this.namedKeys = configuration.namedKeys;
         if (configuration.sslContext != null) {
             this.jwkManager = new JwkManager(configuration.sslContext,
                                             configuration.hostnameVerifier != null ? configuration.hostnameVerifier : HttpsURLConnection.getDefaultHostnameVerifier(),
-                                            configuration.updateTimeout, configuration.connectionTimeout, configuration.readTimeout, configuration.minTimeBetweenRequests);
+                                            configuration.updateTimeout, configuration.connectionTimeout, configuration.readTimeout, configuration.minTimeBetweenRequests,
+                                            configuration.allowedJkuValues);
         }
         else {
             log.tokenRealmJwtNoSSLIgnoringJku();
@@ -106,6 +109,9 @@ public class JwtValidator implements TokenValidator {
         if (audiences.isEmpty()) {
             log.tokenRealmJwtWarnNoAudienceIgnoringAudienceCheck();
         }
+        if (allowedJkuValues.isEmpty()) {
+            log.allowedJkuValuesNotConfigured();
+        }
 
     }
 
@@ -311,6 +317,10 @@ public class JwtValidator implements TokenValidator {
                 log.debugf("Cannot validate token with jku [%s]. SSL is not configured and jku claim is not supported.", jku);
                 return null;
             }
+            if (! allowedJkuValues.contains(jku.getString())) {
+                log.debug("Cannot validate token, jku value is not allowed");
+                return null;
+            }
             try {
                 return jwkManager.getPublicKey(kid.getString(), new URL(jku.getString()));
             } catch (MalformedURLException e) {
@@ -340,6 +350,7 @@ public class JwtValidator implements TokenValidator {
 
         private Set<String> issuers = new LinkedHashSet<>();
         private Set<String> audience = new LinkedHashSet<>();
+        private Set<String> allowedJkuValues = new LinkedHashSet<>();
         private PublicKey publicKey;
         private Map<String, PublicKey> namedKeys = new LinkedHashMap<>();
         private HostnameVerifier hostnameVerifier;
@@ -495,6 +506,19 @@ public class JwtValidator implements TokenValidator {
             return this;
         }
 
+        /**
+         * One or more string values representing the jku values that are supported by this configuration.
+         * During JWT validation, if the jku header parameter is present in a token, it must exactly match
+         * one of the strings defined here or token validation will fail.
+         *
+         * @param allowedJkuValues the allowed values for the jku header parameter
+         * @return this instance
+         */
+        public Builder setAllowedJkuValues(String... allowedJkuValues) {
+            this.allowedJkuValues.addAll(asList(allowedJkuValues));
+            return this;
+        }
+
         /**
          * Returns a {@link JwtValidator} instance based on all the configuration provided with this builder.
          *
diff --git a/tests/base/src/test/java/org/wildfly/security/auth/realm/token/JwtSecurityRealmTest.java b/tests/base/src/test/java/org/wildfly/security/auth/realm/token/JwtSecurityRealmTest.java
index 25abd2a9b0..4827738fab 100644
--- a/tests/base/src/test/java/org/wildfly/security/auth/realm/token/JwtSecurityRealmTest.java
+++ b/tests/base/src/test/java/org/wildfly/security/auth/realm/token/JwtSecurityRealmTest.java
@@ -245,6 +245,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .setJkuTimeout(0) //refresh jwks every time
                         .setJkuMinTimeBetweenRequests(0)
                         .useSslContext(sslContext)
@@ -276,6 +277,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .setJkuTimeout(60000L) // 60s of cache
                         .setJkuMinTimeBetweenRequests(0) // no time betweeen requests
                         .useSslContext(sslContext)
@@ -309,6 +311,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .setJkuTimeout(60000L) // 60s of cache
                         .setJkuMinTimeBetweenRequests(10000) // 10s between calls
                         .useSslContext(sslContext)
@@ -352,6 +355,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .publicKeys(namedKeys)
                         .publicKey(keyPair3.getPublic())
                         .useSslContext(sslContext)
@@ -382,6 +386,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50832")
                         .useSslContext(sslContext)
                         .useSslHostnameVerifier((a,b) -> true).build())
                 .build();
@@ -429,6 +434,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .setJkuTimeout(0) //Keys will be downloaded on every request
                         .setJkuMinTimeBetweenRequests(0)
                         .useSslContext(sslContext)
@@ -457,6 +463,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .useSslContext(sslContext)
                         .useSslHostnameVerifier((a,b) -> true).build())
                 .build();
@@ -477,6 +484,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:80")
                         .useSslContext(sslContext).useSslHostnameVerifier((a,b) -> true).build())
                 .build();
 
@@ -496,6 +504,7 @@ public class JwtSecurityRealmTest {
                 .validator(JwtValidator.builder()
                         .issuer("elytron-oauth2-realm")
                         .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50831")
                         .useSslContext(sslContext)
                         .useSslHostnameVerifier((a,b) -> true).build())
                 .build();
@@ -722,6 +731,112 @@ public class JwtSecurityRealmTest {
         assertEquals("elytron@jboss.org", realmIdentity.getRealmIdentityPrincipal().getName());
     }
 
+    @Test
+    public void testTokenWithJkuValueAllowed() throws Exception {
+        BearerTokenEvidence evidence = new BearerTokenEvidence(
+                JwtTestUtil.createJwt(keyPair1, 60, -1, "1", new URI("https://localhost:50831")));
+
+        X509TrustManager tm = getTrustManager();
+        SSLContext sslContext = new SSLContextBuilder()
+                .setTrustManager(tm)
+                .setClientMode(true)
+                .setSessionTimeout(10)
+                .build()
+                .create();
+
+        TokenSecurityRealm securityRealm = TokenSecurityRealm.builder()
+                .principalClaimName("sub")
+                .validator(JwtValidator.builder()
+                        .issuer("elytron-oauth2-realm")
+                        .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50832", "https://localhost:50831")
+                        .useSslContext(sslContext)
+                        .useSslHostnameVerifier((a,b) -> true).build())
+                .build();
+
+        // token validation should succeed
+        assertIdentityExist(securityRealm, evidence);
+    }
+
+    @Test
+    public void testTokenWithJkuValueNotAllowed() throws Exception {
+        BearerTokenEvidence evidence = new BearerTokenEvidence(
+                JwtTestUtil.createJwt(keyPair1, 60, -1, "1", new URI("https://localhost:50834")));
+
+        X509TrustManager tm = getTrustManager();
+        SSLContext sslContext = new SSLContextBuilder()
+                .setTrustManager(tm)
+                .setClientMode(true)
+                .setSessionTimeout(10)
+                .build()
+                .create();
+
+        TokenSecurityRealm securityRealm = TokenSecurityRealm.builder()
+                .principalClaimName("sub")
+                .validator(JwtValidator.builder()
+                        .issuer("elytron-oauth2-realm")
+                        .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50832", "https://localhost:50831")
+                        .useSslContext(sslContext)
+                        .useSslHostnameVerifier((a,b) -> true).build())
+                .build();
+
+        // token validation should fail
+        assertIdentityNotExist(securityRealm, evidence);
+    }
+
+    @Test
+    public void testAllowedJkuValuesNotConfigured() throws Exception {
+        BearerTokenEvidence evidence = new BearerTokenEvidence(
+                JwtTestUtil.createJwt(keyPair1, 60, -1, "1", new URI("https://localhost:50831")));
+
+        X509TrustManager tm = getTrustManager();
+        SSLContext sslContext = new SSLContextBuilder()
+                .setTrustManager(tm)
+                .setClientMode(true)
+                .setSessionTimeout(10)
+                .build()
+                .create();
+
+        TokenSecurityRealm securityRealm = TokenSecurityRealm.builder()
+                .principalClaimName("sub")
+                .validator(JwtValidator.builder()
+                        .issuer("elytron-oauth2-realm")
+                        .audience("my-app-valid")
+                        .useSslContext(sslContext)
+                        .useSslHostnameVerifier((a,b) -> true).build())
+                .build();
+
+        // token validation should fail
+        assertIdentityNotExist(securityRealm, evidence);
+    }
+
+    @Test
+    public void testTokenWithoutJkuValue() throws Exception {
+        BearerTokenEvidence evidence1 = new BearerTokenEvidence(
+                createJwt(keyPair1, 60, -1, "1", null));
+        BearerTokenEvidence evidence2 = new BearerTokenEvidence(
+                createJwt(keyPair2, 60, -1, "2", null));
+
+        Map<String, PublicKey> namedKeys = new LinkedHashMap<>();
+        namedKeys.put("1", keyPair1.getPublic());
+        namedKeys.put("2", keyPair2.getPublic());
+
+        TokenSecurityRealm securityRealm = TokenSecurityRealm.builder()
+                .principalClaimName("sub")
+                .validator(JwtValidator.builder()
+                        .issuer("elytron-oauth2-realm")
+                        .audience("my-app-valid")
+                        .setAllowedJkuValues("https://localhost:50832", "https://localhost:50831")
+                        .publicKeys(namedKeys)
+                        .build())
+                .build();
+
+        // token validation should succeed
+        assertIdentityExist(securityRealm, evidence1);
+        assertIdentityExist(securityRealm, evidence2);
+    }
+
     private void assertIdentityNotExist(SecurityRealm realm, Evidence evidence) throws RealmUnavailableException {
         RealmIdentity identity = realm.getRealmIdentity(evidence);
         assertNotNull(identity);
