commit 340d769934219369c5f8045fc6244da867d37c68
Author: Uladzimir Asipchuk <vladimir.osipchuk@duallab.com>
Date:   Wed Aug 4 11:00:36 2021 +0300

    Improve input processing for ImageMagick and Ghostscript
    
    DEVSIX-5638

diff --git a/io/src/main/java/com/itextpdf/io/util/FileUtil.java b/io/src/main/java/com/itextpdf/io/util/FileUtil.java
index 418f26c19..4f53358ed 100644
--- a/io/src/main/java/com/itextpdf/io/util/FileUtil.java
+++ b/io/src/main/java/com/itextpdf/io/util/FileUtil.java
@@ -43,11 +43,6 @@
  */
 package com.itextpdf.io.util;
 
-import java.io.InputStream;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import org.slf4j.LoggerFactory;
-
 import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -55,6 +50,7 @@ import java.io.FileFilter;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
@@ -63,11 +59,15 @@ import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URISyntaxException;
 import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
+import org.slf4j.LoggerFactory;
 
 /**
  * This file is a helper class for internal usage only.
@@ -223,6 +223,86 @@ public final class FileUtil {
             return url.toURI().resolve(".").toString();
     }
 
+    /**
+     * Creates a temporary file.
+     *
+     * @param tempFilePrefix the prefix of the copied file's name
+     * @param tempFilePostfix the postfix of the copied file's name
+     *
+     * @return the path to the copied file
+     */
+    public static File createTempFile(String tempFilePrefix, String tempFilePostfix) throws IOException {
+        return File.createTempFile(tempFilePrefix, tempFilePostfix);
+    }
+
+    /**
+     * Creates a temporary copy of a file.
+     *
+     * @param file the path to the file to be copied
+     * @param tempFilePrefix the prefix of the copied file's name
+     * @param tempFilePostfix the postfix of the copied file's name
+     *
+     * @return the path to the copied file
+     */
+    public static String createTempCopy(String file, String tempFilePrefix, String tempFilePostfix)
+            throws IOException {
+        Path replacementFilePath = null;
+        try {
+            replacementFilePath = Files.createTempFile(tempFilePrefix, tempFilePostfix);
+            Path pathToPassedFile = Paths.get(file);
+            Files.copy(pathToPassedFile, replacementFilePath, StandardCopyOption.REPLACE_EXISTING);
+        } catch (IOException e) {
+            if (null != replacementFilePath) {
+                FileUtil.removeFiles(new String[] {replacementFilePath.toString()});
+            }
+            throw e;
+        }
+        return replacementFilePath.toString();
+    }
+
+    /**
+     * Creates a copy of a file.
+     *
+     * @param inputFile the path to the file to be copied
+     * @param outputFile the path, to which the passed file should be copied
+     */
+    public static void copy(String inputFile, String outputFile)
+            throws IOException {
+        Files.copy(Paths.get(inputFile), Paths.get(outputFile), StandardCopyOption.REPLACE_EXISTING);
+    }
+
+    /**
+     * Creates a temporary directory.
+     *
+     * @param tempFilePrefix the prefix of the temporary directory's name
+     * @return the path to the temporary directory
+     */
+    public static String createTempDirectory(String tempFilePrefix)
+            throws IOException {
+        return Files.createTempDirectory(tempFilePrefix).toString();
+    }
+
+    /**
+     * Removes all of the passed files.
+     *
+     * @param paths paths to files, which should be removed
+     *
+     * @return true if all the files have been successfully removed, false otherwise
+     */
+    public static boolean removeFiles(String[] paths) {
+        boolean allFilesAreRemoved = true;
+        for (String path : paths) {
+            try {
+                if (null != path) {
+                    Files.delete(Paths.get(path));
+                }
+            } catch (Exception e) {
+                allFilesAreRemoved = false;
+            }
+        }
+        return allFilesAreRemoved;
+    }
+
     private static class CaseSensitiveFileComparator implements Comparator<File> {
         @Override
         public int compare(File f1, File f2) {
diff --git a/io/src/main/java/com/itextpdf/io/util/GhostscriptHelper.java b/io/src/main/java/com/itextpdf/io/util/GhostscriptHelper.java
index 7aeaf05c1..8e34a5841 100644
--- a/io/src/main/java/com/itextpdf/io/util/GhostscriptHelper.java
+++ b/io/src/main/java/com/itextpdf/io/util/GhostscriptHelper.java
@@ -46,6 +46,8 @@ package com.itextpdf.io.util;
 import com.itextpdf.io.IoExceptionMessage;
 
 import java.io.IOException;
+import java.nio.file.Paths;
+import java.util.regex.Pattern;
 
 /**
  * A utility class that is used as an interface to run 3rd-party tool Ghostscript.
@@ -67,8 +69,14 @@ public class GhostscriptHelper {
     static final String GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY = "gsExec";
 
     static final String GHOSTSCRIPT_KEYWORD = "GPL Ghostscript";
+    private static final String TEMP_FILE_PREFIX = "itext_gs_io_temp";
 
-    private static final String GHOSTSCRIPT_PARAMS = " -dSAFER -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 {0} -sOutputFile=\"{1}\" \"{2}\"";
+    private static final String RENDERED_IMAGE_EXTENSION = "png";
+    private static final String GHOSTSCRIPT_PARAMS = " -dSAFER -dNOPAUSE -dBATCH -sDEVICE="
+            + RENDERED_IMAGE_EXTENSION + "16m -r150 {0} -sOutputFile=\"{1}\" \"{2}\"";
+    private static final String PAGE_NUMBER_PATTERN = "%03d";
+
+    private static final Pattern PAGE_LIST_REGEX = Pattern.compile("^(\\d+,)*\\d+$");
 
     private String gsExec;
 
@@ -112,11 +120,17 @@ public class GhostscriptHelper {
     }
 
     /**
-     * Runs ghostscript to create images of pdfs.
+     * Runs Ghostscript to render the PDF's pages as PNG images.
      *
-     * @param pdf    Path to the pdf file.
-     * @param outDir Path to the output directory
-     * @param image  Path to the generated image
+     * @param pdf    Path to the PDF file to be rendered
+     * @param outDir Path to the output directory, in which the rendered pages will be stored
+     * @param image  String which defines the name of the resultant images. This string will be
+     *               concatenated with the number of the rendered page from the start of the
+     *               PDF in "-%03d" format, e.g. "-011" for the eleventh rendered page and so on.
+     *               This number may not correspond to the actual page number: for example,
+     *               if the passed pageList equals to "5,3", then images with postfixes "-001.png"
+     *               and "-002.png" will be created: the former for the third page, the latter
+     *               for the fifth page. "%" sign in the passed name is prohibited.
      *
      * @throws IOException          if there are file's reading/writing issues
      * @throws InterruptedException if there is thread interruption while executing GhostScript.
@@ -127,14 +141,20 @@ public class GhostscriptHelper {
     }
 
     /**
-     * Runs ghostscript to create images of specified pages of pdfs.
+     * Runs Ghostscript to render the PDF's pages as PNG images.
      *
-     * @param pdf      Path to the pdf file.
-     * @param outDir   Path to the output directory
-     * @param image    Path to the generated image
-     * @param pageList String with numbers of the required pages to extract as image. Should be formatted as string with
-     *                 numbers, separated by commas, without whitespaces. Can be null, if it is required to extract
-     *                 all pages as images.
+     * @param pdf    Path to the PDF file to be rendered
+     * @param outDir Path to the output directory, in which the rendered pages will be stored
+     * @param image  String which defines the name of the resultant images. This string will be
+     *               concatenated with the number of the rendered page from the start of the
+     *               PDF in "-%03d" format, e.g. "-011" for the eleventh rendered page and so on.
+     *               This number may not correspond to the actual page number: for example,
+     *               if the passed pageList equals to "5,3", then images with postfixes "-001.png"
+     *               and "-002.png" will be created: the former for the third page, the latter
+     *               for the fifth page. "%" sign in the passed name is prohibited.
+     * @param pageList String with numbers of the required pages to be rendered as images.
+     *                 This string should be formatted as a string with numbers, separated by commas,
+     *                 without whitespaces. Can be null, if it is required to render all the PDF's pages.
      *
      * @throws IOException          if there are file's reading/writing issues
      * @throws InterruptedException if there is thread interruption while executing GhostScript.
@@ -145,12 +165,48 @@ public class GhostscriptHelper {
             throw new IllegalArgumentException(
                     IoExceptionMessage.CANNOT_OPEN_OUTPUT_DIRECTORY.replace("<filename>", pdf));
         }
+        if (!validateImageFilePattern(image)) {
+            throw new IllegalArgumentException("Invalid output image pattern: " + image);
+        }
+        if (!validatePageList(pageList)) {
+            throw new IllegalArgumentException("Invalid page list: " + pageList);
+        }
+        String formattedPageList = (pageList == null) ? "" : "-sPageList=<pagelist>".replace("<pagelist>", pageList);
+
+        String replacementPdf = null;
+        String replacementImagesDirectory = null;
+        String[] temporaryOutputImages = null;
+        try {
+            replacementPdf = FileUtil.createTempCopy(pdf, TEMP_FILE_PREFIX, null);
+            replacementImagesDirectory = FileUtil.createTempDirectory(TEMP_FILE_PREFIX);
+            String currGsParams = MessageFormatUtil.format(GHOSTSCRIPT_PARAMS, formattedPageList,
+                    Paths.get(replacementImagesDirectory,
+                            TEMP_FILE_PREFIX + PAGE_NUMBER_PATTERN + "." + RENDERED_IMAGE_EXTENSION).toString(),
+                    replacementPdf);
+
+            if (!SystemUtil.runProcessAndWait(gsExec, currGsParams)) {
+                temporaryOutputImages = FileUtil
+                        .listFilesInDirectory(replacementImagesDirectory, false);
+                throw new GhostscriptExecutionException(
+                        IoExceptionMessage.GHOSTSCRIPT_FAILED.replace("<filename>", pdf));
+            }
 
-        pageList = (pageList == null) ? "" : "-sPageList=<pagelist>".replace("<pagelist>", pageList);
-
-        String currGsParams = MessageFormatUtil.format(GHOSTSCRIPT_PARAMS, pageList, outDir + image, pdf);
-        if (!SystemUtil.runProcessAndWait(gsExec, currGsParams)) {
-            throw new GhostscriptExecutionException(IoExceptionMessage.GHOSTSCRIPT_FAILED.replace("<filename>", pdf));
+            temporaryOutputImages = FileUtil
+                    .listFilesInDirectory(replacementImagesDirectory, false);
+            if (null != temporaryOutputImages) {
+                for (int i = 0; i < temporaryOutputImages.length; i++) {
+                    FileUtil.copy(temporaryOutputImages[i],
+                            Paths.get(
+                                    outDir,
+                                    image + "-" + formatImageNumber(i + 1) + "." + RENDERED_IMAGE_EXTENSION
+                            ).toString());
+                }
+            }
+        } finally {
+            if (null != temporaryOutputImages) {
+                FileUtil.removeFiles(temporaryOutputImages);
+            }
+            FileUtil.removeFiles(new String[] {replacementImagesDirectory, replacementPdf});
         }
     }
 
@@ -168,4 +224,26 @@ public class GhostscriptHelper {
             super(msg);
         }
     }
+
+    static boolean validatePageList(String pageList) {
+        return null == pageList
+                || PAGE_LIST_REGEX.matcher(pageList).matches();
+    }
+
+    static boolean validateImageFilePattern(String imageFilePattern) {
+        return null != imageFilePattern
+                && !imageFilePattern.trim().isEmpty()
+                && !imageFilePattern.contains("%");
+    }
+
+    static String formatImageNumber(int pageNumber) {
+        StringBuilder stringBuilder = new StringBuilder();
+        int zeroFiller = pageNumber;
+        while (0 == zeroFiller / 100) {
+            stringBuilder.append('0');
+            zeroFiller *= 10;
+        }
+        stringBuilder.append(pageNumber);
+        return stringBuilder.toString();
+    }
 }
diff --git a/io/src/main/java/com/itextpdf/io/util/ImageMagickHelper.java b/io/src/main/java/com/itextpdf/io/util/ImageMagickHelper.java
index 58588158a..a8f6b2eab 100644
--- a/io/src/main/java/com/itextpdf/io/util/ImageMagickHelper.java
+++ b/io/src/main/java/com/itextpdf/io/util/ImageMagickHelper.java
@@ -45,6 +45,7 @@ package com.itextpdf.io.util;
 
 import com.itextpdf.io.IoExceptionMessage;
 
+import java.io.File;
 import java.io.IOException;
 
 /**
@@ -67,6 +68,8 @@ public class ImageMagickHelper {
 
     static final String MAGICK_COMPARE_KEYWORD = "ImageMagick Studio LLC";
 
+    private static final String TEMP_FILE_PREFIX = "itext_im_io_temp";
+
     private String compareExec;
 
     /**
@@ -113,9 +116,7 @@ public class ImageMagickHelper {
      * @param outImageFilePath Path to the output image file
      * @param cmpImageFilePath Path to the cmp image file
      * @param diffImageName    Path to the difference output image file
-     *
      * @return boolean result of comparing: true - images are visually equal
-     *
      * @throws IOException          if there are file's reading/writing issues
      * @throws InterruptedException if there is thread interruption while executing ImageMagick.
      */
@@ -132,22 +133,51 @@ public class ImageMagickHelper {
      * @param diffImageName    Path to the difference output image file
      * @param fuzzValue        String fuzziness value to compare images. Should be formatted as string with integer
      *                         or decimal number. Can be null, if it is not required to use fuzziness
-     *
      * @return boolean result of comparing: true - images are visually equal
-     *
      * @throws IOException          if there are file's reading/writing issues
      * @throws InterruptedException if there is thread interruption while executing ImageMagick.
      */
     public boolean runImageMagickImageCompare(String outImageFilePath, String cmpImageFilePath,
             String diffImageName, String fuzzValue) throws IOException, InterruptedException {
+        if (!validateFuzziness(fuzzValue)) {
+            throw new IllegalArgumentException("Invalid fuzziness value: " + fuzzValue);
+        }
         fuzzValue = (fuzzValue == null) ? "" : " -metric AE -fuzz <fuzzValue>%".replace("<fuzzValue>", fuzzValue);
 
-        StringBuilder currCompareParams = new StringBuilder();
-        currCompareParams
-                .append(fuzzValue).append(" '")
-                .append(outImageFilePath).append("' '")
-                .append(cmpImageFilePath).append("' '")
-                .append(diffImageName).append("'");
-        return SystemUtil.runProcessAndWait(compareExec, currCompareParams.toString());
+        String replacementOutFile = null;
+        String replacementCmpFile = null;
+        String replacementDiff = null;
+        try {
+            replacementOutFile = FileUtil.createTempCopy(outImageFilePath, TEMP_FILE_PREFIX, null);
+            replacementCmpFile = FileUtil.createTempCopy(cmpImageFilePath, TEMP_FILE_PREFIX, null);
+
+            replacementDiff = FileUtil.createTempFile(TEMP_FILE_PREFIX, null).toString();
+            String currCompareParams = fuzzValue + " '"
+                    + replacementOutFile + "' '"
+                    + replacementCmpFile + "' '"
+                    + replacementDiff + "'";
+            boolean result = SystemUtil.runProcessAndWait(compareExec, currCompareParams);
+
+            if (FileUtil.fileExists(replacementDiff)) {
+                FileUtil.copy(replacementDiff, diffImageName);
+            }
+            return result;
+        } finally {
+            FileUtil.removeFiles(new String[] {replacementOutFile, replacementCmpFile, replacementDiff});
+        }
+    }
+
+    static boolean validateFuzziness(String fuzziness) {
+        if (null == fuzziness) {
+            return true;
+        } else {
+            try {
+                return Double.parseDouble(fuzziness) >= 0;
+            } catch (NumberFormatException e) {
+                // In case of an exception the string could not be parsed to double,
+                // therefore it is considered to be invalid.
+                return false;
+            }
+        }
     }
 }
diff --git a/io/src/test/java/com/itextpdf/io/util/GhostScriptHelperUnitTest.java b/io/src/test/java/com/itextpdf/io/util/GhostScriptHelperUnitTest.java
new file mode 100644
index 000000000..d61010292
--- /dev/null
+++ b/io/src/test/java/com/itextpdf/io/util/GhostScriptHelperUnitTest.java
@@ -0,0 +1,155 @@
+/*
+    This file is part of the iText (R) project.
+    Copyright (c) 1998-2021 iText Group NV
+    Authors: iText Software.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License version 3
+    as published by the Free Software Foundation with the addition of the
+    following permission added to Section 15 as permitted in Section 7(a):
+    FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
+    ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
+    OF THIRD PARTY RIGHTS
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.
+    See the GNU Affero General Public License for more details.
+    You should have received a copy of the GNU Affero General Public License
+    along with this program; if not, see http://www.gnu.org/licenses or write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA, 02110-1301 USA, or download the license from the following URL:
+    http://itextpdf.com/terms-of-use/
+
+    The interactive user interfaces in modified source and object code versions
+    of this program must display Appropriate Legal Notices, as required under
+    Section 5 of the GNU Affero General Public License.
+
+    In accordance with Section 7(b) of the GNU Affero General Public License,
+    a covered work must retain the producer line in every PDF that is created
+    or manipulated using iText.
+
+    You can be released from the requirements of the license by purchasing
+    a commercial license. Buying such a license is mandatory as soon as you
+    develop commercial activities involving the iText software without
+    disclosing the source code of your own applications.
+    These activities include: offering paid services to customers as an ASP,
+    serving PDFs on the fly in a web application, shipping iText with a closed
+    source product.
+
+    For more information, please contact iText Software Corp. at this
+    address: sales@itextpdf.com
+ */
+package com.itextpdf.io.util;
+
+import com.itextpdf.test.ExtendedITextTest;
+import com.itextpdf.test.annotations.type.UnitTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(UnitTest.class)
+public class GhostScriptHelperUnitTest extends ExtendedITextTest {
+
+    @Test
+    public void verifyEmptyPageList() {
+        String testPageList = "";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyNullPageList() {
+        String testPageList = null;
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyPageListWithLeadingSpaces() {
+        String testPageList = "     1";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyPageListWithTrailingSpaces() {
+        String testPageList = "1     ";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyValidPageListWithSeveralPages() {
+        String testPageList = "1,2,3";
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyValidPageListOfOnePage() {
+        String testPageList = "2";
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    // It's worth mentioning that gs allows negative arguments: if one of the passed list numbers is negative,
+    // then all the pages are processed. However, if "0" is passed, then no pages are processed.
+    // Having said that, at iText level we're strict and do not allow such values.
+    public void verifyPageListWithNegativePages() {
+        String testPageList = "-2";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    // It's worth mentioning that gs allows negative arguments: if one of the passed list numbers is negative,
+    // then all the pages are processed. However, if "0" is passed, then no pages are processed.
+    // Having said that, at iText level we're strict and do not allow such values.
+    public void verifyPageListWithSomeNegativePagesInTheMiddle() {
+        String testPageList = "1,-2,3";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    // It's worth mentioning that gs allows negative arguments: if one of the passed list numbers is negative,
+    // then all the pages are processed. However, if "0" is passed, then no pages are processed.
+    // Having said that, at iText level we're strict and do not allow such values.
+    public void verifyPageListWithSomeNegativePagesAtTheEnd() {
+        String testPageList = "1,-2";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyPageListWithOnlyPageZero() {
+        String testPageList = "0";
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyPageListWithOneOfPagesBeingZero() {
+        String testPageList = "3,0,2";
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    // For gs the order doesn't play any role
+    public void verifyValidPageListWithDescendingOrder() {
+        String testPageList = "3,2,1";
+
+        Assert.assertTrue(GhostscriptHelper.validatePageList(testPageList));
+    }
+
+    @Test
+    public void verifyTextInPageList() {
+        String testPageList = "1,hello,2";
+
+        Assert.assertFalse(GhostscriptHelper.validatePageList(testPageList));
+    }
+}
diff --git a/io/src/test/java/com/itextpdf/io/util/GhostscriptHelperTest.java b/io/src/test/java/com/itextpdf/io/util/GhostscriptHelperTest.java
index 5f7a768c9..2d7833d01 100644
--- a/io/src/test/java/com/itextpdf/io/util/GhostscriptHelperTest.java
+++ b/io/src/test/java/com/itextpdf/io/util/GhostscriptHelperTest.java
@@ -46,19 +46,24 @@ import com.itextpdf.io.IoExceptionMessage;
 import com.itextpdf.test.ExtendedITextTest;
 import com.itextpdf.test.annotations.type.IntegrationTest;
 
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import java.io.File;
-import java.io.IOException;
-
 
 @Category(IntegrationTest.class)
 public class GhostscriptHelperTest extends ExtendedITextTest {
     private final static String SOURCE_FOLDER = "./src/test/resources/com/itextpdf/io/util/GhostscriptHelperTest/";
     private static final String DESTINATION_FOLDER = "./target/test/com/itextpdf/io/GhostscriptHelperTest/";
 
+    // In some of the test we will check whether Ghostscript has printed its help message to the console.
+    // The value of this threshold should be definitely less than the length of the help message.
+    private static final int SYSTEM_OUT_LENGTH_LIMIT = 400;
+
     @Before
     public void setUp() {
         createOrClearDestinationFolder(DESTINATION_FOLDER);
@@ -74,7 +79,8 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
     public void ghostScriptEnvVarIsExplicitlySpecified() {
         String gsExec = SystemUtil.getPropertyOrEnvironmentVariable(GhostscriptHelper.GHOSTSCRIPT_ENVIRONMENT_VARIABLE);
         if (gsExec == null) {
-            gsExec = SystemUtil.getPropertyOrEnvironmentVariable(GhostscriptHelper.GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY);
+            gsExec = SystemUtil
+                    .getPropertyOrEnvironmentVariable(GhostscriptHelper.GHOSTSCRIPT_ENVIRONMENT_VARIABLE_LEGACY);
         }
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper(gsExec);
@@ -112,15 +118,16 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
     }
 
     @Test
-    public void runGhostScriptIncorrectParams() throws IOException, InterruptedException {
+    public void runGhostScriptIncorrectParams() {
         String inputPdf = SOURCE_FOLDER + "imageHandlerUtilTest.pdf";
-        String exceptionMessage = "GhostScript failed for " + inputPdf;
+        String invalidPageList = "q@W";
+        String exceptionMessage = "Invalid page list: " + invalidPageList;
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
 
-        Exception e = Assert.assertThrows(GhostscriptHelper.GhostscriptExecutionException.class,
-                () ->  ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,
-                        "outputPageImage.png", "q@W")
+        Exception e = Assert.assertThrows(IllegalArgumentException.class,
+                () -> ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,
+                        "outputPageImage.png", invalidPageList)
         );
         Assert.assertEquals(exceptionMessage, e.getMessage());
     }
@@ -131,10 +138,10 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
         ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,
-                "specificPage.png", "1");
+                "specificPage", "1");
 
         Assert.assertEquals(1, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);
-        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + "specificPage.png"));
+        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + "specificPage-001.png"));
     }
 
     @Test
@@ -142,13 +149,15 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
         String inputPdf = SOURCE_FOLDER + "imageHandlerUtilTest.pdf";
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
-        String imageFileName = new File(inputPdf).getName() + "_severalSpecificPages-%03d.png";
+        String imageFileName = new File(inputPdf).getName() + "_severalSpecificPages";
         ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,
                 imageFileName, "1,3");
 
         Assert.assertEquals(2, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);
-        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + "imageHandlerUtilTest.pdf_severalSpecificPages-001.png"));
-        Assert.assertTrue(FileUtil.fileExists(DESTINATION_FOLDER + "imageHandlerUtilTest.pdf_severalSpecificPages-002.png"));
+        Assert.assertTrue(
+                FileUtil.fileExists(DESTINATION_FOLDER + "imageHandlerUtilTest.pdf_severalSpecificPages-001.png"));
+        Assert.assertTrue(
+                FileUtil.fileExists(DESTINATION_FOLDER + "imageHandlerUtilTest.pdf_severalSpecificPages-002.png"));
     }
 
     @Test
@@ -156,7 +165,7 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
         String inputPdf = SOURCE_FOLDER + "imageHandlerUtilTest.pdf";
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
-        String imageFileName = new File(inputPdf).getName() + "_allPages-%03d.png";
+        String imageFileName = new File(inputPdf).getName() + "_allPages";
         ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, imageFileName);
 
         Assert.assertEquals(3, FileUtil.listFilesInDirectory(DESTINATION_FOLDER, true).length);
@@ -169,8 +178,7 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
     public void dSaferParamInGhostScriptHelperTest() throws IOException, InterruptedException {
         String input = SOURCE_FOLDER + "unsafePostScript.ps";
         String outputName = "unsafePostScript.png";
-        String maliciousResult1 = DESTINATION_FOLDER + "output1.txt";
-        String maliciousResult2 = DESTINATION_FOLDER + "output2.txt";
+
         try {
             GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
             ghostscriptHelper.runGhostScriptImageGeneration(input, DESTINATION_FOLDER, outputName);
@@ -179,23 +187,97 @@ public class GhostscriptHelperTest extends ExtendedITextTest {
                     + "This is expected for some environments and ghostscript versions. "
                     + "We assert only the absence of malicious script result (created file).\n");
         }
+
+        // If we had not set -dSAFER option, the following files would be created
+        String maliciousResult1 = DESTINATION_FOLDER + "output1.txt";
+        String maliciousResult2 = DESTINATION_FOLDER + "output2.txt";
+
         Assert.assertFalse(FileUtil.fileExists(maliciousResult1));
         Assert.assertFalse(FileUtil.fileExists(maliciousResult2));
     }
 
     @Test
     public void ghostScriptImageGenerationTest() throws IOException, InterruptedException {
-        String filename = "resultantImage.png";
+        String name = "resultantImage";
+        String filename = name + ".png";
         String psFile = SOURCE_FOLDER + "simple.ps";
-        String resultantImage = DESTINATION_FOLDER + filename;
+        String resultantImage = DESTINATION_FOLDER + name + "-001.png";
         String cmpResultantImage = SOURCE_FOLDER + "cmp_" + filename;
         String diff = DESTINATION_FOLDER + "diff_" + filename;
 
         GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
-        ghostscriptHelper.runGhostScriptImageGeneration(psFile, DESTINATION_FOLDER, filename);
+        ghostscriptHelper.runGhostScriptImageGeneration(psFile, DESTINATION_FOLDER, name);
         Assert.assertTrue(FileUtil.fileExists(resultantImage));
 
         ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
         Assert.assertTrue(imageMagickHelper.runImageMagickImageCompare(resultantImage, cmpResultantImage, diff));
     }
+
+    @Test
+    // Previously this test printed help message. Now an exception should be thrown.
+    public void pdfCallsHelpTest() {
+        String inputPdf = SOURCE_FOLDER + "../test.pdf -h";
+        String outputImagePattern = "image";
+
+        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
+
+        // In .NET the type of the thrown exception is different, therefore we just check here that
+        // any exception has been thrown.
+        Assert.assertThrows(Exception.class, () ->
+                ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, outputImagePattern));
+    }
+
+    @Test
+    public void outputImageCallsHelpTest() throws IOException {
+        String inputPdf = SOURCE_FOLDER + "../test.pdf";
+        String outputImagePattern = "justSomeText \" -h";
+
+        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
+
+        Object storedPrintStream = System.out;
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try {
+            System.setOut(new PrintStream(baos));
+            ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER, outputImagePattern);
+        } catch (Exception e) {
+            // This test fails on Windows, but works on Linux. So our goal is not to check
+            // whether an exception was thrown, but whether there is the help message in the output
+        } finally {
+            System.out.flush();
+            StandardOutUtil.restoreStandardOut(storedPrintStream);
+            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);
+            baos.close();
+        }
+    }
+
+    @Test
+    // Previously this test printed help message. Now an exception should be thrown.
+    public void pageListCallsHelpTest() {
+        String inputPdf = SOURCE_FOLDER + "../test.pdf";
+        String outputImagePattern = "justSomeText";
+        String pageList = "1 -h";
+
+        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
+
+        // In .NET the type of the thrown exception is different, therefore we just check here that
+        // any exception has been thrown.
+        Assert.assertThrows(Exception.class, () ->
+                ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, DESTINATION_FOLDER,
+                        outputImagePattern, pageList));
+    }
+
+    @Test
+    public void nonExistingDestinationFolder() {
+        String inputPdf = SOURCE_FOLDER + "../test.pdf";
+        String outputImagePattern = "justSomeText";
+        String destinationFolder = "notExistingFolder";
+
+        GhostscriptHelper ghostscriptHelper = new GhostscriptHelper();
+
+        // In .NET the type of the thrown exception is different, therefore we just check here that
+        // any exception has been thrown.
+        Assert.assertThrows(Exception.class,
+                () -> ghostscriptHelper.runGhostScriptImageGeneration(inputPdf, destinationFolder,
+                        outputImagePattern));
+    }
 }
diff --git a/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperTest.java b/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperTest.java
index e71cfdb03..154cf8e90 100644
--- a/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperTest.java
+++ b/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperTest.java
@@ -46,17 +46,26 @@ import com.itextpdf.io.IoExceptionMessage;
 import com.itextpdf.test.ExtendedITextTest;
 import com.itextpdf.test.annotations.type.IntegrationTest;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
-import java.io.IOException;
 
 @Category(IntegrationTest.class)
 public class ImageMagickHelperTest extends ExtendedITextTest {
-    private final static String SOURCE_FOLDER = "./src/test/resources/com/itextpdf/io/util/ImageMagickHelperTest/";
+    private static final String SOURCE_FOLDER = "./src/test/resources/com/itextpdf/io/util/ImageMagickHelperTest/";
     private static final String DESTINATION_FOLDER = "./target/test/com/itextpdf/io/ImageMagickHelperTest/";
 
+    // In some of the test we will check whether ImageMagick has printed something to the console.
+    // For this reason the standard output stream will be customized. In .NET, however,
+    // on the contrary to Java the name of the test gets to this stream, hence we cannot check
+    // its length against zero and need to introduce some threshold, which should be definitely
+    // less than the length of the help message.
+    private static final int SYSTEM_OUT_LENGTH_LIMIT = 50;
+
     @Before
     public void setUp() {
         createOrClearDestinationFolder(DESTINATION_FOLDER);
@@ -70,9 +79,11 @@ public class ImageMagickHelperTest extends ExtendedITextTest {
 
     @Test
     public void imageMagickEnvVarIsExplicitlySpecified() {
-        String compareExec = SystemUtil.getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE);
+        String compareExec = SystemUtil
+                .getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE);
         if (compareExec == null) {
-            compareExec = SystemUtil.getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE_LEGACY);
+            compareExec = SystemUtil
+                    .getPropertyOrEnvironmentVariable(ImageMagickHelper.MAGICK_COMPARE_ENVIRONMENT_VARIABLE_LEGACY);
         }
 
         ImageMagickHelper imageMagickHelper = new ImageMagickHelper(compareExec);
@@ -165,4 +176,175 @@ public class ImageMagickHelperTest extends ExtendedITextTest {
         Assert.assertTrue(result);
         Assert.assertTrue(FileUtil.fileExists(diff));
     }
+
+    @Test
+    public void outImageCallsHelpTest() {
+        String cmpImage = SOURCE_FOLDER + "cmp_Im1_1.jpg";
+        String diff = DESTINATION_FOLDER + "diff.png";
+
+        String outImage = SOURCE_FOLDER + "Im1_1.jpg' -help '" + cmpImage + "' '" + diff;
+
+        Object storedPrintStream = System.out;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            System.setOut(new PrintStream(baos));
+
+            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+
+            // In .NET the type of the thrown exception is different, therefore we just check here that
+            // any exception has been thrown.
+            Assert.assertThrows(Exception.class,
+                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff));
+
+            // Previously a lengthy help message was printed
+            System.out.flush();
+            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);
+        } catch (IOException e) {
+            Assert.fail("No exception is excepted here.");
+        } finally {
+            StandardOutUtil.restoreStandardOut(storedPrintStream);
+        }
+    }
+
+    @Test
+    public void cmpImageCallsHelpTest() {
+        String outImage = SOURCE_FOLDER + "Im1_1.jpg";
+        String diff = DESTINATION_FOLDER + "diff.png";
+        String cmpImage = SOURCE_FOLDER + "cmp_Im1_1.jpg' -help '" + diff;
+
+        Object storedPrintStream = System.out;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            System.setOut(new PrintStream(baos));
+
+            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+
+            // In .NET the type of the thrown exception is different, therefore we just check here that
+            // any exception has been thrown.
+            Assert.assertThrows(Exception.class,
+                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff));
+
+            // Previously a lengthy help message was printed
+            System.out.flush();
+            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);
+        } catch (IOException e) {
+            Assert.fail("No exception is excepted here.");
+        } finally {
+            StandardOutUtil.restoreStandardOut(storedPrintStream);
+        }
+    }
+
+    @Test
+    public void fuzzinessCallsHelpTest() {
+        String outImage = SOURCE_FOLDER + "Im1_1.jpg";
+        String diff = DESTINATION_FOLDER + "diff.png";
+        String cmpImage = SOURCE_FOLDER + "cmp_Im1_1.jpg";
+
+        String fuzziness = "1% -help ";
+
+        Object storedPrintStream = System.out;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            System.setOut(new PrintStream(baos));
+
+            ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+
+            // In .NET the type of the thrown exception is different, therefore we just check here that
+            // any exception has been thrown.
+            Assert.assertThrows(Exception.class,
+                    () -> imageMagickHelper.runImageMagickImageCompare(outImage, cmpImage, diff, fuzziness));
+
+            // Previously a lengthy help message was printed
+            System.out.flush();
+            Assert.assertTrue(baos.toByteArray().length < SYSTEM_OUT_LENGTH_LIMIT);
+        } catch (IOException e) {
+            Assert.fail("No exception is excepted here.");
+        } finally {
+            StandardOutUtil.restoreStandardOut(storedPrintStream);
+        }
+    }
+
+    @Test
+    // In this test we will pass several arguments as the first one. Previously that resulted in
+    // different rather than equal images being compared. Now we expect an exception
+    public void passOutAndCmpAndDiffAsOutTest() throws IOException, InterruptedException {
+        String image = SOURCE_FOLDER + "image.png";
+        String differentImage = SOURCE_FOLDER + "Im1_1.jpg";
+
+        String diff = DESTINATION_FOLDER + "diff_equalImages.png";
+
+        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+        Assert.assertThrows(Exception.class,
+                () -> imageMagickHelper.runImageMagickImageCompare(
+                        image + "' '" + differentImage + "' '" + diff,
+                        image,
+                        diff));
+    }
+
+    @Test
+    // In this test we will pass several arguments as the second one. Previously that resulted in
+    // diff being overridden (second diff was used). Now we expect an exception
+    public void passCmpAndDiffAsDiffTest() throws IOException, InterruptedException {
+        String image = SOURCE_FOLDER + "image.png";
+
+        String diff = DESTINATION_FOLDER + "diff_equalImages.png";
+        String secondDiff = DESTINATION_FOLDER + "diff_secondEqualImages.png";
+
+        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+        Assert.assertThrows(Exception.class,
+                () -> imageMagickHelper.runImageMagickImageCompare(
+                        image,
+                        image + "' '" + secondDiff,
+                        diff));
+    }
+
+    @Test
+    // In this test we will pass several arguments, including fuzziness, as the first one.
+    // Previously that resulted in different images being compared and the number of different bytes
+    // being printed to System.out. Now we expect an exception
+    public void passFuzzinessAsOutTest() {
+        String image = SOURCE_FOLDER + "image.png";
+        String differentImage = SOURCE_FOLDER + "Im1_1.jpg";
+
+        String diff = DESTINATION_FOLDER + "diff.png";
+
+        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+        Assert.assertThrows(Exception.class, () ->
+                imageMagickHelper.runImageMagickImageCompare(
+                        image + "' -metric AE -fuzz 1% '" + differentImage + "' '" + diff,
+                        image,
+                        diff));
+    }
+
+    @Test
+    // When fuzziness is specified, ImageMagick prints to standard output the number of different bytes.
+    // Since we compare equal images, we expect this number to be zero.
+    public void compareEqualsImagesAndCheckFuzzinessTest() {
+        String image = SOURCE_FOLDER + "image.png";
+        String diff = DESTINATION_FOLDER + "diff_equalImages.png";
+
+        ImageMagickHelper imageMagickHelper = new ImageMagickHelper();
+        Object storedPrintStream = System.out;
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();) {
+            System.setOut(new PrintStream(baos));
+            boolean result = imageMagickHelper.runImageMagickImageCompare(
+                    image,
+                    image,
+                    diff, "1");
+
+            Assert.assertTrue(result);
+            Assert.assertTrue(FileUtil.fileExists(diff));
+
+            System.out.flush();
+            String output = new String(baos.toByteArray()).trim();
+
+            // This check is implemented in such a peculiar way because of .NET autoporting
+            Assert.assertEquals('0', output.charAt(output.length() - 1));
+            if (output.length() > 1) {
+                Assert.assertFalse(Character.isDigit(output.charAt(output.length() - 2)));
+            }
+        } catch (Exception e) {
+            Assert.fail("No exception is expected here.");
+        } finally {
+            StandardOutUtil.restoreStandardOut(storedPrintStream);
+        }
+    }
+
 }
diff --git a/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperUnitTest.java b/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperUnitTest.java
new file mode 100644
index 000000000..f84da56b5
--- /dev/null
+++ b/io/src/test/java/com/itextpdf/io/util/ImageMagickHelperUnitTest.java
@@ -0,0 +1,117 @@
+/*
+    This file is part of the iText (R) project.
+    Copyright (c) 1998-2021 iText Group NV
+    Authors: iText Software.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License version 3
+    as published by the Free Software Foundation with the addition of the
+    following permission added to Section 15 as permitted in Section 7(a):
+    FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
+    ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
+    OF THIRD PARTY RIGHTS
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.
+    See the GNU Affero General Public License for more details.
+    You should have received a copy of the GNU Affero General Public License
+    along with this program; if not, see http://www.gnu.org/licenses or write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA, 02110-1301 USA, or download the license from the following URL:
+    http://itextpdf.com/terms-of-use/
+
+    The interactive user interfaces in modified source and object code versions
+    of this program must display Appropriate Legal Notices, as required under
+    Section 5 of the GNU Affero General Public License.
+
+    In accordance with Section 7(b) of the GNU Affero General Public License,
+    a covered work must retain the producer line in every PDF that is created
+    or manipulated using iText.
+
+    You can be released from the requirements of the license by purchasing
+    a commercial license. Buying such a license is mandatory as soon as you
+    develop commercial activities involving the iText software without
+    disclosing the source code of your own applications.
+    These activities include: offering paid services to customers as an ASP,
+    serving PDFs on the fly in a web application, shipping iText with a closed
+    source product.
+
+    For more information, please contact iText Software Corp. at this
+    address: sales@itextpdf.com
+ */
+package com.itextpdf.io.util;
+
+import com.itextpdf.test.ExtendedITextTest;
+import com.itextpdf.test.annotations.type.UnitTest;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+@Category(UnitTest.class)
+public class ImageMagickHelperUnitTest extends ExtendedITextTest {
+
+    @Test
+    public void verifyValidIntegerFuzzValue() {
+        String testFuzzValue = "10";
+
+        Assert.assertTrue(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyValidDecimalFuzzValue() {
+        String testFuzzValue = "10.5";
+
+        Assert.assertTrue(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyFuzzIntegerValueGT100() {
+        String testFuzzValue = "200";
+
+        Assert.assertTrue(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyFuzzDecimalValueGT100() {
+        String testFuzzValue = "200.5";
+
+        Assert.assertTrue(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyNegativeIntegerFuzzValue() {
+        String testFuzzValue = "-10";
+
+        Assert.assertFalse(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyNegativeDecimalFuzzValue() {
+        String testFuzzValue = "-10.5";
+
+        Assert.assertFalse(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyEmptyFuzzValue() {
+        String testFuzzValue = "";
+
+        Assert.assertFalse(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifyNullFuzzValue() {
+        String testFuzzValue = null;
+
+        Assert.assertTrue(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+
+    @Test
+    public void verifySomeTextInFuzzValue() {
+        String testFuzzValue = "10hello";
+
+        Assert.assertFalse(ImageMagickHelper.validateFuzziness(testFuzzValue));
+    }
+}
diff --git a/io/src/test/java/com/itextpdf/io/util/StandardOutUtil.java b/io/src/test/java/com/itextpdf/io/util/StandardOutUtil.java
new file mode 100644
index 000000000..fc54e654a
--- /dev/null
+++ b/io/src/test/java/com/itextpdf/io/util/StandardOutUtil.java
@@ -0,0 +1,52 @@
+/*
+    This file is part of the iText (R) project.
+    Copyright (c) 1998-2021 iText Group NV
+    Authors: iText Software.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Affero General Public License version 3
+    as published by the Free Software Foundation with the addition of the
+    following permission added to Section 15 as permitted in Section 7(a):
+    FOR ANY PART OF THE COVERED WORK IN WHICH THE COPYRIGHT IS OWNED BY
+    ITEXT GROUP. ITEXT GROUP DISCLAIMS THE WARRANTY OF NON INFRINGEMENT
+    OF THIRD PARTY RIGHTS
+
+    This program is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.
+    See the GNU Affero General Public License for more details.
+    You should have received a copy of the GNU Affero General Public License
+    along with this program; if not, see http://www.gnu.org/licenses or write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA, 02110-1301 USA, or download the license from the following URL:
+    http://itextpdf.com/terms-of-use/
+
+    The interactive user interfaces in modified source and object code versions
+    of this program must display Appropriate Legal Notices, as required under
+    Section 5 of the GNU Affero General Public License.
+
+    In accordance with Section 7(b) of the GNU Affero General Public License,
+    a covered work must retain the producer line in every PDF that is created
+    or manipulated using iText.
+
+    You can be released from the requirements of the license by purchasing
+    a commercial license. Buying such a license is mandatory as soon as you
+    develop commercial activities involving the iText software without
+    disclosing the source code of your own applications.
+    These activities include: offering paid services to customers as an ASP,
+    serving PDFs on the fly in a web application, shipping iText with a closed
+    source product.
+
+    For more information, please contact iText Software Corp. at this
+    address: sales@itextpdf.com
+ */
+package com.itextpdf.io.util;
+
+import java.io.PrintStream;
+
+public class StandardOutUtil {
+
+    static void restoreStandardOut(Object stream) {
+        System.setOut((PrintStream) stream);
+    }
+}
diff --git a/kernel/src/main/java/com/itextpdf/kernel/utils/CompareTool.java b/kernel/src/main/java/com/itextpdf/kernel/utils/CompareTool.java
index a55a70a3e..2042eac76 100644
--- a/kernel/src/main/java/com/itextpdf/kernel/utils/CompareTool.java
+++ b/kernel/src/main/java/com/itextpdf/kernel/utils/CompareTool.java
@@ -958,9 +958,12 @@ public class CompareTool {
         this.cmpPdf = cmpPdf;
         outPdfName = new File(outPdf).getName();
         cmpPdfName = new File(cmpPdf).getName();
-        outImage = outPdfName + "-%03d.png";
-        if (cmpPdfName.startsWith("cmp_")) cmpImage = cmpPdfName + "-%03d.png";
-        else cmpImage = "cmp_" + cmpPdfName + "-%03d.png";
+        outImage = outPdfName;
+        if (cmpPdfName.startsWith("cmp_")) {
+            cmpImage = cmpPdfName;
+        } else {
+            cmpImage = "cmp_" + cmpPdfName;
+        }
     }
 
     private void setPassword(byte[] outPass, byte[] cmpPass) {
