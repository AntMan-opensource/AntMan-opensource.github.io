commit cd5d2129e2ee60f79d8649c2754d822e60252647
Author: Brian Stansberry <brian.stansberry@redhat.com>
Date:   Wed May 13 20:30:34 2020 -0500

    [WFLY-13549] Apply a blacklist to classes unmarshalled via RemoteEjbService

diff --git a/ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteConnectorService.java b/ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteConnectorService.java
index 49c30c44bf..ec5fbf6ff2 100644
--- a/ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteConnectorService.java
+++ b/ejb3/src/main/java/org/jboss/as/ejb3/remote/EJBRemoteConnectorService.java
@@ -23,6 +23,7 @@ package org.jboss.as.ejb3.remote;
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
+import java.util.function.Function;
 
 import org.jboss.as.remoting.RemotingConnectorBindingInfoService;
 import org.jboss.ejb.protocol.remote.RemoteEJBService;
@@ -56,13 +57,12 @@ public class EJBRemoteConnectorService implements Service<Void> {
     private final InjectedValue<RemotingTransactionService> remotingTransactionServiceInjectedValue = new InjectedValue<>();
     private volatile Registration registration;
     private final OptionMap channelCreationOptions;
+    private final Function<String, Boolean> classResolverFilter;
 
-    public EJBRemoteConnectorService() {
-        this(OptionMap.EMPTY);
-    }
-
-    public EJBRemoteConnectorService(final OptionMap channelCreationOptions) {
+    public EJBRemoteConnectorService(final OptionMap channelCreationOptions,
+                                     final Function<String, Boolean> classResolverFilter) {
         this.channelCreationOptions = channelCreationOptions;
+        this.classResolverFilter = classResolverFilter;
     }
 
     @Override
@@ -75,7 +75,8 @@ public class EJBRemoteConnectorService implements Service<Void> {
         }
         RemoteEJBService remoteEJBService = RemoteEJBService.create(
             associationService.getAssociation(),
-            remotingTransactionServiceInjectedValue.getValue()
+            remotingTransactionServiceInjectedValue.getValue(),
+            classResolverFilter
         );
         remoteEJBService.serverUp();
 
diff --git a/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3RemoteServiceAdd.java b/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3RemoteServiceAdd.java
index 44bd3cbb88..f0194cf3ee 100644
--- a/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3RemoteServiceAdd.java
+++ b/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/EJB3RemoteServiceAdd.java
@@ -114,7 +114,7 @@ public class EJB3RemoteServiceAdd extends AbstractBoottimeAddStepHandler {
         final OptionMap channelCreationOptions = this.getChannelCreationOptions(context);
         // Install the EJB remoting connector service which will listen for client connections on the remoting channel
         // TODO: Externalize (expose via management API if needed) the version and the marshalling strategy
-        final EJBRemoteConnectorService ejbRemoteConnectorService = new EJBRemoteConnectorService(channelCreationOptions);
+        final EJBRemoteConnectorService ejbRemoteConnectorService = new EJBRemoteConnectorService(channelCreationOptions, new FilterSpecClassResolverFilter());
         ServiceBuilder<?> builder = context.getCapabilityServiceTarget().addCapability(EJB3RemoteResourceDefinition.EJB_REMOTE_CAPABILITY)
                 .setInstance(ejbRemoteConnectorService)
                 .addAliases(EJBRemoteConnectorService.SERVICE_NAME)
diff --git a/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilter.java b/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilter.java
new file mode 100644
index 0000000000..b35988a06b
--- /dev/null
+++ b/ejb3/src/main/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilter.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2020. Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.as.ejb3.subsystem;
+
+import static org.jboss.as.ejb3.logging.EjbLogger.REMOTE_LOGGER;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Function;
+
+import org.wildfly.common.Assert;
+import org.wildfly.security.manager.WildFlySecurityManager;
+
+/**
+ * Class name filtering {@code Function<String, Boolean>} implementation that is configured by a {@code filterSpec}
+ * string provided to the constructor. The function returns {@code true} if the given class name is acceptable
+ * for class resolution, {@code false} otherwise. The function is meant to be used for implementation blacklists
+ * or whitelists of classes that would be loaded when remote EJB invocations are received.
+ * <p>
+ * The {@code filterSpec} string is composed of one or more filter spec elements separated by the {@code ';'} char.
+ * A filter spec element that begins with the {@code '!'} char is a 'rejecting element' and indicates resolution of a
+ * class name should not be allowed if the rest of the element matches the class name. Otherwise the spec element
+ * indicates the class name can be accepted if it matches.
+ * </p>
+ * <p>
+ * Matching is done according to the following rules:
+ * <ul>
+ *     <li>If the spec element does not terminate in the {@code '*'} char the given class name must match.</li>
+ *     <li>If the spec element terminates in the string {@code ".*"} the portion of the class name up to and
+ *     including any final {@code '.'} char must match. Such a spec element indicates a single package in which a class
+ *     must reside.</li>
+ *     <li>If the spec element terminates in the string {@code ".**"} the class name must begin with the portion of the
+ *     spec element before the first {@code '*'}. Such a spec element indicates a package hierarchy in which a class
+ *     must reside.</li>
+ *     <li>Otherwise the spec element ends in the {@code '*'} char and the class name must begin with portion
+ *     spec element before the first {@code '*'}. Such a spec element indicates a general string 'starts with' match.</li>
+ * </ul>
+ * </>
+ * <p>
+ * The presence of the {@code '='} or {@code '/'} chars anywhere in the filter spec will result in an
+ * {@link IllegalArgumentException} from the constructor. The presence of the {@code '*'} char in any substring
+ * other than the ones described above will also result in an {@link IllegalArgumentException} from the constructor.
+ * </p>
+ * <p>
+ * If any element in the filter spec indicates a class name should be rejected, it will be rejected. If any element
+ * in the filter spec does not begin with the {@code '!'} char, then the filter will act like a whitelist, and
+ * at least one non-rejecting filter spec element must match the class name for the filter to return {@code true}.
+ * Rejecting elements can be used in an overall filter spec for a whitelist, for example to exclude a particular
+ * class from a package that is otherwise whitelisted.
+ * </p>
+ *
+ * @author Brian Stansberry
+ */
+final class FilterSpecClassResolverFilter implements Function<String, Boolean> {
+
+    // Note -- the default filter spec represents a blacklist.
+    /**
+     * Value provided to {@link #FilterSpecClassResolverFilter(String)} by the default no-arg constructor.
+     * Represents the default filtering rules for this library.
+     */
+    public static final String DEFAULT_FILTER_SPEC =
+            "!org.apache.commons.collections.functors.InvokerTransformer;"
+                    + "!org.apache.commons.collections.functors.InstantiateTransformer;"
+                    + "!org.apache.commons.collections4.functors.InvokerTransformer;"
+                    + "!org.apache.commons.collections4.functors.InstantiateTransformer;"
+                    + "!org.codehaus.groovy.runtime.ConvertedClosure;"
+                    + "!org.codehaus.groovy.runtime.MethodClosure;"
+                    + "!org.springframework.beans.factory.ObjectFactory;"
+                    + "!com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;"
+                    + "!org.apache.xalan.xsltc.trax.TemplatesImpl";
+
+    private final String filterSpec;
+    private final List<String> parsedFilterSpecs;
+    private final List<Function<String, Boolean>> unmarshallingFilters;
+    private final boolean whitelistUnmarshalling;
+
+    /**
+     * Creates a filter using the default rules.
+     */
+    FilterSpecClassResolverFilter() {
+        this(getUnmarshallingFilterSpec());
+    }
+
+
+    private static String getUnmarshallingFilterSpec() {
+        // The default blacklisting can be disabled via system property
+        String disabled = WildFlySecurityManager.getPropertyPrivileged("jboss.ejb.unmarshalling.filter.disabled", null);
+        if ("true".equalsIgnoreCase(disabled)) {
+            return "";  // empty string disables filtering
+        }
+        // This is an unsupported property to facilitate integration testing. It's use can be removed at any time.
+        String spec = WildFlySecurityManager.getPropertyPrivileged("jboss.experimental.ejb.unmarshalling.filter.spec", null);
+        if (spec != null) {
+            return spec;
+        }
+        return DEFAULT_FILTER_SPEC;
+    }
+
+    /**
+     * Create a filter using the given {@code filterSpec}.
+     * @param filterSpec filter configuration as described in the class javadoc. Cannot be {@code null}
+     *
+     * @throws IllegalArgumentException if the form of {@code filterSpec} violates any of the rules for this class
+     */
+    FilterSpecClassResolverFilter(String filterSpec) {
+        Assert.checkNotNullParam("filterSpec", filterSpec);
+        this.filterSpec = filterSpec;
+        if (filterSpec.isEmpty()) {
+            parsedFilterSpecs = null;
+            unmarshallingFilters = null;
+            whitelistUnmarshalling = false;
+        } else {
+
+            parsedFilterSpecs = new ArrayList<>(Arrays.asList(filterSpec.split(";")));
+            unmarshallingFilters = new ArrayList<>(parsedFilterSpecs.size());
+            ExactMatchFilter exactMatchWhitelist = null;
+            ExactMatchFilter exactMatchBlacklist = null;
+            boolean whitelist = false;
+
+            for (String spec : parsedFilterSpecs) {
+
+                if (spec.contains("=") || spec.contains("/")) {
+                    // perhaps this is an attempt to pass a JEPS 290 style limit or module name pattern; not supported
+                    throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                }
+
+                boolean blacklistElement = spec.startsWith("!");
+                whitelist |= !blacklistElement;
+
+                // For a blacklist element, return FALSE for a match; i.e. don't resolve
+                // For a whitelist, return TRUE for a match; i.e. definitely do resolve
+                // For any non-match, return null which means that check has no opinion
+                final Boolean matchReturn = blacklistElement ? Boolean.FALSE : Boolean.TRUE;
+
+                if (blacklistElement) {
+                    if (spec.length() == 1) {
+                        throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                    }
+                    spec = spec.substring(1);
+                }
+
+                Function<String, Boolean> filter = null;
+                int lastStar = spec.lastIndexOf('*');
+                if (lastStar >= 0) {
+                    if (lastStar != spec.length() - 1) {
+                        // wildcards only allowed at the end
+                        throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                    }
+                    int firstStar = spec.indexOf('*');
+                    if (firstStar != lastStar) {
+                        if (firstStar == lastStar - 1 && spec.endsWith(".**")) {
+                            if (spec.length() == 3) {
+                                throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                            }
+                            String pkg = spec.substring(0, spec.length() - 2);
+                            filter = cName -> cName.startsWith(pkg) ? matchReturn : null;
+                        } else {
+                            // there's an extra star in some spot other than between a final '.' and '*'
+                            throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                        }
+                    } else if (spec.endsWith(".*")) {
+                        if (spec.length() == 2) {
+                            throw REMOTE_LOGGER.invalidFilterSpec(spec);
+                        }
+                        String pkg = spec.substring(0, spec.length() - 1);
+                        filter = cName -> cName.startsWith(pkg) && cName.lastIndexOf('.') == pkg.length() - 1 ? matchReturn : null;
+                    } else {
+                        String startsWith = spec.substring(0, spec.length() - 1); // note that an empty 'startsWith' is ok; e.g. from a "*" spec to allow all
+                        filter = cName -> cName.startsWith(startsWith) ? matchReturn : null;
+                    }
+                } else {
+                    // For exact matches store them in a set and just do a single set.contains check
+                    if (blacklistElement) {
+                        if (exactMatchBlacklist == null) {
+                            filter = exactMatchBlacklist = new ExactMatchFilter(false);
+                        }
+                        exactMatchBlacklist.addMatchingClass(spec);
+                    } else {
+                        if (exactMatchWhitelist == null) {
+                            filter = exactMatchWhitelist = new ExactMatchFilter(true);
+                        }
+                        exactMatchWhitelist.addMatchingClass(spec);
+                    }
+                     if (filter == null) {
+                         // An ExactMatchFilter earlier in the list would have already handled this.
+                         // Just add a no-op placeholder function to keep the list of specs and functions in sync
+                         filter = cName -> null;
+                     }
+                }
+                unmarshallingFilters.add(filter);
+            }
+            if (whitelist) {
+                // Don't force users to whitelist the classes we send. Add a whitelist spec for their package
+                // TODO is this a good idea?
+                final String pkg = "org.jboss.ejb.client.";
+                parsedFilterSpecs.add(pkg + "*");
+                unmarshallingFilters.add(cName -> cName.startsWith(pkg) && cName.lastIndexOf('.') == pkg.length() - 1 ? true : null);
+            }
+            assert parsedFilterSpecs.size() == unmarshallingFilters.size();
+            whitelistUnmarshalling = whitelist;
+        }
+    }
+
+    @Override
+    public Boolean apply(String className) {
+        Assert.checkNotNullParam("className", className);
+        boolean anyAccept = false;
+        if (unmarshallingFilters != null) {
+
+            for (int i = 0; i < unmarshallingFilters.size(); i++) {
+                Function<String, Boolean> func = unmarshallingFilters.get(i);
+                Boolean accept = func.apply(className);
+                if (accept == Boolean.FALSE) {
+                    String failedSpec = func instanceof ExactMatchFilter ? "!" + className : parsedFilterSpecs.get(i);
+                    REMOTE_LOGGER.debugf("Class %s has been explicitly rejected by filter spec element %s", className, failedSpec);
+                    return false;
+                } else {
+                    anyAccept |= accept != null;
+                }
+            }
+            if (whitelistUnmarshalling && !anyAccept) {
+                REMOTE_LOGGER.debugf("Class %s has not been explicitly whitelisted by filter spec %s", className, filterSpec);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private static class ExactMatchFilter implements Function<String, Boolean> {
+        private final Set<String> matches = new HashSet<>();
+        private final Boolean matchResult;
+
+        private ExactMatchFilter(boolean forWhitelist) {
+            this.matchResult = forWhitelist;
+        }
+
+        private void addMatchingClass(String name) {
+            matches.add(name);
+        }
+
+        @Override
+        public Boolean apply(String s) {
+            return matches.contains(s) ? matchResult : null;
+        }
+    }
+}
diff --git a/ejb3/src/test/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilterUnitTestCase.java b/ejb3/src/test/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilterUnitTestCase.java
new file mode 100644
index 0000000000..daf7fe4a2a
--- /dev/null
+++ b/ejb3/src/test/java/org/jboss/as/ejb3/subsystem/FilterSpecClassResolverFilterUnitTestCase.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2020. Red Hat, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.jboss.as.ejb3.subsystem;
+
+import static org.jboss.as.ejb3.subsystem.FilterSpecClassResolverFilter.DEFAULT_FILTER_SPEC;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class FilterSpecClassResolverFilterUnitTestCase {
+
+    private static final String[] DEFAULT_SPECS = DEFAULT_FILTER_SPEC.split(";");
+
+    @Test
+    public void testBlackListSanity() {
+        // It's fine to change this list if we change what we want.
+        // This test is just a guard against unintended modification
+        final String sanityFilterSpec =
+                "!org.apache.commons.collections.functors.InvokerTransformer;"
+                        + "!org.apache.commons.collections.functors.InstantiateTransformer;"
+                        + "!org.apache.commons.collections4.functors.InvokerTransformer;"
+                        + "!org.apache.commons.collections4.functors.InstantiateTransformer;"
+                        + "!org.codehaus.groovy.runtime.ConvertedClosure;"
+                        + "!org.codehaus.groovy.runtime.MethodClosure;"
+                        + "!org.springframework.beans.factory.ObjectFactory;"
+                        + "!com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;"
+                        + "!org.apache.xalan.xsltc.trax.TemplatesImpl";
+
+        Set<String> defaultSpec = new HashSet<>(Arrays.asList(DEFAULT_SPECS));
+        for (String spec : sanityFilterSpec.split(";")) {
+            Assert.assertTrue(spec, defaultSpec.contains(spec));
+        }
+    }
+
+    @Test
+    public void testDefaultBlacklist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter();
+        for (String spec : DEFAULT_SPECS) {
+            boolean negate = spec.startsWith("!");
+            if (negate) {
+                Assert.assertFalse(spec, filter.apply(spec.substring(1)));
+            } else {
+                Assert.assertTrue(spec, filter.apply(spec));
+            }
+        }
+    }
+
+    @Test
+    public void testDefaultBlacklistDisabled() {
+        String currentFlag = System.getProperty("jboss.ejb.unmarshalling.filter.disabled");
+        try {
+            System.setProperty("jboss.ejb.unmarshalling.filter.disabled", "true");
+            FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter();
+            for (String spec : DEFAULT_SPECS) {
+                spec = spec.startsWith("!") ? spec.substring(1) : spec;
+                Assert.assertTrue(spec, filter.apply(spec));
+            }
+        } finally {
+            if (currentFlag == null) {
+                System.clearProperty("jboss.ejb.unmarshalling.filter.disabled");
+            } else {
+                System.setProperty("jboss.ejb.unmarshalling.filter.disabled", currentFlag);
+            }
+        }
+    }
+
+    @Test
+    public void testBasicWhitelist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("java.lang.String");
+        Assert.assertTrue(filter.apply("java.lang.String"));
+        Assert.assertFalse(filter.apply("java.lang.Integer"));
+    }
+
+    @Test
+    public void testWhitelistAllowsEjbClient() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("java.lang.String");
+        Assert.assertTrue(filter.apply("org.jboss.ejb.client.SessionId"));
+        Assert.assertTrue(filter.apply("org.jboss.ejb.client.Foo"));
+        Assert.assertFalse(filter.apply("org.jboss.ejb.client.foo.Bar"));
+    }
+
+    // It's fine to remove this test if the jboss.experimental.ejb.unmarshalling.filter.spec logic is removed
+    @Test
+    public void testExperimentalConfig() {
+        String currentFlag = System.getProperty("jboss.experimental.ejb.unmarshalling.filter.spec");
+        try {
+            System.setProperty("jboss.experimental.ejb.unmarshalling.filter.spec", "java.lang.String;java.lang.Boolean");
+            FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter();
+            Assert.assertTrue(filter.apply("java.lang.String"));
+            Assert.assertTrue(filter.apply("java.lang.Boolean"));
+            Assert.assertFalse(filter.apply("java.lang.Integer"));
+        } finally {
+            if (currentFlag == null) {
+                System.clearProperty("jboss.experimental.ejb.unmarshalling.filter.spec");
+            } else {
+                System.setProperty("jboss.experimental.ejb.unmarshalling.filter.spec", currentFlag);
+            }
+        }
+    }
+
+    @Test
+    public void testPackageWhitelist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("foo.bar.*");
+        Assert.assertTrue(filter.apply("foo.bar.FooBar"));
+        Assert.assertTrue(filter.apply("foo.bar.Baz"));
+        Assert.assertFalse(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertFalse(filter.apply("foo.barFly"));
+        Assert.assertFalse(filter.apply("foo.baz.bar.FooBar"));
+    }
+
+    @Test
+    public void testPackageBlacklist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("!foo.bar.*");
+        Assert.assertFalse(filter.apply("foo.bar.FooBar"));
+        Assert.assertFalse(filter.apply("foo.bar.Baz"));
+        Assert.assertTrue(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertTrue(filter.apply("foo.barFly"));
+        Assert.assertTrue(filter.apply("foo.baz.bar.FooBar"));
+    }
+
+    @Test
+    public void testPackageHierarchyWhitelist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("foo.bar.**");
+        Assert.assertTrue(filter.apply("foo.bar.FooBar"));
+        Assert.assertTrue(filter.apply("foo.bar.Baz"));
+        Assert.assertTrue(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertFalse(filter.apply("foo.barFly"));
+        Assert.assertFalse(filter.apply("foo.baz.bar.FooBar"));
+    }
+
+    @Test
+    public void testPackageHierarchyBlacklist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("!foo.bar.**");
+        Assert.assertFalse(filter.apply("foo.bar.FooBar"));
+        Assert.assertFalse(filter.apply("foo.bar.Baz"));
+        Assert.assertFalse(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertTrue(filter.apply("foo.barFly"));
+        Assert.assertTrue(filter.apply("foo.baz.bar.FooBar"));
+    }
+
+    @Test
+    public void testEndsWithWhitelist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("foo.bar*");
+        Assert.assertTrue(filter.apply("foo.bar.FooBar"));
+        Assert.assertTrue(filter.apply("foo.bar.Baz"));
+        Assert.assertTrue(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertTrue(filter.apply("foo.barFly"));
+        Assert.assertFalse(filter.apply("foo.baz.bar.FooBar"));
+        Assert.assertFalse(filter.apply("foo.bazFly"));
+    }
+
+    @Test
+    public void testEndsWithBlacklist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("!foo.bar*");
+        Assert.assertFalse(filter.apply("foo.bar.FooBar"));
+        Assert.assertFalse(filter.apply("foo.bar.Baz"));
+        Assert.assertFalse(filter.apply("foo.bar.baz.FooBar"));
+        Assert.assertFalse(filter.apply("foo.barFly"));
+        Assert.assertTrue(filter.apply("foo.baz.bar.FooBar"));
+        Assert.assertTrue(filter.apply("foo.bazFly"));
+    }
+
+    @Test
+    public void testGlobalWhitelist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("*");
+
+        for (String spec : DEFAULT_SPECS) {
+            spec = spec.startsWith("!") ? spec.substring(1) : spec;
+            Assert.assertTrue(spec, filter.apply(spec));
+        }
+        Assert.assertTrue(filter.apply("java.lang.String"));
+        Assert.assertTrue(filter.apply(""));
+        Assert.assertTrue(filter.apply("*")); // not really legal input but why not :)
+    }
+
+    @Test
+    public void testEmptySpec() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("");
+
+        for (String spec : DEFAULT_SPECS) {
+            spec = spec.startsWith("!") ? spec.substring(1) : spec;
+            Assert.assertTrue(spec, filter.apply(spec));
+        }
+        Assert.assertTrue(filter.apply("java.lang.String"));
+        Assert.assertTrue(filter.apply(""));
+        Assert.assertTrue(filter.apply("*")); // not really legal input but why not :)
+    }
+
+    @Test
+    public void testGlobalBlacklist() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("!*");
+
+        for (String spec : DEFAULT_SPECS) {
+            spec = spec.startsWith("!") ? spec.substring(1) : spec;
+            Assert.assertFalse(spec, filter.apply(spec));
+        }
+        Assert.assertFalse(filter.apply("java.lang.String"));
+        Assert.assertFalse(filter.apply(""));
+        Assert.assertFalse(filter.apply("*")); // not really legal input but why not :)
+    }
+
+    @Test
+    public void testWhiteListExceptions() {
+        exceptionTest("!foo.bar.Baz;foo.bar.*");
+        exceptionTest("foo.bar.*;!foo.bar.Baz");
+        exceptionTest("!foo.bar.Baz;foo.bar.**");
+        exceptionTest("foo.bar.**;!foo.bar.Baz");
+        exceptionTest("!foo.bar.Baz;foo.bar*");
+        exceptionTest("foo.bar*;!foo.bar.Baz");
+        exceptionTest("!foo.bar.Baz;foo.bar.FooBar");
+        exceptionTest("foo.bar.FooBar;!foo.bar.Baz");
+        // Negation overrules even exact whitelisting
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter("!foo.bar.Baz;foo.bar.Baz");
+        Assert.assertFalse(filter.apply("foo.bar.Baz"));
+    }
+
+    private void exceptionTest(String filterSpec) {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter(filterSpec);
+        Assert.assertFalse(filter.apply("foo.bar.Baz"));
+        Assert.assertTrue(filter.apply("foo.bar.FooBar"));
+    }
+
+    @Test
+    public void testNullInput() {
+        FilterSpecClassResolverFilter filter = new FilterSpecClassResolverFilter();
+        try {
+            filter.apply(null);
+            Assert.fail("Null input accepted");
+        } catch (IllegalArgumentException good) {
+            // good
+        }
+    }
+
+    @Test
+    public void testIllegalSpecs() {
+        illegalSpecTest("foo.***");
+        illegalSpecTest("foo.*.**");
+        illegalSpecTest("foo.*.bar.**");
+        illegalSpecTest("foo.**.**");
+        illegalSpecTest("*foo.Bar");
+        illegalSpecTest("*foo.*");
+        illegalSpecTest("*foo.**");
+        illegalSpecTest("*foo*");
+        illegalSpecTest("foo.Bar;bar*.Baz");
+        illegalSpecTest("a=2");
+        illegalSpecTest("foo.*;a=2;bar.baz.**");
+    }
+
+    private void illegalSpecTest(String spec) {
+        try {
+            new FilterSpecClassResolverFilter(spec);
+            Assert.fail("Illegal spec should have been rejected: " + spec);
+        } catch (IllegalArgumentException good) {
+            // good
+        }
+    }
+}
