commit b2aa9f49b46a7b0e03d8b8d753809cd1e8e2016c
Author: Trustin Lee <trustin@linecorp.com>
Date:   Mon Feb 26 10:43:20 2024 +0900

    Merge pull request from GHSA-4m6j-23p2-8c54
    
    * Reject an unsigned SAML message by default
    
    Motivation:
    
    When the binding protocol is HTTP POST, Armeria doesn't reject an
    unsigned SAML message. This allows an attacker to forge a SAML message
    to bypass authentication.
    
    Note that an unsigned SAML message is rejected as expected when the
    binding protocol is HTTP redirect.
    
    Modifications:
    
    - Introduced a new configuration property called `signatureRequired` to
      `SamlServiceProvider` and `SamlServiceProviderBuilder`, whose default
      is `true`.
    - Modified the `validateSignature()` methods in `SamlMessageUtil` and
      `HttpRedirectBindingUtil` to respect the `signatureRequired` property.
    - Miscellaneous:
      - Fixed a typo in `SamlServiceProviderTest`
    
    Result:
    
    - An attacker cannot forge a SAML assertion to bypass authentication
      anymore, unless a user explicitly disabled the `signatureRequired`
      option.
    
    * Consistent param names
    
    * Add more tests

diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/HttpRedirectBindingUtil.java b/saml/src/main/java/com/linecorp/armeria/server/saml/HttpRedirectBindingUtil.java
index 4fe3caf6b..f7a3d1f2f 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/HttpRedirectBindingUtil.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/HttpRedirectBindingUtil.java
@@ -131,13 +131,22 @@ final class HttpRedirectBindingUtil {
      */
     private static void validateSignature(Credential validationCredential,
                                           SamlParameters parameters,
-                                          String messageParamName) {
+                                          String messageParamName,
+                                          boolean signatureRequired) {
         requireNonNull(validationCredential, "validationCredential");
         requireNonNull(parameters, "parameters");
         requireNonNull(messageParamName, "messageParamName");
 
-        final String signature = parameters.getFirstValue(SIGNATURE);
-        final String sigAlg = parameters.getFirstValue(SIGNATURE_ALGORITHM);
+        final String signature = parameters.getFirstValueOrNull(SIGNATURE);
+        final String sigAlg = parameters.getFirstValueOrNull(SIGNATURE_ALGORITHM);
+
+        if (signature == null || sigAlg == null) {
+            if (signatureRequired) {
+                throw new InvalidSamlRequestException("rejecting due to a missing signature");
+            } else {
+                return;
+            }
+        }
 
         // The order is one of the followings:
         // - SAMLRequest={value}&RelayState={value}=SigAlg={value}
@@ -236,7 +245,8 @@ final class HttpRedirectBindingUtil {
     static <T extends SAMLObject> MessageContext<T> toSamlObject(
             AggregatedHttpRequest req, String name,
             Map<String, SamlIdentityProviderConfig> idpConfigs,
-            @Nullable SamlIdentityProviderConfig defaultIdpConfig) {
+            @Nullable SamlIdentityProviderConfig defaultIdpConfig,
+            boolean signatureRequired) {
         requireNonNull(req, "req");
         requireNonNull(name, "name");
         requireNonNull(idpConfigs, "idpConfigs");
@@ -275,7 +285,7 @@ final class HttpRedirectBindingUtil {
 
         // If this message is sent via HTTP-redirect binding protocol, its signature parameter should
         // be validated.
-        validateSignature(config.signingCredential(), parameters, name);
+        validateSignature(config.signingCredential(), parameters, name, signatureRequired);
 
         final String relayState = parameters.getFirstValueOrNull(RELAY_STATE);
         if (relayState != null) {
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlAssertionConsumerFunction.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlAssertionConsumerFunction.java
index f9919d039..599a9bf77 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlAssertionConsumerFunction.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlAssertionConsumerFunction.java
@@ -67,28 +67,33 @@ final class SamlAssertionConsumerFunction implements SamlServiceFunction {
 
     private final SamlRequestIdManager requestIdManager;
     private final SamlSingleSignOnHandler ssoHandler;
+    private final boolean signatureRequired;
 
     SamlAssertionConsumerFunction(SamlAssertionConsumerConfig cfg, String entityId,
                                   Map<String, SamlIdentityProviderConfig> idpConfigs,
                                   @Nullable SamlIdentityProviderConfig defaultIdpConfig,
                                   SamlRequestIdManager requestIdManager,
-                                  SamlSingleSignOnHandler ssoHandler) {
+                                  SamlSingleSignOnHandler ssoHandler,
+                                  boolean signatureRequired) {
         this.cfg = cfg;
         this.entityId = entityId;
         this.idpConfigs = idpConfigs;
         this.defaultIdpConfig = defaultIdpConfig;
         this.requestIdManager = requestIdManager;
         this.ssoHandler = ssoHandler;
+        this.signatureRequired = signatureRequired;
     }
 
     @Override
     public HttpResponse serve(ServiceRequestContext ctx, AggregatedHttpRequest req,
                               String defaultHostname, SamlPortConfig portConfig) {
         try {
+            final SamlBindingProtocol bindingProtocol = cfg.endpoint().bindingProtocol();
             final MessageContext<Response> messageContext;
-            if (cfg.endpoint().bindingProtocol() == SamlBindingProtocol.HTTP_REDIRECT) {
+            if (bindingProtocol == SamlBindingProtocol.HTTP_REDIRECT) {
                 messageContext = HttpRedirectBindingUtil.toSamlObject(req, SAML_RESPONSE,
-                                                                      idpConfigs, defaultIdpConfig);
+                                                                      idpConfigs, defaultIdpConfig,
+                                                                      signatureRequired);
             } else {
                 messageContext = HttpPostBindingUtil.toSamlObject(req, SAML_RESPONSE);
             }
@@ -96,7 +101,9 @@ final class SamlAssertionConsumerFunction implements SamlServiceFunction {
             final String endpointUri = cfg.endpoint().toUriString(portConfig.scheme().uriText(),
                                                                   defaultHostname, portConfig.port());
             final Response response = messageContext.getMessage();
-            final Assertion assertion = getValidatedAssertion(response, endpointUri);
+            assert response != null;
+
+            final Assertion assertion = getValidatedAssertion(bindingProtocol, response, endpointUri);
 
             // Find a session index which is sent by an identity provider.
             final String sessionIndex = assertion.getAuthnStatements().stream()
@@ -125,7 +132,8 @@ final class SamlAssertionConsumerFunction implements SamlServiceFunction {
                                               issuer.getValue());
     }
 
-    private Assertion getValidatedAssertion(Response response, String endpointUri) {
+    private Assertion getValidatedAssertion(SamlBindingProtocol bindingProtocol,
+                                            Response response, String endpointUri) {
         final Status status = response.getStatus();
         final String statusCode = status.getStatusCode().getValue();
         if (!StatusCode.SUCCESS.equals(statusCode)) {
@@ -190,8 +198,13 @@ final class SamlAssertionConsumerFunction implements SamlServiceFunction {
 
             final SamlIdentityProviderConfig idp = resolveIdpConfig(issuer);
 
-            validateSignature(idp.signingCredential(), response);
-            validateSignature(idp.signingCredential(), assertion);
+            if (bindingProtocol != SamlBindingProtocol.HTTP_REDIRECT) {
+                validateSignature(idp.signingCredential(), response, signatureRequired);
+            } else {
+                // The above `HttpRedirectBindingUtil.toSamlObject()` call performed the validation already.
+            }
+
+            validateSignature(idp.signingCredential(), assertion, signatureRequired);
 
             final List<AuthnStatement> authnStatements = assertion.getAuthnStatements();
             if (authnStatements.isEmpty()) {
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlMessageUtil.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlMessageUtil.java
index f787c7c32..5ac8d6478 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlMessageUtil.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlMessageUtil.java
@@ -153,18 +153,19 @@ final class SamlMessageUtil {
         }
     }
 
-    static void validateSignature(Credential validationCredential, SignableSAMLObject signableObj) {
+    static void validateSignature(Credential validationCredential, SignableSAMLObject signableObj,
+                                  boolean signatureRequired) {
         requireNonNull(validationCredential, "validationCredential");
         requireNonNull(signableObj, "signableObj");
 
-        // Skip signature validation if the object is not signed.
-        if (!signableObj.isSigned()) {
-            return;
-        }
-
+        // Reject the object if signature is missing, unless allowed explicitly.
         final Signature signature = signableObj.getSignature();
-        if (signature == null) {
-            throw new InvalidSamlRequestException("failed to validate a signature because no signature exists");
+        if (signature == null || !signableObj.isSigned()) {
+            if (signatureRequired) {
+                throw new InvalidSamlRequestException("rejecting due to a missing signature");
+            } else {
+                return;
+            }
         }
 
         try {
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlService.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlService.java
index 32ac13662..6c74f9fae 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlService.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlService.java
@@ -89,7 +89,8 @@ final class SamlService implements HttpServiceWithRoutes {
                                                                      sp.idpConfigs(),
                                                                      sp.defaultIdpConfig(),
                                                                      sp.requestIdManager(),
-                                                                     sp.ssoHandler())));
+                                                                     sp.ssoHandler(),
+                                                                     sp.isSignatureRequired())));
         sp.sloEndpoints().forEach(
                 cfg -> builder.put(cfg.uri().getPath(),
                                    new SamlSingleLogoutFunction(cfg,
@@ -99,7 +100,8 @@ final class SamlService implements HttpServiceWithRoutes {
                                                                 sp.idpConfigs(),
                                                                 sp.defaultIdpConfig(),
                                                                 sp.requestIdManager(),
-                                                                sp.sloHandler())));
+                                                                sp.sloHandler(),
+                                                                sp.isSignatureRequired())));
         final Route route = sp.metadataRoute();
         if (route.pathType() == RoutePathType.EXACT) {
             builder.put(route.paths().get(0),
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProvider.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProvider.java
index 5b382f8c0..b89ca9f2b 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProvider.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProvider.java
@@ -78,6 +78,7 @@ public final class SamlServiceProvider {
 
     private final SamlSingleSignOnHandler ssoHandler;
     private final SamlSingleLogoutHandler sloHandler;
+    private final boolean signatureRequired;
 
     /**
      * A class which helps a {@link Server} have a SAML-based authentication.
@@ -97,7 +98,8 @@ public final class SamlServiceProvider {
                         Collection<SamlEndpoint> sloEndpoints,
                         SamlRequestIdManager requestIdManager,
                         SamlSingleSignOnHandler ssoHandler,
-                        SamlSingleLogoutHandler sloHandler) {
+                        SamlSingleLogoutHandler sloHandler,
+                        boolean signatureRequired) {
         this.authorizer = requireNonNull(authorizer, "authorizer");
         this.entityId = requireNonNull(entityId, "entityId");
         this.hostname = hostname;
@@ -114,6 +116,7 @@ public final class SamlServiceProvider {
         this.requestIdManager = requireNonNull(requestIdManager, "requestIdManager");
         this.ssoHandler = requireNonNull(ssoHandler, "ssoHandler");
         this.sloHandler = requireNonNull(sloHandler, "sloHandler");
+        this.signatureRequired = signatureRequired;
 
         defaultAcsConfig = acsConfigs.stream().filter(SamlAssertionConsumerConfig::isDefault).findFirst()
                                      .orElseThrow(() -> new IllegalArgumentException(
@@ -244,6 +247,13 @@ public final class SamlServiceProvider {
         return sloHandler;
     }
 
+    /**
+     * Returns whether to require an SAML message to have a signature.
+     */
+    boolean isSignatureRequired() {
+        return signatureRequired;
+    }
+
     /**
      * Creates a decorator which initiates a SAML authentication if a request is not authenticated.
      */
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProviderBuilder.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProviderBuilder.java
index d3f03a4ca..371c9df1d 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProviderBuilder.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlServiceProviderBuilder.java
@@ -99,6 +99,8 @@ public final class SamlServiceProviderBuilder {
     @Nullable
     private SamlRequestIdManager requestIdManager;
 
+    private boolean signatureRequired = true;
+
     private SamlSingleSignOnHandler ssoHandler = new SamlSingleSignOnHandler() {
         @Override
         public CompletionStage<Void> beforeInitiatingSso(ServiceRequestContext ctx, HttpRequest req,
@@ -309,6 +311,21 @@ public final class SamlServiceProviderBuilder {
         return config;
     }
 
+    /**
+     * Sets whether to require the received SAML objects to be signed. If enabled, the received SAML objects
+     * are rejected when they are not signed or have invalid signature. Otherwise, the received SAML objects
+     * will be accepted even if they are not signed, although the objects with an invalid signature will still
+     * be rejected. It is <strong>strongly discouraged</strong> to disable this option because otherwise
+     * an attacker can forge an SAML object to bypass authentication. This option is enabled by default.
+     *
+     * @param signatureRequired {@code true} to reject the SAML objects without signature.
+     *                          {@code false} to accept the SAML objects without signature.
+     */
+    public SamlServiceProviderBuilder signatureRequired(boolean signatureRequired) {
+        this.signatureRequired = signatureRequired;
+        return this;
+    }
+
     /**
      * Builds a {@link SamlServiceProvider} which helps a {@link Server} have a SAML-based
      * authentication.
@@ -446,7 +463,8 @@ public final class SamlServiceProviderBuilder {
                                        sloEndpoints,
                                        requestIdManager,
                                        ssoHandler,
-                                       sloHandler);
+                                       sloHandler,
+                                       signatureRequired);
     }
 
     private static void validateSignatureAlgorithm(String signatureAlgorithm, Credential credential) {
diff --git a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlSingleLogoutFunction.java b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlSingleLogoutFunction.java
index 7756859ec..abdb516bc 100644
--- a/saml/src/main/java/com/linecorp/armeria/server/saml/SamlSingleLogoutFunction.java
+++ b/saml/src/main/java/com/linecorp/armeria/server/saml/SamlSingleLogoutFunction.java
@@ -63,6 +63,7 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
 
     private final SamlRequestIdManager requestIdManager;
     private final SamlSingleLogoutHandler sloHandler;
+    private final boolean signatureRequired;
 
     SamlSingleLogoutFunction(SamlEndpoint endpoint, String entityId,
                              Credential signingCredential,
@@ -70,7 +71,8 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
                              Map<String, SamlIdentityProviderConfig> idpConfigs,
                              @Nullable SamlIdentityProviderConfig defaultIdpConfig,
                              SamlRequestIdManager requestIdManager,
-                             SamlSingleLogoutHandler sloHandler) {
+                             SamlSingleLogoutHandler sloHandler,
+                             boolean signatureRequired) {
         this.endpoint = endpoint;
         this.entityId = entityId;
         this.signingCredential = signingCredential;
@@ -79,6 +81,7 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
         this.defaultIdpConfig = defaultIdpConfig;
         this.requestIdManager = requestIdManager;
         this.sloHandler = sloHandler;
+        this.signatureRequired = signatureRequired;
     }
 
     @Override
@@ -88,7 +91,8 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
             final MessageContext<LogoutRequest> messageContext;
             if (endpoint.bindingProtocol() == SamlBindingProtocol.HTTP_REDIRECT) {
                 messageContext = HttpRedirectBindingUtil.toSamlObject(req, SAML_REQUEST,
-                                                                      idpConfigs, defaultIdpConfig);
+                                                                      idpConfigs, defaultIdpConfig,
+                                                                      signatureRequired);
             } else {
                 messageContext = HttpPostBindingUtil.toSamlObject(req, SAML_REQUEST);
             }
@@ -98,8 +102,10 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
             final LogoutRequest logoutRequest = messageContext.getMessage();
             final SamlIdentityProviderConfig idp = validateAndGetIdPConfig(logoutRequest, endpointUri);
 
-            if (endpoint.bindingProtocol() == SamlBindingProtocol.HTTP_POST) {
-                validateSignature(idp.signingCredential(), logoutRequest);
+            if (endpoint.bindingProtocol() != SamlBindingProtocol.HTTP_REDIRECT) {
+                validateSignature(idp.signingCredential(), logoutRequest, signatureRequired);
+            } else {
+                // The above `HttpRedirectBindingUtil.toSamlObject()` call performed the validation already.
             }
 
             final SamlEndpoint sloResEndpoint = idp.sloResEndpoint();
@@ -128,7 +134,13 @@ final class SamlSingleLogoutFunction implements SamlServiceFunction {
 
     private static HttpResponse fail(ServiceRequestContext ctx, Throwable cause) {
         logger.warn("{} Cannot handle a logout request", ctx, cause);
-        return HttpResponse.of(HttpStatus.SERVICE_UNAVAILABLE);
+        final HttpStatus status;
+        if (cause instanceof InvalidSamlRequestException) {
+            status = HttpStatus.BAD_REQUEST;
+        } else {
+            status = HttpStatus.SERVICE_UNAVAILABLE;
+        }
+        return HttpResponse.of(status);
     }
 
     private HttpResponse fail(ServiceRequestContext ctx,
diff --git a/saml/src/test/java/com/linecorp/armeria/server/saml/SamlServiceProviderTest.java b/saml/src/test/java/com/linecorp/armeria/server/saml/SamlServiceProviderTest.java
index 1db632a0a..1ea46283d 100644
--- a/saml/src/test/java/com/linecorp/armeria/server/saml/SamlServiceProviderTest.java
+++ b/saml/src/test/java/com/linecorp/armeria/server/saml/SamlServiceProviderTest.java
@@ -29,13 +29,17 @@ import static com.linecorp.armeria.server.saml.SamlHttpParameterNames.SIGNATURE;
 import static com.linecorp.armeria.server.saml.SamlHttpParameterNames.SIGNATURE_ALGORITHM;
 import static com.linecorp.armeria.server.saml.SamlMessageUtil.build;
 import static com.linecorp.armeria.server.saml.SamlMessageUtil.deserialize;
+import static com.linecorp.armeria.server.saml.SamlMessageUtil.serialize;
 import static com.linecorp.armeria.server.saml.SamlMessageUtil.sign;
 import static com.linecorp.armeria.server.saml.SamlMetadataServiceFunction.CONTENT_TYPE_SAML_METADATA;
 import static java.util.Objects.requireNonNull;
+import static net.shibboleth.utilities.java.support.xml.SerializeSupport.nodeToString;
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.nio.charset.StandardCharsets;
 import java.security.KeyStore;
 import java.security.cert.Certificate;
+import java.util.Base64;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -114,29 +118,24 @@ class SamlServiceProviderTest {
     private static final String signatureAlgorithm = SignatureConstants.ALGO_ID_SIGNATURE_RSA;
 
     private static final String spHostname = "localhost";
-    // Entity ID can be any form of a string. An URI string is one of the general forms of that.
+    // Entity ID can be any form of a string. A URI string is one of the general forms of that.
     private static final String spEntityId = "http://127.0.0.1";
     private static final CredentialResolver spCredentialResolver;
 
     private static final Credential idpCredential;
 
+    private static final Credential badIdpCredential;
+
     private static final SamlRequestIdManager requestIdManager = new SequentialRequestIdManager();
 
     static {
         try {
             // Create IdP's key store for testing.
-            final KeyStore idpKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
-            idpKeyStore.load(null, null);
-
             final SelfSignedCertificate idp = new SelfSignedCertificate();
-            idpKeyStore.setKeyEntry("signing", idp.key(), "".toCharArray(),
-                                    new Certificate[] { idp.cert() });
-            final CredentialResolver idpCredentialResolver =
-                    new KeyStoreCredentialResolver(idpKeyStore, ImmutableMap.of("signing", ""));
+            idpCredential = toIdpCredential(idp);
 
-            final CriteriaSet cs = new CriteriaSet();
-            cs.add(new EntityIdCriterion("signing"));
-            idpCredential = idpCredentialResolver.resolveSingle(cs);
+            // Create a bad IdP's key store to ensure our SAML implementation rejects an invalid signature.
+            badIdpCredential = toIdpCredential(new SelfSignedCertificate());
 
             // Create my key store for testing.
             final KeyStore myKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
@@ -164,6 +163,22 @@ class SamlServiceProviderTest {
         }
     }
 
+    private static Credential toIdpCredential(SelfSignedCertificate ssc) throws Exception {
+        final KeyStore idpKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+        idpKeyStore.load(null, null);
+
+        idpKeyStore.setKeyEntry("signing", ssc.key(), "".toCharArray(), new Certificate[] { ssc.cert() });
+        final CredentialResolver idpCredentialResolver =
+                new KeyStoreCredentialResolver(idpKeyStore, ImmutableMap.of("signing", ""));
+
+        final CriteriaSet badCs = new CriteriaSet();
+        badCs.add(new EntityIdCriterion("signing"));
+
+        final Credential credential = idpCredentialResolver.resolveSingle(badCs);
+        assert credential != null;
+        return credential;
+    }
+
     @RegisterExtension
     static final ServerExtension server = new ServerExtension() {
         @Override
@@ -389,7 +404,8 @@ class SamlServiceProviderTest {
         final Response response =
                 getAuthResponse("http://" + spHostname + ':' + server.httpPort() + "/saml/acs/post");
         final AggregatedHttpResponse res = sendViaHttpPostBindingProtocol("/saml/acs/post",
-                                                                          SAML_RESPONSE, response);
+                                                                          SAML_RESPONSE, response,
+                                                                          idpCredential);
 
         assertThat(res.status()).isEqualTo(HttpStatus.FOUND);
         assertThat(res.headers().get(HttpHeaderNames.LOCATION)).isEqualTo("/");
@@ -400,12 +416,55 @@ class SamlServiceProviderTest {
         final Response response =
                 getAuthResponse("http://" + spHostname + ':' + server.httpPort() + "/saml/acs/redirect");
         final AggregatedHttpResponse res = sendViaHttpRedirectBindingProtocol("/saml/acs/redirect",
-                                                                              SAML_RESPONSE, response);
+                                                                              SAML_RESPONSE, response,
+                                                                              idpCredential);
 
         assertThat(res.status()).isEqualTo(HttpStatus.FOUND);
         assertThat(res.headers().get(HttpHeaderNames.LOCATION)).isEqualTo("/");
     }
 
+    @Test
+    void shouldNotConsumeAssertionWithInvalidSignature_HttpPost() throws Exception {
+        shouldNotConsumeAssertion_HttpPost(badIdpCredential);
+    }
+
+    @Test
+    void shouldNotConsumeAssertionWithInvalidSignature_HttpRedirect() throws Exception {
+        shouldNotConsumeAssertion_HttpRedirect(badIdpCredential);
+    }
+
+    @Test
+    void shouldNotConsumeAssertionWithoutSignature_HttpPost() throws Exception {
+        shouldNotConsumeAssertion_HttpPost(null);
+    }
+
+    @Test
+    void shouldNotConsumeAssertionWithoutSignature_HttpRedirect() throws Exception {
+        shouldNotConsumeAssertion_HttpRedirect(null);
+    }
+
+    private void shouldNotConsumeAssertion_HttpPost(@Nullable Credential idpCredential) throws Exception {
+        final Response response =
+                getAuthResponse("http://" + spHostname + ':' + server.httpPort() + "/saml/acs/post");
+        final AggregatedHttpResponse res = sendViaHttpPostBindingProtocol("/saml/acs/post",
+                                                                          SAML_RESPONSE, response,
+                                                                          idpCredential);
+
+        assertThat(res.status()).isEqualTo(HttpStatus.BAD_REQUEST);
+        assertThat(res.headers().get(HttpHeaderNames.LOCATION)).isNull();
+    }
+
+    private void shouldNotConsumeAssertion_HttpRedirect(@Nullable Credential idpCredential) throws Exception {
+        final Response response =
+                getAuthResponse("http://" + spHostname + ':' + server.httpPort() + "/saml/acs/redirect");
+        final AggregatedHttpResponse res = sendViaHttpRedirectBindingProtocol("/saml/acs/redirect",
+                                                                              SAML_RESPONSE, response,
+                                                                              idpCredential);
+
+        assertThat(res.status()).isEqualTo(HttpStatus.BAD_REQUEST);
+        assertThat(res.headers().get(HttpHeaderNames.LOCATION)).isNull();
+    }
+
     private static Response getAuthResponse(String recipient) throws Exception {
         // IdP entity ID
         final Issuer issuer = build(Issuer.DEFAULT_ELEMENT_NAME);
@@ -472,8 +531,8 @@ class SamlServiceProviderTest {
                 getLogoutRequest("http://" + spHostname + ':' + server.httpPort() + "/saml/slo/post",
                                  "http://idp.example.com/post");
 
-        final AggregatedHttpResponse res = sendViaHttpPostBindingProtocol("/saml/slo/post",
-                                                                          SAML_REQUEST, logoutRequest);
+        final AggregatedHttpResponse res = sendViaHttpPostBindingProtocol("/saml/slo/post", SAML_REQUEST,
+                                                                          logoutRequest, idpCredential);
 
         assertThat(res.status()).isEqualTo(HttpStatus.OK);
         assertThat(res.contentType()).isEqualTo(MediaType.HTML_UTF_8);
@@ -495,7 +554,8 @@ class SamlServiceProviderTest {
                                  "http://idp.example.com/redirect");
 
         final AggregatedHttpResponse res =
-                sendViaHttpRedirectBindingProtocol("/saml/slo/redirect", SAML_REQUEST, logoutRequest);
+                sendViaHttpRedirectBindingProtocol("/saml/slo/redirect", SAML_REQUEST,
+                                                   logoutRequest, idpCredential);
 
         assertThat(res.status()).isEqualTo(HttpStatus.FOUND);
 
@@ -508,6 +568,52 @@ class SamlServiceProviderTest {
         assertThat(p.matcher(location).matches()).isTrue();
     }
 
+    @Test
+    void shouldNotConsumeLogoutRequestWithInvalidSignature_HttpPost() throws Exception {
+        shouldNotConsumeLogoutRequest_HttpPost(badIdpCredential);
+    }
+
+    @Test
+    void shouldNotConsumeLogoutRequestWithInvalidSignature_HttpRedirect() throws Exception {
+        shouldNotConsumeLogoutRequest_HttpRedirect(badIdpCredential);
+    }
+
+    @Test
+    void shouldNotConsumeLogoutRequestWithoutSignature_HttpPost() throws Exception {
+        shouldNotConsumeLogoutRequest_HttpPost(null);
+    }
+
+    @Test
+    void shouldNotConsumeLogoutRequestWithoutSignature_HttpRedirect() throws Exception {
+        shouldNotConsumeLogoutRequest_HttpRedirect(null);
+    }
+
+    private void shouldNotConsumeLogoutRequest_HttpPost(@Nullable Credential idpCredential) {
+        final LogoutRequest logoutRequest =
+                getLogoutRequest("http://" + spHostname + ':' + server.httpPort() + "/saml/slo/post",
+                                 "http://idp.example.com/post");
+
+        final AggregatedHttpResponse res = sendViaHttpPostBindingProtocol("/saml/slo/post", SAML_REQUEST,
+                                                                          logoutRequest, idpCredential);
+
+        assertThat(res.status()).isEqualTo(HttpStatus.BAD_REQUEST);
+        assertThat(res.contentType()).isEqualTo(MediaType.PLAIN_TEXT_UTF_8);
+        assertThat(res.contentUtf8()).isEqualTo("400 Bad Request");
+    }
+
+    private void shouldNotConsumeLogoutRequest_HttpRedirect(@Nullable Credential idpCredential) {
+        final LogoutRequest logoutRequest =
+                getLogoutRequest("http://" + spHostname + ':' + server.httpPort() + "/saml/slo/redirect",
+                                 "http://idp.example.com/redirect");
+
+        final AggregatedHttpResponse res =
+                sendViaHttpRedirectBindingProtocol("/saml/slo/redirect", SAML_REQUEST,
+                                                   logoutRequest, idpCredential);
+
+        assertThat(res.status()).isEqualTo(HttpStatus.BAD_REQUEST);
+        assertThat(res.headers().get(HttpHeaderNames.LOCATION)).isNull();
+    }
+
     private static LogoutRequest getLogoutRequest(String destination, String issuerId) {
         final LogoutRequest logoutRequest = build(LogoutRequest.DEFAULT_ELEMENT_NAME);
 
@@ -528,22 +634,33 @@ class SamlServiceProviderTest {
     }
 
     private AggregatedHttpResponse sendViaHttpPostBindingProtocol(
-            String path, String paramName, SignableSAMLObject signableObj) throws Exception {
-        final String encoded = toSignedBase64(signableObj, idpCredential, signatureAlgorithm);
+            String path, String paramName, SignableSAMLObject signableObj, @Nullable Credential idpCredential) {
+        final String encoded;
+        if (idpCredential != null) {
+            encoded = toSignedBase64(signableObj, idpCredential, signatureAlgorithm);
+        } else {
+            // Generate an unsigned message.
+            final String messageStr = nodeToString(serialize(signableObj));
+            encoded = Base64.getEncoder().encodeToString(messageStr.getBytes(StandardCharsets.UTF_8));
+        }
+
         final HttpRequest req = HttpRequest.of(HttpMethod.POST, path, MediaType.FORM_DATA,
                                                QueryParams.of(paramName, encoded).toQueryString());
         return client.execute(req).aggregate().join();
     }
 
     private AggregatedHttpResponse sendViaHttpRedirectBindingProtocol(
-            String path, String paramName, SAMLObject samlObject) throws Exception {
+            String path, String paramName, SAMLObject samlObject, @Nullable Credential idpCredential) {
 
         final QueryParamsBuilder params = QueryParams.builder();
         params.add(paramName, toDeflatedBase64(samlObject));
         params.add(SIGNATURE_ALGORITHM, signatureAlgorithm);
         final String input = params.toQueryString();
-        final String output = generateSignature(idpCredential, signatureAlgorithm, input);
-        params.add(SIGNATURE, output);
+        if (idpCredential != null) {
+            params.add(SIGNATURE, generateSignature(idpCredential, signatureAlgorithm, input));
+        } else {
+            // Generate an unsigned message.
+        }
 
         final HttpRequest req = HttpRequest.of(HttpMethod.POST, path, MediaType.FORM_DATA,
                                                params.toQueryString());
