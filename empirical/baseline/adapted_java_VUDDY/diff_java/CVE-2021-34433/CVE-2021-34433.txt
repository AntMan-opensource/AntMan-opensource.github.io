commit 368760ac2ca1144b15f434d805421e68028c3cf8
Author: Achim Kraus <achim.kraus@bosch.io>
Date:   Fri Aug 6 16:24:11 2021 +0200

    Fail on missing signature in server key exchange.
    
    Signed-off-by: Achim Kraus <achim.kraus@bosch.io>

diff --git a/scandium-core/src/main/java/org/eclipse/californium/scandium/dtls/EcdhEcdsaServerKeyExchange.java b/scandium-core/src/main/java/org/eclipse/californium/scandium/dtls/EcdhEcdsaServerKeyExchange.java
index 9a084be56..ae865470a 100644
--- a/scandium-core/src/main/java/org/eclipse/californium/scandium/dtls/EcdhEcdsaServerKeyExchange.java
+++ b/scandium-core/src/main/java/org/eclipse/californium/scandium/dtls/EcdhEcdsaServerKeyExchange.java
@@ -38,15 +38,16 @@ import org.slf4j.LoggerFactory;
 /**
  * The server's ephemeral ECDH with ECDSA signatures.
  * 
- * See <a href="https://tools.ietf.org/html/rfc4492#section-5.4" target="_blank">
- * RFC 4492, section 5.4 Server Key Exchange</a> for details regarding
- * the message format.
+ * See
+ * <a href="https://tools.ietf.org/html/rfc4492#section-5.4" target="_blank">
+ * RFC 4492, section 5.4 Server Key Exchange</a> for details regarding the
+ * message format.
  * 
- * According <a href="https://tools.ietf.org/html/rfc8422#section-5.1.1" target="_blank">RFC
- * 8422, 5.1.1. Supported Elliptic Curves Extension</a> only "named curves" are
- * valid, the "prime" and "char2" curve descriptions are deprecated. Also only
- * "UNCOMPRESSED" as point format is valid, the other formats have been
- * deprecated.
+ * According <a href="https://tools.ietf.org/html/rfc8422#section-5.1.1" target=
+ * "_blank">RFC 8422, 5.1.1. Supported Elliptic Curves Extension</a> only "named
+ * curves" are valid, the "prime" and "char2" curve descriptions are deprecated.
+ * Also only "UNCOMPRESSED" as point format is valid, the other formats have
+ * been deprecated.
  * 
  * @since 2.3
  */
@@ -55,37 +56,29 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 
 	private static final Logger LOGGER = LoggerFactory.getLogger(EcdhEcdsaServerKeyExchange.class);
 
-	// DTLS-specific constants ////////////////////////////////////////
-
 	private static final int HASH_ALGORITHM_BITS = 8;
 	private static final int SIGNATURE_ALGORITHM_BITS = 8;
 	private static final int SIGNATURE_LENGTH_BITS = 16;
 
-	// Members ////////////////////////////////////////////////////////
-
 	private final byte[] signatureEncoded;
 
-	/** The signature and hash algorithm which must be included into the digitally-signed struct. */
+	/**
+	 * The signature and hash algorithm which must be included into the
+	 * digitally-signed struct.
+	 */
 	private final SignatureAndHashAlgorithm signatureAndHashAlgorithm;
 
-	// Constructors //////////////////////////////////////////////////
-
 	/**
 	 * Called by server with generated ephemeral keys and generates signature.
 	 * 
-	 * @param signatureAndHashAlgorithm
-	 *            the algorithm to use
-	 * @param ecdhe
-	 *            the ECDHE helper class. Contains generated ephemeral keys.
-	 * @param serverPrivateKey
-	 *            the server's private key
-	 * @param clientRandom
-	 *            the client's random (used for signature)
-	 * @param serverRandom
-	 *            the server's random (used for signature)
+	 * @param signatureAndHashAlgorithm the algorithm to use
+	 * @param ecdhe the ECDHE helper class. Contains generated ephemeral keys.
+	 * @param serverPrivateKey the server's private key
+	 * @param clientRandom the client's random (used for signature)
+	 * @param serverRandom the server's random (used for signature)
 	 * @throws HandshakeException if generating the signature providing prove of
-	 *            possession of the private key fails, e.g. due to an unsupported
-	 *            signature or hash algorithm or an invalid key
+	 *             possession of the private key fails, e.g. due to an
+	 *             unsupported signature or hash algorithm or an invalid key
 	 */
 	public EcdhEcdsaServerKeyExchange(SignatureAndHashAlgorithm signatureAndHashAlgorithm, XECDHECryptography ecdhe,
 			PrivateKey serverPrivateKey, Random clientRandom, Random serverRandom) throws HandshakeException {
@@ -106,8 +99,7 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 			updateSignature(signature, clientRandom, serverRandom);
 			signatureEncoded = signature.sign();
 		} catch (GeneralSecurityException e) {
-			throw new HandshakeException(
-					String.format("Server failed to sign key exchange: %s", e.getMessage()),
+			throw new HandshakeException(String.format("Server failed to sign key exchange: %s", e.getMessage()),
 					new AlertMessage(AlertLevel.FATAL, AlertDescription.ILLEGAL_PARAMETER));
 		}
 	}
@@ -115,27 +107,27 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 	/**
 	 * Called when reconstructing from the byte array.
 	 * 
-	 * @param signatureAndHashAlgorithm
-	 *            the algorithm to use
-	 * @param supportedGroup
-	 *            the supported group (curve)
-	 * @param encodedPoint
-	 *            the encoded point of the other peeer (public key)
-	 * @param signatureEncoded
-	 *            the signature (encoded)
+	 * @param signatureAndHashAlgorithm the algorithm to use
+	 * @param supportedGroup the supported group (curve)
+	 * @param encodedPoint the encoded point of the other peer (public key)
+	 * @param signatureEncoded the signature (encoded)
+	 * @throws NullPointerException if only one of the parameters
+	 *             signatureAndHashAlgorithm and signatureEncoded is
+	 *             {@code null}, or any of the other parameters
 	 */
-	private EcdhEcdsaServerKeyExchange(SignatureAndHashAlgorithm signatureAndHashAlgorithm, SupportedGroup supportedGroup, byte[] encodedPoint,
-			byte[] signatureEncoded) {
+	private EcdhEcdsaServerKeyExchange(SignatureAndHashAlgorithm signatureAndHashAlgorithm,
+			SupportedGroup supportedGroup, byte[] encodedPoint, byte[] signatureEncoded) {
 		super(supportedGroup, encodedPoint);
-		if (signatureAndHashAlgorithm == null) {
+		if (signatureAndHashAlgorithm == null && signatureEncoded != null) {
 			throw new NullPointerException("signature and hash algorithm cannot be null");
 		}
+		if (signatureAndHashAlgorithm != null && signatureEncoded == null) {
+			throw new NullPointerException("signature cannot be null");
+		}
 		this.signatureAndHashAlgorithm = signatureAndHashAlgorithm;
 		this.signatureEncoded = signatureEncoded;
 	}
 
-	// Serialization //////////////////////////////////////////////////
-
 	@Override
 	public int getMessageLength() {
 		// the signature length field uses 2 bytes, if a signature available
@@ -150,7 +142,8 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 
 		// signature
 		if (signatureEncoded != null) {
-			// according to http://tools.ietf.org/html/rfc5246#section-A.7 the
+			// according to
+			// https://datatracker.ietf.org/doc/html/rfc5246#appendix-A.7 the
 			// signature algorithm must also be included
 			writer.write(signatureAndHashAlgorithm.getHash().getCode(), HASH_ALGORITHM_BITS);
 			writer.write(signatureAndHashAlgorithm.getSignature().getCode(), SIGNATURE_ALGORITHM_BITS);
@@ -162,9 +155,8 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 
 	public static HandshakeMessage fromReader(DatagramReader reader) throws HandshakeException {
 		EcdhData ecdhData = readNamedCurve(reader);
-		// default is SHA256withECDSA
-		SignatureAndHashAlgorithm signAndHash = new SignatureAndHashAlgorithm(SignatureAndHashAlgorithm.HashAlgorithm.SHA256, SignatureAndHashAlgorithm.SignatureAlgorithm.ECDSA);
 
+		SignatureAndHashAlgorithm signAndHash = null;
 		byte[] signatureEncoded = null;
 		if (reader.bytesAvailable()) {
 			int hashAlgorithm = reader.read(HASH_ALGORITHM_BITS);
@@ -172,28 +164,25 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 			signAndHash = new SignatureAndHashAlgorithm(hashAlgorithm, signatureAlgorithm);
 			signatureEncoded = reader.readVarBytes(SIGNATURE_LENGTH_BITS);
 		}
-		return new EcdhEcdsaServerKeyExchange(signAndHash, ecdhData.supportedGroup, ecdhData.encodedPoint, signatureEncoded);
+		return new EcdhEcdsaServerKeyExchange(signAndHash, ecdhData.supportedGroup, ecdhData.encodedPoint,
+				signatureEncoded);
 	}
 
-	// Methods ////////////////////////////////////////////////////////
-
 	/**
 	 * Called by the client after receiving the server's
 	 * {@link ServerKeyExchange} message. Verifies the contained signature.
 	 * 
-	 * @param serverPublicKey
-	 *            the server's public key.
-	 * @param clientRandom
-	 *            the client's random (used in signature).
-	 * @param serverRandom
-	 *            the server's random (used in signature).
-	 * @throws HandshakeException
-	 *             if the signature could not be verified.
+	 * @param serverPublicKey the server's public key.
+	 * @param clientRandom the client's random (used in signature).
+	 * @param serverRandom the server's random (used in signature).
+	 * @throws HandshakeException if the signature could not be verified.
 	 */
-	public void verifySignature(PublicKey serverPublicKey, Random clientRandom, Random serverRandom) throws HandshakeException {
+	public void verifySignature(PublicKey serverPublicKey, Random clientRandom, Random serverRandom)
+			throws HandshakeException {
 		if (signatureEncoded == null) {
-			// no signature available, nothing to verify
-			return;
+			String message = "The server's ECDHE key exchange message has no signature.";
+			AlertMessage alert = new AlertMessage(AlertLevel.FATAL, AlertDescription.DECRYPT_ERROR);
+			throw new HandshakeException(message, alert);
 		}
 		boolean verified = false;
 		try {
@@ -206,9 +195,8 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 			verified = signature.verify(signatureEncoded);
 
 		} catch (GeneralSecurityException e) {
-			LOGGER.error("Could not verify the server's signature.",e);
+			LOGGER.error("Could not verify the server's signature.", e);
 		}
-
 		if (!verified) {
 			String message = "The server's ECDHE key exchange message's signature could not be verified.";
 			AlertMessage alert = new AlertMessage(AlertLevel.FATAL, AlertDescription.DECRYPT_ERROR);
@@ -218,20 +206,18 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 
 	/**
 	 * Update the signature: SHA(ClientHello.random + ServerHello.random +
-	 * ServerKeyExchange.params). See <a
-	 * href="https://tools.ietf.org/html/rfc4492#section-5.4" target="_blank">RFC 4492, Section
-	 * 5.4. Server Key Exchange</a> for further details on the signature format.
+	 * ServerKeyExchange.params). See
+	 * <a href="https://tools.ietf.org/html/rfc4492#section-5.4" target=
+	 * "_blank">RFC 4492, Section 5.4. Server Key Exchange</a> for further
+	 * details on the signature format.
 	 * 
-	 * @param signature
-	 *            the signature
-	 * @param clientRandom
-	 *            the client random
-	 * @param serverRandom
-	 *            the server random
-	 * @throws SignatureException
-	 *             the signature exception
+	 * @param signature the signature
+	 * @param clientRandom the client random
+	 * @param serverRandom the server random
+	 * @throws SignatureException the signature exception
 	 */
-	private void updateSignature(Signature signature, Random clientRandom, Random serverRandom) throws SignatureException {
+	private void updateSignature(Signature signature, Random clientRandom, Random serverRandom)
+			throws SignatureException {
 		signature.update(clientRandom.getBytes());
 		signature.update(serverRandom.getBytes());
 		updateSignatureForNamedCurve(signature);
@@ -239,13 +225,15 @@ public final class EcdhEcdsaServerKeyExchange extends ECDHServerKeyExchange {
 
 	@Override
 	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append(super.toString());
-		if (signatureEncoded != null)
-		sb.append("\t\tSignature: ");
-		sb.append(signatureAndHashAlgorithm.toString()).append("-").append(StringUtil.byteArray2HexString(signatureEncoded, StringUtil.NO_SEPARATOR, 10));
-		sb.append(StringUtil.lineSeparator());
-
-		return sb.toString();
+		String text = super.toString();
+		if (signatureEncoded != null) {
+			StringBuilder sb = new StringBuilder(text);
+			sb.append("\t\tSignature: ");
+			sb.append(signatureAndHashAlgorithm.toString()).append("-")
+					.append(StringUtil.byteArray2HexString(signatureEncoded, StringUtil.NO_SEPARATOR, 10));
+			sb.append(StringUtil.lineSeparator());
+			text = sb.toString();
+		}
+		return text;
 	}
 }
